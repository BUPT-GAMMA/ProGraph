[
    {
        "Section_id": "RectangleDrawer",
        "Description": "Static class which draws rectangular vertices"
    },
    {
        "Field List > Methods > draw_path": {
            "Description": "overrides igraph.drawing.shapes.ShapeDrawer.draw_path\nDraws a rectangle-shaped path on the Cairo context without stroking or filling it.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "ShapeDrawer.draw_path",
            "example": []
        },
        "Section_id": "RectangleDrawer"
    },
    {
        "Field List > Methods > intersection_point": {
            "Description": "overrides igraph.drawing.shapes.ShapeDrawer.intersection_point\nDetermines where the rectangle centered at (center_x, center_y) having the given width and height intersects with a line drawn from (source_x, source_y) to (center_x, center_y).",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "ShapeDrawer.intersection_point",
            "example": []
        },
        "Section_id": "RectangleDrawer"
    },
    {
        "Field List > property": {},
        "Section_id": "RectangleDrawer"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "RectangleDrawer"
    },
    {
        "Section_id": "RainbowPalette",
        "Description": "A palette that varies the hue of the colors along a scale.\nColors in a rainbow palette all have the same saturation, value and alpha components, while the hue is varied between two given extremes linearly. This palette has the advantage that it wraps around nicely if the hue is varied between zero and one (which is the default).\n"
    },
    {
        "Field List > Methods > __init__": {
            "Description": "overrides igraph.drawing.colors.Palette.__init__\nCreates a rainbow palette.",
            "Paramters": {
                "n": "the umber of colors i the palette.",
                "s": "the aturation of the color in the palette.",
                "v": "the alue component of the colors in the palette.",
                "start": "the hue at which the rainbow begins (between 0 and 1).",
                "end": "the hue at which the rainbow s (between 0 and 1).",
                "alpha": "the  component of the colors in the palette."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "RainbowPalette"
    },
    {
        "Field List > Methods > __len__": {
            "Description": "Inherited from Palette:Returns the number of colors in this palette"
        },
        "Section_id": "RainbowPalette"
    },
    {
        "Field List > Methods > __plot__": {
            "Description": "Inherited from Palette:Plots the colors of the palette on the given Cairo context/mpl Axes"
        },
        "Section_id": "RainbowPalette"
    },
    {
        "Field List > Methods > __repr__": {
            "Description": "Inherited from Palette:Undocumented"
        },
        "Section_id": "RainbowPalette"
    },
    {
        "Field List > Methods > clear_cache": {
            "Description": "Inherited from Palette:Clears the result cache."
        },
        "Section_id": "RainbowPalette"
    },
    {
        "Field List > Methods > get": {
            "Description": "Inherited from Palette:Returns the given color from the palette."
        },
        "Section_id": "RainbowPalette"
    },
    {
        "Field List > Methods > get_many": {
            "Description": "Inherited from Palette:Returns multiple colors from the palette."
        },
        "Section_id": "RainbowPalette"
    },
    {
        "Field List > property": {
            "length": "Inherited from Palette:Returns the number of colors in this palette"
        },
        "Section_id": "RainbowPalette"
    },
    {
        "Rubric": {
            "Example": [
                "Example:\n>>> pal = RainbowPalette(n=120)\n>>> pal.get(0)\n(1.0, 0.0, 0.0, 1.0)\n>>> pal.get(20)\n(1.0, 1.0, 0.0, 1.0)\n>>> pal.get(40)\n(0.0, 1.0, 0.0, 1.0)\n>>> pal = RainbowPalette(n=120, s=1, v=0.5, alpha=0.75)\n>>> pal.get(60)\n(0.0, 0.5, 0.5, 0.75)\n>>> pal.get(80)\n(0.0, 0.0, 0.5, 0.75)\n>>> pal.get(100)\n(0.5, 0.0, 0.5, 0.75)\n>>> pal = RainbowPalette(n=120)\n>>> pal2 = RainbowPalette(n=120, start=0.5, end=0.5)\n>>> pal.get(60) == pal2.get(0)\nTrue\n>>> pal.get(90) == pal2.get(30)\nTrue\n"
            ]
        },
        "Section_id": "RainbowPalette"
    },
    {
        "Section_id": "mpl",
        "Description": "Undocumented"
    },
    {
        "Section_id": "plt",
        "Description": "Undocumented"
    },
    {
        "Section_id": "EdgeSeq",
        "Description": "Class representing a sequence of edges in the graph.\nThis class is most easily accessed by the es field of the Graph object, which returns an ordered sequence of all edges in the graph. The edge sequence can be refined by invoking the EdgeSeq.select() method. EdgeSeq.select() can also be accessed by simply calling the EdgeSeq object.\n"
    },
    {
        "Field List > Methods > __call__": {
            "Description": "Shorthand notation to select()\nThis method simply passes all its arguments to EdgeSeq.select().",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "EdgeSeq"
    },
    {
        "Field List > Methods > attributes": {
            "Description": "Returns the list of all the edge attributes in the graph associated to this edge sequence.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "EdgeSeq"
    },
    {
        "Field List > Methods > find": {
            "Description": "overrides igraph._igraph.EdgeSeq.find\nReturns the first edge of the edge sequence that matches some criteria.\nThe selection criteria are equal to the ones allowed by VertexSeq.select. See VertexSeq.select for more details.\nFor instance, to find the first edge with weight larger than 5 in graph g:",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": [
                "For instance, to find the first edge with weight larger than 5 in graph g:\n>>> g.es.find(weight_gt=5)           #doctest:+SKIP"
            ]
        },
        "Section_id": "EdgeSeq"
    },
    {
        "Field List > Methods > select": {
            "Description": "overrides igraph._igraph.EdgeSeq.select\nSelects a subset of the edge sequence based on some criteria\nThe selection criteria can be specified by the positional and the keyword arguments. Positional arguments are always processed before keyword arguments.If the first positional argument is None, an empty sequence is returned.If the first positional argument is a callable object, the object will be called for every edge in the sequence. If it returns True, the edge will be included, otherwise it will be excluded.If the first positional argument is an iterable, it must return integers and they will be considered as indices of the current edge set (NOT the whole edge set of the graph -- the difference matters when one filters an edge set that has already been filtered by a previous invocation of EdgeSeq.select(). In this case, the indices do not refer directly to the edges of the graph but to the elements of the filtered edge sequence.If the first positional argument is an integer, all remaining arguments are expected to be integers. They are considered as indices of the current edge set again.\nKeyword arguments can be used to filter the edges based on their attributes and properties. The name of the keyword specifies the name of the attribute and the filtering operator, they should be concatenated by an underscore (_) character. Attribute names can also contain underscores, but operator names don't, so the operator is always the largest trailing substring of the keyword name that does not contain an underscore. Possible operators are:eq: equal tone: not equal tolt: less thangt: greater thanle: less than or equal toge: greater than or equal toin: checks if the value of an attribute is in a given listnotin: checks if the value of an attribute is not in a given list\nFor instance, if you want to filter edges with a numeric weight property larger than 50, you have to write:",
            "Paramters": {},
            "Return": [
                "the new, filtered edge sequence"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": [
                "For instance, if you want to filter edges with a numeric weight property larger than 50, you have to write:\n>>> g.es.select(weight_gt=50)            #doctest: +SKIP",
                "Similarly, to filter edges whose type is in a list of predefined types:\n>>> g.es.select(weight_gt=50)            #doctest: +SKIP",
                "If the operator is omitted, it defaults to eq. For instance, the following selector selects edges whose type property is intracluster:\n>>> g.es.select(weight_gt=50)            #doctest: +SKIP",
                "For instance, if you want to exclude edges with a betweenness centrality less than 2:\n>>> g.es.select(weight_gt=50)            #doctest: +SKIP",
                "To select edges originating from vertices 2 and 4:\n>>> g.es.select(weight_gt=50)            #doctest: +SKIP",
                "To select edges lying entirely within the subgraph spanned by vertices 2, 3, 4 and 7:\n>>> g.es.select(weight_gt=50)            #doctest: +SKIP",
                "To select edges with one endpoint in the vertex set containing vertices 2, 3, 4 and 7 and the other endpoint in the vertex set containing vertices 8 and 9:\n>>> g.es.select(weight_gt=50)            #doctest: +SKIP",
                "For properties that take a long time to be computed (e.g., betweenness centrality for large graphs), it is advised to calculate the values in advance and store it in a graph attribute. The same applies when you are selecting based on the same property more than once in the same select() call to avoid calculating it twice unnecessarily. For instance, the following would calculate betweenness centralities twice:\n>>> g.es.select(weight_gt=50)            #doctest: +SKIP",
                "It is advised to use this instead:\n>>> g.es.select(weight_gt=50)            #doctest: +SKIP"
            ]
        },
        "Section_id": "EdgeSeq"
    },
    {
        "Field List > Methods > attribute_names": {
            "Description": "Inherited from EdgeSeq:Returns the attribute name list of the graph's edges"
        },
        "Section_id": "EdgeSeq"
    },
    {
        "Field List > Methods > get_attribute_values": {
            "Description": "Inherited from EdgeSeq:Returns the value of a given edge attribute for all edges."
        },
        "Section_id": "EdgeSeq"
    },
    {
        "Field List > Methods > is_all": {
            "Description": "Inherited from EdgeSeq:Returns whether the edge sequence contains all the edges exactly once, in the order of their edge IDs."
        },
        "Section_id": "EdgeSeq"
    },
    {
        "Field List > Methods > set_attribute_values": {
            "Description": "Inherited from EdgeSeq:Sets the value of a given edge attribute for all vertices"
        },
        "Section_id": "EdgeSeq"
    },
    {
        "Field List > property": {},
        "Section_id": "EdgeSeq"
    },
    {
        "Rubric": {
            "Example": [
                "An alternative way to create an edge sequence referring to a given graph is to use the constructor directly:\n>>> g = Graph.Full(3)\n>>> es = EdgeSeq(g)\n>>> restricted_es = EdgeSeq(g, [0, 1])",
                "The individual edges can be accessed by indexing the edge sequence object. It can be used as an iterable as well, or even in a list comprehension:\n>>> g = Graph.Full(3)\n>>> es = EdgeSeq(g)\n>>> restricted_es = EdgeSeq(g, [0, 1])",
                "The edge sequence can also be used as a dictionary where the keys are the attribute names. The values corresponding to the keys are the values of the given attribute of every edge in the graph:\n>>> g = Graph.Full(3)\n>>> es = EdgeSeq(g)\n>>> restricted_es = EdgeSeq(g, [0, 1])",
                "If you specify a sequence that is shorter than the number of edges in the EdgeSeq, the sequence is reused:\n>>> g = Graph.Full(3)\n>>> es = EdgeSeq(g)\n>>> restricted_es = EdgeSeq(g, [0, 1])",
                "You can even pass a single string or integer, it will be considered as a sequence of length 1:\n>>> g = Graph.Full(3)\n>>> es = EdgeSeq(g)\n>>> restricted_es = EdgeSeq(g, [0, 1])",
                "Some methods of the edge sequences are simply proxy methods to the corresponding methods in the Graph object. One such example is EdgeSeq.is_multiple():\n>>> g = Graph.Full(3)\n>>> es = EdgeSeq(g)\n>>> restricted_es = EdgeSeq(g, [0, 1])"
            ]
        },
        "Section_id": "EdgeSeq"
    },
    {
        "Section_id": "AttributeSpecification",
        "Description": "Class that describes how the value of a given attribute should be retrieved.\nThe class contains the following members: name: the name of the attribute. This is also used when we are trying to get its value from a vertex/edge attribute of a graph. alt_name: alternative name of the attribute. This is used when we are trying to get its value from a Python dict or an igraph.Configuration object. If omitted at construction time, it will be equal to name. default: the default value of the attribute when none of the sources we try can provide a meaningful value. transform: optional transformation to be performed on the attribute value. If None or omitted, it defaults to the type of the default value. func: when given, this function will be called with an index in order to derive the value of the attribute. "
    },
    {
        "Field List > Methods > __init__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "AttributeSpecification"
    },
    {
        "Field List > property": {},
        "Section_id": "AttributeSpecification"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "AttributeSpecification"
    },
    {
        "Section_id": "MatplotlibDendrogramDrawer",
        "Description": "Matplotlib drawer object for dendrograms."
    },
    {
        "Field List > Methods > __init__": {
            "Description": "Constructs the drawer and associates it to the given Axes.",
            "Paramters": {
                "ax": "the Axes on which we will draw"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "MatplotlibDendrogramDrawer"
    },
    {
        "Field List > Methods > draw": {
            "Description": "overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nDraws the given Dendrogram in a matplotlib Axes.\nOther keyword arguments are passed to mpl.patches.Polygon.",
            "Paramters": {
                "dendro": "the igraph.Dendrogram to plot.",
                "orientation": "the direction of the plot. Accepted values are \"lr\" (root on the right), \"rl\" (root on the left), \"tb\" (root at the bottom), and \"bt\" (root at the top). A few aliases are available (see utils.str_to_).",
                "**kwds": "Undocumented"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "MatplotlibDendrogramDrawer"
    },
    {
        "Field List > property": {},
        "Section_id": "MatplotlibDendrogramDrawer"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "MatplotlibDendrogramDrawer"
    },
    {
        "Section_id": "DrawerDirectory",
        "Description": "Static class that finds the object/backend drawer\nThis directory is used by the __plot__ functions."
    },
    {
        "Field List > Methods > resolve": {
            "Description": "Given a shape name, returns the corresponding shape drawer class",
            "Paramters": {
                "cls": "the class to resolve",
                "obj": "an instance of the ect to plot",
                "backend": "the name of the "
            },
            "Return": [
                "the corresponding shape drawer class"
            ],
            "References": [],
            "Rasises": {
                "ValueError": "if no drawer is available for this backend/object"
            },
            "See Also": "",
            "example": []
        },
        "Section_id": "DrawerDirectory"
    },
    {
        "Field List > property": {},
        "Section_id": "DrawerDirectory"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "DrawerDirectory"
    },
    {
        "Section_id": "mpl",
        "Description": "Undocumented"
    },
    {
        "Section_id": "plt",
        "Description": "Undocumented"
    },
    {
        "Section_id": "summary",
        "Description": "Prints a summary of object o to a given stream\nPositional and keyword arguments not explicitly mentioned here are passed on to the underlying summary() method of the object if it has any."
    },
    {
        "Paramters": {
            "obj": "the ect about which a human-readable summary is requested.",
            "stream": "the  to be used. If None, the standard output will be used.",
            "*args": "Undocumented",
            "**kwds": "Undocumented"
        },
        "Section_id": "summary"
    },
    {
        "Raises": {},
        "Section_id": "summary"
    },
    {
        "Section_id": "summary",
        "See Also": ""
    },
    {
        "Section_id": "AttributeCollectorBase",
        "Description": "Base class for attribute collector subclasses. Classes that inherit this class may use a declarative syntax to specify which vertex or edge attributes they intend to collect. See AttributeCollectorMeta for the details."
    },
    {
        "Field List > Methods > __getitem__": {
            "Description": "Returns the collected attributes of the vertex/edge with the given index.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "AttributeCollectorBase"
    },
    {
        "Field List > Methods > __init__": {
            "Description": "Constructs a new attribute collector that uses the given vertex/edge sequence and the given dict as data sources.",
            "Paramters": {
                "seq": "an igraph.VertexSeq or igraph.EdgeSeq class that will be used as a data source for attributes.",
                "kwds": "a Python dict that will be used to override the attributes collected from seq if necessary."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "AttributeCollectorBase"
    },
    {
        "Field List > Methods > __len__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "AttributeCollectorBase"
    },
    {
        "Field List > property": {},
        "Section_id": "AttributeCollectorBase"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "AttributeCollectorBase"
    },
    {
        "Section_id": "mpl",
        "Description": "Undocumented"
    },
    {
        "Section_id": "plt",
        "Description": "Undocumented"
    },
    {
        "Section_id": "MatplotlibHistogramDrawer",
        "Description": "Matplotlib drawer object for matrices."
    },
    {
        "Field List > Methods > __init__": {
            "Description": "Constructs the drawer and associates it to the given Axes.",
            "Paramters": {
                "ax": "the Axes on which we will draw"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "MatplotlibHistogramDrawer"
    },
    {
        "Field List > Methods > draw": {
            "Description": "overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nDraws the given Matrix in a matplotlib Axes.",
            "Paramters": {
                "matrix": "the igraph.Histogram to plot.",
                "**kwds": "Undocumented"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "MatplotlibHistogramDrawer"
    },
    {
        "Field List > property": {},
        "Section_id": "MatplotlibHistogramDrawer"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "MatplotlibHistogramDrawer"
    },
    {
        "Section_id": "mpl",
        "Description": "Undocumented"
    },
    {
        "Section_id": "_",
        "Description": "Undocumented"
    },
    {
        "Section_id": "TriadCensus",
        "Description": "Triad census of a graph.\nThis is a pretty simple class - basically it is a tuple, but it allows the user to refer to its individual items by the following triad names: 003 -- the empty graph 012 -- a graph with a single directed edge (A --> B, C) 102 -- a graph with a single mutual edge (A <-> B, C) 021D -- the binary out-tree (A <-- B --> C) 021U -- the binary in-tree (A --> B <-- C) 021C -- the directed line (A --> B --> C) 111D -- A <-> B <-- C 111U -- A <-> B --> C 030T -- A --> B <-- C, A --> C 030C -- A <-- B <-- C, A --> C 201 -- A <-> B <-> C 120D -- A <-- B --> C, A <-> C 120U -- A --> B <-- C, A <-> C 120C -- A --> B --> C, A <-> C 210C -- A --> B <-> C, A <-> C 300 -- the complete graph (A <-> B <-> C, A <-> C) \nAttribute and item accessors are provided. Due to the syntax of Python, attribute names are not allowed to start with a number, therefore the triad names must be prepended with a lowercase t when accessing them as attributes. This is not necessary with the item accessor syntax.\n"
    },
    {
        "Field List > Methods > __getattr__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "TriadCensus"
    },
    {
        "Field List > Methods > __getitem__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "TriadCensus"
    },
    {
        "Field List > Methods > __repr__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "TriadCensus"
    },
    {
        "Field List > Methods > __str__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "TriadCensus"
    },
    {
        "Field List > property": {},
        "Section_id": "TriadCensus"
    },
    {
        "Rubric": {
            "Example": [
                "Examples:\n>>> from igraph import Graph\n>>> g=Graph.Erdos_Renyi(100, 0.2, directed=True)\n>>> tc=g.triad_census()\n>>> print(tc.t003)                    #doctest:+SKIP\n39864\n>>> print(tc[\"030C\"])                 #doctest:+SKIP\n1206\n"
            ]
        },
        "Section_id": "TriadCensus"
    },
    {
        "Section_id": "ClusterColoringPalette",
        "Description": "A palette suitable for coloring vertices when plotting a clustering.\nThis palette tries to make sure that the colors are easily distinguishable. This is achieved by using a set of base colors and their lighter and darker variants, depending on the number of elements in the palette.\nWhen the desired size of the palette is less than or equal to the number of base colors (denoted by n), only the bsae colors will be used. When the size of the palette is larger than n but less than 2*n, the base colors and their lighter variants will be used. Between 2*n and 3*n, the base colors and their lighter and darker variants will be used. Above 3*n, more darker and lighter variants will be generated, but this makes the individual colors less and less distinguishable."
    },
    {
        "Field List > Methods > __init__": {
            "Description": "overrides igraph.drawing.colors.PrecalculatedPalette.__init__\nCreates the palette backed by the given list. The list must contain RGBA quadruplets or color names, which will be resolved first by color_name_to_rgba(). Anything that is understood by color_name_to_rgba() is OK here.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "ClusterColoringPalette"
    },
    {
        "Field List > property": {},
        "Section_id": "ClusterColoringPalette"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "ClusterColoringPalette"
    },
    {
        "Section_id": "BFSIter",
        "Description": "igraph BFS iterator object"
    },
    {
        "Field List > property": {},
        "Section_id": "BFSIter"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "BFSIter"
    },
    {
        "Section_id": "NullDrawer",
        "Description": "Static drawer class which draws nothing.\nThis class is used for graph vertices with unknown shapes"
    },
    {
        "Field List > Methods > draw_path": {
            "Description": "overrides igraph.drawing.shapes.ShapeDrawer.draw_path\nDraws nothing.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "NullDrawer"
    },
    {
        "Field List > property": {},
        "Section_id": "NullDrawer"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "NullDrawer"
    },
    {
        "Section_id": "plotly",
        "Description": "Undocumented"
    },
    {
        "Section_id": "CairoTextDrawer",
        "Description": "Class that draws text on a Cairo context.\nThis class supports multi-line text unlike the original Cairo text drawing methods."
    },
    {
        "Field List > Methods > __init__": {
            "Description": "overrides igraph.drawing.cairo.base.AbstractCairoDrawer.__init__\nConstructs a new instance that will draw the given text on the given Cairo context.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "CairoTextDrawer"
    },
    {
        "Field List > Methods > draw": {
            "Description": "overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nDraws the text in the current bounding box of the drawer.\nSince the class itself is an instance of AbstractCairoDrawer, it has an attribute named bbox which will be used as a bounding box.",
            "Paramters": {
                "wrap": "whether to allow re-ping of the text if it does not fit within the bounding box horizontally."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "CairoTextDrawer"
    },
    {
        "Field List > Methods > draw_at": {
            "Description": "Draws the text by setting up an appropriate path on the Cairo context and filling it. x and y denote the coordinates where the drawing should start. If they are both None, the current position of the context will be used.\nVertical alignment settings are not taken into account in this method as the text is not drawn within a box.",
            "Paramters": {
                "x": "The X coordinate of the reference point where the layout should start.",
                "y": "The Y coordinate of the reference point where the laout should start.",
                "width": "The  of the box in which the text will be fitted. It matters only when the text is right-aligned or centered. The text will overflow the box if any of the lines is longer than the box  and wrap is False.",
                "wrap": "whether to allow re-ping of the text if it does not fit within the given width."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "CairoTextDrawer"
    },
    {
        "Field List > Methods > get_text_layout": {
            "Description": "Calculates the layout of the current text. x and y denote the coordinates where the drawing should start. If they are both None, the current position of the context will be used.\nVertical alignment settings are not taken into account in this method as the text is not drawn within a box.",
            "Paramters": {
                "x": "The X coordinate of the reference point where the layout should start.",
                "y": "The Y coordinate of the reference point where the laout should start.",
                "width": "The  of the box in which the text will be fitted. It matters only when the text is right-aligned or centered. The text will overflow the box if any of the lines is longer than the box  and wrap is False.",
                "wrap": "whether to allow re-ping of the text if it does not fit within the given width."
            },
            "Return": [
                "a list consisting of (x, y, line) tuples where x and y refer to reference points on the Cairo canvas and line refers to the corresponding text that should be plotted there."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "CairoTextDrawer"
    },
    {
        "Field List > Methods > text": {
            "Description": "Sets the text that will be drawn.\nIf text is None, it will be mapped to an empty string; otherwise, it will be converted to a string.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "CairoTextDrawer"
    },
    {
        "Field List > Methods > text_extents": {
            "Description": "Returns the X-bearing, Y-bearing, width, height, X-advance and Y-advance of the text.\nFor multi-line text, the X-bearing and Y-bearing correspond to the first line, while the X-advance is extracted from the last line. and the Y-advance is the sum of all the Y-advances. The width and height correspond to the entire bounding box of the text.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "CairoTextDrawer"
    },
    {
        "Field List > Methods > bbox.setter": {
            "Description": "Inherited from AbstractCairoDrawer:Sets the bounding box of the drawing area where this drawer will draw."
        },
        "Section_id": "CairoTextDrawer"
    },
    {
        "Field List > property": {
            "text": "Returns the text to be drawn.\n",
            "bbox": "Inherited from AbstractCairoDrawer:The bounding box of the drawing area where this drawer will draw."
        },
        "Section_id": "CairoTextDrawer"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "CairoTextDrawer"
    },
    {
        "Section_id": "AbstractCairoVertexDrawer",
        "Description": "Abstract base class for vertex drawers that draw on a Cairo canvas."
    },
    {
        "Field List > Methods > __init__": {
            "Description": "overrides igraph.drawing.baseclasses.AbstractVertexDrawer.__init__\nConstructs the vertex drawer and associates it to the given Cairo context and the given BoundingBox.",
            "Paramters": {
                "context": "the  on which we will draw",
                "bbox": "the bounding box within which we will draw. Can be anything accepted by the constructor of BoundingBox (i.e., a 2-tuple, a 4-tuple or a BoundingBox object).",
                "palette": "the  that can be used to map integer color indices to colors when drawing vertices",
                "layout": "the  of the vertices in the graph being drawn"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "AbstractCairoVertexDrawer"
    },
    {
        "Field List > Methods > draw": {
            "Description": "Inherited from AbstractVertexDrawer:Draws the given vertex."
        },
        "Section_id": "AbstractCairoVertexDrawer"
    },
    {
        "Field List > property": {},
        "Section_id": "AbstractCairoVertexDrawer"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "AbstractCairoVertexDrawer"
    },
    {
        "Section_id": "GraphBase",
        "Description": "Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead."
    },
    {
        "Field List > Methods > __new__": {
            "Description": "Create and return a new object.  See help(type) for accurate signature.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > add_edges": {
            "Description": "overridden in igraph.Graph\nAdds edges to the graph.",
            "Paramters": {
                "es": "the list of edg to be added. Every edge is reprented with a tuple, containing the vertex IDs of the two endpoints. Vertic are enumerated from zero."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > add_vertices": {
            "Description": "overridden in igraph.Graph\nAdds vertices to the graph.",
            "Paramters": {
                "n": "the umber of vertices to be added"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > Adjacency": {
            "Description": "overridden in igraph.Graph\nGenerates a graph from its adjacency matrix.",
            "Paramters": {
                "matrix": "the adjacency ",
                "mode": "the  to be used. Possible values are:\"directed\" - the graph will be directed and a matrix element specifies the number of edges between two vertices.\"undirected\" - the graph will be undirected and a matrix element specifies the number of edges between two vertices. The input matrix must be symmetric.\"max\"   - undirected graph will be created and the number of edges between vertex i and j is max(A(i,\u2009j),\u2009A(j,\u2009i))\"min\"   - like \"max\", but with min(A(i,\u2009j),\u2009A(j,\u2009i))\"plus\"  - like \"max\", but with A(i,\u2009j)\u2009+\u2009A(j,\u2009i)\"upper\" - undirected graph with the upper right triangle of the matrix (including the diagonal)\"lower\" - undirected graph with the lower left triangle of the matrix (including the diagonal)",
                "loops": "specifies how the diagonal of the matrix should be handled:\"ignore\" - ignore loop edges in the diagonal\"once\" - treat the diagonal entries as loop edge counts\"twice\" - treat the diagonal entries as twice the number of loop edges"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > all_minimal_st_separators": {
            "Description": "Returns a list containing all the minimal s-t separators of a graph.\nA minimal separator is a set of vertices whose removal disconnects the graph, while the removal of any subset of the set keeps the graph connected.\nReference: Anne Berry, Jean-Paul Bordat and Olivier Cogis: Generating all the minimal separators of a graph. In: Peter Widmayer, Gabriele Neyer and Stephan Eidenbenz (eds.): Graph-theoretic concepts in computer science, 1665, 167-172, 1999. Springer.",
            "Paramters": {},
            "Return": [
                "a list where each item lists the vertex indices of a given minimal s-t separator."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > all_st_cuts": {
            "Description": "overridden in igraph.Graph\nReturns all the cuts between the source and target vertices in a directed graph.\nThis function lists all edge-cuts between a source and a target vertex. Every cut is listed exactly once.\nAttention: this function has a more convenient interface in class Graph, which wraps the result in a list of Cut objects. It is advised to use that.",
            "Paramters": {
                "source": "the  vertex ID",
                "target": "the  vertex ID"
            },
            "Return": [
                "a tuple where the first element is a list of lists of edge IDs representing a cut and the second element is a list of lists of vertex IDs representing the sets of vertices that were separated by the cuts."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > all_st_mincuts": {
            "Description": "overridden in igraph.Graph\nReturns all minimum cuts between the source and target vertices in a directed graph.\nAttention: this function has a more convenient interface in class Graph, which wraps the result in a list of Cut objects. It is advised to use that.",
            "Paramters": {
                "source": "the  vertex ID",
                "target": "the  vertex ID"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > are_connected": {
            "Description": "Decides whether two given vertices are directly connected.",
            "Paramters": {
                "v1": "the ID or name of the first vertex",
                "v2": "the ID or name of the second vertex"
            },
            "Return": [
                "True if there exists an edge from v1 to v2, False otherwise."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > articulation_points": {
            "Description": "Returns the list of articulation points in the graph.\nA vertex is an articulation point if its removal increases the number of connected components in the graph.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > assortativity": {
            "Description": "Returns the assortativity of the graph based on numeric properties of the vertices.\nThis coefficient is basically the correlation between the actual connectivity patterns of the vertices and the pattern expected from the distribution of the vertex types.\nSee equation (21) in Newman MEJ: Mixing patterns in networks, Phys Rev E 67:026126 (2003) for the proper definition. The actual calculation is performed using equation (26) in the same paper for directed graphs, and equation (4) in Newman MEJ: Assortative mixing in networks, Phys Rev Lett 89:208701 (2002) for undirected graphs.\n",
            "Paramters": {
                "types1": "vertex types in a list or the name of a vertex attribute holding vertex types. Types are ideally denoted by numeric values.",
                "types2": "in directed assortativity calculations, each vertex can have an out-type and an in-type. In this case, types1 contains the out-types and this parameter contains the in-types in a list or the name of a vertex attribute. If None, it is assumed to be equal to types1.",
                "directed": "whether to consider edge directions or not.",
                "normalized": "whether to compute the  covariance, i.e. Pearson correlation. Supply True here to compute the standard assortativity."
            },
            "Return": [
                "the assortativity coefficient"
            ],
            "References": [
                "Newman MEJ: Mixing patterns in networks, Phys Rev E 67:026126, 2003.Newman MEJ: Assortative mixing in networks, Phys Rev Lett 89:208701, 2002."
            ],
            "Rasises": {},
            "See Also": "assortativity_degree() when the types are the vertex degrees",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > assortativity_degree": {
            "Description": "Returns the assortativity of a graph based on vertex degrees.\nSee assortativity() for the details. assortativity_degree() simply calls assortativity() with the vertex degrees as types.",
            "Paramters": {
                "directed": "whether to consider edge directions for  graphs or not. This argument is ignored for un graphs."
            },
            "Return": [
                "the assortativity coefficient"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "assortativity()",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > assortativity_nominal": {
            "Description": "Returns the assortativity of the graph based on vertex categories.\nAssuming that the vertices belong to different categories, this function calculates the assortativity coefficient, which specifies the extent to which the connections stay within categories. The assortativity coefficient is one if all the connections stay within categories and minus one if all the connections join vertices of different categories. For a randomly connected network, it is asymptotically zero.\nSee equation (2) in Newman MEJ: Mixing patterns in networks, Phys Rev E 67:026126 (2003) for the proper definition.\nReference: Newman MEJ: Mixing patterns in networks, Phys Rev E 67:026126, 2003.",
            "Paramters": {
                "types": "vertex  in a list or the name of a vertex attribute holding vertex . Types should be denoted by numeric values.",
                "directed": "whether to consider edge directions or not.",
                "normalized": "whether to compute the (usual)  assortativity. The un version is identical to modularity. Supply True here to compute the standard assortativity."
            },
            "Return": [
                "the assortativity coefficient"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > Asymmetric_Preference": {
            "Description": "Generates a graph based on asymmetric vertex types and connection probabilities.\nThis is the asymmetric variant of Preference(). A given number of vertices are generated. Every vertex is assigned to an \"incoming\" and an \"outgoing\" vertex type according to the given joint type probabilities. Finally, every vertex pair is evaluated and a directed edge is created between them with a probability depending on the \"outgoing\" type of the source vertex and the \"incoming\" type of the target vertex.",
            "Paramters": {
                "n": "the umber of vertices i the graph",
                "type_dist_matrix": "matrix giving the joint distribution of vertex types",
                "pref_matrix": "matrix giving the connection probabilities for different vertex types.",
                "attribute": "the vertex  name used to store the vertex types. If None, vertex types are not stored.",
                "loops": "whether loop edges are allowed."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > Atlas": {
            "Description": "Generates a graph from the Graph Atlas.\nReference: Ronald C. Read and Robin J. Wilson: An Atlas of Graphs. Oxford University Press, 1998.",
            "Paramters": {
                "idx": "The index of the graph to be generated. Indices start from zero, graphs are listed:in increasing order of number of vertices;for a fixed number of vertices, in increasing order of the number of edges;for fixed numbers of vertices and edges, in increasing order of the degree sequence, for example 111223 < 112222;for fixed degree sequence, in increasing number of automorphisms."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > attributes": {
            "Description": "",
            "Paramters": {},
            "Return": [
                "the attribute name list of the graph"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > authority_score": {
            "Description": "Calculates Kleinberg's authority score for the vertices of the graph",
            "Paramters": {
                "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name.",
                "scale": "whether to normalize the scores so that the largest one is 1.",
                "arpack_options": "an ARPACKOptions object used to fine-tune the ARPACK eigenvector calculation. If omitted, the module-level variable called  is used.",
                "return_eigenvalue": "whether to return the largest eigenvalue"
            },
            "Return": [
                "the authority scores in a list and optionally the largest eigenvalue as a second member of a tuple"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "hub_score()",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > automorphism_group": {
            "Description": "Calculates the generators of the automorphism group of a graph using the BLISS isomorphism algorithm.\nThe generator set may not be minimal and may depend on the splitting heuristics. The generators are permutations represented using zero-based indexing.",
            "Paramters": {
                "sh": "splitting heuristics for graph as a case-insensitive string, with the following possible values:\"f\": first non-singleton cell\"fl\": first largest non-singleton cell\"fs\": first smallest non-singleton cell\"fm\": first maximally non-trivially connected non-singleton cell\"flm\": largest maximally non-trivially connected non-singleton cell\"fsm\": smallest maximally non-trivially connected non-singleton cell",
                "color": "optional vector storing a ing of the vertices with respect to which the isomorphism is computed.  If None, all vertices have the same ."
            },
            "Return": [
                "a list of integer vectors, each vector representing an automorphism group of the graph."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > average_path_length": {
            "Description": "Calculates the average path length in a graph.",
            "Paramters": {
                "directed": "whether to consider  paths in case of a  graph. Ignored for un graphs.",
                "unconn": "what to do when the graph is ected. If True, the average of the geodesic lengths in the components is calculated. Otherwise for all ected vertex pairs, a path length equal to the number of vertices is used.",
                "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name."
            },
            "Return": [
                "the average path length in the graph"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > Barabasi": {
            "Description": "Generates a graph based on the Barab\u00e1si-Albert model.\nReference: Barab\u00e1si, A-L and Albert, R. 1999. Emergence of scaling in random networks. Science, 286 509-512.",
            "Paramters": {
                "n": "the umber of vertices",
                "m": "either the nuber of outgoing edges generated for each vertex or a list containing the nuber of outgoing edges for each vertex explicitly.",
                "outpref": "True if the out-degree of a given vertex should also increase its citation probability (as well as its in-degree), but it defaults to False.",
                "directed": "True if the generated graph should be  (default: False).",
                "power": "the  constant of the nonlinear model. It can be omitted, and in this case the usual linear model will be used.",
                "zero_appeal": "the attractivity of vertices with degree zero.",
                "implementation": "the algorithm to use to generate the network. Possible values are:\"bag\": the algorithm that was the default in igraph before 0.6. It works by putting the ids of the vertices into a bag (multiset) exactly as many times as their in-degree, plus once more. The required number of cited vertices are then drawn from the bag with replacement. It works only for power=1 and zero_appeal=1.\"psumtree\": this algorithm uses a partial prefix-sum tree to generate the graph. It does not generate multiple edges and it works for any values of power and zero_appeal.\"psumtree_multiple\": similar to \"psumtree\", but it will generate multiple edges as well. igraph before 0.6 used this algorithm for powers other than 1.",
                "start_from": "if given and not None, this must be another GraphBase object. igraph will use this graph as a starting point for the preferential attachment model."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > betweenness": {
            "Description": "Calculates or estimates the betweenness of vertices in a graph.\nAlso supports calculating betweenness with shortest path length cutoffs or considering shortest paths only from certain source vertices or to certain target vertices.\nKeyword arguments:",
            "Paramters": {
                "vertices": "the  for which the betweennesses must be returned. If None, assumes all of the  in the graph.",
                "directed": "whether to consider  paths.",
                "cutoff": "if it is an integer, only paths less than or equal to this length are considered, effectively resulting in an estimation of the betweenness for the given vertices. If None, the exact betweenness is returned.",
                "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name.",
                "sources": "the set of source vertices to consider when calculating shortest paths.",
                "targets": "the set of target vertices to consider when calculating shortest paths."
            },
            "Return": [
                "the (possibly cutoff-limited) betweenness of the given vertices in a list"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > bfs": {
            "Description": "Conducts a breadth first search (BFS) on the graph.",
            "Paramters": {
                "vid": "the root vertex ID",
                "mode": "either \"in\" or \"out\" or \"all\", ignored for undirected graphs."
            },
            "Return": [
                "a tuple with the following items:\n\nThe vertex IDs visited (in order)\nThe start indices of the layers in the vertex list\nThe parent of every vertex in the BFS\n\n"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > bfsiter": {
            "Description": "Constructs a breadth first search (BFS) iterator of the graph.",
            "Paramters": {
                "vid": "the root vertex ID",
                "mode": "either \"in\" or \"out\" or \"all\".",
                "advanced": "if False, the iterator returns the next vertex in BFS order in every step. If True, the iterator returns the distance of the vertex from the root and the parent of the vertex in the BFS tree as well."
            },
            "Return": [
                "the BFS iterator as an igraph.BFSIter object."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > bibcoupling": {
            "Description": "Calculates bibliographic coupling scores for given vertices in a graph.",
            "Paramters": {
                "vertices": "the  to be analysed. If None, all  will be considered."
            },
            "Return": [
                "bibliographic coupling scores for all given vertices in a matrix."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > biconnected_components": {
            "Description": "overridden in igraph.Graph\nCalculates the biconnected components of the graph.\nComponents containing a single vertex only are not considered as being biconnected.",
            "Paramters": {
                "return_articulation_points": "whether to return the articulation points as well"
            },
            "Return": [
                "a list of lists containing edge indices making up spanning trees of the biconnected components (one spanning tree for each component) and optionally the list of articulation points"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > bipartite_projection": {
            "Description": "overridden in igraph.Graph\nInternal function, undocumented.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "Graph.bipartite_projection()",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > bipartite_projection_size": {
            "Description": "overridden in igraph.Graph\nInternal function, undocumented.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "Graph.bipartite_projection_size()",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > bridges": {
            "Description": "Returns the list of bridges in the graph.\nAn edge is a bridge if its removal increases the number of (weakly) connected components in the graph.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > canonical_permutation": {
            "Description": "Calculates the canonical permutation of a graph using the BLISS isomorphism algorithm.\nPassing the permutation returned here to permute_vertices() will transform the graph into its canonical form.\nSee http://www.tcs.hut.fi/Software/bliss/index.html for more information about the BLISS algorithm and canonical permutations.",
            "Paramters": {
                "sh": "splitting heuristics for graph as a case-insensitive string, with the following possible values:\"f\": first non-singleton cell\"fl\": first largest non-singleton cell\"fs\": first smallest non-singleton cell\"fm\": first maximally non-trivially connected non-singleton cell\"flm\": largest maximally non-trivially connected non-singleton cell\"fsm\": smallest maximally non-trivially connected non-singleton cell",
                "color": "optional vector storing a ing of the vertices with respect to which the isomorphism is computed.  If None, all vertices have the same ."
            },
            "Return": [
                "a permutation vector containing vertex IDs. Vertex 0 in the original graph will be mapped to an ID contained in the first element of this vector; vertex 1 will be mapped to the second and so on."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > chordal_completion": {
            "Description": "Returns the list of edges needed to be added to the graph to make it chordal.\nA graph is chordal if each of its cycles of four or more nodes has a chord, i.e. an edge joining two nodes that are not adjacent in the cycle. An equivalent definition is that any chordless cycles have at most three nodes.\nThe chordal completion of a graph is the list of edges that needed to be added to the graph to make it chordal. It is an empty list if the graph is already chordal.\nNote that at the moment igraph does not guarantee that the returned chordal completion is minimal; there may exist a subset of the returned chordal completion that is still a valid chordal completion.",
            "Paramters": {
                "alpha": "the  vector from the result of calling maximum_cardinality_search() on the graph. Useful only if you already have the  vector; simply passing None here will make igraph calculate the  vector on its own.",
                "alpham1": "the inverse alpha vector from the result of calling maximum_cardinality_search() on the graph. Useful only if you already have the inverse alpha vector; simply passing None here will make igraph calculate the inverse alpha vector on its own."
            },
            "Return": [
                "the list of edges to add to the graph; each item in the list is a source-target pair of vertex indices."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > clique_number": {
            "Description": "Returns the clique number of the graph.\nThe clique number of the graph is the size of the largest clique.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "largest_cliques() for the largest cliques.",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > cliques": {
            "Description": "Returns some or all cliques of the graph as a list of tuples.\nA clique is a complete subgraph -- a set of vertices where an edge is present between any two of them (excluding loops)",
            "Paramters": {
                "min": "the imum size of cliques to be returned. If zero or negative, no lower bound will be used.",
                "max": "the imum size of cliques to be returned. If zero or negative, no upper bound will be used."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > closeness": {
            "Description": "Calculates the closeness centralities of given vertices in a graph.\nThe closeness centrality of a vertex measures how easily other vertices can be reached from it (or the other way: how easily it can be reached from the other vertices). It is defined as the number of vertices minus one divided by the sum of the lengths of all geodesics from/to the given vertex.\nIf the graph is not connected, and there is no path between two vertices, the number of vertices is used instead the length of the geodesic. This is always longer than the longest possible geodesic.",
            "Paramters": {
                "vertices": "the  for which the closenesses must be returned. If None, uses all of the  in the graph.",
                "mode": "must be one of \"in\", \"out\" and \"all\". \"in\" means that the length of the incoming paths, \"out\" means that the length of the outgoing paths must be calculated. \"all\" means that both of them must be calculated.",
                "cutoff": "if it is an integer, only paths less than or equal to this length are considered, effectively resulting in an estimation of the closeness for the given vertices (which is always an underestimation of the real closeness, since some vertex pairs will appear as disconnected even though they are connected).. If None, the exact closeness is returned.",
                "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name.",
                "normalized": "Whether to normalize the raw closeness scores by multiplying by the number of vertices minus one."
            },
            "Return": [
                "the calculated closenesses in a list"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > cocitation": {
            "Description": "Calculates cocitation scores for given vertices in a graph.",
            "Paramters": {
                "vertices": "the  to be analysed. If None, all  will be considered."
            },
            "Return": [
                "cocitation scores for all given vertices in a matrix."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > cohesive_blocks": {
            "Description": "overridden in igraph.Graph\nCalculates the cohesive block structure of the graph.\nAttention: this function has a more convenient interface in class Graph, which wraps the result in a CohesiveBlocks object. It is advised to use that.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > community_edge_betweenness": {
            "Description": "overridden in igraph.Graph\nCommunity structure detection based on the betweenness of the edges in the network. This algorithm was invented by M Girvan and MEJ Newman, see: M Girvan and MEJ Newman: Community structure in social and biological networks, Proc. Nat. Acad. Sci. USA 99, 7821-7826 (2002).\nThe idea is that the betweenness of the edges connecting two communities is typically high. So we gradually remove the edge with the highest betweenness from the network and recalculate edge betweenness after every removal, as long as all edges are removed.\nAttention: this function is wrapped in a more convenient syntax in the derived class Graph. It is advised to use that instead of this version.",
            "Paramters": {
                "directed": "whether to take into account the ness of the edges when we calculate the betweenness values.",
                "weights": "name of an edge attribute or a list containing edge ."
            },
            "Return": [
                "a tuple with the merge matrix that describes the dendrogram and the modularity scores before each merge. The modularity scores use the weights if the original graph was weighted."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > community_fastgreedy": {
            "Description": "overridden in igraph.Graph\nFinds the community structure of the graph according to the algorithm of Clauset et al based on the greedy optimization of modularity.\nThis is a bottom-up algorithm: initially every vertex belongs to a separate community, and communities are merged one by one. In every step, the two communities being merged are the ones which result in the maximal increase in modularity.\nAttention: this function is wrapped in a more convenient syntax in the derived class Graph. It is advised to use that instead of this version.\nReference: A. Clauset, M. E. J. Newman and C. Moore: Finding community structure in very large networks. Phys Rev E 70, 066111 (2004).",
            "Paramters": {
                "weights": "name of an edge attribute or a list containing edge "
            },
            "Return": [
                "a tuple with the following elements:\n\nThe list of merges\nThe modularity scores before each merge\n\n"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "modularity()",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > community_infomap": {
            "Description": "overridden in igraph.Graph\nFinds the community structure of the network according to the Infomap method of Martin Rosvall and Carl T. Bergstrom.\nSee http://www.mapequation.org for a visualization of the algorithm or one of the references provided below. ",
            "Paramters": {
                "edge_weights": "name of an edge attribute or a list containing edge weights.",
                "vertex_weights": "name of an vertex attribute or a list containing vertex weights.",
                "trials": "the number of attempts to partition the network."
            },
            "Return": [
                "the calculated membership vector and the corresponding codelength in a tuple."
            ],
            "References": [
                "M. Rosvall and C. T. Bergstrom: Maps of information flow reveal community structure in complex networks. PNAS 105, 1118 (2008). http://arxiv.org/abs/0707.0609M. Rosvall, D. Axelsson and C. T. Bergstrom: The map equation. Eur Phys J Special Topics 178, 13 (2009). http://arxiv.org/abs/0906.1405"
            ],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > community_label_propagation": {
            "Description": "overridden in igraph.Graph\nFinds the community structure of the graph according to the label propagation method of Raghavan et al.\nInitially, each vertex is assigned a different label. After that, each vertex chooses the dominant label in its neighbourhood in each iteration. Ties are broken randomly and the order in which the vertices are updated is randomized before every iteration. The algorithm ends when vertices reach a consensus.\nNote that since ties are broken randomly, there is no guarantee that the algorithm returns the same community structure after each run. In fact, they frequently differ. See the paper of Raghavan et al on how to come up with an aggregated community structure.\nReference: Raghavan, U.N. and Albert, R. and Kumara, S. Near linear time algorithm to detect community structures in large-scale networks. Phys Rev E 76:036106, 2007. http://arxiv.org/abs/0709.2938.",
            "Paramters": {
                "weights": "name of an edge attribute or a list containing edge ",
                "initial": "name of a vertex attribute or a list containing the  vertex labels. Labels are identified by integers from zero to n\u2009\u2212\u20091 where n is the number of vertices. Negative numbers may also be present in this vector, they represent unlabeled vertices.",
                "fixed": "a list of booleans for each vertex. True corresponds to vertices whose labeling should not change during the algorithm. It only makes sense if initial labels are also given. Unlabeled vertices cannot be . Note that vertex attribute names are not accepted here."
            },
            "Return": [
                "the resulting membership vector"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > community_leading_eigenvector": {
            "Description": "overridden in igraph.Graph\nA proper implementation of Newman's eigenvector community structure detection. Each split is done by maximizing the modularity regarding the original network. See the reference for details.\nAttention: this function is wrapped in a more convenient syntax in the derived class Graph. It is advised to use that instead of this version.\nReference: MEJ Newman: Finding community structure in networks using the eigenvectors of matrices, arXiv:physics/0605087",
            "Paramters": {
                "n": "the desired umber of commuities. If egative, the algorithm tries to do as may splits as possible. Note that the algorithm wo't split a commuity further if the sigs of the leadig eigevector are all the same.",
                "arpack_options": "an ARPACKOptions object used to fine-tune the ARPACK eigenvector calculation. If omitted, the module-level variable called  is used.",
                "weights": "name of an edge attribute or a list containing edge "
            },
            "Return": [
                "a tuple where the first element is the membership vector of the clustering and the second element is the merge matrix."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > community_leiden": {
            "Description": "overridden in igraph.Graph\nFinds the community structure of the graph using the Leiden algorithm of Traag, van Eck & Waltman.",
            "Paramters": {
                "edge_weights": "edge weights to be used. Can be a sequence or iterable or even an edge attribute name.",
                "node_weights": "the node weights used in the Leiden algorithm.",
                "resolution": "the  parameter to use. Higher s lead to more smaller communities, while lower s lead to fewer larger communities.",
                "normalize_resolution": "if set to true, the resolution parameter will be divided by the sum of the node weights. If this is not supplied, it will default to the node degree, or weighted degree in case edge_weights are supplied.",
                "beta": "parameter affecting the randomness in the Leiden algorithm. This affects only the refinement step of the algorithm.",
                "initial_membership": "if provided, the Leiden algorithm will try to improve this provided membership. If no argument is provided, the aglorithm simply starts from the singleton partition.",
                "n_iterations": "the number of iterations to iterate the Leiden algorithm. Each iteration may improve the partition further. You can also set this parameter to a negative number, which means that the algorithm will be iterated until an iteration does not change the current membership vector any more."
            },
            "Return": [
                "the community membership vector."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > community_multilevel": {
            "Description": "overridden in igraph.Graph\nFinds the community structure of the graph according to the multilevel algorithm of Blondel et al. This is a bottom-up algorithm: initially every vertex belongs to a separate community, and vertices are moved between communities iteratively in a way that maximizes the vertices' local contribution to the overall modularity score. When a consensus is reached (i.e. no single move would increase the modularity score), every community in the original graph is shrank to a single vertex (while keeping the total weight of the incident edges) and the process continues on the next level. The algorithm stops when it is not possible to increase the modularity any more after shrinking the communities to vertices.\nReference: VD Blondel, J-L Guillaume, R Lambiotte and E Lefebvre: Fast unfolding of community hierarchies in large networks. J Stat Mech P10008 (2008), http://arxiv.org/abs/0803.0476\nAttention: this function is wrapped in a more convenient syntax in the derived class Graph. It is advised to use that instead of this version.",
            "Paramters": {
                "weights": "name of an edge attribute or a list containing edge ",
                "return_levels": "if True, returns the multilevel result. If False, only the best level (corresponding to the best modularity) is returned.",
                "resolution": "the  parameter to use in the modularity measure. Smaller values result in a smaller number of larger clusters, while higher values yield a large number of small clusters. The classical modularity measure assumes a  parameter of 1."
            },
            "Return": [
                "either a single list describing the community membership of each vertex (if return_levels is False), or a list of community membership vectors, one corresponding to each level and a list of corresponding modularities (if return_levels is True)."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "modularity()",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > community_optimal_modularity": {
            "Description": "overridden in igraph.Graph\nCalculates the optimal modularity score of the graph and the corresponding community structure.\nThis function uses the GNU Linear Programming Kit to solve a large integer optimization problem in order to find the optimal modularity score and the corresponding community structure, therefore it is unlikely to work for graphs larger than a few (less than a hundred) vertices. Consider using one of the heuristic approaches instead if you have such a large graph.",
            "Paramters": {
                "weights": "name of an edge attribute or a list containing edge ."
            },
            "Return": [
                "the calculated membership vector and the corresponding modularity in a tuple."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > community_spinglass": {
            "Description": "overridden in igraph.Graph\nFinds the community structure of the graph according to the spinglass community detection method of Reichardt & Bornholdt.",
            "Paramters": {
                "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name.",
                "spins": "integer, the number of  to use. This is the upper limit for the number of communities. It is not a problem to supply a (reasonably) big number here, in which case some spin states will be unpopulated.",
                "parupdate": "whether to update the spins of the vertices in parallel (synchronously) or not",
                "start_temp": "the starting temperature",
                "stop_temp": "the stop temperature",
                "cool_fact": "cooling factor for the simulated annealing",
                "update_rule": "specifies the null model of the simulation. Possible values are \"config\" (a random graph with the same vertex degrees as the input graph) or \"simple\" (a random graph with the same number of edges)",
                "gamma": "the  argument of the algorithm, specifying the balance between the importance of present and missing edges within a community. The default value of 1.0 assigns equal importance to both of them.",
                "implementation": "currently igraph contains two s for the spinglass community detection algorithm. The faster original  is the default. The other  is able to take into account negative weights, this can be chosen by setting  to \"neg\".",
                "lambda_": "the lambda argument of the algorithm, which specifies the balance between the importance of present and missing negatively weighted edges within a community. Smaller values of lambda lead to communities with less negative intra-connectivity. If the argument is zero, the algorithm reduces to a graph coloring algorithm, using the number of spins as colors. This argument is ignored if the original implementation is used."
            },
            "Return": [
                "the community membership vector."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > community_walktrap": {
            "Description": "overridden in igraph.Graph\nFinds the community structure of the graph according to the random walk method of Latapy & Pons.\nThe basic idea of the algorithm is that short random walks tend to stay in the same community. The method provides a dendrogram.\nAttention: this function is wrapped in a more convenient syntax in the derived class Graph. It is advised to use that instead of this version.\nReference: Pascal Pons, Matthieu Latapy: Computing communities in large networks using random walks, http://arxiv.org/abs/physics/0512106.",
            "Paramters": {
                "weights": "name of an edge attribute or a list containing edge ",
                "steps": "Undocumented"
            },
            "Return": [
                "a tuple with the list of merges and the modularity scores corresponding to each merge"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "modularity()",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > complementer": {
            "Description": "Returns the complementer of the graph",
            "Paramters": {
                "loops": "whether to include loop edges in the complementer."
            },
            "Return": [
                "the complementer of the graph"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > compose": {
            "Description": "Returns the composition of two graphs.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > connected_components": {
            "Description": "overridden in igraph.Graph\nCalculates the (strong or weak) connected components for a given graph.\nAttention: this function has a more convenient interface in class Graph, which wraps the result in a VertexClustering object. It is advised to use that.",
            "Paramters": {
                "mode": "must be either \"strong\" or \"weak\", depending on the clusters being sought. Optional, defaults to \"strong\"."
            },
            "Return": [
                "the component index for every node in the graph."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > constraint": {
            "Description": "Calculates Burt's constraint scores for given vertices in a graph.\nBurt's constraint is higher if ego has less, or mutually stronger related (i.e. more redundant) contacts. Burt's measure of constraint, C[i], of vertex i's ego network V[i], is defined for directed and valued graphs as follows:\nC[i] = sum( sum( (p[i,q] p[q,j])^2, q in V[i], q != i,j ), j in V[], j != i)\nfor a graph of order (ie. number od vertices) N, where proportional tie strengths are defined as follows:\np[i,j]=(a[i,j]+a[j,i]) / sum(a[i,k]+a[k,i], k in V[i], k != i), a[i,j] are elements of A and the latter being the graph adjacency matrix.\nFor isolated vertices, constraint is undefined.",
            "Paramters": {
                "vertices": "the  to be analysed or None for all .",
                "weights": " associated to the edges. Can be an attribute name as well. If None, every edge will have the same weight."
            },
            "Return": [
                "constraint scores for all given vertices in a matrix."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > contract_vertices": {
            "Description": "Contracts some vertices in the graph, i.e. replaces groups of vertices with single vertices. Edges are not affected.",
            "Paramters": {
                "mapping": "numeric vector which gives the  between old and new vertex IDs. Vertices having the same new vertex ID in this vector will be remapped into a single new vertex. It is safe to pass the membership vector of a VertexClustering object here.",
                "combine_attrs": "specifies how to combine the attributes of the vertices being collapsed into a single one. If it is None, all the attributes will be lost. If it is a function, the attributes of the vertices will be collected and passed on to that function which will return the new attribute value that has to be assigned to the single collapsed vertex. It can also be one of the following string constants which define built-in collapsing functions: sum, prod, mean, median, max, min, first, last, random. You can also specify different combination functions for different attributes by passing a dict here which maps attribute names to functions. See simplify() for more details."
            },
            "Return": [
                "None."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "simplify()",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > convergence_degree": {
            "Description": "Undocumented (yet).",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > convergence_field_size": {
            "Description": "Undocumented (yet).",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > copy": {
            "Description": "Creates a copy of the graph.\nAttributes are copied by reference; in other words, if you use mutable Python objects as attribute values, these objects will still be shared between the old and new graph. You can use `deepcopy()` from the `copy` module if you need a truly deep copy of the graph.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > coreness": {
            "Description": "Finds the coreness (shell index) of the vertices of the network.\nThe k-core of a graph is a maximal subgraph in which each vertex has at least degree k. (Degree here means the degree in the subgraph of course). The coreness of a vertex is k if it is a member of the k-core but not a member of the k\u2009+\u20091-core.\nReference: Vladimir Batagelj, Matjaz Zaversnik: An O(m) Algorithm for Core Decomposition of Networks.",
            "Paramters": {
                "mode": "whether to compute the in-corenesses (\"in\"), the out-corenesses (\"out\") or the undirected corenesses (\"all\"). Ignored and assumed to be \"all\" for undirected graphs."
            },
            "Return": [
                "the corenesses for each vertex."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > count_automorphisms": {
            "Description": "Calculates the number of automorphisms of a graph using the BLISS isomorphism algorithm.\nSee http://www.tcs.hut.fi/Software/bliss/index.html for more information about the BLISS algorithm and canonical permutations.",
            "Paramters": {
                "sh": "splitting heuristics for graph as a case-insensitive string, with the following possible values:\"f\": first non-singleton cell\"fl\": first largest non-singleton cell\"fs\": first smallest non-singleton cell\"fm\": first maximally non-trivially connected non-singleton cell\"flm\": largest maximally non-trivially connected non-singleton cell\"fsm\": smallest maximally non-trivially connected non-singleton cell",
                "color": "optional vector storing a ing of the vertices with respect to which the isomorphism is computed.  If None, all vertices have the same ."
            },
            "Return": [
                "the number of automorphisms of the graph."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > count_isomorphisms_vf2": {
            "Description": "Determines the number of isomorphisms between the graph and another one\nVertex and edge colors may be used to restrict the isomorphisms, as only vertices and edges with the same color will be allowed to match each other.",
            "Paramters": {
                "other": "the  graph. If None, the number of automorphisms will be returned.",
                "color1": "optional vector storing the coloring of the vertices of the first graph. If None, all vertices have the same color.",
                "color2": "optional vector storing the coloring of the vertices of the second graph. If None, all vertices have the same color.",
                "edge_color1": "optional vector storing the coloring of the edges of the first graph. If None, all edges have the same color.",
                "edge_color2": "optional vector storing the coloring of the edges of the second graph. If None, all edges have the same color.",
                "node_compat_fn": "a function that receives the two graphs and two node indices (one from the first graph, one from the second graph) and returns True if the nodes given by the two indices are compatible (i.e. they could be matched to each other) or False otherwise. This can be used to restrict the set of isomorphisms based on node-specific criteria that are too complicated to be represented by node color vectors (i.e. the color1 and color2 parameters). None means that every node is compatible with every other node.",
                "edge_compat_fn": "a function that receives the two graphs and two edge indices (one from the first graph, one from the second graph) and returns True if the edges given by the two indices are compatible (i.e. they could be matched to each other) or False otherwise. This can be used to restrict the set of isomorphisms based on edge-specific criteria that are too complicated to be represented by edge color vectors (i.e. the edge_color1 and edge_color2 parameters). None means that every edge is compatible with every other node."
            },
            "Return": [
                "the number of isomorphisms between the two given graphs (or the number of automorphisms if other is None."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > count_multiple": {
            "Description": "Counts the multiplicities of the given edges.",
            "Paramters": {
                "edges": "edge indices for which we want to count their multiplicity. If None, all  are counted."
            },
            "Return": [
                "the multiplicities of the given edges as a list."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > count_subisomorphisms_vf2": {
            "Description": "Determines the number of subisomorphisms between the graph and another one\nVertex and edge colors may be used to restrict the isomorphisms, as only vertices and edges with the same color will be allowed to match each other.",
            "Paramters": {
                "other": "the  graph.",
                "color1": "optional vector storing the coloring of the vertices of the first graph. If None, all vertices have the same color.",
                "color2": "optional vector storing the coloring of the vertices of the second graph. If None, all vertices have the same color.",
                "edge_color1": "optional vector storing the coloring of the edges of the first graph. If None, all edges have the same color.",
                "edge_color2": "optional vector storing the coloring of the edges of the second graph. If None, all edges have the same color.",
                "node_compat_fn": "a function that receives the two graphs and two node indices (one from the first graph, one from the second graph) and returns True if the nodes given by the two indices are compatible (i.e. they could be matched to each other) or False otherwise. This can be used to restrict the set of isomorphisms based on node-specific criteria that are too complicated to be represented by node color vectors (i.e. the color1 and color2 parameters). None means that every node is compatible with every other node.",
                "edge_compat_fn": "a function that receives the two graphs and two edge indices (one from the first graph, one from the second graph) and returns True if the edges given by the two indices are compatible (i.e. they could be matched to each other) or False otherwise. This can be used to restrict the set of isomorphisms based on edge-specific criteria that are too complicated to be represented by edge color vectors (i.e. the edge_color1 and edge_color2 parameters). None means that every edge is compatible with every other node."
            },
            "Return": [
                "the number of subisomorphisms between the two given graphs"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > De_Bruijn": {
            "Description": "Generates a de Bruijn graph with parameters (m, n)\nA de Bruijn graph represents relationships between strings. An alphabet of m letters are used and strings of length n are considered. A vertex corresponds to every possible string and there is a directed edge from vertex v to vertex w if the string of v can be transformed into the string of w by removing its first letter and appending a letter to it.\nPlease note that the graph will have mn vertices and even more edges, so probably you don't want to supply too big numbers for m and n.",
            "Paramters": {
                "m": "the size of the alphabet",
                "n": "the legth of the strigs"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > decompose": {
            "Description": "Decomposes the graph into subgraphs.",
            "Paramters": {
                "mode": "must be either \"strong\" or \"weak\", depending on the clusters being sought. Optional, defaults to \"strong\".",
                "maxcompno": "maximum number of components to return. None means all possible components.",
                "minelements": "minimum number of vertices in a component. By setting this to 2, isolated vertices are not returned as separate components."
            },
            "Return": [
                "a list of the subgraphs. Every returned subgraph is a copy of the original."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > degree": {
            "Description": "Returns some vertex degrees from the graph.\nThis method accepts a single vertex ID or a list of vertex IDs as a parameter, and returns the degree of the given vertices (in the form of a single integer or a list, depending on the input parameter).",
            "Paramters": {
                "vertices": "a single vertex ID or a list of vertex IDs",
                "mode": "the type of degree to be returned (\"out\" for out-degrees, \"in\" for in-degrees or \"all\" for the sum of them).",
                "loops": "whether self- should be counted."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > Degree_Sequence": {
            "Description": "Generates a graph with a given degree sequence.",
            "Paramters": {
                "out": "the -degree sequence for a directed graph. If the in-degree sequence is omitted, the generated graph will be undirected, so this will be the in-degree sequence as well",
                "in_": "the in-degree sequence for a directed graph. If omitted, the generated graph will be undirected.",
                "method": "the generation  to be used. One of the following:\"configuration\" -- simple generator that implements the stub-matching configuration model. It may generate self-loops and multiple edges. This  does not sample multigraphs uniformly, but it can be used to implement uniform sampling for simple graphs by rejecting any result that is non-simple (i.e. contains loops or multi-edges).\"fast_heur_simple\" -- similar to \"configuration\" but avoids the generation of multiple and loop edges at the expense of increased time complexity. The  will re-start the generation every time it gets stuck in a configuration where it is not possible to insert any more edges without creating loops or multiple edges, and there is no upper bound on the number of iterations, but it will succeed eventually if the input degree sequence is graphical and throw an exception if the input degree sequence is not graphical. This  does not sample simple graphs uniformly.\"configuration_simple\" -- similar to \"configuration\" but rejects generated graphs if they are not simple. This  samples simple graphs uniformly.\"edge_switching_simple\" -- an MCMC sampler based on degree-preserving edge switches. It generates simple undirected or directed graphs. The algorithm uses Graph.Realize_Degree_Sequence() to construct an initial graph, then rewires it using Graph.rewire().\"vl\" -- a more sophisticated generator that can sample undirected, connected simple graphs approximately uniformly. It uses edge-switching Monte-Carlo s to randomize the graphs. This generator should be favoured if undirected and connected graphs are to be generated and execution time is not a concern. igraph uses the original implementation of Fabien Viger; see the following URL and the paper cited on it for the details of the algorithm: https://www-complexnetworks.lip6.fr/~latapy/FV/generation.html."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > delete_edges": {
            "Description": "overridden in igraph.Graph\nRemoves edges from the graph.\nAll vertices will be kept, even if they lose all their edges. Nonexistent edges will be silently ignored.",
            "Paramters": {
                "es": "the list of edg to be removed. Edg are identifed by edge IDs. EdgeSeq objects are also accepted here. No argument delet all edg."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > delete_vertices": {
            "Description": "Deletes vertices and all its edges from the graph.",
            "Paramters": {
                "vs": "a single vertex ID or the list of vertex IDs to be deleted. No argument deletes all vertices."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > density": {
            "Description": "Calculates the density of the graph.",
            "Paramters": {
                "loops": "whether to take  into consideration. If True, the algorithm assumes that there might be some  in the graph and calculates the density accordingly. If False, the algorithm assumes that there can't be any ."
            },
            "Return": [
                "the density of the graph."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > dfsiter": {
            "Description": "Constructs a depth first search (DFS) iterator of the graph.",
            "Paramters": {
                "vid": "the root vertex ID",
                "mode": "either \"in\" or \"out\" or \"all\".",
                "advanced": "if False, the iterator returns the next vertex in DFS order in every step. If True, the iterator returns the distance of the vertex from the root and the parent of the vertex in the DFS tree as well."
            },
            "Return": [
                "the DFS iterator as an igraph.DFSIter object."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > diameter": {
            "Description": "Calculates the diameter of the graph.",
            "Paramters": {
                "directed": "whether to consider  paths.",
                "unconn": "if True and the graph is ected, the longest geodesic within a component will be returned. If False and the graph is ected, the result is the number of vertices if there are no weights or infinity if there are weights.",
                "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name."
            },
            "Return": [
                "the diameter"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > difference": {
            "Description": "Subtracts the given graph from the original",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > distances": {
            "Description": "Calculates shortest path lengths for given vertices in a graph.\nThe algorithm used for the calculations is selected automatically: a simple BFS is used for unweighted graphs, Dijkstra's algorithm is used when all the weights are non-negative. Otherwise, the Bellman-Ford algorithm is used if the number of requested source vertices is smaller than 100 and Johnson's algorithm is used otherwise.",
            "Paramters": {
                "source": "a list containing the  vertex IDs which should be included in the result. If None, all vertices will be considered.",
                "target": "a list containing the  vertex IDs which should be included in the result. If None, all vertices will be considered.",
                "weights": "a list containing the edge . It can also be an attribute name (edge  are retrieved from the given attribute) or None (all edges have equal weight).",
                "mode": "the type of shortest paths to be used for the calculation in directed graphs. \"out\" means only outgoing, \"in\" means only incoming paths. \"all\" means to consider the directed graph as an undirected one.",
                "algorithm": "the shortest path  to use. \"auto\" selects an  automatically based on whether the graph has negative weights or not. \"dijkstra\" uses Dijkstra's . \"bellman_ford\" uses the Bellman-Ford . \"johnson\" uses Johnson's . Ignored for unweighted graphs."
            },
            "Return": [
                "the shortest path lengths for given vertices in a matrix"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > diversity": {
            "Description": "Calculates the structural diversity index of the vertices.\nThe structural diversity index of a vertex is simply the (normalized) Shannon entropy of the weights of the edges incident on the vertex.\nThe measure is defined for undirected graphs only; edge directions are ignored.\nReference: Eagle N, Macy M and Claxton R: Network diversity and economic development, Science 328, 1029-1031, 2010.",
            "Paramters": {
                "vertices": "the  for which the diversity indices must be returned. If None, uses all of the  in the graph.",
                "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name."
            },
            "Return": [
                "the calculated diversity indices in a list, or a single number if a single vertex was supplied."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > dominator": {
            "Description": "Returns the dominator tree from the given root node",
            "Paramters": {
                "vid": "the root vertex ID",
                "mode": "either \"in\" or \"out\""
            },
            "Return": [
                "a list containing the dominator tree for the current graph."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > dyad_census": {
            "Description": "overridden in igraph.Graph\nDyad census, as defined by Holland and Leinhardt\nDyad census means classifying each pair of vertices of a directed graph into three categories: mutual, there is an edge from a to b and also from b to a; asymmetric, there is an edge either from a to b or from b to a but not the other way and null, no edges between a and b.\nAttention: this function has a more convenient interface in class Graph, which wraps the result in a DyadCensus object. It is advised to use that.",
            "Paramters": {},
            "Return": [
                "the number of mutual, asymmetric and null connections in a 3-tuple."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > eccentricity": {
            "Description": "Calculates the eccentricities of given vertices in a graph.\nThe eccentricity of a vertex is calculated by measuring the shortest distance from (or to) the vertex, to (or from) all other vertices in the graph, and taking the maximum.",
            "Paramters": {
                "vertices": "the  for which the eccentricity scores must be returned. If None, uses all of the  in the graph.",
                "mode": "must be one of \"in\", \"out\" and \"all\". \"in\" means that edge directions are followed; \"out\" means that edge directions are followed the opposite direction; \"all\" means that directions are ignored. The argument has no effect for undirected graphs.",
                "weights": "a list containing the edge . It can also be an attribute name (edge  are retrieved from the given attribute) or None (all edges have equal weight)."
            },
            "Return": [
                "the calculated eccentricities in a list, or a single number if a single vertex was supplied."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > ecount": {
            "Description": "Counts the number of edges.",
            "Paramters": {},
            "Return": [
                "integerthe number of edges in the graph."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > edge_attributes": {
            "Description": "",
            "Paramters": {},
            "Return": [
                "the attribute name list of the edges of the graph"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > edge_betweenness": {
            "Description": "Calculates or estimates the edge betweennesses in a graph.\nAlso supports calculating edge betweenness with shortest path length cutoffs or considering shortest paths only from certain source vertices or to certain target vertices.",
            "Paramters": {
                "directed": "whether to consider  paths.",
                "cutoff": "if it is an integer, only paths less than or equal to this length are considered, effectively resulting in an estimation of the betweenness values. If None, the exact betweennesses are returned.",
                "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name.",
                "sources": "the set of source vertices to consider when calculating shortest paths.",
                "targets": "the set of target vertices to consider when calculating shortest paths."
            },
            "Return": [
                "a list with the (exact or estimated) edge betweennesses of all edges."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > edge_connectivity": {
            "Description": "Calculates the edge connectivity of the graph or between some vertices.\nThe edge connectivity between two given vertices is the number of edges that have to be removed in order to disconnect the two vertices into two separate components. This is also the number of edge disjoint directed paths between the vertices. The edge connectivity of the graph is the minimal edge connectivity over all vertex pairs.\nThis method calculates the edge connectivity of a given vertex pair if both the source and target vertices are given. If none of them is given (or they are both negative), the overall edge connectivity is returned.",
            "Paramters": {
                "source": "the  vertex involved in the calculation.",
                "target": "the  vertex involved in the calculation.",
                "checks": "if the whole graph connectivity is calculated and this is True, igraph performs some basic  before calculation. If the graph is not strongly connected, then the connectivity is obviously zero. If the minimum degree is one, then the connectivity is also one. These simple  are much faster than checking the entire graph, therefore it is advised to set this to True. The parameter is ignored if the connectivity between two given vertices is computed."
            },
            "Return": [
                "the edge connectivity"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > eigen_adjacency": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > eigenvector_centrality": {
            "Description": "Calculates the eigenvector centralities of the vertices in a graph.\nEigenvector centrality is a measure of the importance of a node in a network. It assigns relative scores to all nodes in the network based on the principle that connections from high-scoring nodes contribute more to the score of the node in question than equal connections from low-scoring nodes. In practice, the centralities are determined by calculating eigenvector corresponding to the largest positive eigenvalue of the adjacency matrix. In the undirected case, this function considers the diagonal entries of the adjacency matrix to be twice the number of self-loops on the corresponding vertex.\nIn the directed case, the left eigenvector of the adjacency matrix is calculated. In other words, the centrality of a vertex is proportional to the sum of centralities of vertices pointing to it.\nEigenvector centrality is meaningful only for connected graphs. Graphs that are not connected should be decomposed into connected components, and the eigenvector centrality calculated for each separately.",
            "Paramters": {
                "directed": "whether to consider edge directions in a  graph. Ignored for un graphs.",
                "scale": "whether to normalize the centralities so the largest one will always be 1.",
                "weights": "edge  given as a list or an edge attribute. If None, all edges have equal weight.",
                "return_eigenvalue": "whether to return the actual largest eigenvalue along with the centralities",
                "arpack_options": "an ARPACKOptions object that can be used to fine-tune the calculation. If it is omitted, the module-level variable called  is used."
            },
            "Return": [
                "the eigenvector centralities in a list and optionally the largest eigenvalue (as a second member of a tuple)"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > Erdos_Renyi": {
            "Description": "Generates a graph based on the Erd\u0151s-R\u00e9nyi model.",
            "Paramters": {
                "n": "the umber of vertices.",
                "p": "the robability of edges. If given, m must be missing.",
                "m": "the nuber of edges. If given, p ust be issing.",
                "directed": "whether to generate a  graph.",
                "loops": "whether self- are allowed."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > Establishment": {
            "Description": "Generates a graph based on a simple growing model with vertex types.\nA single vertex is added at each time step. This new vertex tries to connect to k vertices in the graph. The probability that such a connection is realized depends on the types of the vertices involved.",
            "Paramters": {
                "n": "the umber of vertices i the graph",
                "k": "the number of connections tried in each step",
                "type_dist": "list giving the distribution of vertex types",
                "pref_matrix": "matrix (list of lists) giving the connection probabilities for different vertex types",
                "directed": "whether to generate a  graph."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > Famous": {
            "Description": "Generates a famous graph based on its name.\nSeveral famous graphs are known to igraph including (but not limited to) the Chvatal graph, the Petersen graph or the Tutte graph. This method generates one of them based on its name (case insensitive). See the documentation of the C interface of igraph for the names available: https://igraph.org/c/doc.",
            "Paramters": {
                "name": "the  of the graph to be generated."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > farthest_points": {
            "Description": "Returns two vertex IDs whose distance equals the actual diameter of the graph.\nIf there are many shortest paths with the length of the diameter, it returns the first one it found.",
            "Paramters": {
                "directed": "whether to consider  paths.",
                "unconn": "if True and the graph is ected, the longest geodesic within a component will be returned. If False and the graph is ected, the result contains the number of vertices if there are no weights or infinity if there are weights.",
                "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name."
            },
            "Return": [
                "a triplet containing the two vertex IDs and their distance. The IDs are None if the graph is unconnected and unconn is False."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > feedback_arc_set": {
            "Description": "Calculates an approximately or exactly minimal feedback arc set.\nA feedback arc set is a set of edges whose removal makes the graph acyclic. Since this is always possible by removing all the edges, we are in general interested in removing the smallest possible number of edges, or an edge set with as small total weight as possible. This method calculates one such edge set. Note that the task is trivial for an undirected graph as it is enough to find a spanning tree and then remove all the edges not in the spanning tree. Of course it is more complicated for directed graphs.\nReference: Eades P, Lin X and Smyth WF: A fast and effective heuristic for the feedback arc set problem. In: Proc Inf Process Lett 319-323, 1993.",
            "Paramters": {
                "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name. When given, the algorithm will strive to remove lightweight edges in order to minimize the total weight of the feedback arc set.",
                "method": "the algorithm to use. \"eades\" uses the greedy cycle breaking heuristic of Eades, Lin and Smyth, which is linear in the number of edges but not necessarily optimal; however, it guarantees that the number of edges to be removed is smaller than |E|/2 - |V|/6. \"ip\" uses an integer programming formulation which is guaranteed to yield an optimal result, but is too slow for large graphs."
            },
            "Return": [
                "the IDs of the edges to be removed, in a list."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > Forest_Fire": {
            "Description": "Generates a graph based on the forest fire model\nThe forest fire model is a growing graph model. In every time step, a new vertex is added to the graph. The new vertex chooses an ambassador (or more than one if ambs\u2009>\u20091) and starts a simulated forest fire at its ambassador(s). The fire spreads through the edges. The spreading probability along an edge is given by fwprob. The fire may also spread backwards on an edge by probability fwprob*bwfactor. When the fire ended, the newly added vertex connects to the vertices ``burned'' in the previous fire.",
            "Paramters": {
                "n": "the umber of vertices i the graph",
                "fw_prob": "forward burning probability",
                "bw_factor": "ratio of backward and forward burning probability",
                "ambs": "number of ambassadors chosen in each step",
                "directed": "whether the graph will be "
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > Full": {
            "Description": "Generates a full graph (directed or undirected, with or without loops).",
            "Paramters": {
                "n": "the umber of vertices.",
                "directed": "whether to generate a  graph.",
                "loops": "whether self- are allowed."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > Full_Citation": {
            "Description": "Generates a full citation graph\nA full citation graph is a graph where the vertices are indexed from 0 to n\u2009\u2212\u20091 and vertex i has a directed edge towards all vertices with an index less than i.",
            "Paramters": {
                "n": "the umber of vertices.",
                "directed": "whether to generate a  graph."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > fundamental_cycles": {
            "Description": "Finds a single fundamental cycle basis of the graph",
            "Paramters": {
                "start_vid": "when None or negative, a complete fundamental cycle basis is returned. When it is a vertex or a vertex ID, the fundamental cycles associated with the BFS tree rooted in that vertex will be returned, only for the weakly connected component containing that vertex",
                "cutoff": "when None or negative, a complete cycle basis is returned. Otherwise the BFS is stopped after this many steps, so the result will effectively include cycles of length 2*\u2009+\u20091 or shorter only."
            },
            "Return": [
                "the cycle basis as a list of tuples containing edge IDs"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > get_adjacency": {
            "Description": "overridden in igraph.Graph\nReturns the adjacency matrix of a graph.",
            "Paramters": {
                "type": "one of \"lower\" (uses the lower triangle of the matrix), \"upper\" (uses the upper triangle) or \"both\" (uses both parts). Ignored for directed graphs.",
                "loops": "specifies how loop edges should be handled. False or \"ignore\" ignores loop edges. \"once\" counts each loop edge once in the diagonal. \"twice\" counts each loop edge twice (i.e. it counts the endpoints of the loop edges, not the edges themselves)."
            },
            "Return": [
                "the adjacency matrix."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > get_all_shortest_paths": {
            "Description": "Calculates all of the shortest paths from/to a given node in a graph.",
            "Paramters": {
                "v": "the source for the calculated paths",
                "to": "a vertex selecr describing the destination for the calculated paths. This can be a single vertex ID, a list of vertex IDs, a single vertex name, a list of vertex names or a VertexSeq object. None means all the vertices.",
                "weights": "edge  in a list or the name of an edge attribute holding edge . If None, all edges are assumed to have equal weight.",
                "mode": "the directionality of the paths. \"in\" means to calculate incoming paths, \"out\" means to calculate outgoing paths, \"all\" means to calculate both ones."
            },
            "Return": [
                "all of the shortest path from the given node to every other reachable node in the graph in a list. Note that in case of mode=\"in\", the vertices in a path are returned in reversed order!"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > get_biadjacency": {
            "Description": "overridden in igraph.Graph\nInternal function, undocumented.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "Graph.get_biadjacency()",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > get_diameter": {
            "Description": "Returns a path with the actual diameter of the graph.\nIf there are many shortest paths with the length of the diameter, it returns the first one it founds.",
            "Paramters": {
                "directed": "whether to consider  paths.",
                "unconn": "if True and the graph is ected, the longest geodesic within a component will be returned. If False and the graph is ected, the result is the number of vertices if there are no weights or infinity if there are weights.",
                "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name."
            },
            "Return": [
                "the vertices in the path in order."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > get_edgelist": {
            "Description": "Returns the edge list of a graph.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > get_eid": {
            "Description": "Returns the edge ID of an arbitrary edge between vertices v1 and v2",
            "Paramters": {
                "v1": "the ID or name of the first vertex",
                "v2": "the ID or name of the second vertex",
                "directed": "whether edge directions should be considered in  graphs. The default is True. Ignored for un graphs.",
                "error": "if True, an exception will be raised when the given edge does not exist. If False, -1 will be returned in that case."
            },
            "Return": [
                "the edge ID of an arbitrary edge between vertices v1 and v2"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > get_eids": {
            "Description": "Returns the edge IDs of some edges between some vertices.\nThe method does not consider multiple edges; if there are multiple edges between a pair of vertices, only the ID of one of the edges is returned.",
            "Paramters": {
                "pairs": "a list of integer . Each integer pair is considered as a source-target vertex pair; the corresponding edge is looked up in the graph and the edge ID is returned for each pair.",
                "directed": "whether edge directions should be considered in  graphs. The default is True. Ignored for un graphs.",
                "error": "if True, an exception will be raised if a given edge does not exist. If False, -1 will be returned in that case."
            },
            "Return": [
                "the edge IDs in a list"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > get_isomorphisms_vf2": {
            "Description": "Returns all isomorphisms between the graph and another one\nVertex and edge colors may be used to restrict the isomorphisms, as only vertices and edges with the same color will be allowed to match each other.",
            "Paramters": {
                "other": "the  graph. If None, the automorphisms will be returned.",
                "color1": "optional vector storing the coloring of the vertices of the first graph. If None, all vertices have the same color.",
                "color2": "optional vector storing the coloring of the vertices of the second graph. If None, all vertices have the same color.",
                "edge_color1": "optional vector storing the coloring of the edges of the first graph. If None, all edges have the same color.",
                "edge_color2": "optional vector storing the coloring of the edges of the second graph. If None, all edges have the same color.",
                "node_compat_fn": "a function that receives the two graphs and two node indices (one from the first graph, one from the second graph) and returns True if the nodes given by the two indices are compatible (i.e. they could be matched to each other) or False otherwise. This can be used to restrict the set of isomorphisms based on node-specific criteria that are too complicated to be represented by node color vectors (i.e. the color1 and color2 parameters). None means that every node is compatible with every other node.",
                "edge_compat_fn": "a function that receives the two graphs and two edge indices (one from the first graph, one from the second graph) and returns True if the edges given by the two indices are compatible (i.e. they could be matched to each other) or False otherwise. This can be used to restrict the set of isomorphisms based on edge-specific criteria that are too complicated to be represented by edge color vectors (i.e. the edge_color1 and edge_color2 parameters). None means that every edge is compatible with every other node."
            },
            "Return": [
                "a list of lists, each item of the list containing the mapping from vertices of the second graph to the vertices of the first one"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > get_k_shortest_paths": {
            "Description": "Calculates the k shortest paths from/to a given node in a graph.",
            "Paramters": {
                "v": "the ID or name of the ertex from which the paths are calculated.",
                "to": "the ID or name of the vertex  which the paths are calculated.",
                "k": "the desired number of shortest path",
                "weights": "edge  in a list or the name of an edge attribute holding edge . If None, all edges are assumed to have equal weight.",
                "mode": "the directionality of the paths. \"in\" means to calculate incoming paths, \"out\" means to calculate outgoing paths, \"all\" means to calculate both ones.",
                "output": "determines what should be returned. If this is \"vpath\", a list of vertex IDs will be returned, one path for each target vertex. For unconnected graphs, some of the list elements may be empty. Note that in case of mode=\"in\", the vertices in a path are returned in reversed order. If =\"epath\", edge IDs are returned instead of vertex IDs."
            },
            "Return": [
                "the k shortest paths from the given source node to the given target node in a list of vertex or edge IDs (depending on the value of the output argument). Note that in case of mode=\"in\", the vertices in a path are returned in reversed order!"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > get_shortest_path": {
            "Description": "Calculates the shortest path from a source vertex to a target vertex in a graph.",
            "Paramters": {
                "v": "the source ertex of the path",
                "to": "the target vertex of the path",
                "weights": "edge  in a list or the name of an edge attribute holding edge . If None, all edges are assumed to have equal weight.",
                "mode": "the directionality of the paths. \"out\" means to calculate paths from source to target, following edges according to their natural direction. \"in\" means to calculate paths from target to source, flipping the direction of each edge on-the-fly. \"all\" means to ignore edge directions.",
                "output": "determines what should be returned. If this is \"vpath\", a list of vertex IDs will be returned. If this is \"epath\", edge IDs are returned instead of vertex IDs.",
                "algorithm": "the shortest path  to use. \"auto\" selects an  automatically based on whether the graph has negative weights or not. \"dijkstra\" uses Dijkstra's . \"bellman_ford\" uses the Bellman-Ford . Ignored for unweighted graphs."
            },
            "Return": [
                "see the documentation of the output parameter."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > get_shortest_path_astar": {
            "Description": "Calculates the shortest path from a source vertex to a target vertex in a graph using the A-Star algorithm and a heuristic function.",
            "Paramters": {
                "v": "the source ertex of the path",
                "to": "the target vertex of the path",
                "heuristics": "a function that will be called with the graph and two vertices, and must return an estimate of the cost of the path from the first vertex to the second vertex. The A-Star algorithm is guaranteed to return an optimal solution if the heuristic is admissible, i.e. if it does never overestimate the cost of the shortest path from the given source vertex to the given target vertex.",
                "weights": "edge  in a list or the name of an edge attribute holding edge . If None, all edges are assumed to have equal weight.",
                "mode": "the directionality of the paths. \"out\" means to calculate paths from source to target, following edges according to their natural direction. \"in\" means to calculate paths from target to source, flipping the direction of each edge on-the-fly. \"all\" means to ignore edge directions.",
                "output": "determines what should be returned. If this is \"vpath\", a list of vertex IDs will be returned. If this is \"epath\", edge IDs are returned instead of vertex IDs."
            },
            "Return": [
                "see the documentation of the output parameter."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > get_shortest_paths": {
            "Description": "Calculates the shortest paths from/to a given node in a graph.",
            "Paramters": {
                "v": "the source/destination for the calculated paths",
                "to": "a vertex selecr describing the destination/source for the calculated paths. This can be a single vertex ID, a list of vertex IDs, a single vertex name, a list of vertex names or a VertexSeq object. None means all the vertices.",
                "weights": "edge  in a list or the name of an edge attribute holding edge . If None, all edges are assumed to have equal weight.",
                "mode": "the directionality of the paths. \"in\" means to calculate incoming paths, \"out\" means to calculate outgoing paths, \"all\" means to calculate both ones.",
                "output": "determines what should be returned. If this is \"vpath\", a list of vertex IDs will be returned, one path for each target vertex. For unconnected graphs, some of the list elements may be empty. Note that in case of mode=\"in\", the vertices in a path are returned in reversed order. If =\"epath\", edge IDs are returned instead of vertex IDs.",
                "algorithm": "the shortest path  to use. \"auto\" selects an  automatically based on whether the graph has negative weights or not. \"dijkstra\" uses Dijkstra's . \"bellman_ford\" uses the Bellman-Ford . Ignored for unweighted graphs."
            },
            "Return": [
                "see the documentation of the output parameter."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > get_subisomorphisms_lad": {
            "Description": "Returns all subisomorphisms between the graph and another one using the LAD algorithm.\nThe optional domains argument may be used to restrict vertices that may match each other. You can also specify whether you are interested in induced subgraphs only or not.",
            "Paramters": {
                "other": "the pattern graph we are looking for in the graph.",
                "domains": "a list of lists, one sublist belonging to each vertex in the template graph. Sublist i contains the indices of the vertices in the original graph that may match vertex i in the template graph. None means that every vertex may match every other vertex.",
                "induced": "whether to consider  subgraphs only.",
                "time_limit": "an optimal time limit in seconds. Only the integral part of this number is taken into account. If the time limit is exceeded, the method will throw an exception."
            },
            "Return": [
                "a list of lists, each item of the list containing the mapping from vertices of the second graph to the vertices of the first one"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > get_subisomorphisms_vf2": {
            "Description": "Returns all subisomorphisms between the graph and another one\nVertex and edge colors may be used to restrict the isomorphisms, as only vertices and edges with the same color will be allowed to match each other.",
            "Paramters": {
                "other": "the  graph.",
                "color1": "optional vector storing the coloring of the vertices of the first graph. If None, all vertices have the same color.",
                "color2": "optional vector storing the coloring of the vertices of the second graph. If None, all vertices have the same color.",
                "edge_color1": "optional vector storing the coloring of the edges of the first graph. If None, all edges have the same color.",
                "edge_color2": "optional vector storing the coloring of the edges of the second graph. If None, all edges have the same color.",
                "node_compat_fn": "a function that receives the two graphs and two node indices (one from the first graph, one from the second graph) and returns True if the nodes given by the two indices are compatible (i.e. they could be matched to each other) or False otherwise. This can be used to restrict the set of isomorphisms based on node-specific criteria that are too complicated to be represented by node color vectors (i.e. the color1 and color2 parameters). None means that every node is compatible with every other node.",
                "edge_compat_fn": "a function that receives the two graphs and two edge indices (one from the first graph, one from the second graph) and returns True if the edges given by the two indices are compatible (i.e. they could be matched to each other) or False otherwise. This can be used to restrict the set of isomorphisms based on edge-specific criteria that are too complicated to be represented by edge color vectors (i.e. the edge_color1 and edge_color2 parameters). None means that every edge is compatible with every other node."
            },
            "Return": [
                "a list of lists, each item of the list containing the mapping from vertices of the second graph to the vertices of the first one"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > girth": {
            "Description": "Returns the girth of the graph.\nThe girth of a graph is the length of the shortest circle in it.",
            "Paramters": {
                "return_shortest_circle": "whether to return one of the shortest circles found in the graph."
            },
            "Return": [
                "the length of the shortest circle or (if return_shortest_circle) is true, the shortest circle itself as a list"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > gomory_hu_tree": {
            "Description": "overridden in igraph.Graph\nInternal function, undocumented.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "Graph.gomory_hu_tree()",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > Growing_Random": {
            "Description": "Generates a growing random graph.",
            "Paramters": {
                "n": "The umber of vertices i the graph",
                "m": "The nuber of edges to add in each step (after adding a new vertex)",
                "directed": "whether the graph should be .",
                "citation": "whether the new edges should originate from the most recently added vertex."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > harmonic_centrality": {
            "Description": "Calculates the harmonic centralities of given vertices in a graph.\nThe harmonic centrality of a vertex measures how easily other vertices can be reached from it (or the other way: how easily it can be reached from the other vertices). It is defined as the mean inverse distance to all other vertices.\nIf the graph is not connected, and there is no path between two vertices, the inverse distance is taken to be zero.",
            "Paramters": {
                "vertices": "the  for which the harmonic centrality must be returned. If None, uses all of the  in the graph.",
                "mode": "must be one of \"in\", \"out\" and \"all\". \"in\" means that the length of the incoming paths, \"out\" means that the length of the outgoing paths must be calculated. \"all\" means that both of them must be calculated.",
                "cutoff": "if it is not None, only paths less than or equal to this length are considered.",
                "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name.",
                "normalized": "Whether to normalize the result. If True, the result is the mean inverse path length to other vertices, i.e. it is  by the number of vertices minus one. If False, the result is the sum of inverse path lengths to other vertices."
            },
            "Return": [
                "the calculated harmonic centralities in a list"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > has_multiple": {
            "Description": "Checks whether the graph has multiple edges.",
            "Paramters": {},
            "Return": [
                "booleanTrue if the graph has at least one multiple edge, False otherwise."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > Hexagonal_Lattice": {
            "Description": "Generates a regular hexagonal lattice.",
            "Paramters": {
                "dim": "list with the ensions of the lattice",
                "directed": "whether to create a  graph.",
                "mutual": "whether to create all connections as  in case of a directed graph."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > hub_score": {
            "Description": "Calculates Kleinberg's hub score for the vertices of the graph",
            "Paramters": {
                "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name.",
                "scale": "whether to normalize the scores so that the largest one is 1.",
                "arpack_options": "an ARPACKOptions object used to fine-tune the ARPACK eigenvector calculation. If omitted, the module-level variable called  is used.",
                "return_eigenvalue": "whether to return the largest eigenvalue"
            },
            "Return": [
                "the hub scores in a list and optionally the largest eigenvalue as a second member of a tuple"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "authority_score()",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > incident": {
            "Description": "Returns the edges a given vertex is incident on.",
            "Paramters": {
                "vertex": "a  ID",
                "mode": "whether to return only successors (\"out\"), predecessors (\"in\") or both (\"all\"). Ignored for undirected graphs."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > independence_number": {
            "Description": "Returns the independence number of the graph.\nThe independence number of the graph is the size of the largest independent vertex set.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "largest_independent_vertex_sets() for the largest independent vertex sets",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > independent_vertex_sets": {
            "Description": "Returns some or all independent vertex sets of the graph as a list of tuples.\nTwo vertices are independent if there is no edge between them. Members of an independent vertex set are mutually independent.",
            "Paramters": {
                "min": "the imum size of sets to be returned. If zero or negative, no lower bound will be used.",
                "max": "the imum size of sets to be returned. If zero or negative, no upper bound will be used."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > induced_subgraph": {
            "Description": "Returns a subgraph spanned by the given vertices.",
            "Paramters": {
                "vertices": "a list containing the vertex IDs which should be included in the result.",
                "implementation": "the  to use when constructing the new subgraph. igraph includes two s at the moment. \"copy_and_delete\" copies the original graph and removes those vertices that are not in the given set. This is more efficient if the size of the subgraph is comparable to the original graph. The other  (\"create_from_scratch\") constructs the result graph from scratch and then copies the attributes accordingly. This is a better solution if the subgraph is relatively small, compared to the original graph. \"auto\" selects between the two s automatically, based on the ratio of the size of the subgraph and the size of the original graph."
            },
            "Return": [
                "the subgraph"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > is_acyclic": {
            "Description": "Returns whether the graph is acyclic (i.e. contains no cycles).",
            "Paramters": {},
            "Return": [
                "booleanTrue if the graph is acyclic, False otherwise."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > is_biconnected": {
            "Description": "Decides whether the graph is biconnected.\nA graph is biconnected if it stays connected after the removal of any single vertex.\nNote that there are different conventions in use about whether to consider a graph consisting of two connected vertices to be biconnected. igraph does consider it biconnected.",
            "Paramters": {},
            "Return": [
                "booleanTrue if it is biconnected, False otherwise."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > is_bipartite": {
            "Description": "Decides whether the graph is bipartite or not.\nVertices of a bipartite graph can be partitioned into two groups A and B in a way that all edges go between the two groups.",
            "Paramters": {
                "return_types": "if False, the method will simply return True or False depending on whether the graph is bipartite or not. If True, the actual group assignments are also returned as a list of boolean values. (Note that the group assignment is not unique, especially if the graph consists of multiple components, since the assignments of components are independent from each other)."
            },
            "Return": [
                "True if the graph is bipartite, False if not. If return_types is True, the group assignment is also returned."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > is_chordal": {
            "Description": "Returns whether the graph is chordal or not.\nA graph is chordal if each of its cycles of four or more nodes has a chord, i.e. an edge joining two nodes that are not adjacent in the cycle. An equivalent definition is that any chordless cycles have at most three nodes.",
            "Paramters": {
                "alpha": "the  vector from the result of calling maximum_cardinality_search() on the graph. Useful only if you already have the  vector; simply passing None here will make igraph calculate the  vector on its own.",
                "alpham1": "the inverse alpha vector from the result of calling maximum_cardinality_search() on the graph. Useful only if you already have the inverse alpha vector; simply passing None here will make igraph calculate the inverse alpha vector on its own."
            },
            "Return": [
                "True if the graph is chordal, False otherwise."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > is_connected": {
            "Description": "Decides whether the graph is connected.",
            "Paramters": {
                "mode": "whether we should calculate strong or weak connectivity."
            },
            "Return": [
                "True if the graph is connected, False otherwise."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > is_dag": {
            "Description": "Checks whether the graph is a DAG (directed acyclic graph).\nA DAG is a directed graph with no directed cycles.",
            "Paramters": {},
            "Return": [
                "booleanTrue if it is a DAG, False otherwise."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > is_directed": {
            "Description": "Checks whether the graph is directed.",
            "Paramters": {},
            "Return": [
                "booleanTrue if it is directed, False otherwise."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > is_loop": {
            "Description": "Checks whether a specific set of edges contain loop edges",
            "Paramters": {
                "edges": "edge indices which we want to check. If None, all  are checked."
            },
            "Return": [
                "a list of booleans, one for every edge given"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > is_minimal_separator": {
            "Description": "Decides whether the given vertex set is a minimal separator.\nA minimal separator is a set of vertices whose removal disconnects the graph, while the removal of any subset of the set keeps the graph connected.",
            "Paramters": {
                "vertices": "a single vertex ID or a list of vertex IDs"
            },
            "Return": [
                "True is the given vertex set is a minimal separator, False otherwise."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > is_multiple": {
            "Description": "Checks whether an edge is a multiple edge.\nAlso works for a set of edges -- in this case, every edge is checked one by one. Note that if there are multiple edges going between a pair of vertices, there is always one of them that is not reported as multiple (only the others). This allows one to easily detect the edges that have to be deleted in order to make the graph free of multiple edges.",
            "Paramters": {
                "edges": "edge indices which we want to check. If None, all  are checked."
            },
            "Return": [
                "a list of booleans, one for every edge given"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > is_mutual": {
            "Description": "Checks whether an edge has an opposite pair.\nAlso works for a set of edges -- in this case, every edge is checked one by one. The result will be a list of booleans (or a single boolean if only an edge index is supplied), every boolean corresponding to an edge in the edge set supplied. True is returned for a given edge a --> b if there exists another edge b --> a in the original graph (not the given edge set!). All edges in an undirected graph are mutual. In case there are multiple edges between a and b, it is enough to have at least one edge in either direction to report all edges between them as mutual, so the multiplicity of edges do not matter.",
            "Paramters": {
                "edges": "edge indices which we want to check. If None, all  are checked.",
                "loops": "specifies whether loop edges should be treated as mutual in a directed graph."
            },
            "Return": [
                "a list of booleans, one for every edge given"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > is_separator": {
            "Description": "Decides whether the removal of the given vertices disconnects the graph.",
            "Paramters": {
                "vertices": "a single vertex ID or a list of vertex IDs"
            },
            "Return": [
                "True is the given vertex set is a separator, False if not."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > is_simple": {
            "Description": "Checks whether the graph is simple (no loop or multiple edges).",
            "Paramters": {},
            "Return": [
                "booleanTrue if it is simple, False otherwise."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > is_tree": {
            "Description": "Checks whether the graph is a (directed or undirected) tree graph.\nFor directed trees, the function may require that the edges are oriented outwards from the root or inwards to the root, depending on the value of the mode argument.",
            "Paramters": {
                "mode": "for directed graphs, specifies how the edge directions should be taken into account. \"all\" means that the edge directions must be ignored, \"out\" means that the edges must be oriented away from the root, \"in\" means that the edges must be oriented towards the root. Ignored for undirected graphs."
            },
            "Return": [
                "booleanTrue if the graph is a tree, False otherwise."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > Isoclass": {
            "Description": "Generates a graph with a given isomorphism class.\nCurrently we support directed graphs of size 3 and 4, and undirected graphs of size 3, 4, 5 or 6. Use the isoclass() instance method to find the isomorphism class of a given graph.",
            "Paramters": {
                "n": "the umber of vertices i the graph",
                "cls": "the isomorphism class",
                "directed": "whether the graph should be ."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > isoclass": {
            "Description": "Returns the isomorphism class of the graph or its subgraph.\nIsomorphism class calculations are implemented only for directed graphs with 3 or 4 vertices, or undirected graphs with 3, 4, 5 or 6 vertices..",
            "Paramters": {
                "vertices": "a list of  if we want to calculate the isomorphism class for only a subset of . None means to use the full graph."
            },
            "Return": [
                "the isomorphism class of the (sub)graph"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > isomorphic": {
            "Description": "Checks whether the graph is isomorphic to another graph.\nThe algorithm being used is selected using a simple heuristic:If one graph is directed and the other undirected, an exception is thrown.If the two graphs does not have the same number of vertices and edges, it returns with FalseIf the graphs have three or four vertices, then an O(1) algorithm is used with precomputed data.Otherwise if the graphs are directed, then the VF2 isomorphism algorithm is used (see isomorphic_vf2).Otherwise the BLISS isomorphism algorithm is used, see isomorphic_bliss.",
            "Paramters": {},
            "Return": [
                "True if the graphs are isomorphic, False otherwise."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > isomorphic_bliss": {
            "Description": "Checks whether the graph is isomorphic to another graph, using the BLISS isomorphism algorithm.\nSee http://www.tcs.hut.fi/Software/bliss/index.html for more information about the BLISS algorithm.",
            "Paramters": {
                "other": "the  graph with which we want to compare the graph.",
                "return_mapping_12": "if True, calculates the mapping which maps the vertices of the first graph to the second.",
                "return_mapping_21": "if True, calculates the mapping which maps the vertices of the second graph to the first.",
                "sh1": "splitting heuristics for the first graph as a case-insensitive string, with the following possible values:\"f\": first non-singleton cell\"fl\": first largest non-singleton cell\"fs\": first smallest non-singleton cell\"fm\": first maximally non-trivially connected non-singleton cell\"flm\": largest maximally non-trivially connected non-singleton cell\"fsm\": smallest maximally non-trivially connected non-singleton cell",
                "sh2": "splitting heuristics to be used for the second graph. This must be the same as sh1; alternatively, it can be None, in which case it will automatically use the same value as sh1. Currently it is present for backwards compatibility only.",
                "color1": "optional vector storing the coloring of the vertices of the first graph. If None, all vertices have the same color.",
                "color2": "optional vector storing the coloring of the vertices of the second graph. If None, all vertices have the same color."
            },
            "Return": [
                "if no mapping is calculated, the result is True if the graphs are isomorphic, False otherwise. If any or both mappings are calculated, the result is a 3-tuple, the first element being the above mentioned boolean, the second element being the 1 -> 2 mapping and the third element being the 2 -> 1 mapping. If the corresponding mapping was not calculated, None is returned in the appropriate element of the 3-tuple."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > isomorphic_vf2": {
            "Description": "Checks whether the graph is isomorphic to another graph, using the VF2 isomorphism algorithm.\nVertex and edge colors may be used to restrict the isomorphisms, as only vertices and edges with the same color will be allowed to match each other.",
            "Paramters": {
                "other": "the  graph with which we want to compare the graph. If None, the automorphjisms of the graph will be tested.",
                "color1": "optional vector storing the coloring of the vertices of the first graph. If None, all vertices have the same color.",
                "color2": "optional vector storing the coloring of the vertices of the second graph. If None, all vertices have the same color.",
                "edge_color1": "optional vector storing the coloring of the edges of the first graph. If None, all edges have the same color.",
                "edge_color2": "optional vector storing the coloring of the edges of the second graph. If None, all edges have the same color.",
                "return_mapping_12": "if True, calculates the mapping which maps the vertices of the first graph to the second.",
                "return_mapping_21": "if True, calculates the mapping which maps the vertices of the second graph to the first.",
                "node_compat_fn": "a function that receives the two graphs and two node indices (one from the first graph, one from the second graph) and returns True if the nodes given by the two indices are compatible (i.e. they could be matched to each other) or False otherwise. This can be used to restrict the set of isomorphisms based on node-specific criteria that are too complicated to be represented by node color vectors (i.e. the color1 and color2 parameters). None means that every node is compatible with every other node.",
                "edge_compat_fn": "a function that receives the two graphs and two edge indices (one from the first graph, one from the second graph) and returns True if the edges given by the two indices are compatible (i.e. they could be matched to each other) or False otherwise. This can be used to restrict the set of isomorphisms based on edge-specific criteria that are too complicated to be represented by edge color vectors (i.e. the edge_color1 and edge_color2 parameters). None means that every edge is compatible with every other node.",
                "callback": "if not None, the isomorphism search will not stop at the first match; it will call this  function instead for every isomorphism found. The  function must accept four arguments: the first graph, the second graph, a mapping from the nodes of the first graph to the second, and a mapping from the nodes of the second graph to the first. The function must return True if the search should continue or False otherwise."
            },
            "Return": [
                "if no mapping is calculated, the result is True if the graphs are isomorphic, False otherwise. If any or both mappings are calculated, the result is a 3-tuple, the first element being the above mentioned boolean, the second element being the 1 -> 2 mapping and the third element being the 2 -> 1 mapping. If the corresponding mapping was not calculated, None is returned in the appropriate element of the 3-tuple."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > K_Regular": {
            "Description": "Generates a k-regular random graph\nA k-regular random graph is a random graph where each vertex has degree k. If the graph is directed, both the in-degree and the out-degree of each vertex will be k.",
            "Paramters": {
                "n": "The umber of vertices i the graph",
                "k": "The degree of each vertex if the graph is undirected, or the in-degree and out-degree of each vertex if the graph is directed",
                "directed": "whether the graph should be .",
                "multiple": "whether it is allowed to create  edges."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > Kautz": {
            "Description": "Generates a Kautz graph with parameters (m, n)\nA Kautz graph is a labeled graph, vertices are labeled by strings of length n\u2009+\u20091 above an alphabet with m\u2009+\u20091 letters, with the restriction that every two consecutive letters in the string must be different. There is a directed edge from a vertex v to another vertex w if it is possible to transform the string of v into the string of w by removing the first letter and appending a letter to it.",
            "Paramters": {
                "m": "the size of the alphabet inus one",
                "n": "the legth of the strigs mius oe"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > knn": {
            "Description": "Calculates the average degree of the neighbors for each vertex, and the same quantity as the function of vertex degree.",
            "Paramters": {
                "vids": "the vertices for which the calculation is performed. None means all vertices.",
                "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name. If this is given, the vertex strength will be used instead of the vertex degree in the calculations, but the \"ordinary\" vertex degree will be used for the second (degree- dependent) list in the result."
            },
            "Return": [
                "two lists in a tuple. The first list contains the average degree of neighbors for each vertex, the second contains the average degree of neighbors as a function of vertex degree. The zeroth element of this list corresponds to vertices of degree 1."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > laplacian": {
            "Description": "Returns the Laplacian matrix of a graph.\nThe Laplacian matrix is similar to the adjacency matrix, but the edges are denoted with -1 and the diagonal contains the node degrees.\nSymmetric normalized Laplacian matrices have 1 or 0 in their diagonals (0 for vertices with no edges), edges are denoted by 1 / sqrt(d_i * d_j) where d_i is the degree of node i.\nLeft-normalized and right-normalized Laplacian matrices are derived from the unnormalized Laplacian by scaling the row or the column sums to be equal to 1.",
            "Paramters": {
                "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name. When edge  are used, the degree of a node is considered to be the sum of the  of its incident edges.",
                "normalized": "whether to return the  Laplacian matrix. False or \"un\" returns the un Laplacian matrix. True or \"symmetric\" returns the symmetric normalization of the Laplacian matrix. \"left\" returns the left-, \"right\" returns the right- Laplacian matrix.",
                "mode": "for directed graphs, specifies whether to use out- or in-degrees in the Laplacian matrix. \"all\" means that the edge directions must be ignored, \"out\" means that the out-degrees should be used, \"in\" means that the in-degrees should be used. Ignored for undirected graphs."
            },
            "Return": [
                "the Laplacian matrix."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > largest_cliques": {
            "Description": "Returns the largest cliques of the graph as a list of tuples.\nQuite intuitively a clique is considered largest if there is no clique with more vertices in the whole graph. All largest cliques are maximal (i.e. nonextendable) but not all maximal cliques are largest.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "clique_number() for the size of the largest cliques or maximal_cliques() for the maximal cliques",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > largest_independent_vertex_sets": {
            "Description": "Returns the largest independent vertex sets of the graph as a list of tuples.\nQuite intuitively an independent vertex set is considered largest if there is no other set with more vertices in the whole graph. All largest sets are maximal (i.e. nonextendable) but not all maximal sets are largest.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "independence_number() for the size of the largest independent vertex sets or maximal_independent_vertex_sets() for the maximal (nonextendable) independent vertex sets",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > Lattice": {
            "Description": "Generates a regular square lattice.",
            "Paramters": {
                "dim": "list with the ensions of the lattice",
                "nei": "value giving the distance (number of steps) within which two vertices will be connected.",
                "directed": "whether to create a  graph.",
                "mutual": "whether to create all connections as  in case of a directed graph.",
                "circular": "whether the generated lattice is periodic. May also be an iterable; in this case, the iterator is assumed to yield booleans that specify whether the lattice is periodic along each dimension."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > layout_bipartite": {
            "Description": "Place the vertices of a bipartite graph in two layers.\nThe layout is created by placing the vertices in two rows, according to their types. The positions of the vertices within the rows are then optimized to minimize the number of edge crossings using the heuristic used by the Sugiyama layout algorithm.",
            "Paramters": {
                "types": "an igraph vector containing the vertex , or an attribute name. Anything that evalulates to False corresponds to vertices of the first kind, everything else to the second kind.",
                "hgap": "minimum horizontal gap between vertices in the same layer.",
                "vgap": "vertical gap between the two layers.",
                "maxiter": "maximum number of iterations to take in the crossing reduction step. Increase this if you feel that you are getting too many edge crossings."
            },
            "Return": [
                "the calculated layout."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > layout_circle": {
            "Description": "Places the vertices of the graph uniformly on a circle or a sphere.",
            "Paramters": {
                "dim": "the desired number of ensions for the layout. =2 means a 2D layout, =3 means a 3D layout.",
                "order": "the  in which the vertices are placed along the circle. Not supported when dim is not equal to 2."
            },
            "Return": [
                "the calculated layout."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > layout_davidson_harel": {
            "Description": "Places the vertices on a 2D plane according to the Davidson-Harel layout algorithm.\nThe algorithm uses simulated annealing and a sophisticated energy function, which is unfortunately hard to parameterize for different graphs. The original publication did not disclose any parameter values, and the ones below were determined by experimentation.\nThe algorithm consists of two phases: an annealing phase and a fine-tuning phase. There is no simulated annealing in the second phase.",
            "Paramters": {
                "seed": "if None, uses a random starting layout for the algorithm. If a matrix (list of lists), uses the given matrix as the starting position.",
                "maxiter": "Number of iterations to perform in the annealing phase.",
                "fineiter": "Number of iterations to perform in the fine-tuning phase. Negative numbers set up a reasonable default from the base-2 logarithm of the vertex count, bounded by 10 from above.",
                "cool_fact": "Cooling factor of the simulated annealing phase.",
                "weight_node_dist": "Weight for the node-node distances in the energy function.",
                "weight_border": "Weight for the distance from the border component of the energy function. Zero means that vertices are allowed to sit on the border of the area designated for the layout.",
                "weight_edge_lengths": "Weight for the edge length component of the energy function. Negative numbers are replaced by the density of the graph divided by 10.",
                "weight_edge_crossings": "Weight for the edge crossing component of the energy function. Negative numbers are replaced by one minus the square root of the density of the graph.",
                "weight_node_edge_dist": "Weight for the node-edge distance component of the energy function. Negative numbers are replaced by 0.2 minus 0.2 times the density of the graph."
            },
            "Return": [
                "the calculated layout."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > layout_drl": {
            "Description": "Places the vertices on a 2D plane or in the 3D space ccording to the DrL layout algorithm.\nThis is an algorithm suitable for quite large graphs, but it can be surprisingly slow for small ones (where the simpler force-based layouts like layout_kamada_kawai() or layout_fruchterman_reingold() are more useful.",
            "Paramters": {
                "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name.",
                "fixed": "ignored. We used to assume that the DrL layout supports  nodes, but later it turned out that the argument has no effect in the original DrL code. We kept the argument for sake of backwards compatibility, but it will have no effect on the final layout.",
                "seed": "if None, uses a random starting layout for the algorithm. If a matrix (list of lists), uses the given matrix as the starting position.",
                "options": "if you give a string argument here, you can select from five default preset parameterisations: default, coarsen for a coarser layout, coarsest for an even coarser layout, refine for refining an existing layout and final for finalizing a layout. If you supply an object that is not a string, the DrL layout parameters are retrieved from the respective keys of the object (so it should be a dict or something else that supports the mapping protocol). The following keys can be used:edge_cut: edge cutting is done in the late stages of the algorithm in order to achieve less dense layouts. Edges are cut if there is a lot of stress on them (a large value in the objective function sum). The edge cutting parameter is a value between 0 and 1 with 0 representing no edge cutting and 1 representing maximal edge cutting.init_iterations: number of iterations in the initialization phaseinit_temperature: start temperature during initializationinit_attraction: attraction during initializationinit_damping_mult: damping multiplier during initializationliquid_iterations, liquid_temperature, liquid_attraction, liquid_damping_mult: same parameters for the liquid phaseexpansion_iterations, expansion_temperature, expansion_attraction, expansion_damping_mult: parameters for the expansion phasecooldown_...: parameters for the cooldown phasecrunch_...: parameters for the crunch phasesimmer_...: parameters for the simmer phaseInstead of a mapping, you can also use an arbitrary Python object here: if the object does not support the mapping protocol, an attribute of the object with the same name is looked up instead. If a parameter cannot be found either as a key or an attribute, the default from the default preset will be used.",
                "dim": "the desired number of ensions for the layout. =2 means a 2D layout, =3 means a 3D layout."
            },
            "Return": [
                "the calculated layout."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > layout_fruchterman_reingold": {
            "Description": "Places the vertices on a 2D plane according to the Fruchterman-Reingold algorithm.\nThis is a force directed layout, see Fruchterman, T. M. J. and Reingold, E. M.: Graph Drawing by Force-directed Placement. Software -- Practice and Experience, 21/11, 1129--1164, 1991",
            "Paramters": {
                "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name.",
                "niter": "the number of iterations to perform. The default is 500.",
                "seed": "if None, uses a random starting layout for the algorithm. If a matrix (list of lists), uses the given matrix as the starting position.",
                "start_temp": "Real scalar, the start temperature. This is the maximum amount of movement alloved along one axis, within one step, for a vertex. Currently it is decreased linearly to zero during the iteration. The default is the square root of the number of vertices divided by 10.",
                "minx": "if not None, it must be a vector with exactly as many elements as there are vertices in the graph. Each element is a minimum constraint on the X value of the vertex in the layout.",
                "maxx": "similar to minx, but with maximum constraints",
                "miny": "similar to minx, but with the Y coordinates",
                "maxy": "similar to maxx, but with the Y coordinates",
                "minz": "similar to minx, but with the Z coordinates. Use only for 3D layouts (dim=3).",
                "maxz": "similar to maxx, but with the Z coordinates. Use only for 3D layouts (dim=3).",
                "grid": "whether to use a faster, but less accurate -based implementation of the algorithm. \"auto\" decides based on the number of vertices in the graph; a  will be used if there are at least 1000 vertices. \"\" is equivalent to True, \"no\" is equivalent to False."
            },
            "Return": [
                "the calculated layout."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > layout_graphopt": {
            "Description": "This is a port of the graphopt layout algorithm by Michael Schmuhl. graphopt version 0.4.1 was rewritten in C and the support for layers was removed.\ngraphopt uses physical analogies for defining attracting and repelling forces among the vertices and then the physical system is simulated until it reaches an equilibrium or the maximal number of iterations is reached.\nSee http://www.schmuhl.org/graphopt/ for the original graphopt.",
            "Paramters": {
                "niter": "the number of iterations to perform. Should be a couple of hundred in general.",
                "node_charge": "the charge of the vertices, used to calculate electric repulsion.",
                "node_mass": "the mass of the vertices, used for the spring forces",
                "spring_length": "the length of the springs",
                "spring_constant": "the spring constant",
                "max_sa_movement": "the maximum amount of movement allowed in a single step along a single axis.",
                "seed": "a matrix containing a  layout from which the algorithm will be started. If None, a random layout will be used."
            },
            "Return": [
                "the calculated layout."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > layout_grid": {
            "Description": "Places the vertices of a graph in a 2D or 3D grid.",
            "Paramters": {
                "width": "the number of vertices in a single row of the layout. Zero or negative numbers mean that the  should be determined automatically.",
                "height": "the number of vertices in a single column of the layout. Zero or negative numbers mean that the  should be determined automatically. It must not be given if the number of dimensions is 2.",
                "dim": "the desired number of ensions for the layout. =2 means a 2D layout, =3 means a 3D layout."
            },
            "Return": [
                "the calculated layout."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > layout_kamada_kawai": {
            "Description": "Places the vertices on a plane according to the Kamada-Kawai algorithm.\nThis is a force directed layout, see Kamada, T. and Kawai, S.: An Algorithm for Drawing General Undirected Graphs. Information Processing Letters, 31/1, 7--15, 1989.",
            "Paramters": {
                "maxiter": "the maximum number of iterations to perform. None selects a reasonable default based on the number of vertices.",
                "epsilon": "quit if the energy of the system changes less than . See the original paper for details.",
                "kkconst": "the Kamada-Kawai vertex attraction constant. None means the number of vertices.",
                "seed": "when None, uses a circular layout as a starting point for the algorithm when no bounds are given, or a random layout when bounds are specified for the coordinated. When the argument is a matrix (list of lists), it uses the given matrix as the initial layout.",
                "minx": "if not None, it must be a vector with exactly as many elements as there are vertices in the graph. Each element is a minimum constraint on the X value of the vertex in the layout.",
                "maxx": "similar to minx, but with maximum constraints",
                "miny": "similar to minx, but with the Y coordinates",
                "maxy": "similar to maxx, but with the Y coordinates",
                "minz": "similar to minx, but with the Z coordinates. Use only for 3D layouts (dim=3).",
                "maxz": "similar to maxx, but with the Z coordinates. Use only for 3D layouts (dim=3).",
                "dim": "the desired number of ensions for the layout. =2 means a 2D layout, =3 means a 3D layout.",
                "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name."
            },
            "Return": [
                "the calculated layout."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > layout_lgl": {
            "Description": "Places the vertices on a 2D plane according to the Large Graph Layout.",
            "Paramters": {
                "maxiter": "the number of iterations to perform.",
                "maxdelta": "the maximum distance to move a vertex in an iteration. If negative, defaults to the number of vertices.",
                "area": "the  of the square on which the vertices will be placed. If negative, defaults to the number of vertices squared.",
                "coolexp": "the cooling exponent of the simulated annealing.",
                "repulserad": "determines the radius at which vertex-vertex repulsion cancels out attraction of adjacent vertices. If negative, defaults to area times the number of vertices.",
                "cellsize": "the size of the grid cells. When calculating the repulsion forces, only vertices in the same or neighboring grid cells are taken into account. Defaults to the fourth root of area.",
                "root": "the  vertex, this is placed first, its neighbors in the first iteration, second neighbors in the second, etc. None means that a random vertex will be chosen."
            },
            "Return": [
                "the calculated layout."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > layout_mds": {
            "Description": "Places the vertices in an Euclidean space with the given number of dimensions using multidimensional scaling.\nThis layout requires a distance matrix, where the intersection of row i and column j specifies the desired distance between vertex i and vertex j. The algorithm will try to place the vertices in a way that approximates the distance relations prescribed in the distance matrix. igraph uses the classical multidimensional scaling by Torgerson (see reference below).\nFor unconnected graphs, the method will decompose the graph into weakly connected components and then lay out the components individually using the appropriate parts of the distance matrix.\nReference: Cox & Cox: Multidimensional Scaling (1994), Chapman and Hall, London.",
            "Paramters": {
                "dist": "the ance matrix. It must be symmetric and the symmetry is not checked -- results are unspecified when a non-symmetric ance matrix is used. If this parameter is None, the shortest path lengths will be used as ances. Directed graphs are treated as undirected when calculating the shortest path lengths to ensure symmetry.",
                "dim": "the number of ensions. For 2D layouts, supply 2 here; for 3D layouts, supply 3.",
                "arpack_options": "an ARPACKOptions object used to fine-tune the ARPACK eigenvector calculation. If omitted, the module-level variable called  is used."
            },
            "Return": [
                "the calculated layout."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > layout_random": {
            "Description": "Places the vertices of the graph randomly.",
            "Paramters": {
                "dim": "the desired number of ensions for the layout. =2 means a 2D layout, =3 means a 3D layout."
            },
            "Return": [
                "the coordinate pairs in a list."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > layout_reingold_tilford": {
            "Description": "Places the vertices on a 2D plane according to the Reingold-Tilford layout algorithm.\nThis is a tree layout. If the given graph is not a tree, a breadth-first search is executed first to obtain a possible spanning tree.\nReference: EM Reingold, JS Tilford: Tidier Drawings of Trees. IEEE Transactions on Software Engineering 7:22, 223-228, 1981.",
            "Paramters": {
                "mode": "specifies which edges to consider when builing the tree. If it is OUT then only the outgoing, if it is IN then only the incoming edges of a parent are considered. If it is ALL then all edges are used (this was the behaviour in igraph 0.5 and before). This parameter also influences how the root vertices are calculated if they are not given. See the root parameter.",
                "root": "the index of the  vertex or  vertices. If this is a non-empty vector then the supplied vertex IDs are used as the s of the trees (or a single tree if the graph is connected). If this is None or an empty list, the  vertices are automatically calculated in such a way so that all other vertices would be reachable from them. Currently, automatic  selection prefers low eccentricity vertices in small graphs (fewer than 500 vertices) and high degree vertices in large graphs. This heuristic may change in future versions. Specify s manually for a consistent output.",
                "rootlevel": "this argument is useful when drawing forests which are not trees. It specifies the level of the root vertices for every tree in the forest."
            },
            "Return": [
                "the calculated layout."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "layout_reingold_tilford_circular",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > layout_reingold_tilford_circular": {
            "Description": "Circular Reingold-Tilford layout for trees.\nThis layout is similar to the Reingold-Tilford layout, but the vertices are placed in a circular way, with the root vertex in the center.\nSee layout_reingold_tilford for the explanation of the parameters.\nReference: EM Reingold, JS Tilford: Tidier Drawings of Trees. IEEE Transactions on Software Engineering 7:22, 223-228, 1981.",
            "Paramters": {},
            "Return": [
                "the calculated layout."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "layout_reingold_tilford",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > layout_star": {
            "Description": "Calculates a star-like layout for the graph.",
            "Paramters": {
                "center": "the ID of the vertex to put in the ",
                "order": "a numeric vector giving the  of the vertices (including the center vertex!). If it is None, the vertices will be placed in increasing vertex ID ."
            },
            "Return": [
                "the calculated layout."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > layout_umap": {
            "Description": "Uniform Manifold Approximation and Projection (UMAP).\nThis layout is a probabilistic algorithm that places vertices that are connected and have a short distance close by in the embedded space.\nReference: L McInnes, J Healy, J Melville: UMAP: Uniform Manifold Approximation and Projection for Dimension Reduction. arXiv:1802.03426.",
            "Paramters": {
                "dist": "ances associated with the graph edges. If None, all edges will be assumed to convey the same ance between the vertices. Either this argument of the weights argument can be set, but not both. It is fine to set neither.",
                "weights": "precomputed edge  if you have them, as an alternative to setting the dist argument. Zero  will be ignored if this argument is set, e.g. if you computed the  via igraph.umap_compute_().",
                "dim": "the desired number of ensions for the layout. =2 means a 2D layout, =3 means a 3D layout.",
                "seed": "if None, uses a random starting layout for the algorithm. If a matrix (list of lists), uses the given matrix as the starting position.",
                "min_dist": "the minimal distance in the embedded space beyond which the probability of being located closeby decreases.",
                "epochs": "the number of  (iterations) the algorithm will iterate over. Accuracy increases with more , at the cost of longer runtimes. Values between 50 and 1000 are typical. Notice that UMAP does not technically converge for symmetry reasons, but a larger number of  should generally give an equivalent or better layout."
            },
            "Return": [
                "the calculated layout.\nPlease note that if distances are set, the graph is usually directed, whereas if weights are precomputed, the graph will be treated as undirected. A special case is when the graph is directed but the precomputed weights are symmetrized in a way only one of each pair of opposite edges has nonzero weight, e.g. as computed by igraph.umap_compute_weights(). For example: weights = igraph.umap_compute_weights(graph, dist) layout = graph.layout_umap(weights=weights)\n"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "igraph.umap_compute_weights()",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > LCF": {
            "Description": "Generates a graph from LCF notation.\nLCF is short for Lederberg-Coxeter-Frucht, it is a concise notation for 3-regular Hamiltonian graphs. It consists of three parameters, the number of vertices in the graph, a list of shifts giving additional edges to a cycle backbone and another integer giving how many times the shifts should be performed. See http://mathworld.wolfram.com/LCFNotation.html for details.",
            "Paramters": {
                "n": "the umber of vertices",
                "shifts": "the  in a list or tuple",
                "repeats": "the number of "
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > linegraph": {
            "Description": "Returns the line graph of the graph.\nThe line graph L(G) of an undirected graph is defined as follows: L(G) has one vertex for each edge in G and two vertices in L(G) are connected iff their corresponding edges in the original graph share an end point.\nThe line graph of a directed graph is slightly different: two vertices are connected by a directed edge iff the target of the first vertex's corresponding edge is the same as the source of the second vertex's corresponding edge.\nEdge i in the original graph will map to vertex i of the line graph.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > list_triangles": {
            "Description": "Lists the triangles of the graph",
            "Paramters": {},
            "Return": [
                "the list of triangles in the graph; each triangle is represented by a tuple of length 3, containing the corresponding vertex IDs."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > maxdegree": {
            "Description": "Returns the maximum degree of a vertex set in the graph.\nThis method accepts a single vertex ID or a list of vertex IDs as a parameter, and returns the degree of the given vertices (in the form of a single integer or a list, depending on the input parameter).",
            "Paramters": {
                "vertices": "a single vertex ID or a list of vertex IDs, or None meaning all the  in the graph.",
                "mode": "the type of degree to be returned (\"out\" for out-degrees, \"in\" IN for in-degrees or \"all\" for the sum of them).",
                "loops": "whether self- should be counted."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > maxflow": {
            "Description": "overridden in igraph.Graph\nReturns the maximum flow between the source and target vertices.\nAttention: this function has a more convenient interface in class Graph, which wraps the result in a Flow object. It is advised to use that.",
            "Paramters": {
                "source": "the  vertex ID",
                "target": "the  vertex ID",
                "capacity": "the  of the edges. It must be a list or a valid attribute name or None. In the latter case, every edge will have the same ."
            },
            "Return": [
                "a tuple containing the following: the value of the maximum flow between the given vertices, the flow value on all the edges, the edge IDs that are part of the corresponding minimum cut, and the vertex IDs on one side of the cut. For directed graphs, the flow value vector gives the flow value on each edge. For undirected graphs, the flow value is positive if the flow goes from the smaller vertex ID to the bigger one and negative if the flow goes from the bigger vertex ID to the smaller."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > maxflow_value": {
            "Description": "Returns the value of the maximum flow between the source and target vertices.",
            "Paramters": {
                "source": "the  vertex ID",
                "target": "the  vertex ID",
                "capacity": "the  of the edges. It must be a list or a valid attribute name or None. In the latter case, every edge will have the same ."
            },
            "Return": [
                "the value of the maximum flow between the given vertices"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > maximal_cliques": {
            "Description": "Returns the maximal cliques of the graph as a list of tuples.\nA maximal clique is a clique which can't be extended by adding any other vertex to it. A maximal clique is not necessarily one of the largest cliques in the graph.",
            "Paramters": {
                "min": "the imum size of maximal cliques to be returned. If zero or negative, no lower bound will be used.",
                "max": "the imum size of imal cliques to be returned. If zero or negative, no upper bound will be used. If nonzero, the size of every imal clique found will be compared to this value and a clique will be returned only if its size is smaller than this limit.",
                "file": "a  object or the name of the  to write the results to. When this argument is None, the maximal cliques will be returned as a list of lists."
            },
            "Return": [
                "the maximal cliques of the graph as a list of lists, or None if the file argument was given.@see: largest_cliques() for the largest cliques."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > maximal_independent_vertex_sets": {
            "Description": "Returns the maximal independent vertex sets of the graph as a list of tuples.\nA maximal independent vertex set is an independent vertex set which can't be extended by adding any other vertex to it. A maximal independent vertex set is not necessarily one of the largest independent vertex sets in the graph.\nReference: S. Tsukiyama, M. Ide, H. Ariyoshi and I. Shirawaka: A new algorithm for generating all the maximal independent sets. SIAM J Computing, 6:505-517, 1977.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "largest_independent_vertex_sets() for the largest independent vertex sets",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > maximum_cardinality_search": {
            "Description": "Conducts a maximum cardinality search on the graph. The function computes a rank alpha for each vertex such that visiting vertices in decreasing rank order corresponds to always choosing the vertex with the most already visited neighbors as the next one to visit.\nMaximum cardinality search is useful in deciding the chordality of a graph: a graph is chordal if and only if any two neighbors of a vertex that are higher in rank than the original vertex are connected to each other.\nThe result of this function can be passed to is_chordal() to speed up the chordality computation if you also need the result of the maximum cardinality search for other purposes.",
            "Paramters": {},
            "Return": [
                "a tuple consisting of the rank vector and its inverse."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > mincut": {
            "Description": "overridden in igraph.Graph\nCalculates the minimum cut between the source and target vertices or within the whole graph.\nThe minimum cut is the minimum set of edges that needs to be removed to separate the source and the target (if they are given) or to disconnect the graph (if the source and target are not given). The minimum is calculated using the weights (capacities) of the edges, so the cut with the minimum total capacity is calculated. For undirected graphs and no source and target, the method uses the Stoer-Wagner algorithm. For a given source and target, the method uses the push-relabel algorithm; see the references below.\nAttention: this function has a more convenient interface in class Graph, which wraps the result in a Cut object. It is advised to use that.\n",
            "Paramters": {
                "source": "the  vertex ID. If None, target must also be {None} and the calculation will be done for the entire graph (i.e. all possible vertex pairs).",
                "target": "the  vertex ID. If None, source must also be {None} and the calculation will be done for the entire graph (i.e. all possible vertex pairs).",
                "capacity": "the  of the edges. It must be a list or a valid attribute name or None. In the latter case, every edge will have the same ."
            },
            "Return": [
                "the value of the minimum cut, the IDs of vertices in the first and second partition, and the IDs of edges in the cut, packed in a 4-tuple"
            ],
            "References": [
                "M. Stoer, F. Wagner: A simple min-cut algorithm. Journal of the ACM 44(4):585-591, 1997.A. V. Goldberg, R. E. Tarjan: A new approach to the maximum-flow problem. Journal of the ACM 35(4):921-940, 1988."
            ],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > mincut_value": {
            "Description": "Returns the minimum cut between the source and target vertices or within the whole graph.",
            "Paramters": {
                "source": "the  vertex ID. If negative, the calculation is done for every vertex except the target and the minimum is returned.",
                "target": "the  vertex ID. If negative, the calculation is done for every vertex except the source and the minimum is returned.",
                "capacity": "the  of the edges. It must be a list or a valid attribute name or None. In the latter case, every edge will have the same ."
            },
            "Return": [
                "the value of the minimum cut between the given vertices"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > minimum_cycle_basis": {
            "Description": "Computes a minimum cycle basis of the graph",
            "Paramters": {
                "cutoff": "when None or negative, a complete minimum cycle basis is returned. Otherwise only those cycles in the result will be part of some minimum cycle basis that are of length 2*\u2009+\u20091 or shorter. Cycles longer than this limit may not be of the smallest possible size. This parameter effectively limits the depth of the BFS tree when computing candidate cycles and may speed up the computation substantially.",
                "complete": "used only when a cutoff is specified, and in this case it specifies whether a  basis is returned (True) or the result will be limited to cycles of length 2*cutoff\u2009+\u20091 or shorter only. This limits computation time, but the result may not span the entire cycle space.",
                "use_cycle_order": "if True, every cycle is returned in natural order: the edge IDs will appear ordered along the cycle. If False, no guarantees are given about the ordering of edge IDs within cycles."
            },
            "Return": [
                "the cycle basis as a list of tuples containing edge IDs"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > minimum_size_separators": {
            "Description": "Returns a list containing all separator vertex sets of minimum size.\nA vertex set is a separator if its removal disconnects the graph. This method lists all the separators for which no smaller separator set exists in the given graph.\nReference: Arkady Kanevsky: Finding all minimum-size separating vertex sets in a graph. Networks 23:533-541, 1993.",
            "Paramters": {},
            "Return": [
                "a list where each item lists the vertex indices of a given separator of minimum size."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > modularity": {
            "Description": "overridden in igraph.Graph\nCalculates the modularity of the graph with respect to some vertex types.\nThe modularity of a graph w.r.t. some division measures how good the division is, or how separated are the different vertex types from each other. It is defined as Q\u2009=\u20091\u2009\u2044\u2009(2m)*sum(Aij\u2009\u2212\u2009gamma*ki*kj\u2009\u2044\u2009(2m)delta(ci,\u2009cj),\u2009i,\u2009j). m is the number of edges, Aij is the element of the A adjacency matrix in row i and column j, ki is the degree of node i, kj is the degree of node j, Ci and cj are the types of the two vertices (i and j), and gamma is a resolution parameter that defaults to 1 for the classical definition of modularity. delta(x,\u2009y) is one iff x\u2009=\u2009y, 0 otherwise.\nIf edge weights are given, the definition of modularity is modified as follows: Aij becomes the weight of the corresponding edge, ki is the total weight of edges incident on vertex i, kj is the total weight of edges incident on vertex j and m is the total edge weight in the graph.\nAttention: method overridden in Graph to allow VertexClustering objects as a parameter. This method is not strictly necessary, since the VertexClustering class provides a variable called modularity.\nReference: MEJ Newman and M Girvan: Finding and evaluating community structure in networks. Phys Rev E 69 026113, 2004.",
            "Paramters": {
                "membership": "the  vector, e.g. the vertex type index for each vertex.",
                "weights": "optional edge  or None if all edges are weighed equally.",
                "resolution": "the  parameter gamma in the formula above. The classical definition of modularity is retrieved when the  parameter is set to 1.",
                "directed": "whether to consider edge directions if the graph is . True will use the  variant of the modularity measure where the in- and out-degrees of nodes are treated separately; False will treat  graphs as un."
            },
            "Return": [
                "the modularity score."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > modularity_matrix": {
            "Description": "Calculates the modularity matrix of the graph.",
            "Paramters": {
                "weights": "optional edge  or None if all edges are weighed equally.",
                "resolution": "the  parameter gamma of the modularity formula. The classical definition of modularity is retrieved when the  parameter is set to 1.",
                "directed": "whether to consider edge directions if the graph is . True will use the  variant of the modularity measure where the in- and out-degrees of nodes are treated separately; False will treat  graphs as un."
            },
            "Return": [
                "the modularity matrix as a list of lists."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > motifs_randesu": {
            "Description": "Counts the number of motifs in the graph\nMotifs are small subgraphs of a given structure in a graph. It is argued that the motif profile (ie. the number of different motifs in the graph) is characteristic for different types of networks and network function is related to the motifs in the graph.\nCurrently we support motifs of size 3 and 4 for directed graphs, and motifs of size 3, 4, 5 or 6 for undirected graphs.\nIn a big network the total number of motifs can be very large, so it takes a lot of time to find all of them. In such cases, a sampling method can be used. This function is capable of doing sampling via the cut_prob argument. This argument gives the probability that a branch of the motif search tree will not be explored.\nReference: S. Wernicke and F. Rasche: FANMOD: a tool for fast network motif detection, Bioinformatics 22(9), 1152--1153, 2006.",
            "Paramters": {
                "size": "the  of the motifs",
                "cut_prob": "the cut probabilities for different levels of the search tree. This must be a list of length size or None to find all motifs.",
                "callback": "None or a callable that will be called for every motif found in the graph. The callable must accept three parameters: the graph itself, the list of vertices in the motif and the isomorphism class of the motif (see isoclass()). The search will stop when the  returns an object with a non-zero truth value or raises an exception."
            },
            "Return": [
                "the list of motifs if callback is None, or None otherwise"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "Graph.motifs_randesu_no()",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > motifs_randesu_estimate": {
            "Description": "Counts the total number of motifs in the graph\nMotifs are small subgraphs of a given structure in a graph. This function estimates the total number of motifs in a graph without assigning isomorphism classes to them by extrapolating from a random sample of vertices.\nCurrently we support motifs of size 3 and 4 for directed graphs, and motifs of size 3, 4, 5 or 6 for undirected graphs.\nReference: S. Wernicke and F. Rasche: FANMOD: a tool for fast network motif detection, Bioinformatics 22(9), 1152--1153, 2006.",
            "Paramters": {
                "size": "the  of the motifs",
                "cut_prob": "the cut probabilities for different levels of the search tree. This must be a list of length size or None to find all motifs.",
                "sample": "the size of the  or the vertex IDs of the vertices to be used for sampling."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "Graph.motifs_randesu()",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > motifs_randesu_no": {
            "Description": "Counts the total number of motifs in the graph\nMotifs are small subgraphs of a given structure in a graph. This function counts the total number of motifs in a graph without assigning isomorphism classes to them.\nCurrently we support motifs of size 3 and 4 for directed graphs, and motifs of size 3, 4, 5 or 6 for undirected graphs.\nReference: S. Wernicke and F. Rasche: FANMOD: a tool for fast network motif detection, Bioinformatics 22(9), 1152--1153, 2006.",
            "Paramters": {
                "size": "the  of the motifs",
                "cut_prob": "the cut probabilities for different levels of the search tree. This must be a list of length size or None to find all motifs."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "Graph.motifs_randesu()",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > neighborhood": {
            "Description": "For each vertex specified by vertices, returns the vertices reachable from that vertex in at most order steps. If mindist is larger than zero, vertices that are reachable in less than mindist steps are excluded.",
            "Paramters": {
                "vertices": "a single vertex ID or a list of vertex IDs, or None meaning all the  in the graph.",
                "order": "the  of the neighborhood, i.e. the maximum number of steps to take from the seed vertex.",
                "mode": "specifies how to take into account the direction of the edges if a directed graph is analyzed. \"out\" means that only the outgoing edges are followed, so all vertices reachable from the source vertex in at most order steps are counted. \"in\" means that only the incoming edges are followed (in reverse direction of course), so all vertices from which the source vertex is reachable in at most order steps are counted. \"all\" treats directed edges as undirected.",
                "mindist": "the minimum distance required to include a vertex in the result. If this is one, the seed vertex is not included. If this is two, the direct neighbors of the seed vertex are not included either, and so on."
            },
            "Return": [
                "a single list specifying the neighborhood if vertices was an integer specifying a single vertex index, or a list of lists if vertices was a list or None."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > neighborhood_size": {
            "Description": "For each vertex specified by vertices, returns the number of vertices reachable from that vertex in at most order steps. If mindist is larger than zero, vertices that are reachable in less than mindist steps are excluded.",
            "Paramters": {
                "vertices": "a single vertex ID or a list of vertex IDs, or None meaning all the  in the graph.",
                "order": "the  of the neighborhood, i.e. the maximum number of steps to take from the seed vertex.",
                "mode": "specifies how to take into account the direction of the edges if a directed graph is analyzed. \"out\" means that only the outgoing edges are followed, so all vertices reachable from the source vertex in at most order steps are counted. \"in\" means that only the incoming edges are followed (in reverse direction of course), so all vertices from which the source vertex is reachable in at most order steps are counted. \"all\" treats directed edges as undirected.",
                "mindist": "the minimum distance required to include a vertex in the result. If this is one, the seed vertex is not counted. If this is two, the direct neighbors of the seed vertex are not counted either, and so on."
            },
            "Return": [
                "a single number specifying the neighborhood size if vertices was an integer specifying a single vertex index, or a list of sizes if vertices was a list or None."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > neighbors": {
            "Description": "Returns adjacent vertices to a given vertex.",
            "Paramters": {
                "vertex": "a  ID",
                "mode": "whether to return only successors (\"out\"), predecessors (\"in\") or both (\"all\"). Ignored for undirected graphs."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > path_length_hist": {
            "Description": "overridden in igraph.Graph\nCalculates the path length histogram of the graph Attention: this function is wrapped in a more convenient syntax in the derived class Graph. It is advised to use that instead of this version.",
            "Paramters": {
                "directed": "whether to consider  paths"
            },
            "Return": [
                "a tuple. The first item of the tuple is a list of path lengths, the ith element of the list contains the number of paths with length i\u2009+\u20091. The second item contains the number of unconnected vertex pairs as a float (since it might not fit into an integer)"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > permute_vertices": {
            "Description": "Permutes the vertices of the graph according to the given permutation and returns the new graph.\nVertex k of the original graph will become vertex permutation[k] in the new graph. No validity checks are performed on the permutation vector.",
            "Paramters": {},
            "Return": [
                "the new graph"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > personalized_pagerank": {
            "Description": "Calculates the personalized PageRank values of a graph.\nThe personalized PageRank calculation is similar to the PageRank calculation, but the random walk is reset to a non-uniform distribution over the vertices in every step with probability 1\u2009\u2212\u2009damping instead of a uniform distribution.",
            "Paramters": {
                "vertices": "the indices of the  being queried. None means all of the .",
                "directed": "whether to consider  paths.",
                "damping": "the  factor.",
                "reset": "the distribution over the vertices to be used when ting the random walk. Can be a sequence, an iterable or a vertex attribute name as long as they return a list of floats whose length is equal to the number of vertices. If None, a uniform distribution is assumed, which makes the method equivalent to the original PageRank algorithm.",
                "reset_vertices": "an alternative way to specify the distribution over the vertices to be used when resetting the random walk. Simply supply a list of vertex IDs here, or a VertexSeq or a Vertex. Resetting will take place using a uniform distribution over the specified vertices.",
                "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name.",
                "arpack_options": "an ARPACKOptions object used to fine-tune the ARPACK eigenvector calculation. If omitted, the module-level variable called  is used. This argument is ignored if not the ARPACK implementation is used, see the implementation argument.",
                "implementation": "which  to use to solve the PageRank eigenproblem. Possible values are:\"prpack\": use the PRPACK library. This is a new  in igraph 0.7\"arpack\": use the ARPACK library. This  was used from version 0.5, until version 0.7."
            },
            "Return": [
                "a list with the personalized PageRank values of the specified vertices."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > predecessors": {
            "Description": "Returns the predecessors of a given vertex.\nEquivalent to calling the neighbors() method with type=\"in\".",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > Preference": {
            "Description": "Generates a graph based on vertex types and connection probabilities.\nThis is practically the non-growing variant of Establishment. A given number of vertices are generated. Every vertex is assigned to a vertex type according to the given type probabilities. Finally, every vertex pair is evaluated and an edge is created between them with a probability depending on the types of the vertices involved.",
            "Paramters": {
                "n": "the umber of vertices i the graph",
                "type_dist": "list giving the distribution of vertex types",
                "pref_matrix": "matrix giving the connection probabilities for different vertex types.",
                "attribute": "the vertex  name used to store the vertex types. If None, vertex types are not stored.",
                "directed": "whether to generate a  graph.",
                "loops": "whether loop edges are allowed."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > Prufer": {
            "Description": "Generates a tree from its Pr\u00fcfer sequence.\nA Pr\u00fcfer sequence is a unique sequence of integers associated with a labelled tree. A tree on n vertices can be represented by a sequence of n\u2009\u2212\u20092 integers, each between 0 and n\u2009\u2212\u20091 (inclusive).",
            "Paramters": {
                "seq": "the Pr\u00fcfer uence as an iterable of integers"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > radius": {
            "Description": "Calculates the radius of the graph.\nThe radius of a graph is defined as the minimum eccentricity of its vertices (see eccentricity()).",
            "Paramters": {
                "mode": "what kind of paths to consider for the calculation in case of directed graphs. OUT considers paths that follow edge directions, IN considers paths that follow the opposite edge directions, ALL ignores edge directions. The argument is ignored for undirected graphs.",
                "weights": "a list containing the edge . It can also be an attribute name (edge  are retrieved from the given attribute) or None (all edges have equal weight)."
            },
            "Return": [
                "the radius"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "eccentricity()",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > random_walk": {
            "Description": "Performs a random walk of a given length from a given node.",
            "Paramters": {
                "start": "the ing vertex of the walk",
                "steps": "the number of  that the random walk should take",
                "mode": "whether to follow outbound edges only (\"out\"), inbound edges only (\"in\") or both (\"all\"). Ignored for undirected graphs.@param stuck: what to do when the random walk gets stuck. \"return\" returns a partial random walk; \"error\" throws an exception.",
                "stuck": "Undocumented",
                "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name.",
                "return_type": "what to return. It can be \"vertices\" (default), then the function returns a list of the vertex ids visited; \"edges\", then the function returns a list of edge ids visited; or \"both\", then the function return a dictionary with keys \"vertices\" and \"edges\"."
            },
            "Return": [
                "a random walk that starts from the given vertex and has at most the given length (shorter if the random walk got stuck)."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > Read_DIMACS": {
            "Description": "overridden in igraph.Graph\nReads a graph from a file conforming to the DIMACS minimum-cost flow file format.\nFor the exact description of the format, see http://lpsolve.sourceforge.net/5.5/DIMACS.htm\nRestrictions compared to the official description of the format:igraph's DIMACS reader requires only three fields in an arc definition, describing the edge's source and target node and its capacity.Source vertices are identified by 's' in the FLOW field, target vertices are identified by 't'.Node indices start from 1. Only a single source and target node is allowed.",
            "Paramters": {
                "f": "the name o the ile or a Python ile handle",
                "directed": "whether the generated graph should be ."
            },
            "Return": [
                "the generated graph, the source and the target of the flow and the edge capacities in a tuple"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > Read_DL": {
            "Description": "Reads an UCINET DL file and creates a graph based on it.",
            "Paramters": {
                "f": "the name o the ile or a Python ile handle",
                "directed": "whether the generated graph should be ."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > Read_Edgelist": {
            "Description": "Reads an edge list from a file and creates a graph based on it.\nPlease note that the vertex indices are zero-based. A vertex of zero degree will be created for every integer that is in range but does not appear in the edgelist.",
            "Paramters": {
                "f": "the name o the ile or a Python ile handle",
                "directed": "whether the generated graph should be ."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > Read_GML": {
            "Description": "Reads a GML file and creates a graph based on it.",
            "Paramters": {
                "f": "the name o the ile or a Python ile handle"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > Read_GraphDB": {
            "Description": "Reads a GraphDB format file and creates a graph based on it.\nGraphDB is a binary format, used in the graph database for isomorphism testing (see http://amalfi.dis.unina.it/graph/).",
            "Paramters": {
                "f": "the name o the ile or a Python ile handle",
                "directed": "whether the generated graph should be ."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > Read_GraphML": {
            "Description": "Reads a GraphML format file and creates a graph based on it.",
            "Paramters": {
                "f": "the name o the ile or a Python ile handle",
                "index": "if the GraphML file contains multiple graphs, specifies the one that should be loaded. Graph indices start from zero, so if you want to load the first graph, specify 0 here."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > Read_Lgl": {
            "Description": "Reads an .lgl file used by LGL.\nIt is also useful for creating graphs from \"named\" (and optionally weighted) edge lists.\nThis format is used by the Large Graph Layout program. See the documentation of LGL regarding the exact format description.\nLGL originally cannot deal with graphs containing multiple or loop edges, but this condition is not checked here, as igraph is happy with these.",
            "Paramters": {
                "f": "the name o the ile or a Python ile handle",
                "names": "If True, the vertex  are added as a vertex attribute called 'name'.",
                "weights": "If True, the edge  are added as an edge attribute called 'weight', even if there are no  in the file. If False, the edge  are never added, even if they are present. \"auto\" or \"if_present\" means that  are added if there is at least one weighted edge in the input file, but they are not added otherwise.",
                "directed": "whether the graph being created should be "
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > Read_Ncol": {
            "Description": "Reads an .ncol file used by LGL.\nIt is also useful for creating graphs from \"named\" (and optionally weighted) edge lists.\nThis format is used by the Large Graph Layout program. See the repository of LGL for more information.\nLGL originally cannot deal with graphs containing multiple or loop edges, but this condition is not checked here, as igraph is happy with these.",
            "Paramters": {
                "f": "the name o the ile or a Python ile handle",
                "names": "If True, the vertex  are added as a vertex attribute called 'name'.",
                "weights": "If True, the edge  are added as an edge attribute called 'weight', even if there are no  in the file. If False, the edge  are never added, even if they are present. \"auto\" or \"if_present\" means that  are added if there is at least one weighted edge in the input file, but they are not added otherwise.",
                "directed": "whether the graph being created should be "
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > Read_Pajek": {
            "Description": "Reads a file in the Pajek format and creates a graph based on it. Only Pajek network files (.net extension) are supported, not project files (.paj).",
            "Paramters": {
                "f": "the name o the ile or a Python ile handle"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > Realize_Bipartite_Degree_Sequence": {
            "Description": "Generates a bipartite graph from the degree sequences of its partitions.\nThis method implements a Havel-Hakimi style graph construction for biparite graphs. In each step, the algorithm picks two vertices in a deterministic manner and connects them. The way the vertices are picked is defined by the method parameter. The allowed edge types (i.e. whether multi-edges are allowed) are specified in the allowed_edge_types parameter. Self-loops are never created, since a graph with self-loops is not bipartite.",
            "Paramters": {
                "degrees1": "the degrees of the first partition.",
                "degrees2": "the degrees of the second partition.",
                "allowed_edge_types": "controls whether multi-edges are allowed during the generation process. Possible values are:\"simple\": simple graphs (no multi-edges)\"multi\": multi-edges allowed",
                "method": "controls how the vertices are selected during the generation process. Possible values are:smallest: The vertex with smallest remaining degree first.largest: The vertex with the largest remaining degree first.index: The vertices are selected in order of their index.The smallest smallest  is guaranteed to produce a connected graph, if one exists."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > Realize_Degree_Sequence": {
            "Description": "Generates a graph from a degree sequence.\nThis method implements a Havel-Hakimi style graph construction from a given degree sequence. In each step, the algorithm picks two vertices in a deterministic manner and connects them. The way the vertices are picked is defined by the method parameter. The allowed edge types (i.e. whether multiple or loop edges are allowed) are specified in the allowed_edge_types parameter.\n",
            "Paramters": {
                "out": "the degree sequence of an undirected graph (if in_=None), or the -degree sequence of a directed graph.",
                "in_": "None to generate an undirected graph, the in-degree sequence to generate a directed graph.",
                "allowed_edge_types": "controls whether loops or multi-edges are allowed during the generation process. Note that not all combinations are supported for all types of graphs; an exception will be raised for unsupported combinations. Possible values are:\"simple\": simple graphs (no self-loops, no multi-edges)\"loops\": single self-loops allowed, but not multi-edges\"multi\": multi-edges allowed, but not self-loops\"all\": multi-edges and self-loops allowed",
                "method": "controls how the vertices are selected during the generation process. Possible values are:smallest: The vertex with smallest remaining degree first.largest: The vertex with the largest remaining degree first.index: The vertices are selected in order of their index.In the undirected case, smallest is guaranteed to produce a connected graph. See Horv\u00e1t and Modes (2021) for details."
            },
            "Return": [],
            "References": [
                "V. Havel, Pozn\u00e1mka o existenci kone\u010dn\u00fdch graf\u016f (A remark on the existence of finite graphs), \u010casopis pro p\u011bstov\u00e1n\u00ed matematiky 80, 477-480 (1955). http://eudml.org/doc/19050S. L. Hakimi, On Realizability of a Set of Integers as Degrees of the Vertices of a Linear Graph, Journal of the SIAM 10, 3 (1962). https://www.jstor.org/stable/2098770D. J. Kleitman and D. L. Wang, Algorithms for Constructing Graphs and Digraphs with Given Valences and Factors, Discrete Mathematics 6, 1 (1973). https://doi.org/10.1016/0012-365X%2873%2990037-XSz. Horv\u00e1t and C. D. Modes, Connectedness matters: construction and exact random sampling of connected networks (2021). https://doi.org/10.1088/2632-072X/abced5"
            ],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > Recent_Degree": {
            "Description": "Generates a graph based on a stochastic model where the probability of an edge gaining a new node is proportional to the edges gained in a given time window.",
            "Paramters": {
                "n": "the umber of vertices",
                "m": "either the nuber of outgoing edges generated for each vertex or a list containing the nuber of outgoing edges for each vertex explicitly.",
                "window": "size of the  in time steps",
                "outpref": "True if the out-degree of a given vertex should also increase its citation probability (as well as its in-degree), but it defaults to False.",
                "directed": "True if the generated graph should be  (default: False).",
                "power": "the  constant of the nonlinear model. It can be omitted, and in this case the usual linear model will be used."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > reciprocity": {
            "Description": "Reciprocity defines the proportion of mutual connections in a directed graph. It is most commonly defined as the probability that the opposite counterpart of a directed edge is also included in the graph. This measure is calculated if mode is \"default\".\nPrior to igraph 0.6, another measure was implemented, defined as the probability of mutual connection between a vertex pair if we know that there is a (possibly non-mutual) connection between them. In other words, (unordered) vertex pairs are classified into three groups: (1) disconnected, (2) non-reciprocally connected and (3) reciprocally connected. The result is the size of group (3), divided by the sum of sizes of groups (2) and (3). This measure is calculated if mode is \"ratio\".",
            "Paramters": {
                "ignore_loops": "whether loop edges should be ignored.",
                "mode": "the algorithm to use to calculate the reciprocity; see above for more details."
            },
            "Return": [
                "the reciprocity of the graph"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > reverse_edges": {
            "Description": "Reverses the direction of some edges in the graph.\nThis function is a no-op for undirected graphs.",
            "Paramters": {
                "es": "the list of edg to be reversed. Edg are identifed by edge IDs. EdgeSeq objects are also accepted here. When omitted, all edg will be reversed."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > rewire": {
            "Description": "Randomly rewires the graph while preserving the degree distribution.\nPlease note that the rewiring is done \"in-place\", so the original graph will be modified. If you want to preserve the original graph, use the copy method before.",
            "Paramters": {
                "n": "the umber of rewirig trials.",
                "mode": "the rewiring algorithm to use. It can either be \"simple\" or \"loops\"; the former does not create or destroy loop edges while the latter does."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > rewire_edges": {
            "Description": "Rewires the edges of a graph with constant probability.\nEach endpoint of each edge of the graph will be rewired with a constant probability, given in the first argument.\nPlease note that the rewiring is done \"in-place\", so the original graph will be modified. If you want to preserve the original graph, use the copy method before.",
            "Paramters": {
                "prob": "rewiring ability",
                "loops": "whether the algorithm is allowed to create loop edges",
                "multiple": "whether the algorithm is allowed to create  edges."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > Ring": {
            "Description": "Generates a ring graph.",
            "Paramters": {
                "n": "the umber of vertices i the rig",
                "directed": "whether to create a  ring.",
                "mutual": "whether to create  edges in a directed ring.",
                "circular": "whether to create a closed ring."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > SBM": {
            "Description": "Generates a graph based on a stochastic block model.\nA given number of vertices are generated. Every vertex is assigned to a vertex type according to the given block sizes. Vertices of the same type will be assigned consecutive vertex IDs. Finally, every vertex pair is evaluated and an edge is created between them with a probability depending on the types of the vertices involved. The probabilities are taken from the preference matrix.",
            "Paramters": {
                "n": "the umber of vertices i the graph",
                "pref_matrix": "matrix giving the connection probabilities for different vertex types.",
                "block_sizes": "list giving the number of vertices in each block; must sum up to n.",
                "directed": "whether to generate a  graph.",
                "loops": "whether loop edges are allowed."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > similarity_dice": {
            "Description": "Dice similarity coefficient of vertices.\nThe Dice similarity coefficient of two vertices is twice the number of their common neighbors divided by the sum of their degrees. This coefficient is very similar to the Jaccard coefficient, but usually gives higher similarities than its counterpart.",
            "Paramters": {
                "vertices": "the  to be analysed. If None and pairs is also None, all  will be considered.",
                "pairs": "the vertex  to be analysed. If this is given, vertices must be None, and the similarity values will be calculated only for the given . Vertex  must be specified as tuples of vertex IDs.",
                "mode": "which neighbors should be considered for directed graphs. Can be \"all\", \"in\" or \"out\", ignored for undirected graphs.",
                "loops": "whether vertices should be considered adjacent to themselves. Setting this to True assumes a loop edge for all vertices even if none is present in the graph. Setting this to False may result in strange results: nonadjacent vertices may have larger similarities compared to the case when an edge is added between them -- however, this might be exactly the result you want to get."
            },
            "Return": [
                "the pairwise similarity coefficients for the vertices specified, in the form of a matrix if pairs is None or in the form of a list if pairs is not None."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > similarity_inverse_log_weighted": {
            "Description": "Inverse log-weighted similarity coefficient of vertices.\nEach vertex is assigned a weight which is 1 / log(degree). The log-weighted similarity of two vertices is the sum of the weights of their common neighbors.\nNote that the presence of loop edges may yield counter-intuitive results. A node with a loop edge is considered to be a neighbor of itself twice (because there are two edge stems incident on the node). Adding a loop edge to a node may decrease its similarity to other nodes, but it may also increase it. For instance, if nodes A and B are connected but share no common neighbors, their similarity is zero. However, if a loop edge is added to B, then B itself becomes a common neighbor of A and B and thus the similarity of A and B will be increased. Consider removing loop edges explicitly before invoking this function using Graph.simplify().",
            "Paramters": {
                "vertices": "the  to be analysed. If None, all  will be considered.",
                "mode": "which neighbors should be considered for directed graphs. Can be \"all\", \"in\" or \"out\", ignored for undirected graphs. \"in\" means that the weights are determined by the out-degrees, \"out\" means that the weights are determined by the in-degrees."
            },
            "Return": [
                "the pairwise similarity coefficients for the vertices specified, in the form of a matrix (list of lists)."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > similarity_jaccard": {
            "Description": "Jaccard similarity coefficient of vertices.\nThe Jaccard similarity coefficient of two vertices is the number of their common neighbors divided by the number of vertices that are adjacent to at least one of them.",
            "Paramters": {
                "vertices": "the  to be analysed. If None and pairs is also None, all  will be considered.",
                "pairs": "the vertex  to be analysed. If this is given, vertices must be None, and the similarity values will be calculated only for the given . Vertex  must be specified as tuples of vertex IDs.",
                "mode": "which neighbors should be considered for directed graphs. Can be \"all\", \"in\" or \"out\", ignored for undirected graphs.",
                "loops": "whether vertices should be considered adjacent to themselves. Setting this to True assumes a loop edge for all vertices even if none is present in the graph. Setting this to False may result in strange results: nonadjacent vertices may have larger similarities compared to the case when an edge is added between them -- however, this might be exactly the result you want to get."
            },
            "Return": [
                "the pairwise similarity coefficients for the vertices specified, in the form of a matrix if pairs is None or in the form of a list if pairs is not None."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > simplify": {
            "Description": "Simplifies a graph by removing self-loops and/or multiple edges.\nFor example, suppose you have a graph with an edge attribute named weight. graph.simplify(combine_edges=max) will take the maximum of the weights of multiple edges and assign that weight to the collapsed edge. graph.simplify(combine_edges=sum) will take the sum of the weights. You can also write graph.simplify(combine_edges=dict(weight=\"sum\")) or graph.simplify(combine_edges=dict(weight=sum)), since sum is recognised both as a Python built-in function and as a string constant.",
            "Paramters": {
                "multiple": "whether to remove  edges.",
                "loops": "whether to remove .",
                "combine_edges": "specifies how to combine the attributes of multiple edges between the same pair of vertices into a single attribute. If it is None, only one of the edges will be kept and all the attributes will be lost. If it is a function, the attributes of multiple edges will be collected and passed on to that function which will return the new attribute value that has to be assigned to the single collapsed edge. It can also be one of the following string constants:\"ignore\": all the edge attributes will be ignored.\"sum\": the sum of the edge attribute values will be used for the new edge.\"product\": the product of the edge attribute values will be used for the new edge.\"mean\": the mean of the edge attribute values will be used for the new edge.\"median\": the median of the edge attribute values will be used for the new edge.\"min\": the minimum of the edge attribute values will be used for the new edge.\"max\": the maximum of the edge attribute values will be used for the new edge.\"first\": the attribute value of the first edge in the collapsed set will be used for the new edge.\"last\": the attribute value of the last edge in the collapsed set will be used for the new edge.\"random\": a randomly selected value will be used for the new edge\"concat\": the attribute values will be concatenated for the new edge.You can also use a dict mapping edge attribute names to functions or the above string constants if you want to make the behaviour of the simplification process depend on the name of the attribute. None is a special key in this dict, its value will be used for all the attributes not specified explicitly in the dictionary."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > st_mincut": {
            "Description": "overridden in igraph.Graph\nCalculates the minimum cut between the source and target vertices in a graph.\nAttention: this function has a more convenient interface in class Graph, which wraps the result in a list of Cut objects. It is advised to use that.",
            "Paramters": {
                "source": "the  vertex ID",
                "target": "the  vertex ID",
                "capacity": "the  of the edges. It must be a list or a valid attribute name or None. In the latter case, every edge will have the same ."
            },
            "Return": [
                "the value of the minimum cut, the IDs of vertices in the first and second partition, and the IDs of edges in the cut, packed in a 4-tuple"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > Star": {
            "Description": "Generates a star graph.",
            "Paramters": {
                "n": "the umber of vertices i the graph",
                "mode": "Gives the type of the star graph to create. Should be either \"in\", \"out\", \"mutual\" or \"undirected\"",
                "center": "Vertex ID for the central vertex in the star."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > Static_Fitness": {
            "Description": "Generates a non-growing graph with edge probabilities proportional to node fitnesses.\nThe algorithm randomly selects vertex pairs and connects them until the given number of edges are created. Each vertex is selected with a probability proportional to its fitness; for directed graphs, a vertex is selected as a source proportional to its out-fitness and as a target proportional to its in-fitness.",
            "Paramters": {
                "m": "the nuber of edges in the graph",
                "fitness_out": "a numeric vector with non-negative entries, one for each vertex. These values represent the fitness scores (out-fitness scores for directed graphs). fitness is an alias of this keyword argument.",
                "fitness_in": "a numeric vector with non-negative entries, one for each vertex. These values represent the in-fitness scores for directed graphs. For undirected graphs, this argument must be None.",
                "loops": "whether loop edges are allowed.",
                "multiple": "whether  edges are allowed."
            },
            "Return": [
                "a directed or undirected graph with the prescribed power-law degree distributions."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > Static_Power_Law": {
            "Description": "Generates a non-growing graph with prescribed power-law degree distributions.\n",
            "Paramters": {
                "n": "the umber of vertices i the graph",
                "m": "the nuber of edges in the graph",
                "exponent_out": "the exponent of the out-degree distribution, which must be between 2 and infinity (inclusive). When exponent_in is not given or negative, the graph will be undirected and this parameter specifies the degree distribution. exponent is an alias to this keyword argument.",
                "exponent_in": "the exponent of the in-degree distribution, which must be between 2 and infinity (inclusive) It can also be negative, in which case an undirected graph will be generated.",
                "loops": "whether loop edges are allowed.",
                "multiple": "whether  edges are allowed.",
                "finite_size_correction": "whether to apply a finite-size correction to the generated fitness values for exponents less than 3. See the paper of Cho et al for more details."
            },
            "Return": [
                "a directed or undirected graph with the prescribed power-law degree distributions."
            ],
            "References": [
                "Goh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.Cho YS, Kim JS, Park J, Kahng B, Kim D: Percolation transitions in scale-free networks under the Achlioptas process. Phys Rev Lett 103:135702, 2009."
            ],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > strength": {
            "Description": "Returns the strength (weighted degree) of some vertices from the graph\nThis method accepts a single vertex ID or a list of vertex IDs as a parameter, and returns the strength (that is, the sum of the weights of all incident edges) of the given vertices (in the form of a single integer or a list, depending on the input parameter).",
            "Paramters": {
                "vertices": "a single vertex ID or a list of vertex IDs",
                "mode": "the type of degree to be returned (\"out\" for out-degrees, \"in\" for in-degrees or \"all\" for the sum of them).",
                "loops": "whether self- should be counted.",
                "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name. ``None`` means to treat the graph as unweighted, falling back to ordinary degree calculations."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > subcomponent": {
            "Description": "Determines the indices of vertices which are in the same component as a given vertex.",
            "Paramters": {
                "v": "the index of the ertex used as the source/destination",
                "mode": "if equals to \"in\", returns the vertex IDs from where the given vertex can be reached. If equals to \"out\", returns the vertex IDs which are reachable from the given vertex. If equals to \"all\", returns all vertices within the same component as the given vertex, ignoring edge directions. Note that this is not equal to calculating the union of the results of \"in\" and \"out\"."
            },
            "Return": [
                "the indices of vertices which are in the same component as a given vertex."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > subgraph_edges": {
            "Description": "Returns a subgraph spanned by the given edges.",
            "Paramters": {
                "edges": "a list containing the edge IDs which should be included in the result.",
                "delete_vertices": "if True, vertices not incident on any of the specified edges will be deleted from the result. If False, all vertices will be kept."
            },
            "Return": [
                "the subgraph"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > subisomorphic_lad": {
            "Description": "Checks whether a subgraph of the graph is isomorphic to another graph.\nThe optional domains argument may be used to restrict vertices that may match each other. You can also specify whether you are interested in induced subgraphs only or not.",
            "Paramters": {
                "other": "the pattern graph we are looking for in the graph.",
                "domains": "a list of lists, one sublist belonging to each vertex in the template graph. Sublist i contains the indices of the vertices in the original graph that may match vertex i in the template graph. None means that every vertex may match every other vertex.",
                "induced": "whether to consider  subgraphs only.",
                "time_limit": "an optimal time limit in seconds. Only the integral part of this number is taken into account. If the time limit is exceeded, the method will throw an exception.",
                "return_mapping": "when True, the function will return a tuple, where the first element is a boolean denoting whether a subisomorphism has been found or not, and the second element describes the mapping of the vertices from the template graph to the original graph. When False, only the boolean is returned."
            },
            "Return": [
                "if no mapping is calculated, the result is True if the graph contains a subgraph that is isomorphic to the given template, False otherwise. If the mapping is calculated, the result is a tuple, the first element being the above mentioned boolean, and the second element being the mapping from the target to the original graph."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > subisomorphic_vf2": {
            "Description": "Checks whether a subgraph of the graph is isomorphic to another graph.\nVertex and edge colors may be used to restrict the isomorphisms, as only vertices and edges with the same color will be allowed to match each other.",
            "Paramters": {
                "other": "the  graph with which we want to compare the graph.",
                "color1": "optional vector storing the coloring of the vertices of the first graph. If None, all vertices have the same color.",
                "color2": "optional vector storing the coloring of the vertices of the second graph. If None, all vertices have the same color.",
                "edge_color1": "optional vector storing the coloring of the edges of the first graph. If None, all edges have the same color.",
                "edge_color2": "optional vector storing the coloring of the edges of the second graph. If None, all edges have the same color.",
                "return_mapping_12": "if True, calculates the mapping which maps the vertices of the first graph to the second. The mapping can contain -1 if a given node is not mapped.",
                "return_mapping_21": "if True, calculates the mapping which maps the vertices of the second graph to the first. The mapping can contain -1 if a given node is not mapped.",
                "callback": "if not None, the subisomorphism search will not stop at the first match; it will call this  function instead for every subisomorphism found. The  function must accept four arguments: the first graph, the second graph, a mapping from the nodes of the first graph to the second, and a mapping from the nodes of the second graph to the first. The function must return True if the search should continue or False otherwise.",
                "node_compat_fn": "a function that receives the two graphs and two node indices (one from the first graph, one from the second graph) and returns True if the nodes given by the two indices are compatible (i.e. they could be matched to each other) or False otherwise. This can be used to restrict the set of isomorphisms based on node-specific criteria that are too complicated to be represented by node color vectors (i.e. the color1 and color2 parameters). None means that every node is compatible with every other node.",
                "edge_compat_fn": "a function that receives the two graphs and two edge indices (one from the first graph, one from the second graph) and returns True if the edges given by the two indices are compatible (i.e. they could be matched to each other) or False otherwise. This can be used to restrict the set of isomorphisms based on edge-specific criteria that are too complicated to be represented by edge color vectors (i.e. the edge_color1 and edge_color2 parameters). None means that every edge is compatible with every other node."
            },
            "Return": [
                "if no mapping is calculated, the result is True if the graph contains a subgraph that's isomorphic to the given one, False otherwise. If any or both mappings are calculated, the result is a 3-tuple, the first element being the above mentioned boolean, the second element being the 1 -> 2 mapping and the third element being the 2 -> 1 mapping. If the corresponding mapping was not calculated, None is returned in the appropriate element of the 3-tuple."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > successors": {
            "Description": "Returns the successors of a given vertex.\nEquivalent to calling the neighbors() method with type=\"out\".",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > to_directed": {
            "Description": "Converts an undirected graph to directed.",
            "Paramters": {
                "mode": "specifies how to convert undirected edges into directed ones. True or \"mutual\" creates a mutual edge pair for each undirected edge. False or \"arbitrary\" picks an arbitrary (but deterministic) edge direction for each edge. \"random\" picks a random direction for each edge. \"acyclic\" picks the edge directions in a way that the resulting graph will be acyclic if there were no self-loops in the original graph."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > to_prufer": {
            "Description": "Converts a tree graph into a Pr\u00fcfer sequence.",
            "Paramters": {},
            "Return": [
                "the Pr\u00fcfer sequence as a list"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > to_undirected": {
            "Description": "Converts a directed graph to undirected.",
            "Paramters": {
                "mode": "specifies what to do with multiple directed edges going between the same vertex pair. True or \"collapse\" means that only a single edge should be created from multiple directed edges. False or \"each\" means that every edge will be kept (with the arrowheads removed). \"mutual\" creates one undirected edge for each mutual directed edge pair.",
                "combine_edges": "specifies how to combine the attributes of multiple edges between the same pair of vertices into a single attribute. See simplify() for more details."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > topological_sorting": {
            "Description": "Calculates a possible topological sorting of the graph.\nReturns a partial sorting and issues a warning if the graph is not a directed acyclic graph.",
            "Paramters": {
                "mode": "if \"out\", vertices are returned according to the forward topological order -- all vertices come before their successors. If \"in\", all vertices come before their ancestors."
            },
            "Return": [
                "a possible topological ordering as a list"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > transitivity_avglocal_undirected": {
            "Description": "overridden in igraph.Graph\nCalculates the average of the vertex transitivities of the graph.\nThe transitivity measures the probability that two neighbors of a vertex are connected. In case of the average local transitivity, this probability is calculated for each vertex and then the average is taken. Vertices with less than two neighbors require special treatment, they will either be left out from the calculation or they will be considered as having zero transitivity, depending on the mode parameter.\nNote that this measure is different from the global transitivity measure (see transitivity_undirected()) as it simply takes the average local transitivity across the whole network.\nReference: D. J. Watts and S. Strogatz: Collective dynamics of small-world networks. Nature 393(6884):440-442, 1998.",
            "Paramters": {
                "mode": "defines how to treat vertices with degree less than two. If TRANSITIVITT_ZERO or \"zero\", these vertices will have zero transitivity. If TRANSITIVITY_NAN or \"nan\", these vertices will be excluded from the average."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "transitivity_undirected(), transitivity_local_undirected()",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > transitivity_local_undirected": {
            "Description": "Calculates the local transitivity (clustering coefficient) of the given vertices in the graph.\nThe transitivity measures the probability that two neighbors of a vertex are connected. In case of the local transitivity, this probability is calculated separately for each vertex.\nNote that this measure is different from the global transitivity measure (see transitivity_undirected()) as it calculates a transitivity value for each vertex individually.\nThe traditional local transitivity measure applies for unweighted graphs only. When the weights argument is given, this function calculates the weighted local transitivity proposed by Barrat et al (see references).\n",
            "Paramters": {
                "vertices": "a list containing the vertex IDs which should be included in the result. None means all of the .",
                "mode": "defines how to treat vertices with degree less than two. If TRANSITIVITT_ZERO or \"zero\", these vertices will have zero transitivity. If TRANSITIVITY_NAN or \"nan\", these vertices will have NaN (not a number) as their transitivity.",
                "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name."
            },
            "Return": [
                "the transitivities for the given vertices in a list"
            ],
            "References": [
                ":D. J. Watts and S. Strogatz: Collective dynamics of small-world networks. Nature 393(6884):440-442, 1998.Barrat A, Barthelemy M, Pastor-Satorras R and Vespignani A: The architecture of complex weighted networks. PNAS 101, 3747 (2004). http://arxiv.org/abs/cond-mat/0311416."
            ],
            "Rasises": {},
            "See Also": "transitivity_undirected(), transitivity_avglocal_undirected()",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > transitivity_undirected": {
            "Description": "Calculates the global transitivity (clustering coefficient) of the graph.\nThe transitivity measures the probability that two neighbors of a vertex are connected. More precisely, this is the ratio of the triangles and connected triplets in the graph. The result is a single real number. Directed graphs are considered as undirected ones.\nNote that this measure is different from the local transitivity measure (see transitivity_local_undirected()) as it calculates a single value for the whole graph.\nReference: S. Wasserman and K. Faust: Social Network Analysis: Methods and Applications. Cambridge: Cambridge University Press, 1994.",
            "Paramters": {
                "mode": "if TRANSITIVITY_ZERO or \"zero\", the result will be zero if the graph does not have any triplets. If \"nan\" or TRANSITIVITY_NAN, the result will be NaN (not a number)."
            },
            "Return": [
                "the transitivity"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "transitivity_local_undirected(), transitivity_avglocal_undirected()",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > Tree": {
            "Description": "Generates a tree in which almost all vertices have the same number of children.",
            "Paramters": {
                "n": "the umber of vertices i the graph",
                "children": "the number of  of a vertex in the graph",
                "mode": "determines whether the tree should be directed, and if this is the case, also its orientation. Must be one of \"in\", \"out\" and \"undirected\"."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > Tree_Game": {
            "Description": "Generates a random tree by sampling uniformly from the set of labelled trees with a given number of nodes.",
            "Paramters": {
                "n": "the umber of vertices i the tree",
                "directed": "whether the graph should be ",
                "method": "the generation  to be used. One of the following:\"prufer\" -- samples Pr\u00fcfer sequences uniformly, then converts them to trees\"lerw\" -- performs a loop-erased random walk on the complete graph to uniformly sample its spanning trees (Wilson's algorithm). This is the default choice as it supports both directed and undirected graphs."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > triad_census": {
            "Description": "overridden in igraph.Graph\nTriad census, as defined by Davis and Leinhardt\nCalculating the triad census means classifying every triplets of vertices in a directed graph. A triplet can be in one of 16 states, these are listed in the documentation of the C interface of igraph.\nAttention: this function has a more convenient interface in class Graph, which wraps the result in a TriadCensus object. It is advised to use that. The name of the triplet classes are also documented there.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > Triangular_Lattice": {
            "Description": "Generates a regular triangular lattice.",
            "Paramters": {
                "dim": "list with the ensions of the lattice",
                "directed": "whether to create a  graph.",
                "mutual": "whether to create all connections as  in case of a directed graph."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > unfold_tree": {
            "Description": "Unfolds the graph using a BFS to a tree by duplicating vertices as necessary.",
            "Paramters": {
                "sources": "the source vertices to start the unfolding from. It should be a list of vertex indices, preferably one vertex from each connected component. You can use topological_sorting() to determine a suitable set. A single vertex index is also accepted.",
                "mode": "which edges to follow during the BFS. OUT follows outgoing edges, IN follows incoming edges, ALL follows both. Ignored for undirected graphs."
            },
            "Return": [
                "the unfolded tree graph and a mapping from the new vertex indices to the old ones."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > vcount": {
            "Description": "Counts the number of vertices.",
            "Paramters": {},
            "Return": [
                "integerthe number of vertices in the graph."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > vertex_attributes": {
            "Description": "",
            "Paramters": {},
            "Return": [
                "the attribute name list of the vertices of the graph"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > vertex_coloring_greedy": {
            "Description": "Calculates a greedy vertex coloring for the graph based on some heuristics.",
            "Paramters": {
                "method": "the heuristics to use. colored_neighbors always picks the vertex with the largest number of colored neighbors as the next vertex to pick a color for. dsatur picks the vertex with the largest number of unique colors in its neighborhood; this is also known as the DSatur heuristics (hence the name)."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > vertex_connectivity": {
            "Description": "Calculates the vertex connectivity of the graph or between some vertices.\nThe vertex connectivity between two given vertices is the number of vertices that have to be removed in order to disconnect the two vertices into two separate components. This is also the number of vertex disjoint directed paths between the vertices (apart from the source and target vertices of course). The vertex connectivity of the graph is the minimal vertex connectivity over all vertex pairs.\nThis method calculates the vertex connectivity of a given vertex pair if both the source and target vertices are given. If none of them is given (or they are both negative), the overall vertex connectivity is returned.",
            "Paramters": {
                "source": "the  vertex involved in the calculation.",
                "target": "the  vertex involved in the calculation.",
                "checks": "if the whole graph connectivity is calculated and this is True, igraph performs some basic  before calculation. If the graph is not strongly connected, then the connectivity is obviously zero. If the minimum degree is one, then the connectivity is also one. These simple  are much faster than checking the entire graph, therefore it is advised to set this to True. The parameter is ignored if the connectivity between two given vertices is computed.",
                "neighbors": "tells igraph what to do when the two vertices are connected. \"error\" raises an exception, \"negative\" returns a negative value, \"number_of_nodes\" or \"nodes\" returns the number of nodes, or \"ignore\" ignores the edge."
            },
            "Return": [
                "the vertex connectivity"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > Watts_Strogatz": {
            "Description": "This function generates networks with the small-world property based on a variant of the Watts-Strogatz model. The network is obtained by first creating a periodic undirected lattice, then rewiring both endpoints of each edge with probability p, while avoiding the creation of multi-edges.\nThis process differs from the original model of Watts and Strogatz (see reference) in that it rewires both endpoints of edges. Thus in the limit of p=1, we obtain a G(n,m) random graph with the same number of vertices and edges as the original lattice. In comparison, the original Watts-Strogatz model only rewires a single endpoint of each edge, thus the network does not become fully random even for <code>p=1</code>.\nFor appropriate choices of p, both models exhibit the property of simultaneously having short path lengths and high clustering.\nReference: Duncan J Watts and Steven H Strogatz: Collective dynamics of small world networks, Nature 393, 440-442, 1998",
            "Paramters": {
                "dim": "the ension of the lattice",
                "size": "the  of the lattice along all dimensions",
                "nei": "value giving the distance (number of steps) within which two vertices will be connected.",
                "p": "rewiring robability",
                "loops": "specifies whether loop edges are allowed",
                "multiple": "specifies whether  edges are allowed"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "Lattice(), rewire(), rewire_edges() if more flexibility is needed",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > write_dimacs": {
            "Description": "overridden in igraph.Graph\nWrites the graph in DIMACS format to the given file.",
            "Paramters": {
                "f": "the name o the ile to be written or a Python ile handle",
                "source": "the  vertex ID",
                "target": "the  vertex ID",
                "capacity": "the capacities of the edges in a list. If it is not a list, the corresponding edge attribute will be used to retrieve capacities."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > write_dot": {
            "Description": "Writes the graph in DOT format to the given file.\nDOT is the format used by the GraphViz software package.",
            "Paramters": {
                "f": "the name o the ile to be written or a Python ile handle"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > write_edgelist": {
            "Description": "Writes the edge list of a graph to a file.\nDirected edges are written in (from, to) order.",
            "Paramters": {
                "f": "the name o the ile to be written or a Python ile handle"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > write_gml": {
            "Description": "Writes the graph in GML format to the given file.",
            "Paramters": {
                "f": "the name o the ile to be written or a Python ile handle",
                "creator": "optional  information to be written to the file. If None, the current date and time is added.",
                "ids": "optional numeric vertex IDs to use in the file. This must be a list of integers or None. If None, the id attribute of the vertices are used, or if they don't exist, numeric vertex IDs will be generated automatically."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > write_graphml": {
            "Description": "Writes the graph to a GraphML file.",
            "Paramters": {
                "f": "the name o the ile to be written or a Python ile handle"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > write_leda": {
            "Description": "Writes the graph to a file in LEDA native format.\nThe LEDA format supports at most one attribute per vertex and edge. You can specify which vertex and edge attribute you want to use. Note that the name of the attribute is not saved in the LEDA file.",
            "Paramters": {
                "f": "the name o the ile to be written or a Python ile handle",
                "names": "the name of the vertex attribute to be stored along with the vertices. It is usually used to store the vertex  (hence the name of the keyword argument), but you may also use a numeric attribute. If you don't want to store any vertex attributes, supply None here.",
                "weights": "the name of the edge attribute to be stored along with the edges. It is usually used to store the edge  (hence the name of the keyword argument), but you may also use a string attribute. If you don't want to store any edge attributes, supply None here."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > write_lgl": {
            "Description": "Writes the edge list of a graph to a file in .lgl format.\nNote that multiple edges and/or loops break the LGL software, but igraph does not check for this condition. Unless you know that the graph does not have multiple edges and/or loops, it is wise to call simplify() before saving.",
            "Paramters": {
                "f": "the name o the ile to be written or a Python ile handle",
                "names": "the name of the vertex attribute containing the name of the vertices. If you don't want to store vertex , supply None here.",
                "weights": "the name of the edge attribute containing the weight of the vertices. If you don't want to store , supply None here.",
                "isolates": "whether to include isolated vertices in the output."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > write_ncol": {
            "Description": "Writes the edge list of a graph to a file in .ncol format.\nNote that multiple edges and/or loops break the LGL software, but igraph does not check for this condition. Unless you know that the graph does not have multiple edges and/or loops, it is wise to call simplify() before saving.",
            "Paramters": {
                "f": "the name o the ile to be written or a Python ile handle",
                "names": "the name of the vertex attribute containing the name of the vertices. If you don't want to store vertex , supply None here.",
                "weights": "the name of the edge attribute containing the weight of the vertices. If you don't want to store , supply None here."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > Methods > write_pajek": {
            "Description": "Writes the graph in Pajek format to the given file.",
            "Paramters": {
                "f": "the name o the ile to be written or a Python ile handle"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Field List > property": {},
        "Section_id": "GraphBase"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "GraphBase"
    },
    {
        "Section_id": "Types",
        "Description": "Static class for the implementation of custom getter/setter functions for configuration keys"
    },
    {
        "Field List > Methods > setboolean": {
            "Description": "Sets a boolean value in the given configuration object.",
            "Paramters": {
                "obj": "a configuration ect",
                "section": "the  of the value to be set",
                "key": "the  of the value to be set",
                "value": "the  itself. 0, false, no and off means false, 1, true, yes and on means true, everything else results in a ValueError being thrown. Values are case-insensitive"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Types"
    },
    {
        "Field List > Methods > setfloat": {
            "Description": "Sets a float value in the given configuration object.\nNote that float values are converted to strings in the configuration object, which may lead to some precision loss.",
            "Paramters": {
                "obj": "a configuration ect",
                "section": "the  of the value to be set",
                "key": "the  of the value to be set",
                "value": "the  itself."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Types"
    },
    {
        "Field List > Methods > setint": {
            "Description": "Sets an integer value in the given configuration object.",
            "Paramters": {
                "obj": "a configuration ect",
                "section": "the  of the value to be set",
                "key": "the  of the value to be set",
                "value": "the  itself."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Types"
    },
    {
        "Field List > property": {},
        "Section_id": "Types"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "Types"
    },
    {
        "Section_id": "PlotlyEdgeDrawer",
        "Description": "Matplotlib-specific abstract edge drawer object."
    },
    {
        "Field List > Methods > __init__": {
            "Description": "Constructs the edge drawer.",
            "Paramters": {
                "context": "a plotly Figure object on which the edges will be drawn.",
                "palette": "the  that can be used to map integer color indices to colors when drawing edges"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "PlotlyEdgeDrawer"
    },
    {
        "Field List > Methods > draw_directed_edge": {
            "Description": "overrides igraph.drawing.baseclasses.AbstractEdgeDrawer.draw_directed_edge\nDraws a directed edge.",
            "Paramters": {
                "edge": "the  to be drawn. Visual properties of the  are defined by the attributes of this object.",
                "src_vertex": "the source vertex. Visual properties are defined by the attributes of this object.",
                "dest_vertex": "the source vertex. Visual properties are defined by the attributes of this object."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "PlotlyEdgeDrawer"
    },
    {
        "Field List > Methods > draw_loop_edge": {
            "Description": "Draws a loop edge.\nThe default implementation draws a small circle.",
            "Paramters": {
                "edge": "the  to be drawn. Visual properties of the  are defined by the attributes of this object.",
                "vertex": "the  to which the edge is attached. Visual properties are given again as attributes."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "PlotlyEdgeDrawer"
    },
    {
        "Field List > Methods > draw_undirected_edge": {
            "Description": "overrides igraph.drawing.baseclasses.AbstractEdgeDrawer.draw_undirected_edge\nDraws an undirected edge.\nThe default implementation of this method draws undirected edges as straight lines. Loop edges are drawn as small circles.",
            "Paramters": {
                "edge": "the  to be drawn. Visual properties of the  are defined by the attributes of this object.",
                "src_vertex": "the source vertex. Visual properties are given again as attributes.",
                "dest_vertex": "the target vertex. Visual properties are given again as attributes."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "PlotlyEdgeDrawer"
    },
    {
        "Field List > Methods > get_label_position": {
            "Description": "Inherited from AbstractEdgeDrawer:Returns the position where the label of an edge should be drawn. the default implementation returns the midpoint of the edge and an alignment that tries to avoid overlapping the label with the edge."
        },
        "Section_id": "PlotlyEdgeDrawer"
    },
    {
        "Field List > Methods > get_label_rotation": {
            "Description": "Inherited from AbstractEdgeDrawer:Get the rotation angle of the label to align with the edge."
        },
        "Section_id": "PlotlyEdgeDrawer"
    },
    {
        "Field List > property": {},
        "Section_id": "PlotlyEdgeDrawer"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "PlotlyEdgeDrawer"
    },
    {
        "Section_id": "MatplotlibVertexDrawer",
        "Description": "Matplotlib backend-specific vertex drawer."
    },
    {
        "Field List > Methods > __init__": {
            "Description": "overrides igraph.drawing.baseclasses.AbstractVertexDrawer.__init__\nConstructs the vertex drawer and associates it to the given palette.",
            "Paramters": {
                "ax": "Undocumented",
                "palette": "the  that can be used to map integer color indices to colors when drawing vertices",
                "layout": "the  of the vertices in the graph being drawn"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "MatplotlibVertexDrawer"
    },
    {
        "Field List > Methods > draw": {
            "Description": "overrides igraph.drawing.baseclasses.AbstractVertexDrawer.draw\nBuild the Artist for a vertex and return it.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "MatplotlibVertexDrawer"
    },
    {
        "Field List > property": {},
        "Section_id": "MatplotlibVertexDrawer"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "MatplotlibVertexDrawer"
    },
    {
        "Section_id": "DownTriangleDrawer",
        "Description": "Static class which draws triangles pointing down"
    },
    {
        "Field List > Methods > draw_path": {
            "Description": "overrides igraph.drawing.shapes.ShapeDrawer.draw_path\nDraws a triangle on the Cairo context without stroking or filling it.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "ShapeDrawer.draw_path",
            "example": []
        },
        "Section_id": "DownTriangleDrawer"
    },
    {
        "Field List > Methods > intersection_point": {
            "Description": "overrides igraph.drawing.shapes.ShapeDrawer.intersection_point\nDetermines where the triangle centered at (center_x, center_y) intersects with a line drawn from (source_x, source_y) to (center_x, center_y).",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "ShapeDrawer.intersection_point",
            "example": []
        },
        "Section_id": "DownTriangleDrawer"
    },
    {
        "Field List > property": {},
        "Section_id": "DownTriangleDrawer"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "DownTriangleDrawer"
    },
    {
        "Section_id": "TextAlignment",
        "Description": "Text alignment constants."
    },
    {
        "Field List > property": {},
        "Section_id": "TextAlignment"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "TextAlignment"
    },
    {
        "Section_id": "FakeWrapper",
        "Description": "Object whose interface is compatible with textwrap.TextWrapper but does no wrapping."
    },
    {
        "Field List > Methods > __init__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "FakeWrapper"
    },
    {
        "Field List > Methods > fill": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "FakeWrapper"
    },
    {
        "Field List > Methods > wrap": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "FakeWrapper"
    },
    {
        "Field List > property": {},
        "Section_id": "FakeWrapper"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "FakeWrapper"
    },
    {
        "Section_id": "mpl",
        "Description": "Undocumented"
    },
    {
        "Section_id": "_",
        "Description": "Undocumented"
    },
    {
        "Section_id": "AdvancedGradientPalette",
        "Description": "Advanced gradient that consists of more than two base colors.\n"
    },
    {
        "Field List > Methods > __init__": {
            "Description": "overrides igraph.drawing.colors.Palette.__init__\nCreates an advanced gradient palette",
            "Paramters": {
                "colors": "the  in the gradient.",
                "indices": "the color  belonging to the given colors. If None, the colors are distributed equidistantly",
                "n": "the total umber of colors i the palette"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "AdvancedGradientPalette"
    },
    {
        "Field List > Methods > __len__": {
            "Description": "Inherited from Palette:Returns the number of colors in this palette"
        },
        "Section_id": "AdvancedGradientPalette"
    },
    {
        "Field List > Methods > __plot__": {
            "Description": "Inherited from Palette:Plots the colors of the palette on the given Cairo context/mpl Axes"
        },
        "Section_id": "AdvancedGradientPalette"
    },
    {
        "Field List > Methods > __repr__": {
            "Description": "Inherited from Palette:Undocumented"
        },
        "Section_id": "AdvancedGradientPalette"
    },
    {
        "Field List > Methods > clear_cache": {
            "Description": "Inherited from Palette:Clears the result cache."
        },
        "Section_id": "AdvancedGradientPalette"
    },
    {
        "Field List > Methods > get": {
            "Description": "Inherited from Palette:Returns the given color from the palette."
        },
        "Section_id": "AdvancedGradientPalette"
    },
    {
        "Field List > Methods > get_many": {
            "Description": "Inherited from Palette:Returns multiple colors from the palette."
        },
        "Section_id": "AdvancedGradientPalette"
    },
    {
        "Field List > property": {
            "length": "Inherited from Palette:Returns the number of colors in this palette"
        },
        "Section_id": "AdvancedGradientPalette"
    },
    {
        "Rubric": {
            "Example": [
                "Example:\n>>> pal = AdvancedGradientPalette([\"red\", \"black\", \"blue\"], n=9)\n>>> pal.get(2)\n(0.5, 0.0, 0.0, 1.0)\n>>> pal.get(7)\n(0.0, 0.0, 0.75, 1.0)\n"
            ]
        },
        "Section_id": "AdvancedGradientPalette"
    },
    {
        "Section_id": "AbstractCairoDrawer",
        "Description": "Abstract class that serves as a base class for anything that draws on a Cairo context within a given bounding box.\nA subclass of AbstractCairoDrawer is guaranteed to have an attribute named context that represents the Cairo context to draw on, and an attribute named bbox for the BoundingBox of the drawing area."
    },
    {
        "Field List > Methods > __init__": {
            "Description": "overridden in igraph.drawing.cairo.coord.DescartesCoordinateSystem, igraph.drawing.cairo.dendrogram.CairoDendrogramDrawer, igraph.drawing.cairo.graph.AbstractCairoGraphDrawer, igraph.drawing.cairo.histogram.CairoHistogramDrawer, igraph.drawing.cairo.matrix.CairoMatrixDrawer, igraph.drawing.cairo.palette.CairoPaletteDrawer, igraph.drawing.cairo.polygon.CairoPolygonDrawer, igraph.drawing.cairo.text.CairoTextDrawer, igraph.drawing.cairo.vertex.AbstractCairoVertexDrawer\nConstructs the drawer and associates it to the given Cairo context and the given BoundingBox.",
            "Paramters": {
                "context": "the  on which we will draw",
                "bbox": ":BoundingBox or Nonethe bounding box within which we will draw. Can be anything accepted by the constructor of BoundingBox (i.e., a 2-tuple, a 4-tuple or a BoundingBox object)."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "AbstractCairoDrawer"
    },
    {
        "Field List > Methods > bbox": {
            "Description": "overridden in igraph.drawing.cairo.coord.DescartesCoordinateSystem\nSets the bounding box of the drawing area where this drawer will draw.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "AbstractCairoDrawer"
    },
    {
        "Field List > Methods > draw": {
            "Description": "Inherited from AbstractDrawer:Abstract method, must be implemented in derived classes."
        },
        "Section_id": "AbstractCairoDrawer"
    },
    {
        "Field List > property": {
            "bbox": "overridden in igraph.drawing.cairo.coord.DescartesCoordinateSystem, igraph.drawing.cairo.graph.CairoGraphDrawer, igraph.drawing.cairo.histogram.CairoHistogramDrawer, igraph.drawing.cairo.matrix.CairoMatrixDrawer, igraph.drawing.cairo.palette.CairoPaletteDrawer\nThe bounding box of the drawing area where this drawer will draw.\n"
        },
        "Section_id": "AbstractCairoDrawer"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "AbstractCairoDrawer"
    },
    {
        "Section_id": "mean",
        "Description": "Returns the mean of an iterable.\nExample:>>> mean([1, 4, 7, 11])5.75"
    },
    {
        "Paramters": {
            "xs": "an iterable yielding numbers."
        },
        "Section_id": "mean"
    },
    {
        "Section_id": "mean",
        "Return": [
            "the mean of the numbers provided by the iterable."
        ]
    },
    {
        "Raises": {},
        "Section_id": "mean"
    },
    {
        "Section_id": "mean",
        "See Also": "RunningMean() if you also need the variance or the standard deviation"
    },
    {
        "Section_id": "median",
        "Description": "Returns the median of an unsorted or sorted numeric vector."
    },
    {
        "Paramters": {
            "xs": "the vector itself.",
            "sort": "whether to  the vector. If you know that the vector is ed already, pass False here."
        },
        "Section_id": "median"
    },
    {
        "Section_id": "median",
        "Return": [
            "the median, which will always be a float, even if the vector contained integers originally."
        ]
    },
    {
        "Raises": {},
        "Section_id": "median"
    },
    {
        "Section_id": "median",
        "See Also": ""
    },
    {
        "Section_id": "percentile",
        "Description": "Returns the pth percentile of an unsorted or sorted numeric vector.\nThis is equivalent to calling quantile(xs, p/100.0); see quantile for more details on the calculation.\nExample:>>> round(percentile([15, 20, 40, 35, 50], 40), 2)26.0>>> for perc in percentile([15, 20, 40, 35, 50], (0, 25, 50, 75, 100)):...     print(\"%.2f\" % perc)...15.0017.5035.0045.0050.00"
    },
    {
        "Paramters": {
            "xs": "the vector itself.",
            "p": "the ercentile we are looking for. It may also be a list if you want to calculate multile quantiles with a single call. The default value calculates the 25th, 50th and 75th ercentile.",
            "sort": "whether to  the vector. If you know that the vector is ed already, pass False here."
        },
        "Section_id": "percentile"
    },
    {
        "Section_id": "percentile",
        "Return": [
            "the pth percentile, which will always be a float, even if the vector contained integers originally. If p is a list, the result will also be a list containing the percentiles for each item in the list."
        ]
    },
    {
        "Raises": {},
        "Section_id": "percentile"
    },
    {
        "Section_id": "percentile",
        "See Also": ""
    },
    {
        "Section_id": "power_law_fit",
        "Description": "Fitting a power-law distribution to empirical data\n"
    },
    {
        "Paramters": {
            "data": "the  to fit, a list containing integer values",
            "xmin": "the lower bound for fitting the power-law. If None, the optimal  value will be estimated as well. Zero means that the smallest possible  value will be used.",
            "method": "the fitting  to use. The following s are implemented so far:continuous, hill: exact maximum likelihood estimation when the input data comes from a continuous scale. This is known as the Hill estimator. The statistical error of this estimator is (alpha\u2009\u2212\u20091)\u2009\u2044\u2009sqrt(n), where alpha is the estimated exponent and n is the number of data points above xmin. The estimator is known to exhibit a small finite sample-size bias of order O(n\u2009\u2212\u20091), which is small when n\u2009>\u2009100. igraph will try to compensate for the finite sample size if n is small.discrete: exact maximum likelihood estimation when the input comes from a discrete scale (see Clauset et al. among the references).auto: exact maximum likelihood estimation where the continuous  is used if the input vector contains at least one fractional value and the discrete  is used if the input vector contains integers only.",
            "p_precision": "desired precision of the p-value calculation. The precision ultimately depends on the number of resampling attempts. The number of resampling trials is determined by 0.25 divided by the square of the required precision. For instance, a required precision of 0.01 means that 2500 samples will be drawn."
        },
        "Section_id": "power_law_fit"
    },
    {
        "Section_id": "power_law_fit",
        "Return": [
            "a FittedPowerLaw object. The fitted xmin value and the power-law exponent can be queried from the xmin and alpha properties of the returned object."
        ]
    },
    {
        "Raises": {},
        "Section_id": "power_law_fit"
    },
    {
        "Section_id": "power_law_fit",
        "References": [
            "MEJ Newman: Power laws, Pareto distributions and Zipf's law. Contemporary Physics 46, 323-351 (2005)",
            "A Clauset, CR Shalizi, MEJ Newman: Power-law distributions in empirical data. E-print (2007). arXiv:0706.1062"
        ]
    },
    {
        "Section_id": "power_law_fit",
        "See Also": ""
    },
    {
        "Section_id": "quantile",
        "Description": "Returns the qth quantile of an unsorted or sorted numeric vector.\nThere are a number of different ways to calculate the sample quantile. The method implemented by igraph is the one recommended by NIST. First we calculate a rank n as q(N+1), where N is the number of items in xs, then we split n into its integer component k and decimal component d. If k <= 1, we return the first element; if k >= N, we return the last element, otherwise we return the linear interpolation between xs[k-1] and xs[k] using a factor d.\nExample:>>> round(quantile([15, 20, 40, 35, 50], 0.4), 2)26.0"
    },
    {
        "Paramters": {
            "xs": "the vector itself.",
            "q": "the uantile we are looking for. It may also be a list if you want to calculate multiple uantiles with a single call. The default value calculates the 25th, 50th and 75th percentile.",
            "sort": "whether to  the vector. If you know that the vector is ed already, pass False here."
        },
        "Section_id": "quantile"
    },
    {
        "Section_id": "quantile",
        "Return": [
            "the qth quantile, which will always be a float, even if the vector contained integers originally. If q is a list, the result will also be a list containing the quantiles for each item in the list."
        ]
    },
    {
        "Raises": {},
        "Section_id": "quantile"
    },
    {
        "Section_id": "quantile",
        "See Also": ""
    },
    {
        "Section_id": "sd",
        "Description": "Returns the standard deviation of an iterable.\nExample:>>> sd([1, 4, 7, 11])       #doctest:+ELLIPSIS4.2720..."
    },
    {
        "Paramters": {
            "xs": "an iterable yielding numbers."
        },
        "Section_id": "sd"
    },
    {
        "Section_id": "sd",
        "Return": [
            "the standard deviation of the numbers provided by the iterable."
        ]
    },
    {
        "Raises": {},
        "Section_id": "sd"
    },
    {
        "Section_id": "sd",
        "See Also": "RunningMean() if you also need the mean"
    },
    {
        "Section_id": "var",
        "Description": "Returns the variance of an iterable.\nExample:>>> var([1, 4, 8, 11])            #doctest:+ELLIPSIS19.333333..."
    },
    {
        "Paramters": {
            "xs": "an iterable yielding numbers."
        },
        "Section_id": "var"
    },
    {
        "Section_id": "var",
        "Return": [
            "the variance of the numbers provided by the iterable."
        ]
    },
    {
        "Raises": {},
        "Section_id": "var"
    },
    {
        "Section_id": "var",
        "See Also": "RunningMean() if you also need the mean"
    },
    {
        "Section_id": "construct_graph_from_formula",
        "Description": "Graph.Formula(formula = None, attr = \"name\", simplify = True)\nGenerates a graph from a graph formula\nA graph formula is a simple string representation of a graph. It is very handy for creating small graphs quickly. The string consists of vertex names separated by edge operators. An edge operator is a sequence of dashes (-) that may or may not start with an arrowhead (< at the beginning of the sequence or > at the end of the sequence). The edge operators can be arbitrarily long, i.e., you may use as many dashes to draw them as you like. This makes a total of four different edge operators:----- makes an undirected edge<---- makes a directed edge pointing from the vertex on the right hand side of the operator to the vertex on the left hand side----> is the opposite of <----<---> creates a mutual directed edge pair between the two vertices\nIf you only use the undirected edge operator (-----), the graph will be undirected. Otherwise it will be directed. Vertex names used in the formula will be assigned to the name vertex attribute of the graph.\nSome simple examples:>>> from igraph import Graph>>> print(Graph.Formula())          # empty graphIGRAPH UN-- 0 0 --+ attr: name (v)>>> g = Graph.Formula(\"A-B\")        # undirected graph>>> g.vs[\"name\"]['A', 'B']>>> print(g)IGRAPH UN-- 2 1 --+ attr: name (v)+ edges (vertex names):A--B>>> g.get_edgelist()[(0, 1)]>>> g2 = Graph.Formula(\"A-----------B\")>>> g2.isomorphic(g)True>>> g = Graph.Formula(\"A  --->  B\") # directed graph>>> g.vs[\"name\"]['A', 'B']>>> print(g)IGRAPH DN-- 2 1 --+ attr: name (v)+ edges (vertex names):A->B\nIf you have many disconnected componnets, you can separate them with commas. You can also specify isolated vertices:>>> g = Graph.Formula(\"A--B, C--D, E--F, G--H, I, J, K\")>>> print(\", \".join(g.vs[\"name\"]))A, B, C, D, E, F, G, H, I, J, K>>> g.connected_components().membership[0, 0, 1, 1, 2, 2, 3, 3, 4, 5, 6]\nThe colon (:) operator can be used to specify vertex sets. If an edge operator connects two vertex sets, then every vertex from the first vertex set will be connected to every vertex in the second set:>>> g = Graph.Formula(\"A:B:C:D --- E:F:G\")>>> g.isomorphic(Graph.Full_Bipartite(4, 3))True\nNote that you have to quote vertex names if they include spaces or special characters:>>> g = Graph.Formula('\"this is\" +- \"a silly\" -+ \"graph here\"')>>> g.vs[\"name\"]['this is', 'a silly', 'graph here']"
    },
    {
        "Paramters": {
            "cls": "Undocumented",
            "formula": "the  itself",
            "attr": "name of the vertex ibute where the vertex names will be stored",
            "simplify": "whether to  the constructed graph"
        },
        "Section_id": "construct_graph_from_formula"
    },
    {
        "Section_id": "construct_graph_from_formula",
        "Return": [
            "the constructed graph:"
        ]
    },
    {
        "Raises": {},
        "Section_id": "construct_graph_from_formula"
    },
    {
        "Section_id": "construct_graph_from_formula",
        "See Also": ""
    },
    {
        "Section_id": "generate_edges",
        "Description": "Parses an edge specification from the head of the given formula part and yields the following:startpoint(s) of the edge by vertex namesendpoint(s) of the edge by names or an empty list if the vertices are isolateda pair of bools to denote whether we had arrowheads at the start and end vertices"
    },
    {
        "Paramters": {},
        "Section_id": "generate_edges"
    },
    {
        "Raises": {},
        "Section_id": "generate_edges"
    },
    {
        "Section_id": "generate_edges",
        "See Also": ""
    },
    {
        "Section_id": "Histogram",
        "Description": "Generic histogram class for real numbers\n"
    },
    {
        "Field List > Methods > __init__": {
            "Description": "Initializes the histogram with the given data set.",
            "Paramters": {
                "bin_width": "the bin width of the histogram.",
                "data": "the  set to be used. Must contain real numbers."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Histogram"
    },
    {
        "Field List > Methods > __plot__": {
            "Description": "Plotting support",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Histogram"
    },
    {
        "Field List > Methods > __str__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Histogram"
    },
    {
        "Field List > Methods > add": {
            "Description": "Adds a single number to the histogram.",
            "Paramters": {
                "num": "the ber to be added",
                "repeat": "number of ed additions"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Histogram"
    },
    {
        "Field List > Methods > add_many": {
            "Description": "Adds a single number or the elements of an iterable to the histogram.",
            "Paramters": {
                "data": "the  to be added"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Histogram"
    },
    {
        "Field List > Methods > bins": {
            "Description": "Generator returning the bins of the histogram in increasing order",
            "Paramters": {},
            "Return": [
                "a tuple with the following elements: left bound, right bound, number of elements in the bin"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Histogram"
    },
    {
        "Field List > Methods > clear": {
            "Description": "Clears the collected data",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Histogram"
    },
    {
        "Field List > Methods > to_string": {
            "Description": "Returns the string representation of the histogram.",
            "Paramters": {
                "max_width": "the maximal width of each line of the string This value may not be obeyed if it is too small.",
                "show_bars": "specify whether the histogram bars should be shown",
                "show_counts": "specify whether the histogram counts should be shown. If both show_bars and  are False, only a general descriptive statistics (number of elements, mean and standard deviation) is shown."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Histogram"
    },
    {
        "Field List > property": {
            "mean": "Returns the mean of the elements in the histogram\n",
            "n": "Returns the number of elements in the histogram\n",
            "sd": "Returns the standard deviation of the elements in the histogram\n",
            "var": "Returns the variance of the elements in the histogram\n"
        },
        "Section_id": "Histogram"
    },
    {
        "Rubric": {
            "Example": [
                "Example:\n>>> h = Histogram(5)     # Initializing, bin width = 5\n>>> h << [2,3,2,7,8,5,5,0,7,9]     # Adding more items\n>>> print(h)\nN = 10, mean +- sd: 4.8000 +- 2.9740\n[ 0,  5): **** (4)\n[ 5, 10): ****** (6)\n"
            ]
        },
        "Section_id": "Histogram"
    },
    {
        "Section_id": "Cover",
        "Description": "Class representing a cover of an arbitrary ordered set.\nCovers are similar to clusterings, but each element of the set may belong to more than one cluster in a cover, and elements not belonging to any cluster are also allowed.\nCover instances provide a similar API as Clustering instances; for instance, iterating over a Cover will iterate over the clusters just like with a regular Clustering instance. However, they are not derived from each other or from a common superclass, and there might be functions that exist only in one of them or the other.\n"
    },
    {
        "Field List > Methods > __getitem__": {
            "Description": "Returns the cluster with the given index.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Cover"
    },
    {
        "Field List > Methods > __init__": {
            "Description": "overridden in igraph.VertexCover\nConstructs a cover with the given clusters.",
            "Paramters": {
                "clusters": "the  in this cover, as a list or iterable. Each cluster is specified by a list or tuple that contains the IDs of the items in this cluster. IDs start from zero.",
                "n": "the total umber of elemets i the set that is covered by this cover. If it is less tha the umber of uique elemets foud i all the clusters, we will simply use the umber of uique elemets, so it is safe to leave this at zero. You oly have to specify this parameter if there are some elemets that are covered by oe of the clusters."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Cover"
    },
    {
        "Field List > Methods > __iter__": {
            "Description": "Iterates over the clusters in this cover.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Cover"
    },
    {
        "Field List > Methods > __len__": {
            "Description": "Returns the number of clusters in this cover.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Cover"
    },
    {
        "Field List > Methods > __str__": {
            "Description": "Returns a string representation of the cover.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Cover"
    },
    {
        "Field List > Methods > size": {
            "Description": "Returns the size of a given cluster.",
            "Paramters": {
                "idx": "the cluster in which we are interested."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Cover"
    },
    {
        "Field List > Methods > size_histogram": {
            "Description": "Returns the histogram of cluster sizes.",
            "Paramters": {
                "bin_width": "the bin width of the histogram"
            },
            "Return": [
                "a Histogram object"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Cover"
    },
    {
        "Field List > Methods > sizes": {
            "Description": "Returns the size of given clusters.\nThe indices are given as positional arguments. If there are no positional arguments, the function will return the sizes of all clusters.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Cover"
    },
    {
        "Field List > Methods > summary": {
            "Description": "Returns the summary of the cover.\nThe summary includes the number of items and clusters, and also the list of members for each of the clusters if the verbosity is nonzero.",
            "Paramters": {
                "verbosity": "determines whether the cluster members should be printed. Zero  prints the number of items and clusters only.",
                "width": "Undocumented"
            },
            "Return": [
                "the summary of the cover as a string."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Cover"
    },
    {
        "Field List > property": {
            "membership": "Returns the membership vector of this cover.\nThe membership vector of a cover covering n elements is a list of length n, where element i contains the cluster indices of the ith item.\n\n",
            "n": "Returns the number of elements in the set covered by this cover.\n"
        },
        "Section_id": "Cover"
    },
    {
        "Rubric": {
            "Example": [
                "Clusters of an individual cover can be accessed by the [] operator:\n>>> cl = Cover([[0,1,2,3], [2,3,4], [0,1,6]])\n>>> cl[0]\n[0, 1, 2, 3]\n",
                "The membership vector can be accessed by the membership property. Note that contrary to Clustering instances, the membership vector will contain lists that contain the cluster indices each item belongs to:\n>>> cl = Cover([[0,1,2,3], [2,3,4], [0,1,6]])\n>>> cl[0]\n[0, 1, 2, 3]\n",
                "The number of clusters can be retrieved by the len function:\n>>> cl = Cover([[0,1,2,3], [2,3,4], [0,1,6]])\n>>> cl[0]\n[0, 1, 2, 3]\n",
                "You can iterate over the cover as if it were a regular list of clusters:\n>>> cl = Cover([[0,1,2,3], [2,3,4], [0,1,6]])\n>>> cl[0]\n[0, 1, 2, 3]\n",
                "If you need all the clusters at once as lists, you can simply convert the cover to a list:\n>>> cl = Cover([[0,1,2,3], [2,3,4], [0,1,6]])\n>>> cl[0]\n[0, 1, 2, 3]\n",
                "Clustering objects can readily be converted to Cover objects using the constructor:\n>>> cl = Cover([[0,1,2,3], [2,3,4], [0,1,6]])\n>>> cl[0]\n[0, 1, 2, 3]\n"
            ]
        },
        "Section_id": "Cover"
    },
    {
        "Section_id": "clamp",
        "Description": "Clamps the given value between min and max"
    },
    {
        "Paramters": {},
        "Section_id": "clamp"
    },
    {
        "Raises": {},
        "Section_id": "clamp"
    },
    {
        "Section_id": "clamp",
        "See Also": ""
    },
    {
        "Section_id": "color_name_to_rgb",
        "Description": "Converts a color given in one of the supported color formats to R-G-B values.\nThis is done by calling color_name_to_rgba and then throwing away the alpha value."
    },
    {
        "Paramters": {},
        "Section_id": "color_name_to_rgb"
    },
    {
        "Raises": {},
        "Section_id": "color_name_to_rgb"
    },
    {
        "Section_id": "color_name_to_rgb",
        "See Also": "color_name_to_rgba for more details about what formats are understood by this function."
    },
    {
        "Section_id": "color_name_to_rgba",
        "Description": "Converts a color given in one of the supported color formats to R-G-B-A values.\nExamples:>>> color_name_to_rgba(\"red\")(1.0, 0.0, 0.0, 1.0)>>> color_name_to_rgba(\"#ff8000\") == (1.0, 128/255.0, 0.0, 1.0)True>>> color_name_to_rgba(\"#ff800080\") == (1.0, 128/255.0, 0.0, 128/255.0)True>>> color_name_to_rgba(\"#08f\") == (0.0, 136/255.0, 1.0, 1.0)True>>> color_name_to_rgba(\"rgb(100%, 50%, 0%)\")(1.0, 0.5, 0.0, 1.0)>>> color_name_to_rgba(\"rgba(100%, 50%, 0%, 25%)\")(1.0, 0.5, 0.0, 0.25)>>> color_name_to_rgba(\"hsla(120, 100%, 50%, 0.5)\")(0.0, 1.0, 0.0, 0.5)>>> color_name_to_rgba(\"hsl(60, 100%, 50%)\")(1.0, 1.0, 0.0, 1.0)>>> color_name_to_rgba(\"hsv(60, 100%, 100%)\")(1.0, 1.0, 0.0, 1.0)"
    },
    {
        "Paramters": {
            "color": "the  to be converted in one of the following formats:CSS3  specification: #rrggbb, #rgb, #rrggbbaa, #rgba, rgb(red, green, blue), rgba(red, green, blue, alpha), hsl(hue, saturation, lightness), hsla(hue, saturation, lightness, alpha), hsv(hue, saturation, value) and hsva(hue, saturation, value, alpha) where the components are given as hexadecimal numbers in the first four cases and as decimals or percentages (0%-100%) in the remaining cases. Red, green and blue components are between 0 and 255; hue is between 0 and 360; saturation, lightness and value is between 0 and 100; alpha is between 0 and 1.Valid HTML  names, i.e. those that are present in the HTML 4.0 specificationValid X11  names, see http://en.wikipedia.org/wiki/X11__namesRed-green-blue components given separately in either a comma-, slash- or whitespace-separated string or a list or a tuple, in the range of 0-255. An alpha value of 255 (maximal opacity) will be assumed.Red-green-blue-alpha components given separately in either a comma-, slash- or whitespace-separated string or a list or a tuple, in the range of 0-255A single palette index given either as a string or a number. Uses the palette given in the palette parameter of the method call.",
            "palette": "the  to be used if a single number is passed to the method. Must be an instance of colors.Palette."
        },
        "Section_id": "color_name_to_rgba"
    },
    {
        "Section_id": "color_name_to_rgba",
        "Return": [
            "the RGBA values corresponding to the given color in a 4-tuple. Since these colors are primarily used by Cairo routines, the tuples contain floats in the range 0.0-1.0"
        ]
    },
    {
        "Raises": {},
        "Section_id": "color_name_to_rgba"
    },
    {
        "Section_id": "color_name_to_rgba",
        "See Also": ""
    },
    {
        "Section_id": "color_to_html_format",
        "Description": "Formats a color given as a 3-tuple or 4-tuple in HTML format.\nThe HTML format is simply given by #rrggbbaa, where rr gives the red component in hexadecimal format, gg gives the green component bb gives the blue component and gg gives the alpha level. The alpha level is optional."
    },
    {
        "Paramters": {},
        "Section_id": "color_to_html_format"
    },
    {
        "Raises": {},
        "Section_id": "color_to_html_format"
    },
    {
        "Section_id": "color_to_html_format",
        "See Also": ""
    },
    {
        "Section_id": "darken",
        "Description": "Creates a darker version of a color given by an RGB triplet.\nThis is done by mixing the original color with black using the given ratio. A ratio of 1.0 will yield a completely black color, a ratio of 0.0 will yield the original color. The alpha values are left intact."
    },
    {
        "Paramters": {},
        "Section_id": "darken"
    },
    {
        "Raises": {},
        "Section_id": "darken"
    },
    {
        "Section_id": "darken",
        "See Also": ""
    },
    {
        "Section_id": "hsl_to_rgb",
        "Description": "Converts a color given by its HSL coordinates (hue, saturation, lightness) to RGB coordinates.\nEach of the HSL coordinates must be in the range [0, 1]."
    },
    {
        "Paramters": {},
        "Section_id": "hsl_to_rgb"
    },
    {
        "Raises": {},
        "Section_id": "hsl_to_rgb"
    },
    {
        "Section_id": "hsl_to_rgb",
        "See Also": ""
    },
    {
        "Section_id": "hsla_to_rgba",
        "Description": "Converts a color given by its HSLA coordinates (hue, saturation, lightness, alpha) to RGBA coordinates.\nEach of the HSLA coordinates must be in the range [0, 1]."
    },
    {
        "Paramters": {},
        "Section_id": "hsla_to_rgba"
    },
    {
        "Raises": {},
        "Section_id": "hsla_to_rgba"
    },
    {
        "Section_id": "hsla_to_rgba",
        "See Also": ""
    },
    {
        "Section_id": "hsv_to_rgb",
        "Description": "Converts a color given by its HSV coordinates (hue, saturation, value) to RGB coordinates.\nEach of the HSV coordinates must be in the range [0, 1]."
    },
    {
        "Paramters": {},
        "Section_id": "hsv_to_rgb"
    },
    {
        "Raises": {},
        "Section_id": "hsv_to_rgb"
    },
    {
        "Section_id": "hsv_to_rgb",
        "See Also": ""
    },
    {
        "Section_id": "hsva_to_rgba",
        "Description": "Converts a color given by its HSVA coordinates (hue, saturation, value, alpha) to RGB coordinates.\nEach of the HSVA coordinates must be in the range [0, 1]."
    },
    {
        "Paramters": {},
        "Section_id": "hsva_to_rgba"
    },
    {
        "Raises": {},
        "Section_id": "hsva_to_rgba"
    },
    {
        "Section_id": "hsva_to_rgba",
        "See Also": ""
    },
    {
        "Section_id": "lighten",
        "Description": "Creates a lighter version of a color given by an RGB triplet.\nThis is done by mixing the original color with white using the given ratio. A ratio of 1.0 will yield a completely white color, a ratio of 0.0 will yield the original color."
    },
    {
        "Paramters": {},
        "Section_id": "lighten"
    },
    {
        "Raises": {},
        "Section_id": "lighten"
    },
    {
        "Section_id": "lighten",
        "See Also": ""
    },
    {
        "Section_id": "rgb_to_hsl",
        "Description": "Converts a color given by its RGB coordinates to HSL coordinates (hue, saturation, lightness).\nEach of the RGB coordinates must be in the range [0, 1]."
    },
    {
        "Paramters": {},
        "Section_id": "rgb_to_hsl"
    },
    {
        "Raises": {},
        "Section_id": "rgb_to_hsl"
    },
    {
        "Section_id": "rgb_to_hsl",
        "See Also": ""
    },
    {
        "Section_id": "rgb_to_hsv",
        "Description": "Converts a color given by its RGB coordinates to HSV coordinates (hue, saturation, value).\nEach of the RGB coordinates must be in the range [0, 1]."
    },
    {
        "Paramters": {},
        "Section_id": "rgb_to_hsv"
    },
    {
        "Raises": {},
        "Section_id": "rgb_to_hsv"
    },
    {
        "Section_id": "rgb_to_hsv",
        "See Also": ""
    },
    {
        "Section_id": "rgba_to_hsla",
        "Description": "Converts a color given by its RGBA coordinates to HSLA coordinates (hue, saturation, lightness, alpha).\nEach of the RGBA coordinates must be in the range [0, 1]."
    },
    {
        "Paramters": {},
        "Section_id": "rgba_to_hsla"
    },
    {
        "Raises": {},
        "Section_id": "rgba_to_hsla"
    },
    {
        "Section_id": "rgba_to_hsla",
        "See Also": ""
    },
    {
        "Section_id": "rgba_to_hsva",
        "Description": "Converts a color given by its RGBA coordinates to HSVA coordinates (hue, saturation, value, alpha).\nEach of the RGBA coordinates must be in the range [0, 1]."
    },
    {
        "Paramters": {},
        "Section_id": "rgba_to_hsva"
    },
    {
        "Raises": {},
        "Section_id": "rgba_to_hsva"
    },
    {
        "Section_id": "rgba_to_hsva",
        "See Also": ""
    },
    {
        "Section_id": "default_edge_colors",
        "Description": "Undocumented"
    },
    {
        "Section_id": "known_colors",
        "Description": "Undocumented"
    },
    {
        "Section_id": "palettes",
        "Description": "Undocumented"
    },
    {
        "Section_id": "GephiConnection",
        "Description": "Object that represents a connection to a Gephi master server."
    },
    {
        "Field List > Methods > __del__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GephiConnection"
    },
    {
        "Field List > Methods > __init__": {
            "Description": "Constructs a connection to a Gephi master server.\nThe connection object can be constructed either by specifying theurl directly, or by specifying the host, port andworkspace arguments.  The latter three are evaluated only ifurl is None; otherwise the url will take precedence.\nThe url argument does not have to include the operation (e.g.,?operation=updateGraph); the connection will take care of it.E.g., if you wish to connect to workspace 2 in a local Gephi instanceon port 7341, the correct form to use for the url is as follows:",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": [
                "The url argument does not have to include the operation (e.g.,\n?operation=updateGraph); the connection will take care of it.\nE.g., if you wish to connect to workspace 2 in a local Gephi instance\non port 7341, the correct form to use for the url is as follows:\nhttp://localhost:7341/workspace0\n"
            ]
        },
        "Section_id": "GephiConnection"
    },
    {
        "Field List > Methods > __repr__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GephiConnection"
    },
    {
        "Field List > Methods > close": {
            "Description": "Flushes all the pending operations to the Gephi master server in asingle request.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GephiConnection"
    },
    {
        "Field List > Methods > flush": {
            "Description": "Flushes all the pending operations to the Gephi master server in asingle request.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GephiConnection"
    },
    {
        "Field List > Methods > url": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GephiConnection"
    },
    {
        "Field List > Methods > write": {
            "Description": "Sends the given raw data to the Gephi streaming master server in an HTTPPOST request.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GephiConnection"
    },
    {
        "Field List > property": {
            "url": "The URL of the Gephi workspace where the data will be sent.\n"
        },
        "Section_id": "GephiConnection"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "GephiConnection"
    },
    {
        "Section_id": "ShapeDrawer",
        "Description": "Static class, the ancestor of all vertex shape drawer classes.\nCustom shapes must implement at least the draw_path method of the class. The method must not stroke or fill, it should just set up the current Cairo path appropriately."
    },
    {
        "Field List > Methods > draw_path": {
            "Description": "overridden in igraph.drawing.shapes.CircleDrawer, igraph.drawing.shapes.DiamondDrawer, igraph.drawing.shapes.DownTriangleDrawer, igraph.drawing.shapes.NullDrawer, igraph.drawing.shapes.RectangleDrawer, igraph.drawing.shapes.UpTriangleDrawer\nDraws the path of the shape on the given Cairo context, without stroking or filling it.\nThis method must be overridden in derived classes implementing custom shapes and declared as a static method using staticmethod(...).",
            "Paramters": {
                "ctx": "the context to draw on",
                "center_x": "the X coordinate of the center of the object",
                "center_y": "the Y coordinate of the center of the object",
                "width": "the  of the object",
                "height": "the  of the object. If None, equals to the width.",
                "**kwargs": "Undocumented"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "ShapeDrawer"
    },
    {
        "Field List > Methods > intersection_point": {
            "Description": "overridden in igraph.drawing.shapes.CircleDrawer, igraph.drawing.shapes.DiamondDrawer, igraph.drawing.shapes.DownTriangleDrawer, igraph.drawing.shapes.RectangleDrawer, igraph.drawing.shapes.UpTriangleDrawer\nDetermines where the shape centered at (center_x, center_y) intersects with a line drawn from (source_x, source_y) to (center_x, center_y).\nCan be overridden in derived classes. Must always be defined as a static method using staticmethod(...)",
            "Paramters": {
                "center_x": "Undocumented",
                "center_y": "Undocumented",
                "source_x": "Undocumented",
                "source_y": "Undocumented",
                "width": "the  of the shape",
                "height": "the  of the shape. If None, defaults to the width"
            },
            "Return": [
                "the intersection point (the closest to (source_x, source_y) if there are more than one) or (center_x, center_y) if there is no intersection"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "ShapeDrawer"
    },
    {
        "Field List > property": {},
        "Section_id": "ShapeDrawer"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "ShapeDrawer"
    },
    {
        "Section_id": "MatplotlibMatrixDrawer",
        "Description": "Matplotlib drawer object for matrices."
    },
    {
        "Field List > Methods > __init__": {
            "Description": "Constructs the drawer and associates it to the given Axes.",
            "Paramters": {
                "ax": "the Axes on which we will draw"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "MatplotlibMatrixDrawer"
    },
    {
        "Field List > Methods > draw": {
            "Description": "overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nDraws the given Matrix in a matplotlib Axes.",
            "Paramters": {
                "matrix": "the igraph.Matrix to plot.Keyword arguments are passed to Axes.imshow.",
                "**kwds": "Undocumented"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "MatplotlibMatrixDrawer"
    },
    {
        "Field List > property": {},
        "Section_id": "MatplotlibMatrixDrawer"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "MatplotlibMatrixDrawer"
    },
    {
        "Section_id": "test",
        "Description": "Testing routine for CairoTextDrawer"
    },
    {
        "Paramters": {},
        "Section_id": "test"
    },
    {
        "Raises": {},
        "Section_id": "test"
    },
    {
        "Section_id": "test",
        "See Also": ""
    },
    {
        "Section_id": "AbstractCairoGraphDrawer",
        "Description": "Abstract base class for graph drawers that draw on a Cairo canvas."
    },
    {
        "Field List > Methods > __init__": {
            "Description": "overrides igraph.drawing.cairo.base.AbstractCairoDrawer.__init__\nConstructs the graph drawer and associates it to the given Cairo context and the given BoundingBox.",
            "Paramters": {
                "context": "the  on which we will draw",
                "bbox": "the bounding box within which we will draw. Can be anything accepted by the constructor of BoundingBox (i.e., a 2-tuple, a 4-tuple or a BoundingBox object)."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "AbstractCairoGraphDrawer"
    },
    {
        "Field List > Methods > draw": {
            "Description": "Inherited from AbstractGraphDrawer:Abstract method, must be implemented in derived classes."
        },
        "Section_id": "AbstractCairoGraphDrawer"
    },
    {
        "Field List > property": {},
        "Section_id": "AbstractCairoGraphDrawer"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "AbstractCairoGraphDrawer"
    },
    {
        "Section_id": "FakeModule",
        "Description": "Fake module that raises an exception for everything"
    },
    {
        "Field List > Methods > __call__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "FakeModule"
    },
    {
        "Field List > Methods > __getattr__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "FakeModule"
    },
    {
        "Field List > Methods > __init__": {
            "Description": "Constructor.",
            "Paramters": {
                "message": " to print in exceptions raised from this module"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "FakeModule"
    },
    {
        "Field List > Methods > __setattr__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "FakeModule"
    },
    {
        "Field List > property": {},
        "Section_id": "FakeModule"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "FakeModule"
    },
    {
        "Section_id": "LightToDarkEdgeDrawer",
        "Description": "Edge drawer implementation that draws undirected edges as straight lines and directed edges by using an alpha value of zero (total transparency) at the source and an alpha value of one (full opacity) at the destination. The alpha value is interpolated in-between."
    },
    {
        "Field List > Methods > __init__": {
            "Description": "overrides igraph.drawing.cairo.edge.AlphaVaryingEdgeDrawer.__init__\nConstructs the edge drawer.",
            "Paramters": {
                "context": "a Cairo  on which the edges will be drawn.",
                "palette": "the  that can be used to map integer color indices to colors when drawing edges"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "LightToDarkEdgeDrawer"
    },
    {
        "Field List > Methods > draw_directed_edge": {
            "Description": "Inherited from AlphaVaryingEdgeDrawer:Draws a directed edge."
        },
        "Section_id": "LightToDarkEdgeDrawer"
    },
    {
        "Field List > property": {},
        "Section_id": "LightToDarkEdgeDrawer"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "LightToDarkEdgeDrawer"
    },
    {
        "Section_id": "MatplotlibPaletteDrawer",
        "Description": "Matplotlib drawer object for matrices."
    },
    {
        "Field List > Methods > __init__": {
            "Description": "Constructs the drawer and associates it to the given Axes.",
            "Paramters": {
                "ax": "the Axes on which we will draw"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "MatplotlibPaletteDrawer"
    },
    {
        "Field List > Methods > draw": {
            "Description": "overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nDraws the given Matrix in a matplotlib Axes.",
            "Paramters": {
                "matrix": "the igraph.Histogram to plot.",
                "**kwds": "Undocumented"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "MatplotlibPaletteDrawer"
    },
    {
        "Field List > property": {},
        "Section_id": "MatplotlibPaletteDrawer"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "MatplotlibPaletteDrawer"
    },
    {
        "Section_id": "Shell",
        "Description": "Superclass of the embeddable shells supported by igraph"
    },
    {
        "Field List > Methods > __call__": {
            "Description": "overridden in igraph.app.shell.ClassicPythonShell, igraph.app.shell.IDLEShell, igraph.app.shell.IPythonShell\nUndocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Shell"
    },
    {
        "Field List > Methods > get_progress_handler": {
            "Description": "Returns the progress handler (if exists) or None (if not).",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Shell"
    },
    {
        "Field List > Methods > get_status_handler": {
            "Description": "Returns the status handler (if exists) or None (if not).",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Shell"
    },
    {
        "Field List > Methods > supports_progress_bar": {
            "Description": "Checks whether the shell supports progress bars.\nThis is done by checking for the existence of an attribute called _progress_handler.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Shell"
    },
    {
        "Field List > Methods > supports_status_messages": {
            "Description": "Checks whether the shell supports status messages.\nThis is done by checking for the existence of an attribute called _status_handler.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Shell"
    },
    {
        "Field List > property": {},
        "Section_id": "Shell"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "Shell"
    },
    {
        "Section_id": "GradientPalette",
        "Description": "Base class for gradient palettes\nGradient palettes contain a gradient between two given colors.\n"
    },
    {
        "Field List > Methods > __init__": {
            "Description": "overrides igraph.drawing.colors.Palette.__init__\nCreates a gradient palette.",
            "Paramters": {
                "color1": "the color where the gradient starts.",
                "color2": "the color where the gradient ends.",
                "n": "the umber of colors i the palette."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GradientPalette"
    },
    {
        "Field List > Methods > __len__": {
            "Description": "Inherited from Palette:Returns the number of colors in this palette"
        },
        "Section_id": "GradientPalette"
    },
    {
        "Field List > Methods > __plot__": {
            "Description": "Inherited from Palette:Plots the colors of the palette on the given Cairo context/mpl Axes"
        },
        "Section_id": "GradientPalette"
    },
    {
        "Field List > Methods > __repr__": {
            "Description": "Inherited from Palette:Undocumented"
        },
        "Section_id": "GradientPalette"
    },
    {
        "Field List > Methods > clear_cache": {
            "Description": "Inherited from Palette:Clears the result cache."
        },
        "Section_id": "GradientPalette"
    },
    {
        "Field List > Methods > get": {
            "Description": "Inherited from Palette:Returns the given color from the palette."
        },
        "Section_id": "GradientPalette"
    },
    {
        "Field List > Methods > get_many": {
            "Description": "Inherited from Palette:Returns multiple colors from the palette."
        },
        "Section_id": "GradientPalette"
    },
    {
        "Field List > property": {
            "length": "Inherited from Palette:Returns the number of colors in this palette"
        },
        "Section_id": "GradientPalette"
    },
    {
        "Rubric": {
            "Example": [
                "Example:\n>>> pal = GradientPalette(\"red\", \"blue\", 5)\n>>> pal.get(0)\n(1.0, 0.0, 0.0, 1.0)\n>>> pal.get(2)\n(0.5, 0.0, 0.5, 1.0)\n>>> pal.get(4)\n(0.0, 0.0, 1.0, 1.0)\n"
            ]
        },
        "Section_id": "GradientPalette"
    },
    {
        "Section_id": "TerminalController",
        "Description": "A class that can be used to portably generate formatted output to a terminal.\n"
    },
    {
        "Field List > Methods > __init__": {
            "Description": "Create a TerminalController and initialize its attributes with appropriate values for the current terminal. term_stream is the stream that will be used for terminal output; if this stream is not a tty, then the terminal is assumed to be a dumb terminal (i.e., have no capabilities).",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "TerminalController"
    },
    {
        "Field List > Methods > render": {
            "Description": "Replace each $-substitutions in the given template string with the corresponding terminal control string (if it's defined) or '' (if it's not).",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "TerminalController"
    },
    {
        "Field List > property": {},
        "Section_id": "TerminalController"
    },
    {
        "Rubric": {
            "Example": [
                "TerminalController defines a set of instance variables whose values are initialized to the control sequence necessary to perform a given action.  These can be simply included in normal output to the terminal:\n>>> term = TerminalController()\n>>> print('This is '+term.GREEN+'green'+term.NORMAL)\nThis is green\n",
                "Alternatively, the render() method can used, which replaces ${action} with the string required to perform action:\n>>> term = TerminalController()\n>>> print('This is '+term.GREEN+'green'+term.NORMAL)\nThis is green\n",
                "If the terminal doesn't support a given action, then the value of the corresponding instance variable will be set to ''.  As a result, the above code will still work on terminals that do not support color, except that their output will not be colored. Also, this means that you can test whether the terminal supports a given action by simply testing the truth value of the corresponding instance variable:\n>>> term = TerminalController()\n>>> print('This is '+term.GREEN+'green'+term.NORMAL)\nThis is green\n"
            ]
        },
        "Section_id": "TerminalController"
    },
    {
        "Section_id": "RunningMean",
        "Description": "Running mean calculator.\nThis class can be used to calculate the mean of elements from a list, tuple, iterable or any other data source. The mean is calculated on the fly without explicitly summing the values, so it can be used for data sets with arbitrary item count. Also capable of returning the standard deviation (also calculated on the fly)"
    },
    {
        "Field List > Methods > __complex__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "RunningMean"
    },
    {
        "Field List > Methods > __float__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "RunningMean"
    },
    {
        "Field List > Methods > __init__": {
            "Description": "RunningMean(items=None, n=0.0, mean=0.0, sd=0.0)\nInitializes the running mean calculator.\nThere are two possible ways to initialize the calculator. First, one can provide an iterable of items; alternatively, one can specify the number of items, the mean and the standard deviation if we want to continue an interrupted calculation.",
            "Paramters": {
                "items": "the  that are used to initialize the running mean calcuator. If  is given, n, mean and sd must be zeros.",
                "n": "the iitial umber of elemets already processed. If this is give, items must be Noe.",
                "mean": "the initial . If this is given, items must be None.",
                "sd": "the initial standard deviation. If this is given, items must be None."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "RunningMean"
    },
    {
        "Field List > Methods > __int__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "RunningMean"
    },
    {
        "Field List > Methods > __len__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "RunningMean"
    },
    {
        "Field List > Methods > __repr__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "RunningMean"
    },
    {
        "Field List > Methods > __str__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "RunningMean"
    },
    {
        "Field List > Methods > add": {
            "Description": "RunningMean.add(value, repeat=1)\nAdds the given value to the elements from which we calculate the mean and the standard deviation.",
            "Paramters": {
                "value": "the element to be added",
                "repeat": "number of ed additions"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "RunningMean"
    },
    {
        "Field List > Methods > add_many": {
            "Description": "RunningMean.add(values)\nAdds the values in the given iterable to the elements from which we calculate the mean. Can also accept a single number. The left shift (<<) operator is aliased to this function, so you can use it to add elements as well:",
            "Paramters": {
                "values": ":iterablethe element(s) to be added"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": [
                "Adds the values in the given iterable to the elements from which we calculate the mean. Can also accept a single number. The left shift (<<) operator is aliased to this function, so you can use it to add elements as well:\n>>> rm=RunningMean()\n>>> rm << [1,2,3,4]\n>>> rm.result               # doctest:+ELLIPSIS\n(2.5, 1.290994...)\n"
            ]
        },
        "Section_id": "RunningMean"
    },
    {
        "Field List > Methods > clear": {
            "Description": "Resets the running mean calculator.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "RunningMean"
    },
    {
        "Field List > property": {
            "mean": "Returns the current mean\n",
            "result": "Returns the current mean and standard deviation as a tuple\n",
            "sd": "Returns the current standard deviation\n",
            "var": "Returns the current variation\n"
        },
        "Section_id": "RunningMean"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "RunningMean"
    },
    {
        "Section_id": "Cut",
        "Description": "A cut of a given graph.\nThis is a simple class used to represent cuts returned by Graph.mincut(), Graph.all_st_cuts() and other functions that calculate cuts.\nA cut is a special vertex clustering with only two clusters. Besides the usual VertexClustering methods, it also has the following attributes: value - the value (capacity) of the cut. It is equal to the number of edges if there are no capacities on the edges. partition - vertex IDs in the parts created after removing edges in the cut cut - edge IDs in the cut es - an edge selector restricted to the edges in the cut. \nYou can use indexing on this object to obtain lists of vertex IDs for both sides of the partition.\nThis class is usually not instantiated directly, everything is taken care of by the functions that return cuts.\n"
    },
    {
        "Field List > Methods > __init__": {
            "Description": "overrides igraph.VertexClustering.__init__\nInitializes the cut.\nThis should not be called directly, everything is taken care of by the functions that return cuts.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Cut"
    },
    {
        "Field List > Methods > __repr__": {
            "Description": "overridden in igraph.Flow\nUndocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Cut"
    },
    {
        "Field List > Methods > __str__": {
            "Description": "overrides igraph.Clustering.__str__\nUndocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Cut"
    },
    {
        "Field List > Methods > __plot__": {
            "Description": "Inherited from VertexClustering:Plots the clustering to the given Cairo context or matplotlib Axes."
        },
        "Section_id": "Cut"
    },
    {
        "Field List > Methods > as_cover": {
            "Description": "Inherited from VertexClustering:Returns a VertexCover that contains the same clusters as this clustering."
        },
        "Section_id": "Cut"
    },
    {
        "Field List > Methods > cluster_graph": {
            "Description": "Inherited from VertexClustering:Returns a graph where each cluster is contracted into a single vertex."
        },
        "Section_id": "Cut"
    },
    {
        "Field List > Methods > crossing": {
            "Description": "Inherited from VertexClustering:Returns a boolean vector where element i is True iff edge i lies between clusters, False otherwise."
        },
        "Section_id": "Cut"
    },
    {
        "Field List > Methods > giant": {
            "Description": "Inherited from VertexClustering:Returns the largest cluster of the clustered graph."
        },
        "Section_id": "Cut"
    },
    {
        "Field List > Methods > recalculate_modularity": {
            "Description": "Inherited from VertexClustering:Recalculates the stored modularity value."
        },
        "Section_id": "Cut"
    },
    {
        "Field List > Methods > subgraph": {
            "Description": "Inherited from VertexClustering:Get the subgraph belonging to a given cluster."
        },
        "Section_id": "Cut"
    },
    {
        "Field List > Methods > subgraphs": {
            "Description": "Inherited from VertexClustering:Gets all the subgraphs belonging to each of the clusters."
        },
        "Section_id": "Cut"
    },
    {
        "Field List > property": {
            "cut": "Returns the edge IDs in the cut\n",
            "es": "Returns an edge selector restricted to the cut\n",
            "partition": "Returns the vertex IDs partitioned according to the cut\n",
            "value": "Returns the sum of edge capacities in the cut\n",
            "graph": "Inherited from VertexClustering:Returns the graph belonging to this object",
            "modularity": "Inherited from VertexClustering:Returns the modularity score"
        },
        "Section_id": "Cut"
    },
    {
        "Rubric": {
            "Example": [
                "Examples:\n>>> from igraph import Graph\n>>> g = Graph.Ring(20)\n>>> mc = g.mincut()\n>>> print(mc.value)\n2.0\n>>> print(min(len(x) for x in mc))\n1\n>>> mc.es[\"color\"] = \"red\""
            ]
        },
        "Section_id": "Cut"
    },
    {
        "Section_id": "HullCollection",
        "Description": "Collection for hulls connecting vertex covers/clusters.\nThe class takes the normal arguments of a PathCollection, plus one argument called \"corner_radius\" that specifies how much to smoothen the polygon vertices into round corners. This argument can be a float or a sequence of floats, one for each hull to be drawn."
    },
    {
        "Field List > Methods > __init__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "HullCollection"
    },
    {
        "Field List > Methods > draw": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "HullCollection"
    },
    {
        "Field List > property": {},
        "Section_id": "HullCollection"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "HullCollection"
    },
    {
        "Section_id": "CairoGraphDrawer",
        "Description": "Class implementing the default visualisation of a graph.\nThe default visualisation of a graph draws the nodes on a 2D plane according to a given Layout, then draws a straight or curved edge between nodes connected by edges. This is the visualisation used when one invokes the plot() function on a Graph object.\nSee Graph.__plot__() for the keyword arguments understood by this drawer."
    },
    {
        "Field List > Methods > __init__": {
            "Description": "overrides igraph.drawing.cairo.graph.AbstractCairoGraphDrawer.__init__\nConstructs the graph drawer and associates it to the given Cairo context and the given BoundingBox.",
            "Paramters": {
                "context": "the  on which we will draw",
                "bbox": "the bounding box within which we will draw. Can be anything accepted by the constructor of BoundingBox (i.e., a 2-tuple, a 4-tuple or a BoundingBox object).",
                "vertex_drawer_factory": "a factory method that returns an AbstractCairoVertexDrawer instance bound to a given Cairo context. The factory method must take four parameters: the Cairo context, the bounding box of the drawing area, the palette to be used for drawing colored vertices, and the graph layout. The default vertex drawer is CairoVertexDrawer.",
                "edge_drawer_factory": "a factory method that returns an AbstractCairoEdgeDrawer instance bound to a given Cairo context. The factory method must take two parameters: the Cairo context and the palette to be used for drawing colored edges. You can use any of the actual AbstractEdgeDrawer implementations here to control the style of edges drawn by igraph. The default edge drawer is CairoArrowEdgeDrawer.",
                "label_drawer_factory": "a factory method that returns a CairoTextDrawer instance bound to a given Cairo context. The method must take one parameter: the Cairo context. The default label drawer is CairoTextDrawer."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "CairoGraphDrawer"
    },
    {
        "Field List > Methods > draw": {
            "Description": "overrides igraph.drawing.baseclasses.AbstractGraphDrawer.draw\nAbstract method, must be implemented in derived classes.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "CairoGraphDrawer"
    },
    {
        "Field List > property": {},
        "Section_id": "CairoGraphDrawer"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "CairoGraphDrawer"
    },
    {
        "Section_id": "Vertex",
        "Description": "Class representing a single vertex in a graph.\nThe vertex is referenced by its index, so if the underlying graph changes, the semantics of the vertex object might change as well (if the vertex indices are altered in the original graph).\n"
    },
    {
        "Field List > Methods > all_edges": {
            "Description": "Proxy method to Graph.incident(..., mode=\"all\")\nThis method calls the incident() method of the Graph class with this vertex as the first argument and \"all\" as the mode argument, and returns the result.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "Graph.incident() for details.",
            "example": []
        },
        "Section_id": "Vertex"
    },
    {
        "Field List > Methods > attribute_names": {
            "Description": "Returns the list of vertex attribute names",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Vertex"
    },
    {
        "Field List > Methods > attributes": {
            "Description": "Returns a dict of attribute names and values for the vertex",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Vertex"
    },
    {
        "Field List > Methods > betweenness": {
            "Description": "Proxy method to Graph.betweenness()\nThis method calls the betweenness() method of the Graph class with this vertex as the first argument, and returns the result.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "Graph.betweenness() for details.",
            "example": []
        },
        "Section_id": "Vertex"
    },
    {
        "Field List > Methods > closeness": {
            "Description": "Proxy method to Graph.closeness()\nThis method calls the closeness() method of the Graph class with this vertex as the first argument, and returns the result.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "Graph.closeness() for details.",
            "example": []
        },
        "Section_id": "Vertex"
    },
    {
        "Field List > Methods > constraint": {
            "Description": "Proxy method to Graph.constraint()\nThis method calls the constraint() method of the Graph class with this vertex as the first argument, and returns the result.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "Graph.constraint() for details.",
            "example": []
        },
        "Section_id": "Vertex"
    },
    {
        "Field List > Methods > degree": {
            "Description": "Proxy method to Graph.degree()\nThis method calls the degree() method of the Graph class with this vertex as the first argument, and returns the result.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "Graph.degree() for details.",
            "example": []
        },
        "Section_id": "Vertex"
    },
    {
        "Field List > Methods > delete": {
            "Description": "Proxy method to Graph.delete_vertices()\nThis method calls the delete_vertices method of the Graph class with this vertex as the first argument, and returns the result.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "Graph.delete_vertices() for details.",
            "example": []
        },
        "Section_id": "Vertex"
    },
    {
        "Field List > Methods > distances": {
            "Description": "Proxy method to Graph.distances()\nThis method calls the distances() method of the Graph class with this vertex as the first argument, and returns the result.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "Graph.distances() for details.",
            "example": []
        },
        "Section_id": "Vertex"
    },
    {
        "Field List > Methods > diversity": {
            "Description": "Proxy method to Graph.diversity()\nThis method calls the diversity() method of the Graph class with this vertex as the first argument, and returns the result.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "Graph.diversity() for details.",
            "example": []
        },
        "Section_id": "Vertex"
    },
    {
        "Field List > Methods > eccentricity": {
            "Description": "Proxy method to Graph.eccentricity()\nThis method calls the eccentricity() method of the Graph class with this vertex as the first argument, and returns the result.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "Graph.eccentricity() for details.",
            "example": []
        },
        "Section_id": "Vertex"
    },
    {
        "Field List > Methods > get_shortest_paths": {
            "Description": "Proxy method to Graph.get_shortest_paths()\nThis method calls the get_shortest_paths() method of the Graph class with this vertex as the first argument, and returns the result.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "Graph.get_shortest_paths() for details.",
            "example": []
        },
        "Section_id": "Vertex"
    },
    {
        "Field List > Methods > in_edges": {
            "Description": "Proxy method to Graph.incident(..., mode=\"in\")\nThis method calls the incident() method of the Graph class with this vertex as the first argument and \"in\" as the mode argument, and returns the result.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "Graph.incident() for details.",
            "example": []
        },
        "Section_id": "Vertex"
    },
    {
        "Field List > Methods > incident": {
            "Description": "Proxy method to Graph.incident()\nThis method calls the incident() method of the Graph class with this vertex as the first argument, and returns the result.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "Graph.incident() for details.",
            "example": []
        },
        "Section_id": "Vertex"
    },
    {
        "Field List > Methods > indegree": {
            "Description": "Proxy method to Graph.indegree()\nThis method calls the indegree() method of the Graph class with this vertex as the first argument, and returns the result.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "Graph.indegree() for details.",
            "example": []
        },
        "Section_id": "Vertex"
    },
    {
        "Field List > Methods > is_minimal_separator": {
            "Description": "Proxy method to Graph.is_minimal_separator()\nThis method calls the is_minimal_separator() method of the Graph class with this vertex as the first argument, and returns the result.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "Graph.is_minimal_separator() for details.",
            "example": []
        },
        "Section_id": "Vertex"
    },
    {
        "Field List > Methods > is_separator": {
            "Description": "Proxy method to Graph.is_separator()\nThis method calls the is_separator() method of the Graph class with this vertex as the first argument, and returns the result.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "Graph.is_separator() for details.",
            "example": []
        },
        "Section_id": "Vertex"
    },
    {
        "Field List > Methods > neighbors": {
            "Description": "Proxy method to Graph.neighbors()\nThis method calls the neighbors() method of the Graph class with this vertex as the first argument, and returns the result.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "Graph.neighbors() for details.",
            "example": []
        },
        "Section_id": "Vertex"
    },
    {
        "Field List > Methods > out_edges": {
            "Description": "Proxy method to Graph.incident(..., mode=\"out\")\nThis method calls the incident() method of the Graph class with this vertex as the first argument and \"out\" as the mode argument, and returns the result.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "Graph.incident() for details.",
            "example": []
        },
        "Section_id": "Vertex"
    },
    {
        "Field List > Methods > outdegree": {
            "Description": "Proxy method to Graph.outdegree()\nThis method calls the outdegree() method of the Graph class with this vertex as the first argument, and returns the result.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "Graph.outdegree() for details.",
            "example": []
        },
        "Section_id": "Vertex"
    },
    {
        "Field List > Methods > pagerank": {
            "Description": "Proxy method to Graph.pagerank()\nThis method calls the pagerank() method of the Graph class with this vertex as the first argument, and returns the result.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "Graph.pagerank() for details.",
            "example": []
        },
        "Section_id": "Vertex"
    },
    {
        "Field List > Methods > personalized_pagerank": {
            "Description": "Proxy method to Graph.personalized_pagerank()\nThis method calls the personalized_pagerank() method of the Graph class with this vertex as the first argument, and returns the result.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "Graph.personalized_pagerank() for details.",
            "example": []
        },
        "Section_id": "Vertex"
    },
    {
        "Field List > Methods > predecessors": {
            "Description": "Proxy method to Graph.predecessors()\nThis method calls the predecessors() method of the Graph class with this vertex as the first argument, and returns the result.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "Graph.predecessors() for details.",
            "example": []
        },
        "Section_id": "Vertex"
    },
    {
        "Field List > Methods > strength": {
            "Description": "Proxy method to Graph.strength()\nThis method calls the strength() method of the Graph class with this vertex as the first argument, and returns the result.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "Graph.strength() for details.",
            "example": []
        },
        "Section_id": "Vertex"
    },
    {
        "Field List > Methods > successors": {
            "Description": "Proxy method to Graph.successors()\nThis method calls the successors() method of the Graph class with this vertex as the first argument, and returns the result.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "Graph.successors() for details.",
            "example": []
        },
        "Section_id": "Vertex"
    },
    {
        "Field List > Methods > update_attributes": {
            "Description": "Updates the attributes of the vertex from dict/iterable E and F.\nIf E has a keys() method, it does: for k in E: self[k] = E[k]. If E lacks a keys() method, it does: for (k, v) in E: self[k] = v. In either case, this is followed by: for k in F: self[k] = F[k].\nThis method thus behaves similarly to the update() method of Python dictionaries.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Vertex"
    },
    {
        "Field List > property": {},
        "Section_id": "Vertex"
    },
    {
        "Rubric": {
            "Example": [
                "The attributes of the vertex can be accessed by using the vertex as a hash:\n>>> v[\"color\"] = \"red\"                  #doctest: +SKIP\n>>> print(v[\"color\"])                     #doctest: +SKIP\nred\n"
            ]
        },
        "Section_id": "Vertex"
    },
    {
        "Section_id": "Palette",
        "Description": "Base class of color palettes.\nColor palettes are mappings that assign integers from the range 0..n\u2009\u2212\u20091 to colors (4-tuples). n is called the size or length of the palette. igraph comes with a number of predefined palettes, so this class is useful for you only if you want to define your own palette. This can be done by subclassing this class and implementing the Palette._get method as necessary.\nPalettes can also be used as lists or dicts, for the __getitem__ method is overridden properly to call Palette.get."
    },
    {
        "Field List > Methods > __init__": {
            "Description": "overridden in igraph.drawing.colors.AdvancedGradientPalette, igraph.drawing.colors.GradientPalette, igraph.drawing.colors.PrecalculatedPalette, igraph.drawing.colors.RainbowPalette\nUndocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Palette"
    },
    {
        "Field List > Methods > __len__": {
            "Description": "Returns the number of colors in this palette",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Palette"
    },
    {
        "Field List > Methods > __plot__": {
            "Description": "Plots the colors of the palette on the given Cairo context/mpl Axes\nSupported keywork arguments in both Cairo and matplotlib are:orientation: the orientation of the palette. Must be one of the following values: left-right, bottom-top, right-left or top-bottom. Possible aliases: horizontal = left-right, vertical = bottom-top, lr = left-right, rl = right-left, tb = top-bottom, bt = bottom-top. The default is left-right.\nAdditional supported keyword arguments in Cairo are:border_width: line width of the border shown around the palette. If zero or negative, the border is turned off. Default is 1.grid_width: line width of the grid that separates palette cells. If zero or negative, the grid is turned off. The grid is also turned off if the size of a cell is less than three times the given line width. Default is 0.  Fractional widths are also allowed.\nKeyword arguments in matplotlib are passes to Axes.imshow.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Palette"
    },
    {
        "Field List > Methods > __repr__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Palette"
    },
    {
        "Field List > Methods > clear_cache": {
            "Description": "Clears the result cache.\nThe return values of Palette.get are cached. Use this method to clear the cache.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Palette"
    },
    {
        "Field List > Methods > get": {
            "Description": "Returns the given color from the palette.\nValues are cached: if the specific value given has already been looked up, its value will be returned from the cache instead of calculating it again. Use Palette.clear_cache to clear the cache if necessary.",
            "Paramters": {
                "v": "the color to be retrieed. If it is an integer, it is passed to Palette._get to be translated to an RGBA quadruplet. Otherwise it is passed to color_name_to_rgb() to determine the RGBA alues."
            },
            "Return": [
                "the color as an RGBA quadruplet",
                "you shouldn't override this method in subclasses, override _get instead. If you override this method, lookups in the known_colors dict won't work, so you won't be able to refer to colors by names or RGBA quadruplets, only by integer indices. The caching functionality will disappear as well. However, feel free to override this method if this is exactly the behaviour you want."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Palette"
    },
    {
        "Field List > Methods > get_many": {
            "Description": "Returns multiple colors from the palette.\nValues are cached: if the specific value given has already been looked upon, its value will be returned from the cache instead of calculating it again. Use Palette.clear_cache to clear the cache if necessary.",
            "Paramters": {
                "colors": "the list of  to be retrieved. The palette class tries to make an educated guess here: if it is not possible to interpret the value you passed here as a list of , the class will simply try to interpret it as a single color by forwarding the value to Palette.get."
            },
            "Return": [
                "the colors as a list of RGBA quadruplets. The result will be a list even if you passed a single color index or color name."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Palette"
    },
    {
        "Field List > property": {
            "length": "Returns the number of colors in this palette\n"
        },
        "Section_id": "Palette"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "Palette"
    },
    {
        "Section_id": "VertexSeq",
        "Description": "Low-level representation of a vertex sequence.\nDon't use it directly, use igraph.VertexSeq instead."
    },
    {
        "Field List > Methods > attribute_names": {
            "Description": "Returns the attribute name list of the graph's vertices",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "VertexSeq"
    },
    {
        "Field List > Methods > find": {
            "Description": "overridden in igraph.VertexSeq\nFor internal use only.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "VertexSeq"
    },
    {
        "Field List > Methods > get_attribute_values": {
            "Description": "Returns the value of a given vertex attribute for all vertices in a list.\nThe values stored in the list are exactly the same objects that are stored in the vertex attribute, meaning that in the case of mutable objects, the modification of the list element does affect the attribute stored in the vertex. In the case of immutable objects, modification of the list does not affect the attribute values.",
            "Paramters": {
                "attrname": "the name of the attribute"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "VertexSeq"
    },
    {
        "Field List > Methods > select": {
            "Description": "overridden in igraph.VertexSeq\nFor internal use only.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "VertexSeq"
    },
    {
        "Field List > Methods > set_attribute_values": {
            "Description": "Sets the value of a given vertex attribute for all vertices",
            "Paramters": {
                "attrname": "the name of the attribute",
                "values": "the new attribute  in a list"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "VertexSeq"
    },
    {
        "Field List > property": {},
        "Section_id": "VertexSeq"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "VertexSeq"
    },
    {
        "Section_id": "Dendrogram",
        "Description": "The hierarchical clustering (dendrogram) of some dataset.\nA hierarchical clustering means that we know not only the way the elements are separated into groups, but also the exact history of how individual elements were joined into larger subgroups.\n"
    },
    {
        "Field List > Methods > __init__": {
            "Description": "overridden in igraph.VertexDendrogram\nCreates a hierarchical clustering.",
            "Paramters": {
                "merges": "the merge history either in matrix or tuple format"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Dendrogram"
    },
    {
        "Field List > Methods > __plot__": {
            "Description": "overridden in igraph.VertexDendrogram\nDraws the dendrogram on the given Cairo context or matplotlib Axes.\nSupported keyword arguments are:orientation: the orientation of the dendrogram. Must be one of the following values: left-right, bottom-top, right-left or top-bottom. Individual elements are always placed at the former edge and merges are performed towards the latter edge. Possible aliases: horizontal = left-right, vertical = bottom-top, lr = left-right, rl = right-left, tb = top-bottom, bt = bottom-top. The default is left-right.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Dendrogram"
    },
    {
        "Field List > Methods > __str__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Dendrogram"
    },
    {
        "Field List > Methods > format": {
            "Description": "Formats the dendrogram in a foreign format.\nCurrently only the Newick format is supported.\nExample:",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": [
                "Example:\n>>> d = Dendrogram([(2, 3), (0, 1), (4, 5)])\n>>> d.format()\n'((2,3)4,(0,1)5)6;'\n>>> d.names = list(\"ABCDEFG\")\n>>> d.format()\n'((C,D)E,(A,B)F)G;'\n"
            ]
        },
        "Section_id": "Dendrogram"
    },
    {
        "Field List > Methods > names": {
            "Description": "Sets the names of the nodes in the dendrogram",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Dendrogram"
    },
    {
        "Field List > Methods > summary": {
            "Description": "Returns the summary of the dendrogram.\nThe summary includes the number of leafs and branches, and also an ASCII art representation of the dendrogram unless it is too large.",
            "Paramters": {
                "verbosity": "determines whether the ASCII representation of the dendrogram should be printed. Zero  prints only the number of leafs and branches.",
                "max_leaf_count": "the maximal number of leafs to print in the ASCII representation. If the dendrogram has more leafs than this limit, the ASCII representation will not be printed even if the verbosity is larger than or equal to 1."
            },
            "Return": [
                "the summary of the dendrogram as a string."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Dendrogram"
    },
    {
        "Field List > property": {
            "merges": "Returns the performed merges in matrix format\n",
            "names": "Returns the names of the nodes in the dendrogram\n"
        },
        "Section_id": "Dendrogram"
    },
    {
        "Rubric": {
            "Example": [
                "This class internally represents the hierarchy by a matrix with n rows and 2 columns -- or more precisely, a list of lists of size 2. This is exactly the same as the original format used by igraph's C core. The ith row of the matrix contains the indices of the two clusters being joined in time step i. The joint group will be represented by the ID n\u2009+\u2009i, with i starting from one. The ID of the joint group will be referenced in the upcoming steps instead of any of its individual members. So, IDs less than or equal to n (where n is the number of rows in the matrix) mean the original members of the dataset (with ID from 0 to n), while IDs up from n\u2009+\u20091 mean joint groups. As an example, take a look at the dendrogram and the internal representation of a given clustering of five nodes:\n  0 -+\n     |\n  1 -+-+\n       |\n  2 ---+-+        <====>   [[0, 1], [3, 4], [2, 5], [6, 7]]\n         |\n  3 -+   |\n     |   |\n  4 -+---+---\n"
            ]
        },
        "Section_id": "Dendrogram"
    },
    {
        "Section_id": "CytoscapeGraphDrawer",
        "Description": "Graph drawer that sends/receives graphs to/from Cytoscape using CytoscapeRPC.\nThis graph drawer cooperates with Cytoscape using CytoscapeRPC. You need to install the CytoscapeRPC plugin first and start the XML-RPC server on a given port (port 9000 by default) from the appropriate Plugins submenu in Cytoscape.\nGraph, vertex and edge attributes are transferred to Cytoscape whenever possible (i.e. when a suitable mapping exists between a Python type and a Cytoscape type). If there is no suitable Cytoscape type for a Python type, the drawer will use a string attribute on the Cytoscape side and invoke str() on the Python attributes.\nIf an attribute to be created on the Cytoscape side already exists with a different type, an underscore will be appended to the attribute name to resolve the type conflict.\nYou can use the network_id attribute of this class to figure out the network ID of the last graph drawn with this drawer."
    },
    {
        "Field List > Methods > infer_cytoscape_type": {
            "Description": "Returns a Cytoscape type that can be used to represent all the values in values and an appropriately converted copy of values that is suitable for an XML-RPC call.  Note that the string type in Cytoscape is used as a catch-all type; if no other type fits, attribute values will be converted to string and then posted to Cytoscape.\nNone entries are allowed in values, they will be ignored on the Cytoscape side.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "CytoscapeGraphDrawer"
    },
    {
        "Field List > Methods > __init__": {
            "Description": "overrides igraph.drawing.baseclasses.AbstractXMLRPCDrawer.__init__\nConstructs a Cytoscape graph drawer using the XML-RPC interface of Cytoscape at the given URL.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "CytoscapeGraphDrawer"
    },
    {
        "Field List > Methods > draw": {
            "Description": "overrides igraph.drawing.baseclasses.AbstractGraphDrawer.draw\nSends the given graph to Cytoscape as a new network.",
            "Paramters": {
                "graph": "Undocumented",
                "name": "the  of the network in Cytoscape.",
                "create_view": "whether to create a view for the network in Cytoscape.The default is True.",
                "*args": "Undocumented",
                "node_ids": "specifies the identifiers of the nodes to be used in Cytoscape. This must either be the name of a vertex attribute or a list specifying the identifiers, one for each node in the graph. The default is None, which simply uses the vertex index for each vertex."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "CytoscapeGraphDrawer"
    },
    {
        "Field List > Methods > fetch": {
            "Description": "Fetches the network with the given name from Cytoscape.\nWhen fetching networks from Cytoscape, the canonicalName attributes of vertices and edges are not converted by default. Use the keep_canonical_names parameter to retrieve these attributes as well.",
            "Paramters": {
                "name": "the  of the network in Cytoscape.",
                "directed": "whether the network is .",
                "keep_canonical_names": "whether to keep the canonicalName vertex/edge attributes that are added automatically by Cytoscape"
            },
            "Return": [
                "an appropriately constructed igraph Graph."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "CytoscapeGraphDrawer"
    },
    {
        "Field List > property": {},
        "Section_id": "CytoscapeGraphDrawer"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "CytoscapeGraphDrawer"
    },
    {
        "Section_id": "GraphArtist",
        "Description": "Artist for an igraph.Graph object.ParametersgraphAn igraph.Graph object to plotlayoutA layout object or matrix of coordinates to use for plotting. Each element or row should describes the coordinates for a vertex.vertex_styleA dictionary specifying style options for vertices.edge_styleA dictionary specifying style options for edges."
    },
    {
        "Field List > Methods > __init__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphArtist"
    },
    {
        "Field List > Methods > contains": {
            "Description": "Track 'contains' event for mouse interactions.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphArtist"
    },
    {
        "Field List > Methods > draw": {
            "Description": "overrides igraph.drawing.baseclasses.AbstractGraphDrawer.draw\nDraw each of the children, with some buffering mechanism.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphArtist"
    },
    {
        "Field List > Methods > get_children": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphArtist"
    },
    {
        "Field List > Methods > get_datalim": {
            "Description": "Get limits on x/y axes based on the graph layout data.\nThere is a small padding based on the size of the vertex marker to ensure it fits into the canvas.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphArtist"
    },
    {
        "Field List > Methods > get_edge_labels": {
            "Description": "Get list of edge label artists.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphArtist"
    },
    {
        "Field List > Methods > get_edges": {
            "Description": "Get EdgeCollection artist.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphArtist"
    },
    {
        "Field List > Methods > get_groups": {
            "Description": "Get HullCollection group/cluster/cover artists.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphArtist"
    },
    {
        "Field List > Methods > get_vertex_labels": {
            "Description": "Get list of vertex label artists.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphArtist"
    },
    {
        "Field List > Methods > get_vertices": {
            "Description": "Get VertexCollection artist.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphArtist"
    },
    {
        "Field List > Methods > pick": {
            "Description": "Track 'pick' event for mouse interactions.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphArtist"
    },
    {
        "Field List > Methods > set": {
            "Description": "Set multiple parameters at once.\nThe same options can be used as in the igraph.plot function.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphArtist"
    },
    {
        "Field List > property": {},
        "Section_id": "GraphArtist"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "GraphArtist"
    },
    {
        "Section_id": "VertexClustering",
        "Description": "The clustering of the vertex set of a graph.\nThis class extends Clustering by linking it to a specific Graph object and by optionally storing the modularity score of the clustering. It also provides some handy methods like getting the subgraph corresponding to a cluster and such.Notesince this class is linked to a Graph, destroying the graph by the del operator does not free the memory occupied by the graph if there exists a VertexClustering that references the Graph."
    },
    {
        "Field List > Methods > FromAttribute": {
            "Description": "Creates a vertex clustering based on the value of a vertex attribute.\nVertices having the same attribute will correspond to the same cluster.",
            "Paramters": {
                "graph": "the  on which we are working",
                "attribute": "name of the  on which the clustering is based.",
                "intervals": "for numeric attributes, you can either pass a single number or a list of numbers here. A single number means that the vertices will be put in bins of that width and vertices ending up in the same bin will be in the same cluster. A list of numbers specify the bin positions explicitly; e.g., [10, 20, 30] means that there will be four categories: vertices with the attribute value less than 10, between 10 and 20, between 20 and 30 and over 30. Intervals are closed from the left and open from the right.",
                "params": "additional parameters to be stored in this object."
            },
            "Return": [
                "a new VertexClustering object"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "VertexClustering"
    },
    {
        "Field List > Methods > __init__": {
            "Description": "overrides igraph.Clustering.__init__\nCreates a clustering object for a given graph.",
            "Paramters": {
                "graph": "the  that will be associated to the clustering",
                "membership": "the  list. The length of the list must be equal to the number of vertices in the graph. If None, every vertex is assumed to belong to the same cluster.",
                "modularity": "the  score of the clustering. If None, it will be calculated when needed.",
                "params": "additional parameters to be stored in this object.",
                "modularity_params": "arguments that should be passed to Graph.modularity when the modularity is (re)calculated. If the original graph was weighted, you should pass a dictionary containing a weight key with the appropriate value here."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "VertexClustering"
    },
    {
        "Field List > Methods > __plot__": {
            "Description": "Plots the clustering to the given Cairo context or matplotlib Axes.\nThis is done by calling Graph.__plot__() with the same arguments, but coloring the graph vertices according to the current clustering (unless overridden by the vertex_color argument explicitly).\nThis method understands all the positional and keyword arguments that are understood by Graph.__plot__(), only the differences will be highlighted here:mark_groups: whether to highlight some of the vertex groups by colored polygons. Besides the values accepted by Graph.__plot__ (i.e., a dict mapping colors to vertex indices, a list containing lists of vertex indices, or False), the following are also accepted:True: all the groups will be highlighted, the colors matching the corresponding color indices from the current palette (see the palette keyword argument of Graph.__plot__).A dict mapping cluster indices or tuples of vertex indices to color names.  The given clusters or vertex groups will be highlighted by the given colors.A list of cluster indices. This is equivalent to passing a dict mapping numeric color indices from the current palette to cluster indices; therefore, the cluster referred to by element i of the list will be highlighted by color i from the palette.The value of the plotting.mark_groups configuration key is also taken into account here; if that configuration key is True and mark_groups is not given explicitly, it will automatically be set to True.In place of lists of vertex indices, you may also use VertexSeq instances.In place of color names, you may also use color indices into the current palette. None as a color name will mean that the corresponding group is ignored.palette: the palette used to resolve numeric color indices to RGBA values. By default, this is an instance of ClusterColoringPalette.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "Graph.__plot__() for more supported keyword arguments.",
            "example": []
        },
        "Section_id": "VertexClustering"
    },
    {
        "Field List > Methods > as_cover": {
            "Description": "overrides igraph.Clustering.as_cover\nReturns a VertexCover that contains the same clusters as this clustering.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "VertexClustering"
    },
    {
        "Field List > Methods > cluster_graph": {
            "Description": "Returns a graph where each cluster is contracted into a single vertex.\nIn the resulting graph, vertex i represents cluster i in this clustering. Vertex i and j will be connected if there was at least one connected vertex pair (a,\u2009b) in the original graph such that vertex a was in cluster i and vertex b was in cluster j.",
            "Paramters": {
                "combine_vertices": "specifies how to derive the attributes of the vertices in the new graph from the attributes of the old ones. See Graph.contract_vertices() for more details.",
                "combine_edges": "specifies how to derive the attributes of the edges in the new graph from the attributes of the old ones. See Graph.simplify() for more details. If you specify False here, edges will not be combined, and the number of edges between the vertices representing the original clusters will be equal to the number of edges between the members of those clusters in the original graph."
            },
            "Return": [
                "the new graph."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "VertexClustering"
    },
    {
        "Field List > Methods > crossing": {
            "Description": "Returns a boolean vector where element i is True iff edge i lies between clusters, False otherwise.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "VertexClustering"
    },
    {
        "Field List > Methods > giant": {
            "Description": "Returns the largest cluster of the clustered graph.\nThe largest cluster is a cluster for which no larger cluster exists in the clustering. It may also be known as the giant community if the clustering represents the result of a community detection function.\nPrecondition: the vertex set of the graph hasn't been modified since the moment the cover was constructed.",
            "Paramters": {},
            "Return": [
                "a copy of the largest cluster.",
                "there can be multiple largest clusters, this method will return the copy of an arbitrary one if there are multiple largest clusters."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "VertexClustering"
    },
    {
        "Field List > Methods > recalculate_modularity": {
            "Description": "Recalculates the stored modularity value.\nThis method must be called before querying the modularity score of the clustering through the class member modularity or q if the graph has been modified (edges have been added or removed) since the creation of the VertexClustering object.",
            "Paramters": {},
            "Return": [
                "the new modularity score"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "VertexClustering"
    },
    {
        "Field List > Methods > subgraph": {
            "Description": "Get the subgraph belonging to a given cluster.\nPrecondition: the vertex set of the graph hasn't been modified since the moment the cover was constructed.",
            "Paramters": {
                "idx": "the cluster index"
            },
            "Return": [
                "a copy of the subgraph"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "VertexClustering"
    },
    {
        "Field List > Methods > subgraphs": {
            "Description": "Gets all the subgraphs belonging to each of the clusters.\nPrecondition: the vertex set of the graph hasn't been modified since the moment the cover was constructed.",
            "Paramters": {},
            "Return": [
                "a list containing copies of the subgraphs"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "VertexClustering"
    },
    {
        "Field List > Methods > __getitem__": {
            "Description": "Inherited from Clustering:Returns the members of the specified cluster."
        },
        "Section_id": "VertexClustering"
    },
    {
        "Field List > Methods > __iter__": {
            "Description": "Inherited from Clustering:Iterates over the clusters in this clustering."
        },
        "Section_id": "VertexClustering"
    },
    {
        "Field List > Methods > __len__": {
            "Description": "Inherited from Clustering:Returns the number of clusters."
        },
        "Section_id": "VertexClustering"
    },
    {
        "Field List > Methods > __str__": {
            "Description": "Inherited from Clustering:Undocumented"
        },
        "Section_id": "VertexClustering"
    },
    {
        "Field List > Methods > compare_to": {
            "Description": "Inherited from Clustering:Compares this clustering to another one using some similarity or distance metric."
        },
        "Section_id": "VertexClustering"
    },
    {
        "Field List > Methods > size": {
            "Description": "Inherited from Clustering:Returns the size of a given cluster."
        },
        "Section_id": "VertexClustering"
    },
    {
        "Field List > Methods > size_histogram": {
            "Description": "Inherited from Clustering:Returns the histogram of cluster sizes."
        },
        "Section_id": "VertexClustering"
    },
    {
        "Field List > Methods > sizes": {
            "Description": "Inherited from Clustering:Returns the size of given clusters."
        },
        "Section_id": "VertexClustering"
    },
    {
        "Field List > Methods > summary": {
            "Description": "Inherited from Clustering:Returns the summary of the clustering."
        },
        "Section_id": "VertexClustering"
    },
    {
        "Field List > property": {
            "graph": "Returns the graph belonging to this object\n",
            "modularity": "Returns the modularity score\n",
            "membership": "Inherited from Clustering:Returns the membership vector.",
            "n": "Inherited from Clustering:Returns the number of elements covered by this clustering."
        },
        "Section_id": "VertexClustering"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "VertexClustering"
    },
    {
        "Section_id": "plot",
        "Description": "Plots the given object to the given target.\nPositional and keyword arguments not explicitly mentioned here will be passed down to the __plot__ method of the object being plotted. Since you are most likely interested in the keyword arguments available for graph plots, see Graph.__plot__ as well."
    },
    {
        "Paramters": {
            "obj": "the ect to be plotted",
            "target": "the  where the object should be plotted. It can be one of the following types:matplotib.axes.Axes -- a matplotlib/pyplot axes in which the graph will be plotted. Drawing is delegated to the chosen matplotlib backend, and you can use interactive backends and matplotlib functions to save to file as well.string -- a file with the given name will be created and the plot will be stored there. If you are using the Cairo backend, an appropriate Cairo surface will be attached to the file. If you are using the matplotlib backend, the Figure will be saved to that file using Figure.savefig with default parameters. The supported image formats for Cairo are: PNG, PDF, SVG and PostScript; matplotlib might support additional formats.cairo.Surface -- the given Cairo surface will be used. This can refer to a PNG image, an arbitrary window, an SVG file, anything that Cairo can handle.None -- If you are using the Cairo backend, no plotting will be performed; igraph simply returns a CairoPlot_ object that you can use to manipulate the plot and save it to a file later. If you are using the matplotlib backend, a Figure objet and an Axes are created and the Axes is returned so you can manipulate it further. Similarly, if you are using the plotly backend, a Figure object is returned.",
            "bbox": "the bounding box of the plot. It must be a tuple with either two or four integers, or a BoundingBox object. If this is a tuple with two integers, it is interpreted as the width and height of the plot (in pixels for PNG images and on-screen plots, or in points for PDF, SVG and PostScript plots, where 72 pt = 1 inch = 2.54 cm). If this is a tuple with four integers, the first two denotes the X and Y coordinates of a corner and the latter two denoting the X and Y coordinates of the opposite corner. Ignored for Matplotlib plots.",
            "*args": "Undocumented",
            "opacity": "the  of the object being plotted. It can be used to overlap several plots of the same graph if you use the same layout for them -- for instance, you might plot a graph with  0.5 and then plot its spanning tree over it with  0.1. To achieve this, you'll need to modify the Plot object returned with Plot.add. Ignored for Matplotlib plots.",
            "palette": "the  primarily used on the plot if the added objects do not specify a private . Must be either an igraph.drawing.colors.Palette object or a string referring to a valid key of igraph.drawing.colors.s (see module igraph.drawing.colors) or None. In the latter case, the default  given by the configuration key plotting. is used.",
            "margin": "the top, right, bottom, left s as a 4-tuple. If it has less than 4 elements or is a single float, the elements will be re-used until the length is at least 4. The default  is 20 units on each side. Ignored for Matplotlib plots.",
            "inline": "whether to try and show the plot object  in the current IPython notebook. Passing None here or omitting this keyword argument will look up the preferred behaviour from the shell.ipython.inlining.Plot configuration key.  Note that this keyword argument has an effect only if igraph is run inside IPython and target is None.",
            "backend": "the plotting  to use; one of \"cairo\", \"matplotlib\" or \"plotly\". None means to try to decide the  from the plotting target and the default igraph configuration object."
        },
        "Section_id": "plot"
    },
    {
        "Section_id": "plot",
        "Return": [
            "an appropriate CairoPlot object for the Cairo backend, the Matplotlib Axes object for the Matplotlib backend, and the Figure object for the plotly backend."
        ]
    },
    {
        "Raises": {},
        "Section_id": "plot"
    },
    {
        "Section_id": "plot",
        "See Also": "Graph.__plot__"
    },
    {
        "Section_id": "mpl",
        "Description": "Undocumented"
    },
    {
        "Section_id": "plt",
        "Description": "Undocumented"
    },
    {
        "Section_id": "UpTriangleDrawer",
        "Description": "Static class which draws upright triangles"
    },
    {
        "Field List > Methods > draw_path": {
            "Description": "overrides igraph.drawing.shapes.ShapeDrawer.draw_path\nDraws an upright triangle on the Cairo context without stroking or filling it.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "ShapeDrawer.draw_path",
            "example": []
        },
        "Section_id": "UpTriangleDrawer"
    },
    {
        "Field List > Methods > intersection_point": {
            "Description": "overrides igraph.drawing.shapes.ShapeDrawer.intersection_point\nDetermines where the triangle centered at (center_x, center_y) intersects with a line drawn from (source_x, source_y) to (center_x, center_y).",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "ShapeDrawer.intersection_point",
            "example": []
        },
        "Section_id": "UpTriangleDrawer"
    },
    {
        "Field List > property": {},
        "Section_id": "UpTriangleDrawer"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "UpTriangleDrawer"
    },
    {
        "Section_id": "AbstractVertexDrawer",
        "Description": "Abstract vertex drawer object from which all concrete vertex drawer implementations are derived."
    },
    {
        "Field List > Methods > __init__": {
            "Description": "overridden in igraph.drawing.cairo.vertex.AbstractCairoVertexDrawer, igraph.drawing.matplotlib.vertex.MatplotlibVertexDrawer, igraph.drawing.plotly.vertex.PlotlyVerticesDrawer\nConstructs the vertex drawer and associates it to the given palette.",
            "Paramters": {
                "palette": "the  that can be used to map integer color indices to colors when drawing vertices",
                "layout": "the  of the vertices in the graph being drawn"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "AbstractVertexDrawer"
    },
    {
        "Field List > Methods > draw": {
            "Description": "overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nDraws the given vertex.",
            "Paramters": {
                "visual_vertex": "object specifying the visual properties of the vertex. Its structure is defined by the VisualVertexBuilder of the CairoGraphDrawer; see its source code.",
                "vertex": "the raw igraph  being drawn",
                "coords": "the X and Y coordinates of the vertex as specified by the layout algorithm, scaled into the bounding box."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "AbstractVertexDrawer"
    },
    {
        "Field List > property": {},
        "Section_id": "AbstractVertexDrawer"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "AbstractVertexDrawer"
    },
    {
        "Section_id": "CairoPlot",
        "Description": "Class representing an arbitrary plot that uses the Cairo plotting backend.\nObjects that you can plot include graphs, matrices, palettes, clusterings, covers, and dendrograms.\nIn Cairo, every plot has an associated surface object. The surface is an instance of cairo.Surface, a member of the pycairo library. The surface itself provides a unified API to various plotting targets like SVG files, X11 windows, PostScript files, PNG files and so on. igraph does not usually know on which surface it is plotting at each point in time, since pycairo takes care of the actual drawing. Everything that's supported by pycairo should be supported by this class as well.\nCurrent Cairo surfaces include: cairo.GlitzSurface -- OpenGL accelerated surface for the X11 Window System. cairo.ImageSurface -- memory buffer surface. Can be written to a PNG image file. cairo.PDFSurface -- PDF document surface. cairo.PSSurface -- PostScript document surface. cairo.SVGSurface -- SVG (Scalable Vector Graphics) document surface. cairo.Win32Surface -- Microsoft Windows screen rendering. cairo.XlibSurface -- X11 Window System screen rendering. \nIf you create a Plot object with a string given as the target surface, the string will be treated as a filename, and its extension will decide which surface class will be used. Please note that not all surfaces might be available, depending on your pycairo installation.\nA Plot has an assigned default palette (see igraph.drawing.colors.Palette) which is used for plotting objects.\nA Plot object also has a list of objects to be plotted with their respective bounding boxes, palettes and opacities. Palettes assigned to an object override the default palette of the plot. Objects can be added by the Plot.add method and removed by the Plot.remove method."
    },
    {
        "Field List > Methods > __init__": {
            "Description": "Creates a new plot.",
            "Paramters": {
                "target": "the  surface to write to. It can be one of the following types:None -- a Cairo surface will be created and the object will be plotted there.cairo.Surface -- the given Cairo surface will be used.string -- a file with the given name will be created and an appropriate Cairo surface will be attached to it.",
                "bbox": "the bounding box of the surface. It is interpreted differently with different surfaces: PDF and PS surfaces will treat it as points (1 point = 1/72 inch). Image surfaces will treat it as pixels. SVG surfaces will treat it as an abstract unit, but it will mostly be interpreted as pixels when viewing the SVG file in Firefox.",
                "palette": "the  primarily used on the plot if the added objects do not specify a private . Must be either an igraph.drawing.colors.Palette object or a string referring to a valid key of igraph.drawing.colors.s (see module igraph.drawing.colors) or None. In the latter case, the default  given by the configuration key plotting. is used.",
                "background": "the  color. If None, the  will be transparent. You can use any color specification here that is understood by igraph.drawing.colors.color_name_to_rgba."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "CairoPlot"
    },
    {
        "Field List > Methods > add": {
            "Description": "Adds an object to the plot.\nArguments not specified here are stored and passed to the object's plotting function when necessary. Since you are most likely interested in the arguments acceptable by graphs, see Graph.__plot__ for more details.",
            "Paramters": {
                "obj": "the ect to be added",
                "bbox": "the bounding box of the object. If None, the object will fill the entire area of the plot.",
                "palette": "the color  used for drawing the object. If the object tries to get a color assigned to a positive integer, it will use this . If None, defaults to the global  of the plot.",
                "opacity": "the  of the object being plotted, in the range 0.0-1.0",
                "*args": "Undocumented",
                "**kwds": "Undocumented"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "Graph.__plot__",
            "example": []
        },
        "Section_id": "CairoPlot"
    },
    {
        "Field List > Methods > background": {
            "Description": "Sets the background color of the plot. None means a transparent background. You can use any color specification here that is understood by the get method of the current palette or by igraph.drawing.colors.color_name_to_rgb.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "CairoPlot"
    },
    {
        "Field List > Methods > mark_dirty": {
            "Description": "Marks the plot as dirty (should be redrawn)",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "CairoPlot"
    },
    {
        "Field List > Methods > redraw": {
            "Description": "Redraws the plot",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "CairoPlot"
    },
    {
        "Field List > Methods > remove": {
            "Description": "Removes an object from the plot.\nIf the object has been added multiple times and no bounding box was specified, it removes the instance which occurs idxth in the list of identical instances of the object.",
            "Paramters": {
                "obj": "the ect to be removed",
                "bbox": "optional bounding box specification for the object. If given, only objects with exactly this bounding box will be considered.",
                "idx": "if multiple objects match the specification given by obj and bbox, only the th occurrence will be removed."
            },
            "Return": [
                "True if the object has been removed successfully, False if the object was not on the plot at all or idx was larger than the count of occurrences"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "CairoPlot"
    },
    {
        "Field List > Methods > save": {
            "Description": "Saves the plot.",
            "Paramters": {
                "fname": "the filename to save to. It is ignored if the surface of the plot is not an ImageSurface."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "CairoPlot"
    },
    {
        "Field List > property": {
            "background": "Returns the background color of the plot. None means a transparent background.\n",
            "bounding_box": "Returns the bounding box of the Cairo surface as a BoundingBox object\n",
            "height": "Returns the height of the Cairo surface on which the plot is drawn\n",
            "surface": "Returns the Cairo surface on which the plot is drawn\n",
            "width": "Returns the width of the Cairo surface on which the plot is drawn\n"
        },
        "Section_id": "CairoPlot"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "CairoPlot"
    },
    {
        "Section_id": "GraphSummary",
        "Description": "Summary representation of a graph.\n"
    },
    {
        "Field List > Methods > __init__": {
            "Description": "Constructs a summary representation of a graph.",
            "Paramters": {
                "graph": "Undocumented",
                "verbosity": "the  of the summary. If zero, only the header line will be returned. If one, the header line and the list of edges will both be returned.",
                "width": "the maximal  of each line in the summary. None means that no limit will be enforced.",
                "edge_list_format": "format of the edge list in the summary. Supported formats are: compressed, adjlist, edgelist, auto, which selects automatically from the other three based on some simple criteria.",
                "max_rows": "the maximal number of rows to print in a single table (e.g., vertex attribute table or edge attribute table)",
                "print_graph_attributes": "whether to print graph attributes if there are any.",
                "print_vertex_attributes": "whether to print vertex attributes if there are any.",
                "print_edge_attributes": "whether to print edge attributes if there are any.",
                "full": "False has no effect; True turns on the attribute printing for graph, vertex and edge attributes with verbosity 1."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphSummary"
    },
    {
        "Field List > Methods > __str__": {
            "Description": "Returns the summary representation as a string.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GraphSummary"
    },
    {
        "Field List > property": {},
        "Section_id": "GraphSummary"
    },
    {
        "Rubric": {
            "Example": [
                "The summary representation includes a header line and the list of edges. The header line consists of IGRAPH, followed by a four-character long code, the number of vertices, the number of edges, two dashes (--) and the name of the graph (i.e. the contents of the name attribute, if any). For instance, a header line may look like this:\n    IGRAPH U--- 4 5 --\n"
            ]
        },
        "Section_id": "GraphSummary"
    },
    {
        "Section_id": "EdgeSeq",
        "Description": "Low-level representation of an edge sequence.\nDon't use it directly, use igraph.EdgeSeq instead."
    },
    {
        "Field List > Methods > attribute_names": {
            "Description": "Returns the attribute name list of the graph's edges",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "EdgeSeq"
    },
    {
        "Field List > Methods > find": {
            "Description": "overridden in igraph.EdgeSeq\nFor internal use only.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "EdgeSeq"
    },
    {
        "Field List > Methods > get_attribute_values": {
            "Description": "Returns the value of a given edge attribute for all edges.",
            "Paramters": {
                "attrname": "the name of the attribute"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "EdgeSeq"
    },
    {
        "Field List > Methods > is_all": {
            "Description": "Returns whether the edge sequence contains all the edges exactly once, in the order of their edge IDs.\nThis is used for optimizations in some of the edge selector routines.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "EdgeSeq"
    },
    {
        "Field List > Methods > select": {
            "Description": "overridden in igraph.EdgeSeq\nFor internal use only.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "EdgeSeq"
    },
    {
        "Field List > Methods > set_attribute_values": {
            "Description": "Sets the value of a given edge attribute for all vertices",
            "Paramters": {
                "attrname": "the name of the attribute",
                "values": "the new attribute  in a list"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "EdgeSeq"
    },
    {
        "Field List > property": {},
        "Section_id": "EdgeSeq"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "EdgeSeq"
    },
    {
        "Section_id": "Configuration",
        "Description": "Class representing igraph configuration details.\nNote that there is one primary instance of this class, which is used by igraph itself to retrieve configuration parameters when needed. You can access this instance with the instance() method. You may construct other instances by invoking the constructor directly, but these instances will not affect igraph's behaviour. If you are interested in configuring igraph, use igraph.config to get hold of the singleton instance and then modify it. General ideas The configuration of igraph is stored in the form of name-value pairs. This object provides an interface to the configuration data using the syntax known from dict:  >>> c = Configuration() >>> c[\"general.verbose\"] = True >>> print(c[\"general.verbose\"]) True Configuration keys are organized into sections, and the name to be used for a given key is always in the form section.keyname, like general.verbose in the example above. In that case, general is the name of the configuration section, and verbose is the name of the key. If the name of the section is omitted, it defaults to general, so general.verbose can be referred to as verbose:  >>> c = Configuration() >>> c[\"verbose\"] = True >>> print(c[\"general.verbose\"]) True User-level configuration is stored in ~/.igraphrc per default on Linux and Mac OS X systems, or in C:\\Documents and Settings\\username\\.igraphrc on Windows systems. However, this configuration is read only when igraph is launched through its shell interface defined in igraph.app.shell. This behaviour might change before version 1.0.  Known configuration keys The known configuration keys are presented below, sorted by section. When referring to them in program code, don't forget to add the section name, expect in the case of section general.  General settings These settings are all stored in section general.  shells: the list of preferred Python shells to be used with the command-line igraph script. The shells in the list are tried one by one until any of them is found on the system. igraph functions are then imported into the main namespace of the shell and the shell is launched. Known shells and their respective class names to be used can be found in igraph.app.shell. Example: IPythonShell, ClassicPythonShell. This is the default, by the way. verbose: whether igraph should talk more than really necessary. For instance, if set to True, some functions display progress bars.    Plotting settings These settings specify the default values used by plotting functions. They are all stored in section plotting.  backend: either \"cairo\" if you want to use Cairo for plotting or \"matplotlib\" if you want to use the Matplotlib plotting backend. layout: default graph layout algorithm to be used. mark_groups: whether to mark the clusters by polygons when plotting a clustering object. palette: default palette to be used for converting integer numbers to colors. See colors.Palette for more information. Valid palette names are stored in colors.palettes. wrap_labels: whether to try to wrap the labels of the vertices automatically if they don't fit within the vertex. Default: False.    Shell settings These settings specify options for external environments in which igraph is embedded (e.g., IPython and its Qt console). These settings are stored in section shell.  ipython.inlining.Plot: whether to show instances of the Plot class inline in IPython's console if the console supports it. Default: True   "
    },
    {
        "Field List > Methods > instance": {
            "Description": "Returns the single instance of the configuration object.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Configuration"
    },
    {
        "Field List > Methods > __contains__": {
            "Description": "Checks whether the given configuration item is set.",
            "Paramters": {
                "item": ":strthe configuration key to check."
            },
            "Return": [
                "boolTrue if the key has an associated value, False otherwise."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Configuration"
    },
    {
        "Field List > Methods > __delitem__": {
            "Description": "Deletes the given item from the configuration.\nIf the item has a default value, the default value is written back instead of the current value. Without a default value, the item is really deleted.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Configuration"
    },
    {
        "Field List > Methods > __getitem__": {
            "Description": "Returns the given configuration item.",
            "Paramters": {
                "item": ":strthe configuration key to retrieve."
            },
            "Return": [
                "the configuration value"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Configuration"
    },
    {
        "Field List > Methods > __init__": {
            "Description": "Creates a new configuration instance.",
            "Paramters": {
                "filename": "file or file-like object to be read. Can be omitted."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Configuration"
    },
    {
        "Field List > Methods > __setitem__": {
            "Description": "Sets the given configuration item.",
            "Paramters": {
                "item": ":strthe configuration key to set",
                "value": "the new  of the configuration key"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Configuration"
    },
    {
        "Field List > Methods > has_key": {
            "Description": "Checks if the configuration has a given key.",
            "Paramters": {
                "item": ":strthe key being sought"
            },
            "Return": [
                "boolUndocumented"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Configuration"
    },
    {
        "Field List > Methods > load": {
            "Description": "Loads the configuration from the given file.",
            "Paramters": {
                "stream": "name of a file or a file object. The configuration will be loaded from here. Can be omitted, in this case, the user-level configuration is loaded."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Configuration"
    },
    {
        "Field List > Methods > save": {
            "Description": "Saves the configuration.",
            "Paramters": {
                "stream": ":Optional[Union[str, IO[str]]]name of a file or a file-like object. The configuration will be saved there. Can be omitted, in this case, the user-level configuration file will be overwritten."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Configuration"
    },
    {
        "Field List > property": {
            "filename": "Returns the filename associated to the object.\nIt is usually the name of the configuration file that was used when creating the object. Configuration.load always overwrites it with the filename given to it. If None, the configuration was either created from scratch or it was updated from a stream without name information.\n\n"
        },
        "Section_id": "Configuration"
    },
    {
        "Rubric": {
            "Example": [
                "The configuration of igraph is stored in the form of name-value pairs. This object provides an interface to the configuration data using the syntax known from dict:\n>>> c = Configuration()\n>>> c[\"general.verbose\"] = True\n>>> print(c[\"general.verbose\"])\nTrue\n",
                "Configuration keys are organized into sections, and the name to be used for a given key is always in the form section.keyname, like general.verbose in the example above. In that case, general is the name of the configuration section, and verbose is the name of the key. If the name of the section is omitted, it defaults to general, so general.verbose can be referred to as verbose:\n>>> c = Configuration()\n>>> c[\"general.verbose\"] = True\n>>> print(c[\"general.verbose\"])\nTrue\n"
            ]
        },
        "Section_id": "Configuration"
    },
    {
        "Section_id": "VertexSeq",
        "Description": "Class representing a sequence of vertices in the graph.\nThis class is most easily accessed by the vs field of the Graph object, which returns an ordered sequence of all vertices in the graph. The vertex sequence can be refined by invoking the VertexSeq.select() method. VertexSeq.select() can also be accessed by simply calling the VertexSeq object.\n"
    },
    {
        "Field List > Methods > __call__": {
            "Description": "Shorthand notation to select()\nThis method simply passes all its arguments to VertexSeq.select().",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "VertexSeq"
    },
    {
        "Field List > Methods > attributes": {
            "Description": "Returns the list of all the vertex attributes in the graph associated to this vertex sequence.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "VertexSeq"
    },
    {
        "Field List > Methods > find": {
            "Description": "overrides igraph._igraph.VertexSeq.find\nReturns the first vertex of the vertex sequence that matches some criteria.\nThe selection criteria are equal to the ones allowed by VertexSeq.select. See VertexSeq.select for more details.\nFor instance, to find the first vertex with name foo in graph g:",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": [
                "For instance, to find the first vertex with name foo in graph g:\n>>> g.vs.find(name=\"foo\")            #doctest:+SKIP",
                "To find an arbitrary isolated vertex:\n>>> g.vs.find(name=\"foo\")            #doctest:+SKIP"
            ]
        },
        "Section_id": "VertexSeq"
    },
    {
        "Field List > Methods > select": {
            "Description": "overrides igraph._igraph.VertexSeq.select\nSelects a subset of the vertex sequence based on some criteria\nThe selection criteria can be specified by the positional and the keyword arguments. Positional arguments are always processed before keyword arguments.If the first positional argument is None, an empty sequence is returned.If the first positional argument is a callable object, the object will be called for every vertex in the sequence. If it returns True, the vertex will be included, otherwise it will be excluded.If the first positional argument is an iterable, it must return integers and they will be considered as indices of the current vertex set (NOT the whole vertex set of the graph -- the difference matters when one filters a vertex set that has already been filtered by a previous invocation of VertexSeq.select(). In this case, the indices do not refer directly to the vertices of the graph but to the elements of the filtered vertex sequence.If the first positional argument is an integer, all remaining arguments are expected to be integers. They are considered as indices of the current vertex set again.\nKeyword arguments can be used to filter the vertices based on their attributes. The name of the keyword specifies the name of the attribute and the filtering operator, they should be concatenated by an underscore (_) character. Attribute names can also contain underscores, but operator names don't, so the operator is always the largest trailing substring of the keyword name that does not contain an underscore. Possible operators are:eq: equal tone: not equal tolt: less thangt: greater thanle: less than or equal toge: greater than or equal toin: checks if the value of an attribute is in a given listnotin: checks if the value of an attribute is not in a given list\nFor instance, if you want to filter vertices with a numeric age property larger than 200, you have to write:",
            "Paramters": {},
            "Return": [
                "the new, filtered vertex sequence"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": [
                "For instance, if you want to filter vertices with a numeric age property larger than 200, you have to write:\n>>> g.vs.select(age_gt=200)                   #doctest: +SKIP",
                "Similarly, to filter vertices whose type is in a list of predefined types:\n>>> g.vs.select(age_gt=200)                   #doctest: +SKIP",
                "If the operator is omitted, it defaults to eq. For instance, the following selector selects vertices whose cluster property equals to 2:\n>>> g.vs.select(age_gt=200)                   #doctest: +SKIP",
                "Attribute names inferred from keyword arguments are treated specially if they start with an underscore (_). These are not real attributes but refer to specific properties of the vertices, e.g., its degree. The rule is as follows: if an attribute name starts with an underscore, the rest of the name is interpreted as a method of the Graph object. This method is called with the vertex sequence as its first argument (all others left at default values) and vertices are filtered according to the value returned by the method. For instance, if you want to exclude isolated vertices:\n>>> g.vs.select(age_gt=200)                   #doctest: +SKIP",
                "For properties that take a long time to be computed (e.g., betweenness centrality for large graphs), it is advised to calculate the values in advance and store it in a graph attribute. The same applies when you are selecting based on the same property more than once in the same select() call to avoid calculating it twice unnecessarily. For instance, the following would calculate betweenness centralities twice:\n>>> g.vs.select(age_gt=200)                   #doctest: +SKIP",
                "It is advised to use this instead:\n>>> g.vs.select(age_gt=200)                   #doctest: +SKIP"
            ]
        },
        "Section_id": "VertexSeq"
    },
    {
        "Field List > Methods > attribute_names": {
            "Description": "Inherited from VertexSeq:Returns the attribute name list of the graph's vertices"
        },
        "Section_id": "VertexSeq"
    },
    {
        "Field List > Methods > get_attribute_values": {
            "Description": "Inherited from VertexSeq:Returns the value of a given vertex attribute for all vertices in a list."
        },
        "Section_id": "VertexSeq"
    },
    {
        "Field List > Methods > set_attribute_values": {
            "Description": "Inherited from VertexSeq:Sets the value of a given vertex attribute for all vertices"
        },
        "Section_id": "VertexSeq"
    },
    {
        "Field List > property": {},
        "Section_id": "VertexSeq"
    },
    {
        "Rubric": {
            "Example": [
                "An alternative way to create a vertex sequence referring to a given graph is to use the constructor directly:\n>>> g = Graph.Full(3)\n>>> vs = VertexSeq(g)\n>>> restricted_vs = VertexSeq(g, [0, 1])",
                "The individual vertices can be accessed by indexing the vertex sequence object. It can be used as an iterable as well, or even in a list comprehension:\n>>> g = Graph.Full(3)\n>>> vs = VertexSeq(g)\n>>> restricted_vs = VertexSeq(g, [0, 1])",
                "The vertex set can also be used as a dictionary where the keys are the attribute names. The values corresponding to the keys are the values of the given attribute for every vertex selected by the sequence.\n>>> g = Graph.Full(3)\n>>> vs = VertexSeq(g)\n>>> restricted_vs = VertexSeq(g, [0, 1])",
                "If you specify a sequence that is shorter than the number of vertices in the VertexSeq, the sequence is reused:\n>>> g = Graph.Full(3)\n>>> vs = VertexSeq(g)\n>>> restricted_vs = VertexSeq(g, [0, 1])",
                "You can even pass a single string or integer, it will be considered as a sequence of length 1:\n>>> g = Graph.Full(3)\n>>> vs = VertexSeq(g)\n>>> restricted_vs = VertexSeq(g, [0, 1])",
                "Some methods of the vertex sequences are simply proxy methods to the corresponding methods in the Graph object. One such example is VertexSeq.degree():\n>>> g = Graph.Full(3)\n>>> vs = VertexSeq(g)\n>>> restricted_vs = VertexSeq(g, [0, 1])"
            ]
        },
        "Section_id": "VertexSeq"
    },
    {
        "Section_id": "AbstractDrawer",
        "Description": "Abstract class that serves as a base class for anything that draws an igraph object."
    },
    {
        "Field List > Methods > draw": {
            "Description": "overridden in igraph.drawing.baseclasses.AbstractGraphDrawer, igraph.drawing.baseclasses.AbstractVertexDrawer, igraph.drawing.cairo.coord.CoordinateSystem, igraph.drawing.cairo.dendrogram.CairoDendrogramDrawer, igraph.drawing.cairo.graph.CairoGraphDrawer, igraph.drawing.cairo.histogram.CairoHistogramDrawer, igraph.drawing.cairo.matrix.CairoMatrixDrawer, igraph.drawing.cairo.palette.CairoPaletteDrawer, igraph.drawing.cairo.polygon.CairoPolygonDrawer, igraph.drawing.cairo.text.CairoTextDrawer, igraph.drawing.cairo.vertex.CairoVertexDrawer, igraph.drawing.graph.CytoscapeGraphDrawer, igraph.drawing.matplotlib.dendrogram.MatplotlibDendrogramDrawer, igraph.drawing.matplotlib.histogram.MatplotlibHistogramDrawer, igraph.drawing.matplotlib.matrix.MatplotlibMatrixDrawer, igraph.drawing.matplotlib.palette.MatplotlibPaletteDrawer\nAbstract method, must be implemented in derived classes.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "AbstractDrawer"
    },
    {
        "Field List > property": {},
        "Section_id": "AbstractDrawer"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "AbstractDrawer"
    },
    {
        "Section_id": "Edge",
        "Description": "Class representing a single edge in a graph.\nThe edge is referenced by its index, so if the underlying graph changes, the semantics of the edge object might change as well (if the edge indices are altered in the original graph).\n"
    },
    {
        "Field List > Methods > attribute_names": {
            "Description": "Returns the list of edge attribute names",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Edge"
    },
    {
        "Field List > Methods > attributes": {
            "Description": "Returns a dict of attribute names and values for the edge",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Edge"
    },
    {
        "Field List > Methods > count_multiple": {
            "Description": "Proxy method to Graph.count_multiple()\nThis method calls the count_multiple method of the Graph class with this edge as the first argument, and returns the result.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "Graph.count_multiple() for details.",
            "example": []
        },
        "Section_id": "Edge"
    },
    {
        "Field List > Methods > delete": {
            "Description": "Proxy method to Graph.delete_edges()\nThis method calls the delete_edges method of the Graph class with this edge as the first argument, and returns the result.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "Graph.delete_edges() for details.",
            "example": []
        },
        "Section_id": "Edge"
    },
    {
        "Field List > Methods > is_loop": {
            "Description": "Proxy method to Graph.is_loop()\nThis method calls the is_loop method of the Graph class with this edge as the first argument, and returns the result.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "Graph.is_loop() for details.",
            "example": []
        },
        "Section_id": "Edge"
    },
    {
        "Field List > Methods > is_multiple": {
            "Description": "Proxy method to Graph.is_multiple()\nThis method calls the is_multiple method of the Graph class with this edge as the first argument, and returns the result.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "Graph.is_multiple() for details.",
            "example": []
        },
        "Section_id": "Edge"
    },
    {
        "Field List > Methods > is_mutual": {
            "Description": "Proxy method to Graph.is_mutual()\nThis method calls the is_mutual method of the Graph class with this edge as the first argument, and returns the result.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "Graph.is_mutual() for details.",
            "example": []
        },
        "Section_id": "Edge"
    },
    {
        "Field List > Methods > update_attributes": {
            "Description": "Updates the attributes of the edge from dict/iterable E and F.\nIf E has a keys() method, it does: for k in E: self[k] = E[k]. If E lacks a keys() method, it does: for (k, v) in E: self[k] = v. In either case, this is followed by: for k in F: self[k] = F[k].\nThis method thus behaves similarly to the update() method of Python dictionaries.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Edge"
    },
    {
        "Field List > property": {},
        "Section_id": "Edge"
    },
    {
        "Rubric": {
            "Example": [
                "The attributes of the edge can be accessed by using the edge as a hash:\n>>> e[\"weight\"] = 2                  #doctest: +SKIP\n>>> print(e[\"weight\"])               #doctest: +SKIP\n2\n"
            ]
        },
        "Section_id": "Edge"
    },
    {
        "Section_id": "autocurve",
        "Description": "Calculates curvature values for each of the edges in the graph to make sure that multiple edges are shown properly on a graph plot.\nThis function checks the multiplicity of each edge in the graph and assigns curvature values (numbers between -1 and 1, corresponding to CCW (-1), straight (0) and CW (1) curved edges) to them. The assigned values are either stored in an edge attribute or returned as a list, depending on the value of the attribute argument."
    },
    {
        "Paramters": {
            "graph": "the  on which the calculation will be run",
            "attribute": "the name of the edge  to save the curvature values to. The default value is curved, which is the name of the edge  the default graph plotter checks to decide whether an edge should be curved on the plot or not. If  is None, the result will not be stored.",
            "default": "the  curvature for single edges. Zero means that single edges will be straight. If you want single edges to be curved as well, try passing 0.5 or -0.5 here."
        },
        "Section_id": "autocurve"
    },
    {
        "Section_id": "autocurve",
        "Return": [
            "the list of curvature values if attribute is None, otherwise None."
        ]
    },
    {
        "Raises": {},
        "Section_id": "autocurve"
    },
    {
        "Section_id": "autocurve",
        "See Also": ""
    },
    {
        "Section_id": "calculate_corner_radii",
        "Description": "Given a list of points and a desired corner radius, returns a list containing proposed corner radii for each of the points such that it is ensured that the corner radius at a point is never larger than half of the minimum distance between the point and its neighbors."
    },
    {
        "Paramters": {},
        "Section_id": "calculate_corner_radii"
    },
    {
        "Raises": {},
        "Section_id": "calculate_corner_radii"
    },
    {
        "Section_id": "calculate_corner_radii",
        "See Also": ""
    },
    {
        "Section_id": "euclidean_distance",
        "Description": "Computes the Euclidean distance between points (x1,y1) and (x2,y2)."
    },
    {
        "Paramters": {},
        "Section_id": "euclidean_distance"
    },
    {
        "Raises": {},
        "Section_id": "euclidean_distance"
    },
    {
        "Section_id": "euclidean_distance",
        "See Also": ""
    },
    {
        "Section_id": "evaluate_cubic_bezier",
        "Description": "Evaluates the Bezier curve from point (x0,y0) to (x3,y3) via control points (x1,y1) and (x2,y2) at t. t is typically in the range [0; 1] such that 0 returns (x0, y0) and 1 returns (x3, y3)."
    },
    {
        "Paramters": {},
        "Section_id": "evaluate_cubic_bezier"
    },
    {
        "Raises": {},
        "Section_id": "evaluate_cubic_bezier"
    },
    {
        "Section_id": "evaluate_cubic_bezier",
        "See Also": ""
    },
    {
        "Section_id": "get_bezier_control_points_for_curved_edge",
        "Description": "Helper function that calculates the Bezier control points for a curved edge that goes from (x1, y1) to (x2, y2)."
    },
    {
        "Paramters": {},
        "Section_id": "get_bezier_control_points_for_curved_edge"
    },
    {
        "Raises": {},
        "Section_id": "get_bezier_control_points_for_curved_edge"
    },
    {
        "Section_id": "get_bezier_control_points_for_curved_edge",
        "See Also": ""
    },
    {
        "Section_id": "intersect_bezier_curve_and_circle",
        "Description": "Binary search solver for finding the intersection of a Bezier curve and a circle centered at the curve's end point.\nReturns the x, y coordinates of the intersection point."
    },
    {
        "Paramters": {},
        "Section_id": "intersect_bezier_curve_and_circle"
    },
    {
        "Raises": {},
        "Section_id": "intersect_bezier_curve_and_circle"
    },
    {
        "Section_id": "intersect_bezier_curve_and_circle",
        "See Also": ""
    },
    {
        "Section_id": "str_to_orientation",
        "Description": "Tries to interpret a string as an orientation value.\nThe following basic values are understood: ``left-right``, ``bottom-top``, ``right-left``, ``top-bottom``. Possible aliases are:``horizontal``, ``horiz``, ``h`` and ``lr`` for ``left-right````vertical``, ``vert``, ``v`` and ``tb`` for top-bottom.``lr`` for ``left-right``.``rl`` for ``right-left``.\n``reversed_horizontal`` reverses the meaning of ``horizontal``, ``horiz`` and ``h`` to ``rl`` (instead of ``lr``); similarly, ``reversed_vertical`` reverses the meaning of ``vertical``, ``vert`` and ``v`` to ``bt`` (instead of ``tb``).\nReturns one of ``lr``, ``rl``, ``tb`` or ``bt``, or throws ``ValueError`` if the string cannot be interpreted as an orientation."
    },
    {
        "Paramters": {},
        "Section_id": "str_to_orientation"
    },
    {
        "Raises": {},
        "Section_id": "str_to_orientation"
    },
    {
        "Section_id": "str_to_orientation",
        "See Also": ""
    },
    {
        "Section_id": "AttributeCollectorMeta",
        "Description": "Metaclass for attribute collector classes\nClasses that use this metaclass are intended to collect vertex/edge attributes from various sources (a Python dict, a vertex/edge sequence, default values from the igraph configuration and such) in a given order of precedence. See the module documentation for more details. This metaclass enables the user to use a simple declarative syntax to specify which attributes he is interested in. For each vertex/edge attribute, a corresponding class attribute must be defined with a value that describes the default value of that attribute if no other data source provides us with any suitable value. The default value can also be a tuple; in that case, the first element of the tuple is the actual default value, the second element is a converter function that will convert the attribute values to a format expected by the caller who uses the class being defined.\nThere is a special class attribute called _kwds_prefix; this is not used as an attribute declaration. It can contain a string which will be used to derive alternative names for the attributes when the attribute is accessed in a Python dict. This is useful in many situations; for instance, the default graph drawer would want to access the vertex colors using the color vertex attribute, but when it looks at the keyword arguments passed to the original call of igraph.Graph.__plot__, the vertex_color keyword argument should be looked up because we also have colors for the edges. _kwds_prefix will be prepended to the attribute names when they are looked up in a dict of keyword arguments.\nIf you require a more fine-tuned behaviour, you can assign an AttributeSpecification instance to a class attribute directly.See AlsoAttributeCollectorBase"
    },
    {
        "Field List > Methods > record_generator": {
            "Description": "Generates a simple class that has the given slots and nothing else",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "AttributeCollectorMeta"
    },
    {
        "Field List > Methods > __new__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "AttributeCollectorMeta"
    },
    {
        "Field List > property": {},
        "Section_id": "AttributeCollectorMeta"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "AttributeCollectorMeta"
    },
    {
        "Section_id": "operator_method_registry",
        "Description": "Undocumented"
    },
    {
        "Section_id": "multidict",
        "Description": "A dictionary-like object that is customized to deal with multiple values for the same key.\nEach value in this dictionary will be a list. Methods which emulate the methods of a standard Python dict object will return or manipulate the first items of the lists only. Special methods are provided to deal with keys having multiple values."
    },
    {
        "Field List > Methods > __contains__": {
            "Description": "Returns whether there are any items associated to the givenkey.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "multidict"
    },
    {
        "Field List > Methods > __delitem__": {
            "Description": "Removes all the items associated to the given key.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "multidict"
    },
    {
        "Field List > Methods > __getitem__": {
            "Description": "Returns an arbitrary item associated to the given key. Raises KeyErrorif no such key exists.\nExample:>>> d = multidict([(\"spam\", \"eggs\"), (\"spam\", \"bacon\")])>>> d[\"spam\"]'eggs'",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": [
                ">>> d = multidict([(\"spam\", \"eggs\"), (\"spam\", \"bacon\")])\n>>> d[\"spam\"]\n'eggs'\n"
            ]
        },
        "Section_id": "multidict"
    },
    {
        "Field List > Methods > __init__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "multidict"
    },
    {
        "Field List > Methods > __iter__": {
            "Description": "Iterates over the keys of the multidict.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "multidict"
    },
    {
        "Field List > Methods > __len__": {
            "Description": "Returns the number of distinct keys in this multidict.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "multidict"
    },
    {
        "Field List > Methods > __setitem__": {
            "Description": "Sets the item associated to the given key. Any values associated to thekey will be erased and replaced by value.\nExample:>>> d = multidict([(\"spam\", \"eggs\"), (\"spam\", \"bacon\")])>>> d[\"spam\"] = \"ham\">>> d[\"spam\"]'ham'",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": [
                ">>> d = multidict([(\"spam\", \"eggs\"), (\"spam\", \"bacon\")])\n>>> d[\"spam\"] = \"ham\"\n>>> d[\"spam\"]\n'ham'\n"
            ]
        },
        "Section_id": "multidict"
    },
    {
        "Field List > Methods > add": {
            "Description": "Adds value to the list of items associated to key.\nExample:>>> d = multidict()>>> d.add(\"spam\", \"ham\")>>> d[\"spam\"]'ham'>>> d.add(\"spam\", \"eggs\")>>> d.getlist(\"spam\")['ham', 'eggs']",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": [
                ">>> d = multidict()\n>>> d.add(\"spam\", \"ham\")\n>>> d[\"spam\"]\n'ham'\n>>> d.add(\"spam\", \"eggs\")\n>>> d.getlist(\"spam\")\n['ham', 'eggs']\n"
            ]
        },
        "Section_id": "multidict"
    },
    {
        "Field List > Methods > clear": {
            "Description": "Removes all the items from the multidict.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "multidict"
    },
    {
        "Field List > Methods > get": {
            "Description": "Returns an arbitrary item associated to the given key. If keydoes not exist or has zero associated items, default will bereturned.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "multidict"
    },
    {
        "Field List > Methods > getlist": {
            "Description": "Returns the list of values for the given key. An empty list willbe returned if there is no such key.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "multidict"
    },
    {
        "Field List > Methods > iterlists": {
            "Description": "Iterates over (key, values) pairs where values is the listof values associated with key.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "multidict"
    },
    {
        "Field List > Methods > lists": {
            "Description": "Returns a list of (key, values) pairs where values is the listof values associated with key.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "multidict"
    },
    {
        "Field List > Methods > update": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "multidict"
    },
    {
        "Field List > property": {},
        "Section_id": "multidict"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "multidict"
    },
    {
        "Section_id": "IPythonShell",
        "Description": "IPython embedded shell interface.\nThis class allows igraph to be embedded in IPython's interactive shell."
    },
    {
        "Field List > Methods > __call__": {
            "Description": "overrides igraph.app.shell.Shell.__call__\nStarts the embedded shell.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "IPythonShell"
    },
    {
        "Field List > Methods > __init__": {
            "Description": "overrides igraph.app.shell.ConsoleProgressBarMixin.__init__\nConstructor.\nImports IPython's embedded shell with separator lines removed.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "IPythonShell"
    },
    {
        "Field List > Methods > get_progress_handler": {
            "Description": "Inherited from Shell:Returns the progress handler (if exists) or None (if not)."
        },
        "Section_id": "IPythonShell"
    },
    {
        "Field List > Methods > get_status_handler": {
            "Description": "Inherited from Shell:Returns the status handler (if exists) or None (if not)."
        },
        "Section_id": "IPythonShell"
    },
    {
        "Field List > Methods > supports_progress_bar": {
            "Description": "Inherited from Shell:Checks whether the shell supports progress bars."
        },
        "Section_id": "IPythonShell"
    },
    {
        "Field List > Methods > supports_status_messages": {
            "Description": "Inherited from Shell:Checks whether the shell supports status messages."
        },
        "Section_id": "IPythonShell"
    },
    {
        "Field List > property": {},
        "Section_id": "IPythonShell"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "IPythonShell"
    },
    {
        "Section_id": "PlotlyGraphDrawer",
        "Description": "Graph drawer that uses a pyplot.Axes as context"
    },
    {
        "Field List > Methods > __init__": {
            "Description": "Constructs the graph drawer and associates it with the plotly Figure",
            "Paramters": {
                "fig": "the plotly.graph_objects.Figure to draw into.",
                "vertex_drawer_factory": "Undocumented",
                "edge_drawer_factory": "Undocumented"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "PlotlyGraphDrawer"
    },
    {
        "Field List > Methods > draw": {
            "Description": "overrides igraph.drawing.baseclasses.AbstractGraphDrawer.draw\nAbstract method, must be implemented in derived classes.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "PlotlyGraphDrawer"
    },
    {
        "Field List > property": {},
        "Section_id": "PlotlyGraphDrawer"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "PlotlyGraphDrawer"
    },
    {
        "Section_id": "CoordinateSystem",
        "Description": "Class implementing a coordinate system object.\nCoordinate system objects are used when drawing plots which 2D or 3D coordinate system axes. This is an abstract class which must be extended in order to use it. In general, you'll only need the documentation of this class if you intend to implement an own coordinate system not present in igraph yet."
    },
    {
        "Field List > Methods > draw": {
            "Description": "overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nDraws the coordinate system.\nThis method must be overridden in derived classes.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "CoordinateSystem"
    },
    {
        "Field List > Methods > local_to_context": {
            "Description": "overridden in igraph.drawing.cairo.coord.DescartesCoordinateSystem\nConverts local coordinates to the context coordinate system (given by the bounding box).\nThis method must be overridden in derived classes.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "CoordinateSystem"
    },
    {
        "Field List > Methods > __init__": {
            "Description": "Inherited from AbstractCairoDrawer:Constructs the drawer and associates it to the given Cairo context and the given BoundingBox."
        },
        "Section_id": "CoordinateSystem"
    },
    {
        "Field List > Methods > bbox.setter": {
            "Description": "Inherited from AbstractCairoDrawer:Sets the bounding box of the drawing area where this drawer will draw."
        },
        "Section_id": "CoordinateSystem"
    },
    {
        "Field List > property": {
            "bbox": "Inherited from AbstractCairoDrawer:The bounding box of the drawing area where this drawer will draw."
        },
        "Section_id": "CoordinateSystem"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "CoordinateSystem"
    },
    {
        "Section_id": "disjoint_union",
        "Description": "Graph disjoint union.\nThe disjoint union of two or more graphs is created.\nThis function keeps the attributes of all graphs. All graph, vertex andedge attributes are copied to the result. If an attribute is present inmultiple graphs and would result a name clash, then this attribute isrenamed by adding suffixes: _1, _2, etc.\nAn error is generated if some input graphs are directed and others areundirected."
    },
    {
        "Paramters": {
            "graphs": "list of . A lazy sequence is not acceptable."
        },
        "Section_id": "disjoint_union"
    },
    {
        "Section_id": "disjoint_union",
        "Return": [
            "the disjoint union graph"
        ]
    },
    {
        "Raises": {},
        "Section_id": "disjoint_union"
    },
    {
        "Section_id": "disjoint_union",
        "See Also": ""
    },
    {
        "Section_id": "intersection",
        "Description": "Graph intersection.\nThe intersection of two or more graphs is created. The graphs may haveidentical or overlapping vertex sets. Edges which are included in allgraphs will be part of the new graph.\nThis function keeps the attributes of all graphs. All graph, vertex andedge attributes are copied to the result. If an attribute is present inmultiple graphs and would result a name clash, then this attribute isrenamed by adding suffixes: _1, _2, etc.\nThe name vertex attribute is treated specially if the operation isperformed based on symbolic vertex names. In this case name must bepresent in all graphs, and it is not renamed in the result graph.\nAn error is generated if some input graphs are directed and others areundirected."
    },
    {
        "Paramters": {
            "graphs": "list of . A lazy sequence is not acceptable.",
            "byname": "bool or 'auto' specifying the function behaviour withrespect to names vertices (i.e. vertices with the 'name' attribute). IfFalse, ignore vertex names. If True, merge vertices based on names. If'auto', use True if all graphs have named vertices and False otherwise(in the latter case, a warning is generated too).",
            "keep_all_vertices": "bool specifying if vertices that are not presentin all graphs should be kept in the intersection."
        },
        "Section_id": "intersection"
    },
    {
        "Section_id": "intersection",
        "Return": [
            "the intersection graph"
        ]
    },
    {
        "Raises": {
            "RuntimeError": "if 'byname' is set to True and some graphs are not named or\nthe set of names is not unique in one of the graphs"
        },
        "Section_id": "intersection"
    },
    {
        "Section_id": "intersection",
        "See Also": ""
    },
    {
        "Section_id": "name_set",
        "Description": "Converts a list of names to a set of names while checking for duplicates."
    },
    {
        "Paramters": {
            "names": "the list of  to convert"
        },
        "Section_id": "name_set"
    },
    {
        "Section_id": "name_set",
        "Return": [
            "the set of unique names appearing in the list"
        ]
    },
    {
        "Raises": {
            "RuntimeError": "if the input name list has duplicates"
        },
        "Section_id": "name_set"
    },
    {
        "Section_id": "name_set",
        "See Also": ""
    },
    {
        "Section_id": "union",
        "Description": "Graph union.\nThe union of two or more graphs is created. The graphs may have identicalor overlapping vertex sets. Edges which are included in at least one graphwill be part of the new graph.\nThis function keeps the attributes of all graphs. All graph, vertex andedge attributes are copied to the result. If an attribute is present inmultiple graphs and would result a name clash, then this attribute isrenamed by adding suffixes: _1, _2, etc.\nThe name vertex attribute is treated specially if the operation isperformed based on symbolic vertex names. In this case name must bepresent in all graphs, and it is not renamed in the result graph.\nAn error is generated if some input graphs are directed and others areundirected."
    },
    {
        "Paramters": {
            "graphs": "list of . A lazy sequence is not acceptable.",
            "byname": "bool or 'auto' specifying the function behaviour withrespect to names vertices (i.e. vertices with the 'name' attribute). IfFalse, ignore vertex names. If True, merge vertices based on names. If'auto', use True if all graphs have named vertices and False otherwise(in the latter case, a warning is generated too)."
        },
        "Section_id": "union"
    },
    {
        "Section_id": "union",
        "Return": [
            "the union graph"
        ]
    },
    {
        "Raises": {
            "RuntimeError": "if 'byname' is set to True and some graphs are not named or\nthe set of names is not unique in one of the graphs"
        },
        "Section_id": "union"
    },
    {
        "Section_id": "union",
        "See Also": ""
    },
    {
        "Section_id": "CairoPolygonDrawer",
        "Description": "Class that is used to draw polygons in Cairo.\nThe corner points of the polygon can be set by the points property of the drawer, or passed at construction time. Most drawing methods in this class also have an extra points argument that can be used to override the set of points in the points property."
    },
    {
        "Field List > Methods > __init__": {
            "Description": "overrides igraph.drawing.cairo.base.AbstractCairoDrawer.__init__\nConstructs a new polygon drawer that draws on the given Cairo context.",
            "Paramters": {
                "context": "the Cairo  to draw on",
                "bbox": "ignored, leave it at its default value"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "CairoPolygonDrawer"
    },
    {
        "Field List > Methods > draw": {
            "Description": "overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nDraws the polygon using the current stroke of the Cairo context.",
            "Paramters": {
                "points": "the coordinates of the corners of the polygon, in clockwise or counter-clockwise order."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "CairoPolygonDrawer"
    },
    {
        "Field List > Methods > draw_path": {
            "Description": "Sets up a Cairo path for the outline of a polygon on the given Cairo context.",
            "Paramters": {
                "points": "the coordinates of the corners of the polygon, in clockwise or counter-clockwise order.",
                "corner_radius": "if zero, an ordinary polygon will be drawn. If positive, the corners of the polygon will be rounded with the given radius."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "CairoPolygonDrawer"
    },
    {
        "Field List > Methods > bbox.setter": {
            "Description": "Inherited from AbstractCairoDrawer:Sets the bounding box of the drawing area where this drawer will draw."
        },
        "Section_id": "CairoPolygonDrawer"
    },
    {
        "Field List > property": {
            "bbox": "Inherited from AbstractCairoDrawer:The bounding box of the drawing area where this drawer will draw."
        },
        "Section_id": "CairoPolygonDrawer"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "CairoPolygonDrawer"
    },
    {
        "Section_id": "main",
        "Description": "The main entry point for igraph when invoked from the command line shell"
    },
    {
        "Paramters": {},
        "Section_id": "main"
    },
    {
        "Raises": {},
        "Section_id": "main"
    },
    {
        "Section_id": "main",
        "See Also": ""
    },
    {
        "Section_id": "get_user_config_file",
        "Description": "Returns the path where the user-level configuration file is stored"
    },
    {
        "Paramters": {},
        "Section_id": "get_user_config_file"
    },
    {
        "Raises": {},
        "Section_id": "get_user_config_file"
    },
    {
        "Section_id": "get_user_config_file",
        "See Also": ""
    },
    {
        "Section_id": "init",
        "Description": "Default mechanism to initiate igraph configuration\nThis method loads the user-specific configuration file from the user's home directory, or if it does not exist, creates a default configuration.\nThe method is safe to be called multiple times, it will not parse the configuration file twice."
    },
    {
        "Paramters": {},
        "Section_id": "init"
    },
    {
        "Section_id": "init",
        "Return": [
            "Configurationthe Configuration object loaded or created."
        ]
    },
    {
        "Raises": {},
        "Section_id": "init"
    },
    {
        "Section_id": "init",
        "See Also": ""
    },
    {
        "Section_id": "ARPACKOptions",
        "Description": "Class representing the parameters of the ARPACK module.\nARPACK is a Fortran implementation of the implicitly restarted Arnoldi method, an algorithm for calculating some of the eigenvalues and eigenvectors of a given matrix. igraph uses this package occasionally, and this class can be used to fine-tune the behaviour of ARPACK in such cases.\nThe class has several attributes which are not documented here, since they are usually of marginal use to the ordinary user. See the source code of the original ARPACK Fortran package (especially the file dsaupd.f) for a detailed explanation of the parameters. Only the most basic attributes are explained here. Most of them are read only unless stated otherwise. bmat: type of the eigenproblem solved. 'I' means standard eigenproblem (A*x = lambda*x), 'G' means generalized eigenproblem (A*x = lambda*B*x). n: dimension of the eigenproblem tol: precision. If less than or equal to zero, the standard machine precision is used as computed by the LAPACK utility called dlamch. This can be modified. mxiter: maximum number of update iterations to take. This can be modified. You can also use maxiter. iter: actual number of update iterations taken numop: total number of OP*x operations numopb: total number of B*x operations if bmat is 'G' numreo: total number of steps of re-orthogonalization "
    },
    {
        "Field List > property": {},
        "Section_id": "ARPACKOptions"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "ARPACKOptions"
    },
    {
        "Section_id": "GephiGraphStreamer",
        "Description": "Class that produces JSON event objects that stream an igraph graph to Gephi using the Gephi Graph Streaming API.\nThe Gephi graph streaming format is a simple JSON-based format that can be used to post mutations to a graph (i.e. node and edge additions, removals and updates) to a remote component. For instance, one can open up Gephi (http://www.gephi.org), install the Gephi graph streaming plugin and then send a graph from igraph straight into the Gephi window by using GephiGraphStreamer with the appropriate URL where Gephi is listening.\n"
    },
    {
        "Field List > Methods > __init__": {
            "Description": "Constructs a Gephi graph streamer that will post graphs to agiven file-like object or a Gephi connection.\nencoder must either be None or an instance of json.JSONEncoderand it must contain the JSON encoder to be used when posting JSON objects.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GephiGraphStreamer"
    },
    {
        "Field List > Methods > iterjsonobj": {
            "Description": "Iterates over the JSON objects that build up the graph using theGephi graph streaming API. The objects returned from this function arePython objects; they must be formatted with json.dumps beforesending them to the destination.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GephiGraphStreamer"
    },
    {
        "Field List > Methods > post": {
            "Description": "Posts the given graph to the destination of the streamer using thegiven JSON encoder. When encoder is None, it falls back to thedefault JSON encoder of the streamer in the encoder property.\ndestination must be a file-like object or an instance ofGephiConnection.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GephiGraphStreamer"
    },
    {
        "Field List > Methods > send_event": {
            "Description": "Sends a single JSON event to the given destination using the givenJSON encoder.  When encoder is None, it falls back to thedefault JSON encoder of the streamer in the encoder property.\ndestination must be a file-like object or an instance ofGephiConnection.\nThe method flushes the destination after sending the event. If you wantto avoid this (e.g., because you are sending many events), setflush to False.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GephiGraphStreamer"
    },
    {
        "Field List > property": {},
        "Section_id": "GephiGraphStreamer"
    },
    {
        "Rubric": {
            "Example": [
                "Example:\n>>> from cStringIO import StringIO\n>>> from igraph import Graph\n>>> buf = StringIO()\n>>> streamer = GephiGraphStreamer()\n>>> graph = Graph.Formula(\"A --> B, B --> C\")\n>>> streamer.post(graph, buf)\n>>> print(buf.getvalue())        # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE\n{\"an\": {\"igraph:...:v:0\": {\"name\": \"A\"}}}\n{\"an\": {\"igraph:...:v:1\": {\"name\": \"B\"}}}\n{\"an\": {\"igraph:...:v:2\": {\"name\": \"C\"}}}\n{\"ae\": {\"igraph:...:e:0:1\": {...}}}\n{\"ae\": {\"igraph:...:e:1:2\": {...}}}\n<BLANKLINE>\n"
            ]
        },
        "Section_id": "GephiGraphStreamer"
    },
    {
        "Section_id": "find_matplotlib",
        "Description": "Tries to import the matplotlib Python module if it is installed.Returns a fake module if everything fails."
    },
    {
        "Paramters": {},
        "Section_id": "find_matplotlib"
    },
    {
        "Raises": {},
        "Section_id": "find_matplotlib"
    },
    {
        "Section_id": "find_matplotlib",
        "See Also": ""
    },
    {
        "Section_id": "VertexCollection",
        "Description": "Collection of vertex patches for plotting.\nThis class takes additional keyword arguments compared to PatchCollection:Parametersvertex_builderA list of vertex builders to construct the visual vertices. This is updated if the size of the vertices is changed.size_callbackA function to be triggered after vertex sizes are changed. Typically this redraws the edges."
    },
    {
        "Field List > Methods > __init__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "VertexCollection"
    },
    {
        "Field List > Methods > get_size": {
            "Description": "Get vertex sizes.\nIf width and height are unequal, get the largest of the two.",
            "Paramters": {},
            "Return": [
                "An array of vertex sizes."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "VertexCollection"
    },
    {
        "Field List > Methods > get_sizes": {
            "Description": "Same as get_size.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "VertexCollection"
    },
    {
        "Field List > Methods > set_size": {
            "Description": "Set vertex sizes.\nThis rescales the current vertex symbol/path linearly, using this value as the largest of width and height.",
            "Paramters": {
                "sizes": "A sequence of vertex  or a single size."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "VertexCollection"
    },
    {
        "Field List > Methods > set_sizes": {
            "Description": "Same as set_size.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "VertexCollection"
    },
    {
        "Field List > Methods > stale": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "VertexCollection"
    },
    {
        "Field List > property": {
            "stale": "Undocumented\n"
        },
        "Section_id": "VertexCollection"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "VertexCollection"
    },
    {
        "Section_id": "TaperedEdgeDrawer",
        "Description": "Edge drawer implementation that draws undirected edges as straight lines and directed edges as tapered lines that are wider at the source and narrow at the destination."
    },
    {
        "Field List > Methods > draw_directed_edge": {
            "Description": "overrides igraph.drawing.baseclasses.AbstractEdgeDrawer.draw_directed_edge\nDraws a directed edge.",
            "Paramters": {
                "edge": "the  to be drawn. Visual properties of the  are defined by the attributes of this object.",
                "src_vertex": "the source vertex. Visual properties are defined by the attributes of this object.",
                "dest_vertex": "the source vertex. Visual properties are defined by the attributes of this object."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "TaperedEdgeDrawer"
    },
    {
        "Field List > Methods > __init__": {
            "Description": "Inherited from AbstractCairoEdgeDrawer:Constructs the edge drawer."
        },
        "Section_id": "TaperedEdgeDrawer"
    },
    {
        "Field List > Methods > draw_loop_edge": {
            "Description": "Inherited from AbstractCairoEdgeDrawer:Draws a loop edge."
        },
        "Section_id": "TaperedEdgeDrawer"
    },
    {
        "Field List > Methods > draw_undirected_edge": {
            "Description": "Inherited from AbstractCairoEdgeDrawer:Draws an undirected edge."
        },
        "Section_id": "TaperedEdgeDrawer"
    },
    {
        "Field List > property": {},
        "Section_id": "TaperedEdgeDrawer"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "TaperedEdgeDrawer"
    },
    {
        "Section_id": "Rectangle",
        "Description": "Class representing a rectangle."
    },
    {
        "Field List > Methods > __bool__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Rectangle"
    },
    {
        "Field List > Methods > __eq__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Rectangle"
    },
    {
        "Field List > Methods > __hash__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Rectangle"
    },
    {
        "Field List > Methods > __init__": {
            "Description": "Creates a rectangle.\nThe corners of the rectangle can be specified by either a tuple (four items, two for each corner, respectively), four separate numbers (X and Y coordinates for each corner) or two separate numbers (width and height, the upper left corner is assumed to be at (0,0))",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Rectangle"
    },
    {
        "Field List > Methods > __ior__": {
            "Description": "overridden in igraph.drawing.utils.BoundingBox\nExpands this rectangle to include itself and another completely while still being as small as possible.\nExample:",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": [
                "Example:\n    >>> r1 = Rectangle(10, 10, 30, 30)\n    >>> r2 = Rectangle(20, 20, 50, 50)\n    >>> r3 = Rectangle(70, 70, 90, 90)\n    >>> r1 |= r2\n    >>> r1\n    Rectangle(10.0, 10.0, 50.0, 50.0)\n    >>> r1 |= r3\n    >>> r1\n    Rectangle(10.0, 10.0, 90.0, 90.0)\n"
            ]
        },
        "Section_id": "Rectangle"
    },
    {
        "Field List > Methods > __ne__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Rectangle"
    },
    {
        "Field List > Methods > __repr__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Rectangle"
    },
    {
        "Field List > Methods > bottom": {
            "Description": "Sets the Y coordinate of the bottom edge of the box",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Rectangle"
    },
    {
        "Field List > Methods > contract": {
            "Description": "Contracts the rectangle by the given margins.",
            "Paramters": {},
            "Return": [
                "a new Rectangle object."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Rectangle"
    },
    {
        "Field List > Methods > coords": {
            "Description": "Sets the coordinates of the corners.",
            "Paramters": {
                "coords": "a 4-tuple with the coordinates of the corners"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Rectangle"
    },
    {
        "Field List > Methods > expand": {
            "Description": "Expands the rectangle by the given margins.",
            "Paramters": {},
            "Return": [
                "a new Rectangle object."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Rectangle"
    },
    {
        "Field List > Methods > height": {
            "Description": "Sets the height of the rectangle by adjusting the bottom edge.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Rectangle"
    },
    {
        "Field List > Methods > intersection": {
            "Description": "Returns the intersection of this rectangle with another.\nExample:",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": [
                "Example:\n    >>> r1 = Rectangle(10, 10, 30, 30)\n    >>> r2 = Rectangle(20, 20, 50, 50)\n    >>> r3 = Rectangle(70, 70, 90, 90)\n    >>> r1.intersection(r2)\n    Rectangle(20.0, 20.0, 30.0, 30.0)\n    >>> r2 & r1\n    Rectangle(20.0, 20.0, 30.0, 30.0)\n    >>> r2.intersection(r1) == r1.intersection(r2)\n    True\n    >>> r1.intersection(r3)\n    Rectangle(0.0, 0.0, 0.0, 0.0)\n"
            ]
        },
        "Section_id": "Rectangle"
    },
    {
        "Field List > Methods > isdisjoint": {
            "Description": "Returns True if the two rectangles have no intersection.\nExample:",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": [
                "Example:\n    >>> r1 = Rectangle(10, 10, 30, 30)\n    >>> r2 = Rectangle(20, 20, 50, 50)\n    >>> r3 = Rectangle(70, 70, 90, 90)\n    >>> r1.isdisjoint(r2)\n    False\n    >>> r2.isdisjoint(r1)\n    False\n    >>> r1.isdisjoint(r3)\n    True\n    >>> r3.isdisjoint(r1)\n    True\n"
            ]
        },
        "Section_id": "Rectangle"
    },
    {
        "Field List > Methods > isempty": {
            "Description": "Returns True if the rectangle is empty (i.e. it has zero width and height).\nExample:",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": [
                "Example:\n    >>> r1 = Rectangle(10, 10, 30, 30)\n    >>> r2 = Rectangle(70, 70, 90, 90)\n    >>> r1.isempty()\n    False\n    >>> r2.isempty()\n    False\n    >>> r1.intersection(r2).isempty()\n    True\n"
            ]
        },
        "Section_id": "Rectangle"
    },
    {
        "Field List > Methods > left": {
            "Description": "Sets the X coordinate of the left side of the box",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Rectangle"
    },
    {
        "Field List > Methods > midx": {
            "Description": "Moves the center of the box to the given X coordinate",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Rectangle"
    },
    {
        "Field List > Methods > midy": {
            "Description": "Moves the center of the box to the given Y coordinate",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Rectangle"
    },
    {
        "Field List > Methods > right": {
            "Description": "Sets the X coordinate of the right side of the box",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Rectangle"
    },
    {
        "Field List > Methods > shape": {
            "Description": "Sets the shape of the rectangle (width, height).",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Rectangle"
    },
    {
        "Field List > Methods > top": {
            "Description": "Sets the Y coordinate of the top edge of the box",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Rectangle"
    },
    {
        "Field List > Methods > translate": {
            "Description": "Translates the rectangle in-place.\nExample:",
            "Paramters": {
                "dx": "the X coordinate of the translation vector",
                "dy": "the Y coordinate of the translation vector"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": [
                "Example:\n>>> r = Rectangle(10, 20, 50, 70)\n>>> r.translate(30, -10)\n>>> r\nRectangle(40.0, 10.0, 80.0, 60.0)\n"
            ]
        },
        "Section_id": "Rectangle"
    },
    {
        "Field List > Methods > union": {
            "Description": "Returns the union of this rectangle with another.\nThe resulting rectangle is the smallest rectangle that contains both rectangles.\nExample:",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": [
                "Example:\n    >>> r1 = Rectangle(10, 10, 30, 30)\n    >>> r2 = Rectangle(20, 20, 50, 50)\n    >>> r3 = Rectangle(70, 70, 90, 90)\n    >>> r1.union(r2)\n    Rectangle(10.0, 10.0, 50.0, 50.0)\n    >>> r2 | r1\n    Rectangle(10.0, 10.0, 50.0, 50.0)\n    >>> r2.union(r1) == r1.union(r2)\n    True\n    >>> r1.union(r3)\n    Rectangle(10.0, 10.0, 90.0, 90.0)\n"
            ]
        },
        "Section_id": "Rectangle"
    },
    {
        "Field List > Methods > width": {
            "Description": "Sets the width of the rectangle by adjusting the right edge.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Rectangle"
    },
    {
        "Field List > property": {
            "bottom": "The Y coordinate of the bottom edge of the box\n",
            "coords": "The coordinates of the corners.\nThe coordinates are returned as a 4-tuple in the following order: left edge, top edge, right edge, bottom edge.\n\n",
            "left": "The X coordinate of the left side of the box\n",
            "midx": "The X coordinate of the center of the box\n",
            "midy": "The Y coordinate of the center of the box\n",
            "right": "The X coordinate of the right side of the box\n",
            "shape": "The shape of the rectangle (width, height)\n",
            "top": "The Y coordinate of the top edge of the box\n"
        },
        "Section_id": "Rectangle"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "Rectangle"
    },
    {
        "Section_id": "cairo",
        "Description": "Undocumented"
    },
    {
        "Section_id": "AbstractEdgeDrawer",
        "Description": "Abstract edge drawer object from which all concrete edge drawer implementations are derived."
    },
    {
        "Field List > Methods > draw_directed_edge": {
            "Description": "overridden in igraph.drawing.cairo.edge.AlphaVaryingEdgeDrawer, igraph.drawing.cairo.edge.CairoArrowEdgeDrawer, igraph.drawing.cairo.edge.TaperedEdgeDrawer, igraph.drawing.matplotlib.edge.MatplotlibEdgeDrawer, igraph.drawing.plotly.edge.PlotlyEdgeDrawer\nDraws a directed edge.",
            "Paramters": {
                "edge": "the  to be drawn. Visual properties of the  are defined by the attributes of this object.",
                "src_vertex": "the source vertex. Visual properties are defined by the attributes of this object.",
                "dest_vertex": "the source vertex. Visual properties are defined by the attributes of this object."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "AbstractEdgeDrawer"
    },
    {
        "Field List > Methods > draw_undirected_edge": {
            "Description": "overridden in igraph.drawing.cairo.edge.AbstractCairoEdgeDrawer, igraph.drawing.matplotlib.edge.MatplotlibEdgeDrawer, igraph.drawing.plotly.edge.PlotlyEdgeDrawer\nDraws an undirected edge.",
            "Paramters": {
                "edge": "the  to be drawn. Visual properties of the  are defined by the attributes of this object.",
                "src_vertex": "the source vertex. Visual properties are defined by the attributes of this object.",
                "dest_vertex": "the source vertex. Visual properties are defined by the attributes of this object."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "AbstractEdgeDrawer"
    },
    {
        "Field List > Methods > get_label_position": {
            "Description": "Returns the position where the label of an edge should be drawn. the default implementation returns the midpoint of the edge and an alignment that tries to avoid overlapping the label with the edge.",
            "Paramters": {
                "edge": "the  to be drawn. visual properties of the  are defined by the attributes of this object.",
                "src_vertex": "the source vertex. visual properties are given again as attributes.",
                "dest_vertex": "the target vertex. visual properties are given again as attributes."
            },
            "Return": [
                "a tuple containing two more tuples: the desired position of the label and the desired alignment of the label, where the position is given as c{(x, y)} and the alignment is given as c{(horizontal, vertical)}. members of the alignment tuple are taken from constants in the l{textalignment} class."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "AbstractEdgeDrawer"
    },
    {
        "Field List > Methods > get_label_rotation": {
            "Description": "Get the rotation angle of the label to align with the edge.",
            "Paramters": {
                "edge": "the  to be drawn. visual properties of the  are defined by the attributes of this object.",
                "src_vertex": "the source vertex. visual properties are given again as attributes.",
                "dest_vertex": "the target vertex. visual properties are given again as attributes."
            },
            "Return": [
                "a float with the desired angle, in degrees (out of 360)."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "AbstractEdgeDrawer"
    },
    {
        "Field List > property": {},
        "Section_id": "AbstractEdgeDrawer"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "AbstractEdgeDrawer"
    },
    {
        "Section_id": "find_plotly",
        "Description": "Tries to import the plotly Python module if it is installed.Returns a fake module if everything fails."
    },
    {
        "Paramters": {},
        "Section_id": "find_plotly"
    },
    {
        "Raises": {},
        "Section_id": "find_plotly"
    },
    {
        "Section_id": "find_plotly",
        "See Also": ""
    },
    {
        "Section_id": "format_arc",
        "Description": "Approximation of an SVG-style arc\nNOTE: plotly does not currently support the native SVG \"A/a\" commands"
    },
    {
        "Paramters": {},
        "Section_id": "format_arc"
    },
    {
        "Raises": {},
        "Section_id": "format_arc"
    },
    {
        "Section_id": "format_arc",
        "See Also": ""
    },
    {
        "Section_id": "format_path_step",
        "Description": "Format step in SVG path for plotly"
    },
    {
        "Paramters": {},
        "Section_id": "format_path_step"
    },
    {
        "Raises": {},
        "Section_id": "format_path_step"
    },
    {
        "Section_id": "format_path_step",
        "See Also": ""
    },
    {
        "Section_id": "format_rgba",
        "Description": "Format colors in a way understood by plotly"
    },
    {
        "Paramters": {},
        "Section_id": "format_rgba"
    },
    {
        "Raises": {},
        "Section_id": "format_rgba"
    },
    {
        "Section_id": "format_rgba",
        "See Also": ""
    },
    {
        "Section_id": "DFSIter",
        "Description": "igraph DFS iterator object"
    },
    {
        "Field List > property": {},
        "Section_id": "DFSIter"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "DFSIter"
    },
    {
        "Section_id": "cairo",
        "Description": "Undocumented"
    },
    {
        "Section_id": "CairoMatrixDrawer",
        "Description": "Default Cairo drawer object for matrices."
    },
    {
        "Field List > Methods > __init__": {
            "Description": "overrides igraph.drawing.cairo.base.AbstractCairoDrawer.__init__\nConstructs the vertex drawer and associates it to the given palette.",
            "Paramters": {
                "context": "the  on which we will draw"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "CairoMatrixDrawer"
    },
    {
        "Field List > Methods > draw": {
            "Description": "overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nDraws the given Matrix in a Cairo context.",
            "Paramters": {
                "matrix": "the igraph.Matrix to plot.It accepts the following keyword arguments:bbox:    the bounding box within which we will draw. Can be anything accepted by the constructor of BoundingBox (i.e., a 2-tuple, a 4-tuple or a BoundingBox object).palette: the palette that can be used to map integer color indices to colors when drawing verticesstyle: the style of the plot. boolean is useful for plotting matrices with boolean (True/False or 0/1) values: False will be shown with a white box and True with a black box. palette uses the given palette to represent numbers by colors, the minimum will be assigned to palette color index 0 and the maximum will be assigned to the length of the palette. None draws transparent cell backgrounds only. The default style is boolean (but it may change in the future). None values in the  are treated specially in both cases: nothing is drawn in the cell corresponding to None.square: whether the cells of the  should be square or not. Default is True.grid_width: line width of the grid shown on the . If zero or negative, the grid is turned off. The grid is also turned off if the size of a cell is less than three times the given line width. Default is 1. Fractional widths are also allowed.border_width: line width of the border drawn around the . If zero or negative, the border is turned off. Default is 1.row_names: the names of the rowscol_names: the names of the columns.values: values to be displayed in the cells. If None or False, no values are displayed. If True, the values come from the  being plotted. If it is another , the values of that  are shown in the cells. In this case, the shape of the value  must match the shape of the  being plotted.value_format: a format string or a callable that specifies how the values should be plotted. If it is a callable, it must be a function that expects a single value and returns a string. Example: \"%#.2f\" for floating-point numbers with always exactly two digits after the decimal point. See the Python documentation of the % operator for details on the format string. If the format string is not given, it defaults to the str function.If only the row names or the column names are given and the  is square-shaped, the same names are used for both column and row names.",
                "**kwds": "Undocumented"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "CairoMatrixDrawer"
    },
    {
        "Field List > Methods > bbox.setter": {
            "Description": "Inherited from AbstractCairoDrawer:Sets the bounding box of the drawing area where this drawer will draw."
        },
        "Section_id": "CairoMatrixDrawer"
    },
    {
        "Field List > property": {},
        "Section_id": "CairoMatrixDrawer"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "CairoMatrixDrawer"
    },
    {
        "Section_id": "Matrix",
        "Description": "Simple matrix data type.\nOf course there are much more advanced matrix data types for Python (for instance, the ndarray data type of Numeric Python) and this implementation does not want to compete with them. The only role of this data type is to provide a convenient interface for the matrices returned by the Graph object (for instance, allow indexing with tuples in the case of adjacency matrices and so on)."
    },
    {
        "Field List > Methods > Fill": {
            "Description": "Creates a matrix filled with the given value",
            "Paramters": {
                "value": "the  to be used",
                "*args": "Undocumented",
                "shape": "the  of the matrix. Can be a single integer, two integers or a tuple. If a single integer is given here, the matrix is assumed to be square-d."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Matrix"
    },
    {
        "Field List > Methods > Identity": {
            "Description": "Creates an identity matrix.",
            "Paramters": {
                "*args": "Undocumented",
                "shape": "the  of the matrix. Can be a single integer, two integers or a tuple. If a single integer is given here, the matrix is assumed to be square-d."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Matrix"
    },
    {
        "Field List > Methods > Zero": {
            "Description": "Creates a matrix filled with zeros.",
            "Paramters": {
                "*args": "Undocumented",
                "shape": "the  of the matrix. Can be a single integer, two integers or a tuple. If a single integer is given here, the matrix is assumed to be square-d."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Matrix"
    },
    {
        "Field List > Methods > __add__": {
            "Description": "Adds the given value to the matrix.",
            "Paramters": {
                "other": "either a scalar or a matrix. Scalars will be added to each element of the matrix. Matrices will be added together elementwise."
            },
            "Return": [
                "the result matrix"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Matrix"
    },
    {
        "Field List > Methods > __eq__": {
            "Description": "Checks whether a given matrix is equal to another one",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Matrix"
    },
    {
        "Field List > Methods > __getitem__": {
            "Description": "Returns a single item, a row or a column of the matrix",
            "Paramters": {
                "i": "f a sngle nteger, returns the th row as a lst. If a slce, returns the correspondng rows as another Matrx object. If a 2-tuple, the frst element of the tuple s used to select a row and the second s used to select a column."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Matrix"
    },
    {
        "Field List > Methods > __hash__": {
            "Description": "Returns a hash value for a matrix.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Matrix"
    },
    {
        "Field List > Methods > __iadd__": {
            "Description": "In-place addition of a matrix or scalar.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Matrix"
    },
    {
        "Field List > Methods > __init__": {
            "Description": "Initializes a matrix.",
            "Paramters": {
                "data": "the elements of the matrix as a list of lists, or None to create a 0x0 matrix."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Matrix"
    },
    {
        "Field List > Methods > __isub__": {
            "Description": "In-place subtraction of a matrix or scalar.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Matrix"
    },
    {
        "Field List > Methods > __iter__": {
            "Description": "Support for iteration.\nThis is actually implemented as a generator, so there is no need for a separate iterator class. The generator returns copies of the rows in the matrix as lists to avoid messing around with the internals. Feel free to do anything with the copies, the changes won't be reflected in the original matrix.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Matrix"
    },
    {
        "Field List > Methods > __len__": {
            "Description": "Returns the number of rows in the matrix.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Matrix"
    },
    {
        "Field List > Methods > __ne__": {
            "Description": "Checks whether a given matrix is not equal to another one",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Matrix"
    },
    {
        "Field List > Methods > __plot__": {
            "Description": "Plots the matrix to the given Cairo context or matplotlib Axes.\nBesides the usual self-explanatory plotting parameters (context, bbox, palette), it accepts the following keyword arguments:style: the style of the plot. boolean is useful for plotting matrices with boolean (True/False or 0/1) values: False will be shown with a white box and True with a black box. palette uses the given palette to represent numbers by colors, the minimum will be assigned to palette color index 0 and the maximum will be assigned to the length of the palette. None draws transparent cell backgrounds only. The default style is boolean (but it may change in the future). None values in the matrix are treated specially in both cases: nothing is drawn in the cell corresponding to None.square: whether the cells of the matrix should be square or not. Default is True.grid_width: line width of the grid shown on the matrix. If zero or negative, the grid is turned off. The grid is also turned off if the size of a cell is less than three times the given line width. Default is 1. Fractional widths are also allowed.border_width: line width of the border drawn around the matrix. If zero or negative, the border is turned off. Default is 1.row_names: the names of the rowscol_names: the names of the columns.values: values to be displayed in the cells. If None or False, no values are displayed. If True, the values come from the matrix being plotted. If it is another matrix, the values of that matrix are shown in the cells. In this case, the shape of the value matrix must match the shape of the matrix being plotted.value_format: a format string or a callable that specifies how the values should be plotted. If it is a callable, it must be a function that expects a single value and returns a string. Example: \"%#.2f\" for floating-point numbers with always exactly two digits after the decimal point. See the Python documentation of the % operator for details on the format string. If the format string is not given, it defaults to the str function.\nIf only the row names or the column names are given and the matrix is square-shaped, the same names are used for both column and row names.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Matrix"
    },
    {
        "Field List > Methods > __repr__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Matrix"
    },
    {
        "Field List > Methods > __setitem__": {
            "Description": "Sets a single item, a row or a column of the matrix",
            "Paramters": {
                "i": "f a sngle nteger, sets the th row as a lst. If a slce, sets the correspondng rows from another Matrx object. If a 2-tuple, the frst element of the tuple s used to select a row and the second s used to select a column.",
                "value": "the new "
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Matrix"
    },
    {
        "Field List > Methods > __str__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Matrix"
    },
    {
        "Field List > Methods > __sub__": {
            "Description": "Subtracts the given value from the matrix.",
            "Paramters": {
                "other": "either a scalar or a matrix. Scalars will be subtracted from each element of the matrix. Matrices will be subtracted together elementwise."
            },
            "Return": [
                "the result matrix"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Matrix"
    },
    {
        "Field List > Methods > max": {
            "Description": "Returns the maximum of the matrix along the given dimension",
            "Paramters": {
                "dim": "the ension. 0 means determining the column maximums, 1 means determining the row maximums. If None, the global maximum is returned."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Matrix"
    },
    {
        "Field List > Methods > min": {
            "Description": "Returns the minimum of the matrix along the given dimension",
            "Paramters": {
                "dim": "the ension. 0 means determining the column minimums, 1 means determining the row minimums. If None, the global minimum is returned."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Matrix"
    },
    {
        "Field List > property": {
            "shape": "Returns the shape of the matrix as a tuple\n"
        },
        "Section_id": "Matrix"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "Matrix"
    },
    {
        "Section_id": "EdgeCollection",
        "Description": "Undocumented"
    },
    {
        "Field List > Methods > __init__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "EdgeCollection"
    },
    {
        "Field List > Methods > draw": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "EdgeCollection"
    },
    {
        "Field List > Methods > get_arrow_size": {
            "Description": "Get arrow sizes for the edges (directed only).",
            "Paramters": {},
            "Return": [
                "An array of arrow sizes."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "EdgeCollection"
    },
    {
        "Field List > Methods > get_arrow_sizes": {
            "Description": "Same as get_arrow_size.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "EdgeCollection"
    },
    {
        "Field List > Methods > get_arrow_width": {
            "Description": "Get arrow widths for the edges (directed only).",
            "Paramters": {},
            "Return": [
                "An array of arrow widths."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "EdgeCollection"
    },
    {
        "Field List > Methods > get_arrow_widths": {
            "Description": "Same as get_arrow_width.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "EdgeCollection"
    },
    {
        "Field List > Methods > set_arrow_size": {
            "Description": "Set arrow sizes.",
            "Paramters": {
                "sizes": "A sequence of arrow  or a single size."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "EdgeCollection"
    },
    {
        "Field List > Methods > set_arrow_sizes": {
            "Description": "Same as set_arrow_size",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "EdgeCollection"
    },
    {
        "Field List > Methods > set_arrow_width": {
            "Description": "Set arrow widths.",
            "Paramters": {
                "widths": "A sequence of arrow  or a single width."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "EdgeCollection"
    },
    {
        "Field List > Methods > set_arrow_widths": {
            "Description": "Same as set_arrow_width",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "EdgeCollection"
    },
    {
        "Field List > Methods > stale": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "EdgeCollection"
    },
    {
        "Field List > property": {
            "stale": "Undocumented\n"
        },
        "Section_id": "EdgeCollection"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "EdgeCollection"
    },
    {
        "Section_id": "Layout",
        "Description": "Represents the layout of a graph.\nA layout is practically a list of coordinates in an n-dimensional space. This class is generic in the sense that it can store coordinates in any n-dimensional space.\nLayout objects are not associated directly with a graph. This is deliberate: there were times when I worked with almost identical copies of the same graph, the only difference was that they had different colors assigned to the vertices. It was particularly convenient for me to use the same layout for all of them, especially when I made figures for a paper. However, igraph will of course refuse to draw a graph with a layout that has fewer coordinates than the node count of the graph.\n"
    },
    {
        "Field List > Methods > __copy__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Layout"
    },
    {
        "Field List > Methods > __delitem__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Layout"
    },
    {
        "Field List > Methods > __getitem__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Layout"
    },
    {
        "Field List > Methods > __init__": {
            "Description": "Constructor.",
            "Paramters": {
                "coords": "the coordinates to be stored in the layout.",
                "dim": "the number of ensions. If None, the number of ensions is determined automatically from the length of the first item of the coordinate list. If there are no entries in the coordinate list, the default will be 2.  Generally, this should be given if the length of the coordinate list is zero, otherwise it should be left as is."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Layout"
    },
    {
        "Field List > Methods > __len__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Layout"
    },
    {
        "Field List > Methods > __repr__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Layout"
    },
    {
        "Field List > Methods > __setitem__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Layout"
    },
    {
        "Field List > Methods > append": {
            "Description": "Appends a new point to the layout",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Layout"
    },
    {
        "Field List > Methods > boundaries": {
            "Description": "Returns the boundaries of the layout.\nThe boundaries are the minimum and maximum coordinates along all dimensions.",
            "Paramters": {
                "border": "this value gets subtracted from the minimum bounds and gets added to the maximum bounds before returning the coordinates of the box. Defaults to zero."
            },
            "Return": [
                "the minimum and maximum coordinates along all dimensions, in a tuple containing two lists, one for the minimum coordinates, the other one for the maximum."
            ],
            "References": [],
            "Rasises": {
                "ValueError": "if the layout contains no layout items"
            },
            "See Also": "",
            "example": []
        },
        "Section_id": "Layout"
    },
    {
        "Field List > Methods > bounding_box": {
            "Description": "Returns the bounding box of the layout.\nThe bounding box of the layout is the smallest box enclosing all the points in the layout.",
            "Paramters": {
                "border": "this value gets subtracted from the minimum bounds and gets added to the maximum bounds before returning the coordinates of the box. Defaults to zero."
            },
            "Return": [
                "the coordinates of the lower left and the upper right corner of the box. \"Lower left\" means the minimum coordinates and \"upper right\" means the maximum. These are encapsulated in a BoundingBox object."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Layout"
    },
    {
        "Field List > Methods > center": {
            "Description": "Centers the layout around the given point.\nThe point itself can be supplied as multiple unnamed arguments, as a simple unnamed list or as a keyword argument. This operation moves the centroid of the layout to the given point. If no point is supplied, defaults to the origin of the coordinate system.",
            "Paramters": {
                "*args": "Undocumented",
                "p": "the oint where the centroid of the layout will be after the oeration."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Layout"
    },
    {
        "Field List > Methods > centroid": {
            "Description": "Returns the centroid of the layout.\nThe centroid of the layout is the arithmetic mean of the points in the layout.",
            "Paramters": {},
            "Return": [
                "the centroid as a list of floats"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Layout"
    },
    {
        "Field List > Methods > copy": {
            "Description": "Creates an exact copy of the layout.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Layout"
    },
    {
        "Field List > Methods > fit_into": {
            "Description": "Fits the layout into the given bounding box.\nThe layout will be modified in-place.",
            "Paramters": {
                "bbox": "the bounding box in which to fit the layout. If the dimension of the layout is d, it can either be a d-tuple (defining the sizes of the box), a 2d-tuple (defining the coordinates of the top left and the bottom right point of the box), or a BoundingBox object (for 2D layouts only).",
                "keep_aspect_ratio": "whether to keep the aspect ratio of the current layout. If False, the layout will be rescaled to fit exactly into the bounding box. If True, the original aspect ratio of the layout will be kept and it will be centered within the bounding box."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Layout"
    },
    {
        "Field List > Methods > mirror": {
            "Description": "Mirrors the layout along the given dimension(s)",
            "Paramters": {
                "dim": "the list of ensions or a single ension"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Layout"
    },
    {
        "Field List > Methods > rotate": {
            "Description": "Rotates the layout by the given degrees on the plane defined by the given two dimensions.",
            "Paramters": {
                "angle": "the  of the rotation, specified in degrees.",
                "dim1": "the first axis of the plane of the rotation.",
                "dim2": "the second axis of the plane of the rotation.",
                "origin": "the  of the rotation. If not specified, the  will be the  of the coordinate system."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Layout"
    },
    {
        "Field List > Methods > scale": {
            "Description": "Scales the layout.\nScaling parameters can be provided either through the scale keyword argument or through plain unnamed arguments. If a single integer or float is given, it is interpreted as a uniform multiplier to be applied on all dimensions. If it is a list or tuple, its length must be equal to the number of dimensions in the layout, and each element must be an integer or float describing the scaling coefficient in one of the dimensions.",
            "Paramters": {
                "*args": "Undocumented",
                "scale": "scaling coefficients (integer, float, list or tuple)",
                "origin": "the  of scaling (this point will stay in place). Optional, defaults to the  of the coordinate system being used."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Layout"
    },
    {
        "Field List > Methods > to_radial": {
            "Description": "Converts a planar layout to a radial one\nThis method applies only to 2D layouts. The X coordinate of the layout is transformed to an angle, with min(x) corresponding to the parameter called min_angle and max(y) corresponding to max_angle. Angles are given in degrees, zero degree corresponds to the direction pointing upwards. The Y coordinate is interpreted as a radius, with min(y) belonging to the minimum and max(y) to the maximum radius given in the arguments.\nThis is not a fully generic polar coordinate transformation, but it is fairly useful in creating radial tree layouts from ordinary top-down ones (that's why the Y coordinate belongs to the radius). It can also be used in conjunction with the Fruchterman-Reingold layout algorithm via its miny and maxy parameters (see Graph.layout_fruchterman_reingold()) to produce radial layouts where the radius belongs to some property of the vertices.",
            "Paramters": {
                "min_angle": "the angle corresponding to the minimum X value",
                "max_angle": "the angle corresponding to the maximum X value",
                "min_radius": "the radius corresponding to the minimum Y value",
                "max_radius": "the radius corresponding to the maximum Y value"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Layout"
    },
    {
        "Field List > Methods > transform": {
            "Description": "Performs an arbitrary transformation on the layout\nAdditional positional and keyword arguments are passed intact to the given function.",
            "Paramters": {
                "function": "a  which receives the coordinates as a tuple and returns the transformed tuple.",
                "*args": "Undocumented",
                "**kwds": "Undocumented"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Layout"
    },
    {
        "Field List > Methods > translate": {
            "Description": "Translates the layout.\nThe translation vector can be provided either through the v keyword argument or through plain unnamed arguments. If unnamed arguments are used, the vector can be supplied as a single list (or tuple) or just as a series of arguments. In all cases, the translation vector must have the same number of dimensions as the layout.",
            "Paramters": {
                "*args": "Undocumented",
                "v": "the translation ector"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Layout"
    },
    {
        "Field List > property": {
            "coords": "The coordinates as a list of lists\n",
            "dim": "Returns the number of dimensions\n"
        },
        "Section_id": "Layout"
    },
    {
        "Rubric": {
            "Example": [
                "Layouts behave exactly like lists when they are accessed using the item index operator ([...]). They can even be iterated through. Items returned by the index operator are only copies of the coordinates, but the stored coordinates can be modified by directly assigning to an index.\n>>> layout = Layout([(0, 1), (0, 2)])\n>>> coords = layout[1]\n>>> print(coords)\n[0, 2]\n>>> coords = (0, 3)\n>>> print(layout[1])\n[0, 2]\n>>> layout[1] = coords\n>>> print(layout[1])\n[0, 3]\n"
            ]
        },
        "Section_id": "Layout"
    },
    {
        "Section_id": "plotly",
        "Description": "Undocumented"
    },
    {
        "Section_id": "ProgressBar",
        "Description": "A 2-line progress bar.\n"
    },
    {
        "Field List > Methods > __init__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "ProgressBar"
    },
    {
        "Field List > Methods > clear": {
            "Description": "Clears the progress bar (i.e. removes it from the screen)",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "ProgressBar"
    },
    {
        "Field List > Methods > update": {
            "Description": "Updates the progress bar.",
            "Paramters": {
                "percent": "the age to be shown. If None, the previous value will be used.",
                "message": "the  to be shown above the progress bar. If None, the previous  will be used."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "ProgressBar"
    },
    {
        "Field List > Methods > update_message": {
            "Description": "Updates the message of the progress bar.",
            "Paramters": {
                "message": "the  to be shown above the progress bar"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "ProgressBar"
    },
    {
        "Field List > property": {},
        "Section_id": "ProgressBar"
    },
    {
        "Rubric": {
            "Example": [
                "The progress bar looks roughly like this in the console:\n                            Header\n    20% [===========----------------------------------]\n"
            ]
        },
        "Section_id": "ProgressBar"
    },
    {
        "Section_id": "BoundingBox",
        "Description": "Class representing a bounding box (a rectangular area) that encloses some objects."
    },
    {
        "Field List > Methods > __ior__": {
            "Description": "overrides igraph.drawing.utils.Rectangle.__ior__\nReplaces this bounding box with the union of itself and another.\nExample:",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": [
                "Example:\n    >>> box1 = BoundingBox(10, 20, 50, 60)\n    >>> box2 = BoundingBox(70, 40, 100, 90)\n    >>> box1 |= box2\n    >>> print(box1)\n    BoundingBox(10.0, 20.0, 100.0, 90.0)\n"
            ]
        },
        "Section_id": "BoundingBox"
    },
    {
        "Field List > Methods > __or__": {
            "Description": "Takes the union of this bounding box with another.\nThe result is a bounding box which encloses both bounding boxes.\nExample:",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": [
                "Example:\n    >>> box1 = BoundingBox(10, 20, 50, 60)\n    >>> box2 = BoundingBox(70, 40, 100, 90)\n    >>> box1 | box2\n    BoundingBox(10.0, 20.0, 100.0, 90.0)\n"
            ]
        },
        "Section_id": "BoundingBox"
    },
    {
        "Field List > Methods > __bool__": {
            "Description": "Inherited from Rectangle:Undocumented"
        },
        "Section_id": "BoundingBox"
    },
    {
        "Field List > Methods > __eq__": {
            "Description": "Inherited from Rectangle:Undocumented"
        },
        "Section_id": "BoundingBox"
    },
    {
        "Field List > Methods > __hash__": {
            "Description": "Inherited from Rectangle:Undocumented"
        },
        "Section_id": "BoundingBox"
    },
    {
        "Field List > Methods > __init__": {
            "Description": "Inherited from Rectangle:Creates a rectangle."
        },
        "Section_id": "BoundingBox"
    },
    {
        "Field List > Methods > __ne__": {
            "Description": "Inherited from Rectangle:Undocumented"
        },
        "Section_id": "BoundingBox"
    },
    {
        "Field List > Methods > __repr__": {
            "Description": "Inherited from Rectangle:Undocumented"
        },
        "Section_id": "BoundingBox"
    },
    {
        "Field List > Methods > bottom.setter": {
            "Description": "Inherited from Rectangle:Sets the Y coordinate of the bottom edge of the box"
        },
        "Section_id": "BoundingBox"
    },
    {
        "Field List > Methods > contract": {
            "Description": "Inherited from Rectangle:Contracts the rectangle by the given margins."
        },
        "Section_id": "BoundingBox"
    },
    {
        "Field List > Methods > coords.setter": {
            "Description": "Inherited from Rectangle:Sets the coordinates of the corners."
        },
        "Section_id": "BoundingBox"
    },
    {
        "Field List > Methods > expand": {
            "Description": "Inherited from Rectangle:Expands the rectangle by the given margins."
        },
        "Section_id": "BoundingBox"
    },
    {
        "Field List > Methods > height.setter": {
            "Description": "Inherited from Rectangle:Sets the height of the rectangle by adjusting the bottom edge."
        },
        "Section_id": "BoundingBox"
    },
    {
        "Field List > Methods > intersection": {
            "Description": "Inherited from Rectangle:Returns the intersection of this rectangle with another."
        },
        "Section_id": "BoundingBox"
    },
    {
        "Field List > Methods > isdisjoint": {
            "Description": "Inherited from Rectangle:Returns True if the two rectangles have no intersection."
        },
        "Section_id": "BoundingBox"
    },
    {
        "Field List > Methods > isempty": {
            "Description": "Inherited from Rectangle:Returns True if the rectangle is empty (i.e. it has zero width and height)."
        },
        "Section_id": "BoundingBox"
    },
    {
        "Field List > Methods > left.setter": {
            "Description": "Inherited from Rectangle:Sets the X coordinate of the left side of the box"
        },
        "Section_id": "BoundingBox"
    },
    {
        "Field List > Methods > midx.setter": {
            "Description": "Inherited from Rectangle:Moves the center of the box to the given X coordinate"
        },
        "Section_id": "BoundingBox"
    },
    {
        "Field List > Methods > midy.setter": {
            "Description": "Inherited from Rectangle:Moves the center of the box to the given Y coordinate"
        },
        "Section_id": "BoundingBox"
    },
    {
        "Field List > Methods > right.setter": {
            "Description": "Inherited from Rectangle:Sets the X coordinate of the right side of the box"
        },
        "Section_id": "BoundingBox"
    },
    {
        "Field List > Methods > shape.setter": {
            "Description": "Inherited from Rectangle:Sets the shape of the rectangle (width, height)."
        },
        "Section_id": "BoundingBox"
    },
    {
        "Field List > Methods > top.setter": {
            "Description": "Inherited from Rectangle:Sets the Y coordinate of the top edge of the box"
        },
        "Section_id": "BoundingBox"
    },
    {
        "Field List > Methods > translate": {
            "Description": "Inherited from Rectangle:Translates the rectangle in-place."
        },
        "Section_id": "BoundingBox"
    },
    {
        "Field List > Methods > union": {
            "Description": "Inherited from Rectangle:Returns the union of this rectangle with another."
        },
        "Section_id": "BoundingBox"
    },
    {
        "Field List > Methods > width.setter": {
            "Description": "Inherited from Rectangle:Sets the width of the rectangle by adjusting the right edge."
        },
        "Section_id": "BoundingBox"
    },
    {
        "Field List > property": {
            "bottom": "Inherited from Rectangle:The Y coordinate of the bottom edge of the box",
            "coords": "Inherited from Rectangle:The coordinates of the corners.",
            "left": "Inherited from Rectangle:The X coordinate of the left side of the box",
            "midx": "Inherited from Rectangle:The X coordinate of the center of the box",
            "midy": "Inherited from Rectangle:The Y coordinate of the center of the box",
            "right": "Inherited from Rectangle:The X coordinate of the right side of the box",
            "shape": "Inherited from Rectangle:The shape of the rectangle (width, height)",
            "top": "Inherited from Rectangle:The Y coordinate of the top edge of the box"
        },
        "Section_id": "BoundingBox"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "BoundingBox"
    },
    {
        "Section_id": "GephiGraphStreamingDrawer",
        "Description": "Graph drawer that sends a graph to a file-like object (e.g., socket, URL connection, file) using the Gephi graph streaming format.\nThe Gephi graph streaming format is a simple JSON-based format that can be used to post mutations to a graph (i.e. node and edge additions, removals and updates) to a remote component. For instance, one can open up Gephi (http://www.gephi.org), install the Gephi graph streaming plugin and then send a graph from igraph straight into the Gephi window by using GephiGraphStreamingDrawer with the appropriate URL where Gephi is listening.\nThe connection property exposes the GephiConnection that the drawer uses. The drawer also has a property called streamer which exposes the underlying GephiGraphStreamer that is responsible for generating the JSON objects, encoding them and writing them to a file-like object. If you want to customize the encoding process, this is the object where you can tweak things to your taste."
    },
    {
        "Field List > Methods > __init__": {
            "Description": "Constructs a Gephi graph streaming drawer that will post graphs to the given Gephi connection. If conn is None, the remaining arguments of the constructor are forwarded intact to the constructor of GephiConnection in order to create a connection. This means that any of the following are valid:GephiGraphStreamingDrawer() will construct a drawer that connects to workspace 0 of the local Gephi instance on port 8080.GephiGraphStreamingDrawer(workspace=2) will connect to workspace 2 of the local Gephi instance on port 8080.GephiGraphStreamingDrawer(port=1234) will connect to workspace 0 of the local Gephi instance on port 1234.GephiGraphStreamingDrawer(host=\"remote\", port=1234, workspace=7) will connect to workspace 7 of the Gephi instance on host remote, port 1234.GephiGraphStreamingDrawer(url=\"http://remote:1234/workspace7) is the same as above, but with an explicit URL.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GephiGraphStreamingDrawer"
    },
    {
        "Field List > Methods > draw": {
            "Description": "overrides igraph.drawing.baseclasses.AbstractGraphDrawer.draw\nDraws (i.e. sends) the given graph to the destination of the drawer using the Gephi graph streaming API.\nThe following keyword arguments are allowed:encoder lets one specify an instance of json.JSONEncoder that will be used to encode the JSON objects.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GephiGraphStreamingDrawer"
    },
    {
        "Field List > property": {},
        "Section_id": "GephiGraphStreamingDrawer"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "GephiGraphStreamingDrawer"
    },
    {
        "Section_id": "_layout_mapping",
        "Description": "Undocumented"
    },
    {
        "Section_id": "VertexCover",
        "Description": "The cover of the vertex set of a graph.\nThis class extends Cover by linking it to a specific Graph object. It also provides some handy methods like getting the subgraph corresponding to a cluster and such.Notesince this class is linked to a Graph, destroying the graph by the del operator does not free the memory occupied by the graph if there exists a VertexCover that references the Graph."
    },
    {
        "Field List > Methods > __init__": {
            "Description": "overrides igraph.Cover.__init__\nCreates a cover object for a given graph.",
            "Paramters": {
                "graph": "the  that will be associated to the cover",
                "clusters": "the list of . If None, it is assumed that there is only a single cluster that covers the whole graph."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "VertexCover"
    },
    {
        "Field List > Methods > __plot__": {
            "Description": "overridden in igraph.CohesiveBlocks\nPlots the cover to the given Cairo context or matplotlib Axes.\nThis is done by calling Graph.__plot__() with the same arguments, but drawing nice colored blobs around the vertex groups.\nThis method understands all the positional and keyword arguments that are understood by Graph.__plot__(), only the differences will be highlighted here:mark_groups: whether to highlight the vertex clusters by colored polygons. Besides the values accepted by Graph.__plot__ (i.e., a dict mapping colors to vertex indices, a list containing lists of vertex indices, or False), the following are also accepted:True: all the clusters will be highlighted, the colors matching the corresponding color indices from the current palette (see the palette keyword argument of Graph.__plot__).A dict mapping cluster indices or tuples of vertex indices to color names.  The given clusters or vertex groups will be highlighted by the given colors.A list of cluster indices. This is equivalent to passing a dict mapping numeric color indices from the current palette to cluster indices; therefore, the cluster referred to by element i of the list will be highlighted by color i from the palette.The value of the plotting.mark_groups configuration key is also taken into account here; if that configuration key is True and mark_groups is not given explicitly, it will automatically be set to True.In place of lists of vertex indices, you may also use VertexSeq instances.In place of color names, you may also use color indices into the current palette. None as a color name will mean that the corresponding group is ignored.palette: the palette used to resolve numeric color indices to RGBA values. By default, this is an instance of ClusterColoringPalette.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "Graph.__plot__() for more supported keyword arguments.",
            "example": []
        },
        "Section_id": "VertexCover"
    },
    {
        "Field List > Methods > crossing": {
            "Description": "Returns a boolean vector where element i is True iff edge i lies between clusters, False otherwise.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "VertexCover"
    },
    {
        "Field List > Methods > subgraph": {
            "Description": "Get the subgraph belonging to a given cluster.\nPrecondition: the vertex set of the graph hasn't been modified since the moment the cover was constructed.",
            "Paramters": {
                "idx": "the cluster index"
            },
            "Return": [
                "a copy of the subgraph"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "VertexCover"
    },
    {
        "Field List > Methods > subgraphs": {
            "Description": "Gets all the subgraphs belonging to each of the clusters.\nPrecondition: the vertex set of the graph hasn't been modified since the moment the cover was constructed.",
            "Paramters": {},
            "Return": [
                "a list containing copies of the subgraphs"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "VertexCover"
    },
    {
        "Field List > Methods > __getitem__": {
            "Description": "Inherited from Cover:Returns the cluster with the given index."
        },
        "Section_id": "VertexCover"
    },
    {
        "Field List > Methods > __iter__": {
            "Description": "Inherited from Cover:Iterates over the clusters in this cover."
        },
        "Section_id": "VertexCover"
    },
    {
        "Field List > Methods > __len__": {
            "Description": "Inherited from Cover:Returns the number of clusters in this cover."
        },
        "Section_id": "VertexCover"
    },
    {
        "Field List > Methods > __str__": {
            "Description": "Inherited from Cover:Returns a string representation of the cover."
        },
        "Section_id": "VertexCover"
    },
    {
        "Field List > Methods > size": {
            "Description": "Inherited from Cover:Returns the size of a given cluster."
        },
        "Section_id": "VertexCover"
    },
    {
        "Field List > Methods > size_histogram": {
            "Description": "Inherited from Cover:Returns the histogram of cluster sizes."
        },
        "Section_id": "VertexCover"
    },
    {
        "Field List > Methods > sizes": {
            "Description": "Inherited from Cover:Returns the size of given clusters."
        },
        "Section_id": "VertexCover"
    },
    {
        "Field List > Methods > summary": {
            "Description": "Inherited from Cover:Returns the summary of the cover."
        },
        "Section_id": "VertexCover"
    },
    {
        "Field List > property": {
            "graph": "Returns the graph belonging to this object\n",
            "membership": "Inherited from Cover:Returns the membership vector of this cover.",
            "n": "Inherited from Cover:Returns the number of elements in the set covered by this cover."
        },
        "Section_id": "VertexCover"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "VertexCover"
    },
    {
        "Section_id": "Point",
        "Description": "Class representing a point on the 2D plane."
    },
    {
        "Field List > Methods > FromPolar": {
            "Description": "Constructs a point from polar coordinates.\nradius is the distance of the point from the origin; angle is the angle between the X axis and the vector pointing to the point from the origin.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Point"
    },
    {
        "Field List > Methods > __add__": {
            "Description": "Adds the coordinates of a point to another one",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Point"
    },
    {
        "Field List > Methods > __div__": {
            "Description": "Divides the coordinates by a scalar",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Point"
    },
    {
        "Field List > Methods > __mul__": {
            "Description": "Multiplies the coordinates by a scalar",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Point"
    },
    {
        "Field List > Methods > __sub__": {
            "Description": "Subtracts the coordinates of a point to another one",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Point"
    },
    {
        "Field List > Methods > as_polar": {
            "Description": "Returns the polar coordinate representation of the point.",
            "Paramters": {},
            "Return": [
                "the radius and the angle in a tuple."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Point"
    },
    {
        "Field List > Methods > distance": {
            "Description": "Returns the distance of the point from another one.\nExample:",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": [
                "Example:\n>>> p1 = Point(5, 7)\n>>> p2 = Point(8, 3)\n>>> p1.distance(p2)\n5.0\n"
            ]
        },
        "Section_id": "Point"
    },
    {
        "Field List > Methods > interpolate": {
            "Description": "Linearly interpolates between the coordinates of this point and another one.",
            "Paramters": {
                "other": "the  point",
                "ratio": "the interpolation  between 0 and 1. Zero will return this point, 1 will return the other point."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Point"
    },
    {
        "Field List > Methods > length": {
            "Description": "Returns the length of the vector pointing from the origin to this point.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Point"
    },
    {
        "Field List > Methods > normalized": {
            "Description": "Normalizes the coordinates of the point s.t. its length will be 1 after normalization. Returns the normalized point.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Point"
    },
    {
        "Field List > Methods > sq_length": {
            "Description": "Returns the squared length of the vector pointing from the origin to this point.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Point"
    },
    {
        "Field List > Methods > towards": {
            "Description": "Returns the point that is at a given distance from this point towards another one.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Point"
    },
    {
        "Field List > property": {},
        "Section_id": "Point"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "Point"
    },
    {
        "Section_id": "AlphaVaryingEdgeDrawer",
        "Description": "Edge drawer implementation that draws undirected edges as straight lines and directed edges by varying the alpha value of the specified edge color between the source and the destination."
    },
    {
        "Field List > Methods > __init__": {
            "Description": "overrides igraph.drawing.cairo.edge.AbstractCairoEdgeDrawer.__init__\nConstructs the edge drawer.",
            "Paramters": {
                "context": "a Cairo  on which the edges will be drawn.",
                "palette": "the  that can be used to map integer color indices to colors when drawing edges",
                "alpha_at_src": "Undocumented",
                "alpha_at_dest": "Undocumented"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "AlphaVaryingEdgeDrawer"
    },
    {
        "Field List > Methods > draw_directed_edge": {
            "Description": "overrides igraph.drawing.baseclasses.AbstractEdgeDrawer.draw_directed_edge\nDraws a directed edge.",
            "Paramters": {
                "edge": "the  to be drawn. Visual properties of the  are defined by the attributes of this object.",
                "src_vertex": "the source vertex. Visual properties are defined by the attributes of this object.",
                "dest_vertex": "the source vertex. Visual properties are defined by the attributes of this object."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "AlphaVaryingEdgeDrawer"
    },
    {
        "Field List > Methods > draw_loop_edge": {
            "Description": "Inherited from AbstractCairoEdgeDrawer:Draws a loop edge."
        },
        "Section_id": "AlphaVaryingEdgeDrawer"
    },
    {
        "Field List > Methods > draw_undirected_edge": {
            "Description": "Inherited from AbstractCairoEdgeDrawer:Draws an undirected edge."
        },
        "Section_id": "AlphaVaryingEdgeDrawer"
    },
    {
        "Field List > property": {},
        "Section_id": "AlphaVaryingEdgeDrawer"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "AlphaVaryingEdgeDrawer"
    },
    {
        "Section_id": "CairoPaletteDrawer",
        "Description": "Default Cairo drawer object for palettes"
    },
    {
        "Field List > Methods > __init__": {
            "Description": "overrides igraph.drawing.cairo.base.AbstractCairoDrawer.__init__\nConstructs the vertex drawer and associates it to the given palette.",
            "Paramters": {
                "context": "the  on which we will draw"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "CairoPaletteDrawer"
    },
    {
        "Field List > Methods > draw": {
            "Description": "overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nTODO",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "CairoPaletteDrawer"
    },
    {
        "Field List > Methods > bbox.setter": {
            "Description": "Inherited from AbstractCairoDrawer:Sets the bounding box of the drawing area where this drawer will draw."
        },
        "Section_id": "CairoPaletteDrawer"
    },
    {
        "Field List > property": {},
        "Section_id": "CairoPaletteDrawer"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "CairoPaletteDrawer"
    },
    {
        "Section_id": "CairoHistogramDrawer",
        "Description": "Default Cairo drawer object for histograms"
    },
    {
        "Field List > Methods > __init__": {
            "Description": "overrides igraph.drawing.cairo.base.AbstractCairoDrawer.__init__\nConstructs the vertex drawer and associates it to the given palette.",
            "Paramters": {
                "context": "the  on which we will draw"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "CairoHistogramDrawer"
    },
    {
        "Field List > Methods > draw": {
            "Description": "overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nTODO",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "CairoHistogramDrawer"
    },
    {
        "Field List > Methods > bbox.setter": {
            "Description": "Inherited from AbstractCairoDrawer:Sets the bounding box of the drawing area where this drawer will draw."
        },
        "Section_id": "CairoHistogramDrawer"
    },
    {
        "Field List > property": {},
        "Section_id": "CairoHistogramDrawer"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "CairoHistogramDrawer"
    },
    {
        "Section_id": "safe_locale",
        "Description": "Helper function that establishes a context that temporarily switches the current locale to use decimal dots when printing numbers.\nThis can be used to establish an execution context within which it is safe to call functions that read or write graphs from/to the disk and ensure that they use decimal dots for interoperability with systems that are running with another locale."
    },
    {
        "Paramters": {},
        "Section_id": "safe_locale"
    },
    {
        "Raises": {},
        "Section_id": "safe_locale"
    },
    {
        "Section_id": "safe_locale",
        "See Also": ""
    },
    {
        "Section_id": "find_cairo",
        "Description": "Tries to import the cairo Python module if it is installed,also trying cairocffi (a drop-in replacement of cairo).Returns a fake module if everything fails."
    },
    {
        "Paramters": {},
        "Section_id": "find_cairo"
    },
    {
        "Raises": {},
        "Section_id": "find_cairo"
    },
    {
        "Section_id": "find_cairo",
        "See Also": ""
    },
    {
        "Section_id": "IDLEShell",
        "Description": "IDLE embedded shell interface.\nThis class allows igraph to be embedded in IDLE (the Tk Python IDE)."
    },
    {
        "Field List > Methods > __call__": {
            "Description": "overrides igraph.app.shell.Shell.__call__\nStarts the shell",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "IDLEShell"
    },
    {
        "Field List > Methods > __init__": {
            "Description": "Constructor.\nImports IDLE's embedded shell. The implementation of this method is ripped from idlelib.PyShell.main() after removing the unnecessary parts.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "IDLEShell"
    },
    {
        "Field List > Methods > get_progress_handler": {
            "Description": "Inherited from Shell:Returns the progress handler (if exists) or None (if not)."
        },
        "Section_id": "IDLEShell"
    },
    {
        "Field List > Methods > get_status_handler": {
            "Description": "Inherited from Shell:Returns the status handler (if exists) or None (if not)."
        },
        "Section_id": "IDLEShell"
    },
    {
        "Field List > Methods > supports_progress_bar": {
            "Description": "Inherited from Shell:Checks whether the shell supports progress bars."
        },
        "Section_id": "IDLEShell"
    },
    {
        "Field List > Methods > supports_status_messages": {
            "Description": "Inherited from Shell:Checks whether the shell supports status messages."
        },
        "Section_id": "IDLEShell"
    },
    {
        "Field List > property": {},
        "Section_id": "IDLEShell"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "IDLEShell"
    },
    {
        "Section_id": "DescartesCoordinateSystem",
        "Description": "Class implementing a 2D Descartes coordinate system object."
    },
    {
        "Field List > Methods > __init__": {
            "Description": "overrides igraph.drawing.cairo.base.AbstractCairoDrawer.__init__\nInitializes the coordinate system.",
            "Paramters": {
                "context": "the  on which the coordinate system will be drawn.",
                "bbox": "the bounding box that will contain the coordinate system.",
                "bounds": "minimum and maximum X and Y values in a 4-tuple."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "DescartesCoordinateSystem"
    },
    {
        "Field List > Methods > bbox": {
            "Description": "overrides igraph.drawing.cairo.base.AbstractCairoDrawer.bbox.setter\nSets the bounding box of the coordinate system",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "DescartesCoordinateSystem"
    },
    {
        "Field List > Methods > bounds": {
            "Description": "Sets the lower and upper bounds of the X and Y values",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "DescartesCoordinateSystem"
    },
    {
        "Field List > Methods > draw": {
            "Description": "overrides igraph.drawing.cairo.coord.CoordinateSystem.draw\nDraws the coordinate system.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "DescartesCoordinateSystem"
    },
    {
        "Field List > Methods > local_to_context": {
            "Description": "overrides igraph.drawing.cairo.coord.CoordinateSystem.local_to_context\nConverts local coordinates to the context coordinate system (given by the bounding box).",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "DescartesCoordinateSystem"
    },
    {
        "Field List > property": {
            "bbox": "overrides igraph.drawing.cairo.base.AbstractCairoDrawer.bbox\nReturns the bounding box of the coordinate system\n",
            "bounds": "Returns the lower and upper bounds of the X and Y values\n"
        },
        "Section_id": "DescartesCoordinateSystem"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "DescartesCoordinateSystem"
    },
    {
        "Section_id": "VertexDendrogram",
        "Description": "The dendrogram resulting from the hierarchical clustering of the vertex set of a graph."
    },
    {
        "Field List > Methods > __init__": {
            "Description": "overrides igraph.Dendrogram.__init__\nCreates a dendrogram object for a given graph.",
            "Paramters": {
                "graph": "the  that will be associated to the clustering",
                "merges": "the  performed given in matrix form.",
                "optimal_count": "the optimal number of clusters where the dendrogram should be cut. This is a hint usually provided by the clustering algorithm that produces the dendrogram. None means that such a hint is not available; the optimal count will then be selected based on the modularity in such a case.",
                "modularity_params": "arguments that should be passed to Graph.modularity when the modularity is (re)calculated. If the original graph was weighted, you should pass a dictionary containing a weight key with the appropriate value here."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "VertexDendrogram"
    },
    {
        "Field List > Methods > __plot__": {
            "Description": "overrides igraph.Dendrogram.__plot__\nDraws the vertex dendrogram on the given Cairo context or matplotlib Axes\nSee Dendrogram.__plot__ for the list of supported keyword arguments.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "VertexDendrogram"
    },
    {
        "Field List > Methods > as_clustering": {
            "Description": "Cuts the dendrogram at the given level and returns a corresponding VertexClustering object.",
            "Paramters": {
                "n": "the desired umber of clusters. Merges are replayed from the begiig util the membership vector has exactly  distict elemets or util there are o more recorded merges, whichever happes first. If Noe, the optimal cout hit give by the clusterig algorithm will be used If the optimal cout was ot give either, it will be calculated by selectig the level where the modularity is maximal."
            },
            "Return": [
                "a new VertexClustering object."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "VertexDendrogram"
    },
    {
        "Field List > Methods > optimal_count": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "VertexDendrogram"
    },
    {
        "Field List > Methods > __str__": {
            "Description": "Inherited from Dendrogram:Undocumented"
        },
        "Section_id": "VertexDendrogram"
    },
    {
        "Field List > Methods > format": {
            "Description": "Inherited from Dendrogram:Formats the dendrogram in a foreign format."
        },
        "Section_id": "VertexDendrogram"
    },
    {
        "Field List > Methods > names.setter": {
            "Description": "Inherited from Dendrogram:Sets the names of the nodes in the dendrogram"
        },
        "Section_id": "VertexDendrogram"
    },
    {
        "Field List > Methods > summary": {
            "Description": "Inherited from Dendrogram:Returns the summary of the dendrogram."
        },
        "Section_id": "VertexDendrogram"
    },
    {
        "Field List > property": {
            "optimal_count": "Returns the optimal number of clusters for this dendrogram.\nIf an optimal count hint was given at construction time, this property simply returns the hint. If such a count was not given, this method calculates the optimal number of clusters by maximizing the modularity along all the possible cuts in the dendrogram.\n\n",
            "merges": "Inherited from Dendrogram:Returns the performed merges in matrix format",
            "names": "Inherited from Dendrogram:Returns the names of the nodes in the dendrogram"
        },
        "Section_id": "VertexDendrogram"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "VertexDendrogram"
    },
    {
        "Section_id": "GephiGraphStreamingAPIFormat",
        "Description": "Object that implements the Gephi graph streaming API format and returns Python objects corresponding to the events defined in the API."
    },
    {
        "Field List > Methods > get_add_edge_event": {
            "Description": "Generates a Python object corresponding to the event that adds an edgewith the given source, target, directednessr and attributes in the Gephigraph streaming API.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "GephiGraphStreamingAPIFormat"
    },
    {
        "Field List > Methods > get_add_node_event": {
            "Description": "Generates a Python object corresponding to the event that adds a nodewith the given identifier and attributes in the Gephi graph streaming API.\nExample:",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": [
                "Example:\n>>> api = GephiGraphStreamingAPIFormat()\n>>> api.get_add_node_event(\"spam\")\n{'an': {'spam': {}}}\n>>> api.get_add_node_event(\"spam\", dict(ham=\"eggs\"))\n{'an': {'spam': {'ham': 'eggs'}}}\n"
            ]
        },
        "Section_id": "GephiGraphStreamingAPIFormat"
    },
    {
        "Field List > Methods > get_change_edge_event": {
            "Description": "Generates a Python object corresponding to the event that changes theattributes of some edge in the Gephi graph streaming API. The given attributesare merged into the existing ones; use C{None} as the attribute value todelete a given attribute.\nExample:",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": [
                "Example:\n>>> api = GephiGraphStreamingAPIFormat()\n>>> api.get_change_edge_event(\"spam\", dict(ham=\"eggs\"))\n{'ce': {'spam': {'ham': 'eggs'}}}\n>>> api.get_change_edge_event(\"spam\", dict(ham=None))\n{'ce': {'spam': {'ham': None}}}\n"
            ]
        },
        "Section_id": "GephiGraphStreamingAPIFormat"
    },
    {
        "Field List > Methods > get_change_node_event": {
            "Description": "Generates a Python object corresponding to the event that changes theattributes of some node in the Gephi graph streaming API. The given attributesare merged into the existing ones; use C{None} as the attribute value todelete a given attribute.\nExample:",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": [
                "Example:\n>>> api = GephiGraphStreamingAPIFormat()\n>>> api.get_change_node_event(\"spam\", dict(ham=\"eggs\"))\n{'cn': {'spam': {'ham': 'eggs'}}}\n>>> api.get_change_node_event(\"spam\", dict(ham=None))\n{'cn': {'spam': {'ham': None}}}\n"
            ]
        },
        "Section_id": "GephiGraphStreamingAPIFormat"
    },
    {
        "Field List > Methods > get_delete_edge_event": {
            "Description": "Generates a Python object corresponding to the event that deletes anedge with the given identifier in the Gephi graph streaming API.\nExample:",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": [
                "Example:\n>>> api = GephiGraphStreamingAPIFormat()\n>>> api.get_delete_edge_event(\"spam:ham\")\n{'de': {'spam:ham': {}}}\n"
            ]
        },
        "Section_id": "GephiGraphStreamingAPIFormat"
    },
    {
        "Field List > Methods > get_delete_node_event": {
            "Description": "Generates a Python object corresponding to the event that deletes anode with the given identifier in the Gephi graph streaming API.\nExample:",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": [
                "Example:\n>>> api = GephiGraphStreamingAPIFormat()\n>>> api.get_delete_node_event(\"spam\")\n{'dn': {'spam': {}}}\n"
            ]
        },
        "Section_id": "GephiGraphStreamingAPIFormat"
    },
    {
        "Field List > property": {},
        "Section_id": "GephiGraphStreamingAPIFormat"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "GephiGraphStreamingAPIFormat"
    },
    {
        "Section_id": "AbstractCairoEdgeDrawer",
        "Description": "Cairo-specific abstract edge drawer object."
    },
    {
        "Field List > Methods > __init__": {
            "Description": "overridden in igraph.drawing.cairo.edge.AlphaVaryingEdgeDrawer\nConstructs the edge drawer.",
            "Paramters": {
                "context": "a Cairo  on which the edges will be drawn.",
                "palette": "the  that can be used to map integer color indices to colors when drawing edges"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "AbstractCairoEdgeDrawer"
    },
    {
        "Field List > Methods > draw_loop_edge": {
            "Description": "Draws a loop edge.\nThe default implementation draws a small circle.",
            "Paramters": {
                "edge": "the  to be drawn. Visual properties of the  are defined by the attributes of this object.",
                "vertex": "the  to which the edge is attached. Visual properties are given again as attributes."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "AbstractCairoEdgeDrawer"
    },
    {
        "Field List > Methods > draw_undirected_edge": {
            "Description": "overrides igraph.drawing.baseclasses.AbstractEdgeDrawer.draw_undirected_edge\nDraws an undirected edge.\nThe default implementation of this method draws undirected edges as straight lines. Loop edges are drawn as small circles.",
            "Paramters": {
                "edge": "the  to be drawn. Visual properties of the  are defined by the attributes of this object.",
                "src_vertex": "the source vertex. Visual properties are given again as attributes.",
                "dest_vertex": "the target vertex. Visual properties are given again as attributes."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "AbstractCairoEdgeDrawer"
    },
    {
        "Field List > Methods > draw_directed_edge": {
            "Description": "Inherited from AbstractEdgeDrawer:Draws a directed edge."
        },
        "Section_id": "AbstractCairoEdgeDrawer"
    },
    {
        "Field List > Methods > get_label_position": {
            "Description": "Inherited from AbstractEdgeDrawer:Returns the position where the label of an edge should be drawn. the default implementation returns the midpoint of the edge and an alignment that tries to avoid overlapping the label with the edge."
        },
        "Section_id": "AbstractCairoEdgeDrawer"
    },
    {
        "Field List > Methods > get_label_rotation": {
            "Description": "Inherited from AbstractEdgeDrawer:Get the rotation angle of the label to align with the edge."
        },
        "Section_id": "AbstractCairoEdgeDrawer"
    },
    {
        "Field List > property": {},
        "Section_id": "AbstractCairoEdgeDrawer"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "AbstractCairoEdgeDrawer"
    },
    {
        "Section_id": "PrecalculatedPalette",
        "Description": "A palette that returns colors from a pre-calculated list of colors"
    },
    {
        "Field List > Methods > __init__": {
            "Description": "overrides igraph.drawing.colors.Palette.__init__\nCreates the palette backed by the given list. The list must contain RGBA quadruplets or color names, which will be resolved first by color_name_to_rgba(). Anything that is understood by color_name_to_rgba() is OK here.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "PrecalculatedPalette"
    },
    {
        "Field List > Methods > __len__": {
            "Description": "Inherited from Palette:Returns the number of colors in this palette"
        },
        "Section_id": "PrecalculatedPalette"
    },
    {
        "Field List > Methods > __plot__": {
            "Description": "Inherited from Palette:Plots the colors of the palette on the given Cairo context/mpl Axes"
        },
        "Section_id": "PrecalculatedPalette"
    },
    {
        "Field List > Methods > __repr__": {
            "Description": "Inherited from Palette:Undocumented"
        },
        "Section_id": "PrecalculatedPalette"
    },
    {
        "Field List > Methods > clear_cache": {
            "Description": "Inherited from Palette:Clears the result cache."
        },
        "Section_id": "PrecalculatedPalette"
    },
    {
        "Field List > Methods > get": {
            "Description": "Inherited from Palette:Returns the given color from the palette."
        },
        "Section_id": "PrecalculatedPalette"
    },
    {
        "Field List > Methods > get_many": {
            "Description": "Inherited from Palette:Returns multiple colors from the palette."
        },
        "Section_id": "PrecalculatedPalette"
    },
    {
        "Field List > property": {
            "length": "Inherited from Palette:Returns the number of colors in this palette"
        },
        "Section_id": "PrecalculatedPalette"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "PrecalculatedPalette"
    },
    {
        "Section_id": "FittedPowerLaw",
        "Description": "Result of fitting a power-law to a vector of samples\n"
    },
    {
        "Field List > Methods > __init__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "FittedPowerLaw"
    },
    {
        "Field List > Methods > __repr__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "FittedPowerLaw"
    },
    {
        "Field List > Methods > __str__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "FittedPowerLaw"
    },
    {
        "Field List > Methods > summary": {
            "Description": "Returns the summary of the power law fit.",
            "Paramters": {
                "significance": "the  level of the Kolmogorov-Smirnov test used to decide whether the input data could have come from the fitted distribution"
            },
            "Return": [
                "the summary as a string"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "FittedPowerLaw"
    },
    {
        "Field List > property": {},
        "Section_id": "FittedPowerLaw"
    },
    {
        "Rubric": {
            "Example": [
                "Example:\n>>> result = power_law_fit([1, 2, 3, 4, 5, 6])\n>>> result                   # doctest:+ELLIPSIS\nFittedPowerLaw(continuous=False, alpha=2.42..., xmin=3.0, L=-7.54..., D=0.21..., p=0.993...)\n>>> print(result)            # doctest:+ELLIPSIS\nFitted power-law distribution on discrete data\n<BLANKLINE>\nExponent (alpha)  = 2.42...\nCutoff (xmin)     = 3.000000\n<BLANKLINE>\nLog-likelihood    = -7.54...\n<BLANKLINE>\nH0: data was drawn from the fitted distribution\n<BLANKLINE>\nKS test statistic = 0.21...\np-value           = 0.993...\n<BLANKLINE>\nH0 could not be rejected at significance level 0.05\n>>> result.alpha             # doctest:+ELLIPSIS\n2.42...\n>>> result.xmin\n3.0\n>>> result.continuous\nFalse\n"
            ]
        },
        "Section_id": "FittedPowerLaw"
    },
    {
        "Section_id": "plotly",
        "Description": "Undocumented"
    },
    {
        "Section_id": "cairo",
        "Description": "Undocumented"
    },
    {
        "Section_id": "DyadCensus",
        "Description": "Dyad census of a graph.\nThis is a pretty simple class - basically it is a tuple, but it allows the user to refer to its individual items by the names mutual (or mut), asymmetric (or asy or asym or asymm) and null.\n"
    },
    {
        "Field List > Methods > __getattr__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "DyadCensus"
    },
    {
        "Field List > Methods > __getitem__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "DyadCensus"
    },
    {
        "Field List > Methods > __repr__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "DyadCensus"
    },
    {
        "Field List > Methods > __str__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "DyadCensus"
    },
    {
        "Field List > Methods > as_dict": {
            "Description": "Converts the dyad census to a dict using the known dyad names.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "DyadCensus"
    },
    {
        "Field List > property": {},
        "Section_id": "DyadCensus"
    },
    {
        "Rubric": {
            "Example": [
                "Examples:\n>>> from igraph import Graph\n>>> g=Graph.Erdos_Renyi(100, 0.2, directed=True)\n>>> dc=g.dyad_census()\n>>> print(dc.mutual)            #doctest:+SKIP\n179\n>>> print(dc[\"asym\"])           #doctest:+SKIP\n1609\n>>> print(tuple(dc), list(dc))  #doctest:+SKIP\n(179, 1609, 3162) [179, 1609, 3162]\n>>> print(sorted(dc.as_dict().items()))  #doctest:+ELLIPSIS\n[('asymmetric', ...), ('mutual', ...), ('null', ...)]\n"
            ]
        },
        "Section_id": "DyadCensus"
    },
    {
        "Section_id": "MatplotlibGraphDrawer",
        "Description": "Graph drawer that uses a pyplot.Axes as context"
    },
    {
        "Field List > Methods > __init__": {
            "Description": "Constructs the graph drawer and associates it with the mpl Axes",
            "Paramters": {
                "ax": "the matplotlib Axes to draw into.",
                "vertex_drawer_factory": "a factory method that returns an AbstractVertexDrawer instance bound to the given Matplotlib axes. The factory method must take three parameters: the axes and the palette to be used for drawing colored vertices, and the layout of the graph. The default vertex drawer is MatplotlibVertexDrawer.",
                "edge_drawer_factory": "a factory method that returns an AbstractEdgeDrawer instance bound to a given Matplotlib Axes. The factory method must take two parameters: the Axes and the palette to be used for drawing colored edges. The default edge drawer is MatplotlibEdgeDrawer."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "MatplotlibGraphDrawer"
    },
    {
        "Field List > Methods > draw": {
            "Description": "overrides igraph.drawing.baseclasses.AbstractGraphDrawer.draw\nAbstract method, must be implemented in derived classes.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "MatplotlibGraphDrawer"
    },
    {
        "Field List > property": {},
        "Section_id": "MatplotlibGraphDrawer"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "MatplotlibGraphDrawer"
    },
    {
        "Section_id": "UniqueIdGenerator",
        "Description": "A dictionary-like class that can be used to assign unique IDs to names (say, vertex names).\n"
    },
    {
        "Field List > Methods > __contains__": {
            "Description": "Checks whether item already has an ID or not.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "UniqueIdGenerator"
    },
    {
        "Field List > Methods > __getitem__": {
            "Description": "Retrieves the ID corresponding to item. Generates a new ID for item if it is the first time we request an ID for it.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "UniqueIdGenerator"
    },
    {
        "Field List > Methods > __init__": {
            "Description": "Creates a new unique ID generator. id_generator specifies how do we assign new IDs to elements that do not have an ID yet. If it is None, elements will be assigned integer identifiers starting from 0. If it is an integer, elements will be assigned identifiers starting from the given integer. If it is an iterator or generator, its next() method will be called every time a new ID is needed.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "UniqueIdGenerator"
    },
    {
        "Field List > Methods > __len__": {
            "Description": "Returns the number of items.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "UniqueIdGenerator"
    },
    {
        "Field List > Methods > __setitem__": {
            "Description": "Overrides the ID for item.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "UniqueIdGenerator"
    },
    {
        "Field List > Methods > reverse_dict": {
            "Description": "Returns the reverse mapping, i.e., the one that maps from generated IDs to their corresponding objects",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "UniqueIdGenerator"
    },
    {
        "Field List > Methods > values": {
            "Description": "Returns the values stored so far. If the generator generates items according to the standard sorting order, the values returned will be exactly in the order they were added. This holds for integer IDs for instance (but for many other ID generators as well).",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "UniqueIdGenerator"
    },
    {
        "Field List > property": {},
        "Section_id": "UniqueIdGenerator"
    },
    {
        "Rubric": {
            "Example": [
                "Usage:\n>>> gen = UniqueIdGenerator()\n>>> gen[\"A\"]\n0\n>>> gen[\"B\"]\n1\n>>> gen[\"C\"]\n2\n>>> gen[\"A\"]      # Retrieving already existing ID\n0\n>>> gen.add(\"D\")  # Synonym of gen[\"D\"]\n3\n>>> len(gen)      # Number of already used IDs\n4\n>>> \"C\" in gen\nTrue\n>>> \"E\" in gen\nFalse\n"
            ]
        },
        "Section_id": "UniqueIdGenerator"
    },
    {
        "Section_id": "DiamondDrawer",
        "Description": "Static class which draws diamonds (i.e. rhombuses)"
    },
    {
        "Field List > Methods > draw_path": {
            "Description": "overrides igraph.drawing.shapes.ShapeDrawer.draw_path\nDraws a rhombus on the Cairo context without stroking or filling it.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "ShapeDrawer.draw_path",
            "example": []
        },
        "Section_id": "DiamondDrawer"
    },
    {
        "Field List > Methods > intersection_point": {
            "Description": "overrides igraph.drawing.shapes.ShapeDrawer.intersection_point\nDetermines where the rhombus centered at (center_x, center_y) intersects with a line drawn from (source_x, source_y) to (center_x, center_y).",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "ShapeDrawer.intersection_point",
            "example": []
        },
        "Section_id": "DiamondDrawer"
    },
    {
        "Field List > property": {},
        "Section_id": "DiamondDrawer"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "DiamondDrawer"
    },
    {
        "Section_id": "ConsoleProgressBarMixin",
        "Description": "Mixin class for console shells that support a progress bar."
    },
    {
        "Field List > Methods > __init__": {
            "Description": "overridden in igraph.app.shell.ClassicPythonShell, igraph.app.shell.IPythonShell\nUndocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "ConsoleProgressBarMixin"
    },
    {
        "Field List > property": {},
        "Section_id": "ConsoleProgressBarMixin"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "ConsoleProgressBarMixin"
    },
    {
        "Section_id": "CircleDrawer",
        "Description": "Static class which draws circular vertices"
    },
    {
        "Field List > Methods > draw_path": {
            "Description": "overrides igraph.drawing.shapes.ShapeDrawer.draw_path\nDraws a circular path on the Cairo context without stroking or filling it.\nHeight is ignored, it is the width that determines the diameter of the circle.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "ShapeDrawer.draw_path",
            "example": []
        },
        "Section_id": "CircleDrawer"
    },
    {
        "Field List > Methods > intersection_point": {
            "Description": "overrides igraph.drawing.shapes.ShapeDrawer.intersection_point\nDetermines where the circle centered at (center_x, center_y) intersects with a line drawn from (source_x, source_y) to (center_x, center_y).",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "ShapeDrawer.intersection_point",
            "example": []
        },
        "Section_id": "CircleDrawer"
    },
    {
        "Field List > property": {},
        "Section_id": "CircleDrawer"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "CircleDrawer"
    },
    {
        "Section_id": "plotly",
        "Description": "Undocumented"
    },
    {
        "Section_id": "PlotlyPolygonDrawer",
        "Description": "Class that is used to draw polygons in matplotlib.\nThe corner points of the polygon can be set by the points property of the drawer, or passed at construction time. Most drawing methods in this class also have an extra points argument that can be used to override the set of points in the points property."
    },
    {
        "Field List > Methods > __init__": {
            "Description": "Constructs a new polygon drawer that draws on the given Matplotlib axes.",
            "Paramters": {
                "fig": "the plotly Figure to draw on"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "PlotlyPolygonDrawer"
    },
    {
        "Field List > Methods > draw": {
            "Description": "Draws a polygon to the associated axes.",
            "Paramters": {
                "points": "the coordinates of the corners of the polygon, in clockwise or counter-clockwise order, or None if we are about to use the  property of the class.",
                "corner_radius": "if zero, an ordinary polygon will be drawn. If positive, the corners of the polygon will be rounded with the given radius.",
                "**kwds": "Undocumented"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "PlotlyPolygonDrawer"
    },
    {
        "Field List > property": {},
        "Section_id": "PlotlyPolygonDrawer"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "PlotlyPolygonDrawer"
    },
    {
        "Section_id": "_format_mapping",
        "Description": "Undocumented"
    },
    {
        "Section_id": "CohesiveBlocks",
        "Description": "The cohesive block structure of a graph.\nInstances of this type are created by Graph.cohesive_blocks(). See the documentation of Graph.cohesive_blocks() for an explanation of what cohesive blocks are.\nThis class provides a few more methods that make handling of cohesive block structures easier."
    },
    {
        "Field List > Methods > __init__": {
            "Description": "overrides igraph.VertexCover.__init__\nConstructs a new cohesive block structure for the given graph.\nIf any of blocks, cohesion or parent is None, all the arguments will be ignored and Graph.cohesive_blocks() will be called to calculate the cohesive blocks. Otherwise, these three variables should describe the *result* of a cohesive block structure calculation. Chances are that you never have to construct CohesiveBlocks instances directly, just use Graph.cohesive_blocks().",
            "Paramters": {
                "graph": "the  itself",
                "blocks": "a list containing the ; each block is described as a list containing vertex IDs.",
                "cohesion": "the  of each block. The length of this list must be equal to the length of blocks.",
                "parent": "the  block of each block. Negative values or None mean that there is no  block for that block. There should be only one  block, which covers the entire graph."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "Graph.cohesive_blocks()",
            "example": []
        },
        "Section_id": "CohesiveBlocks"
    },
    {
        "Field List > Methods > __plot__": {
            "Description": "overrides igraph.VertexCover.__plot__\nPlots the cohesive block structure to the given Cairo context or matplotlib Axes.\nSince a CohesiveBlocks instance is also a VertexCover, keyword arguments accepted by VertexCover.__plot__() are also accepted here. The only difference is that the vertices are colored according to their maximal cohesions by default, and groups are marked by colored blobs except the last group which encapsulates the whole graph.\nSee the documentation of VertexCover.__plot__() for more details.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "CohesiveBlocks"
    },
    {
        "Field List > Methods > cohesion": {
            "Description": "Returns the cohesion of the group with the given index.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "CohesiveBlocks"
    },
    {
        "Field List > Methods > cohesions": {
            "Description": "Returns the list of cohesion values for each group.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "CohesiveBlocks"
    },
    {
        "Field List > Methods > hierarchy": {
            "Description": "Returns a new graph that describes the hierarchical relationships between the groups.\nThe new graph will be a directed tree; an edge will point from vertex i to vertex j if group i is a superset of group j. In other words, the edges point downwards.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "CohesiveBlocks"
    },
    {
        "Field List > Methods > max_cohesion": {
            "Description": "Finds the maximum cohesion score among all the groups that contain the given vertex.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "CohesiveBlocks"
    },
    {
        "Field List > Methods > max_cohesions": {
            "Description": "For each vertex in the graph, returns the maximum cohesion score among all the groups that contain the vertex.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "CohesiveBlocks"
    },
    {
        "Field List > Methods > parent": {
            "Description": "Returns the parent group index of the group with the given index or None if the given group is the root.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "CohesiveBlocks"
    },
    {
        "Field List > Methods > parents": {
            "Description": "Returns the list of parent group indices for each group or None if the given group is the root.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "CohesiveBlocks"
    },
    {
        "Field List > Methods > crossing": {
            "Description": "Inherited from VertexCover:Returns a boolean vector where element i is True iff edge i lies between clusters, False otherwise."
        },
        "Section_id": "CohesiveBlocks"
    },
    {
        "Field List > Methods > subgraph": {
            "Description": "Inherited from VertexCover:Get the subgraph belonging to a given cluster."
        },
        "Section_id": "CohesiveBlocks"
    },
    {
        "Field List > Methods > subgraphs": {
            "Description": "Inherited from VertexCover:Gets all the subgraphs belonging to each of the clusters."
        },
        "Section_id": "CohesiveBlocks"
    },
    {
        "Field List > property": {
            "graph": "Inherited from VertexCover:Returns the graph belonging to this object"
        },
        "Section_id": "CohesiveBlocks"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "CohesiveBlocks"
    },
    {
        "Section_id": "consecutive_pairs",
        "Description": "Returns consecutive pairs of items from the given iterable.\nWhen circular is True, the pair consisting of the lastand first elements is also returned.\nExample:>>> list(consecutive_pairs(range(5)))[(0, 1), (1, 2), (2, 3), (3, 4)]>>> list(consecutive_pairs(range(5), circular=True))[(0, 1), (1, 2), (2, 3), (3, 4), (4, 0)]>>> list(consecutive_pairs([]))[]>>> list(consecutive_pairs([], circular=True))[]>>> list(consecutive_pairs([0]))[]>>> list(consecutive_pairs([0], circular=True))[(0, 0)]"
    },
    {
        "Paramters": {},
        "Section_id": "consecutive_pairs"
    },
    {
        "Raises": {},
        "Section_id": "consecutive_pairs"
    },
    {
        "Section_id": "consecutive_pairs",
        "See Also": ""
    },
    {
        "Section_id": "dbl_epsilon",
        "Description": "Approximates the machine epsilon value for doubles."
    },
    {
        "Paramters": {},
        "Section_id": "dbl_epsilon"
    },
    {
        "Raises": {},
        "Section_id": "dbl_epsilon"
    },
    {
        "Section_id": "dbl_epsilon",
        "See Also": ""
    },
    {
        "Section_id": "deprecated",
        "Description": "Prints a warning message related to the deprecation of some igraphfeature."
    },
    {
        "Paramters": {},
        "Section_id": "deprecated"
    },
    {
        "Raises": {},
        "Section_id": "deprecated"
    },
    {
        "Section_id": "deprecated",
        "See Also": ""
    },
    {
        "Section_id": "named_temporary_file",
        "Description": "Context manager that creates a named temporary file andreturns its name.\nAll parameters are passed on to tempfile.mkstemp, seeits documentation for more info."
    },
    {
        "Paramters": {},
        "Section_id": "named_temporary_file"
    },
    {
        "Raises": {},
        "Section_id": "named_temporary_file"
    },
    {
        "Section_id": "named_temporary_file",
        "See Also": ""
    },
    {
        "Section_id": "numpy_to_contiguous_memoryview",
        "Description": "Converts a NumPy array or matrix into a contiguous memoryview objectthat is suitable to be forwarded to the Graph constructor.\nThis is used internally to allow us to use a NumPy array or matrixdirectly when constructing a Graph."
    },
    {
        "Paramters": {},
        "Section_id": "numpy_to_contiguous_memoryview"
    },
    {
        "Raises": {},
        "Section_id": "numpy_to_contiguous_memoryview"
    },
    {
        "Section_id": "numpy_to_contiguous_memoryview",
        "See Also": ""
    },
    {
        "Section_id": "rescale",
        "Description": "Rescales a list of numbers into a given range.\nout_range gives the range of the output values; by default, the minimumof the original numbers in the list will be mapped to the first elementin the output range and the maximum will be mapped to the second element.Elements between the minimum and maximum values in the input list will beinterpolated linearly between the first and second values of the outputrange.\nin_range may be used to override which numbers are mapped to the firstand second values of the output range. This must also be a tuple, wherethe first element will be mapped to the first element of the output rangeand the second element to the second.\nIf clamp is True, elements which are outside the given out_rangeafter rescaling are clamped to the output range to ensure that no numberwill be outside out_range in the result.\nIf scale is not None, it will be called for every element of valuesand the rescaling will take place on the results instead. This can be used,for instance, to transform the logarithm of the original values instead ofthe actual values. A typical use-case is to map a range of values to coloridentifiers on a logarithmic scale. Scaling also applies to the in_rangeparameter if present.\nExamples:>>> rescale(range(5), (0, 8))[0.0, 2.0, 4.0, 6.0, 8.0]>>> rescale(range(5), (2, 10))[2.0, 4.0, 6.0, 8.0, 10.0]>>> rescale(range(5), (0, 4), (1, 3))[-2.0, 0.0, 2.0, 4.0, 6.0]>>> rescale(range(5), (0, 4), (1, 3), clamp=True)[0.0, 0.0, 2.0, 4.0, 4.0]>>> rescale([0]*5, (1, 3))[2.0, 2.0, 2.0, 2.0, 2.0]>>> from math import log10>>> rescale([1, 10, 100, 1000, 10000], (0, 8), scale=log10)[0.0, 2.0, 4.0, 6.0, 8.0]>>> rescale([1, 10, 100, 1000, 10000], (0, 4), (10, 1000), scale=log10)[-2.0, 0.0, 2.0, 4.0, 6.0]"
    },
    {
        "Paramters": {
            "values": "Undocumented",
            "out_range": "the range of output values",
            "in_range": "the range of the input values; this is the range that is mappedto out_range. None means to use the minimum and maximum ofthe input, respectively.",
            "clamp": "specifies what to do when an input value falls outside in_range.True means to  the value to the bounds of in_range,False means not to .",
            "scale": "an optional transformation to perform on the input values beforemapping them to the output range."
        },
        "Section_id": "rescale"
    },
    {
        "Raises": {},
        "Section_id": "rescale"
    },
    {
        "Section_id": "rescale",
        "See Also": ""
    },
    {
        "Section_id": "safemax",
        "Description": "Safer variant of max() that returns a default value if the iterableis empty.\nExample:>>> safemax([-5, 6, 4])6>>> safemax([])0>>> safemax((), 2)2"
    },
    {
        "Paramters": {},
        "Section_id": "safemax"
    },
    {
        "Raises": {},
        "Section_id": "safemax"
    },
    {
        "Section_id": "safemax",
        "See Also": ""
    },
    {
        "Section_id": "safemin",
        "Description": "Safer variant of min() that returns a default value if the iterableis empty.\nExample:>>> safemin([-5, 6, 4])-5>>> safemin([])0>>> safemin((), 2)2"
    },
    {
        "Paramters": {},
        "Section_id": "safemin"
    },
    {
        "Raises": {},
        "Section_id": "safemin"
    },
    {
        "Section_id": "safemin",
        "See Also": ""
    },
    {
        "Section_id": "InternalError",
        "Description": "Undocumented"
    },
    {
        "Field List > property": {},
        "Section_id": "InternalError"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "InternalError"
    },
    {
        "Section_id": "AbstractXMLRPCDrawer",
        "Description": "Abstract drawer that uses a remote service via XML-RPC to draw something on a remote display."
    },
    {
        "Field List > Methods > __init__": {
            "Description": "overridden in igraph.drawing.graph.CytoscapeGraphDrawer\nConstructs an abstract drawer using the XML-RPC service at the given URL.",
            "Paramters": {
                "url": "the URL where the XML-RPC calls for the service should be addressed to.",
                "service": "the name of the  at the XML-RPC address. If None, requests will be directed to the server proxy object constructed by xmlrpclib.ServerProxy; if not None, the given attribute will be looked up in the server proxy object."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "AbstractXMLRPCDrawer"
    },
    {
        "Field List > Methods > draw": {
            "Description": "Inherited from AbstractDrawer:Abstract method, must be implemented in derived classes."
        },
        "Section_id": "AbstractXMLRPCDrawer"
    },
    {
        "Field List > property": {},
        "Section_id": "AbstractXMLRPCDrawer"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "AbstractXMLRPCDrawer"
    },
    {
        "Section_id": "AbstractGraphDrawer",
        "Description": "Abstract class that serves as a base class for anything that draws an igraph.Graph."
    },
    {
        "Field List > Methods > ensure_layout": {
            "Description": "Helper method that ensures that layout is an instance of Layout. If it is not, the method will try to convert it to a Layout according to the following rules:If layout is a string, it is assumed to be a name of an igraph layout, and it will be passed on to the layout method of the given graph if graph is not None.If layout is None and graph has a \"layout\" attribute, call this same function with the value of that attribute.If layout is None and graph does not have a \"layout\" attribute, the layout method of graph will be invoked with no parameters, which will call the default layout algorithm.Otherwise, layout will be passed on to the constructor of Layout. This handles lists of lists, lists of tuples and such.\nIf layout is already a Layout instance, it will still be copied and a copy will be returned. This is because graph drawers are allowed to transform the layout for their purposes, and we don't want the transformation to propagate back to the caller.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "AbstractGraphDrawer"
    },
    {
        "Field List > Methods > draw": {
            "Description": "overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nAbstract method, must be implemented in derived classes.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "AbstractGraphDrawer"
    },
    {
        "Field List > property": {},
        "Section_id": "AbstractGraphDrawer"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "AbstractGraphDrawer"
    },
    {
        "Section_id": "CairoDendrogramDrawer",
        "Description": "Default Cairo drawer object for dendrograms."
    },
    {
        "Field List > Methods > __init__": {
            "Description": "overrides igraph.drawing.cairo.base.AbstractCairoDrawer.__init__\nConstructs the drawer and associates it to the given palette.",
            "Paramters": {
                "context": "the  on which we will draw",
                "bbox": "the bounding box within which we will draw. Can be anything accepted by the constructor of BoundingBox (i.e., a 2-tuple, a 4-tuple or a BoundingBox object).",
                "palette": "the  that can be used to map integer color indices to colors when drawing vertices"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "CairoDendrogramDrawer"
    },
    {
        "Field List > Methods > draw": {
            "Description": "overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nDraws the given Dendrogram in a Cairo context.",
            "Paramters": {
                "dendro": "the igraph.Dendrogram to plot.It accepts the following keyword arguments:style: the style of the plot. boolean is useful for plotting matrices with boolean (True/False or 0/1) values: False will be shown with a white box and True with a black box. palette uses the given palette to represent numbers by colors, the minimum will be assigned to palette color index 0 and the maximum will be assigned to the length of the palette. None draws transparent cell backgrounds only. The default style is boolean (but it may change in the future). None values in the matrix are treated specially in both cases: nothing is drawn in the cell corresponding to None.square: whether the cells of the matrix should be square or not. Default is True.grid_width: line width of the grid shown on the matrix. If zero or negative, the grid is turned off. The grid is also turned off if the size of a cell is less than three times the given line width. Default is 1. Fractional widths are also allowed.border_width: line width of the border drawn around the matrix. If zero or negative, the border is turned off. Default is 1.row_names: the names of the rowscol_names: the names of the columns.values: values to be displayed in the cells. If None or False, no values are displayed. If True, the values come from the matrix being plotted. If it is another matrix, the values of that matrix are shown in the cells. In this case, the shape of the value matrix must match the shape of the matrix being plotted.value_format: a format string or a callable that specifies how the values should be plotted. If it is a callable, it must be a function that expects a single value and returns a string. Example: \"%#.2f\" for floating-point numbers with always exactly two digits after the decimal point. See the Python documentation of the % operator for details on the format string. If the format string is not given, it defaults to the str function.If only the row names or the column names are given and the matrix is square-shaped, the same names are used for both column and row names.",
                "**kwds": "Undocumented"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "CairoDendrogramDrawer"
    },
    {
        "Field List > Methods > bbox.setter": {
            "Description": "Inherited from AbstractCairoDrawer:Sets the bounding box of the drawing area where this drawer will draw."
        },
        "Section_id": "CairoDendrogramDrawer"
    },
    {
        "Field List > property": {
            "bbox": "Inherited from AbstractCairoDrawer:The bounding box of the drawing area where this drawer will draw."
        },
        "Section_id": "CairoDendrogramDrawer"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "CairoDendrogramDrawer"
    },
    {
        "Section_id": "DarkToLightEdgeDrawer",
        "Description": "Edge drawer implementation that draws undirected edges as straight lines and directed edges by using an alpha value of one (full opacity) at the source and an alpha value of zero (total transparency) at the destination. The alpha value is interpolated in-between."
    },
    {
        "Field List > Methods > __init__": {
            "Description": "overrides igraph.drawing.cairo.edge.AlphaVaryingEdgeDrawer.__init__\nConstructs the edge drawer.",
            "Paramters": {
                "context": "a Cairo  on which the edges will be drawn.",
                "palette": "the  that can be used to map integer color indices to colors when drawing edges"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "DarkToLightEdgeDrawer"
    },
    {
        "Field List > Methods > draw_directed_edge": {
            "Description": "Inherited from AlphaVaryingEdgeDrawer:Draws a directed edge."
        },
        "Section_id": "DarkToLightEdgeDrawer"
    },
    {
        "Field List > property": {},
        "Section_id": "DarkToLightEdgeDrawer"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "DarkToLightEdgeDrawer"
    },
    {
        "Section_id": "ShapeDrawerDirectory",
        "Description": "Static class that resolves shape names to their corresponding shape drawer classes.\nClasses that are derived from ShapeDrawer in this module are automatically registered by ShapeDrawerDirectory when the module is loaded for the first time."
    },
    {
        "Field List > Methods > register": {
            "Description": "Registers the given shape drawer class under the given names.",
            "Paramters": {
                "drawer_class": "the shape drawer class to be registered"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "ShapeDrawerDirectory"
    },
    {
        "Field List > Methods > register_namespace": {
            "Description": "Registers all ShapeDrawer classes in the given namespace",
            "Paramters": {
                "namespace": "a Python dict mapping names to Python objects."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "ShapeDrawerDirectory"
    },
    {
        "Field List > Methods > resolve": {
            "Description": "Given a shape name, returns the corresponding shape drawer class",
            "Paramters": {
                "shape": "the name of the "
            },
            "Return": [
                "the corresponding shape drawer class"
            ],
            "References": [],
            "Rasises": {
                "ValueError": "if the shape is unknown"
            },
            "See Also": "",
            "example": []
        },
        "Section_id": "ShapeDrawerDirectory"
    },
    {
        "Field List > Methods > resolve_default": {
            "Description": "Given a shape name, returns the corresponding shape drawer class or the given default shape drawer if the shape name is unknown.",
            "Paramters": {
                "shape": "the name of the ",
                "default": "the  shape drawer to return when the shape is unknown"
            },
            "Return": [
                "the shape drawer class corresponding to the given name or the default shape drawer class if the name is unknown"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "ShapeDrawerDirectory"
    },
    {
        "Field List > property": {},
        "Section_id": "ShapeDrawerDirectory"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "ShapeDrawerDirectory"
    },
    {
        "Section_id": "PlotlyVerticesDrawer",
        "Description": "Plotly backend-specific vertex drawer."
    },
    {
        "Field List > Methods > __init__": {
            "Description": "overrides igraph.drawing.baseclasses.AbstractVertexDrawer.__init__\nConstructs the vertex drawer and associates it to the given palette.",
            "Paramters": {
                "fig": "Undocumented",
                "palette": "the  that can be used to map integer color indices to colors when drawing vertices",
                "layout": "the  of the vertices in the graph being drawn"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "PlotlyVerticesDrawer"
    },
    {
        "Field List > Methods > draw": {
            "Description": "overrides igraph.drawing.baseclasses.AbstractVertexDrawer.draw\nDraws the given vertex.",
            "Paramters": {
                "visual_vertex": "object specifying the visual properties of the vertex. Its structure is defined by the VisualVertexBuilder of the CairoGraphDrawer; see its source code.",
                "vertex": "the raw igraph  being drawn",
                "point": "Undocumented",
                "coords": "the X and Y coordinates of the vertex as specified by the layout algorithm, scaled into the bounding box."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "PlotlyVerticesDrawer"
    },
    {
        "Field List > Methods > draw_label": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "PlotlyVerticesDrawer"
    },
    {
        "Field List > property": {},
        "Section_id": "PlotlyVerticesDrawer"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "PlotlyVerticesDrawer"
    },
    {
        "Section_id": "Flow",
        "Description": "A flow of a given graph.\nThis is a simple class used to represent flows returned by Graph.maxflow. It has the following attributes: graph - the graph on which this flow is defined value - the value (capacity) of the flow flow - the flow values on each edge. For directed graphs, this is simply a list where element i corresponds to the flow on edge i. For undirected graphs, the direction of the flow is not constrained (since the edges are undirected), hence positive flow always means a flow from the smaller vertex ID to the larger, while negative flow means a flow from the larger vertex ID to the smaller. cut - edge IDs in the minimal cut corresponding to the flow. partition - vertex IDs in the parts created after removing edges in the cut es - an edge selector restricted to the edges in the cut. \nThis class is usually not instantiated directly, everything is taken care of by Graph.maxflow.\n"
    },
    {
        "Field List > Methods > __init__": {
            "Description": "overrides igraph.Cut.__init__\nInitializes the flow.\nThis should not be called directly, everything is taken care of by Graph.maxflow.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Flow"
    },
    {
        "Field List > Methods > __repr__": {
            "Description": "overrides igraph.Cut.__repr__\nUndocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Flow"
    },
    {
        "Field List > Methods > __str__": {
            "Description": "overrides igraph.Cut.__str__\nUndocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Flow"
    },
    {
        "Field List > property": {
            "flow": "Returns the flow values for each edge.\nFor directed graphs, this is simply a list where element i corresponds to the flow on edge i. For undirected graphs, the direction of the flow is not constrained (since the edges are undirected), hence positive flow always means a flow from the smaller vertex ID to the larger, while negative flow means a flow from the larger vertex ID to the smaller.\n\n",
            "cut": "Inherited from Cut:Returns the edge IDs in the cut",
            "es": "Inherited from Cut:Returns an edge selector restricted to the cut",
            "partition": "Inherited from Cut:Returns the vertex IDs partitioned according to the cut",
            "value": "Inherited from Cut:Returns the sum of edge capacities in the cut"
        },
        "Section_id": "Flow"
    },
    {
        "Rubric": {
            "Example": [
                "Examples:\n>>> from igraph import Graph\n>>> g = Graph.Ring(20)\n>>> mf = g.maxflow(0, 10)\n>>> print(mf.value)\n2.0\n>>> mf.es[\"color\"] = \"red\""
            ]
        },
        "Section_id": "Flow"
    },
    {
        "Section_id": "Graph",
        "Description": "Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n"
    },
    {
        "Field List > Methods > Adjacency": {
            "Description": "overrides igraph.GraphBase.Adjacency\nGenerates a graph from its adjacency matrix.",
            "Paramters": {
                "matrix": "the adjacency . Possible types are:a list of listsa numpy 2D array or  (will be converted to list of lists)a scipy.sparse  (will be converted to a COO , but not to a dense )a pandas.DataFrame (column/row names must match, and will be used as vertex names).",
                "mode": "the  to be used. Possible values are:\"directed\" - the graph will be directed and a matrix element specifies the number of edges between two vertices.\"undirected\" - the graph will be undirected and a matrix element specifies the number of edges between two vertices. The matrix must be symmetric.\"max\" - undirected graph will be created and the number of edges between vertex i and j is max(A(i,\u2009j),\u2009A(j,\u2009i))\"min\" - like \"max\", but with min(A(i,\u2009j),\u2009A(j,\u2009i))\"plus\"  - like \"max\", but with A(i,\u2009j)\u2009+\u2009A(j,\u2009i)\"upper\" - undirected graph with the upper right triangle of the matrix (including the diagonal)\"lower\" - undirected graph with the lower left triangle of the matrix (including the diagonal)",
                "loops": "specifies how to handle loop edges. When False or \"ignore\", the diagonal of the adjacency matrix will be ignored. When True or \"once\", the diagonal is assumed to contain the multiplicity of the corresponding loop edge. When \"twice\", the diagonal is assumed to contain twice the multiplicity of the corresponding loop edge."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Biadjacency": {
            "Description": "Creates a bipartite graph from a bipartite adjacency matrix.\nExample:",
            "Paramters": {
                "matrix": "the bipartite adjacency .",
                "directed": "whether to create a  graph.",
                "mode": "defines the direction of edges in the graph. If \"out\", then edges go from vertices of the first kind (corresponding to rows of the matrix) to vertices of the second kind (the columns of the matrix). If \"in\", the opposite direction is used. \"all\" creates mutual edges. Ignored for undirected graphs.",
                "multiple": "defines what to do with non-zero entries in the matrix. If False, non-zero entries will create an edge no matter what the value is. If True, non-zero entries are rounded up to the nearest integer and this will be the number of  edges created.",
                "weighted": "defines whether to create a  graph from the adjacency matrix. If it is c{None} then an un graph is created and the multiple argument is used to determine the edges of the graph. If it is a string then for every non-zero matrix entry, an edge is created and the value of the entry is added as an edge attribute named by the  argument. If it is True then a  graph is created and the name of the edge attribute will be \"weight\".",
                "*args": "Undocumented",
                "**kwds": "Undocumented"
            },
            "Return": [
                "the graph with a binary vertex attribute named \"type\" that stores the vertex classes."
            ],
            "References": [],
            "Rasises": {
                "ValueError": "if the weighted and multiple are passed together."
            },
            "See Also": "",
            "example": [
                "Example:\n>>> g = Graph.Biadjacency([[0, 1, 1], [1, 1, 0]])"
            ]
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Bipartite": {
            "Description": "Creates a bipartite graph with the given vertex types and edges. This is similar to the default constructor of the graph, the only difference is that it checks whether all the edges go between the two vertex classes and it assigns the type vector to a type attribute afterwards.\nExamples:",
            "Paramters": {
                "types": "the vertex  as a boolean list. Anything that evaluates to False will denote a vertex of the first kind, anything that evaluates to True will denote a vertex of the second kind.",
                "edges": "the  as a list of tuples.",
                "directed": "whether to create a  graph. Bipartite networks are usually un, so the default is False",
                "*args": "Undocumented",
                "**kwds": "Undocumented"
            },
            "Return": [
                "the graph with a binary vertex attribute named \"type\" that stores the vertex classes."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": [
                "Examples:\n>>> g = Graph.Bipartite([0, 1, 0, 1], [(0, 1), (2, 3), (0, 3)])\n>>> g.is_bipartite()\nTrue\n>>> g.vs[\"type\"]\n[False, True, False, True]\n"
            ]
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > DataFrame": {
            "Description": "Generates a graph from one or two dataframes.",
            "Paramters": {
                "edges": "pandas DataFrame containing  and metadata. The first two columns of this DataFrame contain the source and target vertices for each edge. These indicate the vertex IDs as nonnegative integers rather than vertex names unless use_vids is False. Further columns may contain edge attributes.",
                "directed": ":boolwhether the graph is ",
                "vertices": "None (default) or pandas DataFrame containing vertex metadata. The DataFrame's index must contain the vertex IDs as a sequence of intergers from 0 to len() - 1. If use_vids is False, the first column must contain the unique vertex names. Vertex names should be strings for full compatibility, but many functions will work if you set the name with any hashable object. All other columns will be added as vertex attributes by column name.",
                "use_vids": ":boolwhether to interpret the first two columns of the edges argument as vertex ids (0-based integers) instead of vertex names. If this argument is set to True and the first two columns of edges are not integers, an error is thrown."
            },
            "Return": [
                "the graph\nVertex names in either the edges or vertices arguments that are set to NaN (not a number) will be set to the string \"NA\". That might lead to unexpected behaviour: fill your NaNs with values before calling this function to mitigate.\n"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > DictDict": {
            "Description": "Constructs a graph from a dict-of-dicts representation.\nEach key can be an integer or a string and represent a vertex. Each value is a dict representing edges (outgoing if the graph is directed) from that vertex. Each dict key is an integer/string for a target vertex, such that an edge will be created between those two vertices. Integers are interpreted as vertex_ids from 0 (as used in igraph), strings are interpreted as vertex names, in which case vertices are given separate numeric ids. Each value is a dictionary of edge attributes for that edge.\nExample:",
            "Paramters": {
                "edges": "the dict of dict of dicts specifying the  and their attributes",
                "directed": ":boolwhether to create a  graph",
                "vertex_name_attr": ":strvertex attribute that will store the names"
            },
            "Return": [
                "a Graph object"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": [
                "Example:\n>>> {'Alice': {'Bob': {'weight': 1.5}, 'David': {'weight': 2}}}"
            ]
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > DictList": {
            "Description": "Constructs a graph from a list-of-dictionaries representation.\nThis function is useful when you have two lists of dictionaries, one for vertices and one for edges, each containing their attributes (e.g. name, weight). Of course, the edge dictionary must also contain two special keys that indicate the source and target vertices connected by that edge. Non-list iterables should work as long as they yield dictionaries or dict-like objects (they should have the 'items' and '__getitem__' methods). For instance, a database query result is likely to be fit as long as it's iterable and yields dict-like objects with every iteration.",
            "Paramters": {
                "vertices": "the list of dictionaries for the  or None if there are no special attributes assigned to  and we should simply use the edge list of dicts to infer vertex names.",
                "edges": "the list of dictionaries for the . Each dict must have at least the two keys specified by edge_foreign_keys to label the source and target vertices, while additional items will be treated as edge attributes.",
                "directed": ":boolwhether the constructed graph will be ",
                "vertex_name_attr": ":strthe name of the distinguished key in the dicts in the vertex data source that contains the vertex names. Ignored if vertices is None.",
                "edge_foreign_keys": "tuple specifying the attributes in each edge dictionary that contain the source (1st) and target (2nd) vertex names. These items of each dictionary are also added as edge_attributes.",
                "iterative": ":boolwhether to add the edges to the graph one by one, ly, or to build a large edge list first and use that to construct the graph. The latter approach is faster but it may not be suitable if your dataset is large. The default is to add the edges in a batch from an edge list."
            },
            "Return": [
                "the graph that was constructed\nExample:\n\n>>> vertices = [{'name': 'apple'}, {'name': 'pear'}, {'name': 'peach'}]\n>>> edges = [{'source': 'apple', 'target': 'pear', 'weight': 1.2},\n...          {'source': 'apple', 'target': 'peach', 'weight': 0.9}]\n>>> g = Graph.DictList(vertices, edges)The graph has three vertices with names and two edges with weights.\n"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": [
                "Example:\n>>> vertices = [{'name': 'apple'}, {'name': 'pear'}, {'name': 'peach'}]\n>>> edges = [{'source': 'apple', 'target': 'pear', 'weight': 1.2},\n...          {'source': 'apple', 'target': 'peach', 'weight': 0.9}]\n>>> g = Graph.DictList(vertices, edges)"
            ]
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > from_graph_tool": {
            "Description": "Converts the graph from graph-tool",
            "Paramters": {
                "g": "raph-tool Graph"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > from_networkx": {
            "Description": "Converts the graph from networkx\nVertex names will be stored as a vertex_attr_hashable attribute (usually \"_nx_name\", but see below). Because igraph stored vertices in an ordered manner, vertices will get new IDs from 0 up. In case of multigraphs, each edge will have an \"_nx_multiedge_key\" attribute, to distinguish edges that connect the same two vertices.",
            "Paramters": {
                "g": "networkx Graph or DiGraph",
                "vertex_attr_hashable": ":strattribute used to store the Python hashable used by networkx to identify each vertex. The default value '_nx_name' ensures lossless round trip conversions to/from networkx. An alternative choice is 'name': in that case, using strings for vertex names is recommended and, if the graph is re-exported to networkx, Graph.to_networkx(=\"name\") must be used to recover the correct vertex nomenclature in the exported network."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Full_Bipartite": {
            "Description": "Generates a full bipartite graph (directed or undirected, with or without loops).",
            "Paramters": {
                "n1": "the number of vertices of the first kind.",
                "n2": "the number of vertices of the second kind.",
                "directed": "whether tp generate a  graph.",
                "mode": "if \"out\", then all vertices of the first kind are connected to the others; \"in\" specifies the opposite direction, \"all\" creates mutual edges. Ignored for undirected graphs.",
                "*args": "Undocumented",
                "**kwds": "Undocumented"
            },
            "Return": [
                "the graph with a binary vertex attribute named \"type\" that stores the vertex classes."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": [
                "Generates a full bipartite graph (directed or undirected, with or without loops).\n>>> g = Graph.Full_Bipartite(2, 3)\n>>> g.is_bipartite()\nTrue\n>>> g.vs[\"type\"]\n[False, False, True, True, True]\n"
            ]
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > GRG": {
            "Description": "Generates a random geometric graph.\nThe algorithm drops the vertices randomly on the 2D unit square and connects them if they are closer to each other than the given radius. The coordinates of the vertices are stored in the vertex attributes x and y.",
            "Paramters": {
                "n": "The umber of vertices i the graph",
                "radius": "The given ",
                "torus": "This should be True if we want to use a  instead of a square."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Incidence": {
            "Description": "Deprecated alias to Graph.Biadjacency().",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > ListDict": {
            "Description": "Constructs a graph from a dict-of-lists representation.\nThis function is used to construct a graph from a dictionary of lists. Other, non-list sequences (e.g. tuples) and lazy iterators are are accepted. For each key x, its corresponding value must be a sequence of multiple values y: the edge (x,y) will be created in the graph. x and y must be either one of:two integers: the vertices with those ids will be connectedtwo strings: the vertices with those names will be connected\nIf names are used, the order of vertices is not guaranteed, and each vertex will be given the vertex_name_attr attribute.",
            "Paramters": {
                "edges": "the dict of sequences describing the ",
                "directed": ":boolwhether to create a  graph",
                "vertex_name_attr": ":strvertex attribute that will store the names"
            },
            "Return": [
                "a Graph object\nExample:\n\n>>> mydict = {'apple': ['pear', 'peach'], 'pear': ['peach']}\n>>> g = Graph.ListDict(mydict)# The graph has three vertices with names and three edges connecting # each pair.\n"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": [
                "Example:\n>>> mydict = {'apple': ['pear', 'peach'], 'pear': ['peach']}\n>>> g = Graph.ListDict(mydict)"
            ]
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Random_Bipartite": {
            "Description": "Generates a random bipartite graph with the given number of vertices and edges (if m is given), or with the given number of vertices and the given connection probability (if p is given).\nIf m is given but p is not, the generated graph will have n1 vertices of type 1, n2 vertices of type 2 and m randomly selected edges between them. If p is given but m is not, the generated graph will have n1 vertices of type 1 and n2 vertices of type 2, and each edge will exist between them with probability p.",
            "Paramters": {
                "n1": "the number of vertices of type 1.",
                "n2": "the number of vertices of type 2.",
                "p": "the robability of edges. If given, m must be missing.",
                "m": "the nuber of edges. If given, p ust be issing.",
                "directed": "whether to generate a  graph.",
                "neimode": "if the graph is directed, specifies how the edges will be generated. If it is \"all\", edges will be generated in both directions (from type 1 to type 2 and vice versa) independently. If it is \"out\" edges will always point from type 1 to type 2. If it is \"in\", edges will always point from type 2 to type 1. This argument is ignored for undirected graphs.",
                "*args": "Undocumented",
                "**kwds": "Undocumented"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Read": {
            "Description": "Unified reading function for graphs.\nThis method tries to identify the format of the graph given in the first parameter and calls the corresponding reader method.\nThe remaining arguments are passed to the reader method without any changes.",
            "Paramters": {
                "f": "the ile containing the graph to be loaded",
                "format": "the  of the file (if known in advance). None means auto-detection. Possible values are: \"ncol\" (NCOL ), \"lgl\" (LGL ), \"graphdb\" (GraphDB ), \"graphml\", \"graphmlz\" (GraphML and gzipped GraphML ), \"gml\" (GML ), \"net\", \"pajek\" (Pajek ), \"dimacs\" (DIMACS ), \"edgelist\", \"edges\" or \"edge\" (edge list), \"adjacency\" (adjacency matrix), \"dl\" (DL  used by UCINET), \"pickle\" (Python pickled ), \"picklez\" (gzipped Python pickled )",
                "*args": "Undocumented",
                "**kwds": "Undocumented"
            },
            "Return": [],
            "References": [],
            "Rasises": {
                "IOError": "if the file format can't be identified and none was given."
            },
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Read_Adjacency": {
            "Description": "Constructs a graph based on an adjacency matrix from the given file.\nAdditional positional and keyword arguments not mentioned here are passed intact to Graph.Adjacency.",
            "Paramters": {
                "f": "the name o the ile to be read or a ile object",
                "sep": "the string that arates the matrix elements in a row. None means an arbitrary sequence of whitespace characters.",
                "comment_char": "lines starting with this string are treated as comments.",
                "attribute": "an edge  name where the edge weights are stored in the case of a weighted adjacency matrix. If None, no weights are stored, values larger than 1 are considered as edge multiplicities.",
                "*args": "Undocumented",
                "**kwds": "Undocumented"
            },
            "Return": [
                "the created graph"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Read_DIMACS": {
            "Description": "overrides igraph.GraphBase.Read_DIMACS\nReads a graph from a file conforming to the DIMACS minimum-cost flow file format.\nFor the exact definition of the format, see http://lpsolve.sourceforge.net/5.5/DIMACS.htm.\nRestrictions compared to the official description of the format are as follows:igraph's DIMACS reader requires only three fields in an arc definition, describing the edge's source and target node and its capacity.Source vertices are identified by 's' in the FLOW field, target vertices are identified by 't'.Node indices start from 1. Only a single source and target node is allowed.",
            "Paramters": {
                "f": "the name o the ile or a Python ile handle",
                "directed": "whether the generated graph should be ."
            },
            "Return": [
                "the generated graph. The indices of the source and target vertices are attached as graph attributes source and target, the edge capacities are stored in the capacity edge attribute."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Read_GraphMLz": {
            "Description": "Reads a graph from a zipped GraphML file.",
            "Paramters": {
                "f": "the name o the ile",
                "index": "if the GraphML file contains multiple graphs, specified the one that should be loaded. Graph indices start from zero, so if you want to load the first graph, specify 0 here."
            },
            "Return": [
                "the loaded graph object"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Read_Pickle": {
            "Description": "Reads a graph from Python pickled format",
            "Paramters": {
                "fname": "the name of the file, a stream to read from, or a string containing the pickled data."
            },
            "Return": [
                "the created graph object."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Read_Picklez": {
            "Description": "Reads a graph from compressed Python pickled format, uncompressing it on-the-fly.",
            "Paramters": {
                "fname": "the name of the file or a stream to read from."
            },
            "Return": [
                "the created graph object."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > TupleList": {
            "Description": "Constructs a graph from a list-of-tuples representation.\nThis representation assumes that the edges of the graph are encoded in a list of tuples (or lists). Each item in the list must have at least two elements, which specify the source and the target vertices of the edge. The remaining elements (if any) specify the edge attributes of that edge, where the names of the edge attributes originate from the edge_attrs list. The names of the vertices will be stored in the vertex attribute given by vertex_name_attr.\nThe default parameters of this function are suitable for creating unweighted graphs from lists where each item contains the source vertex and the target vertex. If you have a weighted graph, you can use items where the third item contains the weight of the edge by setting edge_attrs to \"weight\" or [\"weight\"]. If you have even more edge attributes, add them to the end of each item in the edges list and also specify the corresponding edge attribute names in edge_attrs as a list.",
            "Paramters": {
                "edges": "the data source for the . This must be a list where each item is a tuple (or list) containing at least two items: the name of the source and the target vertex. Note that names will be assigned to the name vertex attribute (or another vertex attribute if vertex_name_attr is specified), even if all the vertex names in the list are in fact numbers.",
                "directed": ":boolwhether the constructed graph will be ",
                "vertex_name_attr": ":strthe name of the vertex attribute that will contain the vertex names.",
                "edge_attrs": "the names of the edge attributes that are filled with the extra items in the edge list (starting from index 2, since the first two items are the source and target vertices). If None or an empty sequence, only the source and target vertices will be extracted and additional tuple items will be ignored. If a string, it is interpreted as a single edge attribute.",
                "weights": "alternative way to specify that the graph is weighted. If you set  to true and edge_attrs is not given, it will be assumed that edge_attrs is [\"weight\"] and igraph will parse the third element from each item into an edge weight. If you set  to a string, it will be assumed that edge_attrs contains that string only, and igraph will store the edge  in that attribute."
            },
            "Return": [
                "the graph that was constructed"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Weighted_Adjacency": {
            "Description": "Generates a graph from its weighted adjacency matrix.",
            "Paramters": {
                "matrix": "the adjacency . Possible types are:a list of listsa numpy 2D array or  (will be converted to list of lists)a scipy.sparse  (will be converted to a COO , but not to a dense )",
                "mode": "the  to be used. Possible values are:\"directed\" - the graph will be directed and a matrix element specifies the number of edges between two vertices.\"undirected\" - the graph will be undirected and a matrix element specifies the number of edges between two vertices. The matrix must be symmetric.\"max\"   - undirected graph will be created and the number of edges between vertex i and j is max(A(i,\u2009j),\u2009A(j,\u2009i))\"min\"   - like \"max\", but with min(A(i,\u2009j),\u2009A(j,\u2009i))\"plus\"  - like \"max\", but with A(i,\u2009j)\u2009+\u2009A(j,\u2009i)\"upper\" - undirected graph with the upper right triangle of the matrix (including the diagonal)\"lower\" - undirected graph with the lower left triangle of the matrix (including the diagonal)These values can also be given as strings without the ADJ prefix.",
                "attr": "the name of the edge ibute that stores the edge weights.",
                "loops": "specifies how to handle loop edges. When False or \"ignore\", the diagonal of the adjacency matrix will be ignored. When True or \"once\", the diagonal is assumed to contain the weight of the corresponding loop edge. When \"twice\", the diagonal is assumed to contain twice the weight of the corresponding loop edge."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > __add__": {
            "Description": "Copies the graph and extends the copy depending on the type of the other object given.",
            "Paramters": {
                "graph": "Undocumented",
                "other": "if it is an integer, the copy is extended by the given number of vertices. If it is a string, the copy is extended by a single vertex whose name attribute will be equal to the given string. If it is a tuple with two elements, the copy is extended by a single edge. If it is a list of tuples, the copy is extended by multiple edges. If it is a Graph, a disjoint union is performed."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > __and__": {
            "Description": "Graph intersection operator.",
            "Paramters": {
                "graph": "Undocumented",
                "other": "the  graph to take the intersection with."
            },
            "Return": [
                "the intersected graph."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > __bool__": {
            "Description": "Returns True if the graph has at least one vertex, False otherwise.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > __coerce__": {
            "Description": "Coercion rules.\nThis method is needed to allow the graph to react to additions with lists, tuples, integers, strings, vertices, edges and so on.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > __iadd__": {
            "Description": "In-place addition (disjoint union).",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "__add__",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > __init__": {
            "Description": "__init__(n=0, edges=None, directed=False, graph_attrs=None, vertex_attrs=None, edge_attrs=None)\nConstructs a graph from scratch.",
            "Paramters": {
                "*args": "Undocumented",
                "n": "the umber of vertices. Ca be omitted, the default is zero. Note that if the edge list cotais vertices with idexes larger tha or equal to , the the umber of vertices will be adjusted accordigly.",
                "edges": "the edge list where every list item is a pair of integers. If any of the integers is larger than n\u2009\u2212\u20091, the number of vertices is adjusted accordingly. None means no .",
                "directed": "whether the graph should be ",
                "graph_attrs": "the attributes of the graph as a dictionary.",
                "vertex_attrs": "the attributes of the vertices as a dictionary. The keys of the dictionary must be the names of the attributes; the values must be iterables with exactly n items where n is the number of vertices.",
                "edge_attrs": "the attributes of the edges as a dictionary. The keys of the dictionary must be the names of the attributes; the values must be iterables with exactly m items where m is the number of edges."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > __isub__": {
            "Description": "In-place subtraction (difference).",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "__sub__",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > __mul__": {
            "Description": "Copies exact replicas of the original graph an arbitrary number of times.",
            "Paramters": {
                "graph": "Undocumented",
                "other": "if it is an integer, multiplies the graph by creating the given number of identical copies and taking the disjoint union of them."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > __or__": {
            "Description": "Graph union operator.",
            "Paramters": {
                "graph": "Undocumented",
                "other": "the  graph to take the union with."
            },
            "Return": [
                "the union graph."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > __plot__": {
            "Description": "Plots the graph to the given Cairo context or matplotlib Axes.\nThe visual style of vertices and edges can be modified at three places in the following order of precedence (lower indices override higher indices):Keyword arguments of this function (or of plot() which is passed intact to Graph.__plot__().Vertex or edge attributes, specified later in the list of keyword arguments.igraph-wide plotting defaults (see igraph.config.Configuration)Built-in defaults.\nE.g., if the vertex_size keyword attribute is not present, but there exists a vertex attribute named size, the sizes of the vertices will be specified by that attribute.\nBesides the usual self-explanatory plotting parameters (context, bbox, palette), it accepts the following keyword arguments:autocurve: whether to use curves instead of straight lines for multiple edges on the graph plot. This argument may be True or False; when omitted, True is assumed for graphs with less than 10.000 edges and False otherwise.drawer_factory: a subclass of AbstractCairoGraphDrawer which will be used to draw the graph. You may also provide a function here which takes two arguments: the Cairo context to draw on and a bounding box (an instance of BoundingBox). If this keyword argument is missing, igraph will use the default graph drawer which should be suitable for most purposes. It is safe to omit this keyword argument unless you need to use a specific graph drawer.keep_aspect_ratio: whether to keep the aspect ratio of the layout that igraph calculates to place the nodes. True means that the layout will be scaled proportionally to fit into the bounding box where the graph is to be drawn but the aspect ratio will be kept the same (potentially leaving empty space next to, below or above the graph). False means that the layout will be scaled independently along the X and Y axis in order to fill the entire bounding box. The default is False.layout: the layout to be used. If not an instance of Layout, it will be passed to layout to calculate the layout. Note that if you want a deterministic layout that does not change with every plot, you must either use a deterministic layout function (like GraphBase.layout_circle) or calculate the layout in advance and pass a Layout object here.margin: the top, right, bottom, left margins as a 4-tuple. If it has less than 4 elements or is a single float, the elements will be re-used until the length is at least 4.mark_groups: whether to highlight some of the vertex groups by colored polygons. This argument can be one of the following:False: no groups will be highlightedTrue: only valid if the object plotted is a VertexClustering or VertexCover. The vertex groups in the clutering or cover will be highlighted such that the i-th group will be colored by the i-th color from the current palette. If used when plotting a graph, it will throw an error.A dict mapping tuples of vertex indices to color names. The given vertex groups will be highlighted by the given colors.A list containing pairs or an iterable yielding pairs, where the first element of each pair is a list of vertex indices and the second element is a color.A VertexClustering or VertexCover instance. The vertex groups in the clustering or cover will be highlighted such that the i-th group will be colored by the i-th color from the current palette.In place of lists of vertex indices, you may also use VertexSeq instances.In place of color names, you may also use color indices into the current palette. None as a color name will mean that the corresponding group is ignored.vertex_size: size of the vertices. The corresponding vertex attribute is called size. The default is 10. Vertex sizes are measured in the unit of the Cairo context on which igraph is drawing.vertex_color: color of the vertices. The corresponding vertex attribute is color, the default is red.  Colors can be specified either by common X11 color names (see the source code of igraph.drawing.colors for a list of known colors), by 3-tuples of floats (ranging between 0 and 255 for the R, G and B components), by CSS-style string specifications (#rrggbb) or by integer color indices of the specified palette.vertex_frame_color: color of the frame (i.e. stroke) of the vertices. The corresponding vertex attribute is frame_color, the default is black. See vertex_color for the possible ways of specifying a color.vertex_frame_width: the width of the frame (i.e. stroke) of the vertices. The corresponding vertex attribute is frame_width. The default is 1. Vertex frame widths are measured in the unit of the Cairo context on which igraph is drawing.vertex_shape: shape of the vertices. Alternatively it can be specified by the shape vertex attribute. Possibilities are: square, {circle}, {triangle}, {triangle-down} or hidden. See the source code of igraph.drawing for a list of alternative shape names that are also accepted and mapped to these.vertex_label: labels drawn next to the vertices. The corresponding vertex attribute is label.vertex_label_dist: distance of the midpoint of the vertex label from the center of the corresponding vertex. The corresponding vertex attribute is label_dist.vertex_label_color: color of the label. Corresponding vertex attribute: label_color. See vertex_color for color specification syntax.vertex_label_size: font size of the label, specified in the unit of the Cairo context on which we are drawing. Corresponding vertex attribute: label_size.vertex_label_angle: the direction of the line connecting the midpoint of the vertex with the midpoint of the label. This can be used to position the labels relative to the vertices themselves in conjunction with vertex_label_dist. Corresponding vertex attribute: label_angle. The default is -math.pi/2.vertex_order: drawing order of the vertices. This must be a list or tuple containing vertex indices; vertices are then drawn according to this order.vertex_order_by: an alternative way to specify the drawing order of the vertices; this attribute is interpreted as the name of a vertex attribute, and vertices are drawn such that those with a smaller attribute value are drawn first. You may also reverse the order by passing a tuple here; the first element of the tuple should be the name of the attribute, the second element specifies whether the order is reversed (True, False, \"asc\" and \"desc\" are accepted values).edge_color: color of the edges. The corresponding edge attribute is color, the default is red. See vertex_color for color specification syntax.edge_curved: whether the edges should be curved. Positive numbers correspond to edges curved in a counter-clockwise direction, negative numbers correspond to edges curved in a clockwise direction. Zero represents straight edges. True is interpreted as 0.5, False is interpreted as 0. The default is 0 which makes all the edges straight.edge_width: width of the edges in the default unit of the Cairo context on which we are drawing. The corresponding edge attribute is width, the default is 1.edge_arrow_size: arrow size of the edges. The corresponding edge attribute is arrow_size, the default is 1.edge_arrow_width: width of the arrowhead on the edge. The corresponding edge attribute is arrow_width, the default is 1.edge_order: drawing order of the edges. This must be a list or tuple containing edge indices; edges are then drawn according to this order.edge_order_by: an alternative way to specify the drawing order of the edges; this attribute is interpreted as the name of an edge attribute, and edges are drawn such that those with a smaller attribute value are drawn first. You may also reverse the order by passing a tuple here; the first element of the tuple should be the name of the attribute, the second element specifies whether the order is reversed (True, False, \"asc\" and \"desc\" are accepted values).",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > __reduce__": {
            "Description": "Support for pickling.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > __str__": {
            "Description": "Returns a string representation of the graph.\nBehind the scenes, this method constructs a GraphSummary instance and invokes its __str__ method with a verbosity of 1 and attribute printing turned off.\nSee the documentation of GraphSummary for more details about the output.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > __sub__": {
            "Description": "Removes the given object(s) from the graph",
            "Paramters": {
                "graph": "Undocumented",
                "other": "if it is an integer, removes the vertex with the given ID from the graph (note that the remaining vertices will get re-indexed!). If it is a tuple, removes the given edge. If it is a graph, takes the difference of the two graphs. Accepts lists of integers or lists of tuples as well, but they can't be mixed! Also accepts Edge and EdgeSeq objects."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > add_edge": {
            "Description": "Adds a single edge to the graph.\nKeyword arguments (except the source and target arguments) will be assigned to the edge as attributes.\nThe performance cost of adding a single edge or several edges to a graph is similar. Thus, when adding several edges, a single add_edges() call is more efficient than multiple add_edge() calls.",
            "Paramters": {
                "graph": "Undocumented",
                "source": "the  vertex of the edge or its name.",
                "target": "the  vertex of the edge or its name.",
                "**kwds": "Undocumented"
            },
            "Return": [
                "the newly added edge as an Edge object. Use add_edges([(source, target)]) if you don't need the Edge object and want to avoid the overhead of creating it."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > add_edges": {
            "Description": "overrides igraph.GraphBase.add_edges\nAdds some edges to the graph.",
            "Paramters": {
                "graph": "Undocumented",
                "es": "the list of edg to be added. Every edge is reprented with a tuple containing the vertex IDs or nam of the two endpoints. Vertic are enumerated from zero.",
                "attributes": "dict of sequences, each of length equal to the number of edges to be added, containing the  of the new edges."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > add_vertex": {
            "Description": "Adds a single vertex to the graph. Keyword arguments will be assigned as vertex attributes. Note that name as a keyword argument is treated specially; if a graph has name as a vertex attribute, it allows one to refer to vertices by their names in most places where igraph expects a vertex ID.",
            "Paramters": {},
            "Return": [
                "the newly added vertex as a Vertex object. Use add_vertices(1) if you don't need the Vertex object and want to avoid the overhead of creating t."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > add_vertices": {
            "Description": "overrides igraph.GraphBase.add_vertices\nAdds some vertices to the graph.\nNote that if n is a sequence of strings, indicating the names of the new vertices, and attributes has a key name, the two conflict. In that case the attribute will be applied.",
            "Paramters": {
                "graph": "Undocumented",
                "n": "the umber of vertices to be added, or the ame of a sigle vertex to be added, or a sequece of strigs, each correspodig to the ame of a vertex to be added. Names will be assiged to the ame vertex attribute.",
                "attributes": "dict of sequences, each of length equal to the number of vertices to be added, containing the  of the new vertices. If n is a string (so a single vertex is added), then the values of this dict are the  themselves, but if n=1 then they have to be lists of length 1."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > all_st_cuts": {
            "Description": "overrides igraph.GraphBase.all_st_cuts\nReturns all the cuts between the source and target vertices in a directed graph.\nThis function lists all edge-cuts between a source and a target vertex. Every cut is listed exactly once.\nReference: JS Provan and DR Shier: A paradigm for listing (s,t)-cuts in graphs. Algorithmica 15, 351-372, 1996.",
            "Paramters": {
                "graph": "Undocumented",
                "source": "the  vertex ID",
                "target": "the  vertex ID"
            },
            "Return": [
                "a list of Cut objects."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > all_st_mincuts": {
            "Description": "overrides igraph.GraphBase.all_st_mincuts\nReturns all the mincuts between the source and target vertices in a directed graph.\nThis function lists all minimum edge-cuts between a source and a target vertex.\nReference: JS Provan and DR Shier: A paradigm for listing (s,t)-cuts in graphs. Algorithmica 15, 351-372, 1996.",
            "Paramters": {
                "graph": "Undocumented",
                "source": "the  vertex ID",
                "target": "the  vertex ID",
                "capacity": "the edge capacities (weights). If None, all edges have equal weight. May also be an attribute name."
            },
            "Return": [
                "a list of Cut objects."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > as_directed": {
            "Description": "Returns a directed copy of this graph. Arguments are passed on to GraphBase.to_directed() that is invoked on the copy.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > as_undirected": {
            "Description": "Returns an undirected copy of this graph. Arguments are passed on to GraphBase.to_undirected() that is invoked on the copy.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > biconnected_components": {
            "Description": "overrides igraph.GraphBase.biconnected_components\nCalculates the biconnected components of the graph.",
            "Paramters": {
                "graph": "Undocumented",
                "return_articulation_points": "whether to return the articulation points as well"
            },
            "Return": [
                "a VertexCover object describing the biconnected components, and optionally the list of articulation points as well"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > bipartite_projection": {
            "Description": "overrides igraph.GraphBase.bipartite_projection\nProjects a bipartite graph into two one-mode graphs. Edge directions are ignored while projecting.\nExamples:",
            "Paramters": {
                "graph": "Undocumented",
                "types": "an igraph vector containing the vertex , or an attribute name. Anything that evalulates to False corresponds to vertices of the first kind, everything else to the second kind.",
                "multiplicity": "if True, then igraph keeps the  of the edges in the projection in an edge attribute called \"weight\". E.g., if there is an A-C-B and an A-D-B triplet in the bipartite graph and there is no other X (apart from X=B and X=D) for which an A-X-B triplet would exist in the bipartite graph, the  of the A-B edge in the projection will be 2.",
                "probe1": "this argument can be used to specify the order of the projections in the resulting list. If given and non-negative, then it is considered as a vertex ID; the projection containing the vertex will be the first one in the result.",
                "which": "this argument can be used to specify  of the two projections should be returned if only one of them is needed. Passing 0 here means that only the first projection is returned, while 1 means that only the second projection is returned. (Note that we use 0 and 1 because Python indexing is zero-based). False is equivalent to 0 and True is equivalent to 1. Any other value means that both projections will be returned in a tuple."
            },
            "Return": [
                "a tuple containing the two projected one-mode graphs if which is not 1 or 2, or the projected one-mode graph specified by the which argument if its value is 0, 1, False or True."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": [
                "Examples:\n>>> g = Graph.Full_Bipartite(10, 5)\n>>> g1, g2 = g.bipartite_projection()\n>>> g1.isomorphic(Graph.Full(10))\nTrue\n>>> g2.isomorphic(Graph.Full(5))\nTrue\n"
            ]
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > bipartite_projection_size": {
            "Description": "overrides igraph.GraphBase.bipartite_projection_size\nCalculates the number of vertices and edges in the bipartite projections of this graph according to the specified vertex types. This is useful if you have a bipartite graph and you want to estimate the amount of memory you would need to calculate the projections themselves.",
            "Paramters": {
                "graph": "Undocumented",
                "types": "an igraph vector containing the vertex , or an attribute name. Anything that evalulates to False corresponds to vertices of the first kind, everything else to the second kind.",
                "*args": "Undocumented",
                "**kwds": "Undocumented"
            },
            "Return": [
                "a 4-tuple containing the number of vertices and edges in the first projection, followed by the number of vertices and edges in the second projection."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > blocks": {
            "Description": "Calculates the biconnected components of the graph.",
            "Paramters": {
                "graph": "Undocumented",
                "return_articulation_points": "whether to return the articulation points as well"
            },
            "Return": [
                "a VertexCover object describing the biconnected components, and optionally the list of articulation points as well"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > clear": {
            "Description": "Clears the graph, deleting all vertices, edges, and attributes.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "GraphBase.delete_vertices and Graph.delete_edges.",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > clusters": {
            "Description": "Deprecated alias to Graph.connected_components().",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > cohesive_blocks": {
            "Description": "overrides igraph.GraphBase.cohesive_blocks\nCalculates the cohesive block structure of the graph.\nCohesive blocking is a method of determining hierarchical subsets of graph vertices based on their structural cohesion (i.e. vertex connectivity). For a given graph G, a subset of its vertices S is said to be maximally k-cohesive if there is no superset of S with vertex connectivity greater than or equal to k. Cohesive blocking is a process through which, given a k-cohesive set of vertices, maximally l-cohesive subsets are recursively identified with l > k. Thus a hierarchy of vertex subsets is obtained in the end, with the entire graph G at its root.",
            "Paramters": {},
            "Return": [
                "an instance of CohesiveBlocks. See the documentation of CohesiveBlocks for more information."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "CohesiveBlocks",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > community_edge_betweenness": {
            "Description": "overrides igraph.GraphBase.community_edge_betweenness\nCommunity structure based on the betweenness of the edges in the network.\nThe idea is that the betweenness of the edges connecting two communities is typically high, as many of the shortest paths between nodes in separate communities go through them. So we gradually remove the edge with the highest betweenness and recalculate the betweennesses after every removal. This way sooner or later the network falls of to separate components. The result of the clustering will be represented by a dendrogram.",
            "Paramters": {
                "graph": "Undocumented",
                "clusters": "the number of  we would like to see. This practically defines the \"level\" where we \"cut\" the dendrogram to get the membership vector of the vertices. If None, the dendrogram is cut at the level that maximizes the modularity when the graph is unweighted; otherwise the dendrogram is cut at at a single cluster (because cluster count selection based on modularities does not make sense for this method if not all the weights are equal).",
                "directed": "whether the directionality of the edges should be taken into account or not.",
                "weights": "name of an edge attribute or a list containing edge ."
            },
            "Return": [
                "a VertexDendrogram object, initally cut at the maximum modularity or at the desired number of clusters."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > community_fastgreedy": {
            "Description": "overrides igraph.GraphBase.community_fastgreedy\nCommunity structure based on the greedy optimization of modularity.\nThis algorithm merges individual nodes into communities in a way that greedily maximizes the modularity score of the graph. It can be proven that if no merge can increase the current modularity score, the algorithm can be stopped since no further increase can be achieved.\nThis algorithm is said to run almost in linear time on sparse graphs.\nReference: A Clauset, MEJ Newman and C Moore: Finding community structure in very large networks. Phys Rev E 70, 066111 (2004).",
            "Paramters": {
                "graph": "Undocumented",
                "weights": "edge attribute name or a list containing edge "
            },
            "Return": [
                "an appropriate VertexDendrogram object."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > community_infomap": {
            "Description": "overrides igraph.GraphBase.community_infomap\nFinds the community structure of the network according to the Infomap method of Martin Rosvall and Carl T. Bergstrom.\n",
            "Paramters": {
                "graph": "Undocumented",
                "edge_weights": "name of an edge attribute or a list containing edge weights.",
                "vertex_weights": "name of a vertex attribute or a list containing vertex weights.",
                "trials": "the number of attempts to partition the network."
            },
            "Return": [
                "an appropriate VertexClustering object with an extra attribute called codelength that stores the code length determined by the algorithm."
            ],
            "References": [
                "M. Rosvall and C. T. Bergstrom: Maps of information flow reveal community structure in complex networks, PNAS 105, 1118 (2008). http://dx.doi.org/10.1073/pnas.0706851105, http://arxiv.org/abs/0707.0609.M. Rosvall, D. Axelsson, and C. T. Bergstrom: The map equation, Eur Phys. J Special Topics 178, 13 (2009). http://dx.doi.org/10.1140/epjst/e2010-01179-1, http://arxiv.org/abs/0906.1405."
            ],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > community_label_propagation": {
            "Description": "overrides igraph.GraphBase.community_label_propagation\nFinds the community structure of the graph according to the label propagation method of Raghavan et al.\nInitially, each vertex is assigned a different label. After that, each vertex chooses the dominant label in its neighbourhood in each iteration. Ties are broken randomly and the order in which the vertices are updated is randomized before every iteration. The algorithm ends when vertices reach a consensus.\nNote that since ties are broken randomly, there is no guarantee that the algorithm returns the same community structure after each run. In fact, they frequently differ. See the paper of Raghavan et al. on how to come up with an aggregated community structure.\nAlso note that the community _labels_ (numbers) have no semantic meaning and igraph is free to re-number communities. If you use fixed labels, igraph may still re-number the communities, but co-community membership constraints will be respected: if you had two vertices with fixed labels that belonged to the same community, they will still be in the same community at the end. Similarly, if you had two vertices with fixed labels that belonged to different communities, they will still be in different communities at the end.\nReference: Raghavan, U.N. and Albert, R. and Kumara, S. Near linear time algorithm to detect community structures in large-scale networks. Phys Rev E 76:036106, 2007. http://arxiv.org/abs/0709.2938.",
            "Paramters": {
                "graph": "Undocumented",
                "weights": "name of an edge attribute or a list containing edge ",
                "initial": "name of a vertex attribute or a list containing the  vertex labels. Labels are identified by integers from zero to n\u2009\u2212\u20091 where n is the number of vertices. Negative numbers may also be present in this vector, they represent unlabeled vertices.",
                "fixed": "a list of booleans for each vertex. True corresponds to vertices whose labeling should not change during the algorithm. It only makes sense if initial labels are also given. Unlabeled vertices cannot be . It may also be the name of a vertex attribute; each attribute value will be interpreted as a Boolean."
            },
            "Return": [
                "an appropriate VertexClustering object."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > community_leading_eigenvector": {
            "Description": "overrides igraph.GraphBase.community_leading_eigenvector\nNewman's leading eigenvector method for detecting community structure.\nThis is the proper implementation of the recursive, divisive algorithm: each split is done by maximizing the modularity regarding the original network.\nReference: MEJ Newman: Finding community structure in networks using the eigenvectors of matrices, arXiv:physics/0605087",
            "Paramters": {
                "graph": "Undocumented",
                "clusters": "the desired number of communities. If None, the algorithm tries to do as many splits as possible. Note that the algorithm won't split a community further if the signs of the leading eigenvector are all the same, so the actual number of discovered communities can be less than the desired one.",
                "weights": "name of an edge attribute or a list containing edge .",
                "arpack_options": "an ARPACKOptions object used to fine-tune the ARPACK eigenvector calculation. If omitted, the module-level variable called  is used."
            },
            "Return": [
                "an appropriate VertexClustering object."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > community_leiden": {
            "Description": "overrides igraph.GraphBase.community_leiden\nFinds the community structure of the graph using the Leiden algorithm of Traag, van Eck & Waltman.\nReference: Traag, V. A., Waltman, L., & van Eck, N. J. (2019). From Louvain to Leiden: guaranteeing well-connected communities. Scientific Reports, 9(1), 5233. doi: 10.1038/s41598-019-41695-z",
            "Paramters": {
                "graph": "Undocumented",
                "objective_function": "whether to use the Constant Potts Model (CPM) or modularity. Must be either \"CPM\" or \"modularity\".",
                "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name.",
                "resolution": "the  parameter to use. Higher s lead to more smaller communities, while lower s lead to fewer larger communities.",
                "beta": "parameter affecting the randomness in the Leiden algorithm. This affects only the refinement step of the algorithm.",
                "initial_membership": "if provided, the Leiden algorithm will try to improve this provided membership. If no argument is provided, the aglorithm simply starts from the singleton partition.",
                "n_iterations": "the number of iterations to iterate the Leiden algorithm. Each iteration may improve the partition further. Using a negative number of iterations will run until a stable iteration is encountered (i.e. the quality was not increased during that iteration).",
                "node_weights": "the node weights used in the Leiden algorithm. If this is not provided, it will be automatically determined on the basis of whether you want to use CPM or modularity. If you do provide this, please make sure that you understand what you are doing.",
                "**kwds": "Undocumented"
            },
            "Return": [
                "an appropriate VertexClustering object with an extra attribute called quality that stores the value of the internal quality function optimized by the algorithm."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > community_multilevel": {
            "Description": "overrides igraph.GraphBase.community_multilevel\nCommunity structure based on the multilevel algorithm of Blondel et al.\nThis is a bottom-up algorithm: initially every vertex belongs to a separate community, and vertices are moved between communities iteratively in a way that maximizes the vertices' local contribution to the overall modularity score. When a consensus is reached (i.e. no single move would increase the modularity score), every community in the original graph is shrunk to a single vertex (while keeping the total weight of the incident edges) and the process continues on the next level. The algorithm stops when it is not possible to increase the modularity anymore after shrinking the communities to vertices.\nThis algorithm is said to run almost in linear time on sparse graphs.\nReference: VD Blondel, J-L Guillaume, R Lambiotte and E Lefebvre: Fast unfolding of community hierarchies in large networks, J Stat Mech P10008 (2008). http://arxiv.org/abs/0803.0476",
            "Paramters": {
                "graph": "Undocumented",
                "weights": "edge attribute name or a list containing edge ",
                "return_levels": "if True, the communities at each level are returned in a list. If False, only the community structure with the best modularity is returned.",
                "resolution": "the  parameter to use in the modularity measure. Smaller values result in a smaller number of larger clusters, while higher values yield a large number of small clusters. The classical modularity measure assumes a  parameter of 1."
            },
            "Return": [
                "a list of VertexClustering objects, one corresponding to each level (if return_levels is True), or a VertexClustering corresponding to the best modularity."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > community_optimal_modularity": {
            "Description": "overrides igraph.GraphBase.community_optimal_modularity\nCalculates the optimal modularity score of the graph and the corresponding community structure.\nThis function uses the GNU Linear Programming Kit to solve a large integer optimization problem in order to find the optimal modularity score and the corresponding community structure, therefore it is unlikely to work for graphs larger than a few (less than a hundred) vertices. Consider using one of the heuristic approaches instead if you have such a large graph.",
            "Paramters": {},
            "Return": [
                "the calculated membership vector and the corresponding modularity in a tuple."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > community_spinglass": {
            "Description": "overrides igraph.GraphBase.community_spinglass\nFinds the community structure of the graph according to the spinglass community detection method of Reichardt & Bornholdt.\n",
            "Paramters": {
                "graph": "Undocumented",
                "*args": "Undocumented",
                "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name.",
                "spins": "integer, the number of  to use. This is the upper limit for the number of communities. It is not a problem to supply a (reasonably) big number here, in which case some spin states will be unpopulated.",
                "parupdate": "whether to update the spins of the vertices in parallel (synchronously) or not",
                "start_temp": "the starting temperature",
                "stop_temp": "the stop temperature",
                "cool_fact": "cooling factor for the simulated annealing",
                "update_rule": "specifies the null model of the simulation. Possible values are \"config\" (a random graph with the same vertex degrees as the input graph) or \"simple\" (a random graph with the same number of edges)",
                "gamma": "the  argument of the algorithm, specifying the balance between the importance of present and missing edges within a community. The default value of 1.0 assigns equal importance to both of them.",
                "implementation": "currently igraph contains two s of the spinglass community detection algorithm. The faster original  is the default. The other  is able to take into account negative weights, this can be chosen by setting  to \"neg\"",
                "lambda_": "the lambda argument of the algorithm, which specifies the balance between the importance of present and missing negatively weighted edges within a community. Smaller values of lambda lead to communities with less negative intra-connectivity. If the argument is zero, the algorithm reduces to a graph coloring algorithm, using the number of spins as colors. This argument is ignored if the original implementation is used. Note the underscore at the end of the argument name; this is due to the fact that lambda is a reserved keyword in Python."
            },
            "Return": [
                "an appropriate VertexClustering object."
            ],
            "References": [
                "Reichardt J and Bornholdt S: Statistical mechanics of community detection. Phys Rev E 74:016110 (2006). http://arxiv.org/abs/cond-mat/0603718.Traag VA and Bruggeman J: Community detection in networks with positive and negative links. Phys Rev E 80:036115 (2009). http://arxiv.org/abs/0811.2329."
            ],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > community_walktrap": {
            "Description": "overrides igraph.GraphBase.community_walktrap\nCommunity detection algorithm of Latapy & Pons, based on random walks.\nThe basic idea of the algorithm is that short random walks tend to stay in the same community. The result of the clustering will be represented as a dendrogram.\nReference: Pascal Pons, Matthieu Latapy: Computing communities in large networks using random walks, http://arxiv.org/abs/physics/0512106.",
            "Paramters": {
                "graph": "Undocumented",
                "weights": "name of an edge attribute or a list containing edge ",
                "steps": "length of random walks to perform"
            },
            "Return": [
                "a VertexDendrogram object, initially cut at the maximum modularity."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > components": {
            "Description": "Calculates the (strong or weak) connected components for a given graph.",
            "Paramters": {
                "graph": "Undocumented",
                "mode": "must be either \"strong\" or \"weak\", depending on the connected components being sought. Optional, defaults to \"strong\"."
            },
            "Return": [
                "a VertexClustering object"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > connected_components": {
            "Description": "overrides igraph.GraphBase.connected_components\nCalculates the (strong or weak) connected components for a given graph.",
            "Paramters": {
                "graph": "Undocumented",
                "mode": "must be either \"strong\" or \"weak\", depending on the connected components being sought. Optional, defaults to \"strong\"."
            },
            "Return": [
                "a VertexClustering object"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > count_automorphisms_vf2": {
            "Description": "Returns the number of automorphisms of the graph.\nThis function simply calls count_isomorphisms_vf2 with the graph itgraph. See count_isomorphisms_vf2 for an explanation of the parameters.",
            "Paramters": {},
            "Return": [
                "the number of automorphisms of the graph"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "Graph.count_isomorphisms_vf2",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > degree_distribution": {
            "Description": "Calculates the degree distribution of the graph.\nUnknown keyword arguments are directly passed to GraphBase.degree.",
            "Paramters": {
                "graph": "Undocumented",
                "bin_width": "the bin width of the histogram",
                "*args": "Undocumented",
                "**kwds": "Undocumented"
            },
            "Return": [
                "a histogram representing the degree distribution of the graph."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > delete_edges": {
            "Description": "overrides igraph.GraphBase.delete_edges\nDeletes some edges from the graph.\nThe set of edges to be deleted is determined by the positional and keyword arguments. If the function is called without any arguments, all edges are deleted. If any keyword argument is present, or the first positional argument is callable, an edge sequence is derived by calling EdgeSeq.select with the same positional and keyword arguments. Edges in the derived edge sequence will be removed. Otherwise, the first positional argument is considered as follows:\nDeprecation notice: delete_edges(None) has been replaced by delete_edges() - with no arguments - since igraph 0.8.3.None - deletes all edges (deprecated since 0.8.3)a single integer - deletes the edge with the given IDa list of integers - deletes the edges denoted by the given IDsa list of 2-tuples - deletes the edges denoted by the given source-target vertex pairs. When multiple edges are present between a given source-target vertex pair, only one is removed.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > dfs": {
            "Description": "Conducts a depth first search (DFS) on the graph.",
            "Paramters": {
                "vid": "the root vertex ID",
                "mode": "either \"in\" or \"out\" or \"all\", ignored for undirected graphs."
            },
            "Return": [
                "a tuple with the following items:\n\nThe vertex IDs visited (in order)\nThe parent of every vertex in the DFS\n\n"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > disjoint_union": {
            "Description": "Creates the disjoint union of two (or more) graphs.",
            "Paramters": {
                "graph": "Undocumented",
                "other": "graph or list of graphs to be united with the current one."
            },
            "Return": [
                "the disjoint union graph"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > dyad_census": {
            "Description": "overrides igraph.GraphBase.dyad_census\nCalculates the dyad census of the graph.\nDyad census means classifying each pair of vertices of a directed graph into three categories: mutual (there is an edge from a to b and also from b to a), asymmetric (there is an edge from a to b or from b to a but not the other way round) and null (there is no connection between a and b).\nReference: Holland, P.W. and Leinhardt, S. A Method for Detecting Structure in Sociometric Data. American Journal of Sociology, 70, 492-513, 1970.",
            "Paramters": {},
            "Return": [
                "a DyadCensus object."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > get_adjacency": {
            "Description": "overrides igraph.GraphBase.get_adjacency\nReturns the adjacency matrix of a graph.",
            "Paramters": {
                "type": "either GET_ADJACENCY_LOWER (uses the lower triangle of the matrix) or GET_ADJACENCY_UPPER (uses the upper triangle) or GET_ADJACENCY_BOTH (uses both parts). Ignored for directed graphs.",
                "attribute": "if None, returns the ordinary adjacency matrix. When the name of a valid edge  is given here, the matrix returned will contain the default value at the places where there is no edge or the value of the given  where there is an edge. Multiple edges are not supported, the value written in the matrix in this case will be unpredictable. This parameter is ignored if eids is True",
                "default": "the  value written to the cells in the case of adjacency matrices with attributes.",
                "eids": "specifies whether the edge IDs should be returned in the adjacency matrix. Since zero is a valid edge ID, the cells in the matrix that correspond to unconnected vertex pairs will contain -1 instead of 0 if  is True. If  is False, the number of edges will be returned in the matrix for each vertex pair."
            },
            "Return": [
                "the adjacency matrix as a Matrix."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > get_adjacency_sparse": {
            "Description": "Returns the adjacency matrix of a graph as a SciPy CSR matrix.",
            "Paramters": {
                "attribute": "if None, returns the ordinary adjacency matrix. When the name of a valid edge  is given here, the matrix returned will contain the default value at the places where there is no edge or the value of the given  where there is an edge."
            },
            "Return": [
                "the adjacency matrix as a scipy.sparse.csr_matrix."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > get_adjlist": {
            "Description": "Returns the adjacency list representation of the graph.\nThe adjacency list representation is a list of lists. Each item of the outer list belongs to a single vertex of the graph. The inner list contains the neighbors of the given vertex.",
            "Paramters": {
                "mode": "if \"out\", returns the successors of the vertex. If \"in\", returns the predecessors of the vertex. If \"all\", both the predecessors and the successors will be returned. Ignored for undirected graphs."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > get_all_simple_paths": {
            "Description": "Calculates all the simple paths from a given node to some other nodes (or all of them) in a graph.\nA path is simple if its vertices are unique, i.e. no vertex is visited more than once.\nNote that potentially there are exponentially many paths between two vertices of a graph, especially if your graph is lattice-like. In this case, you may run out of memory when using this function.",
            "Paramters": {
                "v": "the source for the calculated paths",
                "to": "a vertex selecr describing the destination for the calculated paths. This can be a single vertex ID, a list of vertex IDs, a single vertex name, a list of vertex names or a VertexSeq object. None means all the vertices.",
                "cutoff": "maximum length of path that is considered. If negative, paths of all lengths are considered.",
                "mode": "the directionality of the paths. \"in\" means to calculate incoming paths, \"out\" means to calculate outgoing paths, \"all\" means to calculate both ones."
            },
            "Return": [
                "all of the simple paths from the given node to every other reachable node in the graph in a list. Note that in case of mode=\"in\", the vertices in a path are returned in reversed order!"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > get_automorphisms_vf2": {
            "Description": "Returns all the automorphisms of the graph\nThis function simply calls get_isomorphisms_vf2 with the graph itgraph. See get_isomorphisms_vf2 for an explanation of the parameters.",
            "Paramters": {},
            "Return": [
                "a list of lists, each item containing a possible mapping of the graph vertices to itgraph according to the automorphism"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "Graph.get_isomorphisms_vf2",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > get_biadjacency": {
            "Description": "overrides igraph.GraphBase.get_biadjacency\nReturns the bipartite adjacency matrix of a bipartite graph. The bipartite adjacency matrix is an n times m matrix, where n and m are the number of vertices in the two vertex classes.",
            "Paramters": {
                "graph": "Undocumented",
                "types": "an igraph vector containing the vertex , or an attribute name. Anything that evalulates to False corresponds to vertices of the first kind, everything else to the second kind.",
                "*args": "Undocumented",
                "**kwds": "Undocumented"
            },
            "Return": [
                "the bipartite adjacency matrix and two lists in a triplet. The first list defines the mapping between row indices of the matrix and the original vertex IDs. The second list is the same for the column indices."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > get_edge_dataframe": {
            "Description": "Export edges with attributes to pandas.DataFrame\nIf you want to use source and target vertex IDs as index, you can do:",
            "Paramters": {},
            "Return": [
                "a pandas.DataFrame representing edges and their attributes. The index uses edge IDs, from 0 to M - 1 where M is the number of edges. The first two columns of the dataframe represent the IDs of source and target vertices for each edge. These columns have names \"source\" and \"target\". If your edges have attributes with the same names, they will be present in the dataframe, but not in the first two columns."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": [
                "If you want to use source and target vertex IDs as index, you can do:\n>>> from string import ascii_letters\n>>> graph = Graph.GRG(25, 0.4)\n>>> graph.vs[\"name\"] = ascii_letters[:graph.vcount()]\n>>> df = graph.get_edge_dataframe()\n>>> df.set_index(['source', 'target'], inplace=True)",
                "If you want to use vertex names in the source and target columns:\n>>> from string import ascii_letters\n>>> graph = Graph.GRG(25, 0.4)\n>>> graph.vs[\"name\"] = ascii_letters[:graph.vcount()]\n>>> df = graph.get_edge_dataframe()\n>>> df.set_index(['source', 'target'], inplace=True)"
            ]
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > get_incidence": {
            "Description": "Deprecated alias to Graph.get_biadjacency().",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > get_inclist": {
            "Description": "Returns the incidence list representation of the graph.\nThe incidence list representation is a list of lists. Each item of the outer list belongs to a single vertex of the graph. The inner list contains the IDs of the incident edges of the given vertex.",
            "Paramters": {
                "graph": "Undocumented",
                "mode": "if \"out\", returns the successors of the vertex. If \"in\", returns the predecessors of the vertex. If \"all\", both the predecessors and the successors will be returned. Ignored for undirected graphs."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > get_vertex_dataframe": {
            "Description": "Export vertices with attributes to pandas.DataFrame\nIf you want to use vertex names as index, you can do:",
            "Paramters": {},
            "Return": [
                "a pandas.DataFrame representing vertices and their attributes. The index uses vertex IDs, from 0 to N - 1 where N is the number of vertices."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": [
                "If you want to use vertex names as index, you can do:\n>>> from string import ascii_letters\n>>> graph = Graph.GRG(25, 0.4)\n>>> graph.vs[\"name\"] = ascii_letters[:graph.vcount()]\n>>> df = graph.get_vertex_dataframe()\n>>> df.set_index('name', inplace=True)"
            ]
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > gomory_hu_tree": {
            "Description": "overrides igraph.GraphBase.gomory_hu_tree\nCalculates the Gomory-Hu tree of an undirected graph with optional edge capacities.\nThe Gomory-Hu tree is a concise representation of the value of all the maximum flows (or minimum cuts) in a graph. The vertices of the tree correspond exactly to the vertices of the original graph in the same order. Edges of the Gomory-Hu tree are annotated by flow values.  The value of the maximum flow (or minimum cut) between an arbitrary (u,v) vertex pair in the original graph is then given by the minimum flow value (i.e. edge annotation) along the shortest path between u and v in the Gomory-Hu tree.",
            "Paramters": {
                "graph": "Undocumented",
                "capacity": "the edge capacities (weights). If None, all edges have equal weight. May also be an attribute name.",
                "flow": "the name of the edge attribute in the returned graph in which the  values will be stored."
            },
            "Return": [
                "the Gomory-Hu tree as a Graph object."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > indegree": {
            "Description": "Returns the in-degrees in a list.\nSee GraphBase.degree for possible arguments.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > intersection": {
            "Description": "Creates the intersection of two (or more) graphs.",
            "Paramters": {
                "graph": "Undocumented",
                "other": "graph or list of graphs to be intersected with the current one.",
                "byname": "whether to use vertex names instead of ids. See igraph.operators.intersection for details."
            },
            "Return": [
                "the intersection graph"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > is_named": {
            "Description": "Returns whether the graph is named.\nA graph is named if and only if it has a \"name\" vertex attribute.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > is_weighted": {
            "Description": "Returns whether the graph is weighted.\nA graph is weighted if and only if it has a \"weight\" edge attribute.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > k_core": {
            "Description": "Returns some k-cores of the graph.\nThe method accepts an arbitrary number of arguments representing the desired indices of the k-cores to be returned. The arguments can also be lists or tuples. The result is a single Graph object if an only integer argument was given, otherwise the result is a list of Graph objects representing the desired k-cores in the order the arguments were specified. If no argument is given, returns all k-cores in increasing order of k.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > layout": {
            "Description": "Returns the layout of the graph according to a layout algorithm.\nParameters and keyword arguments not specified here are passed to the layout algorithm directly. See the documentation of the layout algorithms for the explanation of these parameters.\nRegistered layout names understood by this method are:auto, automatic: automatic layout (see Graph.layout_auto)bipartite: bipartite layout (see GraphBase.layout_bipartite)circle, circular: circular layout (see GraphBase.layout_circle)dh, davidson_harel: Davidson-Harel layout (see GraphBase.layout_davidson_harel)drl: DrL layout for large graphs (see GraphBase.layout_drl)drl_3d: 3D DrL layout for large graphs (see GraphBase.layout_drl)fr, fruchterman_reingold: Fruchterman-Reingold layout (see GraphBase.layout_fruchterman_reingold).fr_3d, fr3d, fruchterman_reingold_3d: 3D Fruchterman- Reingold layout (see GraphBase.layout_fruchterman_reingold).grid: regular grid layout in 2D (see GraphBase.layout_grid)grid_3d: regular grid layout in 3D (see GraphBase.layout_grid)graphopt: the graphopt algorithm (see GraphBase.layout_graphopt)kk, kamada_kawai: Kamada-Kawai layout (see GraphBase.layout_kamada_kawai)kk_3d, kk3d, kamada_kawai_3d: 3D Kamada-Kawai layout (see GraphBase.layout_kamada_kawai)lgl, large, large_graph: Large Graph Layout (see GraphBase.layout_lgl)mds: multidimensional scaling layout (see GraphBase.layout_mds)random: random layout (see GraphBase.layout_random)random_3d: random 3D layout (see GraphBase.layout_random)rt, tree, reingold_tilford: Reingold-Tilford tree layout (see GraphBase.layout_reingold_tilford)rt_circular, reingold_tilford_circular: circular Reingold-Tilford tree layout (see GraphBase.layout_reingold_tilford_circular)sphere, spherical, circle_3d, circular_3d: spherical layout (see GraphBase.layout_circle)star: star layout (see GraphBase.layout_star)sugiyama: Sugiyama layout (see Graph.layout_sugiyama)",
            "Paramters": {
                "graph": "Undocumented",
                "layout": "the  to use. This can be one of the registered  names or a callable which returns either a Layout object or a list of lists containing the coordinates. If None, uses the value of the plotting. configuration key.",
                "*args": "Undocumented",
                "**kwds": "Undocumented"
            },
            "Return": [
                "a Layout object."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > layout_auto": {
            "Description": "Chooses and runs a suitable layout function based on simple topological properties of the graph.\nThis function tries to choose an appropriate layout function for the graph using the following rules:If the graph has an attribute called layout, it will be used. It may either be a Layout instance, a list of coordinate pairs, the name of a layout function, or a callable function which generates the layout when called with the graph as a parameter.Otherwise, if the graph has vertex attributes called x and y, these will be used as coordinates in the layout. When a 3D layout is requested (by setting dim to 3), a vertex attribute named z will also be needed.Otherwise, if the graph is connected and has at most 100 vertices, the Kamada-Kawai layout will be used (see GraphBase.layout_kamada_kawai()).Otherwise, if the graph has at most 1000 vertices, the Fruchterman-Reingold layout will be used (see GraphBase.layout_fruchterman_reingold()).If everything else above failed, the DrL layout algorithm will be used (see GraphBase.layout_drl()).\nAll the arguments of this function except dim are passed on to the chosen layout function (in case we have to call some layout function).",
            "Paramters": {
                "graph": "Undocumented",
                "*args": "Undocumented",
                "dim": "specifies whether we would like to obtain a 2D or a 3D layout."
            },
            "Return": [
                "a Layout object."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > layout_sugiyama": {
            "Description": "Places the vertices using a layered Sugiyama layout.\nThis is a layered layout that is most suitable for directed acyclic graphs, although it works on undirected or cyclic graphs as well.\nEach vertex is assigned to a layer and each layer is placed on a horizontal line. Vertices within the same layer are then permuted using the barycenter heuristic that tries to minimize edge crossings.\nDummy vertices will be added on edges that span more than one layer. The returned layout therefore contains more rows than the number of nodes in the original graph; the extra rows correspond to the dummy vertices.\n",
            "Paramters": {
                "graph": "Undocumented",
                "layers": "a vector specifying a non-negative integer layer index for each vertex, or the name of a numeric vertex attribute that contains the layer indices. If None, a layering will be determined automatically. For undirected graphs, a spanning tree will be extracted and vertices will be assigned to  using a breadth first search from the node with the largest degree. For directed graphs, cycles are broken by reversing the direction of edges in an approximate feedback arc set using the heuristic of Eades, Lin and Smyth, and then using longest path layering to place the vertices in .",
                "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name.",
                "hgap": "minimum horizontal gap between vertices in the same layer.",
                "vgap": "vertical gap between layers. The layer index will be multiplied by  to obtain the Y coordinate.",
                "maxiter": "maximum number of iterations to take in the crossing reduction step. Increase this if you feel that you are getting too many edge crossings.",
                "return_extended_graph": "specifies that the extended graph with the added dummy vertices should also be returned. When this is True, the result will be a tuple containing the layout and the extended graph. The first |V| nodes of the extended graph will correspond to the nodes of the original graph, the remaining ones are dummy nodes. Plotting the extended graph with the returned layout and hidden dummy nodes will produce a layout that is similar to the original graph, but with the added edge bends. The extended graph also contains an edge attribute called _original_eid which specifies the ID of the edge in the original graph from which the edge of the extended graph was created."
            },
            "Return": [
                "the calculated layout, which may (and usually will) have more rows than the number of vertices; the remaining rows correspond to the dummy nodes introduced in the layering step. When return_extended_graph is True, it will also contain the extended graph."
            ],
            "References": [
                ":K Sugiyama, S Tagawa, M Toda: Methods for visual understanding of hierarchical system structures. IEEE Systems, Man and Cybernetics 11(2):109-125, 1981.P Eades, X Lin and WF Smyth: A fast effective heuristic for the feedback arc set problem. Information Processing Letters 47:319-323, 1993."
            ],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > maxflow": {
            "Description": "overrides igraph.GraphBase.maxflow\nReturns a maximum flow between the given source and target vertices in a graph.\nA maximum flow from source to target is an assignment of non-negative real numbers to the edges of the graph, satisfying two properties:For each edge, the flow (i.e. the assigned number) is not more than the capacity of the edge (see the capacity argument)For every vertex except the source and the target, the incoming flow is the same as the outgoing flow.\nThe value of the flow is the incoming flow of the target or the outgoing flow of the source (which are equal). The maximum flow is the maximum possible such value.",
            "Paramters": {
                "graph": "Undocumented",
                "source": "Undocumented",
                "target": "Undocumented",
                "capacity": "the edge capacities (weights). If None, all edges have equal weight. May also be an attribute name."
            },
            "Return": [
                "a Flow object describing the maximum flow"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > maximum_bipartite_matching": {
            "Description": "Finds a maximum matching in a bipartite graph.\nA maximum matching is a set of edges such that each vertex is incident on at most one matched edge and the number (or weight) of such edges in the set is as large as possible.",
            "Paramters": {
                "graph": "Undocumented",
                "types": "vertex  in a list or the name of a vertex attribute holding vertex . Types should be denoted by zeros and ones (or False and True) for the two sides of the bipartite graph. If omitted, it defaults to type, which is the default vertex type attribute for bipartite graphs.",
                "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name.",
                "eps": "a small real number used in equality tests in the weighted bipartite matching algorithm. Two real numbers are considered equal in the algorithm if their difference is smaller than this value. This is required to avoid the accumulation of numerical errors. If you pass None here, igraph will try to determine an appropriate value automatically."
            },
            "Return": [
                "an instance of Matching."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > mincut": {
            "Description": "overrides igraph.GraphBase.mincut\nCalculates the minimum cut between the given source and target vertices or within the whole graph.\nThe minimum cut is the minimum set of edges that needs to be removed to separate the source and the target (if they are given) or to disconnect the graph (if neither the source nor the target are given). The minimum is calculated using the weights (capacities) of the edges, so the cut with the minimum total capacity is calculated.\nFor undirected graphs and no source and target, the method uses the Stoer-Wagner algorithm. For a given source and target, the method uses the push-relabel algorithm; see the references below.",
            "Paramters": {
                "graph": "Undocumented",
                "source": "the  vertex ID. If None, the target must also be None and the calculation will be done for the entire graph (i.e. all possible vertex pairs).",
                "target": "the  vertex ID. If None, the source must also be None and the calculation will be done for the entire graph (i.e. all possible vertex pairs).",
                "capacity": "the edge capacities (weights). If None, all edges have equal weight. May also be an attribute name."
            },
            "Return": [
                "a Cut object describing the minimum cut"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > modularity": {
            "Description": "overrides igraph.GraphBase.modularity\nCalculates the modularity score of the graph with respect to a given clustering.\nThe modularity of a graph w.r.t. some division measures how good the division is, or how separated are the different vertex types from each other. It's defined as Q\u2009=\u20091\u2009\u2044\u2009(2m)*sum(Aij\u2009\u2212\u2009gamma*ki*kj\u2009\u2044\u2009(2m)delta(ci,\u2009cj),\u2009i,\u2009j). m is the number of edges, Aij is the element of the A adjacency matrix in row i and column j, ki is the degree of node i, kj is the degree of node j, and Ci and cj are the types of the two vertices (i and j), and gamma is a resolution parameter that defaults to 1 for the classical definition of modularity. delta(x,\u2009y) is one iff x\u2009=\u2009y, 0 otherwise.\nIf edge weights are given, the definition of modularity is modified as follows: Aij becomes the weight of the corresponding edge, ki is the total weight of edges adjacent to vertex i, kj is the total weight of edges adjacent to vertex j and m is the total edge weight in the graph.\nReference: MEJ Newman and M Girvan: Finding and evaluating community structure in networks. Phys Rev E 69 026113, 2004.",
            "Paramters": {
                "membership": "a  list or a VertexClustering object",
                "weights": "optional edge  or None if all edges are weighed equally. Attribute names are also allowed.",
                "resolution": "the  parameter gamma in the formula above. The classical definition of modularity is retrieved when the  parameter is set to 1.",
                "directed": "whether to consider edge directions if the graph is . True will use the  variant of the modularity measure where the in- and out-degrees of nodes are treated separately; False will treat  graphs as un."
            },
            "Return": [
                "the modularity score"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > outdegree": {
            "Description": "Returns the out-degrees in a list.\nSee GraphBase.degree for possible arguments.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > pagerank": {
            "Description": "Calculates the PageRank values of a graph.",
            "Paramters": {
                "graph": "Undocumented",
                "vertices": "the indices of the  being queried. None means all of the .",
                "directed": "whether to consider  paths.",
                "damping": "the  factor. 1\u2009\u2212\u2009 is the probability of resetting the random walk to a uniform distribution in each step.",
                "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name.",
                "arpack_options": "an ARPACKOptions object used to fine-tune the ARPACK eigenvector calculation. If omitted, the module-level variable called  is used. This argument is ignored if not the ARPACK implementation is used, see the implementation argument.",
                "implementation": "which  to use to solve the PageRank eigenproblem. Possible values are:\"prpack\": use the PRPACK library. This is a new  in igraph 0.7\"arpack\": use the ARPACK library. This  was used from version 0.5, until version 0.7."
            },
            "Return": [
                "a list with the PageRank values of the specified vertices."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > path_length_hist": {
            "Description": "overrides igraph.GraphBase.path_length_hist\nReturns the path length histogram of the graph",
            "Paramters": {
                "directed": "whether to consider  paths. Ignored for un graphs."
            },
            "Return": [
                "a Histogram object. The object will also have an unconnected attribute that stores the number of unconnected vertex pairs (where the second vertex can not be reached from the first one). The latter one will be of type long (and not a simple integer), since this can be very large."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > shortest_paths": {
            "Description": "Deprecated alias to Graph.distances().",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > spanning_tree": {
            "Description": "Calculates a minimum spanning tree for a graph.\nReference: Prim, R.C. Shortest connection networks and some generalizations. Bell System Technical Journal 36:1389-1401, 1957.",
            "Paramters": {
                "weights": "a vector containing  for every edge in the graph. None means that the graph is unweighted.",
                "return_tree": "whether to return the minimum spanning tree (when  is True) or to return the IDs of the edges in the minimum spanning tree instead (when  is False). The default is True for historical reasons as this argument was introduced in igraph 0.6."
            },
            "Return": [
                "the spanning tree as a Graph object if return_tree is True or the IDs of the edges that constitute the spanning tree if return_tree is False."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > st_mincut": {
            "Description": "overrides igraph.GraphBase.st_mincut\nCalculates the minimum cut between the source and target vertices in a graph.",
            "Paramters": {
                "graph": "Undocumented",
                "source": "the  vertex ID",
                "target": "the  vertex ID",
                "capacity": "the  of the edges. It must be a list or a valid attribute name or None. In the latter case, every edge will have the same ."
            },
            "Return": [
                "the value of the minimum cut, the IDs of vertices in the first and second partition, and the IDs of edges in the cut, packed in a 4-tuple"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > summary": {
            "Description": "Returns the summary of the graph.\nThe output of this method is similar to the output of the __str__ method. If verbosity is zero, only the header line is returned (see __str__ for more details), otherwise the header line and the edge list is printed.\nBehind the scenes, this method constructs a GraphSummary object and invokes its __str__ method.",
            "Paramters": {
                "verbosity": "if zero, only the header line is returned (see __str__ for more details), otherwise the header line and the full edge list is printed.",
                "width": "the number of characters to use in one line. If None, no limit will be enforced on the line lengths.",
                "*args": "Undocumented",
                "**kwds": "Undocumented"
            },
            "Return": [
                "the summary of the graph."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > to_dict_dict": {
            "Description": "Export graph to dictionary of dicts of edge attributes\nThis function is the reverse of Graph.DictDict.\nExample:",
            "Paramters": {
                "graph": "Undocumented",
                "use_vids": ":boolwhether to label vertices in the output data structure by their ids or their vertex_name_attr attribute. If =False but vertices lack a vertex_name_attr attribute, an AttributeError is raised.",
                "edge_attrs": ":Union[str, Sequence[str]]list of edge attributes to export. None (default) signified all attributes (unlike Graph.to_tuple_list). A string is acceptable to signify a single attribute and will be wrapped in a list internally.",
                "skip_none": ":boolwhether to skip, for each edge, attributes that have a value of None. This is useful if only some edges are expected to possess an attribute.",
                "vertex_name_attr": ":stronly used with use_vids=False to choose what vertex attribute to use to name your vertices in the output data structure."
            },
            "Return": [
                "dictionary of dictionaries of dictionaries, with the outer keys vertex ids/names, the middle keys ids/names of their neighbors, and the innermost dictionary representing attributes of that edge."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": [
                "Example:\n>>> g = Graph.Full(3)\n>>> g.es['name'] = ['first_edge', 'second', 'third']\n>>> g.to_dict_dict()\n{0: {1: {'name': 'first_edge'}, 2: {'name': 'second'}}, 1: {2: {'name': 'third'}}}\n"
            ]
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > to_dict_list": {
            "Description": "Export graph as two lists of dictionaries, for vertices and edges.\nThis function is the reverse of Graph.DictList.\nExample:",
            "Paramters": {
                "graph": "Undocumented",
                "use_vids": ":boolwhether to label vertices in the output data structure by their ids or their vertex_name_attr attribute. If =False but vertices lack a vertex_name_attr attribute, an AttributeError is raised.",
                "skip_none": ":boolwhether to skip, for each edge, attributes that have a value of None. This is useful if only some edges are expected to possess an attribute.",
                "vertex_name_attr": ":stronly used with use_vids=False to choose what vertex attribute to use to name your vertices in the output data structure."
            },
            "Return": [
                "a tuple with two lists of dictionaries, representing the vertices and the edges, respectively, with their attributes."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": [
                "Example:\n>>> g = Graph([(0, 1), (1, 2)])\n>>> g.vs[\"name\"] = [\"apple\", \"pear\", \"peach\"]\n>>> g.es[\"name\"] = [\"first_edge\", \"second\"]",
                ">>> g = Graph([(0, 1), (1, 2)])\n>>> g.vs[\"name\"] = [\"apple\", \"pear\", \"peach\"]\n>>> g.es[\"name\"] = [\"first_edge\", \"second\"]",
                ">>> g = Graph([(0, 1), (1, 2)])\n>>> g.vs[\"name\"] = [\"apple\", \"pear\", \"peach\"]\n>>> g.es[\"name\"] = [\"first_edge\", \"second\"]"
            ]
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > to_graph_tool": {
            "Description": "Converts the graph to graph-tool\nData types: graph-tool only accepts specific data types. See the following web page for a list:\nhttps://graph-tool.skewed.de/static/doc/quickstart.html\nNote: because of the restricted data types in graph-tool, vertex and edge attributes require to be type-consistent across all vertices or edges. If you set the property for only some vertices/edges, the other will be tagged as None in igraph, so they can only be converted to graph-tool with the type 'object' and any other conversion will fail.",
            "Paramters": {
                "graph": "Undocumented",
                "graph_attributes": "dictionary of graph attributes to transfer. Keys are attributes from the graph, values are data types (see below). None means no graph attributes are transferred.",
                "vertex_attributes": "dictionary of vertex attributes to transfer. Keys are attributes from the vertices, values are data types (see below). None means no vertex attributes are transferred.",
                "edge_attributes": "dictionary of edge attributes to transfer. Keys are attributes from the edges, values are data types (see below). None means no vertex attributes are transferred."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > to_list_dict": {
            "Description": "Export graph to a dictionary of lists (or other sequences).\nThis function is the reverse of Graph.ListDict.\nExample:",
            "Paramters": {
                "graph": "Undocumented",
                "use_vids": ":boolwhether to label vertices in the output data structure by their ids or their vertex_name_attr attribute. If =False but vertices lack a vertex_name_attr attribute, an AttributeError is raised.",
                "sequence_constructor": ":callableconstructor for the data structure to be used as values of the dictionary. The default (list) makes a dict of lists, with each list representing the neighbors of the vertex specified in the respective dictionary key.",
                "vertex_name_attr": ":stronly used with use_vids=False to choose what vertex attribute to use to name your vertices in the output data structure."
            },
            "Return": [
                "dictionary of sequences, keyed by vertices, with each value containing the neighbors of that vertex."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": [
                "Example:\n>>> g = Graph.Full(3)\n>>> g.to_sequence_dict() -> {0: [1, 2], 1: [2]}\n>>> g.to_sequence_dict(sequence_constructor=tuple) -> {0: (1, 2), 1: (2,)}\n>>> g.vs['name'] = ['apple', 'pear', 'peach']\n>>> g.to_sequence_dict(use_vids=False)\n{'apple': ['pear', 'peach'], 'pear': ['peach']}\n"
            ]
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > to_networkx": {
            "Description": "Converts the graph to networkx format.\nigraph has ordered vertices and edges, but networkx does not. To keep track of the original order, the '_igraph_index' vertex property is added to both vertices and edges.",
            "Paramters": {
                "graph": "Undocumented",
                "create_using": "specifies which NetworkX graph class to use when constructing the graph. None means to let igraph infer the most appropriate class based on whether the graph is directed and whether it has multi-edges.",
                "vertex_attr_hashable": ":strvertex attribute used to name vertices in the exported network. The default \"_nx_name\" ensures round trip conversions to/from networkx are lossless."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > to_tuple_list": {
            "Description": "Export graph to a list of edge tuples\nThis function is the reverse of Graph.TupleList.\nExample:",
            "Paramters": {
                "graph": "Undocumented",
                "use_vids": ":boolwhether to label vertices in the output data structure by their ids or their vertex_name_attr attribute. If =False but vertices lack a vertex_name_attr attribute, an AttributeError is raised.",
                "edge_attrs": ":Union[str, Sequence[str]]list of edge attributes to export in addition to source and target vertex, which are always the first two elements of each tuple. None (default) is equivalent to an empty list. A string is acceptable to signify a single attribute and will be wrapped in a list internally.",
                "vertex_name_attr": ":stronly used with use_vids=False to choose what vertex attribute to use to name your vertices in the output data structure."
            },
            "Return": [
                "a list of tuples, each representing an edge of the graph."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": [
                "Example:\n>>> g = Graph.Full(3)\n>>> g.vs[\"name\"] = [\"apple\", \"pear\", \"peach\"]\n>>> g.es[\"name\"] = [\"first_edge\", \"second\", \"third\"]",
                ">>> g = Graph.Full(3)\n>>> g.vs[\"name\"] = [\"apple\", \"pear\", \"peach\"]\n>>> g.es[\"name\"] = [\"first_edge\", \"second\", \"third\"]",
                ">>> g = Graph.Full(3)\n>>> g.vs[\"name\"] = [\"apple\", \"pear\", \"peach\"]\n>>> g.es[\"name\"] = [\"first_edge\", \"second\", \"third\"]"
            ]
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > transitivity_avglocal_undirected": {
            "Description": "overrides igraph.GraphBase.transitivity_avglocal_undirected\nCalculates the average of the vertex transitivities of the graph.\nIn the unweighted case, the transitivity measures the probability that two neighbors of a vertex are connected. In case of the average local transitivity, this probability is calculated for each vertex and then the average is taken. Vertices with less than two neighbors require special treatment, they will either be left out from the calculation or they will be considered as having zero transitivity, depending on the mode parameter. The calculation is slightly more involved for weighted graphs; in this case, weights are taken into account according to the formula of Barrat et al (see the references).\nNote that this measure is different from the global transitivity measure (see transitivity_undirected()) as it simply takes the average local transitivity across the whole network.\n",
            "Paramters": {
                "mode": "defines how to treat vertices with degree less than two. If TRANSITIVITY_ZERO or \"zero\", these vertices will have zero transitivity. If TRANSITIVITY_NAN or \"nan\", these vertices will be excluded from the average.",
                "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name."
            },
            "Return": [],
            "References": [
                "Watts DJ and Strogatz S: Collective dynamics of small-world networks. Nature 393(6884):440-442, 1998.Barrat A, Barthelemy M, Pastor-Satorras R and Vespignani A: The architecture of complex weighted networks. PNAS 101, 3747 (2004). http://arxiv.org/abs/cond-mat/0311416."
            ],
            "Rasises": {},
            "See Also": "transitivity_undirected(), transitivity_local_undirected()",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > triad_census": {
            "Description": "overrides igraph.GraphBase.triad_census\nCalculates the triad census of the graph.\nReference: Davis, J.A. and Leinhardt, S. The Structure of Positive Interpersonal Relations in Small Groups. In: J. Berger (Ed.), Sociological Theories in Progress, Volume 2, 218-251. Boston: Houghton Mifflin (1972).",
            "Paramters": {},
            "Return": [
                "a TriadCensus object."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > union": {
            "Description": "Creates the union of two (or more) graphs.",
            "Paramters": {
                "graph": "Undocumented",
                "other": "graph or list of graphs to be united with the current one.",
                "byname": "whether to use vertex names instead of ids. See igraph.operators.union for details."
            },
            "Return": [
                "the union graph"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > write": {
            "Description": "Unified writing function for graphs.\nThis method tries to identify the format of the graph given in the first parameter (based on extension) and calls the corresponding writer method.\nThe remaining arguments are passed to the writer method without any changes.",
            "Paramters": {
                "graph": "Undocumented",
                "f": "the ile containing the graph to be saved",
                "format": "the  of the file (if one wants to override the  determined from the filename extension, or the filename itself is a stream). None means auto-detection. Possible values are:\"adjacency\": adjacency matrix \"dimacs\": DIMACS \"dot\", \"graphviz\": GraphViz DOT \"edgelist\", \"edges\" or \"edge\": numeric edge list \"gml\": GML \"graphml\" and \"graphmlz\": standard and gzipped GraphML \"gw\", \"leda\", \"lgr\": LEDA native \"lgl\": LGL \"ncol\": NCOL \"net\", \"pajek\": Pajek \"pickle\", \"picklez\": standard and gzipped Python pickled \"svg\": SVG ",
                "*args": "Undocumented",
                "**kwds": "Undocumented"
            },
            "Return": [],
            "References": [],
            "Rasises": {
                "IOError": "if the file format can't be identified and none was given."
            },
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > write_adjacency": {
            "Description": "Writes the adjacency matrix of the graph to the given file\nAll the remaining arguments not mentioned here are passed intact to Graph.get_adjacency.",
            "Paramters": {
                "graph": "Undocumented",
                "f": "the name o the ile to be written.",
                "sep": "the string that arates the matrix elements in a row",
                "eol": "the string that separates the rows of the matrix. Please note that igraph is able to read back the written adjacency matrix if and only if this is a single newline character",
                "*args": "Undocumented",
                "**kwds": "Undocumented"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > write_dimacs": {
            "Description": "overrides igraph.GraphBase.write_dimacs\nWrites the graph in DIMACS format to the given file.",
            "Paramters": {
                "graph": "Undocumented",
                "f": "the name o the ile to be written or a Python ile handle.",
                "source": "the  vertex ID. If None, igraph will try to infer it from the  graph attribute.",
                "target": "the  vertex ID. If None, igraph will try to infer it from the  graph attribute.",
                "capacity": "the capacities of the edges in a list or the name of an edge attribute that holds the capacities. If there is no such edge attribute, every edge will have a  of 1."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > write_graphmlz": {
            "Description": "Writes the graph to a zipped GraphML file.\nThe library uses the gzip compression algorithm, so the resulting file can be unzipped with regular gzip uncompression (like gunzip or zcat from Unix command line) or the Python gzip module.\nUses a temporary file to store intermediate GraphML data, so make sure you have enough free space to store the unzipped GraphML file as well.",
            "Paramters": {
                "graph": "Undocumented",
                "f": "the name o the ile to be written.",
                "compresslevel": "the level of compression. 1 is fastest and produces the least compression, and 9 is slowest and produces the most compression."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > write_pickle": {
            "Description": "Saves the graph in Python pickled format",
            "Paramters": {
                "graph": "Undocumented",
                "fname": "the name of the file or a stream to save to. If None, saves the graph to a string and returns the string.",
                "version": "pickle protocol  to be used. If -1, uses the highest protocol available"
            },
            "Return": [
                "None if the graph was saved successfully to the given file, or a string if fname was None."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > write_picklez": {
            "Description": "Saves the graph in Python pickled format, compressed with gzip.\nSaving in this format is a bit slower than saving in a Python pickle without compression, but the final file takes up much less space on the hard drive.",
            "Paramters": {
                "graph": "Undocumented",
                "fname": "the name of the file or a stream to save to.",
                "version": "pickle protocol  to be used. If -1, uses the highest protocol available"
            },
            "Return": [
                "None if the graph was saved successfully to the given file."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > write_svg": {
            "Description": "Saves the graph as an SVG (Scalable Vector Graphics) file\nThe file will be Inkscape (http://inkscape.org) compatible. In Inkscape, as nodes are rearranged, the edges auto-update.",
            "Paramters": {
                "graph": "Undocumented",
                "fname": "the name of the file or a Python file handle",
                "layout": "the  of the graph. Can be either an explicitly specified  (using a list of coordinate pairs) or the name of a  algorithm (which should refer to a method in the Graph object, but without the _ prefix.",
                "width": "the preferred  in pixels (default: 400)",
                "height": "the preferred  in pixels (default: 400)",
                "labels": "the vertex . Either it is the name of a vertex attribute to use, or a list explicitly specifying the . It can also be None.",
                "colors": "the vertex . Either it is the name of a vertex attribute to use, or a list explicitly specifying the . A color can be anything acceptable in an SVG file.",
                "shapes": "the vertex . Either it is the name of a vertex attribute to use, or a list explicitly specifying the  as integers. Shape 0 means hidden (nothing is drawn), shape 1 is a circle, shape 2 is a rectangle and shape 3 is a rectangle that automatically sizes to the inner text.",
                "vertex_size": "vertex size in pixels",
                "edge_colors": "the edge colors. Either it is the name of an edge attribute to use, or a list explicitly specifying the colors. A color can be anything acceptable in an SVG file.",
                "edge_stroke_widths": "the stroke widths of the edges. Either it is the name of an edge attribute to use, or a list explicitly specifying the stroke widths. The stroke width can be anything acceptable in an SVG file.",
                "font_size": "font size. If it is a string, it is written into the SVG file as-is (so you can specify anything which is valid as the value of the font-size style). If it is a number, it is interpreted as pixel size and converted to the proper attribute value accordingly.",
                "*args": "Undocumented",
                "**kwds": "Undocumented"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > __new__": {
            "Description": "Inherited from GraphBase:Create and return a new object.  See help(type) for accurate signature."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > all_minimal_st_separators": {
            "Description": "Inherited from GraphBase:Returns a list containing all the minimal s-t separators of a graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > are_connected": {
            "Description": "Inherited from GraphBase:Decides whether two given vertices are directly connected."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > articulation_points": {
            "Description": "Inherited from GraphBase:Returns the list of articulation points in the graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > assortativity": {
            "Description": "Inherited from GraphBase:Returns the assortativity of the graph based on numeric properties of the vertices."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > assortativity_degree": {
            "Description": "Inherited from GraphBase:Returns the assortativity of a graph based on vertex degrees."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > assortativity_nominal": {
            "Description": "Inherited from GraphBase:Returns the assortativity of the graph based on vertex categories."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Asymmetric_Preference": {
            "Description": "Inherited from GraphBase:Generates a graph based on asymmetric vertex types and connection probabilities."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Atlas": {
            "Description": "Inherited from GraphBase:Generates a graph from the Graph Atlas."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > attributes": {
            "Description": "Inherited from GraphBase:No summary"
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > authority_score": {
            "Description": "Inherited from GraphBase:Calculates Kleinberg's authority score for the vertices of the graph"
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > automorphism_group": {
            "Description": "Inherited from GraphBase:Calculates the generators of the automorphism group of a graph using the BLISS isomorphism algorithm."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > average_path_length": {
            "Description": "Inherited from GraphBase:Calculates the average path length in a graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Barabasi": {
            "Description": "Inherited from GraphBase:Generates a graph based on the Barab\u00e1si-Albert model."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > betweenness": {
            "Description": "Inherited from GraphBase:Calculates or estimates the betweenness of vertices in a graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > bfs": {
            "Description": "Inherited from GraphBase:Conducts a breadth first search (BFS) on the graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > bfsiter": {
            "Description": "Inherited from GraphBase:Constructs a breadth first search (BFS) iterator of the graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > bibcoupling": {
            "Description": "Inherited from GraphBase:Calculates bibliographic coupling scores for given vertices in a graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > bridges": {
            "Description": "Inherited from GraphBase:Returns the list of bridges in the graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > canonical_permutation": {
            "Description": "Inherited from GraphBase:Calculates the canonical permutation of a graph using the BLISS isomorphism algorithm."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > chordal_completion": {
            "Description": "Inherited from GraphBase:Returns the list of edges needed to be added to the graph to make it chordal."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > clique_number": {
            "Description": "Inherited from GraphBase:Returns the clique number of the graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > cliques": {
            "Description": "Inherited from GraphBase:Returns some or all cliques of the graph as a list of tuples."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > closeness": {
            "Description": "Inherited from GraphBase:Calculates the closeness centralities of given vertices in a graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > cocitation": {
            "Description": "Inherited from GraphBase:Calculates cocitation scores for given vertices in a graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > complementer": {
            "Description": "Inherited from GraphBase:Returns the complementer of the graph"
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > compose": {
            "Description": "Inherited from GraphBase:Returns the composition of two graphs."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > constraint": {
            "Description": "Inherited from GraphBase:Calculates Burt's constraint scores for given vertices in a graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > contract_vertices": {
            "Description": "Inherited from GraphBase:Contracts some vertices in the graph, i.e. replaces groups of vertices with single vertices. Edges are not affected."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > convergence_degree": {
            "Description": "Inherited from GraphBase:Undocumented (yet)."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > convergence_field_size": {
            "Description": "Inherited from GraphBase:Undocumented (yet)."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > copy": {
            "Description": "Inherited from GraphBase:Creates a copy of the graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > coreness": {
            "Description": "Inherited from GraphBase:Finds the coreness (shell index) of the vertices of the network."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > count_automorphisms": {
            "Description": "Inherited from GraphBase:Calculates the number of automorphisms of a graph using the BLISS isomorphism algorithm."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > count_isomorphisms_vf2": {
            "Description": "Inherited from GraphBase:Determines the number of isomorphisms between the graph and another one"
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > count_multiple": {
            "Description": "Inherited from GraphBase:Counts the multiplicities of the given edges."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > count_subisomorphisms_vf2": {
            "Description": "Inherited from GraphBase:Determines the number of subisomorphisms between the graph and another one"
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > De_Bruijn": {
            "Description": "Inherited from GraphBase:Generates a de Bruijn graph with parameters (m, n)"
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > decompose": {
            "Description": "Inherited from GraphBase:Decomposes the graph into subgraphs."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > degree": {
            "Description": "Inherited from GraphBase:Returns some vertex degrees from the graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Degree_Sequence": {
            "Description": "Inherited from GraphBase:Generates a graph with a given degree sequence."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > delete_vertices": {
            "Description": "Inherited from GraphBase:Deletes vertices and all its edges from the graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > density": {
            "Description": "Inherited from GraphBase:Calculates the density of the graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > dfsiter": {
            "Description": "Inherited from GraphBase:Constructs a depth first search (DFS) iterator of the graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > diameter": {
            "Description": "Inherited from GraphBase:Calculates the diameter of the graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > difference": {
            "Description": "Inherited from GraphBase:Subtracts the given graph from the original"
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > distances": {
            "Description": "Inherited from GraphBase:Calculates shortest path lengths for given vertices in a graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > diversity": {
            "Description": "Inherited from GraphBase:Calculates the structural diversity index of the vertices."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > dominator": {
            "Description": "Inherited from GraphBase:Returns the dominator tree from the given root node"
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > eccentricity": {
            "Description": "Inherited from GraphBase:Calculates the eccentricities of given vertices in a graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > ecount": {
            "Description": "Inherited from GraphBase:Counts the number of edges."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > edge_attributes": {
            "Description": "Inherited from GraphBase:No summary"
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > edge_betweenness": {
            "Description": "Inherited from GraphBase:Calculates or estimates the edge betweennesses in a graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > edge_connectivity": {
            "Description": "Inherited from GraphBase:Calculates the edge connectivity of the graph or between some vertices."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > eigen_adjacency": {
            "Description": "Inherited from GraphBase:Undocumented"
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > eigenvector_centrality": {
            "Description": "Inherited from GraphBase:Calculates the eigenvector centralities of the vertices in a graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Erdos_Renyi": {
            "Description": "Inherited from GraphBase:Generates a graph based on the Erd\u0151s-R\u00e9nyi model."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Establishment": {
            "Description": "Inherited from GraphBase:Generates a graph based on a simple growing model with vertex types."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Famous": {
            "Description": "Inherited from GraphBase:Generates a famous graph based on its name."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > farthest_points": {
            "Description": "Inherited from GraphBase:Returns two vertex IDs whose distance equals the actual diameter of the graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > feedback_arc_set": {
            "Description": "Inherited from GraphBase:Calculates an approximately or exactly minimal feedback arc set."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Forest_Fire": {
            "Description": "Inherited from GraphBase:Generates a graph based on the forest fire model"
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Full": {
            "Description": "Inherited from GraphBase:Generates a full graph (directed or undirected, with or without loops)."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Full_Citation": {
            "Description": "Inherited from GraphBase:Generates a full citation graph"
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > fundamental_cycles": {
            "Description": "Inherited from GraphBase:Finds a single fundamental cycle basis of the graph"
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > get_all_shortest_paths": {
            "Description": "Inherited from GraphBase:Calculates all of the shortest paths from/to a given node in a graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > get_diameter": {
            "Description": "Inherited from GraphBase:Returns a path with the actual diameter of the graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > get_edgelist": {
            "Description": "Inherited from GraphBase:Returns the edge list of a graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > get_eid": {
            "Description": "Inherited from GraphBase:Returns the edge ID of an arbitrary edge between vertices v1 and v2"
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > get_eids": {
            "Description": "Inherited from GraphBase:Returns the edge IDs of some edges between some vertices."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > get_isomorphisms_vf2": {
            "Description": "Inherited from GraphBase:Returns all isomorphisms between the graph and another one"
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > get_k_shortest_paths": {
            "Description": "Inherited from GraphBase:Calculates the k shortest paths from/to a given node in a graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > get_shortest_path": {
            "Description": "Inherited from GraphBase:Calculates the shortest path from a source vertex to a target vertex in a graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > get_shortest_path_astar": {
            "Description": "Inherited from GraphBase:Calculates the shortest path from a source vertex to a target vertex in a graph using the A-Star algorithm and a heuristic function."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > get_shortest_paths": {
            "Description": "Inherited from GraphBase:Calculates the shortest paths from/to a given node in a graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > get_subisomorphisms_lad": {
            "Description": "Inherited from GraphBase:Returns all subisomorphisms between the graph and another one using the LAD algorithm."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > get_subisomorphisms_vf2": {
            "Description": "Inherited from GraphBase:Returns all subisomorphisms between the graph and another one"
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > girth": {
            "Description": "Inherited from GraphBase:Returns the girth of the graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Growing_Random": {
            "Description": "Inherited from GraphBase:Generates a growing random graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > harmonic_centrality": {
            "Description": "Inherited from GraphBase:Calculates the harmonic centralities of given vertices in a graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > has_multiple": {
            "Description": "Inherited from GraphBase:Checks whether the graph has multiple edges."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Hexagonal_Lattice": {
            "Description": "Inherited from GraphBase:Generates a regular hexagonal lattice."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > hub_score": {
            "Description": "Inherited from GraphBase:Calculates Kleinberg's hub score for the vertices of the graph"
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > incident": {
            "Description": "Inherited from GraphBase:Returns the edges a given vertex is incident on."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > independence_number": {
            "Description": "Inherited from GraphBase:Returns the independence number of the graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > independent_vertex_sets": {
            "Description": "Inherited from GraphBase:Returns some or all independent vertex sets of the graph as a list of tuples."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > induced_subgraph": {
            "Description": "Inherited from GraphBase:Returns a subgraph spanned by the given vertices."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > is_acyclic": {
            "Description": "Inherited from GraphBase:Returns whether the graph is acyclic (i.e. contains no cycles)."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > is_biconnected": {
            "Description": "Inherited from GraphBase:Decides whether the graph is biconnected."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > is_bipartite": {
            "Description": "Inherited from GraphBase:Decides whether the graph is bipartite or not."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > is_chordal": {
            "Description": "Inherited from GraphBase:Returns whether the graph is chordal or not."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > is_connected": {
            "Description": "Inherited from GraphBase:Decides whether the graph is connected."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > is_dag": {
            "Description": "Inherited from GraphBase:Checks whether the graph is a DAG (directed acyclic graph)."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > is_directed": {
            "Description": "Inherited from GraphBase:Checks whether the graph is directed."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > is_loop": {
            "Description": "Inherited from GraphBase:Checks whether a specific set of edges contain loop edges"
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > is_minimal_separator": {
            "Description": "Inherited from GraphBase:Decides whether the given vertex set is a minimal separator."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > is_multiple": {
            "Description": "Inherited from GraphBase:Checks whether an edge is a multiple edge."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > is_mutual": {
            "Description": "Inherited from GraphBase:Checks whether an edge has an opposite pair."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > is_separator": {
            "Description": "Inherited from GraphBase:Decides whether the removal of the given vertices disconnects the graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > is_simple": {
            "Description": "Inherited from GraphBase:Checks whether the graph is simple (no loop or multiple edges)."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > is_tree": {
            "Description": "Inherited from GraphBase:Checks whether the graph is a (directed or undirected) tree graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Isoclass": {
            "Description": "Inherited from GraphBase:Generates a graph with a given isomorphism class."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > isoclass": {
            "Description": "Inherited from GraphBase:Returns the isomorphism class of the graph or its subgraph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > isomorphic": {
            "Description": "Inherited from GraphBase:Checks whether the graph is isomorphic to another graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > isomorphic_bliss": {
            "Description": "Inherited from GraphBase:Checks whether the graph is isomorphic to another graph, using the BLISS isomorphism algorithm."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > isomorphic_vf2": {
            "Description": "Inherited from GraphBase:Checks whether the graph is isomorphic to another graph, using the VF2 isomorphism algorithm."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > K_Regular": {
            "Description": "Inherited from GraphBase:Generates a k-regular random graph"
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Kautz": {
            "Description": "Inherited from GraphBase:Generates a Kautz graph with parameters (m, n)"
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > knn": {
            "Description": "Inherited from GraphBase:Calculates the average degree of the neighbors for each vertex, and the same quantity as the function of vertex degree."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > laplacian": {
            "Description": "Inherited from GraphBase:Returns the Laplacian matrix of a graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > largest_cliques": {
            "Description": "Inherited from GraphBase:Returns the largest cliques of the graph as a list of tuples."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > largest_independent_vertex_sets": {
            "Description": "Inherited from GraphBase:Returns the largest independent vertex sets of the graph as a list of tuples."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Lattice": {
            "Description": "Inherited from GraphBase:Generates a regular square lattice."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > layout_bipartite": {
            "Description": "Inherited from GraphBase:Place the vertices of a bipartite graph in two layers."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > layout_circle": {
            "Description": "Inherited from GraphBase:Places the vertices of the graph uniformly on a circle or a sphere."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > layout_davidson_harel": {
            "Description": "Inherited from GraphBase:Places the vertices on a 2D plane according to the Davidson-Harel layout algorithm."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > layout_drl": {
            "Description": "Inherited from GraphBase:Places the vertices on a 2D plane or in the 3D space ccording to the DrL layout algorithm."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > layout_fruchterman_reingold": {
            "Description": "Inherited from GraphBase:Places the vertices on a 2D plane according to the Fruchterman-Reingold algorithm."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > layout_graphopt": {
            "Description": "Inherited from GraphBase:This is a port of the graphopt layout algorithm by Michael Schmuhl. graphopt version 0.4.1 was rewritten in C and the support for layers was removed."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > layout_grid": {
            "Description": "Inherited from GraphBase:Places the vertices of a graph in a 2D or 3D grid."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > layout_kamada_kawai": {
            "Description": "Inherited from GraphBase:Places the vertices on a plane according to the Kamada-Kawai algorithm."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > layout_lgl": {
            "Description": "Inherited from GraphBase:Places the vertices on a 2D plane according to the Large Graph Layout."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > layout_mds": {
            "Description": "Inherited from GraphBase:Places the vertices in an Euclidean space with the given number of dimensions using multidimensional scaling."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > layout_random": {
            "Description": "Inherited from GraphBase:Places the vertices of the graph randomly."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > layout_reingold_tilford": {
            "Description": "Inherited from GraphBase:Places the vertices on a 2D plane according to the Reingold-Tilford layout algorithm."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > layout_reingold_tilford_circular": {
            "Description": "Inherited from GraphBase:Circular Reingold-Tilford layout for trees."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > layout_star": {
            "Description": "Inherited from GraphBase:Calculates a star-like layout for the graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > layout_umap": {
            "Description": "Inherited from GraphBase:Uniform Manifold Approximation and Projection (UMAP)."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > LCF": {
            "Description": "Inherited from GraphBase:Generates a graph from LCF notation."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > linegraph": {
            "Description": "Inherited from GraphBase:Returns the line graph of the graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > list_triangles": {
            "Description": "Inherited from GraphBase:Lists the triangles of the graph"
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > maxdegree": {
            "Description": "Inherited from GraphBase:Returns the maximum degree of a vertex set in the graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > maxflow_value": {
            "Description": "Inherited from GraphBase:Returns the value of the maximum flow between the source and target vertices."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > maximal_cliques": {
            "Description": "Inherited from GraphBase:Returns the maximal cliques of the graph as a list of tuples."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > maximal_independent_vertex_sets": {
            "Description": "Inherited from GraphBase:Returns the maximal independent vertex sets of the graph as a list of tuples."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > maximum_cardinality_search": {
            "Description": "Inherited from GraphBase:Conducts a maximum cardinality search on the graph. The function computes a rank alpha for each vertex such that visiting vertices in decreasing rank order corresponds to always choosing the vertex with the most already visited neighbors as the next one to visit."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > mincut_value": {
            "Description": "Inherited from GraphBase:Returns the minimum cut between the source and target vertices or within the whole graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > minimum_cycle_basis": {
            "Description": "Inherited from GraphBase:Computes a minimum cycle basis of the graph"
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > minimum_size_separators": {
            "Description": "Inherited from GraphBase:Returns a list containing all separator vertex sets of minimum size."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > modularity_matrix": {
            "Description": "Inherited from GraphBase:Calculates the modularity matrix of the graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > motifs_randesu": {
            "Description": "Inherited from GraphBase:Counts the number of motifs in the graph"
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > motifs_randesu_estimate": {
            "Description": "Inherited from GraphBase:Counts the total number of motifs in the graph"
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > motifs_randesu_no": {
            "Description": "Inherited from GraphBase:Counts the total number of motifs in the graph"
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > neighborhood": {
            "Description": "Inherited from GraphBase:For each vertex specified by vertices, returns the vertices reachable from that vertex in at most order steps. If mindist is larger than zero, vertices that are reachable in less than mindist steps are excluded."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > neighborhood_size": {
            "Description": "Inherited from GraphBase:For each vertex specified by vertices, returns the number of vertices reachable from that vertex in at most order steps. If mindist is larger than zero, vertices that are reachable in less than mindist..."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > neighbors": {
            "Description": "Inherited from GraphBase:Returns adjacent vertices to a given vertex."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > permute_vertices": {
            "Description": "Inherited from GraphBase:Permutes the vertices of the graph according to the given permutation and returns the new graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > personalized_pagerank": {
            "Description": "Inherited from GraphBase:Calculates the personalized PageRank values of a graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > predecessors": {
            "Description": "Inherited from GraphBase:Returns the predecessors of a given vertex."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Preference": {
            "Description": "Inherited from GraphBase:Generates a graph based on vertex types and connection probabilities."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Prufer": {
            "Description": "Inherited from GraphBase:Generates a tree from its Pr\u00fcfer sequence."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > radius": {
            "Description": "Inherited from GraphBase:Calculates the radius of the graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > random_walk": {
            "Description": "Inherited from GraphBase:Performs a random walk of a given length from a given node."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Read_DL": {
            "Description": "Inherited from GraphBase:Reads an UCINET DL file and creates a graph based on it."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Read_Edgelist": {
            "Description": "Inherited from GraphBase:Reads an edge list from a file and creates a graph based on it."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Read_GML": {
            "Description": "Inherited from GraphBase:Reads a GML file and creates a graph based on it."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Read_GraphDB": {
            "Description": "Inherited from GraphBase:Reads a GraphDB format file and creates a graph based on it."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Read_GraphML": {
            "Description": "Inherited from GraphBase:Reads a GraphML format file and creates a graph based on it."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Read_Lgl": {
            "Description": "Inherited from GraphBase:Reads an .lgl file used by LGL."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Read_Ncol": {
            "Description": "Inherited from GraphBase:Reads an .ncol file used by LGL."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Read_Pajek": {
            "Description": "Inherited from GraphBase:Reads a file in the Pajek format and creates a graph based on it. Only Pajek network files (.net extension) are supported, not project files (.paj)."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Realize_Bipartite_Degree_Sequence": {
            "Description": "Inherited from GraphBase:Generates a bipartite graph from the degree sequences of its partitions."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Realize_Degree_Sequence": {
            "Description": "Inherited from GraphBase:Generates a graph from a degree sequence."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Recent_Degree": {
            "Description": "Inherited from GraphBase:Generates a graph based on a stochastic model where the probability of an edge gaining a new node is proportional to the edges gained in a given time window."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > reciprocity": {
            "Description": "Inherited from GraphBase:Reciprocity defines the proportion of mutual connections in a directed graph. It is most commonly defined as the probability that the opposite counterpart of a directed edge is also included in the graph..."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > reverse_edges": {
            "Description": "Inherited from GraphBase:Reverses the direction of some edges in the graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > rewire": {
            "Description": "Inherited from GraphBase:Randomly rewires the graph while preserving the degree distribution."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > rewire_edges": {
            "Description": "Inherited from GraphBase:Rewires the edges of a graph with constant probability."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Ring": {
            "Description": "Inherited from GraphBase:Generates a ring graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > SBM": {
            "Description": "Inherited from GraphBase:Generates a graph based on a stochastic block model."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > similarity_dice": {
            "Description": "Inherited from GraphBase:Dice similarity coefficient of vertices."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > similarity_inverse_log_weighted": {
            "Description": "Inherited from GraphBase:Inverse log-weighted similarity coefficient of vertices."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > similarity_jaccard": {
            "Description": "Inherited from GraphBase:Jaccard similarity coefficient of vertices."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > simplify": {
            "Description": "Inherited from GraphBase:Simplifies a graph by removing self-loops and/or multiple edges."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Star": {
            "Description": "Inherited from GraphBase:Generates a star graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Static_Fitness": {
            "Description": "Inherited from GraphBase:Generates a non-growing graph with edge probabilities proportional to node fitnesses."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Static_Power_Law": {
            "Description": "Inherited from GraphBase:Generates a non-growing graph with prescribed power-law degree distributions."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > strength": {
            "Description": "Inherited from GraphBase:Returns the strength (weighted degree) of some vertices from the graph"
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > subcomponent": {
            "Description": "Inherited from GraphBase:Determines the indices of vertices which are in the same component as a given vertex."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > subgraph_edges": {
            "Description": "Inherited from GraphBase:Returns a subgraph spanned by the given edges."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > subisomorphic_lad": {
            "Description": "Inherited from GraphBase:Checks whether a subgraph of the graph is isomorphic to another graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > subisomorphic_vf2": {
            "Description": "Inherited from GraphBase:Checks whether a subgraph of the graph is isomorphic to another graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > successors": {
            "Description": "Inherited from GraphBase:Returns the successors of a given vertex."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > to_directed": {
            "Description": "Inherited from GraphBase:Converts an undirected graph to directed."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > to_prufer": {
            "Description": "Inherited from GraphBase:Converts a tree graph into a Pr\u00fcfer sequence."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > to_undirected": {
            "Description": "Inherited from GraphBase:Converts a directed graph to undirected."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > topological_sorting": {
            "Description": "Inherited from GraphBase:Calculates a possible topological sorting of the graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > transitivity_local_undirected": {
            "Description": "Inherited from GraphBase:Calculates the local transitivity (clustering coefficient) of the given vertices in the graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > transitivity_undirected": {
            "Description": "Inherited from GraphBase:Calculates the global transitivity (clustering coefficient) of the graph."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Tree": {
            "Description": "Inherited from GraphBase:Generates a tree in which almost all vertices have the same number of children."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Tree_Game": {
            "Description": "Inherited from GraphBase:Generates a random tree by sampling uniformly from the set of labelled trees with a given number of nodes."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Triangular_Lattice": {
            "Description": "Inherited from GraphBase:Generates a regular triangular lattice."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > unfold_tree": {
            "Description": "Inherited from GraphBase:Unfolds the graph using a BFS to a tree by duplicating vertices as necessary."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > vcount": {
            "Description": "Inherited from GraphBase:Counts the number of vertices."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > vertex_attributes": {
            "Description": "Inherited from GraphBase:No summary"
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > vertex_coloring_greedy": {
            "Description": "Inherited from GraphBase:Calculates a greedy vertex coloring for the graph based on some heuristics."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > vertex_connectivity": {
            "Description": "Inherited from GraphBase:Calculates the vertex connectivity of the graph or between some vertices."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Watts_Strogatz": {
            "Description": "Inherited from GraphBase:This function generates networks with the small-world property based on a variant of the Watts-Strogatz model. The network is obtained by first creating a periodic undirected lattice, then rewiring both endpoints of each edge with probability ..."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > write_dot": {
            "Description": "Inherited from GraphBase:Writes the graph in DOT format to the given file."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > write_edgelist": {
            "Description": "Inherited from GraphBase:Writes the edge list of a graph to a file."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > write_gml": {
            "Description": "Inherited from GraphBase:Writes the graph in GML format to the given file."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > write_graphml": {
            "Description": "Inherited from GraphBase:Writes the graph to a GraphML file."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > write_leda": {
            "Description": "Inherited from GraphBase:Writes the graph to a file in LEDA native format."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > write_lgl": {
            "Description": "Inherited from GraphBase:Writes the edge list of a graph to a file in .lgl format."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > write_ncol": {
            "Description": "Inherited from GraphBase:Writes the edge list of a graph to a file in .ncol format."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > write_pajek": {
            "Description": "Inherited from GraphBase:Writes the graph in Pajek format to the given file."
        },
        "Section_id": "Graph"
    },
    {
        "Field List > property": {
            "es": "The edge sequence of the graph\n",
            "vs": "The vertex sequence of the graph\n",
            "_as_parameter_": "Undocumented\n"
        },
        "Section_id": "Graph"
    },
    {
        "Rubric": {
            "Example": [
                "Graphs can also be indexed by strings or pairs of vertex indices or vertex names.  When a graph is indexed by a string, the operation translates to the retrieval, creation, modification or deletion of a graph attribute:\n>>> g = Graph.Full(3)\n>>> g[\"name\"] = \"Triangle graph\"\n>>> g[\"name\"]\n'Triangle graph'\n>>> del g[\"name\"]",
                "When a graph is indexed by a pair of vertex indices or names, the graph itself is treated as an adjacency matrix and the corresponding cell of the matrix is returned:\n>>> g = Graph.Full(3)\n>>> g[\"name\"] = \"Triangle graph\"\n>>> g[\"name\"]\n'Triangle graph'\n>>> del g[\"name\"]",
                "Assigning values different from zero or one to the adjacency matrix will be translated to one, unless the graph is weighted, in which case the numbers will be treated as weights:\n>>> g = Graph.Full(3)\n>>> g[\"name\"] = \"Triangle graph\"\n>>> g[\"name\"]\n'Triangle graph'\n>>> del g[\"name\"]"
            ]
        },
        "Section_id": "Graph"
    },
    {
        "Section_id": "CairoArrowEdgeDrawer",
        "Description": "Edge drawer implementation that draws undirected edges as straight lines and directed edges as arrows."
    },
    {
        "Field List > Methods > draw_directed_edge": {
            "Description": "overrides igraph.drawing.baseclasses.AbstractEdgeDrawer.draw_directed_edge\nDraws a directed edge.",
            "Paramters": {
                "edge": "the  to be drawn. Visual properties of the  are defined by the attributes of this object.",
                "src_vertex": "the source vertex. Visual properties are defined by the attributes of this object.",
                "dest_vertex": "the source vertex. Visual properties are defined by the attributes of this object."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "CairoArrowEdgeDrawer"
    },
    {
        "Field List > Methods > __init__": {
            "Description": "Inherited from AbstractCairoEdgeDrawer:Constructs the edge drawer."
        },
        "Section_id": "CairoArrowEdgeDrawer"
    },
    {
        "Field List > Methods > draw_loop_edge": {
            "Description": "Inherited from AbstractCairoEdgeDrawer:Draws a loop edge."
        },
        "Section_id": "CairoArrowEdgeDrawer"
    },
    {
        "Field List > Methods > draw_undirected_edge": {
            "Description": "Inherited from AbstractCairoEdgeDrawer:Draws an undirected edge."
        },
        "Section_id": "CairoArrowEdgeDrawer"
    },
    {
        "Field List > property": {},
        "Section_id": "CairoArrowEdgeDrawer"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "CairoArrowEdgeDrawer"
    },
    {
        "Section_id": "community_to_membership",
        "Description": "Undocumented"
    },
    {
        "Paramters": {},
        "Section_id": "community_to_membership"
    },
    {
        "Raises": {},
        "Section_id": "community_to_membership"
    },
    {
        "Section_id": "community_to_membership",
        "See Also": ""
    },
    {
        "Section_id": "convex_hull",
        "Description": "Calculates the convex hull of a given point set."
    },
    {
        "Paramters": {
            "vs": "the point set as a list of lists",
            "coords": "if True, the function returns the coordinates of the corners of the convex hull polygon, otherwise returns the corner indices."
        },
        "Section_id": "convex_hull"
    },
    {
        "Section_id": "convex_hull",
        "Return": [
            "either the hull's corner coordinates or the point indices corresponding to them, depending on the coords parameter."
        ]
    },
    {
        "Raises": {},
        "Section_id": "convex_hull"
    },
    {
        "Section_id": "convex_hull",
        "See Also": ""
    },
    {
        "Section_id": "is_bigraphical",
        "Description": "Returns whether two sequences of integers can be the degree sequences of a bipartite graph.\nThe bipartite graph may or may not have multiple edges, depending on the allowed edge types in the remaining arguments."
    },
    {
        "Paramters": {
            "degrees1": "the list of degrees in the first partition.",
            "degrees2": "the list of degrees in the second partition.",
            "multiple": "whether  edges are allowed."
        },
        "Section_id": "is_bigraphical"
    },
    {
        "Section_id": "is_bigraphical",
        "Return": [
            "True if there exists some bipartite graph that can realize the given degree sequences with or without multiple edges, False otherwise."
        ]
    },
    {
        "Raises": {},
        "Section_id": "is_bigraphical"
    },
    {
        "Section_id": "is_bigraphical",
        "See Also": ""
    },
    {
        "Section_id": "is_degree_sequence",
        "Description": "Deprecated since 0.9 in favour of is_graphical().\nReturns whether a list of degrees can be a degree sequence of some graph.\nNote that it is not required for the graph to be simple; in other words, this function may return True for degree sequences that can be realized using one or more multiple or loop edges only.\nIn particular, this function checks whetherall the degrees are non-negativefor undirected graphs, the sum of degrees are evenfor directed graphs, the two degree sequences are of the same length and equal sums"
    },
    {
        "Paramters": {
            "out_deg": "the list of degrees. For directed graphs, this list must contain the out-degrees of the vertices.",
            "in_deg": "the list of in-degrees for directed graphs. This parameter must be None for undirected graphs."
        },
        "Section_id": "is_degree_sequence"
    },
    {
        "Section_id": "is_degree_sequence",
        "Return": [
            "True if there exists some graph that can realize the given degree sequence, False otherwise."
        ]
    },
    {
        "Raises": {},
        "Section_id": "is_degree_sequence"
    },
    {
        "Section_id": "is_degree_sequence",
        "See Also": ""
    },
    {
        "Section_id": "is_graphical",
        "Description": "Returns whether a list of degrees can be a degree sequence of some graph, with or without multiple and loop edges, depending on the allowed edge types in the remaining arguments."
    },
    {
        "Paramters": {
            "out_deg": "the list of degrees. For directed graphs, this list must contain the out-degrees of the vertices.",
            "in_deg": "the list of in-degrees for directed graphs. This parameter must be None for undirected graphs.",
            "loops": "whether loop edges are allowed.",
            "multiple": "whether  edges are allowed."
        },
        "Section_id": "is_graphical"
    },
    {
        "Section_id": "is_graphical",
        "Return": [
            "True if there exists some graph that can realize the given degree sequence with the given edge types, False otherwise."
        ]
    },
    {
        "Raises": {},
        "Section_id": "is_graphical"
    },
    {
        "Section_id": "is_graphical",
        "See Also": ""
    },
    {
        "Section_id": "is_graphical_degree_sequence",
        "Description": "Deprecated since 0.9 in favour of is_graphical().\nReturns whether a list of degrees can be a degree sequence of some simple graph.\nNote that it is required for the graph to be simple; in other words, this function will return False for degree sequences that cannot be realized without using one or more multiple or loop edges."
    },
    {
        "Paramters": {
            "out_deg": "the list of degrees. For directed graphs, this list must contain the out-degrees of the vertices.",
            "in_deg": "the list of in-degrees for directed graphs. This parameter must be None for undirected graphs."
        },
        "Section_id": "is_graphical_degree_sequence"
    },
    {
        "Section_id": "is_graphical_degree_sequence",
        "Return": [
            "True if there exists some simple graph that can realize the given degree sequence, False otherwise."
        ]
    },
    {
        "Raises": {},
        "Section_id": "is_graphical_degree_sequence"
    },
    {
        "Section_id": "is_graphical_degree_sequence",
        "See Also": ""
    },
    {
        "Section_id": "set_progress_handler",
        "Description": "Sets the handler to be called when igraph is performing a long operation."
    },
    {
        "Paramters": {
            "handler": "the progress  function. It must accept two arguments, the first is the message informing the user about what igraph is doing right now, the second is the actual progress information (a percentage)."
        },
        "Section_id": "set_progress_handler"
    },
    {
        "Raises": {},
        "Section_id": "set_progress_handler"
    },
    {
        "Section_id": "set_progress_handler",
        "See Also": ""
    },
    {
        "Section_id": "set_random_number_generator",
        "Description": "Sets the random number generator used by igraph."
    },
    {
        "Paramters": {
            "generator": "the  to be used. It must be a Python object with at least three attributes: random, randint and gauss. Each of them must be callable and their signature and behaviour must be identical to random.random, random.randint and random.gauss. Optionally, the object can provide a function named getrandbits with a signature identical to randpm.getrandbits that provides a given number of random bits on demand. By default, igraph uses the random module for random number generation, but you can supply your alternative implementation here. If the given  is None, igraph reverts to the default PCG32  implemented in the C layer, which might be slightly faster than calling back to Python for random numbers, but you cannot set its seed or save its state."
        },
        "Section_id": "set_random_number_generator"
    },
    {
        "Raises": {},
        "Section_id": "set_random_number_generator"
    },
    {
        "Section_id": "set_random_number_generator",
        "See Also": ""
    },
    {
        "Section_id": "set_status_handler",
        "Description": "Sets the handler to be called when igraph tries to display a status message.\nThis is used to communicate the progress of some calculations where no reasonable progress percentage can be given (so it is not possible to use the progress handler)."
    },
    {
        "Paramters": {
            "handler": "the status  function. It must accept a single argument, the message that informs the user about what igraph is doing right now."
        },
        "Section_id": "set_status_handler"
    },
    {
        "Raises": {},
        "Section_id": "set_status_handler"
    },
    {
        "Section_id": "set_status_handler",
        "See Also": ""
    },
    {
        "Section_id": "umap_compute_weights",
        "Description": "Compute undirected UMAP weights from directed distance graph. UMAP is a layout algorithm that usually takes as input a directed distance graph, for instance a k nearest neighbor graph based on Euclidean distance between points in a vector space. The graph is directed because vertex v1 might consider vertex v2 a close neighbor, but v2 itself might have many neighbors that are closer than v1. This function computes the symmetrized weights from the distance graph using union as the symmetry operator. In simple terms, if either vertex considers the other a close neighbor, they will be treated as close neighbors.\nThis function can be used as a separate preprocessing step to Graph.layout_umap(). For efficiency reasons, the returned weights have the same length as the input distances, however because of the symmetryzation some information is lost. Therefore, the weight of one of the edges is set to zero whenever edges in opposite directions are found in the input distance graph. You can pipe the output of this function directly into Graph.layout_umap() as follows: weights = igraph.umap_compute_weights(graph, dist) layout = graph.layout_umap(weights=weights)"
    },
    {
        "Paramters": {
            "graph": "directed  to compute weights for.",
            "dist": "ances associated with the graph edges."
        },
        "Section_id": "umap_compute_weights"
    },
    {
        "Section_id": "umap_compute_weights",
        "Return": [
            "Symmetrized weights associated with each edge. If the distance graph has both directed edges between a pair of vertices, one of the returned weights will be set to zero."
        ]
    },
    {
        "Raises": {},
        "Section_id": "umap_compute_weights"
    },
    {
        "Section_id": "umap_compute_weights",
        "See Also": "Graph.layout_umap()"
    },
    {
        "Section_id": "compare_communities",
        "Description": "Compares two community structures using various distance measures.\n"
    },
    {
        "Paramters": {
            "comm1": "the first community structure as a membership list or as a Clustering object.",
            "comm2": "the second community structure as a membership list or as a Clustering object.",
            "method": "the measure to use. \"vi\" or \"meila\" means the variation of information metric of Meila (2003), \"nmi\" or \"danon\" means the normalized mutual information as defined by Danon et al. (2005), \"split-join\" means the split-join distance of van Dongen (2000), \"rand\" means the Rand index of Rand (1971), \"adjusted_rand\" means the adjusted Rand index of Hubert and Arabie (1985).",
            "remove_none": "whether to remove None entries from the membership lists. This is handy if your Clustering object was constructed using VertexClustering.FromAttribute using an attribute which was not defined for all the vertices. If  is False, a None entry in either comm1 or comm2 will result in an exception. If  is True, None values are filtered away and only the remaining lists are compared."
        },
        "Section_id": "compare_communities"
    },
    {
        "Section_id": "compare_communities",
        "Return": [
            "the calculated measure."
        ]
    },
    {
        "Raises": {},
        "Section_id": "compare_communities"
    },
    {
        "Section_id": "compare_communities",
        "References": [
            "all the degrees are non-negative",
            "for undirected graphs, the sum of degrees are even",
            "for directed graphs, the two degree sequences are of the same length and equal sums"
        ]
    },
    {
        "Section_id": "compare_communities",
        "See Also": ""
    },
    {
        "Section_id": "split_join_distance",
        "Description": "Calculates the split-join distance between two community structures.\nThe split-join distance is a distance measure defined on the space of partitions of a given set. It is the sum of the projection distance of one partition from the other and vice versa, where the projection number of A from B is if calculated as follows:For each set in A, find the set in B with which it has the maximal overlap, and take note of the size of the overlap.Take the sum of the maximal overlap sizes for each set in A.Subtract the sum from n, the number of elements in the partition.\nNote that the projection distance is asymmetric, that's why it has to be calculated in both directions and then added together.  This function returns the projection distance of comm1 from comm2 and the projection distance of comm2 from comm1, and returns them in a pair. The actual split-join distance is the sum of the two distances. The reason why it is presented this way is that one of the elements being zero then implies that one of the partitions is a subpartition of the other (and if it is close to zero, then one of the partitions is close to being a subpartition of the other).\nReference: van Dongen S: Performance criteria for graph clustering and Markov cluster experiments. Technical Report INS-R0012, National Research Institute for Mathematics and Computer Science in the Netherlands, Amsterdam, May 2000."
    },
    {
        "Paramters": {
            "comm1": "the first community structure as a membership list or as a Clustering object.",
            "comm2": "the second community structure as a membership list or as a Clustering object.",
            "remove_none": "whether to remove None entries from the membership lists. This is handy if your Clustering object was constructed using VertexClustering.FromAttribute using an attribute which was not defined for all the vertices. If  is False, a None entry in either comm1 or comm2 will result in an exception. If  is True, None values are filtered away and only the remaining lists are compared."
        },
        "Section_id": "split_join_distance"
    },
    {
        "Section_id": "split_join_distance",
        "Return": [
            "the projection distance of comm1 from comm2 and vice versa in a tuple. The split-join distance is the sum of the two."
        ]
    },
    {
        "Raises": {},
        "Section_id": "split_join_distance"
    },
    {
        "Section_id": "split_join_distance",
        "See Also": "compare_communities() with method = \"split-join\" if you are not interested in the individual projection distances but only the sum of them."
    },
    {
        "Section_id": "get_include",
        "Description": "Returns the folder that contains the C API headers of the Python interface of igraph."
    },
    {
        "Paramters": {},
        "Section_id": "get_include"
    },
    {
        "Raises": {},
        "Section_id": "get_include"
    },
    {
        "Section_id": "get_include",
        "See Also": ""
    },
    {
        "Section_id": "read",
        "Description": "Loads a graph from the given filename.\nThis is just a convenience function, calls Graph.Read directly. All arguments are passed unchanged to Graph.Read"
    },
    {
        "Paramters": {
            "filename": "the name of the file to be loaded",
            "*args": "Undocumented",
            "**kwds": "Undocumented"
        },
        "Section_id": "read"
    },
    {
        "Raises": {},
        "Section_id": "read"
    },
    {
        "Section_id": "read",
        "See Also": ""
    },
    {
        "Section_id": "write",
        "Description": "Saves a graph to the given file.\nThis is just a convenience function, calls Graph.write directly. All arguments are passed unchanged to Graph.write"
    },
    {
        "Paramters": {
            "graph": "the  to be saved",
            "filename": "the name of the file to be written",
            "*args": "Undocumented",
            "**kwds": "Undocumented"
        },
        "Section_id": "write"
    },
    {
        "Raises": {},
        "Section_id": "write"
    },
    {
        "Section_id": "write",
        "See Also": ""
    },
    {
        "Section_id": "__license__",
        "Description": "Undocumented"
    },
    {
        "Section_id": "__version__",
        "Description": "Undocumented"
    },
    {
        "Section_id": "__version_info__",
        "Description": "Undocumented"
    },
    {
        "Section_id": "config",
        "Description": "The main configuration object of igraph. Use this object to modify igraph's behaviour, typically when used in interactive mode."
    },
    {
        "Section_id": "CairoVertexDrawer",
        "Description": "The default vertex drawer implementation of igraph."
    },
    {
        "Field List > Methods > __init__": {
            "Description": "overrides igraph.drawing.cairo.vertex.AbstractCairoVertexDrawer.__init__\nConstructs the vertex drawer and associates it to the given Cairo context and the given BoundingBox.",
            "Paramters": {
                "context": "the  on which we will draw",
                "bbox": "the bounding box within which we will draw. Can be anything accepted by the constructor of BoundingBox (i.e., a 2-tuple, a 4-tuple or a BoundingBox object).",
                "palette": "the  that can be used to map integer color indices to colors when drawing vertices",
                "layout": "the  of the vertices in the graph being drawn"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "CairoVertexDrawer"
    },
    {
        "Field List > Methods > draw": {
            "Description": "overrides igraph.drawing.baseclasses.AbstractVertexDrawer.draw\nDraws the given vertex.",
            "Paramters": {
                "visual_vertex": "object specifying the visual properties of the vertex. Its structure is defined by the VisualVertexBuilder of the CairoGraphDrawer; see its source code.",
                "vertex": "the raw igraph  being drawn",
                "coords": "the X and Y coordinates of the vertex as specified by the layout algorithm, scaled into the bounding box."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "CairoVertexDrawer"
    },
    {
        "Field List > property": {},
        "Section_id": "CairoVertexDrawer"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "CairoVertexDrawer"
    },
    {
        "Section_id": "Matching",
        "Description": "A matching of vertices in a graph.\nA matching of an undirected graph is a set of edges such that each vertex is incident on at most one matched edge. When each vertex is incident on exactly one matched edge, the matching called perfect. This class is used in igraph to represent non-perfect and perfect matchings in undirected graphs.\nThis class is usually not instantiated directly, everything is taken care of by the functions that return matchings.\n"
    },
    {
        "Field List > Methods > __init__": {
            "Description": "Initializes the matching.",
            "Paramters": {
                "graph": "the  the matching belongs to",
                "matching": "a numeric vector where element i corresponds to vertex i of the graph. Element i is -1 or if the corresponding vertex is unmatched, otherwise it contains the index of the vertex to which vertex i is matched.",
                "types": "the  of the vertices if the graph is bipartite. It must either be the name of a vertex attribute (which will be retrieved for all vertices) or a list. Elements in the list will be converted to boolean values True or False, and this will determine which part of the bipartite graph a given vertex belongs to."
            },
            "Return": [],
            "References": [],
            "Rasises": {
                "ValueError": "if the matching vector supplied does not describe a valid matching of the graph."
            },
            "See Also": "",
            "example": []
        },
        "Section_id": "Matching"
    },
    {
        "Field List > Methods > __len__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Matching"
    },
    {
        "Field List > Methods > __repr__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Matching"
    },
    {
        "Field List > Methods > __str__": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Matching"
    },
    {
        "Field List > Methods > edges": {
            "Description": "Returns an edge sequence that contains the edges in the matching.\nIf there are multiple edges between a pair of matched vertices, only one of them will be returned.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Matching"
    },
    {
        "Field List > Methods > is_matched": {
            "Description": "Returns whether the given vertex is matched to another one.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Matching"
    },
    {
        "Field List > Methods > is_maximal": {
            "Description": "Returns whether the matching is maximal.\nA matching is maximal when it is not possible to extend it any more with extra edges; in other words, unmatched vertices in the graph must be adjacent to matched vertices only.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Matching"
    },
    {
        "Field List > Methods > match_of": {
            "Description": "Returns the vertex a given vertex is matched to.",
            "Paramters": {
                "vertex": "the  we are interested in; either an integer index or an instance of Vertex."
            },
            "Return": [
                "the index of the vertex matched to the given vertex, either as an integer index (if vertex was integer) or as an instance of Vertex. When the vertex is unmatched, returns None."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Matching"
    },
    {
        "Field List > Methods > matching": {
            "Description": "Sets the matching vector.",
            "Paramters": {
                "value": "the matching vector which must contain the ID of the vertex matching vertex i at the ith position, or -1 if the vertex is unmatched."
            },
            "Return": [],
            "References": [],
            "Rasises": {
                "ValueError": "if the matching vector supplied does not describe a valid matching of the graph."
            },
            "See Also": "",
            "example": []
        },
        "Section_id": "Matching"
    },
    {
        "Field List > Methods > types": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Matching"
    },
    {
        "Field List > property": {
            "graph": "Returns the graph corresponding to the matching.\n",
            "matching": "Returns the matching vector where element i contains the ID of the vertex that vertex i is matched to.\nThe matching vector will contain -1 for unmatched vertices.\n\n",
            "types": "Returns the type vector if the graph is bipartite.\nElement i of the type vector will be False or True depending on which side of the bipartite graph vertex i belongs to.\nFor non-bipartite graphs, this property returns None.\n\n"
        },
        "Section_id": "Matching"
    },
    {
        "Rubric": {
            "Example": [
                "Examples:\n>>> from igraph import Graph\n>>> g = Graph.Famous(\"noperfectmatching\")\n>>> matching = g.maximum_matching()"
            ]
        },
        "Section_id": "Matching"
    },
    {
        "Section_id": "MatplotlibEdgeDrawer",
        "Description": "Matplotlib-specific abstract edge drawer object."
    },
    {
        "Field List > Methods > __init__": {
            "Description": "Constructs the edge drawer.",
            "Paramters": {
                "context": "a Matplotlib axes object on which the edges will be drawn.",
                "palette": "the  that can be used to map integer color indices to colors when drawing edges"
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "MatplotlibEdgeDrawer"
    },
    {
        "Field List > Methods > build_patch": {
            "Description": "Undocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "MatplotlibEdgeDrawer"
    },
    {
        "Field List > Methods > draw_directed_edge": {
            "Description": "overrides igraph.drawing.baseclasses.AbstractEdgeDrawer.draw_directed_edge\nDraws a directed edge.",
            "Paramters": {
                "edge": "the  to be drawn. Visual properties of the  are defined by the attributes of this object.",
                "src_vertex": "the source vertex. Visual properties are defined by the attributes of this object.",
                "dest_vertex": "the source vertex. Visual properties are defined by the attributes of this object."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "MatplotlibEdgeDrawer"
    },
    {
        "Field List > Methods > draw_undirected_edge": {
            "Description": "overrides igraph.drawing.baseclasses.AbstractEdgeDrawer.draw_undirected_edge\nDraws an undirected edge.",
            "Paramters": {
                "edge": "the  to be drawn. Visual properties of the  are defined by the attributes of this object.",
                "src_vertex": "the source vertex. Visual properties are defined by the attributes of this object.",
                "dest_vertex": "the source vertex. Visual properties are defined by the attributes of this object."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "MatplotlibEdgeDrawer"
    },
    {
        "Field List > Methods > get_label_position": {
            "Description": "Inherited from AbstractEdgeDrawer:Returns the position where the label of an edge should be drawn. the default implementation returns the midpoint of the edge and an alignment that tries to avoid overlapping the label with the edge."
        },
        "Section_id": "MatplotlibEdgeDrawer"
    },
    {
        "Field List > Methods > get_label_rotation": {
            "Description": "Inherited from AbstractEdgeDrawer:Get the rotation angle of the label to align with the edge."
        },
        "Section_id": "MatplotlibEdgeDrawer"
    },
    {
        "Field List > property": {},
        "Section_id": "MatplotlibEdgeDrawer"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "MatplotlibEdgeDrawer"
    },
    {
        "Section_id": "ClassicPythonShell",
        "Description": "Classic Python shell interface.\nThis class allows igraph to be embedded in Python's shell."
    },
    {
        "Field List > Methods > __call__": {
            "Description": "overrides igraph.app.shell.Shell.__call__\nStarts the embedded shell.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "ClassicPythonShell"
    },
    {
        "Field List > Methods > __init__": {
            "Description": "overrides igraph.app.shell.ConsoleProgressBarMixin.__init__\nConstructor.\nImports Python's classic shell",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "ClassicPythonShell"
    },
    {
        "Field List > Methods > get_progress_handler": {
            "Description": "Inherited from Shell:Returns the progress handler (if exists) or None (if not)."
        },
        "Section_id": "ClassicPythonShell"
    },
    {
        "Field List > Methods > get_status_handler": {
            "Description": "Inherited from Shell:Returns the status handler (if exists) or None (if not)."
        },
        "Section_id": "ClassicPythonShell"
    },
    {
        "Field List > Methods > supports_progress_bar": {
            "Description": "Inherited from Shell:Checks whether the shell supports progress bars."
        },
        "Section_id": "ClassicPythonShell"
    },
    {
        "Field List > Methods > supports_status_messages": {
            "Description": "Inherited from Shell:Checks whether the shell supports status messages."
        },
        "Section_id": "ClassicPythonShell"
    },
    {
        "Field List > property": {},
        "Section_id": "ClassicPythonShell"
    },
    {
        "Rubric": {
            "Example": []
        },
        "Section_id": "ClassicPythonShell"
    },
    {
        "Section_id": "Clustering",
        "Description": "Class representing a clustering of an arbitrary ordered set.\nThis is now used as a base for VertexClustering, but it might be useful for other purposes as well.\n"
    },
    {
        "Field List > Methods > __getitem__": {
            "Description": "Returns the members of the specified cluster.",
            "Paramters": {
                "idx": "the index of the cluster"
            },
            "Return": [
                "the members of the specified cluster as a list"
            ],
            "References": [],
            "Rasises": {
                "IndexError": "if the index is out of bounds"
            },
            "See Also": "",
            "example": []
        },
        "Section_id": "Clustering"
    },
    {
        "Field List > Methods > __init__": {
            "Description": "overridden in igraph.VertexClustering\nConstructor.",
            "Paramters": {
                "membership": "the  list -- that is, the cluster index in which each element of the set belongs to.",
                "params": "additional parameters to be stored in this object's dictionary."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Clustering"
    },
    {
        "Field List > Methods > __iter__": {
            "Description": "Iterates over the clusters in this clustering.\nThis method will return a generator that generates the clusters one by one.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Clustering"
    },
    {
        "Field List > Methods > __len__": {
            "Description": "Returns the number of clusters.",
            "Paramters": {},
            "Return": [
                "the number of clusters"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Clustering"
    },
    {
        "Field List > Methods > __str__": {
            "Description": "overridden in igraph.Cut\nUndocumented",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Clustering"
    },
    {
        "Field List > Methods > as_cover": {
            "Description": "overridden in igraph.VertexClustering\nReturns a Cover that contains the same clusters as this clustering.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Clustering"
    },
    {
        "Field List > Methods > compare_to": {
            "Description": "Compares this clustering to another one using some similarity or distance metric.\nThis is a convenience method that simply calls compare_communities with the two clusterings as arguments. Any extra positional or keyword argument is also forwarded to compare_communities.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Clustering"
    },
    {
        "Field List > Methods > size": {
            "Description": "Returns the size of a given cluster.",
            "Paramters": {
                "idx": "the cluster in which we are interested."
            },
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Clustering"
    },
    {
        "Field List > Methods > size_histogram": {
            "Description": "Returns the histogram of cluster sizes.",
            "Paramters": {
                "bin_width": "the bin width of the histogram"
            },
            "Return": [
                "a Histogram object"
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Clustering"
    },
    {
        "Field List > Methods > sizes": {
            "Description": "Returns the size of given clusters.\nThe indices are given as positional arguments. If there are no positional arguments, the function will return the sizes of all clusters.",
            "Paramters": {},
            "Return": [],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Clustering"
    },
    {
        "Field List > Methods > summary": {
            "Description": "Returns the summary of the clustering.\nThe summary includes the number of items and clusters, and also the list of members for each of the clusters if the verbosity is nonzero.",
            "Paramters": {
                "verbosity": "determines whether the cluster members should be printed. Zero  prints the number of items and clusters only.",
                "width": "Undocumented"
            },
            "Return": [
                "the summary of the clustering as a string."
            ],
            "References": [],
            "Rasises": {},
            "See Also": "",
            "example": []
        },
        "Section_id": "Clustering"
    },
    {
        "Field List > property": {
            "membership": "Returns the membership vector.\n",
            "n": "Returns the number of elements covered by this clustering.\n"
        },
        "Section_id": "Clustering"
    },
    {
        "Rubric": {
            "Example": [
                "Members of an individual cluster can be accessed by the [] operator:\n>>> cl = Clustering([0,0,0,0,1,1,1,2,2,2,2])\n>>> cl[0]\n[0, 1, 2, 3]\n",
                "The membership vector can be accessed by the membership property:\n>>> cl = Clustering([0,0,0,0,1,1,1,2,2,2,2])\n>>> cl[0]\n[0, 1, 2, 3]\n",
                "The number of clusters can be retrieved by the len function:\n>>> cl = Clustering([0,0,0,0,1,1,1,2,2,2,2])\n>>> cl[0]\n[0, 1, 2, 3]\n",
                "You can iterate over the clustering object as if it were a regular list of clusters:\n>>> cl = Clustering([0,0,0,0,1,1,1,2,2,2,2])\n>>> cl[0]\n[0, 1, 2, 3]\n",
                "If you need all the clusters at once as lists, you can simply convert the clustering object to a list:\n>>> cl = Clustering([0,0,0,0,1,1,1,2,2,2,2])\n>>> cl[0]\n[0, 1, 2, 3]\n"
            ]
        },
        "Section_id": "Clustering"
    }
]