[
    {
        "Section_id": "NodeClustering",
        "Description": "Node Communities representation."
    },
    {
        "Field List > Parameters": {
            "communities": "list of communities",
            "graph": "a networkx/igraph object",
            "method_name": "community discovery algorithm name",
            "method_parameters": "configuration for the community discovery algorithm used",
            "overlap": "boolean, whether the partition is overlapping or not"
        },
        "Section_id": "NodeClustering"
    },
    {
        "Field List > Methods > adjusted_mutual_information": {
            "Paramters": {
                "clustering": "NodeClustering object"
            },
            "Return": [
                "AMI score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.adjusted_mutual_information(leiden_communities)"
            ],
            "References": [
                "Vinh, N. X., Epps, J., & Bailey, J. (2010). Information theoretic measures for clusterings comparison: Variants, properties, normalization and correction for chance. Journal of Machine Learning Research, 11(Oct), 2837-2854."
            ],
            "Description": "Adjusted Mutual Information between two clusterings.\nAdjusted Mutual Information (AMI) is an adjustment of the Mutual\nInformation (MI) score to account for chance. It accounts for the fact that\nthe MI is generally higher for two clusterings with a larger number of\nclusters, regardless of whether there is actually more information shared.\nFor two clusterings \\(U\\) and \\(V\\), the AMI is given as:\nAMI(U, V) = [MI(U, V) - E(MI(U, V))] / [max(H(U), H(V)) - E(MI(U, V))]\n\nThis metric is independent of the absolute values of the labels:\na permutation of the class or cluster label values won\u2019t change the\nscore value in any way.\nThis metric is furthermore symmetric: switching label_true with\nlabel_pred will return the same score value. This can be useful to\nmeasure the agreement of two independent label assignments strategies\non the same dataset when the real ground truth is not known.\nBe mindful that this function is an order of magnitude slower than other\nmetrics, such as the Adjusted Rand Index.\n"
        },
        "Section_id": "NodeClustering"
    },
    {
        "Field List > Methods > adjusted_rand_index": {
            "Paramters": {
                "clustering": "NodeClustering object"
            },
            "Return": [
                "ARI score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.adjusted_rand_index(leiden_communities)"
            ],
            "References": [
                "Hubert, L., & Arabie, P. (1985). Comparing partitions. Journal of classification, 2(1), 193-218."
            ],
            "Description": "Rand index adjusted for chance.\nThe Rand Index computes a similarity measure between two clusterings\nby considering all pairs of samples and counting pairs that are\nassigned in the same or different clusters in the predicted and\ntrue clusterings.\nThe raw RI score is then \u201cadjusted for chance\u201d into the ARI score\nusing the following scheme:\nARI = (RI - Expected_RI) / (max(RI) - Expected_RI)\n\nThe adjusted Rand index is thus ensured to have a value close to\n0.0 for random labeling independently of the number of clusters and\nsamples and exactly 1.0 when the clusterings are identical (up to\na permutation).\nARI is a symmetric measure:\nadjusted_rand_index(a, b) == adjusted_rand_index(b, a)\n\n"
        },
        "Section_id": "NodeClustering"
    },
    {
        "Field List > Methods > average_internal_degree": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.average_internal_degree()"
            ],
            "References": [],
            "Description": "The average internal degree of the algorithms set.\n\n\\[f(S) = \\frac{2m_S}{n_S}\\]\nwhere \\(m_S\\) is the number of algorithms internal edges and \\(n_S\\) is the number of algorithms nodes.\n"
        },
        "Section_id": "NodeClustering"
    },
    {
        "Field List > Methods > avg_distance": {
            "Paramters": {
                "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
            },
            "Return": [
                "If summary==True a FitnessResult object, otherwise a list of floats."
            ],
            "Example": [],
            "References": [],
            "Description": "Average distance.\nThe average distance of a community is defined average path length across all possible pair of nodes composing it.\n"
        },
        "Section_id": "NodeClustering"
    },
    {
        "Field List > Methods > avg_embeddedness": {
            "Paramters": {
                "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
            },
            "Return": [
                "If summary==True a FitnessResult object, otherwise a list of floats."
            ],
            "Example": [],
            "References": [],
            "Description": "Average embeddedness of nodes within the community.\nThe embeddedness of a node n w.r.t. a community C is the ratio of its degree within the community and its overall degree.\n\n\\[emb(n,C) = \\frac{k_n^C}{k_n}\\]\nThe average embeddedness of a community C is:\n\n\\[avg_embd(c) = \\frac{1}{|C|} \\sum_{i \\in C} \\frac{k_n^C}{k_n}\\]\n"
        },
        "Section_id": "NodeClustering"
    },
    {
        "Field List > Methods > avg_odf": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.avg_odf()"
            ],
            "References": [],
            "Description": "Average fraction of edges of a node of a algorithms that point outside the algorithms itself.\n\n\\[\\frac{1}{n_S} \\sum_{u \\in S} \\frac{|\\{(u,v)\\in E: v \\not\\in S\\}|}{d(u)}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\), \\(d(u)\\) is the degree of \\(u\\) and \\(n_S\\) is the set of algorithms nodes.\n"
        },
        "Section_id": "NodeClustering"
    },
    {
        "Field List > Methods > avg_transitivity": {
            "Paramters": {
                "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
            },
            "Return": [
                "If summary==True a FitnessResult object, otherwise a list of floats."
            ],
            "Example": [],
            "References": [],
            "Description": "Average transitivity.\nThe average transitivity of a community is defined the as the average clustering coefficient of its nodes w.r.t. their connection within the community itself.\n"
        },
        "Section_id": "NodeClustering"
    },
    {
        "Field List > Methods > conductance": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.conductance()"
            ],
            "References": [],
            "Description": "Fraction of total edge volume that points outside the algorithms.\n\n\\[f(S) = \\frac{c_S}{2 m_S+c_S}\\]\nwhere \\(c_S\\) is the number of algorithms nodes and, \\(m_S\\) is the number of algorithms edges\n"
        },
        "Section_id": "NodeClustering"
    },
    {
        "Field List > Methods > cut_ratio": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.cut_ratio()"
            ],
            "References": [],
            "Description": "Fraction of existing edges (out of all possible edges) leaving the algorithms.\n..math:: f(S) = frac{c_S}{n_S (n \u2212 n_S)}\nwhere \\(c_S\\) is the number of algorithms nodes and, \\(n_S\\) is the number of edges on the algorithms boundary\n"
        },
        "Section_id": "NodeClustering"
    },
    {
        "Field List > Methods > edges_inside": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.edges_inside()"
            ],
            "References": [],
            "Description": "Number of edges internal to the algorithms.\n"
        },
        "Section_id": "NodeClustering"
    },
    {
        "Field List > Methods > erdos_renyi_modularity": {
            "Paramters": {},
            "Return": [
                "the Erdos-Renyi modularity score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.erdos_renyi_modularity()"
            ],
            "References": [],
            "Description": "Erdos-Renyi modularity is a variation of the Newman-Girvan one.\nIt assumes that vertices in a network are connected randomly with a constant probability \\(p\\).\n\n\\[Q(S) = \\frac{1}{m}\\sum_{c \\in S} (m_S \u2212 \\frac{mn_S(n_S \u22121)}{n(n\u22121)})\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms edges, \\(l_S\\) is the number of edges from nodes in S to nodes outside S.\n"
        },
        "Section_id": "NodeClustering"
    },
    {
        "Field List > Methods > expansion": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.expansion()"
            ],
            "References": [],
            "Description": "Number of edges per algorithms node that point outside the cluster.\n\n\\[f(S) = \\frac{c_S}{n_S}\\]\nwhere \\(n_S\\) is the number of edges on the algorithms boundary, \\(c_S\\) is the number of algorithms nodes.\n"
        },
        "Section_id": "NodeClustering"
    },
    {
        "Field List > Methods > f1": {
            "Paramters": {
                "clustering": "NodeClustering object"
            },
            "Return": [
                "F1 score (harmonic mean of precision and recall)"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.f1(leiden_communities)"
            ],
            "References": [
                "Rossetti, G., Pappalardo, L., & Rinzivillo, S. (2016). A novel approach to evaluate algorithms detection internal on ground truth. In Complex Networks VII (pp. 133-144). Springer, Cham."
            ],
            "Description": "Compute the average F1 score of the optimal algorithms matches among the partitions in input.\nWorks on overlapping/non-overlapping complete/partial coverage partitions.\n"
        },
        "Section_id": "NodeClustering"
    },
    {
        "Field List > Methods > flake_odf": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.flake_odf()"
            ],
            "References": [],
            "Description": "Fraction of nodes in S that have fewer edges pointing inside than to the outside of the algorithms.\n\n\\[f(S) = \\frac{| \\{ u:u \\in S,| \\{(u,v) \\in E: v \\in S \\}| < d(u)/2 \\}|}{n_S}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\), \\(d(u)\\) is the degree of \\(u\\) and \\(n_S\\) is the set of algorithms nodes.\n"
        },
        "Section_id": "NodeClustering"
    },
    {
        "Field List > Methods > fraction_over_median_degree": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.fraction_over_median_degree()"
            ],
            "References": [],
            "Description": "Fraction of algorithms nodes of having internal degree higher than the median degree value.\n\n\\[f(S) = \\frac{|\\{u: u \\in S,| \\{(u,v): v \\in S\\}| > d_m\\}| }{n_S}\\]\nwhere \\(d_m\\) is the internal degree median value\n"
        },
        "Section_id": "NodeClustering"
    },
    {
        "Field List > Methods > get_description": {
            "Paramters": {
                "parameters_to_display": "parameters to display. By default, all float parameters.",
                "precision": "precision used to plot parameters. default: 3"
            },
            "Return": [
                "a string description of the method.\n"
            ],
            "Example": [],
            "References": [],
            "Description": "Return a description of the clustering, with the name of the method and its numeric parameters.\n"
        },
        "Section_id": "NodeClustering"
    },
    {
        "Field List > Methods > hub_dominance": {
            "Paramters": {
                "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
            },
            "Return": [
                "If summary==True a FitnessResult object, otherwise a list of floats."
            ],
            "Example": [],
            "References": [],
            "Description": "Hub dominance.\nThe hub dominance of a community is defined as the ratio of the degree of its most connected node w.r.t. the theoretically maximal degree within the community.\n"
        },
        "Section_id": "NodeClustering"
    },
    {
        "Field List > Methods > internal_edge_density": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.internal_edge_density()"
            ],
            "References": [],
            "Description": "The internal density of the algorithms set.\n\n\\[f(S) = \\frac{m_S}{n_S(n_S\u22121)/2}\\]\nwhere \\(m_S\\) is the number of algorithms internal edges and \\(n_S\\) is the number of algorithms nodes.\n"
        },
        "Section_id": "NodeClustering"
    },
    {
        "Field List > Methods > link_modularity": {
            "Paramters": {},
            "Return": [
                "the link modularity score"
            ],
            "Example": [
                "from cdlib import evaluation\nfrom cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.link_modularity()"
            ],
            "References": [],
            "Description": "Quality function designed for directed graphs with overlapping communities.\n"
        },
        "Section_id": "NodeClustering"
    },
    {
        "Field List > Methods > max_odf": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.max_odf()"
            ],
            "References": [],
            "Description": "Maximum fraction of edges of a node of a algorithms that point outside the algorithms itself.\n\n\\[max_{u \\in S} \\frac{|\\{(u,v)\\in E: v \\not\\in S\\}|}{d(u)}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\) and \\(d(u)\\) is the degree of \\(u\\)\n"
        },
        "Section_id": "NodeClustering"
    },
    {
        "Field List > Methods > modularity_density": {
            "Paramters": {},
            "Return": [
                "the modularity density score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.modularity_density()"
            ],
            "References": [],
            "Description": "The modularity density is one of several propositions that envisioned to palliate the resolution limit issue of modularity based measures.\nThe idea of this metric is to include the information about algorithms size into the expected density of algorithms to avoid the negligence of small and dense communities.\nFor each algorithms \\(C\\) in partition \\(S\\), it uses the average modularity degree calculated by \\(d(C) = d^{int(C)} \u2212 d^{ext(C)}\\) where \\(d^{int(C)}\\) and \\(d^{ext(C)}\\) are the average internal and external degrees of \\(C\\) respectively to evaluate the fitness of \\(C\\) in its network.\nFinally, the modularity density can be calculated as follows:\n\n\\[Q(S) = \\sum_{C \\in S} \\frac{1}{n_C} ( \\sum_{i \\in C} k^{int}_{iC} - \\sum_{i \\in C} k^{out}_{iC})\\]\nwhere \\(n_C\\) is the number of nodes in C, \\(k^{int}_{iC}\\) is the degree of node i within \\(C\\) and \\(k^{out}_{iC}\\) is the deree of node i outside \\(C\\).\n"
        },
        "Section_id": "NodeClustering"
    },
    {
        "Field List > Methods > modularity_overlap": {
            "Paramters": {
                "weight": "label identifying the edge weight parameter name (if present), default None"
            },
            "Return": [
                "FitnessResult object"
            ],
            "Example": [],
            "References": [
                "\nLazar, D. Abel and T. Vicsek, \u201cModularity measure of networks with overlapping communities\u201d  EPL, 90 (2010) 18001 doi: 10.1209/0295-5075/90/18001\n\n",
                "Lazar, D. Abel and T. Vicsek, \u201cModularity measure of networks with overlapping communities\u201d  EPL, 90 (2010) 18001 doi: 10.1209/0295-5075/90/18001"
            ],
            "Description": "Determines the Overlapping Modularity of a partition C on a graph G.\nOverlapping Modularity is defined as\n\n\\[M_{c_{r}}^{ov} = \\sum_{i \\in c_{r}} \\frac{\\sum_{j \\in c_{r}, i \\neq j}a_{ij} - \\sum_{j \\not \\in c_{r}}a_{ij}}{d_{i} \\cdot s_{i}} \\cdot \\frac{n_{c_{r}}^{e}}{n_{c_{r}} \\cdot \\binom{n_{c_{r}}}{2}}\\]\n"
        },
        "Section_id": "NodeClustering"
    },
    {
        "Field List > Methods > newman_girvan_modularity": {
            "Paramters": {},
            "Return": [
                "the Newman-Girvan modularity score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.newman_girvan_modularity()"
            ],
            "References": [],
            "Description": "Difference the fraction of intra algorithms edges of a partition with the expected number of such edges if distributed according to a null model.\nIn the standard version of modularity, the null model preserves the expected degree sequence of the graph under consideration. In other words, the modularity compares the real network structure with a corresponding one where nodes are connected without any preference about their neighbors.\n\n\\[Q(S) = \\frac{1}{m}\\sum_{c \\in S}(m_S - \\frac{(2 m_S + l_S)^2}{4m})\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms edges, \\(l_S\\) is the number of edges from nodes in S to nodes outside S.\n"
        },
        "Section_id": "NodeClustering"
    },
    {
        "Field List > Methods > nf1": {
            "Paramters": {
                "clustering": "NodeClustering object"
            },
            "Return": [
                "MatchingResult instance"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.nf1(leiden_communities)"
            ],
            "References": [
                "Rossetti, G., Pappalardo, L., & Rinzivillo, S. (2016). A novel approach to evaluate algorithms detection internal on ground truth.",
                "Rossetti, G. (2017). : RDyn: graph benchmark handling algorithms dynamics. Journal of Complex Networks. 5(6), 893-912."
            ],
            "Description": "Compute the Normalized F1 score of the optimal algorithms matches among the partitions in input.\nWorks on overlapping/non-overlapping complete/partial coverage partitions.\n"
        },
        "Section_id": "NodeClustering"
    },
    {
        "Field List > Methods > normalized_cut": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.normalized_cut()"
            ],
            "References": [],
            "Description": "Normalized variant of the Cut-Ratio\n\n\\[: f(S) = \\frac{c_S}{2m_S+c_S} + \\frac{c_S}{2(m\u2212m_S )+c_S}\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms internal edges and \\(c_S\\) is the number of algorithms nodes.\n"
        },
        "Section_id": "NodeClustering"
    },
    {
        "Field List > Methods > normalized_mutual_information": {
            "Paramters": {
                "clustering": "NodeClustering object"
            },
            "Return": [
                "normalized mutual information score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.normalized_mutual_information(leiden_communities)"
            ],
            "References": [],
            "Description": "Normalized Mutual Information between two clusterings.\nNormalized Mutual Information (NMI) is an normalization of the Mutual\nInformation (MI) score to scale the results between 0 (no mutual\ninformation) and 1 (perfect correlation). In this function, mutual\ninformation is normalized by sqrt(H(labels_true) * H(labels_pred))\n"
        },
        "Section_id": "NodeClustering"
    },
    {
        "Field List > Methods > omega": {
            "Paramters": {
                "clustering": "NodeClustering object"
            },
            "Return": [
                "omega index"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.omega(leiden_communities)"
            ],
            "References": [
                "Gabriel Murray, Giuseppe Carenini, and Raymond Ng. 2012. Using the omega index for evaluating abstractive algorithms detection. In Proceedings of Workshop on Evaluation Metrics and System Comparison for Automatic Summarization. Association for Computational Linguistics, Stroudsburg, PA, USA, 10-18."
            ],
            "Description": "Index of resemblance for overlapping, complete coverage, network clusterings.\n"
        },
        "Section_id": "NodeClustering"
    },
    {
        "Field List > Methods > overlapping_normalized_mutual_information_LFK": {
            "Paramters": {
                "clustering": "NodeClustering object"
            },
            "Return": [
                "onmi score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.overlapping_normalized_mutual_information_LFK(leiden_communities)"
            ],
            "References": [
                "Lancichinetti, A., Fortunato, S., & Kertesz, J. (2009). Detecting the overlapping and hierarchical community structure in complex networks. New Journal of Physics, 11(3), 033015."
            ],
            "Description": "Overlapping Normalized Mutual Information between two clusterings.\nExtension of the Normalized Mutual Information (NMI) score to cope with overlapping partitions.\nThis is the version proposed by Lancichinetti et al.\n"
        },
        "Section_id": "NodeClustering"
    },
    {
        "Field List > Methods > overlapping_normalized_mutual_information_MGH": {
            "Paramters": {
                "clustering": "NodeClustering object",
                "normalization": "one of \u201cmax\u201d or \u201cLFK\u201d. Default \u201cmax\u201d (corresponds to the main method described in the article)"
            },
            "Return": [
                "onmi score\n"
            ],
            "Example": [
                "from cdlib import evaluation, algorithms\ng = nx.karate_club_graph()\nlouvain_communities = algorithms.louvain(g)\nleiden_communities = algorithms.leiden(g)\nevaluation.overlapping_normalized_mutual_information_MGH(louvain_communities,leiden_communities)"
            ],
            "References": [
                "McDaid, A. F., Greene, D., & Hurley, N. (2011). Normalized mutual information to evaluate overlapping community finding algorithms. arXiv preprint arXiv:1110.2515. Chicago"
            ],
            "Description": "Overlapping Normalized Mutual Information between two clusterings.\nExtension of the Normalized Mutual Information (NMI) score to cope with overlapping partitions.\nThis is the version proposed by McDaid et al. using a different normalization than the original LFR one. See ref.\nfor more details.\n"
        },
        "Section_id": "NodeClustering"
    },
    {
        "Field List > Methods > scaled_density": {
            "Paramters": {
                "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
            },
            "Return": [
                "If summary==True a FitnessResult object, otherwise a list of floats."
            ],
            "Example": [],
            "References": [],
            "Description": "Scaled density.\nThe scaled density of a community is defined as the ratio of the community density w.r.t. the complete graph density.\n"
        },
        "Section_id": "NodeClustering"
    },
    {
        "Field List > Methods > significance": {
            "Paramters": {},
            "Return": [
                "the significance score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.significance()"
            ],
            "References": [],
            "Description": "Significance estimates how likely a partition of dense communities appear in a random graph.\n"
        },
        "Section_id": "NodeClustering"
    },
    {
        "Field List > Methods > size": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [],
            "References": [],
            "Description": "Size is the number of nodes in the community\n"
        },
        "Section_id": "NodeClustering"
    },
    {
        "Field List > Methods > surprise": {
            "Paramters": {},
            "Return": [
                "the surprise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.surprise()"
            ],
            "References": [],
            "Description": "Surprise is statistical approach proposes a quality metric assuming that edges between vertices emerge randomly according to a hyper-geometric distribution.\nAccording to the Surprise metric, the higher the score of a partition, the less likely it is resulted from a random realization, the better the quality of the algorithms structure.\n"
        },
        "Section_id": "NodeClustering"
    },
    {
        "Field List > Methods > to_json": {
            "Paramters": {},
            "Return": [
                "a JSON formatted string representing the object"
            ],
            "Example": [],
            "References": [],
            "Description": "Generate a JSON representation of the algorithms object\n"
        },
        "Section_id": "NodeClustering"
    },
    {
        "Field List > Methods > to_node_community_map": {
            "Paramters": {},
            "Return": [
                "dict of the form <node, list(communities)>"
            ],
            "Example": [],
            "References": [],
            "Description": "Generate a <node, list(communities)> representation of the current clustering\n"
        },
        "Section_id": "NodeClustering"
    },
    {
        "Field List > Methods > triangle_participation_ratio": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.triangle_participation_ratio()"
            ],
            "References": [],
            "Description": "Fraction of algorithms nodes that belong to a triad.\n\n\\[f(S) = \\frac{ | \\{ u: u \\in S,\\{(v,w):v, w \\in S,(u,v) \\in E,(u,w) \\in E,(v,w) \\in E \\} \\not = \\emptyset \\} |}{n_S}\\]\nwhere \\(n_S\\) is the set of algorithms nodes.\n"
        },
        "Section_id": "NodeClustering"
    },
    {
        "Field List > Methods > variation_of_information": {
            "Paramters": {
                "clustering": "NodeClustering object"
            },
            "Return": [
                "VI score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.variation_of_information(leiden_communities)"
            ],
            "References": [
                "Meila, M. (2007). Comparing clusterings - an information based distance. Journal of Multivariate Analysis, 98, 873-895. doi:10.1016/j.jmva.2006.11.013"
            ],
            "Description": "Variation of Information among two nodes partitions.\n$$ H(p)+H(q)-2MI(p, q) $$\nwhere MI is the mutual information, H the partition entropy and p,q are the algorithms sets\n"
        },
        "Section_id": "NodeClustering"
    },
    {
        "Field List > Methods > z_modularity": {
            "Paramters": {},
            "Return": [
                "the z-modularity score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.z_modularity()"
            ],
            "References": [],
            "Description": "Z-modularity is another variant of the standard modularity proposed to avoid the resolution limit.\nThe concept of this version is based on an observation that the difference between the fraction of edges inside communities and the expected number of such edges in a null model should not be considered as the only contribution to the final quality of algorithms structure.\n"
        },
        "Section_id": "NodeClustering"
    },
    {
        "Section_id": "dpclus",
        "Description": "DPClus projects weights onto an unweighted graph using a common neighbors approach.\nIn DPClus, the weight of an edge (u, v) is de\ufb01ned as the number of common neighbors between u and v.\nSimilarly, the weight of a vertex is its weighted degree \u2013 the sum of all edges connected to the vertex-\nDPClus does not natively generate overlapping clusters but does allow for overlapping cluster nodes to be added in a post-processing step.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "weights": "label used for the edge weights. Default, None.",
            "d_threshold": "cluster density threshold, default 0.9",
            "cp_threshold": "cluster property threshold, default 0.5",
            "overlap": "wheter to output overlapping or crisp communities. Default, True."
        },
        "Section_id": "dpclus"
    },
    {
        "Section_id": "dpclus",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "dpclus",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.dpclus(G)"
        ]
    },
    {
        "Section_id": "mod_m",
        "Description": "Community Discovery algorithm designed to find local optimal community structures in large networks starting from a given source vertex.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "query_node": "Id of the network node whose local community is queried."
        },
        "Section_id": "mod_m"
    },
    {
        "Section_id": "mod_m",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "mod_m",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.mod_m(G, 1)"
        ]
    },
    {
        "Section_id": "overlapping_normalized_mutual_information_MGH",
        "Description": "Overlapping Normalized Mutual Information between two clusterings.\nExtension of the Normalized Mutual Information (NMI) score to cope with overlapping partitions.\nThis is the version proposed by McDaid et al. using a different normalization than the original LFR one. See ref.\nfor more details.\n"
    },
    {
        "Parameters": {
            "first_partition": "NodeClustering object",
            "second_partition": "NodeClustering object",
            "normalization": "one of \u201cmax\u201d or \u201cLFK\u201d. Default \u201cmax\u201d (corresponds to the main method described in the article)"
        },
        "Section_id": "overlapping_normalized_mutual_information_MGH"
    },
    {
        "Section_id": "overlapping_normalized_mutual_information_MGH",
        "Return": [
            "MatchingResult object\n"
        ]
    },
    {
        "Section_id": "overlapping_normalized_mutual_information_MGH",
        "Example": [
            "from cdlib import evaluation, algorithms\ng = nx.karate_club_graph()\nlouvain_communities = algorithms.louvain(g)\nleiden_communities = algorithms.leiden(g)\nevaluation.overlapping_normalized_mutual_information_MGH(louvain_communities,leiden_communities)"
        ]
    },
    {
        "Section_id": "overlapping_normalized_mutual_information_MGH",
        "References": [
            "McDaid, A. F., Greene, D., & Hurley, N. (2011). Normalized mutual information to evaluate overlapping community finding algorithms. arXiv preprint arXiv:1110.2515. Chicago"
        ]
    },
    {
        "Section_id": "ebgc",
        "Description": "The entropy-based clustering approach finds locally optimal clusters by growing a random seed in a manner that minimizes graph entropy.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object"
        },
        "Section_id": "ebgc"
    },
    {
        "Section_id": "ebgc",
        "Return": [
            "NodeClustering object"
        ]
    },
    {
        "Section_id": "ebgc",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.ebgc(G)"
        ]
    },
    {
        "Section_id": "purity",
        "Description": "Purity is the product of the frequencies of the most frequent labels carried by the nodes within the communities\n"
    },
    {
        "Parameters": {
            "communities": "AttrNodeClustering object"
        },
        "Section_id": "purity"
    },
    {
        "Section_id": "purity",
        "Return": [
            "FitnessResult object"
        ]
    },
    {
        "Section_id": "purity",
        "Example": [
            "from cdlib.algorithms import eva\nfrom cdlib import evaluation\nimport random\nl1 = ['A', 'B', 'C', 'D']\nl2 = [\"E\", \"F\", \"G\"]\ng = nx.barabasi_albert_graph(100, 5)\nlabels=dict()\nfor node in g.nodes():\n   labels[node]={\"l1\":random.choice(l1), \"l2\":random.choice(l2)}\ncommunities = eva(g_attr, labels, alpha=0.5)\npur = evaluation.purity(communities)"
        ]
    },
    {
        "Section_id": "purity",
        "References": [
            "Citraro, Salvatore, and Giulio Rossetti. \u201cEva: Attribute-Aware Network Segmentation.\u201d International Conference on Complex Networks and Their Applications. Springer, Cham, 2019."
        ]
    },
    {
        "Section_id": "newman_girvan_modularity",
        "Description": "Difference the fraction of intra community edges of a partition with the expected number of such edges if distributed according to a null model.\nIn the standard version of modularity, the null model preserves the expected degree sequence of the graph under consideration. In other words, the modularity compares the real network structure with a corresponding one where nodes are connected without any preference about their neighbors.\n\n\\[Q(S) = \\frac{1}{m}\\sum_{c \\in S}(m_S - \\frac{(2 m_S + l_S)^2}{4m})\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of community edges, \\(l_S\\) is the number of edges from nodes in S to nodes outside S.\n"
    },
    {
        "Parameters": {
            "graph": "a networkx/igraph object",
            "communities": "NodeClustering object"
        },
        "Section_id": "newman_girvan_modularity"
    },
    {
        "Section_id": "newman_girvan_modularity",
        "Return": [
            "FitnessResult object\n"
        ]
    },
    {
        "Section_id": "newman_girvan_modularity",
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = evaluation.newman_girvan_modularity(g,communities)"
        ]
    },
    {
        "Section_id": "newman_girvan_modularity",
        "References": [
            "Newman, M.E.J. & Girvan, M. Finding and evaluating community structure in networks. Physical Review E 69, 26113(2004)."
        ]
    },
    {
        "Section_id": "eigenvector",
        "Description": "Newman\u2019s leading eigenvector method for detecting community structure based on modularity.\nThis is the proper internal of the recursive, divisive algorithm: each split is done by maximizing the modularity regarding the original network.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object"
        },
        "Section_id": "eigenvector"
    },
    {
        "Section_id": "eigenvector",
        "Return": [
            "NodeClustering object"
        ]
    },
    {
        "Section_id": "eigenvector",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncom = algorithms.eigenvector(G)"
        ]
    },
    {
        "Section_id": "demon",
        "Description": "Demon is a node-centric bottom-up overlapping community discovery algorithm.\nIt leverages ego-network structures and overlapping label propagation to identify micro-scale communities that are subsequently merged in mesoscale ones.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "epsilon": "merging threshold in [0,1], default 0.25.",
            "min_com_size": "minimum community size, default 3."
        },
        "Section_id": "demon"
    },
    {
        "Section_id": "demon",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "demon",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.demon(G, min_com_size=3, epsilon=0.25)"
        ]
    },
    {
        "Section_id": "demon",
        "References": [
            "Coscia, M., Rossetti, G., Giannotti, F., & Pedreschi, D. (2012, August). Demon: a local-first discovery method for overlapping communities. In Proceedings of the 18th ACM SIGKDD international conference on Knowledge discovery and data mining (pp. 615-623). ACM.",
            "Coscia, M., Rossetti, G., Giannotti, F., & Pedreschi, D. (2014). Uncovering hierarchical and overlapping communities with a local-first approach. ACM Transactions on Knowledge Discovery from Data (TKDD), 9(1), 6."
        ]
    },
    {
        "Section_id": "plot_community_graph",
        "Description": "Plot a algorithms-graph with node color coding for communities.\n"
    },
    {
        "Parameters": {
            "graph": "NetworkX/igraph graph",
            "partition": "NodeClustering object",
            "figsize": "the figure size; it is a pair of float, default (8, 8)",
            "node_size": "int, default 200",
            "plot_overlaps": "bool, default False. Flag to control if multiple algorithms memberships are plotted.",
            "plot_labels": "bool, default False. Flag to control if node labels are plotted.",
            "cmap": "str or Matplotlib colormap, Colormap(Matplotlib colormap) for mapping intensities of nodes. If set to None, original colormap is used..",
            "top_k": "int, Show the top K influential communities. If set to zero or negative value indicates all.",
            "min_size": "int, Exclude communities below the specified minimum size."
        },
        "Section_id": "plot_community_graph"
    },
    {
        "Section_id": "plot_community_graph",
        "Example": [
            "from cdlib import algorithms, viz\nimport networkx as nx\ng = nx.karate_club_graph()\ncoms = algorithms.louvain(g)\nviz.plot_community_graph(g, coms)"
        ]
    },
    {
        "Section_id": "paris",
        "Description": "Paris is a hierarchical graph clustering algorithm inspired by modularity-based clustering techniques.\nThe algorithm is agglomerative and based on a simple distance between clusters induced by the probability of sampling node pairs.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object"
        },
        "Section_id": "paris"
    },
    {
        "Section_id": "paris",
        "Return": [
            "NodeClustering object"
        ]
    },
    {
        "Section_id": "paris",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.paris(G)"
        ]
    },
    {
        "Section_id": "kclique",
        "Description": "Find k-clique communities in graph using the percolation method.\nA k-clique community is the union of all cliques of size k that can be reached through adjacent (sharing k-1 nodes) k-cliques.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "k": "Size of smallest clique"
        },
        "Section_id": "kclique"
    },
    {
        "Section_id": "kclique",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "kclique",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncom = algorithms.kclique(G, k=3)"
        ]
    },
    {
        "Section_id": "endntm",
        "Description": "Overlapping community detection algorithm based on an ensemble  approach with a distributed neighbourhood threshold method (EnDNTM).\nEnDNTM uses pre-partitioned disjoint communities generated by the ensemble mechanism and then analyzes the neighbourhood distribution  of boundary nodes in disjoint communities to detect overlapping communities.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "clusterings": "an iterable of Clustering objects (non overlapping node partitions only)",
            "epsilon": "neighbourhood threshold, default 2."
        },
        "Section_id": "endntm"
    },
    {
        "Section_id": "endntm",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "endntm",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms_l = [algorithms.louvain(G), algorithms.label_propagation(G), algorithms.walktrap(G)]\ncoms = algorithms.endntm(G, coms_l)"
        ]
    },
    {
        "Section_id": "multicom",
        "Description": "MULTICOM is an algorithm for detecting multiple local communities, possibly overlapping, by expanding the initial seed set.\nThis algorithm uses local scoring metrics to define an embedding of the graph around the seed set. Based on this embedding, it picks new seeds in the neighborhood of the original seed set, and uses these new seeds to recover multiple communities.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "seed_node": "Id of the seed node around which we want to detect communities."
        },
        "Section_id": "multicom"
    },
    {
        "Section_id": "multicom",
        "Return": [
            "EdgeClustering object\n"
        ]
    },
    {
        "Section_id": "multicom",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.multicom(G, seed_node=0)"
        ]
    },
    {
        "Section_id": "gdmp2",
        "Description": "Gdmp2 is a method for identifying a set of dense subgraphs of a given sparse graph.\nIt is inspired by an effective technique designed for a similar problem\u2014matrix blocking, from a different discipline (solving linear systems).\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "min_threshold": "the minimum density threshold parameter to control the density of the output subgraphs, default 0.75"
        },
        "Section_id": "gdmp2"
    },
    {
        "Section_id": "gdmp2",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "gdmp2",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncom = algorithms.gdmp2(G)"
        ]
    },
    {
        "Section_id": "random_search",
        "Description": "Returns the optimal partition of the specified graph w.r.t. the selected algorithm and quality score over a randomized sample of the input parameters.\n"
    },
    {
        "Parameters": {
            "method": "community discovery method (from nclib.community)",
            "graph": "networkx/igraph object",
            "parameters": "list of Parameter and BoolParameter objects",
            "quality_score": "a fitness function to evaluate the obtained partition (from nclib.evaluation)",
            "instances": "number of randomly selected parameters configurations",
            "aggregate": "function to select the best fitness value. Possible values: min/max"
        },
        "Section_id": "random_search"
    },
    {
        "Section_id": "random_search",
        "Return": [
            "at each call the generator yields a tuple composed by: the optimal configuration for the given algorithm, input paramters and fitness function; the obtained communities; the fitness score\n"
        ]
    },
    {
        "Section_id": "random_search",
        "Example": [
            "import networkx as nx\nfrom cdlib import algorithms, ensemble\ng = nx.karate_club_graph()\nresolution = ensemble.Parameter(name=\"resolution\", start=0.1, end=1, step=0.1)\nrandomize = ensemble.BoolParameter(name=\"randomize\")\ncommunities, scoring = ensemble.random_search(graph=g, method=algorithms.louvain,\n                                                      parameters=[resolution, randomize],\n                                                      quality_score=evaluation.erdos_renyi_modularity,\n                                                      instances=5, aggregate=max)\nprint(communities, scoring)"
        ]
    },
    {
        "Section_id": "frc_fgsn",
        "Description": "Fuzzy-Rough Community Detection on Fuzzy Granular model of Social Network.\nFRC-FGSN assigns nodes to communities specifying the probability of each association.\nThe flattened partition ensure that each node is associated to the community that maximize such association probability.\nFRC-FGSN may generate orphan nodes (i.e., nodes not assigned to any community).\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "networkx/igraph object",
            "theta": "community density coefficient",
            "eps": "coupling coefficient of the community. Ranges in [0, 1], small values ensure that only strongly connected node granules are merged togheter.",
            "r": "radius of the granule (int)"
        },
        "Section_id": "frc_fgsn"
    },
    {
        "Section_id": "frc_fgsn",
        "Return": [
            "FuzzyNodeClustering object\n"
        ]
    },
    {
        "Section_id": "frc_fgsn",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = frc_fgsn(G, theta=1, eps=0.5, r=3)"
        ]
    },
    {
        "Section_id": "triangle_participation_ratio",
        "Description": "Fraction of community nodes that belong to a triad.\n\n\\[f(S) = \\frac{ | \\{ u: u \\in S,\\{(v,w):v, w \\in S,(u,v) \\in E,(u,w) \\in E,(v,w) \\in E \\} \\not = \\emptyset \\} |}{n_S}\\]\nwhere \\(n_S\\) is the set of community nodes.\n"
    },
    {
        "Parameters": {
            "graph": "a networkx/igraph object",
            "community": "NodeClustering object",
            "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
        },
        "Section_id": "triangle_participation_ratio"
    },
    {
        "Section_id": "triangle_participation_ratio",
        "Return": [
            "If summary==True a FitnessResult object, otherwise a list of floats.\n"
        ]
    },
    {
        "Section_id": "triangle_participation_ratio",
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = evaluation.triangle_participation_ratio(g,communities)"
        ]
    },
    {
        "Section_id": "triangle_participation_ratio",
        "References": [
            "Yang, J., Leskovec, J.: Defining and evaluating network communities based on ground-truth. Knowledge and Information Systems 42(1), 181\u2013213 (2015)"
        ]
    },
    {
        "Section_id": "avg_embeddedness",
        "Description": "Average embeddedness of nodes within the community.\nThe embeddedness of a node n w.r.t. a community C is the ratio of its degree within the community and its overall degree.\n\n\\[emb(n,C) = \\frac{k_n^C}{k_n}\\]\nThe average embeddedness of a community C is:\n\n\\[avg_embd(c) = \\frac{1}{|C|} \\sum_{i \\in C} \\frac{k_n^C}{k_n}\\]\n"
    },
    {
        "Parameters": {
            "graph": "a networkx/igraph object",
            "communities": "NodeClustering object",
            "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
        },
        "Section_id": "avg_embeddedness"
    },
    {
        "Section_id": "avg_embeddedness",
        "Return": [
            "If summary==True a FitnessResult object, otherwise a list of floats.\n"
        ]
    },
    {
        "Section_id": "avg_embeddedness",
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nave = evaluation.avg_embeddedness(g,communities)"
        ]
    },
    {
        "Section_id": "nx_node_integer_mapping",
        "Description": "Maps node labels from strings to integers.\n"
    },
    {
        "Parameters": {
            "graph": "networkx graph"
        },
        "Section_id": "nx_node_integer_mapping"
    },
    {
        "Section_id": "nx_node_integer_mapping",
        "Return": [
            "if the node labels are string: networkx graph, dictionary <numeric_id, original_node_label>, false otherwise"
        ]
    },
    {
        "Section_id": "sbm_dl",
        "Description": "Efficient Monte Carlo and greedy heuristic for the inference of stochastic block models.\nFit a non-overlapping stochastic block model (SBM) by minimizing its description length using an agglomerative heuristic.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "network/igraph object"
        },
        "Section_id": "sbm_dl"
    },
    {
        "Section_id": "sbm_dl",
        "Return": [
            "NodeClustering object"
        ]
    },
    {
        "Section_id": "sbm_dl",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.sbm_dl(G)"
        ]
    },
    {
        "Section_id": "omega",
        "Description": "Index of resemblance for overlapping, complete coverage, network clusterings.\n"
    },
    {
        "Parameters": {
            "first_partition": "NodeClustering object",
            "second_partition": "NodeClustering object"
        },
        "Section_id": "omega"
    },
    {
        "Section_id": "omega",
        "Return": [
            "MatchingResult object\n"
        ]
    },
    {
        "Section_id": "omega",
        "Example": [
            "from cdlib import evaluation, algorithms\ng = nx.karate_club_graph()\nlouvain_communities = algorithms.louvain(g)\nleiden_communities = algorithms.leiden(g)\nevaluation.omega(louvain_communities,leiden_communities)"
        ]
    },
    {
        "Section_id": "omega",
        "References": [
            "Gabriel Murray, Giuseppe Carenini, and Raymond Ng. 2012. Using the omega index for evaluating abstractive algorithms detection. In Proceedings of Workshop on Evaluation Metrics and System Comparison for Automatic Summarization. Association for Computational Linguistics, Stroudsburg, PA, USA, 10-18."
        ]
    },
    {
        "Section_id": "node_perception",
        "Description": "Node perception is based on the idea of joining together small sets of nodes.\nThe algorithm first identifies sub-communities corresponding to each node\u2019s perception of the network around it.\nTo perform this step, it considers each node individually, and partition that node\u2019s neighbors into communities using some existing community detection method.\nNext, it creates a new network in which every node corresponds to a sub-community, and two nodes are linked if their associated sub-communities overlap by at least some threshold amount.\nFinally, the algorithm identifies overlapping communities in this new network, and for every such community, merge together the associated sub-communities to identify communities in the original network.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "threshold": "the tolerance required in order to merge communities",
            "overlap_threshold": "the overlap tolerance",
            "min_comm_size": "minimum community size default 3"
        },
        "Section_id": "node_perception"
    },
    {
        "Section_id": "node_perception",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "node_perception",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.node_perception(G, threshold=0.25, overlap_threshold=0.25)"
        ]
    },
    {
        "Section_id": "spectral",
        "Description": "SCD implements a Spectral Clustering algorithm for Communities Discovery.\nIt is based on Fielder\u2019s vector (obtained from the eigenvector related to the second eigenvalue of the normalized Laplacian) that are leveraged to extract the communities using Kmeans clustering.\nSCD a hierarchical graph clustering algorithm inspired by modularity-based clustering techniques.\nThe algorithm is agglomerative and based on a simple distance between clusters induced by the probability of sampling node pairs.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "kmax": "maximum number of desired communities (mandatory). Default 2.",
            "projection_on_smaller_class": "a boolean value that if True then it project a bipartite network in the smallest class of node. (default is True)",
            "scaler": "the function to scale the fielder\u2019s vector to apply KMeans"
        },
        "Section_id": "spectral"
    },
    {
        "Section_id": "spectral",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "spectral",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.spectral(G, kmax=2)"
        ]
    },
    {
        "Section_id": "nf1",
        "Description": "Compute the Normalized F1 score of the optimal algorithms matches among the partitions in input.\nWorks on overlapping/non-overlapping complete/partial coverage partitions.\n"
    },
    {
        "Parameters": {
            "first_partition": "NodeClustering object",
            "second_partition": "NodeClustering object"
        },
        "Section_id": "nf1"
    },
    {
        "Section_id": "nf1",
        "Return": [
            "MatchingResult object\n"
        ]
    },
    {
        "Section_id": "nf1",
        "Example": [
            "from cdlib import evaluation, algorithms\ng = nx.karate_club_graph()\nlouvain_communities = algorithms.louvain(g)\nleiden_communities = algorithms.leiden(g)\nevaluation.nf1(louvain_communities,leiden_communities)"
        ]
    },
    {
        "Section_id": "nf1",
        "References": [
            "Rossetti, G., Pappalardo, L., & Rinzivillo, S. (2016). A novel approach to evaluate algorithms detection internal on ground truth.",
            "Rossetti, G. (2017). : RDyn: graph benchmark handling algorithms dynamics. Journal of Complex Networks. 5(6), 893-912."
        ]
    },
    {
        "Section_id": "core_expansion",
        "Description": "Core Expansion automatically detect the core of each possible community in the network. Then, it iteratively expand each core by adding the nodes to form the fnal communities. The expansion process is based on the neighborhood overlap measure.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "tolerance": "numerical tollerance, default 0.0001"
        },
        "Section_id": "core_expansion"
    },
    {
        "Section_id": "core_expansion",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "core_expansion",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.core_expansion(G)"
        ]
    },
    {
        "Section_id": "pycombo",
        "Description": "This is an implementation (for Modularity maximization) of the community detection algorithm called \u201cCombo\u201d.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "weight": "Optional, defaults to weight. Graph edges property to use as weights. If None, graph assumed to be unweighted. Ignored if graph is passed as string (path to the file), or such property does not exist.",
            "max_communities": "Optional, defaults to None. Maximum number of communities. If <= 0 or None, assume to be infinite.",
            "modularity_resolution": "float, defaults to 1.0. Modularity resolution parameter.",
            "num_split_attempts": "int, defaults to 0. Number of split attempts. If 0, autoadjust this number automatically.",
            "start_separate": "bool, default False. Indicates if Combo should start from assigning each node into its own separate community. This could help to achieve higher modularity, but it makes execution much slower.",
            "treat_as_modularity": "bool, default False. Indicates if edge weights should be treated as modularity scores. If True, the algorithm solves clique partitioning problem over the given graph, treated as modularity graph (matrix). For example, this allows users to provide their own custom \u2018modularity\u2019 matrix. modularity_resolution is ignored in this case.",
            "random_seed": "int, defaults to 42. Random seed to use."
        },
        "Section_id": "pycombo"
    },
    {
        "Section_id": "pycombo",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "pycombo",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.pycombo(G)"
        ]
    },
    {
        "Section_id": "ga",
        "Description": "Genetic based approach to discover communities in social networks.\nGA optimizes a simple but efficacious fitness function able to identify densely connected groups of nodes with sparse connections between groups.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "population": "",
            "generation": "",
            "r": ""
        },
        "Section_id": "ga"
    },
    {
        "Section_id": "ga",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "ga",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.ga(G)"
        ]
    },
    {
        "Section_id": "adjusted_mutual_information",
        "Description": "Adjusted Mutual Information between two clusterings.\nAdjusted Mutual Information (AMI) is an adjustment of the Mutual\nInformation (MI) score to account for chance. It accounts for the fact that\nthe MI is generally higher for two clusterings with a larger number of\nclusters, regardless of whether there is actually more information shared.\nFor two clusterings \\(U\\) and \\(V\\), the AMI is given as:\nAMI(U, V) = [MI(U, V) - E(MI(U, V))] / [max(H(U), H(V)) - E(MI(U, V))]\n\nThis metric is independent of the absolute values of the labels:\na permutation of the class or cluster label values won\u2019t change the\nscore value in any way.\nThis metric is furthermore symmetric: switching label_true with\nlabel_pred will return the same score value. This can be useful to\nmeasure the agreement of two independent label assignments strategies\non the same dataset when the real ground truth is not known.\nBe mindful that this function is an order of magnitude slower than other\nmetrics, such as the Adjusted Rand Index.\n"
    },
    {
        "Parameters": {
            "first_partition": "NodeClustering object",
            "second_partition": "NodeClustering object"
        },
        "Section_id": "adjusted_mutual_information"
    },
    {
        "Section_id": "adjusted_mutual_information",
        "Return": [
            "MatchingResult object\n"
        ]
    },
    {
        "Section_id": "adjusted_mutual_information",
        "Example": [
            "from cdlib import evaluation, algorithms\ng = nx.karate_club_graph()\nlouvain_communities = algorithms.louvain(g)\nleiden_communities = algorithms.leiden(g)\nevaluation.adjusted_mutual_information(louvain_communities,leiden_communities)"
        ]
    },
    {
        "Section_id": "adjusted_mutual_information",
        "References": [
            "Vinh, N. X., Epps, J., & Bailey, J. (2010). Information theoretic measures for clusterings comparison: Variants, properties, normalization and correction for chance. Journal of Machine Learning Research, 11(Oct), 2837-2854."
        ]
    },
    {
        "Section_id": "max_odf",
        "Description": "Maximum fraction of edges of a node of a community that point outside the community itself.\n\n\\[max_{u \\in S} \\frac{|\\{(u,v)\\in E: v \\not\\in S\\}|}{d(u)}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\) and \\(d(u)\\) is the degree of \\(u\\)\n"
    },
    {
        "Parameters": {
            "graph": "a networkx/igraph object",
            "community": "NodeClustering object",
            "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
        },
        "Section_id": "max_odf"
    },
    {
        "Section_id": "max_odf",
        "Return": [
            "If summary==True a FitnessResult object, otherwise a list of floats.\n"
        ]
    },
    {
        "Section_id": "max_odf",
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = evaluation.max_odf(g,communities)"
        ]
    },
    {
        "Section_id": "max_odf",
        "References": [
            "Flake, G.W., Lawrence, S., Giles, C.L., et al.: Efficient identification of web communities. In: KDD, vol. 2000, pp. 150\u2013160 (2000)"
        ]
    },
    {
        "Section_id": "rber_pots",
        "Description": "rber_pots is a  model where the quality function to optimize is:\n\n\\[Q = \\sum_{ij} \\left(A_{ij} - \\gamma p \\right)\\delta(\\sigma_i, \\sigma_j)\\]\nwhere \\(A\\) is the adjacency matrix,  \\(p = \\frac{m}{\\binom{n}{2}}\\) is the overall density of the graph, \\(\\sigma_i\\) denotes the community of node \\(i\\), \\(\\delta(\\sigma_i, \\sigma_j) = 1\\) if  \\(\\sigma_i = \\sigma_j\\) and 0 otherwise, and, finally \\(\\gamma\\) is a resolution parameter.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "initial_membership": "list of int Initial membership for the partition. IfNonethen defaults to a singleton partition. Deafault None",
            "weights": "list of double, or edge attribute Weights of edges. Can be either an iterable or an edge attribute. Deafault None",
            "node_sizes": "list of int, or vertex attribute Sizes of nodes are necessary to know the size of communities in aggregate graphs. Usually this is set to 1 for all nodes, but in specific cases  this could be changed. Deafault None",
            "resolution_parameter": "double >0 A parameter value controlling the coarseness of the clustering. Higher resolutions lead to more communities, while lower resolutions lead to fewer communities. Deafault 1"
        },
        "Section_id": "rber_pots"
    },
    {
        "Section_id": "rber_pots",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "rber_pots",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.rber_pots(G)"
        ]
    },
    {
        "Section_id": "infomap_bipartite",
        "Description": "Infomap is based on ideas of information theory.\nThe algorithm uses the probability flow of random walks on a bipartite network as a proxy for information flows in the real system and it decomposes the network into modules by compressing a description of the probability flow.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "flags": "str flags for Infomap"
        },
        "Section_id": "infomap_bipartite"
    },
    {
        "Section_id": "infomap_bipartite",
        "Return": [
            "BiNodeClustering object\n"
        ]
    },
    {
        "Section_id": "infomap_bipartite",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.algorithms.bipartite.generators.random_graph(100, 20, 0.5)\ncoms = algorithms.infomap_bipartite(G)"
        ]
    },
    {
        "Section_id": "plot_scoring",
        "Description": "Plot the scores obtained by a list of methods on a list of graphs.\n"
    },
    {
        "Parameters": {
            "graphs": "list of graphs on which to make computations",
            "ref_partitions": "list of reference clusterings corresponding to graphs",
            "graph_names": "list of the names of the graphs to display",
            "methods": "list of functions that take a graph as input and return a Clustering as output",
            "scoring": "the scoring function to use, default anmi",
            "nbRuns": "number of runs to do for each method on each graph"
        },
        "Section_id": "plot_scoring"
    },
    {
        "Section_id": "plot_scoring",
        "Return": [
            "a seaborn lineplot\n"
        ]
    },
    {
        "Section_id": "plot_scoring",
        "Example": [
            "from cdlib import algorithms, viz, evaluation\nimport networkx as nx\ng1 = nx.algorithms.community.LFR_benchmark_graph(1000, 3, 1.5, 0.5, min_community=20, average_degree=5)\ng2 = nx.algorithms.community.LFR_benchmark_graph(1000, 3, 1.5, 0.7, min_community=20, average_degree=5)\nnames = [\"g1\", \"g2\"]\ngraphs = [g1, g2]\nfor g in graphs:\n    references.append(NodeClustering(communities={frozenset(g.nodes[v]['community']) for v in g}, graph=g, method_name=\"reference\"))\nalgos = [algorithms.crisp_partition.louvain, algorithms.crisp_partition.label_propagation]\nviz.plot_scoring(graphs, references, names, algos, nbRuns=2)"
        ]
    },
    {
        "Section_id": "aslpaw",
        "Description": "ASLPAw can be used for disjoint and overlapping community detection and works on weighted/unweighted and directed/undirected networks.\nASLPAw is adaptive with virtually no configuration parameters.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object"
        },
        "Section_id": "aslpaw"
    },
    {
        "Section_id": "aslpaw",
        "Return": [
            "NodeClustering object"
        ]
    },
    {
        "Section_id": "aslpaw",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.aslpaw(G)"
        ]
    },
    {
        "Section_id": "lfm",
        "Description": "LFM is based on the local optimization of a fitness function.\nIt finds both overlapping communities and the hierarchical structure.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "alpha": "parameter to controll the size of the communities:  Large values of alpha yield very small communities, small values instead deliver large modules. If alpha is small enough, all nodes end up in the same cluster, the network itself. In most cases, for alpha < 0.5 there is only one community, for alpha > 2 one recovers the smallest communities. A natural choise is alpha =1."
        },
        "Section_id": "lfm"
    },
    {
        "Section_id": "lfm",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "lfm",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncom = algorithms.lfm(G, alpha=0.8)"
        ]
    },
    {
        "Section_id": "hub_dominance",
        "Description": "Hub dominance.\nThe hub dominance of a community is defined as the ratio of the degree of its most connected node w.r.t. the theoretically maximal degree within the community.\n"
    },
    {
        "Parameters": {
            "graph": "a networkx/igraph object",
            "communities": "NodeClustering object",
            "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
        },
        "Section_id": "hub_dominance"
    },
    {
        "Section_id": "hub_dominance",
        "Return": [
            "If summary==True a FitnessResult object, otherwise a list of floats.\n"
        ]
    },
    {
        "Section_id": "hub_dominance",
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nscd = evaluation.hub_dominance(g,communities)"
        ]
    },
    {
        "Section_id": "belief",
        "Description": "Belief community seeks the consensus of many high-modularity partitions.\nIt does this with a scalable message-passing algorithm, derived by treating the modularity as a Hamiltonian and applying the cavity method.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "max_it": "",
            "eps": "",
            "reruns_if_not_conv": "",
            "threshold": "",
            "q_max": ""
        },
        "Section_id": "belief"
    },
    {
        "Section_id": "belief",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "belief",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.belief(G)"
        ]
    },
    {
        "Section_id": "overlapping_normalized_mutual_information_LFK",
        "Description": "Overlapping Normalized Mutual Information between two clusterings.\nExtension of the Normalized Mutual Information (NMI) score to cope with overlapping partitions.\nThis is the version proposed by Lancichinetti et al. (1)\n"
    },
    {
        "Parameters": {
            "first_partition": "NodeClustering object",
            "second_partition": "NodeClustering object"
        },
        "Section_id": "overlapping_normalized_mutual_information_LFK"
    },
    {
        "Section_id": "overlapping_normalized_mutual_information_LFK",
        "Return": [
            "MatchingResult object\n"
        ]
    },
    {
        "Section_id": "overlapping_normalized_mutual_information_LFK",
        "Example": [
            "from cdlib import evaluation, algorithms\ng = nx.karate_club_graph()\nlouvain_communities = algorithms.louvain(g)\nleiden_communities = algorithms.leiden(g)\nevaluation.overlapping_normalized_mutual_information_LFK(louvain_communities,leiden_communities)"
        ]
    },
    {
        "Section_id": "overlapping_normalized_mutual_information_LFK",
        "References": [
            "Lancichinetti, A., Fortunato, S., & Kertesz, J. (2009). Detecting the overlapping and hierarchical community structure in complex networks. New Journal of Physics, 11(3), 033015."
        ]
    },
    {
        "Section_id": "avg_transitivity",
        "Description": "Average transitivity.\nThe average transitivity of a community is defined the as the average clustering coefficient of its nodes w.r.t. their connection within the community itself.\n"
    },
    {
        "Parameters": {
            "graph": "a networkx/igraph object",
            "communities": "NodeClustering object",
            "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
        },
        "Section_id": "avg_transitivity"
    },
    {
        "Section_id": "avg_transitivity",
        "Return": [
            "If summary==True a FitnessResult object, otherwise a list of floats.\n"
        ]
    },
    {
        "Section_id": "avg_transitivity",
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nscd = evaluation.avg_transitivity(g,communities)"
        ]
    },
    {
        "Section_id": "erdos_renyi_modularity",
        "Description": "Erdos-Renyi modularity is a variation of the Newman-Girvan one.\nIt assumes that vertices in a network are connected randomly with a constant probability \\(p\\).\n\n\\[Q(S) = \\frac{1}{m}\\sum_{c \\in S} (m_S \u2212 \\frac{mn_S(n_S \u22121)}{n(n\u22121)})\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of community edges, \\(l_S\\) is the number of edges from nodes in S to nodes outside S.\n"
    },
    {
        "Parameters": {
            "graph": "a networkx/igraph object",
            "communities": "NodeClustering object"
        },
        "Section_id": "erdos_renyi_modularity"
    },
    {
        "Section_id": "erdos_renyi_modularity",
        "Return": [
            "FitnessResult object\n"
        ]
    },
    {
        "Section_id": "erdos_renyi_modularity",
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = evaluation.erdos_renyi_modularity(g,communities)"
        ]
    },
    {
        "Section_id": "erdos_renyi_modularity",
        "References": [
            "Erdos, P., & Renyi, A. (1959). On random graphs I. Publ. Math. Debrecen, 6, 290-297."
        ]
    },
    {
        "Section_id": "threshold_clustering",
        "Description": "Developed for semantic similarity networks, this algorithm specifically targets weighted and directed graphs.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "threshold_function": "callable, optional\nTies smaller than threshold_function(out_ties) are deleted. Example: np.mean, np.median. Default is np.mean."
        },
        "Section_id": "threshold_clustering"
    },
    {
        "Section_id": "threshold_clustering",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "threshold_clustering",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.threshold_clustering(G)"
        ]
    },
    {
        "Section_id": "size",
        "Description": "Size is the number of nodes in the community\n"
    },
    {
        "Parameters": {
            "graph": "a networkx/igraph object",
            "communities": "NodeClustering object",
            "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
        },
        "Section_id": "size"
    },
    {
        "Section_id": "size",
        "Return": [
            "If summary==True a FitnessResult object, otherwise a list of floats.\n"
        ]
    },
    {
        "Section_id": "size",
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nsz = evaluation.size(g,communities)"
        ]
    },
    {
        "Section_id": "eva",
        "Description": "The Eva algorithm extends the Louvain approach in order to deal with the attributes of the nodes (aka Louvain Extended to Vertex Attributes).\nIt optimizes - combining them linearly - two quality functions, a structural and a clustering one, namely Newman\u2019s modularity and purity, estimated as the product of the frequencies of the most frequent labels carried by the nodes within the communities.\nA parameter alpha tunes the importance of the two functions: an high value of alpha favors the clustering criterion instead of the structural one.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "labels": "dictionary specifying for each node (key) a dict (value) specifying the name attribute (key) and its value (value)",
            "weight": "str, optional the key in graph to use as weight. Default to \u2018weight\u2019",
            "resolution": "double, optional  Will change the size of the communities, default to 1.",
            "alpha": "float, assumed in [0,1], optional Will tune the importance of modularity and purity criteria, default to 0.5"
        },
        "Section_id": "eva"
    },
    {
        "Section_id": "eva",
        "Return": [
            "AttrNodeClustering object\n"
        ]
    },
    {
        "Section_id": "eva",
        "Example": [
            "from cdlib.algorithms import eva\nimport networkx as nx\nimport random\nl1 = ['A', 'B', 'C', 'D']\nl2 = [\"E\", \"F\", \"G\"]\ng_attr = nx.barabasi_albert_graph(100, 5)\nlabels=dict()\nfor node in g_attr.nodes():\n   labels[node]={\"l1\":random.choice(l1), \"l2\":random.choice(l2)}\ncommunities = eva(g_attr, labels, alpha=0.8)"
        ]
    },
    {
        "Section_id": "lemon",
        "Description": "Lemon is a large scale overlapping community detection method based on local expansion via minimum one norm.\nThe algorithm adopts a local expansion method in order to identify the community members from a few exemplary seed members.\nThe algorithm finds the community by seeking a sparse vector in the span of the local spectra such that the seeds are in its support. LEMON can achieve the highest detection accuracy among state-of-the-art proposals. The running time depends on the size of the community rather than that of the entire graph.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "seeds": "Node list",
            "min_com_size": "the minimum size of a single community in the network, default 20",
            "max_com_size": "the maximum size of a single community in the network, default 50",
            "expand_step": "the step of seed set increasement during expansion process, default 6",
            "subspace_dim": "dimension of the subspace; choosing a large dimension is undesirable because it would increase the computation cost of generating local spectra default 3",
            "walk_steps": "the number of step for the random walk, default 3",
            "biased": "boolean; set if the random walk starting from seed nodes, default False"
        },
        "Section_id": "lemon"
    },
    {
        "Section_id": "lemon",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "lemon",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\nseeds = [\"$0$\", \"$2$\", \"$3$\"]\ncoms = algorithms.lemon(G, seeds, min_com_size=2, max_com_size=5)"
        ]
    },
    {
        "Section_id": "remap_node_communities",
        "Description": "Apply a map to the obtained communities to retreive the original node labels\n"
    },
    {
        "Parameters": {
            "communities": "NodeClustering object",
            "node_map": "dictionary <numeric_id, node_label>"
        },
        "Section_id": "remap_node_communities"
    },
    {
        "Section_id": "remap_node_communities",
        "Return": [
            "remapped communities\n"
        ]
    },
    {
        "Section_id": "ricci_community",
        "Description": "Curvature is a geometric property to describe the local shape of an object. If we draw two parallel paths on a surface with positive curvature like a sphere, these two paths move closer to each other while for a negatively curved surface like a saddle, these two paths tend to be apart.\nCurrently there are multiple ways to discretize curvature on graph, in this algorithm, we include two of the most frequently used discrete Ricci curvature: Ollivier-Ricci curvature which is based on optimal transportation theory and Forman-Ricci curvature which is base on CW complexes.\nEdge Ricci curvature is observed to play an important role in the graph structure.\nAn edge with positive curvature represents an edge within a cluster, while a negatively curved edge tent to be a bridge within clusters.\nAlso, negatively curved edges are highly related to graph connectivity, with negatively curved edges removed from a connected graph, the graph soon become disconnected.\nRicci flow is a process to uniformized the edge Ricci curvature of the graph.\nFor a given graph, the Ricci flow gives a \u201cRicci flow metric\u201d on each edge as edge weights, such that under these edge weights, the Ricci curvature of the graph is mostly equal everywhere. In [Ni3], this \u201cRicci flow metric\u201d is shown to be able to detect communities.\nBoth Ricci curvature and Ricci flow metric can act as a graph fingerprint for graph classification.\nThe different graph gives different edge Ricci curvature distributions and different Ricci flow metric.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "alpha": "The parameter for the probability distribution, range from [0 ~ 1]. It means the share of mass to leave on the original node. Default, 0.5.",
            "method": "Transportation method. [\u201cOTD\u201d, \u201cATD\u201d, \u201cSinkhorn\u201d]. Default: Sinkhorn"
        },
        "Section_id": "ricci_community"
    },
    {
        "Section_id": "ricci_community",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "ricci_community",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.ricci_community(G)"
        ]
    },
    {
        "Section_id": "angel",
        "Description": "Angel is a node-centric bottom-up community discovery algorithm.\nIt leverages ego-network structures and overlapping label propagation to identify micro-scale communities that are subsequently merged in mesoscale ones.\nAngel is the, faster, successor of Demon.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "threshold": "merging threshold in [0,1].",
            "min_community_size": "minimum community size, default 3."
        },
        "Section_id": "angel"
    },
    {
        "Section_id": "angel",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "angel",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.angel(G, min_com_size=3, threshold=0.25)"
        ]
    },
    {
        "Section_id": "angel",
        "References": [
            "Rossetti, Giulio. \u201cExorcising the Demon: Angel, Efficient Node-Centric Community Discovery.\u201d International Conference on Complex Networks and Their Applications. Springer, Cham, 2019."
        ]
    },
    {
        "Section_id": "percomvc",
        "Description": "The PercoMVC approach composes of two steps.\nIn the first step, the algorithm attempts to determine all communities that the clique percolation algorithm may find.\nIn the second step, the algorithm computes the Eigenvector Centrality method on the output of the first step to measure the influence of network nodes and reduce the rate of the unclassified nodes\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object"
        },
        "Section_id": "percomvc"
    },
    {
        "Section_id": "percomvc",
        "Return": [
            "NodeClustering object"
        ]
    },
    {
        "Section_id": "percomvc",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.percomvc(G)"
        ]
    },
    {
        "Section_id": "graph_entropy",
        "Description": "This method takes advantage of the use of entropy with regard to information theory.\nEntropy is a measure of uncertainty involved in a random variable.\nThis approach uses a new de\ufb01nition, Graph Entropy, as a measure of structural complexity in a graph.\nThis algorithm incorporates a seed-growth technique.\nUnlike the other seed-growth style methods, however, the graph entropy approach does not require any predetermined threshold because it searches for an optimal solution by minimizing graph entropy.\nThis method \ufb01nds locally optimal clusters with minimal graph entropy.\nA seed vertex is selected at random from a candidate set of seed vertices.\nThen, an initial cluster which is composed of the seed vertex and its immediate neighbors is created.\nNext, the neighbors are iteratively evaluated for removal to minimize the initial entropy of the graph.\nFinally, outer boundary vertices are added recursively if their addition causes the entropy of the graph to decrease.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "weights": "label used for the edge weights.. Default, None"
        },
        "Section_id": "graph_entropy"
    },
    {
        "Section_id": "graph_entropy",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "graph_entropy",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.graph_entropy(G)"
        ]
    },
    {
        "Section_id": "plot_network_clusters",
        "Description": "Plot a graph with node color coding for communities.\n"
    },
    {
        "Parameters": {
            "graph": "NetworkX/igraph graph",
            "partition": "NodeClustering object",
            "position": "A dictionary with nodes as keys and positions as values. Example: networkx.fruchterman_reingold_layout(G). By default, uses nx.spring_layout(g)",
            "figsize": "the figure size; it is a pair of float, default (8, 8)",
            "node_size": "int, default 200",
            "plot_overlaps": "bool, default False. Flag to control if multiple algorithms memberships are plotted.",
            "plot_labels": "bool, default False. Flag to control if node labels are plotted.",
            "cmap": "str or Matplotlib colormap, Colormap(Matplotlib colormap) for mapping intensities of nodes. If set to None, original colormap is used.",
            "top_k": "int, Show the top K influential communities. If set to zero or negative value indicates all.",
            "min_size": "int, Exclude communities below the specified minimum size."
        },
        "Section_id": "plot_network_clusters"
    },
    {
        "Section_id": "plot_network_clusters",
        "Example": [
            "from cdlib import algorithms, viz\nimport networkx as nx\ng = nx.karate_club_graph()\ncoms = algorithms.louvain(g)\npos = nx.spring_layout(g)\nviz.plot_network_clusters(g, coms, pos)"
        ]
    },
    {
        "Section_id": "BoolParameter",
        "Description": "Initialize self.  See help(type(self)) for accurate signature."
    },
    {
        "Field List > Parameters": {},
        "Section_id": "BoolParameter"
    },
    {
        "Section_id": "wCommunity",
        "Description": "Algorithm to identify overlapping communities in weighted graphs\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "min_bel_degree": "the tolerance, in terms of beloging degree, required in order to add a node in a community",
            "threshold_bel_degree": "the tolerance, in terms of beloging degree, required in order to add a node in a \u2018NLU\u2019 community",
            "weightName": "name of the edge attribute containing the weights"
        },
        "Section_id": "wCommunity"
    },
    {
        "Section_id": "wCommunity",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "wCommunity",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\nnx.set_edge_attributes(G, values=1, name='weight')\ncoms = algorithms.wCommunity(G, min_bel_degree=0.6, threshold_bel_degree=0.6)"
        ]
    },
    {
        "Section_id": "modularity_density",
        "Description": "The modularity density is one of several propositions that envisioned to palliate the resolution limit issue of modularity based measures.\nThe idea of this metric is to include the information about community size into the expected density of community to avoid the negligence of small and dense communities.\nFor each community \\(C\\) in partition \\(S\\), it uses the average modularity degree calculated by \\(d(C) = d^{int(C)} \u2212 d^{ext(C)}\\) where \\(d^{int(C)}\\) and \\(d^{ext(C)}\\) are the average internal and external degrees of \\(C\\) respectively to evaluate the fitness of \\(C\\) in its network.\nFinally, the modularity density can be calculated as follows:\n\n\\[Q(S) = \\sum_{C \\in S} \\frac{1}{n_C} ( \\sum_{i \\in C} 2 * \\lambda * k^{int}_{iC} - \\sum_{i \\in C} 2 * (1 - \\lambda) * k^{out}_{iC})\\]\nwhere \\(n_C\\) is the number of nodes in C, \\(k^{int}_{iC}\\) is the degree of node i within \\(C\\), \\(k^{out}_{iC}\\) is the deree of node i outside \\(C\\) and \\(\\lambda\\) is a paramter that allows for tuning the measure resolution (its default value, 0.5, computes the standard modularity density score).\n"
    },
    {
        "Parameters": {
            "graph": "a networkx/igraph object",
            "communities": "NodeClustering object",
            "lmbd": "resolution parameter, float in [0,1]. Default 0.5."
        },
        "Section_id": "modularity_density"
    },
    {
        "Section_id": "modularity_density",
        "Return": [
            "FitnessResult object\n"
        ]
    },
    {
        "Section_id": "modularity_density",
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = evaluation.modularity_density(g,communities)"
        ]
    },
    {
        "Section_id": "modularity_density",
        "References": [
            "Zhang, S., Ning, XM., Ding, C. et al. Determining modular organization of protein interaction networks by maximizing modularity density. <https://doi.org/10.1186/1752-0509-4-S2-S10>`_ BMC Syst Biol 4, S10 (2010)."
        ]
    },
    {
        "Section_id": "FuzzyNodeClustering",
        "Description": "Fuzzy Node Communities representation."
    },
    {
        "Field List > Parameters": {
            "communities": "list of communities",
            "node_allocation": "dictionary specifying for each node the allocation of probability toward the communities it is placed in",
            "graph": "a networkx/igraph object",
            "method_name": "community discovery algorithm name",
            "method_parameters": "configuration for the community discovery algorithm used",
            "overlap": "boolean, whether the partition is overlapping or not"
        },
        "Section_id": "FuzzyNodeClustering"
    },
    {
        "Field List > Methods > adjusted_mutual_information": {
            "Paramters": {
                "clustering": "NodeClustering object"
            },
            "Return": [
                "AMI score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.adjusted_mutual_information(leiden_communities)"
            ],
            "References": [
                "Vinh, N. X., Epps, J., & Bailey, J. (2010). Information theoretic measures for clusterings comparison: Variants, properties, normalization and correction for chance. Journal of Machine Learning Research, 11(Oct), 2837-2854."
            ],
            "Description": "Adjusted Mutual Information between two clusterings.\nAdjusted Mutual Information (AMI) is an adjustment of the Mutual\nInformation (MI) score to account for chance. It accounts for the fact that\nthe MI is generally higher for two clusterings with a larger number of\nclusters, regardless of whether there is actually more information shared.\nFor two clusterings \\(U\\) and \\(V\\), the AMI is given as:\nAMI(U, V) = [MI(U, V) - E(MI(U, V))] / [max(H(U), H(V)) - E(MI(U, V))]\n\nThis metric is independent of the absolute values of the labels:\na permutation of the class or cluster label values won\u2019t change the\nscore value in any way.\nThis metric is furthermore symmetric: switching label_true with\nlabel_pred will return the same score value. This can be useful to\nmeasure the agreement of two independent label assignments strategies\non the same dataset when the real ground truth is not known.\nBe mindful that this function is an order of magnitude slower than other\nmetrics, such as the Adjusted Rand Index.\n"
        },
        "Section_id": "FuzzyNodeClustering"
    },
    {
        "Field List > Methods > adjusted_rand_index": {
            "Paramters": {
                "clustering": "NodeClustering object"
            },
            "Return": [
                "ARI score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.adjusted_rand_index(leiden_communities)"
            ],
            "References": [
                "Hubert, L., & Arabie, P. (1985). Comparing partitions. Journal of classification, 2(1), 193-218."
            ],
            "Description": "Rand index adjusted for chance.\nThe Rand Index computes a similarity measure between two clusterings\nby considering all pairs of samples and counting pairs that are\nassigned in the same or different clusters in the predicted and\ntrue clusterings.\nThe raw RI score is then \u201cadjusted for chance\u201d into the ARI score\nusing the following scheme:\nARI = (RI - Expected_RI) / (max(RI) - Expected_RI)\n\nThe adjusted Rand index is thus ensured to have a value close to\n0.0 for random labeling independently of the number of clusters and\nsamples and exactly 1.0 when the clusterings are identical (up to\na permutation).\nARI is a symmetric measure:\nadjusted_rand_index(a, b) == adjusted_rand_index(b, a)\n\n"
        },
        "Section_id": "FuzzyNodeClustering"
    },
    {
        "Field List > Methods > average_internal_degree": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.average_internal_degree()"
            ],
            "References": [],
            "Description": "The average internal degree of the algorithms set.\n\n\\[f(S) = \\frac{2m_S}{n_S}\\]\nwhere \\(m_S\\) is the number of algorithms internal edges and \\(n_S\\) is the number of algorithms nodes.\n"
        },
        "Section_id": "FuzzyNodeClustering"
    },
    {
        "Field List > Methods > avg_distance": {
            "Paramters": {
                "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
            },
            "Return": [
                "If summary==True a FitnessResult object, otherwise a list of floats."
            ],
            "Example": [],
            "References": [],
            "Description": "Average distance.\nThe average distance of a community is defined average path length across all possible pair of nodes composing it.\n"
        },
        "Section_id": "FuzzyNodeClustering"
    },
    {
        "Field List > Methods > avg_embeddedness": {
            "Paramters": {
                "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
            },
            "Return": [
                "If summary==True a FitnessResult object, otherwise a list of floats."
            ],
            "Example": [],
            "References": [],
            "Description": "Average embeddedness of nodes within the community.\nThe embeddedness of a node n w.r.t. a community C is the ratio of its degree within the community and its overall degree.\n\n\\[emb(n,C) = \\frac{k_n^C}{k_n}\\]\nThe average embeddedness of a community C is:\n\n\\[avg_embd(c) = \\frac{1}{|C|} \\sum_{i \\in C} \\frac{k_n^C}{k_n}\\]\n"
        },
        "Section_id": "FuzzyNodeClustering"
    },
    {
        "Field List > Methods > avg_odf": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.avg_odf()"
            ],
            "References": [],
            "Description": "Average fraction of edges of a node of a algorithms that point outside the algorithms itself.\n\n\\[\\frac{1}{n_S} \\sum_{u \\in S} \\frac{|\\{(u,v)\\in E: v \\not\\in S\\}|}{d(u)}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\), \\(d(u)\\) is the degree of \\(u\\) and \\(n_S\\) is the set of algorithms nodes.\n"
        },
        "Section_id": "FuzzyNodeClustering"
    },
    {
        "Field List > Methods > avg_transitivity": {
            "Paramters": {
                "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
            },
            "Return": [
                "If summary==True a FitnessResult object, otherwise a list of floats."
            ],
            "Example": [],
            "References": [],
            "Description": "Average transitivity.\nThe average transitivity of a community is defined the as the average clustering coefficient of its nodes w.r.t. their connection within the community itself.\n"
        },
        "Section_id": "FuzzyNodeClustering"
    },
    {
        "Field List > Methods > conductance": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.conductance()"
            ],
            "References": [],
            "Description": "Fraction of total edge volume that points outside the algorithms.\n\n\\[f(S) = \\frac{c_S}{2 m_S+c_S}\\]\nwhere \\(c_S\\) is the number of algorithms nodes and, \\(m_S\\) is the number of algorithms edges\n"
        },
        "Section_id": "FuzzyNodeClustering"
    },
    {
        "Field List > Methods > cut_ratio": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.cut_ratio()"
            ],
            "References": [],
            "Description": "Fraction of existing edges (out of all possible edges) leaving the algorithms.\n..math:: f(S) = frac{c_S}{n_S (n \u2212 n_S)}\nwhere \\(c_S\\) is the number of algorithms nodes and, \\(n_S\\) is the number of edges on the algorithms boundary\n"
        },
        "Section_id": "FuzzyNodeClustering"
    },
    {
        "Field List > Methods > edges_inside": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.edges_inside()"
            ],
            "References": [],
            "Description": "Number of edges internal to the algorithms.\n"
        },
        "Section_id": "FuzzyNodeClustering"
    },
    {
        "Field List > Methods > erdos_renyi_modularity": {
            "Paramters": {},
            "Return": [
                "the Erdos-Renyi modularity score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.erdos_renyi_modularity()"
            ],
            "References": [],
            "Description": "Erdos-Renyi modularity is a variation of the Newman-Girvan one.\nIt assumes that vertices in a network are connected randomly with a constant probability \\(p\\).\n\n\\[Q(S) = \\frac{1}{m}\\sum_{c \\in S} (m_S \u2212 \\frac{mn_S(n_S \u22121)}{n(n\u22121)})\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms edges, \\(l_S\\) is the number of edges from nodes in S to nodes outside S.\n"
        },
        "Section_id": "FuzzyNodeClustering"
    },
    {
        "Field List > Methods > expansion": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.expansion()"
            ],
            "References": [],
            "Description": "Number of edges per algorithms node that point outside the cluster.\n\n\\[f(S) = \\frac{c_S}{n_S}\\]\nwhere \\(n_S\\) is the number of edges on the algorithms boundary, \\(c_S\\) is the number of algorithms nodes.\n"
        },
        "Section_id": "FuzzyNodeClustering"
    },
    {
        "Field List > Methods > f1": {
            "Paramters": {
                "clustering": "NodeClustering object"
            },
            "Return": [
                "F1 score (harmonic mean of precision and recall)"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.f1(leiden_communities)"
            ],
            "References": [
                "Rossetti, G., Pappalardo, L., & Rinzivillo, S. (2016). A novel approach to evaluate algorithms detection internal on ground truth. In Complex Networks VII (pp. 133-144). Springer, Cham."
            ],
            "Description": "Compute the average F1 score of the optimal algorithms matches among the partitions in input.\nWorks on overlapping/non-overlapping complete/partial coverage partitions.\n"
        },
        "Section_id": "FuzzyNodeClustering"
    },
    {
        "Field List > Methods > flake_odf": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.flake_odf()"
            ],
            "References": [],
            "Description": "Fraction of nodes in S that have fewer edges pointing inside than to the outside of the algorithms.\n\n\\[f(S) = \\frac{| \\{ u:u \\in S,| \\{(u,v) \\in E: v \\in S \\}| < d(u)/2 \\}|}{n_S}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\), \\(d(u)\\) is the degree of \\(u\\) and \\(n_S\\) is the set of algorithms nodes.\n"
        },
        "Section_id": "FuzzyNodeClustering"
    },
    {
        "Field List > Methods > fraction_over_median_degree": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.fraction_over_median_degree()"
            ],
            "References": [],
            "Description": "Fraction of algorithms nodes of having internal degree higher than the median degree value.\n\n\\[f(S) = \\frac{|\\{u: u \\in S,| \\{(u,v): v \\in S\\}| > d_m\\}| }{n_S}\\]\nwhere \\(d_m\\) is the internal degree median value\n"
        },
        "Section_id": "FuzzyNodeClustering"
    },
    {
        "Field List > Methods > get_description": {
            "Paramters": {
                "parameters_to_display": "parameters to display. By default, all float parameters.",
                "precision": "precision used to plot parameters. default: 3"
            },
            "Return": [
                "a string description of the method.\n"
            ],
            "Example": [],
            "References": [],
            "Description": "Return a description of the clustering, with the name of the method and its numeric parameters.\n"
        },
        "Section_id": "FuzzyNodeClustering"
    },
    {
        "Field List > Methods > hub_dominance": {
            "Paramters": {
                "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
            },
            "Return": [
                "If summary==True a FitnessResult object, otherwise a list of floats."
            ],
            "Example": [],
            "References": [],
            "Description": "Hub dominance.\nThe hub dominance of a community is defined as the ratio of the degree of its most connected node w.r.t. the theoretically maximal degree within the community.\n"
        },
        "Section_id": "FuzzyNodeClustering"
    },
    {
        "Field List > Methods > internal_edge_density": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.internal_edge_density()"
            ],
            "References": [],
            "Description": "The internal density of the algorithms set.\n\n\\[f(S) = \\frac{m_S}{n_S(n_S\u22121)/2}\\]\nwhere \\(m_S\\) is the number of algorithms internal edges and \\(n_S\\) is the number of algorithms nodes.\n"
        },
        "Section_id": "FuzzyNodeClustering"
    },
    {
        "Field List > Methods > link_modularity": {
            "Paramters": {},
            "Return": [
                "the link modularity score"
            ],
            "Example": [
                "from cdlib import evaluation\nfrom cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.link_modularity()"
            ],
            "References": [],
            "Description": "Quality function designed for directed graphs with overlapping communities.\n"
        },
        "Section_id": "FuzzyNodeClustering"
    },
    {
        "Field List > Methods > max_odf": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.max_odf()"
            ],
            "References": [],
            "Description": "Maximum fraction of edges of a node of a algorithms that point outside the algorithms itself.\n\n\\[max_{u \\in S} \\frac{|\\{(u,v)\\in E: v \\not\\in S\\}|}{d(u)}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\) and \\(d(u)\\) is the degree of \\(u\\)\n"
        },
        "Section_id": "FuzzyNodeClustering"
    },
    {
        "Field List > Methods > modularity_density": {
            "Paramters": {},
            "Return": [
                "the modularity density score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.modularity_density()"
            ],
            "References": [],
            "Description": "The modularity density is one of several propositions that envisioned to palliate the resolution limit issue of modularity based measures.\nThe idea of this metric is to include the information about algorithms size into the expected density of algorithms to avoid the negligence of small and dense communities.\nFor each algorithms \\(C\\) in partition \\(S\\), it uses the average modularity degree calculated by \\(d(C) = d^{int(C)} \u2212 d^{ext(C)}\\) where \\(d^{int(C)}\\) and \\(d^{ext(C)}\\) are the average internal and external degrees of \\(C\\) respectively to evaluate the fitness of \\(C\\) in its network.\nFinally, the modularity density can be calculated as follows:\n\n\\[Q(S) = \\sum_{C \\in S} \\frac{1}{n_C} ( \\sum_{i \\in C} k^{int}_{iC} - \\sum_{i \\in C} k^{out}_{iC})\\]\nwhere \\(n_C\\) is the number of nodes in C, \\(k^{int}_{iC}\\) is the degree of node i within \\(C\\) and \\(k^{out}_{iC}\\) is the deree of node i outside \\(C\\).\n"
        },
        "Section_id": "FuzzyNodeClustering"
    },
    {
        "Field List > Methods > modularity_overlap": {
            "Paramters": {
                "weight": "label identifying the edge weight parameter name (if present), default None"
            },
            "Return": [
                "FitnessResult object"
            ],
            "Example": [],
            "References": [
                "\nLazar, D. Abel and T. Vicsek, \u201cModularity measure of networks with overlapping communities\u201d  EPL, 90 (2010) 18001 doi: 10.1209/0295-5075/90/18001\n\n",
                "Lazar, D. Abel and T. Vicsek, \u201cModularity measure of networks with overlapping communities\u201d  EPL, 90 (2010) 18001 doi: 10.1209/0295-5075/90/18001"
            ],
            "Description": "Determines the Overlapping Modularity of a partition C on a graph G.\nOverlapping Modularity is defined as\n\n\\[M_{c_{r}}^{ov} = \\sum_{i \\in c_{r}} \\frac{\\sum_{j \\in c_{r}, i \\neq j}a_{ij} - \\sum_{j \\not \\in c_{r}}a_{ij}}{d_{i} \\cdot s_{i}} \\cdot \\frac{n_{c_{r}}^{e}}{n_{c_{r}} \\cdot \\binom{n_{c_{r}}}{2}}\\]\n"
        },
        "Section_id": "FuzzyNodeClustering"
    },
    {
        "Field List > Methods > newman_girvan_modularity": {
            "Paramters": {},
            "Return": [
                "the Newman-Girvan modularity score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.newman_girvan_modularity()"
            ],
            "References": [],
            "Description": "Difference the fraction of intra algorithms edges of a partition with the expected number of such edges if distributed according to a null model.\nIn the standard version of modularity, the null model preserves the expected degree sequence of the graph under consideration. In other words, the modularity compares the real network structure with a corresponding one where nodes are connected without any preference about their neighbors.\n\n\\[Q(S) = \\frac{1}{m}\\sum_{c \\in S}(m_S - \\frac{(2 m_S + l_S)^2}{4m})\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms edges, \\(l_S\\) is the number of edges from nodes in S to nodes outside S.\n"
        },
        "Section_id": "FuzzyNodeClustering"
    },
    {
        "Field List > Methods > nf1": {
            "Paramters": {
                "clustering": "NodeClustering object"
            },
            "Return": [
                "MatchingResult instance"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.nf1(leiden_communities)"
            ],
            "References": [
                "Rossetti, G., Pappalardo, L., & Rinzivillo, S. (2016). A novel approach to evaluate algorithms detection internal on ground truth.",
                "Rossetti, G. (2017). : RDyn: graph benchmark handling algorithms dynamics. Journal of Complex Networks. 5(6), 893-912."
            ],
            "Description": "Compute the Normalized F1 score of the optimal algorithms matches among the partitions in input.\nWorks on overlapping/non-overlapping complete/partial coverage partitions.\n"
        },
        "Section_id": "FuzzyNodeClustering"
    },
    {
        "Field List > Methods > normalized_cut": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.normalized_cut()"
            ],
            "References": [],
            "Description": "Normalized variant of the Cut-Ratio\n\n\\[: f(S) = \\frac{c_S}{2m_S+c_S} + \\frac{c_S}{2(m\u2212m_S )+c_S}\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms internal edges and \\(c_S\\) is the number of algorithms nodes.\n"
        },
        "Section_id": "FuzzyNodeClustering"
    },
    {
        "Field List > Methods > normalized_mutual_information": {
            "Paramters": {
                "clustering": "NodeClustering object"
            },
            "Return": [
                "normalized mutual information score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.normalized_mutual_information(leiden_communities)"
            ],
            "References": [],
            "Description": "Normalized Mutual Information between two clusterings.\nNormalized Mutual Information (NMI) is an normalization of the Mutual\nInformation (MI) score to scale the results between 0 (no mutual\ninformation) and 1 (perfect correlation). In this function, mutual\ninformation is normalized by sqrt(H(labels_true) * H(labels_pred))\n"
        },
        "Section_id": "FuzzyNodeClustering"
    },
    {
        "Field List > Methods > omega": {
            "Paramters": {
                "clustering": "NodeClustering object"
            },
            "Return": [
                "omega index"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.omega(leiden_communities)"
            ],
            "References": [
                "Gabriel Murray, Giuseppe Carenini, and Raymond Ng. 2012. Using the omega index for evaluating abstractive algorithms detection. In Proceedings of Workshop on Evaluation Metrics and System Comparison for Automatic Summarization. Association for Computational Linguistics, Stroudsburg, PA, USA, 10-18."
            ],
            "Description": "Index of resemblance for overlapping, complete coverage, network clusterings.\n"
        },
        "Section_id": "FuzzyNodeClustering"
    },
    {
        "Field List > Methods > overlapping_normalized_mutual_information_LFK": {
            "Paramters": {
                "clustering": "NodeClustering object"
            },
            "Return": [
                "onmi score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.overlapping_normalized_mutual_information_LFK(leiden_communities)"
            ],
            "References": [
                "Lancichinetti, A., Fortunato, S., & Kertesz, J. (2009). Detecting the overlapping and hierarchical community structure in complex networks. New Journal of Physics, 11(3), 033015."
            ],
            "Description": "Overlapping Normalized Mutual Information between two clusterings.\nExtension of the Normalized Mutual Information (NMI) score to cope with overlapping partitions.\nThis is the version proposed by Lancichinetti et al.\n"
        },
        "Section_id": "FuzzyNodeClustering"
    },
    {
        "Field List > Methods > overlapping_normalized_mutual_information_MGH": {
            "Paramters": {
                "clustering": "NodeClustering object",
                "normalization": "one of \u201cmax\u201d or \u201cLFK\u201d. Default \u201cmax\u201d (corresponds to the main method described in the article)"
            },
            "Return": [
                "onmi score\n"
            ],
            "Example": [
                "from cdlib import evaluation, algorithms\ng = nx.karate_club_graph()\nlouvain_communities = algorithms.louvain(g)\nleiden_communities = algorithms.leiden(g)\nevaluation.overlapping_normalized_mutual_information_MGH(louvain_communities,leiden_communities)"
            ],
            "References": [
                "McDaid, A. F., Greene, D., & Hurley, N. (2011). Normalized mutual information to evaluate overlapping community finding algorithms. arXiv preprint arXiv:1110.2515. Chicago"
            ],
            "Description": "Overlapping Normalized Mutual Information between two clusterings.\nExtension of the Normalized Mutual Information (NMI) score to cope with overlapping partitions.\nThis is the version proposed by McDaid et al. using a different normalization than the original LFR one. See ref.\nfor more details.\n"
        },
        "Section_id": "FuzzyNodeClustering"
    },
    {
        "Field List > Methods > scaled_density": {
            "Paramters": {
                "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
            },
            "Return": [
                "If summary==True a FitnessResult object, otherwise a list of floats."
            ],
            "Example": [],
            "References": [],
            "Description": "Scaled density.\nThe scaled density of a community is defined as the ratio of the community density w.r.t. the complete graph density.\n"
        },
        "Section_id": "FuzzyNodeClustering"
    },
    {
        "Field List > Methods > significance": {
            "Paramters": {},
            "Return": [
                "the significance score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.significance()"
            ],
            "References": [],
            "Description": "Significance estimates how likely a partition of dense communities appear in a random graph.\n"
        },
        "Section_id": "FuzzyNodeClustering"
    },
    {
        "Field List > Methods > size": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [],
            "References": [],
            "Description": "Size is the number of nodes in the community\n"
        },
        "Section_id": "FuzzyNodeClustering"
    },
    {
        "Field List > Methods > surprise": {
            "Paramters": {},
            "Return": [
                "the surprise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.surprise()"
            ],
            "References": [],
            "Description": "Surprise is statistical approach proposes a quality metric assuming that edges between vertices emerge randomly according to a hyper-geometric distribution.\nAccording to the Surprise metric, the higher the score of a partition, the less likely it is resulted from a random realization, the better the quality of the algorithms structure.\n"
        },
        "Section_id": "FuzzyNodeClustering"
    },
    {
        "Field List > Methods > to_json": {
            "Paramters": {},
            "Return": [
                "a JSON formatted string representing the object"
            ],
            "Example": [],
            "References": [],
            "Description": "Generate a JSON representation of the algorithms object\n"
        },
        "Section_id": "FuzzyNodeClustering"
    },
    {
        "Field List > Methods > to_node_community_map": {
            "Paramters": {},
            "Return": [
                "dict of the form <node, list(communities)>"
            ],
            "Example": [],
            "References": [],
            "Description": "Generate a <node, list(communities)> representation of the current clustering\n"
        },
        "Section_id": "FuzzyNodeClustering"
    },
    {
        "Field List > Methods > triangle_participation_ratio": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.triangle_participation_ratio()"
            ],
            "References": [],
            "Description": "Fraction of algorithms nodes that belong to a triad.\n\n\\[f(S) = \\frac{ | \\{ u: u \\in S,\\{(v,w):v, w \\in S,(u,v) \\in E,(u,w) \\in E,(v,w) \\in E \\} \\not = \\emptyset \\} |}{n_S}\\]\nwhere \\(n_S\\) is the set of algorithms nodes.\n"
        },
        "Section_id": "FuzzyNodeClustering"
    },
    {
        "Field List > Methods > variation_of_information": {
            "Paramters": {
                "clustering": "NodeClustering object"
            },
            "Return": [
                "VI score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.variation_of_information(leiden_communities)"
            ],
            "References": [
                "Meila, M. (2007). Comparing clusterings - an information based distance. Journal of Multivariate Analysis, 98, 873-895. doi:10.1016/j.jmva.2006.11.013"
            ],
            "Description": "Variation of Information among two nodes partitions.\n$$ H(p)+H(q)-2MI(p, q) $$\nwhere MI is the mutual information, H the partition entropy and p,q are the algorithms sets\n"
        },
        "Section_id": "FuzzyNodeClustering"
    },
    {
        "Field List > Methods > z_modularity": {
            "Paramters": {},
            "Return": [
                "the z-modularity score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.z_modularity()"
            ],
            "References": [],
            "Description": "Z-modularity is another variant of the standard modularity proposed to avoid the resolution limit.\nThe concept of this version is based on an observation that the difference between the fraction of edges inside communities and the expected number of such edges in a null model should not be considered as the only contribution to the final quality of algorithms structure.\n"
        },
        "Section_id": "FuzzyNodeClustering"
    },
    {
        "Section_id": "der",
        "Description": "DER is a Diffusion Entropy Reducer graph clustering algorithm.\nThe algorithm uses random walks to embed the graph in a space of measures, after which a modification of k-means in that space is applied. It creates the walks, creates an initialization, runs the algorithm,\nand finally extracts the communities.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "an undirected networkx graph object",
            "walk_len": "length of the random walk, default 3",
            "threshold": "threshold for stop criteria; if the likelihood_diff is less than threshold tha algorithm stops, default 0.00001",
            "iter_bound": "maximum number of iteration, default 50"
        },
        "Section_id": "der"
    },
    {
        "Section_id": "der",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "der",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.der(G, 3, .00001, 50)"
        ]
    },
    {
        "Section_id": "Parameter",
        "Description": "Initialize self.  See help(type(self)) for accurate signature."
    },
    {
        "Field List > Parameters": {},
        "Section_id": "Parameter"
    },
    {
        "Section_id": "head_tail",
        "Description": "Identifying homogeneous communities in complex networks by applying head/tail breaks on edge betweenness given its heavy-tailed distribution.\nNote: this implementation is suited for small-medium sized graphs, and it may take couple of minutes or longer for a bigger graph.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "head_tail_ratio": "head/tail division rule. Float in [0,1], dafault 0.4."
        },
        "Section_id": "head_tail"
    },
    {
        "Section_id": "head_tail",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "head_tail",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.head_tail(G, head_tail_ratio=0.8)"
        ]
    },
    {
        "Section_id": "lais2",
        "Description": "LAIS2 is an overlapping community discovery algorithm based on the density function.\nIn the algorithm considers the density of a group is defined as the average density of the communication exchanges between the actors of the group.\nLAIS2 IS composed of two procedures LA (Link Aggregate Algorithm) and IS2 (Iterative Scan Algorithm).\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object"
        },
        "Section_id": "lais2"
    },
    {
        "Section_id": "lais2",
        "Return": [
            "NodeClustering object"
        ]
    },
    {
        "Section_id": "lais2",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncom = algorithms.lais2(G)"
        ]
    },
    {
        "Section_id": "plot_sim_matrix",
        "Description": "Plot a similarity matrix between a list of clusterings, using the provided scoring function.\n"
    },
    {
        "Parameters": {
            "clusterings": "list of clusterings to compare",
            "scoring": "the scoring function to use"
        },
        "Section_id": "plot_sim_matrix"
    },
    {
        "Section_id": "plot_sim_matrix",
        "Return": [
            "a ClusterGrid instance\n"
        ]
    },
    {
        "Section_id": "plot_sim_matrix",
        "Example": [
            "from cdlib import algorithms, viz, evaluation\nimport networkx as nx\ng = nx.karate_club_graph()\ncoms = algorithms.louvain(g)\ncoms2 = algorithms.walktrap(g)\nclustermap = viz.plot_sim_matrix([coms,coms2],evaluation.adjusted_mutual_information)"
        ]
    },
    {
        "Section_id": "grid_search",
        "Description": "Returns the optimal partition of the specified graph w.r.t. the selected algorithm and quality score.\n"
    },
    {
        "Parameters": {
            "method": "community discovery method (from nclib.community)",
            "graph": "networkx/igraph object",
            "parameters": "list of Parameter and BoolParameter objects",
            "quality_score": "a fitness function to evaluate the obtained partition (from nclib.evaluation)",
            "aggregate": "function to select the best fitness value. Possible values: min/max"
        },
        "Section_id": "grid_search"
    },
    {
        "Section_id": "grid_search",
        "Return": [
            "at each call the generator yields a tuple composed by: the optimal configuration for the given algorithm, input paramters and fitness function; the obtained communities; the fitness score\n"
        ]
    },
    {
        "Section_id": "grid_search",
        "Example": [
            "import networkx as nx\nfrom cdlib import algorithms, ensemble\ng = nx.karate_club_graph()\nresolution = ensemble.Parameter(name=\"resolution\", start=0.1, end=1, step=0.1)\nrandomize = ensemble.BoolParameter(name=\"randomize\")\ncommunities, scoring = ensemble.grid_search(graph=g, method=algorithms.louvain,\n                                                    parameters=[resolution, randomize],\n                                                    quality_score=evaluation.erdos_renyi_modularity,\n                                                    aggregate=max)\nprint(communities, scoring)"
        ]
    },
    {
        "Section_id": "mcode",
        "Description": "MCODE is the earliest seed-growth method for predicting protein complexes from PPI networks. MCODE works in two steps:\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "weights": "label used for the edge weights. Default, None.",
            "weight_threshold": "Threshold for similarity weighs"
        },
        "Section_id": "mcode"
    },
    {
        "Section_id": "mcode",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "mcode",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.mcode(G)"
        ]
    },
    {
        "Section_id": "mcode",
        "References": [
            "vertex weighting, and",
            "molecular complex prediction."
        ]
    },
    {
        "Section_id": "variation_of_information",
        "Description": "Variation of Information among two nodes partitions.\n$$ H(p)+H(q)-2MI(p, q) $$\nwhere MI is the mutual information, H the partition entropy and p,q are the algorithms sets\n"
    },
    {
        "Parameters": {
            "first_partition": "NodeClustering object",
            "second_partition": "NodeClustering object"
        },
        "Section_id": "variation_of_information"
    },
    {
        "Section_id": "variation_of_information",
        "Return": [
            "MatchingResult object\n"
        ]
    },
    {
        "Section_id": "variation_of_information",
        "Example": [
            "from cdlib import evaluation, algorithms\ng = nx.karate_club_graph()\nlouvain_communities = algorithms.louvain(g)\nleiden_communities = algorithms.leiden(g)\nevaluation.variation_of_information(louvain_communities,leiden_communities)"
        ]
    },
    {
        "Section_id": "variation_of_information",
        "References": [
            "Meila, M. (2007). Comparing clusterings - an information based distance. Journal of Multivariate Analysis, 98, 873-895. doi:10.1016/j.jmva.2006.11.013"
        ]
    },
    {
        "Section_id": "scan",
        "Description": "SCAN (Structural Clustering Algorithm for Networks) is an algorithm which detects clusters, hubs and outliers in networks.\nIt clusters vertices based on a structural similarity measure.\nThe method uses the neighborhood of the vertices as clustering criteria instead of only their direct connections.\nVertices are grouped into the clusters by how they share neighbors.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "epsilon": "the minimum threshold to assigning cluster membership",
            "mu": "minimum number of neineighbors with a structural similarity that exceeds the threshold epsilon"
        },
        "Section_id": "scan"
    },
    {
        "Section_id": "scan",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "scan",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncom = algorithms.scan(G, epsilon=0.7, mu=3)"
        ]
    },
    {
        "Section_id": "umstmo",
        "Description": "Overlapping community detection based on the union of all maximum spanning trees\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object"
        },
        "Section_id": "umstmo"
    },
    {
        "Section_id": "umstmo",
        "Return": [
            "NodeClustering object"
        ]
    },
    {
        "Section_id": "umstmo",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.umstmo(G)"
        ]
    },
    {
        "Section_id": "significance",
        "Description": "Significance estimates how likely a partition of dense communities appear in a random graph.\n"
    },
    {
        "Parameters": {
            "graph": "a networkx/igraph object",
            "communities": "NodeClustering object"
        },
        "Section_id": "significance"
    },
    {
        "Section_id": "significance",
        "Return": [
            "FitnessResult object\n"
        ]
    },
    {
        "Section_id": "significance",
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = evaluation.significance(g,communities)"
        ]
    },
    {
        "Section_id": "significance",
        "References": [
            "Traag, V. A., Aldecoa, R., & Delvenne, J. C. (2015). Detecting communities using asymptotical surprise. Physical Review E, 92(2), 022816."
        ]
    },
    {
        "Section_id": "plot_com_properties_relation",
        "Description": "Plot the relation between two properties/fitness function of a clustering\n"
    },
    {
        "Parameters": {
            "com_clusters": "clustering(s) to analyze (cluster or cluster list)",
            "com_fitness_x": "first fitness/community property",
            "com_fitness_y": "first fitness/community property",
            "kwargs": "parameters for the seaborn lmplot"
        },
        "Section_id": "plot_com_properties_relation"
    },
    {
        "Section_id": "plot_com_properties_relation",
        "Return": [
            "a seaborn lmplot\n"
        ]
    },
    {
        "Section_id": "plot_com_properties_relation",
        "Example": [
            "from cdlib import algorithms, viz, evaluation\nimport networkx as nx\ng = nx.karate_club_graph()\ncoms = algorithms.louvain(g)\ncoms2 = algorithms.walktrap(g)\nlmplot = viz.plot_com_properties_relation([coms,coms2],evaluation.size,evaluation.internal_edge_density)"
        ]
    },
    {
        "Section_id": "kcut",
        "Description": "An Efficient Spectral Algorithm for Network Community Discovery.\nKcut is designed to provide a unique combination of recursive partitioning and direct k-way methods, able to guarantee the efficiency of a recursive approach, while also having the same accuracy as a direct k-way method.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "kmax": "maximum value of k, dafault 4."
        },
        "Section_id": "kcut"
    },
    {
        "Section_id": "kcut",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "kcut",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.kcut(G, kmax=4)"
        ]
    },
    {
        "Section_id": "avg_distance",
        "Description": "Average distance.\nThe average distance of a community is defined average path length across all possible pair of nodes composing it.\n"
    },
    {
        "Parameters": {
            "graph": "a networkx/igraph object",
            "communities": "NodeClustering object",
            "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
        },
        "Section_id": "avg_distance"
    },
    {
        "Section_id": "avg_distance",
        "Return": [
            "If summary==True a FitnessResult object, otherwise a list of floats.\n"
        ]
    },
    {
        "Section_id": "avg_distance",
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nscd = evaluation.avg_distance(g,communities)"
        ]
    },
    {
        "Section_id": "ilouvain",
        "Description": "The I-Louvain algorithm extends the Louvain approach in order to deal only with the scalar attributes of the nodes.\nIt optimizes Newman\u2019s modularity combined with an entropy measure.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "labels": "dictionary specifying for each node (key) a dict (value) specifying the name attribute (key) and its value (value)"
        },
        "Section_id": "ilouvain"
    },
    {
        "Section_id": "ilouvain",
        "Return": [
            "AttrNodeClustering object\n"
        ]
    },
    {
        "Section_id": "ilouvain",
        "Example": [
            "from cdlib.algorithms import ilouvain\nimport networkx as nx\nimport random\nl1 = [0.1, 0.4, 0.5]\nl2 = [34, 3, 112]\ng_attr = nx.barabasi_albert_graph(100, 5)\nlabels=dict()\nfor node in g_attr.nodes():\n   labels[node]={\"l1\":random.choice(l1), \"l2\":random.choice(l2)}\nid = dict()\nfor n in g.nodes():\n    id[n] = n\ncommunities = ilouvain(g_attr, labels, id)"
        ]
    },
    {
        "Section_id": "agdl",
        "Description": "AGDL is a graph-based agglomerative algorithm, for clustering high-dimensional data.\nThe algorithm uses  the indegree and outdegree to characterize the affinity between two clusters.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "number_communities": "number of communities",
            "kc": "size of the neighbor set for each cluster"
        },
        "Section_id": "agdl"
    },
    {
        "Section_id": "agdl",
        "Return": [
            "NodeClustering object\n\n\n\n\nExample:\n\n\n\n\n"
        ]
    },
    {
        "Section_id": "agdl",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncom = algorithms.agdl(g, number_communities=3, kc=4)"
        ]
    },
    {
        "Section_id": "pool",
        "Description": "Execute on a pool of community discovery internal on the input graph.\n"
    },
    {
        "Parameters": {
            "methods": "list community discovery methods (from nclib.community)",
            "graph": "networkx/igraph object",
            "configurations": "list of lists (one for each method) of Parameter and BoolParameter objects"
        },
        "Section_id": "pool"
    },
    {
        "Section_id": "pool",
        "Return": [
            "at each call the generator yields a tuple composed by: the actual method, its current configuration and the obtained communities\n"
        ]
    },
    {
        "Section_id": "pool",
        "Example": [
            "import networkx as nx\nfrom cdlib import algorithms, ensemble\ng = nx.karate_club_graph()\n# Louvain\nresolution = ensemble.Parameter(name=\"resolution\", start=0.1, end=1, step=0.1)\nrandomize = ensemble.BoolParameter(name=\"randomize\")\nlouvain_conf = [resolution, randomize]\n# Angel\nthreshold = ensemble.Parameter(name=\"threshold\", start=0.1, end=1, step=0.1)\nangel_conf = [threshold]\nmethods = [algorithms.louvain, algorithms.angel]\nfor communities in ensemble.pool(g, methods, [louvain_conf, angel_conf]):\n    print(communities)"
        ]
    },
    {
        "Section_id": "rb_pots",
        "Description": "Rb_pots is a model where the quality function to optimize is:\n\n\\[Q = \\sum_{ij} \\left(A_{ij} - \\gamma \\frac{k_i k_j}{2m} \\right)\\delta(\\sigma_i, \\sigma_j)\\]\nwhere \\(A\\) is the adjacency matrix, \\(k_i\\) is the (weighted) degree of node \\(i\\), \\(m\\) is the total number of edges (or total edge weight), \\(\\sigma_i\\) denotes the community of node \\(i\\) and \\(\\delta(\\sigma_i, \\sigma_j) = 1\\) if \\(\\sigma_i = \\sigma_j\\) and 0 otherwise.\nFor directed graphs a slightly different formulation is used, as proposed by Leicht and Newman :\n\n\\[Q = \\sum_{ij} \\left(A_{ij} - \\gamma \\frac{k_i^\\mathrm{out} k_j^\\mathrm{in}}{m} \\right)\\delta(\\sigma_i, \\sigma_j),\\]\nwhere \\(k_i^\\mathrm{out}\\) and \\(k_i^\\mathrm{in}\\) refers to respectively the outdegree and indegree of node \\(i\\) , and \\(A_{ij}\\) refers to an edge from \\(i\\) to \\(j\\).\nNote that this is the same of Leiden algorithm when setting \\(\\gamma=1\\) and normalising by \\(2m\\), or \\(m\\) for directed graphs.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "initial_membership": "list of int Initial membership for the partition. IfNonethen defaults to a singleton partition. Deafault None",
            "weights": "list of double, or edge attribute Weights of edges. Can be either an iterable or an edge attribute. Deafault None",
            "resolution_parameter": "double >0 A parameter value controlling the coarseness of the clustering. Higher resolutions lead to more communities, while lower resolutions lead to fewer communities. Default 1"
        },
        "Section_id": "rb_pots"
    },
    {
        "Section_id": "rb_pots",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "rb_pots",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.rb_pots(G)"
        ]
    },
    {
        "Section_id": "flake_odf",
        "Description": "Fraction of nodes in S that have fewer edges pointing inside than to the outside of the community.\n\n\\[f(S) = \\frac{| \\{ u:u \\in S,| \\{(u,v) \\in E: v \\in S \\}| < d(u)/2 \\}|}{n_S}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\), \\(d(u)\\) is the degree of \\(u\\) and \\(n_S\\) is the set of community nodes.\n"
    },
    {
        "Parameters": {
            "graph": "a networkx/igraph object",
            "community": "NodeClustering object",
            "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
        },
        "Section_id": "flake_odf"
    },
    {
        "Section_id": "flake_odf",
        "Return": [
            "If summary==True a FitnessResult object, otherwise a list of floats.\n"
        ]
    },
    {
        "Section_id": "flake_odf",
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = evaluation.flake_odf(g,communities)"
        ]
    },
    {
        "Section_id": "flake_odf",
        "References": [
            "Flake, G.W., Lawrence, S., Giles, C.L., et al.: Efficient identification of web communities. In: KDD, vol. 2000, pp. 150\u2013160 (2000)"
        ]
    },
    {
        "Section_id": "ego_networks",
        "Description": "Ego-networks returns overlapping communities centered at each nodes within a given radius.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "level": "extrac communities with all neighbors of distance<=level from a node. Deafault 1"
        },
        "Section_id": "ego_networks"
    },
    {
        "Section_id": "ego_networks",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "ego_networks",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.ego_networks(G)"
        ]
    },
    {
        "Section_id": "modularity_overlap",
        "Description": "Determines the Overlapping Modularity of a partition C on a graph G.\nOverlapping Modularity is defined as\n"
    },
    {
        "Parameters": {
            "graph": "a networkx/igraph object",
            "communities": "NodeClustering object",
            "weight": "label identifying the edge weight parameter name (if present), default None"
        },
        "Section_id": "modularity_overlap"
    },
    {
        "Section_id": "modularity_overlap",
        "Return": [
            "FitnessResult object\n"
        ]
    },
    {
        "Section_id": "modularity_overlap",
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = evaluation.modularity_overlap(g, communities)"
        ]
    },
    {
        "Section_id": "modularity_overlap",
        "References": [
            "\nLazar, D. Abel and T. Vicsek, \u201cModularity measure of networks with overlapping communities\u201d  EPL, 90 (2010) 18001 doi: 10.1209/0295-5075/90/18001\n\n",
            "Lazar, D. Abel and T. Vicsek, \u201cModularity measure of networks with overlapping communities\u201d  EPL, 90 (2010) 18001 doi: 10.1209/0295-5075/90/18001"
        ]
    },
    {
        "Section_id": "congo",
        "Description": "CONGO (CONGA Optimized) is an optimization of the CONGA algortithm.\nThe CONGO algorithm is the same as CONGA but using local betweenness. The complete CONGO algorithm is as follows:\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "number_communities": "the number of communities desired",
            "height": "The lengh of the longest shortest paths that CONGO considers, default 2"
        },
        "Section_id": "congo"
    },
    {
        "Section_id": "congo",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "congo",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncom = algorithms.congo(G, number_communities=3, height=2)"
        ]
    },
    {
        "Section_id": "congo",
        "References": [
            "Calculate edge betweenness of edges and split betweenness of vertices.",
            "Find edge with maximum edge betweenness or vertex with maximum split betweenness, if greater.",
            "\nRecalculate edge betweenness and split betweenness:\n\nSubtract betweenness of h-region centred on the removed edge or split vertex.\nRemove the edge or split the vertex.\nAdd betweenness for the same region.\n\n\n\n",
            "Subtract betweenness of h-region centred on the removed edge or split vertex.",
            "Remove the edge or split the vertex.",
            "Add betweenness for the same region.",
            "Repeat from step 2 until no edges remain."
        ]
    },
    {
        "Section_id": "dcs",
        "Description": "Divide and Conquer Strategy\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object"
        },
        "Section_id": "dcs"
    },
    {
        "Section_id": "dcs",
        "Return": [
            "NodeClustering object"
        ]
    },
    {
        "Section_id": "dcs",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.dcs(G)"
        ]
    },
    {
        "Section_id": "girvan_newman",
        "Description": "The Girvan\u2013Newman algorithm detects communities by progressively removing edges from the original graph.\nThe algorithm removes the \u201cmost valuable\u201d edge, traditionally the edge with the highest betweenness centrality, at each step. As the graph breaks down into pieces, the tightly knit community structure is exposed and the result can be depicted as a dendrogram.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "level": "the level where to cut the dendrogram"
        },
        "Section_id": "girvan_newman"
    },
    {
        "Section_id": "girvan_newman",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "girvan_newman",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncom = algorithms.girvan_newman(G, level=3)"
        ]
    },
    {
        "Section_id": "AttrNodeClustering",
        "Description": "Attribute Node Communities representation."
    },
    {
        "Field List > Parameters": {
            "communities": "list of communities",
            "graph": "a networkx/igraph object",
            "method_name": "community discovery algorithm name",
            "coms_labels": "dictionary specifying for each community the frequency of the attribute values",
            "method_parameters": "configuration for the community discovery algorithm used",
            "overlap": "boolean, whether the partition is overlapping or not"
        },
        "Section_id": "AttrNodeClustering"
    },
    {
        "Field List > Methods > adjusted_mutual_information": {
            "Paramters": {
                "clustering": "NodeClustering object"
            },
            "Return": [
                "AMI score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.adjusted_mutual_information(leiden_communities)"
            ],
            "References": [
                "Vinh, N. X., Epps, J., & Bailey, J. (2010). Information theoretic measures for clusterings comparison: Variants, properties, normalization and correction for chance. Journal of Machine Learning Research, 11(Oct), 2837-2854."
            ],
            "Description": "Adjusted Mutual Information between two clusterings.\nAdjusted Mutual Information (AMI) is an adjustment of the Mutual\nInformation (MI) score to account for chance. It accounts for the fact that\nthe MI is generally higher for two clusterings with a larger number of\nclusters, regardless of whether there is actually more information shared.\nFor two clusterings \\(U\\) and \\(V\\), the AMI is given as:\nAMI(U, V) = [MI(U, V) - E(MI(U, V))] / [max(H(U), H(V)) - E(MI(U, V))]\n\nThis metric is independent of the absolute values of the labels:\na permutation of the class or cluster label values won\u2019t change the\nscore value in any way.\nThis metric is furthermore symmetric: switching label_true with\nlabel_pred will return the same score value. This can be useful to\nmeasure the agreement of two independent label assignments strategies\non the same dataset when the real ground truth is not known.\nBe mindful that this function is an order of magnitude slower than other\nmetrics, such as the Adjusted Rand Index.\n"
        },
        "Section_id": "AttrNodeClustering"
    },
    {
        "Field List > Methods > adjusted_rand_index": {
            "Paramters": {
                "clustering": "NodeClustering object"
            },
            "Return": [
                "ARI score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.adjusted_rand_index(leiden_communities)"
            ],
            "References": [
                "Hubert, L., & Arabie, P. (1985). Comparing partitions. Journal of classification, 2(1), 193-218."
            ],
            "Description": "Rand index adjusted for chance.\nThe Rand Index computes a similarity measure between two clusterings\nby considering all pairs of samples and counting pairs that are\nassigned in the same or different clusters in the predicted and\ntrue clusterings.\nThe raw RI score is then \u201cadjusted for chance\u201d into the ARI score\nusing the following scheme:\nARI = (RI - Expected_RI) / (max(RI) - Expected_RI)\n\nThe adjusted Rand index is thus ensured to have a value close to\n0.0 for random labeling independently of the number of clusters and\nsamples and exactly 1.0 when the clusterings are identical (up to\na permutation).\nARI is a symmetric measure:\nadjusted_rand_index(a, b) == adjusted_rand_index(b, a)\n\n"
        },
        "Section_id": "AttrNodeClustering"
    },
    {
        "Field List > Methods > average_internal_degree": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.average_internal_degree()"
            ],
            "References": [],
            "Description": "The average internal degree of the algorithms set.\n\n\\[f(S) = \\frac{2m_S}{n_S}\\]\nwhere \\(m_S\\) is the number of algorithms internal edges and \\(n_S\\) is the number of algorithms nodes.\n"
        },
        "Section_id": "AttrNodeClustering"
    },
    {
        "Field List > Methods > avg_distance": {
            "Paramters": {
                "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
            },
            "Return": [
                "If summary==True a FitnessResult object, otherwise a list of floats."
            ],
            "Example": [],
            "References": [],
            "Description": "Average distance.\nThe average distance of a community is defined average path length across all possible pair of nodes composing it.\n"
        },
        "Section_id": "AttrNodeClustering"
    },
    {
        "Field List > Methods > avg_embeddedness": {
            "Paramters": {
                "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
            },
            "Return": [
                "If summary==True a FitnessResult object, otherwise a list of floats."
            ],
            "Example": [],
            "References": [],
            "Description": "Average embeddedness of nodes within the community.\nThe embeddedness of a node n w.r.t. a community C is the ratio of its degree within the community and its overall degree.\n\n\\[emb(n,C) = \\frac{k_n^C}{k_n}\\]\nThe average embeddedness of a community C is:\n\n\\[avg_embd(c) = \\frac{1}{|C|} \\sum_{i \\in C} \\frac{k_n^C}{k_n}\\]\n"
        },
        "Section_id": "AttrNodeClustering"
    },
    {
        "Field List > Methods > avg_odf": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.avg_odf()"
            ],
            "References": [],
            "Description": "Average fraction of edges of a node of a algorithms that point outside the algorithms itself.\n\n\\[\\frac{1}{n_S} \\sum_{u \\in S} \\frac{|\\{(u,v)\\in E: v \\not\\in S\\}|}{d(u)}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\), \\(d(u)\\) is the degree of \\(u\\) and \\(n_S\\) is the set of algorithms nodes.\n"
        },
        "Section_id": "AttrNodeClustering"
    },
    {
        "Field List > Methods > avg_transitivity": {
            "Paramters": {
                "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
            },
            "Return": [
                "If summary==True a FitnessResult object, otherwise a list of floats."
            ],
            "Example": [],
            "References": [],
            "Description": "Average transitivity.\nThe average transitivity of a community is defined the as the average clustering coefficient of its nodes w.r.t. their connection within the community itself.\n"
        },
        "Section_id": "AttrNodeClustering"
    },
    {
        "Field List > Methods > conductance": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.conductance()"
            ],
            "References": [],
            "Description": "Fraction of total edge volume that points outside the algorithms.\n\n\\[f(S) = \\frac{c_S}{2 m_S+c_S}\\]\nwhere \\(c_S\\) is the number of algorithms nodes and, \\(m_S\\) is the number of algorithms edges\n"
        },
        "Section_id": "AttrNodeClustering"
    },
    {
        "Field List > Methods > cut_ratio": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.cut_ratio()"
            ],
            "References": [],
            "Description": "Fraction of existing edges (out of all possible edges) leaving the algorithms.\n..math:: f(S) = frac{c_S}{n_S (n \u2212 n_S)}\nwhere \\(c_S\\) is the number of algorithms nodes and, \\(n_S\\) is the number of edges on the algorithms boundary\n"
        },
        "Section_id": "AttrNodeClustering"
    },
    {
        "Field List > Methods > edges_inside": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.edges_inside()"
            ],
            "References": [],
            "Description": "Number of edges internal to the algorithms.\n"
        },
        "Section_id": "AttrNodeClustering"
    },
    {
        "Field List > Methods > erdos_renyi_modularity": {
            "Paramters": {},
            "Return": [
                "the Erdos-Renyi modularity score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.erdos_renyi_modularity()"
            ],
            "References": [],
            "Description": "Erdos-Renyi modularity is a variation of the Newman-Girvan one.\nIt assumes that vertices in a network are connected randomly with a constant probability \\(p\\).\n\n\\[Q(S) = \\frac{1}{m}\\sum_{c \\in S} (m_S \u2212 \\frac{mn_S(n_S \u22121)}{n(n\u22121)})\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms edges, \\(l_S\\) is the number of edges from nodes in S to nodes outside S.\n"
        },
        "Section_id": "AttrNodeClustering"
    },
    {
        "Field List > Methods > expansion": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.expansion()"
            ],
            "References": [],
            "Description": "Number of edges per algorithms node that point outside the cluster.\n\n\\[f(S) = \\frac{c_S}{n_S}\\]\nwhere \\(n_S\\) is the number of edges on the algorithms boundary, \\(c_S\\) is the number of algorithms nodes.\n"
        },
        "Section_id": "AttrNodeClustering"
    },
    {
        "Field List > Methods > f1": {
            "Paramters": {
                "clustering": "NodeClustering object"
            },
            "Return": [
                "F1 score (harmonic mean of precision and recall)"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.f1(leiden_communities)"
            ],
            "References": [
                "Rossetti, G., Pappalardo, L., & Rinzivillo, S. (2016). A novel approach to evaluate algorithms detection internal on ground truth. In Complex Networks VII (pp. 133-144). Springer, Cham."
            ],
            "Description": "Compute the average F1 score of the optimal algorithms matches among the partitions in input.\nWorks on overlapping/non-overlapping complete/partial coverage partitions.\n"
        },
        "Section_id": "AttrNodeClustering"
    },
    {
        "Field List > Methods > flake_odf": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.flake_odf()"
            ],
            "References": [],
            "Description": "Fraction of nodes in S that have fewer edges pointing inside than to the outside of the algorithms.\n\n\\[f(S) = \\frac{| \\{ u:u \\in S,| \\{(u,v) \\in E: v \\in S \\}| < d(u)/2 \\}|}{n_S}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\), \\(d(u)\\) is the degree of \\(u\\) and \\(n_S\\) is the set of algorithms nodes.\n"
        },
        "Section_id": "AttrNodeClustering"
    },
    {
        "Field List > Methods > fraction_over_median_degree": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.fraction_over_median_degree()"
            ],
            "References": [],
            "Description": "Fraction of algorithms nodes of having internal degree higher than the median degree value.\n\n\\[f(S) = \\frac{|\\{u: u \\in S,| \\{(u,v): v \\in S\\}| > d_m\\}| }{n_S}\\]\nwhere \\(d_m\\) is the internal degree median value\n"
        },
        "Section_id": "AttrNodeClustering"
    },
    {
        "Field List > Methods > get_description": {
            "Paramters": {
                "parameters_to_display": "parameters to display. By default, all float parameters.",
                "precision": "precision used to plot parameters. default: 3"
            },
            "Return": [
                "a string description of the method.\n"
            ],
            "Example": [],
            "References": [],
            "Description": "Return a description of the clustering, with the name of the method and its numeric parameters.\n"
        },
        "Section_id": "AttrNodeClustering"
    },
    {
        "Field List > Methods > hub_dominance": {
            "Paramters": {
                "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
            },
            "Return": [
                "If summary==True a FitnessResult object, otherwise a list of floats."
            ],
            "Example": [],
            "References": [],
            "Description": "Hub dominance.\nThe hub dominance of a community is defined as the ratio of the degree of its most connected node w.r.t. the theoretically maximal degree within the community.\n"
        },
        "Section_id": "AttrNodeClustering"
    },
    {
        "Field List > Methods > internal_edge_density": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.internal_edge_density()"
            ],
            "References": [],
            "Description": "The internal density of the algorithms set.\n\n\\[f(S) = \\frac{m_S}{n_S(n_S\u22121)/2}\\]\nwhere \\(m_S\\) is the number of algorithms internal edges and \\(n_S\\) is the number of algorithms nodes.\n"
        },
        "Section_id": "AttrNodeClustering"
    },
    {
        "Field List > Methods > link_modularity": {
            "Paramters": {},
            "Return": [
                "the link modularity score"
            ],
            "Example": [
                "from cdlib import evaluation\nfrom cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.link_modularity()"
            ],
            "References": [],
            "Description": "Quality function designed for directed graphs with overlapping communities.\n"
        },
        "Section_id": "AttrNodeClustering"
    },
    {
        "Field List > Methods > max_odf": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.max_odf()"
            ],
            "References": [],
            "Description": "Maximum fraction of edges of a node of a algorithms that point outside the algorithms itself.\n\n\\[max_{u \\in S} \\frac{|\\{(u,v)\\in E: v \\not\\in S\\}|}{d(u)}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\) and \\(d(u)\\) is the degree of \\(u\\)\n"
        },
        "Section_id": "AttrNodeClustering"
    },
    {
        "Field List > Methods > modularity_density": {
            "Paramters": {},
            "Return": [
                "the modularity density score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.modularity_density()"
            ],
            "References": [],
            "Description": "The modularity density is one of several propositions that envisioned to palliate the resolution limit issue of modularity based measures.\nThe idea of this metric is to include the information about algorithms size into the expected density of algorithms to avoid the negligence of small and dense communities.\nFor each algorithms \\(C\\) in partition \\(S\\), it uses the average modularity degree calculated by \\(d(C) = d^{int(C)} \u2212 d^{ext(C)}\\) where \\(d^{int(C)}\\) and \\(d^{ext(C)}\\) are the average internal and external degrees of \\(C\\) respectively to evaluate the fitness of \\(C\\) in its network.\nFinally, the modularity density can be calculated as follows:\n\n\\[Q(S) = \\sum_{C \\in S} \\frac{1}{n_C} ( \\sum_{i \\in C} k^{int}_{iC} - \\sum_{i \\in C} k^{out}_{iC})\\]\nwhere \\(n_C\\) is the number of nodes in C, \\(k^{int}_{iC}\\) is the degree of node i within \\(C\\) and \\(k^{out}_{iC}\\) is the deree of node i outside \\(C\\).\n"
        },
        "Section_id": "AttrNodeClustering"
    },
    {
        "Field List > Methods > modularity_overlap": {
            "Paramters": {
                "weight": "label identifying the edge weight parameter name (if present), default None"
            },
            "Return": [
                "FitnessResult object"
            ],
            "Example": [],
            "References": [
                "\nLazar, D. Abel and T. Vicsek, \u201cModularity measure of networks with overlapping communities\u201d  EPL, 90 (2010) 18001 doi: 10.1209/0295-5075/90/18001\n\n",
                "Lazar, D. Abel and T. Vicsek, \u201cModularity measure of networks with overlapping communities\u201d  EPL, 90 (2010) 18001 doi: 10.1209/0295-5075/90/18001"
            ],
            "Description": "Determines the Overlapping Modularity of a partition C on a graph G.\nOverlapping Modularity is defined as\n\n\\[M_{c_{r}}^{ov} = \\sum_{i \\in c_{r}} \\frac{\\sum_{j \\in c_{r}, i \\neq j}a_{ij} - \\sum_{j \\not \\in c_{r}}a_{ij}}{d_{i} \\cdot s_{i}} \\cdot \\frac{n_{c_{r}}^{e}}{n_{c_{r}} \\cdot \\binom{n_{c_{r}}}{2}}\\]\n"
        },
        "Section_id": "AttrNodeClustering"
    },
    {
        "Field List > Methods > newman_girvan_modularity": {
            "Paramters": {},
            "Return": [
                "the Newman-Girvan modularity score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.newman_girvan_modularity()"
            ],
            "References": [],
            "Description": "Difference the fraction of intra algorithms edges of a partition with the expected number of such edges if distributed according to a null model.\nIn the standard version of modularity, the null model preserves the expected degree sequence of the graph under consideration. In other words, the modularity compares the real network structure with a corresponding one where nodes are connected without any preference about their neighbors.\n\n\\[Q(S) = \\frac{1}{m}\\sum_{c \\in S}(m_S - \\frac{(2 m_S + l_S)^2}{4m})\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms edges, \\(l_S\\) is the number of edges from nodes in S to nodes outside S.\n"
        },
        "Section_id": "AttrNodeClustering"
    },
    {
        "Field List > Methods > nf1": {
            "Paramters": {
                "clustering": "NodeClustering object"
            },
            "Return": [
                "MatchingResult instance"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.nf1(leiden_communities)"
            ],
            "References": [
                "Rossetti, G., Pappalardo, L., & Rinzivillo, S. (2016). A novel approach to evaluate algorithms detection internal on ground truth.",
                "Rossetti, G. (2017). : RDyn: graph benchmark handling algorithms dynamics. Journal of Complex Networks. 5(6), 893-912."
            ],
            "Description": "Compute the Normalized F1 score of the optimal algorithms matches among the partitions in input.\nWorks on overlapping/non-overlapping complete/partial coverage partitions.\n"
        },
        "Section_id": "AttrNodeClustering"
    },
    {
        "Field List > Methods > normalized_cut": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.normalized_cut()"
            ],
            "References": [],
            "Description": "Normalized variant of the Cut-Ratio\n\n\\[: f(S) = \\frac{c_S}{2m_S+c_S} + \\frac{c_S}{2(m\u2212m_S )+c_S}\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms internal edges and \\(c_S\\) is the number of algorithms nodes.\n"
        },
        "Section_id": "AttrNodeClustering"
    },
    {
        "Field List > Methods > normalized_mutual_information": {
            "Paramters": {
                "clustering": "NodeClustering object"
            },
            "Return": [
                "normalized mutual information score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.normalized_mutual_information(leiden_communities)"
            ],
            "References": [],
            "Description": "Normalized Mutual Information between two clusterings.\nNormalized Mutual Information (NMI) is an normalization of the Mutual\nInformation (MI) score to scale the results between 0 (no mutual\ninformation) and 1 (perfect correlation). In this function, mutual\ninformation is normalized by sqrt(H(labels_true) * H(labels_pred))\n"
        },
        "Section_id": "AttrNodeClustering"
    },
    {
        "Field List > Methods > omega": {
            "Paramters": {
                "clustering": "NodeClustering object"
            },
            "Return": [
                "omega index"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.omega(leiden_communities)"
            ],
            "References": [
                "Gabriel Murray, Giuseppe Carenini, and Raymond Ng. 2012. Using the omega index for evaluating abstractive algorithms detection. In Proceedings of Workshop on Evaluation Metrics and System Comparison for Automatic Summarization. Association for Computational Linguistics, Stroudsburg, PA, USA, 10-18."
            ],
            "Description": "Index of resemblance for overlapping, complete coverage, network clusterings.\n"
        },
        "Section_id": "AttrNodeClustering"
    },
    {
        "Field List > Methods > overlapping_normalized_mutual_information_LFK": {
            "Paramters": {
                "clustering": "NodeClustering object"
            },
            "Return": [
                "onmi score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.overlapping_normalized_mutual_information_LFK(leiden_communities)"
            ],
            "References": [
                "Lancichinetti, A., Fortunato, S., & Kertesz, J. (2009). Detecting the overlapping and hierarchical community structure in complex networks. New Journal of Physics, 11(3), 033015."
            ],
            "Description": "Overlapping Normalized Mutual Information between two clusterings.\nExtension of the Normalized Mutual Information (NMI) score to cope with overlapping partitions.\nThis is the version proposed by Lancichinetti et al.\n"
        },
        "Section_id": "AttrNodeClustering"
    },
    {
        "Field List > Methods > overlapping_normalized_mutual_information_MGH": {
            "Paramters": {
                "clustering": "NodeClustering object",
                "normalization": "one of \u201cmax\u201d or \u201cLFK\u201d. Default \u201cmax\u201d (corresponds to the main method described in the article)"
            },
            "Return": [
                "onmi score\n"
            ],
            "Example": [
                "from cdlib import evaluation, algorithms\ng = nx.karate_club_graph()\nlouvain_communities = algorithms.louvain(g)\nleiden_communities = algorithms.leiden(g)\nevaluation.overlapping_normalized_mutual_information_MGH(louvain_communities,leiden_communities)"
            ],
            "References": [
                "McDaid, A. F., Greene, D., & Hurley, N. (2011). Normalized mutual information to evaluate overlapping community finding algorithms. arXiv preprint arXiv:1110.2515. Chicago"
            ],
            "Description": "Overlapping Normalized Mutual Information between two clusterings.\nExtension of the Normalized Mutual Information (NMI) score to cope with overlapping partitions.\nThis is the version proposed by McDaid et al. using a different normalization than the original LFR one. See ref.\nfor more details.\n"
        },
        "Section_id": "AttrNodeClustering"
    },
    {
        "Field List > Methods > scaled_density": {
            "Paramters": {
                "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
            },
            "Return": [
                "If summary==True a FitnessResult object, otherwise a list of floats."
            ],
            "Example": [],
            "References": [],
            "Description": "Scaled density.\nThe scaled density of a community is defined as the ratio of the community density w.r.t. the complete graph density.\n"
        },
        "Section_id": "AttrNodeClustering"
    },
    {
        "Field List > Methods > significance": {
            "Paramters": {},
            "Return": [
                "the significance score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.significance()"
            ],
            "References": [],
            "Description": "Significance estimates how likely a partition of dense communities appear in a random graph.\n"
        },
        "Section_id": "AttrNodeClustering"
    },
    {
        "Field List > Methods > size": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [],
            "References": [],
            "Description": "Size is the number of nodes in the community\n"
        },
        "Section_id": "AttrNodeClustering"
    },
    {
        "Field List > Methods > surprise": {
            "Paramters": {},
            "Return": [
                "the surprise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.surprise()"
            ],
            "References": [],
            "Description": "Surprise is statistical approach proposes a quality metric assuming that edges between vertices emerge randomly according to a hyper-geometric distribution.\nAccording to the Surprise metric, the higher the score of a partition, the less likely it is resulted from a random realization, the better the quality of the algorithms structure.\n"
        },
        "Section_id": "AttrNodeClustering"
    },
    {
        "Field List > Methods > to_json": {
            "Paramters": {},
            "Return": [
                "a JSON formatted string representing the object"
            ],
            "Example": [],
            "References": [],
            "Description": "Generate a JSON representation of the algorithms object\n"
        },
        "Section_id": "AttrNodeClustering"
    },
    {
        "Field List > Methods > to_node_community_map": {
            "Paramters": {},
            "Return": [
                "dict of the form <node, list(communities)>"
            ],
            "Example": [],
            "References": [],
            "Description": "Generate a <node, list(communities)> representation of the current clustering\n"
        },
        "Section_id": "AttrNodeClustering"
    },
    {
        "Field List > Methods > triangle_participation_ratio": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.triangle_participation_ratio()"
            ],
            "References": [],
            "Description": "Fraction of algorithms nodes that belong to a triad.\n\n\\[f(S) = \\frac{ | \\{ u: u \\in S,\\{(v,w):v, w \\in S,(u,v) \\in E,(u,w) \\in E,(v,w) \\in E \\} \\not = \\emptyset \\} |}{n_S}\\]\nwhere \\(n_S\\) is the set of algorithms nodes.\n"
        },
        "Section_id": "AttrNodeClustering"
    },
    {
        "Field List > Methods > variation_of_information": {
            "Paramters": {
                "clustering": "NodeClustering object"
            },
            "Return": [
                "VI score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.variation_of_information(leiden_communities)"
            ],
            "References": [
                "Meila, M. (2007). Comparing clusterings - an information based distance. Journal of Multivariate Analysis, 98, 873-895. doi:10.1016/j.jmva.2006.11.013"
            ],
            "Description": "Variation of Information among two nodes partitions.\n$$ H(p)+H(q)-2MI(p, q) $$\nwhere MI is the mutual information, H the partition entropy and p,q are the algorithms sets\n"
        },
        "Section_id": "AttrNodeClustering"
    },
    {
        "Field List > Methods > z_modularity": {
            "Paramters": {},
            "Return": [
                "the z-modularity score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.z_modularity()"
            ],
            "References": [],
            "Description": "Z-modularity is another variant of the standard modularity proposed to avoid the resolution limit.\nThe concept of this version is based on an observation that the difference between the fraction of edges inside communities and the expected number of such edges in a null model should not be considered as the only contribution to the final quality of algorithms structure.\n"
        },
        "Section_id": "AttrNodeClustering"
    },
    {
        "Section_id": "MatchingResult",
        "Description": "Initialize self.  See help(type(self)) for accurate signature."
    },
    {
        "Field List > Parameters": {},
        "Section_id": "MatchingResult"
    },
    {
        "Section_id": "expansion",
        "Description": "Number of edges per community node that point outside the cluster.\n\n\\[f(S) = \\frac{c_S}{n_S}\\]\nwhere \\(c_S\\) is the number of edges on the community boundary, \\(n_S\\) is the number of community nodes.\n"
    },
    {
        "Parameters": {
            "graph": "a networkx/igraph object",
            "community": "NodeClustering object",
            "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
        },
        "Section_id": "expansion"
    },
    {
        "Section_id": "expansion",
        "Return": [
            "If summary==True a FitnessResult object, otherwise a list of floats.\n"
        ]
    },
    {
        "Section_id": "expansion",
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = evaluation.expansion(g,communities)"
        ]
    },
    {
        "Section_id": "expansion",
        "References": [
            "Radicchi, F., Castellano, C., Cecconi, F., Loreto, V., & Parisi, D. (2004). Defining and identifying communities in networks. Proceedings of the National Academy of Sciences, 101(9), 2658-2663."
        ]
    },
    {
        "Section_id": "walktrap",
        "Description": "walktrap is an approach based on random walks.\nThe general idea is that if you perform random walks on the graph, then the walks are more likely to stay within the same community because there are only a few edges that lead outside a given community. Walktrap runs short random walks and uses the results of these random walks to merge separate communities in a bottom-up manner.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object"
        },
        "Section_id": "walktrap"
    },
    {
        "Section_id": "walktrap",
        "Return": [
            "NodeClusterint object"
        ]
    },
    {
        "Section_id": "walktrap",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.walktrap(G)"
        ]
    },
    {
        "Section_id": "avg_odf",
        "Description": "Average fraction of edges of a node of a community that point outside the community itself.\n\n\\[\\frac{1}{n_S} \\sum_{u \\in S} \\frac{|\\{(u,v)\\in E: v \\not\\in S\\}|}{d(u)}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\), \\(d(u)\\) is the degree of \\(u\\) and \\(n_S\\) is the set of community nodes.\n"
    },
    {
        "Parameters": {
            "graph": "a networkx/igraph object",
            "community": "NodeClustering object",
            "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
        },
        "Section_id": "avg_odf"
    },
    {
        "Section_id": "avg_odf",
        "Return": [
            "If summary==True a FitnessResult object, otherwise a list of floats.\n"
        ]
    },
    {
        "Section_id": "avg_odf",
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = evaluation.avg_odf(g,communities)"
        ]
    },
    {
        "Section_id": "avg_odf",
        "References": [
            "Flake, G.W., Lawrence, S., Giles, C.L., et al.: Efficient identification of web communities. In: KDD, vol. 2000, pp. 150\u2013160 (2000)"
        ]
    },
    {
        "Section_id": "pool_grid_filter",
        "Description": "Execute a pool of community discovery internal on the input graph.\nReturns the optimal partition for each algorithm given the specified quality function.\n"
    },
    {
        "Parameters": {
            "methods": "list community discovery methods (from nclib.community)",
            "graph": "networkx/igraph object",
            "configurations": "list of lists (one for each method) of Parameter and BoolParameter objects",
            "quality_score": "a fitness function to evaluate the obtained partition (from nclib.evaluation)",
            "aggregate": "function to select the best fitness value. Possible values: min/max"
        },
        "Section_id": "pool_grid_filter"
    },
    {
        "Section_id": "pool_grid_filter",
        "Return": [
            "at each call the generator yields a tuple composed by: the actual method, its optimal configuration; the obtained communities; the fitness score.\n"
        ]
    },
    {
        "Section_id": "pool_grid_filter",
        "Example": [
            "import networkx as nx\nfrom cdlib import algorithms, ensemble\ng = nx.karate_club_graph()\n# Louvain\nresolution = ensemble.Parameter(name=\"resolution\", start=0.1, end=1, step=0.1)\nrandomize = ensemble.BoolParameter(name=\"randomize\")\nlouvain_conf = [resolution, randomize]\n# Angel\nthreshold = ensemble.Parameter(name=\"threshold\", start=0.1, end=1, step=0.1)\nangel_conf = [threshold]\nmethods = [algorithms.louvain, algorithms.angel]\nfor communities, scoring in ensemble.pool_grid_filter(g, methods, [louvain_conf, angel_conf], quality_score=evaluation.erdos_renyi_modularity, aggregate=max):\n    print(communities, scoring)"
        ]
    },
    {
        "Section_id": "EdgeClustering",
        "Description": "Edge Clustering representation."
    },
    {
        "Field List > Parameters": {
            "communities": "list of communities",
            "graph": "a networkx/igraph object",
            "method_name": "community discovery algorithm name",
            "method_parameters": "configuration for the community discovery algorithm used",
            "overlap": "boolean, whether the partition is overlapping or not"
        },
        "Section_id": "EdgeClustering"
    },
    {
        "Field List > Methods > get_description": {
            "Paramters": {
                "parameters_to_display": "parameters to display. By default, all float parameters.",
                "precision": "precision used to plot parameters. default: 3"
            },
            "Return": [
                "a string description of the method.\n"
            ],
            "Example": [],
            "References": [],
            "Description": "Return a description of the clustering, with the name of the method and its numeric parameters.\n"
        },
        "Section_id": "EdgeClustering"
    },
    {
        "Field List > Methods > to_edge_community_map": {
            "Paramters": {},
            "Return": [
                "dict of the form <edge, list(communities)>"
            ],
            "Example": [],
            "References": [],
            "Description": "Generate a <edge, list(communities)> representation of the current clustering\n"
        },
        "Section_id": "EdgeClustering"
    },
    {
        "Field List > Methods > to_json": {
            "Paramters": {},
            "Return": [
                "a JSON formatted string representing the object"
            ],
            "Example": [],
            "References": [],
            "Description": "Generate a JSON representation of the algorithms object\n"
        },
        "Section_id": "EdgeClustering"
    },
    {
        "Section_id": "async_fluid",
        "Description": "Fluid Communities (FluidC) is based on the simple idea of fluids (i.e., communities) interacting in an environment (i.e., a non-complete graph), expanding and contracting.\nIt is propagation-based algorithm and it allows to specify the number of desired communities (k) and it is asynchronous, where each vertex update is computed using the latest partial state of the graph.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "k": "Number of communities to search"
        },
        "Section_id": "async_fluid"
    },
    {
        "Section_id": "async_fluid",
        "Return": [
            "EdgeClustering object\n"
        ]
    },
    {
        "Section_id": "async_fluid",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.async_fluid(G,k=2)"
        ]
    },
    {
        "Section_id": "em",
        "Description": "EM is based on based on a mixture model.\nThe algorithm uses the expectation\u2013maximization algorithm to detect structure in networks.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "k": "the number of desired communities"
        },
        "Section_id": "em"
    },
    {
        "Section_id": "em",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "em",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncom = algorithms.em(G, k=3)"
        ]
    },
    {
        "Section_id": "scaled_density",
        "Description": "Scaled density.\nThe scaled density of a community is defined as the ratio of the community density w.r.t. the complete graph density.\n"
    },
    {
        "Parameters": {
            "graph": "a networkx/igraph object",
            "communities": "NodeClustering object",
            "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
        },
        "Section_id": "scaled_density"
    },
    {
        "Section_id": "scaled_density",
        "Return": [
            "If summary==True a FitnessResult object, otherwise a list of floats.\n"
        ]
    },
    {
        "Section_id": "scaled_density",
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nscd = evaluation.scaled_density(g,communities)"
        ]
    },
    {
        "Section_id": "grid_execution",
        "Description": "Instantiate the specified community discovery method performing a grid search on the parameter set.\n"
    },
    {
        "Parameters": {
            "method": "community discovery method (from nclib.community)",
            "graph": "networkx/igraph object",
            "parameters": "list of Parameter and BoolParameter objects"
        },
        "Section_id": "grid_execution"
    },
    {
        "Section_id": "grid_execution",
        "Return": [
            "at each call the generator yields a tuple composed by the current configuration and the obtained communities\n"
        ]
    },
    {
        "Section_id": "grid_execution",
        "Example": [
            "import networkx as nx\nfrom cdlib import algorithms, ensemble\ng = nx.karate_club_graph()\nresolution = ensemble.Parameter(name=\"resolution\", start=0.1, end=1, step=0.1)\nfor communities in ensemble.grid_execution(graph=g, method=algorithms.louvain, parameters=[resolution]):\n    print(communities)"
        ]
    },
    {
        "Section_id": "surprise_communities",
        "Description": "Surprise_communities is a model where the quality function to optimize is:\n\n\\[Q = m D(q \\parallel \\langle q \\rangle)\\]\nwhere \\(m\\) is the number of edges,  \\(q = \\frac{\\sum_c m_c}{m}\\),  is the fraction of internal edges, \\(\\langle q \\rangle = \\frac{\\sum_c \\binom{n_c}{2}}{\\binom{n}{2}}\\) is the expected fraction of internal edges, and finally\n\\(D(x \\parallel y) = x \\ln \\frac{x}{y} + (1 - x) \\ln \\frac{1 - x}{1 - y}\\)  is the binary Kullback-Leibler divergence.\nFor directed graphs we can multiplying the binomials by 2, and this leaves \\(\\langle q \\rangle\\) unchanged, so that we can simply use the same\nformulation.  For weighted graphs we can simply count the total internal weight instead of the total number of edges for \\(q\\) , while \\(\\langle q \\rangle\\) remains unchanged.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "initial_membership": "list of int Initial membership for the partition. IfNonethen defaults to a singleton partition. Deafault None",
            "weights": "list of double, or edge attribute Weights of edges. Can be either an iterable or an edge attribute. Deafault None",
            "node_sizes": "list of int, or vertex attribute Sizes of nodes are necessary to know the size of communities in aggregate graphs. Usually this is set to 1 for all nodes, but in specific cases  this could be changed. Deafault None"
        },
        "Section_id": "surprise_communities"
    },
    {
        "Section_id": "surprise_communities",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "surprise_communities",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.surprise_communities(G)"
        ]
    },
    {
        "Section_id": "internal_edge_density",
        "Description": "The internal density of the community set.\n"
    },
    {
        "Parameters": {
            "graph": "a networkx/igraph object",
            "community": "NodeClustering object",
            "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
        },
        "Section_id": "internal_edge_density"
    },
    {
        "Section_id": "internal_edge_density",
        "Return": [
            "If summary==True a FitnessResult object, otherwise a list of floats.\n"
        ]
    },
    {
        "Section_id": "internal_edge_density",
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = evaluation.internal_edge_density(g,communities)"
        ]
    },
    {
        "Section_id": "internal_edge_density",
        "References": [
            "Radicchi, F., Castellano, C., Cecconi, F., Loreto, V., & Parisi, D. (2004). Defining and identifying communities in networks. Proceedings of the National Academy of Sciences, 101(9), 2658-2663."
        ]
    },
    {
        "Section_id": "spinglass",
        "Description": "Spinglass relies on an analogy between a very popular statistical mechanic model called Potts spin glass, and the community structure.\nIt applies the simulated annealing optimization technique on this model to optimize the modularity.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "spins": "the number of spins to use. This is the upper limit for the number of communities. It is not a problem to supply a (reasonably) big number here, in which case some spin states will be unpopulated."
        },
        "Section_id": "spinglass"
    },
    {
        "Section_id": "spinglass",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "spinglass",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncom = algorithms.spinglass(G)"
        ]
    },
    {
        "Section_id": "lpam",
        "Description": "Link Partitioning Around Medoids\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "k": "number of clusters",
            "threshold": "merging threshold in [0,1], default 0.5",
            "distance": "type of distance: \u201camp\u201d - amplified commute distance, or \u201ccm\u201d - commute distance, or distance matrix between all edges as np ndarray",
            "seed": "random seed for k-medoid heuristic"
        },
        "Section_id": "lpam"
    },
    {
        "Section_id": "lpam",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "lpam",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.lpam(G, k=2, threshold=0.4, distance = \"amp\")"
        ]
    },
    {
        "Section_id": "slpa",
        "Description": "SLPA is an overlapping community discovery that extends tha LPA.\nSLPA consists of the following three stages:\n1) the initialization\n2) the evolution\n3) the post-processing\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "t": "maximum number of iterations, default 20",
            "r": "threshold  \u2208 [0, 1]. It is used in the post-processing stage: if the probability of seeing a particular label during the whole process is less than r, this label is deleted from a node\u2019s memory. Default 0.1"
        },
        "Section_id": "slpa"
    },
    {
        "Section_id": "slpa",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "slpa",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.slpa(G,  t=21, r=0.1)"
        ]
    },
    {
        "Section_id": "lpanni",
        "Description": "LPANNI (Label Propagation Algorithm with Neighbor Node Influence) detects overlapping community structures by adopting fixed label propagation sequence based on the ascending order of node importance and label update strategy based on neighbor node influence and historical label preferred strategy.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "threshold": "Default 0.0001"
        },
        "Section_id": "lpanni"
    },
    {
        "Section_id": "lpanni",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.lpanni(G)"
        ]
    },
    {
        "Section_id": "adjusted_rand_index",
        "Description": "Rand index adjusted for chance.\nThe Rand Index computes a similarity measure between two clusterings\nby considering all pairs of samples and counting pairs that are\nassigned in the same or different clusters in the predicted and\ntrue clusterings.\nThe raw RI score is then \u201cadjusted for chance\u201d into the ARI score\nusing the following scheme:\nARI = (RI - Expected_RI) / (max(RI) - Expected_RI)\n\nThe adjusted Rand index is thus ensured to have a value close to\n0.0 for random labeling independently of the number of clusters and\nsamples and exactly 1.0 when the clusterings are identical (up to\na permutation).\nARI is a symmetric measure:\nadjusted_rand_index(a, b) == adjusted_rand_index(b, a)\n\n"
    },
    {
        "Parameters": {
            "first_partition": "NodeClustering object",
            "second_partition": "NodeClustering object"
        },
        "Section_id": "adjusted_rand_index"
    },
    {
        "Section_id": "adjusted_rand_index",
        "Return": [
            "MatchingResult object\n"
        ]
    },
    {
        "Section_id": "adjusted_rand_index",
        "Example": [
            "from cdlib import evaluation, algorithms\ng = nx.karate_club_graph()\nlouvain_communities = algorithms.louvain(g)\nleiden_communities = algorithms.leiden(g)\nevaluation.adjusted_rand_index(louvain_communities,leiden_communities)"
        ]
    },
    {
        "Section_id": "adjusted_rand_index",
        "References": [
            "Hubert, L., & Arabie, P. (1985). Comparing partitions. Journal of classification, 2(1), 193-218."
        ]
    },
    {
        "Section_id": "tiles",
        "Description": "TILES is designed to incrementally identify and update communities in stream graphs.\nThis implementation assume an explicit edge removal when pairwise interactions cease to exist.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "dg": "dynetx graph object",
            "obs": "community observation interval (default=1)"
        },
        "Section_id": "tiles"
    },
    {
        "Section_id": "tiles",
        "Return": [
            "TemporalClustering object\n"
        ]
    },
    {
        "Section_id": "tiles",
        "Example": [
            "from cdlib import algorithms\nimport dynetx as dn\ndg = dn.DynGraph()\nfor x in range(10):\n    g = nx.erdos_renyi_graph(200, 0.05)\n    dg.add_interactions_from(list(g.edges()), t=x)\ncoms = algorithms.tiles(dg, 2)"
        ]
    },
    {
        "Section_id": "significance_communities",
        "Description": "Significance_communities is a model where the quality function to optimize is:\n\n\\[Q = \\sum_c \\binom{n_c}{2} D(p_c \\parallel p)\\]\nwhere \\(n_c\\) is the number of nodes in community \\(c\\), \\(p_c = \\frac{m_c}{\\binom{n_c}{2}}\\), is the density of community \\(c\\),  \\(p = \\frac{m}{\\binom{n}{2}}\\)  is the overall density of the graph, and finally  \\(D(x \\parallel y) = x \\ln \\frac{x}{y} + (1 - x) \\ln \\frac{1 - x}{1 - y}\\) is the binary Kullback-Leibler divergence.\nFor directed graphs simply multiply the binomials by 2. The expected Significance in Erdos-Renyi graphs behaves roughly as \\(\\frac{1}{2} n \\ln n\\) for both directed and undirected graphs in this formulation.\n\nWarning\nThis method is not suitable for weighted graphs.\n\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "initial_membership": "list of int Initial membership for the partition. IfNonethen defaults to a singleton partition. Deafault None",
            "node_sizes": "list of int, or vertex attribute Sizes of nodes are necessary to know the size of communities in aggregate graphs. Usually this is set to 1 for all nodes, but in specific cases  this could be changed. Deafault None"
        },
        "Section_id": "significance_communities"
    },
    {
        "Section_id": "significance_communities",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "significance_communities",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.significance_communities(G)"
        ]
    },
    {
        "Section_id": "average_internal_degree",
        "Description": "The average internal degree of the community set.\n\n\\[ \\begin{align}\\begin{aligned}f(S) = \\frac{2m_S}{n_S}\\\\where :math:`m_S` is the number of community internal edges and :math:`n_S` is the number of community nodes.\\end{aligned}\\end{align} \\]\n"
    },
    {
        "Parameters": {
            "graph": "a networkx/igraph object",
            "community": "NodeClustering object",
            "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
        },
        "Section_id": "average_internal_degree"
    },
    {
        "Section_id": "average_internal_degree",
        "Return": [
            "If summary==True a FitnessResult object, otherwise a list of floats.\n"
        ]
    },
    {
        "Section_id": "average_internal_degree",
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = evaluation.average_internal_degree(g,communities)"
        ]
    },
    {
        "Section_id": "average_internal_degree",
        "References": [
            "Radicchi, F., Castellano, C., Cecconi, F., Loreto, V., & Parisi, D. (2004). Defining and identifying communities in networks. Proceedings of the National Academy of Sciences, 101(9), 2658-2663."
        ]
    },
    {
        "Section_id": "conductance",
        "Description": "Fraction of total edge volume that points outside the community.\n\n\\[f(S) = \\frac{c_S}{2 m_S+c_S}\\]\nwhere \\(c_S\\) is the number of community nodes and, \\(m_S\\) is the number of community edges\n"
    },
    {
        "Parameters": {
            "graph": "a networkx/igraph object",
            "community": "NodeClustering object",
            "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
        },
        "Section_id": "conductance"
    },
    {
        "Section_id": "conductance",
        "Return": [
            "If summary==True a FitnessResult object, otherwise a list of floats.\n"
        ]
    },
    {
        "Section_id": "conductance",
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = evaluation.conductance(g,communities)"
        ]
    },
    {
        "Section_id": "sbm_dl_nested",
        "Description": "Efficient Monte Carlo and greedy heuristic for the inference of stochastic block models. (nested)\nFit a nested non-overlapping stochastic block model (SBM) by minimizing its description length using an agglomerative heuristic.\nReturn the lowest level found. Currently cdlib do not support hierarchical clustering.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "igraph/networkx object"
        },
        "Section_id": "sbm_dl_nested"
    },
    {
        "Section_id": "sbm_dl_nested",
        "Return": [
            "NodeClustering object"
        ]
    },
    {
        "Section_id": "sbm_dl_nested",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.sbm_dl(G)"
        ]
    },
    {
        "Section_id": "bayan",
        "Description": "The Bayan algorithm is community detection method that is capable of providing a globally optimal solution to the modularity maximization problem.\nBayan can also be implemented such that it provides an approximation of the maximum modularity with a guarantee of proximity.\nThis algorithm is theoretically grounded by the Integer Programming (IP) formulation of the modularity maximization problem and relies on an exact branch-and-cut scheme for solving the NP-complete optimization problem to global optimality.\nThe algorithm is integrated as an optional feature in CDlib due to its dependency on the Gurobi solver.\nFor a detailed description on how to satisfy such a dependency please refer to the instructions provided in the official documentation: https://github.com/saref/bayan\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "threshold": "Threshold is the minimum optimality gap that Bayan should execute till. In the above example if Bayan finds a solution with modularity within 0.001 of the optimal solution, it will return that solution.",
            "time_allowed": "Time allowed is the maximum time in seconds that Bayan should execute for.",
            "resolution": "Resolution is the resolution parameter of the modularity function."
        },
        "Section_id": "bayan"
    },
    {
        "Section_id": "bayan",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "bayan",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncom = algorithms.bayan(G)"
        ]
    },
    {
        "Section_id": "coach",
        "Description": "The motivation behind the core-attachment (CoAch) algorithm  comes from the observation that protein complexes often have a dense core of highly interactive proteins.\nCoAch works in two steps, \ufb01rst discovering highly connected regions (\u201cpreliminary cores\u201d) of a network and then expanding these regions by adding strongly associated neighbors.\nThe algorithm operates with three user-speci\ufb01ed parameters: minimum core density (for preliminary cores), maximum core affinity (similarity threshold for distinct preliminary cores), and minimum neighbor closeness (for attaching non-core neighbors to preliminary cores).\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "density_threshold": "minimum core density. Default, 0.7",
            "affinity_threshold": "maximum core affinity. Default, 0.225",
            "closeness_threshold": "minimum neighbor closeness. Default, 0.5"
        },
        "Section_id": "coach"
    },
    {
        "Section_id": "coach",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "coach",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.coach(G)"
        ]
    },
    {
        "Section_id": "markov_clustering",
        "Description": "The Markov clustering algorithm (MCL) is based on simulation of (stochastic) flow in graphs.\nThe MCL algorithm finds cluster structure in graphs by a mathematical bootstrapping procedure. The process deterministically computes (the probabilities of) random walks through the graph, and uses two operators transforming one set of probabilities into another. It does so using the language of stochastic matrices (also called Markov matrices) which capture the mathematical concept of random walks on a graph.\nThe MCL algorithm simulates random walks within a graph by alternation of two operators called expansion and inflation.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "expansion": "The cluster expansion factor",
            "inflation": "The cluster inflation factor",
            "loop_value": "Initialization value for self-loops",
            "iterations": "Maximum number of iterations\n(actual number of iterations will be less if convergence is reached)",
            "pruning_threshold": "Threshold below which matrix elements will be set set to 0",
            "pruning_frequency": "Perform pruning every \u2018pruning_frequency\u2019\niterations.",
            "convergence_check_frequency": "Perform the check for convergence\nevery convergence_check_frequency iterations"
        },
        "Section_id": "markov_clustering"
    },
    {
        "Section_id": "markov_clustering",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "markov_clustering",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.markov_clustering(G)"
        ]
    },
    {
        "Section_id": "read_community_json",
        "Description": "Read community list from JSON file.\n"
    },
    {
        "Parameters": {
            "path": "input filename",
            "compress": "wheter the file is in a copress format, default False"
        },
        "Section_id": "read_community_json"
    },
    {
        "Section_id": "read_community_json",
        "Return": [
            "a Clustering object\n"
        ]
    },
    {
        "Section_id": "read_community_json",
        "Example": [
            "import networkx as nx\nfrom cdlib import algorithms, readwrite\ng = nx.karate_club_graph()\ncoms = algorithms.louvain(g)\nreadwrite.write_community_json(coms, \"communities.json\")\nreadwrite.read_community_json(coms, \"communities.json\")"
        ]
    },
    {
        "Section_id": "BiNodeClustering",
        "Description": "Bipartite Node Communities representation."
    },
    {
        "Field List > Parameters": {
            "left_communities": "list of left communities",
            "right_communities": "list of right communities",
            "graph": "a networkx/igraph object",
            "method_name": "community discovery algorithm name",
            "method_parameters": "configuration for the community discovery algorithm used",
            "overlap": "boolean, whether the partition is overlapping or not"
        },
        "Section_id": "BiNodeClustering"
    },
    {
        "Field List > Methods > adjusted_mutual_information": {
            "Paramters": {
                "clustering": "NodeClustering object"
            },
            "Return": [
                "AMI score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.adjusted_mutual_information(leiden_communities)"
            ],
            "References": [
                "Vinh, N. X., Epps, J., & Bailey, J. (2010). Information theoretic measures for clusterings comparison: Variants, properties, normalization and correction for chance. Journal of Machine Learning Research, 11(Oct), 2837-2854."
            ],
            "Description": "Adjusted Mutual Information between two clusterings.\nAdjusted Mutual Information (AMI) is an adjustment of the Mutual\nInformation (MI) score to account for chance. It accounts for the fact that\nthe MI is generally higher for two clusterings with a larger number of\nclusters, regardless of whether there is actually more information shared.\nFor two clusterings \\(U\\) and \\(V\\), the AMI is given as:\nAMI(U, V) = [MI(U, V) - E(MI(U, V))] / [max(H(U), H(V)) - E(MI(U, V))]\n\nThis metric is independent of the absolute values of the labels:\na permutation of the class or cluster label values won\u2019t change the\nscore value in any way.\nThis metric is furthermore symmetric: switching label_true with\nlabel_pred will return the same score value. This can be useful to\nmeasure the agreement of two independent label assignments strategies\non the same dataset when the real ground truth is not known.\nBe mindful that this function is an order of magnitude slower than other\nmetrics, such as the Adjusted Rand Index.\n"
        },
        "Section_id": "BiNodeClustering"
    },
    {
        "Field List > Methods > adjusted_rand_index": {
            "Paramters": {
                "clustering": "NodeClustering object"
            },
            "Return": [
                "ARI score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.adjusted_rand_index(leiden_communities)"
            ],
            "References": [
                "Hubert, L., & Arabie, P. (1985). Comparing partitions. Journal of classification, 2(1), 193-218."
            ],
            "Description": "Rand index adjusted for chance.\nThe Rand Index computes a similarity measure between two clusterings\nby considering all pairs of samples and counting pairs that are\nassigned in the same or different clusters in the predicted and\ntrue clusterings.\nThe raw RI score is then \u201cadjusted for chance\u201d into the ARI score\nusing the following scheme:\nARI = (RI - Expected_RI) / (max(RI) - Expected_RI)\n\nThe adjusted Rand index is thus ensured to have a value close to\n0.0 for random labeling independently of the number of clusters and\nsamples and exactly 1.0 when the clusterings are identical (up to\na permutation).\nARI is a symmetric measure:\nadjusted_rand_index(a, b) == adjusted_rand_index(b, a)\n\n"
        },
        "Section_id": "BiNodeClustering"
    },
    {
        "Field List > Methods > average_internal_degree": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.average_internal_degree()"
            ],
            "References": [],
            "Description": "The average internal degree of the algorithms set.\n\n\\[f(S) = \\frac{2m_S}{n_S}\\]\nwhere \\(m_S\\) is the number of algorithms internal edges and \\(n_S\\) is the number of algorithms nodes.\n"
        },
        "Section_id": "BiNodeClustering"
    },
    {
        "Field List > Methods > avg_distance": {
            "Paramters": {
                "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
            },
            "Return": [
                "If summary==True a FitnessResult object, otherwise a list of floats."
            ],
            "Example": [],
            "References": [],
            "Description": "Average distance.\nThe average distance of a community is defined average path length across all possible pair of nodes composing it.\n"
        },
        "Section_id": "BiNodeClustering"
    },
    {
        "Field List > Methods > avg_embeddedness": {
            "Paramters": {
                "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
            },
            "Return": [
                "If summary==True a FitnessResult object, otherwise a list of floats."
            ],
            "Example": [],
            "References": [],
            "Description": "Average embeddedness of nodes within the community.\nThe embeddedness of a node n w.r.t. a community C is the ratio of its degree within the community and its overall degree.\n\n\\[emb(n,C) = \\frac{k_n^C}{k_n}\\]\nThe average embeddedness of a community C is:\n\n\\[avg_embd(c) = \\frac{1}{|C|} \\sum_{i \\in C} \\frac{k_n^C}{k_n}\\]\n"
        },
        "Section_id": "BiNodeClustering"
    },
    {
        "Field List > Methods > avg_odf": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.avg_odf()"
            ],
            "References": [],
            "Description": "Average fraction of edges of a node of a algorithms that point outside the algorithms itself.\n\n\\[\\frac{1}{n_S} \\sum_{u \\in S} \\frac{|\\{(u,v)\\in E: v \\not\\in S\\}|}{d(u)}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\), \\(d(u)\\) is the degree of \\(u\\) and \\(n_S\\) is the set of algorithms nodes.\n"
        },
        "Section_id": "BiNodeClustering"
    },
    {
        "Field List > Methods > avg_transitivity": {
            "Paramters": {
                "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
            },
            "Return": [
                "If summary==True a FitnessResult object, otherwise a list of floats."
            ],
            "Example": [],
            "References": [],
            "Description": "Average transitivity.\nThe average transitivity of a community is defined the as the average clustering coefficient of its nodes w.r.t. their connection within the community itself.\n"
        },
        "Section_id": "BiNodeClustering"
    },
    {
        "Field List > Methods > conductance": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.conductance()"
            ],
            "References": [],
            "Description": "Fraction of total edge volume that points outside the algorithms.\n\n\\[f(S) = \\frac{c_S}{2 m_S+c_S}\\]\nwhere \\(c_S\\) is the number of algorithms nodes and, \\(m_S\\) is the number of algorithms edges\n"
        },
        "Section_id": "BiNodeClustering"
    },
    {
        "Field List > Methods > cut_ratio": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.cut_ratio()"
            ],
            "References": [],
            "Description": "Fraction of existing edges (out of all possible edges) leaving the algorithms.\n..math:: f(S) = frac{c_S}{n_S (n \u2212 n_S)}\nwhere \\(c_S\\) is the number of algorithms nodes and, \\(n_S\\) is the number of edges on the algorithms boundary\n"
        },
        "Section_id": "BiNodeClustering"
    },
    {
        "Field List > Methods > edges_inside": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.edges_inside()"
            ],
            "References": [],
            "Description": "Number of edges internal to the algorithms.\n"
        },
        "Section_id": "BiNodeClustering"
    },
    {
        "Field List > Methods > erdos_renyi_modularity": {
            "Paramters": {},
            "Return": [
                "the Erdos-Renyi modularity score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.erdos_renyi_modularity()"
            ],
            "References": [],
            "Description": "Erdos-Renyi modularity is a variation of the Newman-Girvan one.\nIt assumes that vertices in a network are connected randomly with a constant probability \\(p\\).\n\n\\[Q(S) = \\frac{1}{m}\\sum_{c \\in S} (m_S \u2212 \\frac{mn_S(n_S \u22121)}{n(n\u22121)})\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms edges, \\(l_S\\) is the number of edges from nodes in S to nodes outside S.\n"
        },
        "Section_id": "BiNodeClustering"
    },
    {
        "Field List > Methods > expansion": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.expansion()"
            ],
            "References": [],
            "Description": "Number of edges per algorithms node that point outside the cluster.\n\n\\[f(S) = \\frac{c_S}{n_S}\\]\nwhere \\(n_S\\) is the number of edges on the algorithms boundary, \\(c_S\\) is the number of algorithms nodes.\n"
        },
        "Section_id": "BiNodeClustering"
    },
    {
        "Field List > Methods > f1": {
            "Paramters": {
                "clustering": "NodeClustering object"
            },
            "Return": [
                "F1 score (harmonic mean of precision and recall)"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.f1(leiden_communities)"
            ],
            "References": [
                "Rossetti, G., Pappalardo, L., & Rinzivillo, S. (2016). A novel approach to evaluate algorithms detection internal on ground truth. In Complex Networks VII (pp. 133-144). Springer, Cham."
            ],
            "Description": "Compute the average F1 score of the optimal algorithms matches among the partitions in input.\nWorks on overlapping/non-overlapping complete/partial coverage partitions.\n"
        },
        "Section_id": "BiNodeClustering"
    },
    {
        "Field List > Methods > flake_odf": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.flake_odf()"
            ],
            "References": [],
            "Description": "Fraction of nodes in S that have fewer edges pointing inside than to the outside of the algorithms.\n\n\\[f(S) = \\frac{| \\{ u:u \\in S,| \\{(u,v) \\in E: v \\in S \\}| < d(u)/2 \\}|}{n_S}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\), \\(d(u)\\) is the degree of \\(u\\) and \\(n_S\\) is the set of algorithms nodes.\n"
        },
        "Section_id": "BiNodeClustering"
    },
    {
        "Field List > Methods > fraction_over_median_degree": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.fraction_over_median_degree()"
            ],
            "References": [],
            "Description": "Fraction of algorithms nodes of having internal degree higher than the median degree value.\n\n\\[f(S) = \\frac{|\\{u: u \\in S,| \\{(u,v): v \\in S\\}| > d_m\\}| }{n_S}\\]\nwhere \\(d_m\\) is the internal degree median value\n"
        },
        "Section_id": "BiNodeClustering"
    },
    {
        "Field List > Methods > get_description": {
            "Paramters": {
                "parameters_to_display": "parameters to display. By default, all float parameters.",
                "precision": "precision used to plot parameters. default: 3"
            },
            "Return": [
                "a string description of the method.\n"
            ],
            "Example": [],
            "References": [],
            "Description": "Return a description of the clustering, with the name of the method and its numeric parameters.\n"
        },
        "Section_id": "BiNodeClustering"
    },
    {
        "Field List > Methods > hub_dominance": {
            "Paramters": {
                "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
            },
            "Return": [
                "If summary==True a FitnessResult object, otherwise a list of floats."
            ],
            "Example": [],
            "References": [],
            "Description": "Hub dominance.\nThe hub dominance of a community is defined as the ratio of the degree of its most connected node w.r.t. the theoretically maximal degree within the community.\n"
        },
        "Section_id": "BiNodeClustering"
    },
    {
        "Field List > Methods > internal_edge_density": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.internal_edge_density()"
            ],
            "References": [],
            "Description": "The internal density of the algorithms set.\n\n\\[f(S) = \\frac{m_S}{n_S(n_S\u22121)/2}\\]\nwhere \\(m_S\\) is the number of algorithms internal edges and \\(n_S\\) is the number of algorithms nodes.\n"
        },
        "Section_id": "BiNodeClustering"
    },
    {
        "Field List > Methods > link_modularity": {
            "Paramters": {},
            "Return": [
                "the link modularity score"
            ],
            "Example": [
                "from cdlib import evaluation\nfrom cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.link_modularity()"
            ],
            "References": [],
            "Description": "Quality function designed for directed graphs with overlapping communities.\n"
        },
        "Section_id": "BiNodeClustering"
    },
    {
        "Field List > Methods > max_odf": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.max_odf()"
            ],
            "References": [],
            "Description": "Maximum fraction of edges of a node of a algorithms that point outside the algorithms itself.\n\n\\[max_{u \\in S} \\frac{|\\{(u,v)\\in E: v \\not\\in S\\}|}{d(u)}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\) and \\(d(u)\\) is the degree of \\(u\\)\n"
        },
        "Section_id": "BiNodeClustering"
    },
    {
        "Field List > Methods > modularity_density": {
            "Paramters": {},
            "Return": [
                "the modularity density score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.modularity_density()"
            ],
            "References": [],
            "Description": "The modularity density is one of several propositions that envisioned to palliate the resolution limit issue of modularity based measures.\nThe idea of this metric is to include the information about algorithms size into the expected density of algorithms to avoid the negligence of small and dense communities.\nFor each algorithms \\(C\\) in partition \\(S\\), it uses the average modularity degree calculated by \\(d(C) = d^{int(C)} \u2212 d^{ext(C)}\\) where \\(d^{int(C)}\\) and \\(d^{ext(C)}\\) are the average internal and external degrees of \\(C\\) respectively to evaluate the fitness of \\(C\\) in its network.\nFinally, the modularity density can be calculated as follows:\n\n\\[Q(S) = \\sum_{C \\in S} \\frac{1}{n_C} ( \\sum_{i \\in C} k^{int}_{iC} - \\sum_{i \\in C} k^{out}_{iC})\\]\nwhere \\(n_C\\) is the number of nodes in C, \\(k^{int}_{iC}\\) is the degree of node i within \\(C\\) and \\(k^{out}_{iC}\\) is the deree of node i outside \\(C\\).\n"
        },
        "Section_id": "BiNodeClustering"
    },
    {
        "Field List > Methods > modularity_overlap": {
            "Paramters": {
                "weight": "label identifying the edge weight parameter name (if present), default None"
            },
            "Return": [
                "FitnessResult object"
            ],
            "Example": [],
            "References": [
                "\nLazar, D. Abel and T. Vicsek, \u201cModularity measure of networks with overlapping communities\u201d  EPL, 90 (2010) 18001 doi: 10.1209/0295-5075/90/18001\n\n",
                "Lazar, D. Abel and T. Vicsek, \u201cModularity measure of networks with overlapping communities\u201d  EPL, 90 (2010) 18001 doi: 10.1209/0295-5075/90/18001"
            ],
            "Description": "Determines the Overlapping Modularity of a partition C on a graph G.\nOverlapping Modularity is defined as\n\n\\[M_{c_{r}}^{ov} = \\sum_{i \\in c_{r}} \\frac{\\sum_{j \\in c_{r}, i \\neq j}a_{ij} - \\sum_{j \\not \\in c_{r}}a_{ij}}{d_{i} \\cdot s_{i}} \\cdot \\frac{n_{c_{r}}^{e}}{n_{c_{r}} \\cdot \\binom{n_{c_{r}}}{2}}\\]\n"
        },
        "Section_id": "BiNodeClustering"
    },
    {
        "Field List > Methods > newman_girvan_modularity": {
            "Paramters": {},
            "Return": [
                "the Newman-Girvan modularity score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.newman_girvan_modularity()"
            ],
            "References": [],
            "Description": "Difference the fraction of intra algorithms edges of a partition with the expected number of such edges if distributed according to a null model.\nIn the standard version of modularity, the null model preserves the expected degree sequence of the graph under consideration. In other words, the modularity compares the real network structure with a corresponding one where nodes are connected without any preference about their neighbors.\n\n\\[Q(S) = \\frac{1}{m}\\sum_{c \\in S}(m_S - \\frac{(2 m_S + l_S)^2}{4m})\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms edges, \\(l_S\\) is the number of edges from nodes in S to nodes outside S.\n"
        },
        "Section_id": "BiNodeClustering"
    },
    {
        "Field List > Methods > nf1": {
            "Paramters": {
                "clustering": "NodeClustering object"
            },
            "Return": [
                "MatchingResult instance"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.nf1(leiden_communities)"
            ],
            "References": [
                "Rossetti, G., Pappalardo, L., & Rinzivillo, S. (2016). A novel approach to evaluate algorithms detection internal on ground truth.",
                "Rossetti, G. (2017). : RDyn: graph benchmark handling algorithms dynamics. Journal of Complex Networks. 5(6), 893-912."
            ],
            "Description": "Compute the Normalized F1 score of the optimal algorithms matches among the partitions in input.\nWorks on overlapping/non-overlapping complete/partial coverage partitions.\n"
        },
        "Section_id": "BiNodeClustering"
    },
    {
        "Field List > Methods > normalized_cut": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.normalized_cut()"
            ],
            "References": [],
            "Description": "Normalized variant of the Cut-Ratio\n\n\\[: f(S) = \\frac{c_S}{2m_S+c_S} + \\frac{c_S}{2(m\u2212m_S )+c_S}\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms internal edges and \\(c_S\\) is the number of algorithms nodes.\n"
        },
        "Section_id": "BiNodeClustering"
    },
    {
        "Field List > Methods > normalized_mutual_information": {
            "Paramters": {
                "clustering": "NodeClustering object"
            },
            "Return": [
                "normalized mutual information score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.normalized_mutual_information(leiden_communities)"
            ],
            "References": [],
            "Description": "Normalized Mutual Information between two clusterings.\nNormalized Mutual Information (NMI) is an normalization of the Mutual\nInformation (MI) score to scale the results between 0 (no mutual\ninformation) and 1 (perfect correlation). In this function, mutual\ninformation is normalized by sqrt(H(labels_true) * H(labels_pred))\n"
        },
        "Section_id": "BiNodeClustering"
    },
    {
        "Field List > Methods > omega": {
            "Paramters": {
                "clustering": "NodeClustering object"
            },
            "Return": [
                "omega index"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.omega(leiden_communities)"
            ],
            "References": [
                "Gabriel Murray, Giuseppe Carenini, and Raymond Ng. 2012. Using the omega index for evaluating abstractive algorithms detection. In Proceedings of Workshop on Evaluation Metrics and System Comparison for Automatic Summarization. Association for Computational Linguistics, Stroudsburg, PA, USA, 10-18."
            ],
            "Description": "Index of resemblance for overlapping, complete coverage, network clusterings.\n"
        },
        "Section_id": "BiNodeClustering"
    },
    {
        "Field List > Methods > overlapping_normalized_mutual_information_LFK": {
            "Paramters": {
                "clustering": "NodeClustering object"
            },
            "Return": [
                "onmi score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.overlapping_normalized_mutual_information_LFK(leiden_communities)"
            ],
            "References": [
                "Lancichinetti, A., Fortunato, S., & Kertesz, J. (2009). Detecting the overlapping and hierarchical community structure in complex networks. New Journal of Physics, 11(3), 033015."
            ],
            "Description": "Overlapping Normalized Mutual Information between two clusterings.\nExtension of the Normalized Mutual Information (NMI) score to cope with overlapping partitions.\nThis is the version proposed by Lancichinetti et al.\n"
        },
        "Section_id": "BiNodeClustering"
    },
    {
        "Field List > Methods > overlapping_normalized_mutual_information_MGH": {
            "Paramters": {
                "clustering": "NodeClustering object",
                "normalization": "one of \u201cmax\u201d or \u201cLFK\u201d. Default \u201cmax\u201d (corresponds to the main method described in the article)"
            },
            "Return": [
                "onmi score\n"
            ],
            "Example": [
                "from cdlib import evaluation, algorithms\ng = nx.karate_club_graph()\nlouvain_communities = algorithms.louvain(g)\nleiden_communities = algorithms.leiden(g)\nevaluation.overlapping_normalized_mutual_information_MGH(louvain_communities,leiden_communities)"
            ],
            "References": [
                "McDaid, A. F., Greene, D., & Hurley, N. (2011). Normalized mutual information to evaluate overlapping community finding algorithms. arXiv preprint arXiv:1110.2515. Chicago"
            ],
            "Description": "Overlapping Normalized Mutual Information between two clusterings.\nExtension of the Normalized Mutual Information (NMI) score to cope with overlapping partitions.\nThis is the version proposed by McDaid et al. using a different normalization than the original LFR one. See ref.\nfor more details.\n"
        },
        "Section_id": "BiNodeClustering"
    },
    {
        "Field List > Methods > scaled_density": {
            "Paramters": {
                "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
            },
            "Return": [
                "If summary==True a FitnessResult object, otherwise a list of floats."
            ],
            "Example": [],
            "References": [],
            "Description": "Scaled density.\nThe scaled density of a community is defined as the ratio of the community density w.r.t. the complete graph density.\n"
        },
        "Section_id": "BiNodeClustering"
    },
    {
        "Field List > Methods > significance": {
            "Paramters": {},
            "Return": [
                "the significance score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.significance()"
            ],
            "References": [],
            "Description": "Significance estimates how likely a partition of dense communities appear in a random graph.\n"
        },
        "Section_id": "BiNodeClustering"
    },
    {
        "Field List > Methods > size": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [],
            "References": [],
            "Description": "Size is the number of nodes in the community\n"
        },
        "Section_id": "BiNodeClustering"
    },
    {
        "Field List > Methods > surprise": {
            "Paramters": {},
            "Return": [
                "the surprise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.surprise()"
            ],
            "References": [],
            "Description": "Surprise is statistical approach proposes a quality metric assuming that edges between vertices emerge randomly according to a hyper-geometric distribution.\nAccording to the Surprise metric, the higher the score of a partition, the less likely it is resulted from a random realization, the better the quality of the algorithms structure.\n"
        },
        "Section_id": "BiNodeClustering"
    },
    {
        "Field List > Methods > to_json": {
            "Paramters": {},
            "Return": [
                "a JSON formatted string representing the object"
            ],
            "Example": [],
            "References": [],
            "Description": "Generate a JSON representation of the algorithms object\n"
        },
        "Section_id": "BiNodeClustering"
    },
    {
        "Field List > Methods > to_node_community_map": {
            "Paramters": {},
            "Return": [
                "dict of the form <node, list(communities)>"
            ],
            "Example": [],
            "References": [],
            "Description": "Generate a <node, list(communities)> representation of the current clustering\n"
        },
        "Section_id": "BiNodeClustering"
    },
    {
        "Field List > Methods > triangle_participation_ratio": {
            "Paramters": {
                "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
            },
            "Return": [
                "a FitnessResult object/a list of community-wise score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.triangle_participation_ratio()"
            ],
            "References": [],
            "Description": "Fraction of algorithms nodes that belong to a triad.\n\n\\[f(S) = \\frac{ | \\{ u: u \\in S,\\{(v,w):v, w \\in S,(u,v) \\in E,(u,w) \\in E,(v,w) \\in E \\} \\not = \\emptyset \\} |}{n_S}\\]\nwhere \\(n_S\\) is the set of algorithms nodes.\n"
        },
        "Section_id": "BiNodeClustering"
    },
    {
        "Field List > Methods > variation_of_information": {
            "Paramters": {
                "clustering": "NodeClustering object"
            },
            "Return": [
                "VI score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.variation_of_information(leiden_communities)"
            ],
            "References": [
                "Meila, M. (2007). Comparing clusterings - an information based distance. Journal of Multivariate Analysis, 98, 873-895. doi:10.1016/j.jmva.2006.11.013"
            ],
            "Description": "Variation of Information among two nodes partitions.\n$$ H(p)+H(q)-2MI(p, q) $$\nwhere MI is the mutual information, H the partition entropy and p,q are the algorithms sets\n"
        },
        "Section_id": "BiNodeClustering"
    },
    {
        "Field List > Methods > z_modularity": {
            "Paramters": {},
            "Return": [
                "the z-modularity score"
            ],
            "Example": [
                "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.z_modularity()"
            ],
            "References": [],
            "Description": "Z-modularity is another variant of the standard modularity proposed to avoid the resolution limit.\nThe concept of this version is based on an observation that the difference between the fraction of edges inside communities and the expected number of such edges in a null model should not be considered as the only contribution to the final quality of algorithms structure.\n"
        },
        "Section_id": "BiNodeClustering"
    },
    {
        "Section_id": "convert_graph_formats",
        "Description": "Converts from/to networkx/igraph\n"
    },
    {
        "Parameters": {
            "graph": "original graph object",
            "desired_format": "desired final type. Either nx.Graph or ig.Graph",
            "directed": "boolean, defaultFalse"
        },
        "Section_id": "convert_graph_formats"
    },
    {
        "Section_id": "convert_graph_formats",
        "Return": [
            "the converted graph\n"
        ]
    },
    {
        "Section_id": "overlapping_seed_set_expansion",
        "Description": "OSSE is an overlapping community detection algorithm optimizing the conductance community score\nThe algorithm uses a seed set expansion approach; the key idea is to find good seeds, and then expand these seed sets using the personalized PageRank clustering procedure.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "seeds": "Node list",
            "ninf": "Neighbourhood Inflation parameter (boolean)",
            "expansion": "Seed expansion: ppr or vppr",
            "stopping": "Stopping criteria: cond",
            "nworkers": "Number of Workers: default 1",
            "nruns": "Number of runs: default 13",
            "alpha": "alpha value for Personalized PageRank expansion: default 0.99",
            "maxexpand": "Maximum expansion allowed for approximate ppr: default INF",
            "delta": "Minimum distance parameter for near duplicate communities: default 0.2"
        },
        "Section_id": "overlapping_seed_set_expansion"
    },
    {
        "Section_id": "overlapping_seed_set_expansion",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "overlapping_seed_set_expansion",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncom = algorithms.overlapping_seed_set_expansion(G)"
        ]
    },
    {
        "Section_id": "cpm",
        "Description": "CPM is a model where the quality function to optimize is:\n\n\\[Q = \\sum_{ij} \\left(A_{ij} - \\gamma \\right)\\delta(\\sigma_i, \\sigma_j)\\]\nwhere \\(A\\) is the adjacency matrix, \\(\\sigma_i\\) denotes the community of node \\(i\\), \\(\\delta(\\sigma_i, \\sigma_j) = 1\\) if  \\(\\sigma_i = \\sigma_j\\) and 0 otherwise, and, finally \\(\\gamma\\) is a resolution parameter.\nThe internal density of communities\n\n\\[p_c = \\frac{m_c}{\\binom{n_c}{2}} \\geq \\gamma\\]\nis higher than \\(\\gamma\\), while the external density\n\\(p_{cd} = \\frac{m_{cd}}{n_c n_d} \\leq \\gamma\\)    is lower than \\(\\gamma\\). In other words, choosing a particular\n\\(\\gamma\\) corresponds to choosing to find communities of a particular\ndensity, and as such defines communities. Finally, the definition of a community is in a sense independent of the actual graph, which is not the case for any of the other methods.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "initial_membership": "list of int Initial membership for the partition. IfNonethen defaults to a singleton partition. Deafault None",
            "weights": "list of double, or edge attribute Weights of edges. Can be either an iterable or an edge attribute. Deafault None",
            "node_sizes": "list of int, or vertex attribute Sizes of nodes are necessary to know the size of communities in aggregate graphs. Usually this is set to 1 for all nodes, but in specific cases  this could be changed. Deafault None",
            "resolution_parameter": "double >0 A parameter value controlling the coarseness of the clustering. Higher resolutions lead to more communities, while lower resolutions lead to fewer communities. Deafault 1"
        },
        "Section_id": "cpm"
    },
    {
        "Section_id": "cpm",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "cpm",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.cpm(G)"
        ]
    },
    {
        "Section_id": "infomap",
        "Description": "Infomap is based on ideas of information theory.\nThe algorithm uses the probability flow of random walks on a network as a proxy for information flows in the real system and it decomposes the network into modules by compressing a description of the probability flow.\nNB: in case the Infomap package is not installed/installable (e.g., on M1 silicon Macs), the implementation used is the one from the igraph library.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "flags": "str flags for Infomap"
        },
        "Section_id": "infomap"
    },
    {
        "Section_id": "infomap",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "infomap",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.infomap(G)"
        ]
    },
    {
        "Section_id": "plot_com_stat",
        "Description": "Plot the distribution of a property among all communities for a clustering, or a list of clusterings (violin-plots)\n"
    },
    {
        "Parameters": {
            "com_clusters": "list of clusterings to compare, or a single clustering",
            "com_fitness": "the fitness/community property to use"
        },
        "Section_id": "plot_com_stat"
    },
    {
        "Section_id": "plot_com_stat",
        "Return": [
            "the violin-plots\n"
        ]
    },
    {
        "Section_id": "plot_com_stat",
        "Example": [
            "from cdlib import algorithms, viz, evaluation\nimport networkx as nx\ng = nx.karate_club_graph()\ncoms = algorithms.louvain(g)\ncoms2 = algorithms.walktrap(g)\nviolinplot = viz.plot_com_stat([coms,coms2],evaluation.size)"
        ]
    },
    {
        "Section_id": "z_modularity",
        "Description": "Z-modularity is another variant of the standard modularity proposed to avoid the resolution limit.\nThe concept of this version is based on an observation that the difference between the fraction of edges inside communities and the expected number of such edges in a null model should not be considered as the only contribution to the final quality of community structure.\n"
    },
    {
        "Parameters": {
            "graph": "a networkx/igraph object",
            "communities": "NodeClustering object"
        },
        "Section_id": "z_modularity"
    },
    {
        "Section_id": "z_modularity",
        "Return": [
            "FitnessResult object\n"
        ]
    },
    {
        "Section_id": "z_modularity",
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = evaluation.z_modularity(g,communities)"
        ]
    },
    {
        "Section_id": "z_modularity",
        "References": [
            "Miyauchi, Atsushi, and Yasushi Kawase. Z-score-based modularity for community detection in networks. PloS one 11.1 (2016): e0147805."
        ]
    },
    {
        "Section_id": "surprise",
        "Description": "Surprise is statistical approach proposes a quality metric assuming that edges between vertices emerge randomly according to a hyper-geometric distribution.\nAccording to the Surprise metric, the higher the score of a partition, the less likely it is resulted from a random realization, the better the quality of the community structure.\n"
    },
    {
        "Parameters": {
            "graph": "a networkx/igraph object",
            "communities": "NodeClustering object"
        },
        "Section_id": "surprise"
    },
    {
        "Section_id": "surprise",
        "Return": [
            "FitnessResult object\n"
        ]
    },
    {
        "Section_id": "surprise",
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = evaluation.surprise(g,communities)"
        ]
    },
    {
        "Section_id": "surprise",
        "References": [
            "Traag, V. A., Aldecoa, R., & Delvenne, J. C. (2015). Detecting communities using asymptotical surprise. Physical Review E, 92(2), 022816."
        ]
    },
    {
        "Section_id": "edges_inside",
        "Description": "Number of edges internal to the community.\n"
    },
    {
        "Parameters": {
            "graph": "a networkx/igraph object",
            "community": "NodeClustering object",
            "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
        },
        "Section_id": "edges_inside"
    },
    {
        "Section_id": "edges_inside",
        "Return": [
            "If summary==True a FitnessResult object, otherwise a list of floats.\n"
        ]
    },
    {
        "Section_id": "edges_inside",
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = evaluation.edges_inside(g,communities)"
        ]
    },
    {
        "Section_id": "edges_inside",
        "References": [
            "Radicchi, F., Castellano, C., Cecconi, F., Loreto, V., & Parisi, D. (2004). Defining and identifying communities in networks. Proceedings of the National Academy of Sciences, 101(9), 2658-2663."
        ]
    },
    {
        "Section_id": "normalized_cut",
        "Description": "Normalized variant of the Cut-Ratio\n\n\\[f(S) = \\frac{c_S}{2m_S+c_S} + \\frac{c_S}{2(m\u2212m_S )+c_S}\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of community internal edges and \\(c_S\\) is the number of community nodes.\n"
    },
    {
        "Parameters": {
            "graph": "a networkx/igraph object",
            "community": "NodeClustering object",
            "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
        },
        "Section_id": "normalized_cut"
    },
    {
        "Section_id": "normalized_cut",
        "Return": [
            "If summary==True a FitnessResult object, otherwise a list of floats.\n"
        ]
    },
    {
        "Section_id": "normalized_cut",
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = evaluation.normalized_cut(g,communities)"
        ]
    },
    {
        "Section_id": "CPM_Bipartite",
        "Description": "CPM_Bipartite is the extension of CPM to bipartite graphs\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "resolution_parameter_01": "Resolution parameter for in between two classes.",
            "resolution_parameter_0": "Resolution parameter for class 0.",
            "resolution_parameter_1": "Resolution parameter for class 1.",
            "degree_as_node_size": "IfTrueuse degree as node size instead of 1, to mimic modularity",
            "seed": "the random seed to be used in CPM method to keep results/partitions replicable"
        },
        "Section_id": "CPM_Bipartite"
    },
    {
        "Section_id": "CPM_Bipartite",
        "Return": [
            "BiNodeClustering object\n"
        ]
    },
    {
        "Section_id": "CPM_Bipartite",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.algorithms.bipartite.generators.random_graph(100, 20, 0.5)\ncoms = algorithms.CPM_Bipartite(G, 0.5)"
        ]
    },
    {
        "Section_id": "r_spectral_clustering",
        "Description": "Spectral clustering partitions the nodes of a graph into groups based upon the eigenvectors of the graph Laplacian.\nDespite the claims of spectral clustering being \u201cpopular\u201d, in applied research using graph data, spectral clustering (without regularization) often returns a partition of the nodes that is uninteresting, typically finding a large cluster that contains most of the data and many smaller clusters, each with only a few nodes.\nThis method allows to compute spectral clustering with/withouth different regualarization functions designed to address such a limitation.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "n_clusters": "How many clusters to look at",
            "method": "one among \u201cvanilla\u201d, \u201cregularized\u201d, \u201cregularized_with_kmeans\u201d, \u201csklearn_spectral_embedding\u201d, \u201csklearn_kmeans\u201d, \u201cpercentile\u201d.",
            "percentile": "percentile of the degree distribution to perform regularization. Value in [0, 100]. Mandatory if method=\u201dpercentile\u201d or \u201cregularized\u201d, otherwise None"
        },
        "Section_id": "r_spectral_clustering"
    },
    {
        "Section_id": "r_spectral_clustering",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "r_spectral_clustering",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.r_spectral_clustering(G, n_clusters=2, method=\"regularized\", percentile=20)"
        ]
    },
    {
        "Section_id": "principled_clustering",
        "Description": "An efficient and principled method for detecting communities in networks\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "networkx/igraph object",
            "cluster_count": "number of desired communities"
        },
        "Section_id": "principled_clustering"
    },
    {
        "Section_id": "principled_clustering",
        "Return": [
            "FuzzyNodeClustering object\n"
        ]
    },
    {
        "Section_id": "principled_clustering",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.principled_clustering(G, 3)"
        ]
    },
    {
        "Section_id": "read_community_csv",
        "Description": "Read community list from comma separated value (csv) file.\n"
    },
    {
        "Parameters": {
            "path": "input filename",
            "delimiter": "column delimiter",
            "nodetype": "specify the type of node labels, default str",
            "compress": "wheter the file is compressed or not, default False"
        },
        "Section_id": "read_community_csv"
    },
    {
        "Section_id": "read_community_csv",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "read_community_csv",
        "Example": [
            "import networkx as nx\nfrom cdlib import algorithms, readwrite\ng = nx.karate_club_graph()\ncoms = algorithms.louvain(g)\nreadwrite.write_community_csv(coms, \"communities.csv\", \",\")\ncoms = readwrite.read_community_csv(coms, \"communities.csv\", \",\", str)"
        ]
    },
    {
        "Section_id": "cut_ratio",
        "Description": "Fraction of existing edges (out of all possible edges) leaving the community.\n\n\\[f(S) = \\frac{c_S}{n_S (n \u2212 n_S)}\\]\nwhere \\(c_S\\) is the cut size (number of edges on the community boundary) and \\(n_S\\) is the number of community nodes\n"
    },
    {
        "Parameters": {
            "graph": "a networkx/igraph object",
            "community": "NodeClustering object",
            "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
        },
        "Section_id": "cut_ratio"
    },
    {
        "Section_id": "cut_ratio",
        "Return": [
            "If summary==True a FitnessResult object, otherwise a list of floats.\n"
        ]
    },
    {
        "Section_id": "cut_ratio",
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = evaluation.cut_ratio(g,communities)"
        ]
    },
    {
        "Section_id": "cut_ratio",
        "References": [
            "Fortunato, S.: Community detection in graphs. Physics reports 486(3-5), 75\u2013174 (2010)"
        ]
    },
    {
        "Section_id": "label_propagation",
        "Description": "The Label Propagation algorithm (LPA) detects communities using network structure alone.\nThe algorithm doesn\u2019t require a pre-defined objective function or prior information about the communities.\nIt works as follows:\n-Every node is initialized with a unique label (an identifier)\n-These labels propagate through the network\n-At every iteration of propagation, each node updates its label to the one that the maximum numbers of its neighbours belongs to. Ties are broken uniformly and randomly.\n-LPA reaches convergence when each node has the majority label of its neighbours.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object"
        },
        "Section_id": "label_propagation"
    },
    {
        "Section_id": "label_propagation",
        "Return": [
            "EdgeClustering object"
        ]
    },
    {
        "Section_id": "label_propagation",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.label_propagation(G)"
        ]
    },
    {
        "Section_id": "write_community_json",
        "Description": "Generate a JSON representation of the clustering object\n"
    },
    {
        "Parameters": {
            "communities": "a cdlib clustering object",
            "path": "output filename",
            "compress": "wheter to copress the JSON, default False"
        },
        "Section_id": "write_community_json"
    },
    {
        "Section_id": "write_community_json",
        "Return": [
            "a JSON formatted string representing the object\n"
        ]
    },
    {
        "Section_id": "write_community_json",
        "Example": [
            "import networkx as nx\nfrom cdlib import algorithms, readwrite\ng = nx.karate_club_graph()\ncoms = algorithms.louvain(g)\nreadwrite.write_community_json(coms, \"communities.json\")"
        ]
    },
    {
        "Section_id": "walkscan",
        "Description": "Random walk community detection method leveraging PageRank node scoring.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "nb_steps": "the length of the random walk",
            "eps": "DBSCAN eps",
            "min_samples": "DBSCAN min_samples",
            "init_vector": "dictionary node_id -> initial_probability to initialize the random walk. Default, random selected node with probability set to 1."
        },
        "Section_id": "walkscan"
    },
    {
        "Section_id": "walkscan",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "walkscan",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.walkscan(G)"
        ]
    },
    {
        "Section_id": "lswl_plus",
        "Description": "LSWL+ is capable of finding a partition with overlapping communities or without them, based on user preferences.\nThis method can also find outliers (peripheral nodes of the graph that are marginally connected to communities) and hubs (nodes that bridge the communities)\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "strength_type": "1 strengths between [-1,+1] or, 2 strengths between [0,1]. Default, 2.",
            "merge_outliers": "If outliers need to merge into communities. Default, True.",
            "detect_overlap": "If overlapping communities need to be detected. Default, False"
        },
        "Section_id": "lswl_plus"
    },
    {
        "Section_id": "lswl_plus",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "lswl_plus",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.lswl_plus(G)"
        ]
    },
    {
        "Section_id": "hierarchical_link_community",
        "Description": "HLC (hierarchical link clustering) is a method to classify links into topologically related groups.\nThe algorithm uses a similarity between links to build a dendrogram where each leaf is a link from the original network and branches represent link communities.\nAt each level of the link dendrogram is calculated the partition density function, based on link density inside communities, to pick the best level to cut.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object"
        },
        "Section_id": "hierarchical_link_community"
    },
    {
        "Section_id": "hierarchical_link_community",
        "Return": [
            "EdgeClustering object"
        ]
    },
    {
        "Section_id": "hierarchical_link_community",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncom = algorithms.hierarchical_link_community(G)"
        ]
    },
    {
        "Section_id": "FitnessResult",
        "Description": "Initialize self.  See help(type(self)) for accurate signature."
    },
    {
        "Field List > Parameters": {},
        "Section_id": "FitnessResult"
    },
    {
        "Section_id": "lswl",
        "Description": "LSWL locally discovers networks\u2019 the communities precisely, deterministically, and quickly.\nThis method works in a one-node-expansion model based on a notion of strong and weak links in a graph.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "timeout": "The maximum time in which LSWL should retrieve the community. Default is 1 second.",
            "strength_type": "1 strengths between [-1,+1] or, 2 strengths between [0,1]. Default, 2.",
            "query_node": "Id of the network node whose local community is queried.",
            "online": "wehter the computation should happen in memory or not. Default, True."
        },
        "Section_id": "lswl"
    },
    {
        "Section_id": "lswl",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "lswl",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.lswl(G, 1)"
        ]
    },
    {
        "Section_id": "link_modularity",
        "Description": "Quality function designed for directed graphs with overlapping communities.\n"
    },
    {
        "Parameters": {
            "graph": "a networkx/igraph object",
            "communities": "NodeClustering object"
        },
        "Section_id": "link_modularity"
    },
    {
        "Section_id": "link_modularity",
        "Return": [
            "FitnessResult object\n"
        ]
    },
    {
        "Section_id": "link_modularity",
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = evaluation.link_modularity(g,communities)"
        ]
    },
    {
        "Section_id": "link_modularity",
        "References": [
            "Nicosia, V., Mangioni, G., Carchiolo, V., Malgeri, M.: Extending the definition of modularity to directed graphs with overlapping communities. Journal of Statistical Mechanics: Theory and Experiment 2009(03), 03024 (2009)"
        ]
    },
    {
        "Section_id": "bimlpa",
        "Description": "BiMLPA is designed to detect the many-to-many correspondence community in bipartite networks using multi-label propagation algorithm.\nThis method works for the connected graph. If the graph is not connected, the method will be applied to each connected component of the graph and the results will be merged.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object (instance of igraph.Graph or nx.Graph).",
            "theta": "Label weights threshold. Default 0.3.",
            "lambd": "The max number of labels. Default 7."
        },
        "Section_id": "bimlpa"
    },
    {
        "Section_id": "bimlpa",
        "Return": [
            "BiNodeClustering object\n"
        ]
    },
    {
        "Section_id": "bimlpa",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.algorithms.bipartite.random_graph(50, 50, 0.25)\ncoms = algorithms.bimlpa(G)"
        ]
    },
    {
        "Section_id": "ipca",
        "Description": "IPCA was introduced by Li et al. (2008) as a modi\ufb01ed version of DPClus.\nIn contrast to DPClus, this method focuses on the maintaining the diameter of a cluster, de\ufb01ned as the maximum shortest distance between all pairs of vertices, rather than its density.\nIn doing so, the seed growth aspect of IPCA emphasizes structural closeness of a predicted protein complex, as well as structural connectivity.\nLike DPClus, IPCA computes local vertex and edge weights by counting the number of common neighbors shared between two vertices.\nHowever, IPCA calculates these values only once at the beginning of the algorithm, rather than updating them every time a discovered cluster is removed from the graph.\nThis allows overlap to occur naturally between clusters, as cluster nodes are not permanently removed from the graph; however, it can also lead to a large amount of cluster overlap.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "weights": "label used for the edge weights. Default, None.",
            "t_in": ""
        },
        "Section_id": "ipca"
    },
    {
        "Section_id": "ipca",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "ipca",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.ipca(G)"
        ]
    },
    {
        "Section_id": "TemporalClustering",
        "Description": "Add to the Temporal Clustering the communities observed at a given time"
    },
    {
        "Field List > Parameters": {
            "clustering": "a Clustering object",
            "time": "time of observation"
        },
        "Section_id": "TemporalClustering"
    },
    {
        "Field List > Methods > add_clustering": {
            "Paramters": {
                "clustering": "a Clustering object",
                "time": "time of observation"
            },
            "Return": [],
            "Example": [],
            "References": [],
            "Description": "Add to the Temporal Clustering the communities observed at a given time\n"
        },
        "Section_id": "TemporalClustering"
    },
    {
        "Field List > Methods > add_matching": {
            "Paramters": {
                "matching": "a list of tuples [(Ti_Ca, Tj_Cb, score), \u2026 ].\nCommunity names needs to satisfy the pattern {tid}_{cid}, where tid is the time of observation and\ncid is the position of the community within the Clustering object."
            },
            "Return": [],
            "Example": [],
            "References": [],
            "Description": "Add a precomputed matching of the communities.\n"
        },
        "Section_id": "TemporalClustering"
    },
    {
        "Field List > Methods > clustering_stability_trend": {
            "Paramters": {
                "method": "a comparison score taking as input two Clustering objects (e.g., NMI, NF1, ARI\u2026)"
            },
            "Return": [
                "a list of floats"
            ],
            "Example": [],
            "References": [],
            "Description": "Returns the trend for community stability.\nThe stability index is computed for temporally adjacent clustering pairs.\n"
        },
        "Section_id": "TemporalClustering"
    },
    {
        "Field List > Methods > community_matching": {
            "Paramters": {
                "method": "a set similarity function with co-domain in [0,1] (e.g., Jaccard)",
                "two_sided": "boolean.\nWhether the match has to be applied only from the past to the future (False, default)\nor even from the future to the past (True)"
            },
            "Return": [
                "a list of tuples [(Ti_Ca, Tj_Cb, score), \u2026 ].\nCommunity names are assigned following the pattern {tid}_{cid}, where tid is the time of observation and\ncid is the position of the community within the Clustering object.\n"
            ],
            "Example": [],
            "References": [],
            "Description": "Reconstruct community matches across adjacent observations using a provided similarity function.\n"
        },
        "Section_id": "TemporalClustering"
    },
    {
        "Field List > Methods > get_clustering_at": {
            "Paramters": {
                "time": "the time of observation"
            },
            "Return": [
                "a Clustering object"
            ],
            "Example": [],
            "References": [],
            "Description": "Returns the clustering observed at a given time\n"
        },
        "Section_id": "TemporalClustering"
    },
    {
        "Field List > Methods > get_community": {
            "Paramters": {
                "cid": "community id of the form {tid}_{cid}, where tid is the time of observation and\ncid is the position of the community within the Clustering object."
            },
            "Return": [
                "list of nodes within cid"
            ],
            "Example": [],
            "References": [],
            "Description": "Returns the nodes within a given temporal community\n"
        },
        "Section_id": "TemporalClustering"
    },
    {
        "Field List > Methods > get_explicit_community_match": {
            "Paramters": {},
            "Return": [
                "a list of tuple [(Ti_Ca, Tj_Cb, score), \u2026 ].\nCommunity names are assigned following the pattern {tid}_{cid}, where tid is the time of observation and\ncid is the position of the community within the Clustering object."
            ],
            "Example": [],
            "References": [],
            "Description": "Return an explicit matching of computed communities (if it exists)\n"
        },
        "Section_id": "TemporalClustering"
    },
    {
        "Field List > Methods > has_explicit_match": {
            "Paramters": {},
            "Return": [
                "a list of tuple [(Ti_Ca, Tj_Cb, score), \u2026 ].\nCommunity names are assigned following the pattern {tid}_{cid}, where tid is the time of observation and\ncid is the position of the community within the Clustering object."
            ],
            "Example": [],
            "References": [],
            "Description": "Checks if the algorithm provided an explicit match of temporal communities\n"
        },
        "Section_id": "TemporalClustering"
    },
    {
        "Field List > Methods > lifecycle_polytree": {
            "Paramters": {
                "method": "a set similarity function with co-domain in [0,1] (e.g., Jaccard)",
                "two_sided": "boolean.\nWhether the match has to be applied only from the past to the future (False, default)\nor even from the future to the past (True)"
            },
            "Return": [
                "a networkx DiGraph object.\nNodes represent communities, their ids are assigned following the pattern {tid}_{cid},\nwhere tid is the time of observation and\ncid is the position of the community within the Clustering object.\n"
            ],
            "Example": [],
            "References": [],
            "Description": "Reconstruct the poly-tree representing communities lifecycles using a provided similarity function.\n"
        },
        "Section_id": "TemporalClustering"
    },
    {
        "Field List > Methods > to_json": {
            "Paramters": {},
            "Return": [
                "a JSON formatted string representing the object"
            ],
            "Example": [],
            "References": [],
            "Description": "Generate a JSON representation of the TemporalClustering object\n"
        },
        "Section_id": "TemporalClustering"
    },
    {
        "Section_id": "f1",
        "Description": "Compute the average F1 score of the optimal algorithms matches among the partitions in input.\nWorks on overlapping/non-overlapping complete/partial coverage partitions.\n"
    },
    {
        "Parameters": {
            "first_partition": "NodeClustering object",
            "second_partition": "NodeClustering object"
        },
        "Section_id": "f1"
    },
    {
        "Section_id": "f1",
        "Return": [
            "MatchingResult object\n"
        ]
    },
    {
        "Section_id": "f1",
        "Example": [
            "from cdlib import evaluation, algorithms\ng = nx.karate_club_graph()\nlouvain_communities = algorithms.louvain(g)\nleiden_communities = algorithms.leiden(g)\nevaluation.f1(louvain_communities,leiden_communities)"
        ]
    },
    {
        "Section_id": "f1",
        "References": [
            "Rossetti, G., Pappalardo, L., & Rinzivillo, S. (2016). A novel approach to evaluate algorithms detection internal on ground truth. In Complex Networks VII (pp. 133-144). Springer, Cham."
        ]
    },
    {
        "Section_id": "siblinarity_antichain",
        "Description": "The algorithm extract communities from a DAG that (i) respects its intrinsic order and (ii) are composed of similar nodes.\nThe approach takes inspiration from classic similarity measures of bibliometrics, used to assess how similar two publications are, based on their relative citation patterns.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object representing a DAG (directed acyclic graph)",
            "forwards_backwards_on": "checks successors\u2019 similarity. Boolean, default True",
            "backwards_forwards_on": "checks predecessors\u2019 similarity. Boolean, default True",
            "Lambda": "desired resolution of the partition. Default 1",
            "with_replacement": "If True he similarity of a node to itself is equal to the number of its neighbours based on which the similarity is defined. Boolean, default True."
        },
        "Section_id": "siblinarity_antichain"
    },
    {
        "Section_id": "siblinarity_antichain",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "siblinarity_antichain",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.siblinarity_antichain(G, Lambda=1)"
        ]
    },
    {
        "Section_id": "leiden",
        "Description": "The Leiden algorithm is an improvement of the Louvain algorithm.\nThe Leiden algorithm consists of three phases:\n(1) local moving of nodes,\n(2) refinement of the partition\n(3) aggregation of the network based on the refined partition, using the non-refined partition to create an initial partition for the aggregate network.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "initial_membership": "list of int Initial membership for the partition. IfNonethen defaults to a singleton partition. Deafault None",
            "weights": "list of double, or edge attribute Weights of edges. Can be either an iterable or an edge attribute. Deafault None"
        },
        "Section_id": "leiden"
    },
    {
        "Section_id": "leiden",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "leiden",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.leiden(G)"
        ]
    },
    {
        "Section_id": "mod_r",
        "Description": "Community Discovery algorithm that infers the hierarchy of communities that enclose a given vertex by exploring the graph one vertex at a time.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "query_node": "Id of the network node whose local community is queried."
        },
        "Section_id": "mod_r"
    },
    {
        "Section_id": "mod_r",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "mod_r",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.mod_r(G, 1)"
        ]
    },
    {
        "Section_id": "normalized_mutual_information",
        "Description": "Normalized Mutual Information between two clusterings.\nNormalized Mutual Information (NMI) is an normalization of the Mutual\nInformation (MI) score to scale the results between 0 (no mutual\ninformation) and 1 (perfect correlation). In this function, mutual\ninformation is normalized by sqrt(H(labels_true) * H(labels_pred))\n"
    },
    {
        "Parameters": {
            "first_partition": "NodeClustering object",
            "second_partition": "NodeClustering object"
        },
        "Section_id": "normalized_mutual_information"
    },
    {
        "Section_id": "normalized_mutual_information",
        "Return": [
            "MatchingResult object\n"
        ]
    },
    {
        "Section_id": "normalized_mutual_information",
        "Example": [
            "from cdlib import evaluation, algorithms\ng = nx.karate_club_graph()\nlouvain_communities = algorithms.louvain(g)\nleiden_communities = algorithms.leiden(g)\nevaluation.normalized_mutual_information(louvain_communities,leiden_communities)"
        ]
    },
    {
        "Section_id": "condor",
        "Description": "BRIM algorithm for bipartite community structure detection.\nWorks on weighted and unweighted graphs.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object"
        },
        "Section_id": "condor"
    },
    {
        "Section_id": "condor",
        "Return": [
            "BiNodeClustering object"
        ]
    },
    {
        "Section_id": "condor",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.algorithms.bipartite.random_graph(50, 50, 0.25)\ncoms = algorithms.condor(G)"
        ]
    },
    {
        "Section_id": "louvain",
        "Description": "Louvain  maximizes a modularity score for each community.\nThe algorithm optimises the modularity in two elementary phases:\n(1) local moving of nodes;\n(2) aggregation of the network.\nIn the local moving phase, individual nodes are moved to the community that yields the largest increase in the quality function.\nIn the aggregation phase, an aggregate network is created based on the partition obtained in the local moving phase.\nEach community in this partition becomes a node in the aggregate network. The two phases are repeated until the quality function cannot be increased further.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "weight": "str, optional the key in graph to use as weight. Default to \u2018weight\u2019",
            "resolution": "double, optional  Will change the size of the communities, default to 1.",
            "randomize": "int, RandomState instance or None, optional (default=None). If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used bynp.random."
        },
        "Section_id": "louvain"
    },
    {
        "Section_id": "louvain",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "louvain",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.louvain(G, weight='weight', resolution=1.)"
        ]
    },
    {
        "Section_id": "greedy_modularity",
        "Description": "The CNM algorithm uses the modularity to find the communities strcutures.\nAt every step of the algorithm two communities that contribute maximum positive value to global modularity are merged.\nSupported Graph Types\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "weight": "list of double, or edge attribute Weights of edges. Can be either an iterable or an edge attribute. Deafault None"
        },
        "Section_id": "greedy_modularity"
    },
    {
        "Section_id": "greedy_modularity",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "greedy_modularity",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.greedy_modularity(G)"
        ]
    },
    {
        "Section_id": "conga",
        "Description": "CONGA (Cluster-Overlap Newman Girvan Algorithm) is an algorithm for discovering overlapping communities.\nIt extends the  Girvan and Newman\u2019s algorithm with a specific method of deciding when and how to split vertices. The algorithm is as follows:\n"
    },
    {
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "number_communities": "the number of communities desired"
        },
        "Section_id": "conga"
    },
    {
        "Section_id": "conga",
        "Return": [
            "NodeClustering object\n"
        ]
    },
    {
        "Section_id": "conga",
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncom = algorithms.conga(G, number_communities=3)"
        ]
    },
    {
        "Section_id": "conga",
        "References": [
            "Calculate edge betweenness of all edges in network.",
            "Calculate vertex betweenness of vertices, from edge betweennesses.",
            "Find candidate set of vertices: those whose vertex betweenness is greater than the maximum edge betweenness.",
            "If candidate set is non-empty, calculate pair betweennesses of candidate vertices, and then calculate split betweenness of candidate vertices.",
            "Remove edge with maximum edge betweenness or split vertex with maximum split betweenness (if greater).",
            "Recalculate edge betweenness for all remaining edges in same component(s) as removed edge or split vertex.",
            "Repeat from step 2 until no edges remain."
        ]
    },
    {
        "Section_id": "fraction_over_median_degree",
        "Description": "Fraction of community nodes of having internal degree higher than the median degree value.\n\n\\[f(S) = \\frac{|\\{u: u \\in S,| \\{(u,v): v \\in S\\}| > d_m\\}| }{n_S}\\]\nwhere \\(d_m\\) is the internal degree median value\n"
    },
    {
        "Parameters": {
            "graph": "a networkx/igraph object",
            "community": "NodeClustering object",
            "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
        },
        "Section_id": "fraction_over_median_degree"
    },
    {
        "Section_id": "fraction_over_median_degree",
        "Return": [
            "If summary==True a FitnessResult object, otherwise a list of floats.\n"
        ]
    },
    {
        "Section_id": "fraction_over_median_degree",
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = evaluation.fraction_over_median_degree(g,communities)"
        ]
    },
    {
        "Section_id": "fraction_over_median_degree",
        "References": [
            "Yang, J., Leskovec, J.: Defining and evaluating network communities based on ground-truth. Knowledge and Information Systems 42(1), 181\u2013213 (2015)"
        ]
    },
    {
        "Section_id": "write_community_csv",
        "Description": "Save community structure to comma separated value (csv) file.\n"
    },
    {
        "Parameters": {
            "communities": "a NodeClustering object",
            "path": "output filename",
            "delimiter": "column delimiter",
            "compress": "wheter to copress the csv, default False"
        },
        "Section_id": "write_community_csv"
    },
    {
        "Section_id": "write_community_csv",
        "Example": [
            "import networkx as nx\nfrom cdlib import algorithms, readwrite\ng = nx.karate_club_graph()\ncoms = algorithms.louvain(g)\nreadwrite.write_community_csv(coms, \"communities.csv\", \",\")"
        ]
    }
]