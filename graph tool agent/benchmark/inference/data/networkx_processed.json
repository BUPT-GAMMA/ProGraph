[
    {
        "Section ID": "freeze",
        "Description": [
            "Modify graph to prevent further change by adding or removing\nnodes or edges.",
            "Node and edge data can still be modified."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "To \u201cunfreeze\u201d a graph you must make a copy by creating a new graph object:",
            "Examples": "G=nx.path_graph(4)\nG=nx.freeze(G)\ntry:\nG.add_edge(4,5)\nexceptnx.NetworkXErroraserr:\nprint(str(err))\n# Frozen graph can't be modified"
        }
    },
    {
        "Section ID": "PlanarEmbedding",
        "Description": [
            "Represents a planar graph with its planar embedding.",
            "The planar embedding is given by a combinatorial embedding .",
            "Neighbor ordering:",
            "In comparison to a usual graph structure, the embedding also stores the\norder of all neighbors for every vertex.\nThe order of the neighbors can be given in clockwise (cw) direction or\ncounterclockwise (ccw) direction. This order is stored as edge attributes\nin the underlying directed graph. For the edge (u, v) the edge attribute\n\u2018cw\u2019 is set to the neighbor of u that follows immediately after v in\nclockwise direction.",
            "In order for a PlanarEmbedding to be valid it must fulfill multiple\nconditions. It is possible to check if these conditions are fulfilled with\nthe method check_structure() .\nThe conditions are:",
            "As long as a PlanarEmbedding is invalid only the following methods should\nbe called:",
            "Even though the graph is a subclass of nx.DiGraph, it can still be used\nfor algorithms that require undirected graphs, because the method is_directed() is overridden. This is possible, because a valid\nPlanarGraph must have edges in both directions.",
            "Half edges:",
            "In methods like add_half_edge the term \u201chalf-edge\u201d is used, which is\na term that is used in doubly connected edge lists . It is used\nto emphasize that the edge is only in one direction and there exists\nanother half-edge in the opposite direction.\nWhile conventional edges always have two faces (including outer face) next\nto them, it is possible to assign each half-edge exactly one face.\nFor a half-edge (u, v) that is oriented such that u is below v then the\nface that belongs to (u, v) is to the right of this half-edge.",
            "Examples",
            "Create an embedding of a star graph (compare nx.star_graph(3) ):",
            "Alternatively the same embedding can also be defined in counterclockwise\norientation. The following results in exactly the same PlanarEmbedding:",
            "After creating a graph, it is possible to validate that the PlanarEmbedding\nobject is correct:"
        ],
        "Field List": {
            "Parameters:": {
                "incoming_graph_data : input graph (optional, default: None)": "Data to initialize graph.  If None (default) an empty\ngraph is created.  The data can be an edge list, or any\nNetworkX graph object.  If the corresponding optional Python\npackages are installed the data can also be a 2D NumPy array, a\nSciPy sparse array, or a PyGraphviz graph.",
                "attr : keyword arguments, optional (default= no attributes)": "Attributes to add to graph as key=value pairs."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG=nx.Graph(name=\"my graph\")\ne=[(1,2),(2,3),(3,4)]# list of edges\nG=nx.Graph(e)\nArbitrary graph attribute pairs (key=value) may be assigned\nG=nx.Graph(e,day=\"Friday\")\nG.graph\n# {'day': 'Friday'}"
        }
    },
    {
        "Section ID": "triadic_census",
        "Description": [
            "Determines the triadic census of a directed graph.",
            "The triadic census is a count of how many of the 16 possible types of\ntriads are present in a directed graph. If a list of nodes is passed, then\nonly those triads are taken into account which have elements of nodelist in them."
        ],
        "Field List": {
            "Parameters:": {
                "G : digraph": "A NetworkX DiGraph",
                "nodelist : list": "List of nodes for which you want to calculate triadic census"
            },
            "Returns:": {
                "census : dict": "Dictionary with triad type as keys and number of occurrences as values."
            },
            "Raises:": {
                "ValueError": "Ifnodelistcontains duplicate nodes or nodes not inG.\nIf you want to ignore this you can preprocess withset(nodelist)&G.nodes"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm has complexity \\(O(m)\\) where \\(m\\) is the number of edges in\nthe graph. For undirected graphs, the triadic census can be computed by first converting\nthe graph into a directed graph using the G.to_directed() method.\nAfter this conversion, only the triad types 003, 102, 201 and 300 will be\npresent in the undirected scenario.",
            "References": "[1]Vladimir Batagelj and Andrej Mrvar, A subquadratic triad census\nalgorithm for large sparse networks with small maximum degree,\nUniversity of Ljubljana,http://vlado.fmf.uni-lj.si/pub/networks/doc/triads/triads.pdf",
            "Examples": "G=nx.DiGraph([(1,2),(2,3),(3,1),(3,4),(4,1),(4,2)])\ntriadic_census=nx.triadic_census(G)\nforkey,valueintriadic_census.items():\nprint(f\"{key}: {value}\")\n# 003: 0\n# 012: 0\n# 102: 0\n# 021D: 0\n# 021U: 0\n# 021C: 0\n# 111D: 0\n# 111U: 0\n# 030T: 2\n# 030C: 2\n# 201: 0\n# 120D: 0\n# 120U: 0\n# 120C: 0\n# 210: 0\n# 300: 0"
        }
    },
    {
        "Section ID": "maximum_branching",
        "Description": [
            "Returns a maximum branching from G."
        ],
        "Field List": {
            "Parameters:": {
                "G : (multi)digraph-like": "The graph to be searched.",
                "attr : str": "The edge attribute used to in determining optimality.",
                "default : float": "The value of the edge attribute used if an edge does not have\nthe attributeattr.",
                "preserve_attrs : bool": "If True, preserve the other attributes of the original graph (that are not\npassed toattr)",
                "partition : str": "The key for the edge attribute containing the partition\ndata on the graph. Edges can be included, excluded or open using theEdgePartitionenum."
            },
            "Returns:": {
                "B : (multi)digraph-like": "A maximum branching."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "from_prufer_sequence",
        "Description": [
            "Returns the tree corresponding to the given Pr\u00fcfer sequence.",
            "A Pr\u00fcfer sequence is a list of n - 2 numbers between 0 and n - 1, inclusive. The tree corresponding to a given Pr\u00fcfer\nsequence can be recovered by repeatedly joining a node in the\nsequence with a node with the smallest potential degree according to\nthe sequence."
        ],
        "Field List": {
            "Parameters:": {
                "sequence : list": "A Pr\u00fcfer sequence, which is a list ofn- 2 integers between\nzero andn- 1, inclusive."
            },
            "Returns:": {
                "NetworkX graph": "The tree corresponding to the given Pr\u00fcfer sequence."
            },
            "Raises:": {
                "NetworkXError": "If the Pr\u00fcfer sequence is not valid."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "There is a bijection from labeled trees to Pr\u00fcfer sequences. This\nfunction is the inverse of the from_prufer_sequence() function. Sometimes Pr\u00fcfer sequences use nodes labeled from 1 to n instead\nof from 0 to n - 1. This function requires nodes to be labeled in\nthe latter form. You can use networkx.relabel_nodes() to\nrelabel the nodes of your tree to the appropriate format. This implementation is from [1] and has a running time of \\(O(n)\\) .",
            "References": "[1]Wang, Xiaodong, Lei Wang, and Yingjie Wu.\n\u201cAn optimal algorithm for Prufer codes.\u201dJournal of Software Engineering and Applications2.02 (2009): 111.\n<https://doi.org/10.4236/jsea.2009.22016>",
            "Examples": "There is a bijection between Pr\u00fcfer sequences and labeled trees, so\nthis function is the inverse of theto_prufer_sequence()function:\nedges=[(0,3),(1,3),(2,3),(3,4),(4,5)]\ntree=nx.Graph(edges)\nsequence=nx.to_prufer_sequence(tree)\nsequence\n# [3, 3, 3, 4]\ntree2=nx.from_prufer_sequence(sequence)\nlist(tree2.edges())==edges\n# True"
        }
    },
    {
        "Section ID": "sets",
        "Description": [
            "Returns bipartite node sets of graph G.",
            "Raises an exception if the graph is not bipartite or if the input\ngraph is disconnected and thus more than one valid solution exists.\nSee bipartitedocumentation for further details on how bipartite graphs are handled in NetworkX."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "top_nodes : container, optional": "Container with all nodes in one bipartite node set. If not supplied\nit will be computed. But if more than one solution exists an exception\nwill be raised."
            },
            "Returns:": {
                "X : set": "Nodes from one side of the bipartite graph.",
                "Y : set": "Nodes from the other side."
            },
            "Raises:": {
                "AmbiguousSolution": "Raised if the input bipartite graph is disconnected and no container\nwith all nodes in one bipartite set is provided. When determining\nthe nodes in each bipartite set more than one valid solution is\npossible if the input graph is disconnected.",
                "NetworkXError": "Raised if the input graph is not bipartite."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "fromnetworkx.algorithmsimportbipartite\nG=nx.path_graph(4)\nX,Y=bipartite.sets(G)\nlist(X)\n# [0, 2]\nlist(Y)\n# [1, 3]"
        }
    },
    {
        "Section ID": "eigenvector_centrality_numpy",
        "Description": [
            "Compute the eigenvector centrality for the graph G.",
            "Eigenvector centrality computes the centrality for a node by adding\nthe centrality of its predecessors. The centrality for node \\(i\\) is the \\(i\\) -th element of a left eigenvector associated with the eigenvalue \\(\\lambda\\) of maximum modulus that is positive. Such an eigenvector \\(x\\) is\ndefined up to a multiplicative constant by the equation",
            "where \\(A\\) is the adjacency matrix of the graph G. By definition of\nrow-column product, the equation above is equivalent to",
            "That is, adding the eigenvector centralities of the predecessors of \\(i\\) one obtains the eigenvector centrality of \\(i\\) multiplied by \\(\\lambda\\) . In the case of undirected graphs, \\(x\\) also solves the familiar\nright-eigenvector equation \\(Ax = \\lambda x\\) .",
            "By virtue of the Perron\u2013Frobenius theorem [1] , if G is strongly\nconnected there is a unique eigenvector \\(x\\) , and all its entries\nare strictly positive.",
            "If G is not strongly connected there might be several left\neigenvectors associated with \\(\\lambda\\) , and some of their elements\nmight be zero."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph.",
                "max_iter : integer, optional (default=50)": "Maximum number of Arnoldi update iterations allowed.",
                "tol : float, optional (default=0)": "Relative accuracy for eigenvalues (stopping criterion).\nThe default value of 0 implies machine precision.",
                "weight : None or string, optional (default=None)": "If None, all edge weights are considered equal. Otherwise holds the\nname of the edge attribute used as weight. In this measure the\nweight is interpreted as the connection strength."
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of nodes with eigenvector centrality as the value. The\nassociated vector has unit Euclidean norm and the values are\nnonegative."
            },
            "Raises:": {
                "NetworkXPointlessConcept": "If the graph G is the null graph.",
                "ArpackNoConvergence": "When the requested convergence is not obtained. The currently\nconverged eigenvalues and eigenvectors can be found as\neigenvalues and eigenvectors attributes of the exception object."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Eigenvector centrality was introduced by Landau [2] for chess\ntournaments. It was later rediscovered by Wei [3] and then\npopularized by Kendall [4] in the context of sport ranking. Berge\nintroduced a general definition for graphs based on social connections [5] . Bonacich [6] reintroduced again eigenvector centrality and made\nit popular in link analysis. This function computes the left dominant eigenvector, which corresponds\nto adding the centrality of predecessors: this is the usual approach.\nTo add the centrality of successors first reverse the graph with G.reverse() . This implementation uses the SciPysparseeigenvaluesolver (ARPACK)\nto find the largest eigenvalue/eigenvector pair using Arnoldi iterations [7] .",
            "References": "[1]Abraham Berman and Robert J. Plemmons.\n\u201cNonnegative Matrices in the Mathematical Sciences.\u201d\nClassics in Applied Mathematics. SIAM, 1994.  [2]Edmund Landau.\n\u201cZur relativen Wertbemessung der Turnierresultate.\u201d\nDeutsches Wochenschach, 11:366\u2013369, 1895.  [3]Teh-Hsing Wei.\n\u201cThe Algebraic Foundations of Ranking Theory.\u201d\nPhD thesis, University of Cambridge, 1952.  [4]Maurice G. Kendall.\n\u201cFurther contributions to the theory of paired comparisons.\u201d\nBiometrics, 11(1):43\u201362, 1955.https://www.jstor.org/stable/3001479  [5]Claude Berge\n\u201cTh\u00e9orie des graphes et ses applications.\u201d\nDunod, Paris, France, 1958.  [6]Phillip Bonacich.\n\u201cTechnique for analyzing overlapping memberships.\u201d\nSociological Methodology, 4:176\u2013185, 1972.https://www.jstor.org/stable/270732  [7]Arnoldi iteration::https://en.wikipedia.org/wiki/Arnoldi_iteration",
            "Examples": "G=nx.path_graph(4)\ncentrality=nx.eigenvector_centrality_numpy(G)\nprint([f\"{node} {centrality[node]:0.2f}\"fornodeincentrality])\n# ['0 0.37', '1 0.60', '2 0.60', '3 0.37']"
        }
    },
    {
        "Section ID": "algebraic_connectivity",
        "Description": [
            "Returns the algebraic connectivity of an undirected graph.",
            "The algebraic connectivity of a connected undirected graph is the second\nsmallest eigenvalue of its Laplacian matrix."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "An undirected graph.",
                "weight : object, optional (default: None)": "The data key used to determine the weight of each edge. If None, then\neach edge has unit weight.",
                "normalized : bool, optional (default: False)": "Whether the normalized Laplacian matrix is used.",
                "tol : float, optional (default: 1e-8)": "Tolerance of relative residual in eigenvalue computation.",
                "method : string, optional (default: \u2018tracemin_pcg\u2019)": "Method of eigenvalue computation. It must be one of the tracemin\noptions shown below (TraceMIN), \u2018lanczos\u2019 (Lanczos iteration)\nor \u2018lobpcg\u2019 (LOBPCG).The TraceMIN algorithm uses a linear system solver. The following\nvalues allow specifying the solver to be used.ValueSolver\u2018tracemin_pcg\u2019Preconditioned conjugate gradient method\u2018tracemin_lu\u2019LU factorization",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "algebraic_connectivity : float": "Algebraic connectivity."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is directed.",
                "NetworkXError": "If G has less than two nodes."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weights are interpreted by their absolute values. For MultiGraph\u2019s,\nweights of parallel edges are summed. Zero-weighted edges are ignored.",
            "Examples": "For undirected graphs algebraic connectivity can tell us if a graph is connected or notGis connected iffalgebraic_connectivity(G)>0:\nG=nx.complete_graph(5)\nnx.algebraic_connectivity(G)>0\n# True\nG.add_node(10)# G is no longer connected\nnx.algebraic_connectivity(G)>0\n# False"
        }
    },
    {
        "Section ID": "strongly_connected_components",
        "Description": [
            "Generate nodes in strongly connected components of graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "A directed graph."
            },
            "Returns:": {
                "comp : generator of sets": "A generator of sets of nodes, one for each strongly connected\ncomponent of G."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Uses Tarjan\u2019s algorithm[R827335e01166-1]_ with Nuutila\u2019s modifications[R827335e01166-2]_.\nNonrecursive version of algorithm.",
            "References": "[1]Depth-first search and linear graph algorithms, R. Tarjan\nSIAM Journal of Computing 1(2):146-160, (1972).  [2]On finding the strongly connected components in a directed graph.\nE. Nuutila and E. Soisalon-Soinen\nInformation Processing Letters 49(1): 9-14, (1994)..",
            "Examples": "Generate a sorted list of strongly connected components, largest first.\nG=nx.cycle_graph(4,create_using=nx.DiGraph())\nnx.add_cycle(G,[10,11,12])\n[len(c)forcinsorted(nx.strongly_connected_components(G),key=len,reverse=True)]\n# [4, 3]\nIf you only want the largest component, it\u2019s more efficient to\nuse max instead of sort.\nlargest=max(nx.strongly_connected_components(G),key=len)"
        }
    },
    {
        "Section ID": "min_edge_cover",
        "Description": [
            "Returns a set of edges which constitutes\nthe minimum edge cover of the graph.",
            "The smallest edge cover can be found in polynomial time by finding\na maximum matching and extending it greedily so that all nodes\nare covered."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "An undirected bipartite graph.",
                "matching_algorithm : function": "A function that returns a maximum cardinality matching in a\ngiven bipartite graph. The function must take one input, the\ngraphG, and return a dictionary mapping each node to its\nmate. If not specified,hopcroft_karp_matching()will be used. Other possibilities includeeppstein_matching(),"
            },
            "Returns:": {
                "set": "A set of the edges in a minimum edge cover of the graph, given as\npairs of nodes. It contains both the edges(u,v)and(v,u)for given nodesuandvamong the edges of minimum edge cover."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "An edge cover of a graph is a set of edges such that every node of\nthe graph is incident to at least one edge of the set.\nA minimum edge cover is an edge covering of smallest cardinality. Due to its implementation, the worst-case running time of this algorithm\nis bounded by the worst-case running time of the function matching_algorithm ."
        }
    },
    {
        "Section ID": "adjacency_matrix",
        "Description": [
            "Returns adjacency matrix of G."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "nodelist : list, optional": "The rows and columns are ordered according to the nodes in nodelist.\nIf nodelist is None, then the ordering is produced by G.nodes().",
                "dtype : NumPy data-type, optional": "The desired data-type for the array.\nIf None, then the NumPy default is used.",
                "weight : string or None, optional (default=\u2019weight\u2019)": "The edge data key used to provide each value in the matrix.\nIf None, then each edge has weight 1."
            },
            "Returns:": {
                "A : SciPy sparse array": "Adjacency matrix representation of G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For directed graphs, entry i,j corresponds to an edge from i to j. If you want a pure Python adjacency matrix representation try\nnetworkx.convert.to_dict_of_dicts which will return a\ndictionary-of-dictionaries format that can be addressed as a\nsparse matrix. For MultiGraph/MultiDiGraph with parallel edges the weights are summed.\nSee to_numpy_array for other options. The convention used for self-loop edges in graphs is to assign the\ndiagonal matrix entry value to the edge weight attribute\n(or the number 1 if the edge has no weight attribute).  If the\nalternate convention of doubling the edge weight is desired the\nresulting SciPy sparse array can be modified as follows:"
        }
    },
    {
        "Section ID": "null_graph",
        "Description": [
            "Returns the Null graph with no nodes or edges.",
            "See empty_graph for the use of create_using."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "single_source_dijkstra_path_length",
        "Description": [
            "Find shortest weighted path lengths in G from a source node.",
            "Compute the shortest path length between source and all other\nreachable nodes for a weighted graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node label": "Starting node for path",
                "cutoff : integer or float, optional": "Length (sum of edge weights) at which the search is stopped.\nIf cutoff is provided, only return paths with summed weight <= cutoff.",
                "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge."
            },
            "Returns:": {
                "length : dict": "Dict keyed by node to shortest path length from source."
            },
            "Raises:": {
                "NodeNotFound": "Ifsourceis not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The weight function can be used to hide edges by returning None.\nSo weight=lambdau,v,d:1ifd['color']==\"red\"elseNone will find the shortest red path.",
            "Examples": "G=nx.path_graph(5)\nlength=nx.single_source_dijkstra_path_length(G,0)\nlength[4]\n# 4\nfornodein[0,1,2,3,4]:\nprint(f\"{node}: {length[node]}\")\n# 0: 0\n# 1: 1\n# 2: 2\n# 3: 3\n# 4: 4"
        }
    },
    {
        "Section ID": "effective_graph_resistance",
        "Description": [
            "Returns the Effective graph resistance of G.",
            "Also known as the Kirchhoff index.",
            "The effective graph resistance is defined as the sum\nof the resistance distance of every node pair in G [1] .",
            "If weight is not provided, then a weight of 1 is used for all edges.",
            "The effective graph resistance of a disconnected graph is infinite."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A graph",
                "weight : string or None, optional (default=None)": "The edge data key used to compute the effective graph resistance.\nIf None, then each edge has weight 1.",
                "invert_weight : boolean (default=True)": "Proper calculation of resistance distance requires building the\nLaplacian matrix with the reciprocal of the weight. Not required\nif the weight is already inverted. Weight cannot be zero."
            },
            "Returns:": {
                "RG : float": "The effective graph resistance ofG."
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis a directed graph.",
                "NetworkXError": "IfGdoes not contain any nodes."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The implementation is based on Theorem 2.2 in [2] . Self-loops are ignored.\nMulti-edges are contracted in one edge with weight equal to the harmonic sum of the weights.",
            "References": "[1]Wolfram\n\u201cKirchhoff Index.\u201dhttps://mathworld.wolfram.com/KirchhoffIndex.html  [2]W. Ellens, F. M. Spieksma, P. Van Mieghem, A. Jamakovic, R. E. Kooij.\nEffective graph resistance.\nLin. Alg. Appl. 435:2491-2506, 2011.",
            "Examples": "G=nx.Graph([(1,2),(1,3),(1,4),(3,4),(3,5),(4,5)])\nround(nx.effective_graph_resistance(G),10)\n# 10.25"
        }
    },
    {
        "Section ID": "is_aperiodic",
        "Description": [
            "Returns True if G is aperiodic.",
            "A directed graph is aperiodic if there is no integer k > 1 that\ndivides the length of every cycle in the graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX DiGraph": "A directed graph"
            },
            "Returns:": {
                "bool": "True if the graph is aperiodic False otherwise"
            },
            "Raises:": {
                "NetworkXError": "IfGis not directed"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This uses the method outlined in [1] , which runs in \\(O(m)\\) time\ngiven \\(m\\) edges in G . Note that a graph is not aperiodic if it is\nacyclic as every integer trivial divides length 0 cycles.",
            "References": "[1]Jarvis, J. P.; Shier, D. R. (1996),\n\u201cGraph-theoretic analysis of finite Markov chains,\u201d\nin Shier, D. R.; Wallenius, K. T., Applied Mathematical Modeling:\nA Multidisciplinary Approach, CRC Press.",
            "Examples": "A graph consisting of one cycle, the length of which is 2. Thereforek=2divides the length of every cycle in the graph and thus the graph\nisnot aperiodic:\nDG=nx.DiGraph([(1,2),(2,1)])\nnx.is_aperiodic(DG)\n# False\nA graph consisting of two cycles: one of length 2 and the other of length 3.\nThe cycle lengths are coprime, so there is no single value of k wherek>1that divides each cycle length and therefore the graph isaperiodic:\nDG=nx.DiGraph([(1,2),(2,3),(3,1),(1,4),(4,1)])\nnx.is_aperiodic(DG)\n# True\nA graph consisting of two cycles: one of length 2 and the other of length 4.\nThe lengths of the cycles share a common factork=2, and therefore\nthe graph isnot aperiodic:\nDG=nx.DiGraph([(1,2),(2,1),(3,4),(4,5),(5,6),(6,3)])\nnx.is_aperiodic(DG)\n# False\nAn acyclic graph, therefore the graph isnot aperiodic:\nDG=nx.DiGraph([(1,2),(2,3)])\nnx.is_aperiodic(DG)\n# False"
        }
    },
    {
        "Section ID": "adamic_adar_index",
        "Description": [
            "Compute the Adamic-Adar index of all node pairs in ebunch.",
            "Adamic-Adar index of u and v is defined as",
            "where \\(\\Gamma(u)\\) denotes the set of neighbors of \\(u\\) .\nThis index leads to zero-division for nodes only connected via self-loops.\nIt is intended to be used when no self-loops are present."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "NetworkX undirected graph.",
                "ebunch : iterable of node pairs, optional (default = None)": "Adamic-Adar index will be computed for each pair of nodes given\nin the iterable. The pairs must be given as 2-tuples (u, v)\nwhere u and v are nodes in the graph. If ebunch is None then all\nnonexistent edges in the graph will be used.\nDefault value: None."
            },
            "Returns:": {
                "piter : iterator": "An iterator of 3-tuples in the form (u, v, p) where (u, v) is a\npair of nodes and p is their Adamic-Adar index."
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis aDiGraph, aMultigraphor aMultiDiGraph.",
                "NodeNotFound": "Ifebunchhas a node that is not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]D. Liben-Nowell, J. Kleinberg.\nThe Link Prediction Problem for Social Networks (2004).http://www.cs.cornell.edu/home/kleinber/link-pred.pdf",
            "Examples": "G=nx.complete_graph(5)\npreds=nx.adamic_adar_index(G,[(0,1),(2,3)])\nforu,v,pinpreds:\nprint(f\"({u}, {v}) -> {p:.8f}\")\n# (0, 1) -> 2.16404256\n# (2, 3) -> 2.16404256"
        }
    },
    {
        "Section ID": "incremental_closeness_centrality",
        "Description": [
            "Incremental closeness centrality for nodes.",
            "Compute closeness centrality for nodes using level-based work filtering\nas described in Incremental Algorithms for Closeness Centrality by Sariyuce et al.",
            "Level-based work filtering detects unnecessary updates to the closeness\ncentrality and filters them out.",
            "\u2014\nFrom \u201cIncremental Algorithms for Closeness Centrality\u201d:",
            "Theorem 1: Let \\(G = (V, E)\\) be a graph and u and v be two vertices in V\nsuch that there is no edge (u, v) in E. Let \\(G' = (V, E \\cup uv)\\) Then \\(cc[s] = cc'[s]\\) if and only if \\(\\left|dG(s, u) - dG(s, v)\\right| \\leq 1\\) .",
            "Where \\(dG(u, v)\\) denotes the length of the shortest path between\ntwo vertices u, v in a graph G, cc[s] is the closeness centrality for a\nvertex s in V, and cc\u2019[s] is the closeness centrality for a\nvertex s in V, with the (u, v) edge added.\n\u2014",
            "We use Theorem 1 to filter out updates when adding or removing an edge.\nWhen adding an edge (u, v), we compute the shortest path lengths from all\nother nodes to u and to v before the node is added. When removing an edge,\nwe compute the shortest path lengths after the edge is removed. Then we\napply Theorem 1 to use previously computed closeness centrality for nodes\nwhere \\(\\left|dG(s, u) - dG(s, v)\\right| \\leq 1\\) . This works only for\nundirected, unweighted graphs; the distance argument is not supported.",
            "Closeness centrality [1] of a node u is the reciprocal of the\nsum of the shortest path distances from u to all n-1 other nodes.\nSince the sum of distances depends on the number of nodes in the\ngraph, closeness is normalized by the sum of minimum possible\ndistances n-1 .",
            "where d(v,u) is the shortest-path distance between v and u ,\nand n is the number of nodes in the graph.",
            "Notice that higher values of closeness indicate higher centrality."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "edge : tuple": "The modified edge (u, v) in the graph.",
                "prev_cc : dictionary": "The previous closeness centrality for all nodes in the graph.",
                "insertion : bool, optional": "If True (default) the edge was inserted, otherwise it was deleted from the graph.",
                "wf_improved : bool, optional (default=True)": "If True, scale by the fraction of nodes reachable. This gives the\nWasserman and Faust improved formula. For single component graphs\nit is the same as the original formula."
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of nodes with closeness centrality as the value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The closeness centrality is normalized to (n-1)/(|G|-1) where n is the number of nodes in the connected part of graph\ncontaining the node.  If the graph is not completely connected,\nthis algorithm computes the closeness centrality for each\nconnected part separately.",
            "References": "[1]Freeman, L.C., 1979. Centrality in networks: I.\nConceptual clarification.  Social Networks 1, 215\u2013239.https://doi.org/10.1016/0378-8733(78)90021-7  [2]Sariyuce, A.E. ; Kaya, K. ; Saule, E. ; Catalyiirek, U.V. Incremental\nAlgorithms for Closeness Centrality. 2013 IEEE International Conference on Big Datahttp://sariyuce.com/papers/bigdata13.pdf"
        }
    },
    {
        "Section ID": "spectral_graph_forge",
        "Description": [
            "Returns a random simple graph with spectrum resembling that of G",
            "This algorithm, called Spectral Graph Forge (SGF), computes the\neigenvectors of a given graph adjacency matrix, filters them and\nbuilds a random graph with a similar eigenstructure.\nSGF has been proved to be particularly useful for synthesizing\nrealistic social networks and it can also be used to anonymize\ngraph sensitive data."
        ],
        "Field List": {
            "Parameters:": {
                "G : Graph": "",
                "alpha : float": "Ratio representing the percentage of eigenvectors of G to consider,\nvalues in [0,1].",
                "transformation : string, optional": "Represents the intended matrix linear transformation, possible values\nare \u2018identity\u2019 and \u2018modularity\u2019",
                "seed : integer, random_state, or None (default)": "Indicator of numpy random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "H : Graph": "A graph with a similar eigenvector structure of the input one."
            },
            "Raises:": {
                "NetworkXError": "If transformation has a value different from \u2018identity\u2019 or \u2018modularity\u2019"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Spectral Graph Forge (SGF) generates a random simple graph resembling the\nglobal properties of the given one.\nIt leverages the low-rank approximation of the associated adjacency matrix\ndriven by the alpha precision parameter.\nSGF preserves the number of nodes of the input graph and their ordering.\nThis way, nodes of output graphs resemble the properties of the input one\nand attributes can be directly mapped. It considers the graph adjacency matrices which can optionally be\ntransformed to other symmetric real matrices (currently transformation\noptions include identity and modularity ).\nThe modularity transformation, in the sense of Newman\u2019s modularity matrix\nallows the focusing on community structure related properties of the graph. SGF applies a low-rank approximation whose fixed rank is computed from the\nratio alpha of the input graph adjacency matrix dimension.\nThis step performs a filtering on the input eigenvectors similar to the low\npass filtering common in telecommunications. The filtered values (after truncation) are used as input to a Bernoulli\nsampling for constructing a random adjacency matrix.",
            "References": "[1]L. Baldesi, C. T. Butts, A. Markopoulou, \u201cSpectral Graph Forge:\nGraph Generation Targeting Modularity\u201d, IEEE Infocom, \u201818.https://arxiv.org/abs/1801.01715  [2]M. Newman, \u201cNetworks: an introduction\u201d, Oxford university press,\n2010",
            "Examples": "G=nx.karate_club_graph()\nH=nx.spectral_graph_forge(G,0.3)"
        }
    },
    {
        "Section ID": "maybe_regular_expander",
        "Description": [
            "Utility for creating a random regular expander.",
            "Returns a random \\(d\\) -regular graph on \\(n\\) nodes which is an expander\ngraph with very good probability."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes.",
                "d : int": "The degree of each node.",
                "create_using : Graph Instance or Constructor": "Indicator of type of graph to return.\nIf a Graph-type instance, then clear and use it.\nIf a constructor, call it to create an empty graph.\nUse the Graph constructor by default.",
                "max_tries : int. (default: 100)": "The number of allowed loops when generating each independent cycle",
                "seed : (default: None)": "Seed used to set random number generation state. See :ref`Randomness<randomness>`."
            },
            "Returns:": {
                "G : graph": "The constructed undirected graph."
            },
            "Raises:": {
                "NetworkXError": "If\\(d % 2 != 0\\)as the degree must be even.\nIf\\(n - 1\\)is less than :math:` 2d ` as the graph is complete at most.\nIf max_tries is reached"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The nodes are numbered from \\(0\\) to \\(n - 1\\) . The graph is generated by taking \\(d / 2\\) random independent cycles. Joel Friedman proved that in this model the resulting\ngraph is an expander with probability \\(1 - O(n^{-\\tau})\\) where \\(\\tau = \\lceil (\\sqrt{d - 1}) / 2 \\rceil - 1\\) . [1]",
            "References": "[1]Joel Friedman,\nA Proof of Alon\u2019s Second Eigenvalue Conjecture and Related Problems, 2004https://arxiv.org/abs/cs/0405020",
            "Examples": "G=nx.maybe_regular_expander(n=200,d=6,seed=8020)"
        }
    },
    {
        "Section ID": "parse_pajek",
        "Description": [
            "Parse Pajek format graph from string or iterable."
        ],
        "Field List": {
            "Parameters:": {
                "lines : string or iterable": "Data in Pajek format."
            },
            "Returns:": {
                "G : NetworkX graph": ""
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "core_number",
        "Description": [
            "Returns the core number for each node.",
            "A k-core is a maximal subgraph that contains nodes of degree k or more.",
            "The core number of a node is the largest value k of a k-core containing\nthat node."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "An undirected or directed graph"
            },
            "Returns:": {
                "core_number : dictionary": "A dictionary keyed by node to the core number."
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis a multigraph or contains self loops."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For directed graphs the node degree is defined to be the\nin-degree + out-degree.",
            "References": "[1]An O(m) Algorithm for Cores Decomposition of Networks\nVladimir Batagelj and Matjaz Zaversnik, 2003.https://arxiv.org/abs/cs.DS/0310049",
            "Examples": "degrees=[0,1,2,2,2,2,3]\nH=nx.havel_hakimi_graph(degrees)\nnx.core_number(H)\n# {0: 1, 1: 2, 2: 2, 3: 2, 4: 1, 5: 2, 6: 0}\nG=nx.DiGraph()\nG.add_edges_from([(1,2),(2,1),(2,3),(2,4),(3,4),(4,3)])\nnx.core_number(G)\n# {1: 2, 2: 2, 3: 2, 4: 2}"
        }
    },
    {
        "Section ID": "biconnected_components",
        "Description": [
            "Returns a generator of sets of nodes, one set for each biconnected\ncomponent of the graph",
            "Biconnected components are maximal subgraphs such that the removal of a\nnode (and all edges incident on that node) will not disconnect the\nsubgraph. Note that nodes may be part of more than one biconnected\ncomponent.  Those nodes are articulation points, or cut vertices.  The\nremoval of articulation points will increase the number of connected\ncomponents of the graph.",
            "Notice that by convention a dyad is considered a biconnected component."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "An undirected graph."
            },
            "Returns:": {
                "nodes : generator": "Generator of sets of nodes, one set for each biconnected component."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the input graph is not undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The algorithm to find articulation points and biconnected\ncomponents is implemented using a non-recursive depth-first-search\n(DFS) that keeps track of the highest level that back edges reach\nin the DFS tree.  A node n is an articulation point if, and only\nif, there exists a subtree rooted at n such that there is no\nback edge from any successor of n that links to a predecessor of n in the DFS tree.  By keeping track of all the edges traversed\nby the DFS we can obtain the biconnected components because all\nedges of a bicomponent will be traversed consecutively between\narticulation points.",
            "References": "[1]Hopcroft, J.; Tarjan, R. (1973).\n\u201cEfficient algorithms for graph manipulation\u201d.\nCommunications of the ACM 16: 372\u2013378. doi:10.1145/362248.362272",
            "Examples": "G=nx.lollipop_graph(5,1)\nprint(nx.is_biconnected(G))\n# False\nbicomponents=list(nx.biconnected_components(G))\nlen(bicomponents)\n# 2\nG.add_edge(0,5)\nprint(nx.is_biconnected(G))\n# True\nbicomponents=list(nx.biconnected_components(G))\nlen(bicomponents)\n# 1\nYou can generate a sorted list of biconnected components, largest\nfirst, using sort.\nG.remove_edge(0,5)\n[len(c)forcinsorted(nx.biconnected_components(G),key=len,reverse=True)]\n# [5, 2]\nIf you only want the largest connected component, it\u2019s more\nefficient to use max instead of sort.\nGc=max(nx.biconnected_components(G),key=len)\nTo create the components as subgraphs use:(G.subgraph(c).copy()forcinbiconnected_components(G))"
        }
    },
    {
        "Section ID": "directed_edge_swap",
        "Description": [
            "Swap three edges in a directed graph while keeping the node degrees fixed.",
            "A directed edge swap swaps three edges such that a -> b -> c -> d becomes\na -> c -> b -> d. This pattern of swapping allows all possible states with the\nsame in- and out-degree distribution in a directed graph to be reached.",
            "If the swap would create parallel edges (e.g. if a -> c already existed in the\nprevious example), another attempt is made to find a suitable trio of edges."
        ],
        "Field List": {
            "Parameters:": {
                "G : DiGraph": "A directed graph",
                "nswap : integer (optional, default=1)": "Number of three-edge (directed) swaps to perform",
                "max_tries : integer (optional, default=100)": "Maximum number of attempts to swap edges",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "G : DiGraph": "The graph after the edges are swapped."
            },
            "Raises:": {
                "NetworkXError": "IfGis not directed, or\nIf nswap > max_tries, or\nIf there are fewer than 4 nodes or 3 edges inG.",
                "NetworkXAlgorithmError": "If the number of swap attempts exceedsmax_triesbeforenswapswaps are made"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Does not enforce any connectivity constraints. The graph G is modified in place. A later swap is allowed to undo a previous swap.",
            "References": "[1]Erd\u0151s, P\u00e9ter L., et al. \u201cA Simple Havel-Hakimi Type Algorithm to Realize\nGraphical Degree Sequences of Directed Graphs.\u201d ArXiv:0905.4913 [Math],\nJan. 2010. https://doi.org/10.48550/arXiv.0905.4913.\nPublished  2010 in Elec. J. Combinatorics (17(1)). R66.\nhttp://www.combinatorics.org/Volume_17/PDF/v17i1r66.pdf  [2]\u201cCombinatorics - Reaching All Possible Simple Directed Graphs with a given\nDegree Sequence with 2-Edge Swaps.\u201d Mathematics Stack Exchange,https://math.stackexchange.com/questions/22272/. Accessed 30 May 2022."
        }
    },
    {
        "Section ID": "read_adjlist",
        "Description": [
            "Read graph in adjacency list format from path."
        ],
        "Field List": {
            "Parameters:": {
                "path : string or file": "Filename or file handle to read.\nFilenames ending in .gz or .bz2 will be uncompressed.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated.",
                "nodetype : Python type, optional": "Convert nodes to this type.",
                "comments : string, optional": "Marker for comment lines",
                "delimiter : string, optional": "Separator for node labels.  The default is whitespace."
            },
            "Returns:": {
                "G: NetworkX graph": "The graph corresponding to the lines in adjacency list format."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This format does not store graph or node data.",
            "Examples": "G=nx.path_graph(4)\nnx.write_adjlist(G,\"test.adjlist\")\nG=nx.read_adjlist(\"test.adjlist\")\nThe path can be a filehandle or a string with the name of the file. If a\nfilehandle is provided, it has to be opened in \u2018rb\u2019 mode.\nfh=open(\"test.adjlist\",\"rb\")\nG=nx.read_adjlist(fh)\nFilenames ending in .gz or .bz2 will be compressed.\nnx.write_adjlist(G,\"test.adjlist.gz\")\nG=nx.read_adjlist(\"test.adjlist.gz\")\nThe optional nodetype is a function to convert node strings to nodetype.\nFor example\nG=nx.read_adjlist(\"test.adjlist\",nodetype=int)\nwill attempt to convert all nodes to integer type.\nSince nodes must be hashable, the function nodetype must return hashable\ntypes (e.g. int, float, str, frozenset - or tuples of those, etc.)\nThe optional create_using parameter indicates the type of NetworkX graph\ncreated.  The default isnx.Graph, an undirected graph.\nTo read the data as a directed graph use\nG=nx.read_adjlist(\"test.adjlist\",create_using=nx.DiGraph)"
        }
    },
    {
        "Section ID": "generate_edgelist",
        "Description": [
            "Generate a single line of the bipartite graph G in edge list format."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "The graph is assumed to have node attributepartset to 0,1 representing\nthe two graph parts",
                "delimiter : string, optional": "Separator for node labels",
                "data : bool or list of keys": "If False generate no edge data.  If True use a dictionary\nrepresentation of edge data.  If a list of keys use a list of data\nvalues corresponding to the keys."
            },
            "Returns:": {
                "lines : string": "Lines of data in adjlist format."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "fromnetworkx.algorithmsimportbipartite\nG=nx.path_graph(4)\nG.add_nodes_from([0,2],bipartite=0)\nG.add_nodes_from([1,3],bipartite=1)\nG[1][2][\"weight\"]=3\nG[2][3][\"capacity\"]=12\nforlineinbipartite.generate_edgelist(G,data=False):\nprint(line)\n# 0 1\n# 2 1\n# 2 3\nforlineinbipartite.generate_edgelist(G):\nprint(line)\n# 0 1 {}\n# 2 1 {'weight': 3}\n# 2 3 {'capacity': 12}\nforlineinbipartite.generate_edgelist(G,data=[\"weight\"]):\nprint(line)\n# 0 1\n# 2 1 3\n# 2 3"
        }
    },
    {
        "Section ID": "steiner_tree",
        "Description": [
            "Return an approximation to the minimum Steiner tree of a graph.",
            "The minimum Steiner tree of G w.r.t a set of terminal_nodes (also S )\nis a tree within G that spans those nodes and has minimum size (sum of\nedge weights) among all such trees.",
            "The approximation algorithm is specified with the method keyword\nargument. All three available algorithms produce a tree whose weight is\nwithin a (2-(2/l)) factor of the weight of the optimal Steiner tree,\nwhere l is the minimum number of leaf nodes across all possible Steiner\ntrees."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "terminal_nodes : list": "A list of terminal nodes for which minimum steiner tree is\nto be found.",
                "weight : string (default = \u2018weight\u2019)": "Use the edge attribute specified by this string as the edge weight.\nAny edge attribute not present defaults to 1.",
                "method : string, optional (default = \u2018mehlhorn\u2019)": "The algorithm to use to approximate the Steiner tree.\nSupported options: \u2018kou\u2019, \u2018mehlhorn\u2019.\nOther inputs produce a ValueError."
            },
            "Returns:": {
                "NetworkX graph": "Approximation to the minimum steiner tree ofGinduced byterminal_nodes."
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis directed.",
                "ValueError": "If the specifiedmethodis not supported."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For multigraphs, the edge between two nodes with minimum weight is the\nedge put into the Steiner tree.",
            "References": "[1]Steiner_tree_problem on Wikipedia.https://en.wikipedia.org/wiki/Steiner_tree_problem  [2]Kou, L., G. Markowsky, and L. Berman. 1981.\n\u2018A Fast Algorithm for Steiner Trees\u2019.\nActa Informatica 15 (2): 141\u201345.https://doi.org/10.1007/BF00288961.  [3]Mehlhorn, Kurt. 1988.\n\u2018A Faster Approximation Algorithm for the Steiner Problem in Graphs\u2019.\nInformation Processing Letters 27 (3): 125\u201328.https://doi.org/10.1016/0020-0190(88)90066-X."
        }
    },
    {
        "Section ID": "is_k_edge_connected",
        "Description": [
            "Tests to see if a graph is k-edge-connected.",
            "Is it impossible to disconnect the graph by removing fewer than k edges?\nIf so, then G is k-edge-connected."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "An undirected graph.",
                "k : integer": "edge connectivity to test for"
            },
            "Returns:": {
                "boolean": "True if G is k-edge-connected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.barbell_graph(10,0)\nnx.is_k_edge_connected(G,k=1)\n# True\nnx.is_k_edge_connected(G,k=2)\n# False"
        }
    },
    {
        "Section ID": "spectral_bisection",
        "Description": [
            "Bisect the graph using the Fiedler vector.",
            "This method uses the Fiedler vector to bisect a graph.\nThe partition is defined by the nodes which are associated with\neither positive or negative values in the vector."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "",
                "weight : str, optional (default: weight)": "The data key used to determine the weight of each edge. If None, then\neach edge has unit weight.",
                "normalized : bool, optional (default: False)": "Whether the normalized Laplacian matrix is used.",
                "tol : float, optional (default: 1e-8)": "Tolerance of relative residual in eigenvalue computation.",
                "method : string, optional (default: \u2018tracemin_pcg\u2019)": "Method of eigenvalue computation. It must be one of the tracemin\noptions shown below (TraceMIN), \u2018lanczos\u2019 (Lanczos iteration)\nor \u2018lobpcg\u2019 (LOBPCG).The TraceMIN algorithm uses a linear system solver. The following\nvalues allow specifying the solver to be used.ValueSolver\u2018tracemin_pcg\u2019Preconditioned conjugate gradient method\u2018tracemin_lu\u2019LU factorization",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "bisection : tuple of sets": "Sets with the bisection of nodes"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]M. E. J Newman \u2018Networks: An Introduction\u2019, pages 364-370\nOxford University Press 2011.",
            "Examples": "G=nx.barbell_graph(3,0)\nnx.spectral_bisection(G)\n# ({0, 1, 2}, {3, 4, 5})"
        }
    },
    {
        "Section ID": "tree_all_pairs_lowest_common_ancestor",
        "Description": [
            "Yield the lowest common ancestor for sets of pairs in a tree."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX directed graph (must be a tree)": "",
                "root : node, optional (default: None)": "The root of the subtree to operate on.\nIf None, assume the entire graph has exactly one source and use that.",
                "pairs : iterable or iterator of pairs of nodes, optional (default: None)": "The pairs of interest. If None, Defaults to all pairs of nodes\nunderrootthat have a lowest common ancestor."
            },
            "Returns:": {
                "lcas : generator of tuples((u,v),lca)whereuandvare nodes": "inpairsandlcais their lowest common ancestor."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Only defined on non-null trees represented with directed edges from\nparents to children. Uses Tarjan\u2019s off-line lowest-common-ancestors\nalgorithm. Runs in time \\(O(4 \\times (V + E + P))\\) time, where 4 is the largest\nvalue of the inverse Ackermann function likely to ever come up in actual\nuse, and \\(P\\) is the number of pairs requested (or \\(V^2\\) if all are needed). Tarjan, R. E. (1979), \u201cApplications of path compression on balanced trees\u201d,\nJournal of the ACM 26 (4): 690-715, doi:10.1145/322154.322161.",
            "Examples": "importpprint\nG=nx.DiGraph([(1,3),(2,4),(1,2)])\npprint.pprint(dict(nx.tree_all_pairs_lowest_common_ancestor(G)))\n# {(1, 1): 1,\n#  (2, 1): 1,\n#  (2, 2): 2,\n#  (3, 1): 1,\n#  (3, 2): 1,\n#  (3, 3): 3,\n#  (3, 4): 1,\n#  (4, 1): 1,\n#  (4, 2): 2,\n#  (4, 4): 4}\nWe can also usepairsargument to specify the pairs of nodes for which we\nwant to compute lowest common ancestors. Here is an example:\ndict(nx.tree_all_pairs_lowest_common_ancestor(G,pairs=[(1,4),(2,3)]))\n# {(2, 3): 1, (1, 4): 1}"
        }
    },
    {
        "Section ID": "is_digraphical",
        "Description": [
            "Returns True if some directed graph can realize the in- and out-degree\nsequences."
        ],
        "Field List": {
            "Parameters:": {
                "in_sequence : list or iterable container": "A sequence of integer node in-degrees",
                "out_sequence : list or iterable container": "A sequence of integer node out-degrees"
            },
            "Returns:": {
                "valid : bool": "True if in and out-sequences are digraphic False if not."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm is from Kleitman and Wang [1] .\nThe worst case runtime is \\(O(s \\times \\log n)\\) where \\(s\\) and \\(n\\) are the\nsum and length of the sequences respectively.",
            "References": "[1]D.J. Kleitman and D.L. Wang\nAlgorithms for Constructing Graphs and Digraphs with Given Valences\nand Factors, Discrete Mathematics, 6(1), pp. 79-88 (1973)",
            "Examples": "G=nx.DiGraph([(1,2),(1,3),(2,3),(3,4),(4,2),(5,1),(5,4)])\nin_seq=(dforn,dinG.in_degree())\nout_seq=(dforn,dinG.out_degree())\nnx.is_digraphical(in_seq,out_seq)\n# True\nTo test a non-digraphical scenario:\n>>> in_seq_list = [d for n, d in G.in_degree()]\n>>> in_seq_list[-1] += 1\n>>> nx.is_digraphical(in_seq_list, out_seq)\nFalse"
        }
    },
    {
        "Section ID": "panther_similarity",
        "Description": [
            "Returns the Panther similarity of nodes in the graph G to node v .",
            "Panther is a similarity metric that says \u201ctwo objects are considered\nto be similar if they frequently appear on the same paths.\u201d [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A NetworkX graph",
                "source : node": "Source node for which to find the topksimilar other nodes",
                "k : int (default = 5)": "The number of most similar nodes to return.",
                "path_length : int (default = 5)": "How long the randomly generated paths should be (Tin[1])",
                "c : float (default = 0.5)": "A universal positive constant used to scale the number\nof sample random paths to generate.",
                "delta : float (default = 0.1)": "The probability that the similarity\\(S\\)is not an epsilon-approximation to (R, phi),\nwhere\\(R\\)is the number of random paths and\\(\\phi\\)is the probability\nthat an element sampled from a set\\(A \\subseteq D\\), where\\(D\\)is the domain.",
                "eps : float or None (default = None)": "The error bound. Per[1], a good value issqrt(1/|E|). Therefore,\nif no value is provided, the recommended computed value will be used.",
                "weight : string or None, optional (default=\u201dweight\u201d)": "The name of an edge attribute that holds the numerical value\nused as a weight. If None then each edge has weight 1."
            },
            "Returns:": {
                "similarity : dictionary": "Dictionary of nodes to similarity scores (as floats). Note:\nthe self-similarity (i.e.,v) will not be included in\nthe returned dictionary. So, fork=5, a dictionary of\ntop 4 nodes and their similarity scores will be returned."
            },
            "Raises:": {
                "NetworkXUnfeasible": "Ifsourceis an isolated node.",
                "NodeNotFound": "Ifsourceis not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The isolated nodes in G are ignored.",
            "References": "[1](1,2,3)Zhang, J., Tang, J., Ma, C., Tong, H., Jing, Y., & Li, J.\nPanther: Fast top-k similarity search on large networks.\nIn Proceedings of the ACM SIGKDD International Conference\non Knowledge Discovery and Data Mining (Vol. 2015-August, pp. 1445\u20131454).\nAssociation for Computing Machinery.https://doi.org/10.1145/2783258.2783267.",
            "Examples": "G=nx.star_graph(10)\nsim=nx.panther_similarity(G,0)"
        }
    },
    {
        "Section ID": "degree_mixing_matrix",
        "Description": [
            "Returns mixing matrix for attribute."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "NetworkX graph object.",
                "x: string (\u2018in\u2019,\u2019out\u2019)": "The degree type for source node (directed graphs only).",
                "y: string (\u2018in\u2019,\u2019out\u2019)": "The degree type for target node (directed graphs only).",
                "nodes: list or iterable (optional)": "Build the matrix using only nodes in container.\nThe default is all nodes.",
                "weight: string or None, optional (default=None)": "The edge attribute that holds the numerical value used\nas a weight.  If None, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node.",
                "normalized : bool (default=True)": "Return counts if False or probabilities if True.",
                "mapping : dictionary, optional": "Mapping from node degree to integer index in matrix.\nIf not specified, an arbitrary ordering will be used."
            },
            "Returns:": {
                "m: numpy array": "Counts, or joint probability, of occurrence of node degree."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Definitions of degree mixing matrix vary on whether the matrix\nshould include rows for degree values that don\u2019t arise. Here we\ndo not include such empty-rows. But you can force them to appear\nby inputting a mapping that includes those values. See examples.",
            "Examples": "G=nx.star_graph(3)\nmix_mat=nx.degree_mixing_matrix(G)\nmix_mat\n# array([[0. , 0.5],\n#        [0.5, 0. ]])\nIf you want every possible degree to appear as a row, even if no nodes\nhave that degree, usemappingas follows,\nmax_degree=max(degforn,deginG.degree)\nmapping={x:xforxinrange(max_degree+1)}# identity mapping\nmix_mat=nx.degree_mixing_matrix(G,mapping=mapping)\nmix_mat\n# array([[0. , 0. , 0. , 0. ],\n#        [0. , 0. , 0. , 0.5],\n#        [0. , 0. , 0. , 0. ],\n#        [0. , 0.5, 0. , 0. ]])"
        }
    },
    {
        "Section ID": "chordless_cycles",
        "Description": [
            "Find simple chordless cycles of a graph.",
            "A simplecycle is a closed path where no node appears twice.  In a simple\ncycle, a chord is an additional edge between two nodes in the cycle.  A chordlesscycle is a simple cycle without chords.  Said differently, a\nchordless cycle is a cycle C in a graph G where the number of edges in the\ninduced graph G[C] is equal to the length of C .",
            "Note that some care must be taken in the case that G is not a simple graph\nnor a simple digraph.  Some authors limit the definition of chordless cycles\nto have a prescribed minimum length; we do not.",
            "In a directed graph, two chordless cycles are distinct if they are not\ncyclic permutations of each other.  In an undirected graph, two chordless\ncycles are distinct if they are not cyclic permutations of each other nor of\nthe other\u2019s reversal.",
            "Optionally, the cycles are bounded in length.",
            "We use an algorithm strongly inspired by that of Dias et al [1] .  It has\nbeen modified in the following ways:"
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX DiGraph": "A directed graph",
                "length_bound : int or None, optional (default=None)": "If length_bound is an int, generate all simple cycles of G with length at\nmost length_bound.  Otherwise, generate all simple cycles of G."
            },
            "Yields:": {
                "list of nodes": "Each cycle is represented by a list of nodes along the cycle."
            },
            "Raises:": {
                "ValueError": "when length_bound < 0."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "When length_bound is None, and the graph is simple, the time complexity is \\(O((n+e)(c+1))\\) for \\(n\\) nodes, \\(e\\) edges and \\(c\\) chordless cycles.",
            "References": "[1]Efficient enumeration of chordless cycles\nE. Dias and D. Castonguay and H. Longo and W.A.R. Jradihttps://arxiv.org/abs/1309.1051",
            "Examples": "sorted(list(nx.chordless_cycles(nx.complete_graph(4))))\n# [[1, 0, 2], [1, 0, 3], [2, 0, 3], [2, 1, 3]]"
        }
    },
    {
        "Section ID": "bipartite_layout",
        "Description": [
            "Position nodes in two straight lines."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph or list of nodes": "A position will be assigned to every node in G.",
                "nodes : list or container": "Nodes in one node set of the bipartite graph.\nThis set will be placed on left or top.",
                "align : string (default=\u2019vertical\u2019)": "The alignment of nodes. Vertical or horizontal.",
                "scale : number (default: 1)": "Scale factor for positions.",
                "center : array-like or None": "Coordinate pair around which to center the layout.",
                "aspect_ratio : number (default=4/3):": "The ratio of the width to the height of the layout."
            },
            "Returns:": {
                "pos : dict": "A dictionary of positions keyed by node."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm currently only works in two dimensions and does not\ntry to minimize edge crossings.",
            "Examples": "G=nx.bipartite.gnmk_random_graph(3,5,10,seed=123)\ntop=nx.bipartite.sets(G)[0]\npos=nx.bipartite_layout(G,top)"
        }
    },
    {
        "Section ID": "degree_centrality",
        "Description": [
            "Compute the degree centrality for nodes in a bipartite network.",
            "The degree centrality for a node v is the fraction of nodes\nconnected to it."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A bipartite network",
                "nodes : list or container": "Container with all nodes in one bipartite node set."
            },
            "Returns:": {
                "centrality : dictionary": "Dictionary keyed by node with bipartite degree centrality as the value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The nodes input parameter must contain all nodes in one bipartite node set,\nbut the dictionary returned contains all nodes from both bipartite node\nsets. See bipartitedocumentation for further details on how bipartite graphs are handled in NetworkX. For unipartite networks, the degree centrality values are\nnormalized by dividing by the maximum possible degree (which is n-1 where n is the number of nodes in G). In the bipartite case, the maximum possible degree of a node in a\nbipartite node set is the number of nodes in the opposite node set [1] .  The degree centrality for a node v in the bipartite\nsets U with n nodes and V with m nodes is",
            "References": "[1]Borgatti, S.P. and Halgin, D. In press. \u201cAnalyzing Affiliation\nNetworks\u201d. In Carrington, P. and Scott, J. (eds) The Sage Handbook\nof Social Network Analysis. Sage Publications.https://dx.doi.org/10.4135/9781446294413.n28",
            "Examples": "G=nx.wheel_graph(5)\ntop_nodes={0,1,2}\nnx.bipartite.degree_centrality(G,nodes=top_nodes)\n# {0: 2.0, 1: 1.5, 2: 1.5, 3: 1.0, 4: 1.0}"
        }
    },
    {
        "Section ID": "bethe_hessian_matrix",
        "Description": [
            "Returns the Bethe Hessian matrix of G.",
            "The Bethe Hessian is a family of matrices parametrized by r, defined as\nH(r) = (r^2 - 1) I - r A + D where A is the adjacency matrix, D is the\ndiagonal matrix of node degrees, and I is the identify matrix. It is equal\nto the graph laplacian when the regularizer r = 1.",
            "The default choice of regularizer should be the ratio [2]"
        ],
        "Field List": {
            "Parameters:": {
                "G : Graph": "A NetworkX graph",
                "r : float": "Regularizer parameter",
                "nodelist : list, optional": "The rows and columns are ordered according to the nodes in nodelist.\nIf nodelist is None, then the ordering is produced byG.nodes()."
            },
            "Returns:": {
                "H : scipy.sparse.csr_array": "The Bethe Hessian matrix ofG, with parameterr."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]A. Saade, F. Krzakala and L. Zdeborov\u00e1\n\u201cSpectral Clustering of Graphs with the Bethe Hessian\u201d,\nAdvances in Neural Information Processing Systems, 2014.  [2]C. M. Le, E. Levina\n\u201cEstimating the number of communities in networks by spectral methods\u201d\narXiv:1507.00827, 2015.",
            "Examples": "k=[3,2,2,1,0]\nG=nx.havel_hakimi_graph(k)\nH=nx.bethe_hessian_matrix(G)\nH.toarray()\n# array([[ 3.5625, -1.25  , -1.25  , -1.25  ,  0.    ],\n#        [-1.25  ,  2.5625, -1.25  ,  0.    ,  0.    ],\n#        [-1.25  , -1.25  ,  2.5625,  0.    ,  0.    ],\n#        [-1.25  ,  0.    ,  0.    ,  1.5625,  0.    ],\n#        [ 0.    ,  0.    ,  0.    ,  0.    ,  0.5625]])"
        }
    },
    {
        "Section ID": "complement",
        "Description": [
            "Returns the graph complement of G."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph"
            },
            "Returns:": {
                "GC : A new graph.": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Note that complement does not create self-loops and also\ndoes not produce parallel edges for MultiGraphs. Graph, node, and edge data are not propagated to the new graph.",
            "Examples": "G=nx.Graph([(1,2),(1,3),(2,3),(3,4),(3,5)])\nG_complement=nx.complement(G)\nG_complement.edges()# This shows the edges of the complemented graph\n# EdgeView([(1, 4), (1, 5), (2, 4), (2, 5), (4, 5)])"
        }
    },
    {
        "Section ID": "projected_graph",
        "Description": [
            "Returns the projection of B onto one of its node sets.",
            "Returns the graph G that is the projection of the bipartite graph B\nonto the specified nodes. They retain their attributes and are connected\nin G if they have a common neighbor in B."
        ],
        "Field List": {
            "Parameters:": {
                "B : NetworkX graph": "The input graph should be bipartite.",
                "nodes : list or iterable": "Nodes to project onto (the \u201cbottom\u201d nodes).",
                "multigraph: bool (default=False)": "If True return a multigraph where the multiple edges represent multiple\nshared neighbors.  They edge key in the multigraph is assigned to the\nlabel of the neighbor."
            },
            "Returns:": {
                "Graph : NetworkX graph or multigraph": "A graph that is the projection onto the given nodes."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "No attempt is made to verify that the input graph B is bipartite.\nReturns a simple graph that is the projection of the bipartite graph B\nonto the set of nodes given in list nodes.  If multigraph=True then\na multigraph is returned with an edge for every shared neighbor. Directed graphs are allowed as input.  The output will also then\nbe a directed graph with edges if there is a directed path between\nthe nodes. The graph and node properties are (shallow) copied to the projected graph. See bipartitedocumentation for further details on how bipartite graphs are handled in NetworkX.",
            "Examples": "fromnetworkx.algorithmsimportbipartite\nB=nx.path_graph(4)\nG=bipartite.projected_graph(B,[1,3])\nlist(G)\n# [1, 3]\nlist(G.edges())\n# [(1, 3)]\nIf nodesa, andbare connected through both nodes 1 and 2 then\nbuilding a multigraph results in two edges in the projection onto\n[a,b]:\nB=nx.Graph()\nB.add_edges_from([(\"a\",1),(\"b\",1),(\"a\",2),(\"b\",2)])\nG=bipartite.projected_graph(B,[\"a\",\"b\"],multigraph=True)\nprint([sorted((u,v))foru,vinG.edges()])\n# [['a', 'b'], ['a', 'b']]"
        }
    },
    {
        "Section ID": "tree_isomorphism",
        "Description": [
            "Given two undirected (or free) trees t1 and t2 ,\nthis routine will determine if they are isomorphic.\nIt returns the isomorphism, a mapping of the nodes of t1 onto the nodes\nof t2 , such that two trees are then identical.",
            "Note that two trees may have more than one isomorphism, and this\nroutine just returns one valid mapping."
        ],
        "Field List": {
            "Parameters:": {
                "t1 : undirected NetworkX graph": "One of the trees being compared",
                "t2 : undirected NetworkX graph": "The other tree being compared"
            },
            "Returns:": {
                "isomorphism : list": "A list of pairs in which the left element is a node int1and the right element is a node int2.  The pairs are in\narbitrary order.  If the nodes in one tree is mapped to the names in\nthe other, then trees will be identical. Note that an isomorphism\nwill not necessarily be unique.Ift1andt2are not isomorphic, then it returns the empty list."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This runs in O(n*log(n)) time for trees with n nodes."
        }
    },
    {
        "Section ID": "optimize_edit_paths",
        "Description": [
            "GED (graph edit distance) calculation: advanced interface.",
            "Graph edit path is a sequence of node and edge edit operations\ntransforming graph G1 to graph isomorphic to G2.  Edit operations\ninclude substitutions, deletions, and insertions.",
            "Graph edit distance is defined as minimum cost of edit path."
        ],
        "Field List": {
            "Parameters:": {
                "G1, G2: graphs": "The two graphs G1 and G2 must be of the same type.",
                "node_match : callable": "A function that returns True if node n1 in G1 and n2 in G2\nshould be considered equal during matching.The function will be called likenode_match(G1.nodes[n1], G2.nodes[n2]).That is, the function will receive the node attribute\ndictionaries for n1 and n2 as inputs.Ignored if node_subst_cost is specified.  If neither\nnode_match nor node_subst_cost are specified then node\nattributes are not considered.",
                "edge_match : callable": "A function that returns True if the edge attribute dictionaries\nfor the pair of nodes (u1, v1) in G1 and (u2, v2) in G2 should\nbe considered equal during matching.The function will be called likeedge_match(G1[u1][v1], G2[u2][v2]).That is, the function will receive the edge attribute\ndictionaries of the edges under consideration.Ignored if edge_subst_cost is specified.  If neither\nedge_match nor edge_subst_cost are specified then edge\nattributes are not considered.",
                "node_subst_cost, node_del_cost, node_ins_cost : callable": "Functions that return the costs of node substitution, node\ndeletion, and node insertion, respectively.The functions will be called likenode_subst_cost(G1.nodes[n1], G2.nodes[n2]),\nnode_del_cost(G1.nodes[n1]),\nnode_ins_cost(G2.nodes[n2]).That is, the functions will receive the node attribute\ndictionaries as inputs.  The functions are expected to return\npositive numeric values.Function node_subst_cost overrides node_match if specified.\nIf neither node_match nor node_subst_cost are specified then\ndefault node substitution cost of 0 is used (node attributes\nare not considered during matching).If node_del_cost is not specified then default node deletion\ncost of 1 is used.  If node_ins_cost is not specified then\ndefault node insertion cost of 1 is used.",
                "edge_subst_cost, edge_del_cost, edge_ins_cost : callable": "Functions that return the costs of edge substitution, edge\ndeletion, and edge insertion, respectively.The functions will be called likeedge_subst_cost(G1[u1][v1], G2[u2][v2]),\nedge_del_cost(G1[u1][v1]),\nedge_ins_cost(G2[u2][v2]).That is, the functions will receive the edge attribute\ndictionaries as inputs.  The functions are expected to return\npositive numeric values.Function edge_subst_cost overrides edge_match if specified.\nIf neither edge_match nor edge_subst_cost are specified then\ndefault edge substitution cost of 0 is used (edge attributes\nare not considered during matching).If edge_del_cost is not specified then default edge deletion\ncost of 1 is used.  If edge_ins_cost is not specified then\ndefault edge insertion cost of 1 is used.",
                "upper_bound : numeric": "Maximum edit distance to consider.",
                "strictly_decreasing : bool": "If True, return consecutive approximations of strictly\ndecreasing cost.  Otherwise, return all edit paths of cost\nless than or equal to the previous minimum cost.",
                "roots : 2-tuple": "Tuple where first element is a node in G1 and the second\nis a node in G2.\nThese nodes are forced to be matched in the comparison to\nallow comparison between rooted graphs.",
                "timeout : numeric": "Maximum number of seconds to execute.\nAfter timeout is met, the current best GED is returned."
            },
            "Returns:": {
                "Generator of tuples (node_edit_path, edge_edit_path, cost)": "node_edit_path : list of tuples (u, v)\nedge_edit_path : list of tuples ((u1, v1), (u2, v2))\ncost : numeric"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Zeina Abu-Aisheh, Romain Raveaux, Jean-Yves Ramel, Patrick\nMartineau. An Exact Graph Edit Distance Algorithm for Solving\nPattern Recognition Problems. 4th International Conference on\nPattern Recognition Applications and Methods 2015, Jan 2015,\nLisbon, Portugal. 2015,\n<10.5220/0005209202710278>. <hal-01168816>https://hal.archives-ouvertes.fr/hal-01168816"
        }
    },
    {
        "Section ID": "single_source_dijkstra_path",
        "Description": [
            "Find shortest weighted paths in G from a source node.",
            "Compute shortest path between source and all other reachable\nnodes for a weighted graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node": "Starting node for path.",
                "cutoff : integer or float, optional": "Length (sum of edge weights) at which the search is stopped.\nIf cutoff is provided, only return paths with summed weight <= cutoff.",
                "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge."
            },
            "Returns:": {
                "paths : dictionary": "Dictionary of shortest path lengths keyed by target."
            },
            "Raises:": {
                "NodeNotFound": "Ifsourceis not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The weight function can be used to hide edges by returning None.\nSo weight=lambdau,v,d:1ifd['color']==\"red\"elseNone will find the shortest red path.",
            "Examples": "G=nx.path_graph(5)\npath=nx.single_source_dijkstra_path(G,0)\npath[4]\n# [0, 1, 2, 3, 4]"
        }
    },
    {
        "Section ID": "dfs_postorder_nodes",
        "Description": [
            "Generate nodes in a depth-first-search post-ordering starting at source."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node, optional": "Specify starting node for depth-first search.",
                "depth_limit : int, optional (default=len(G))": "Specify the maximum search depth.",
                "sort_neighbors : function (default=None)": "A function that takes an iterator over nodes as the input, and\nreturns an iterable of the same nodes with a custom ordering.\nFor example,sortedwill sort the nodes in increasing order."
            },
            "Returns:": {
                "nodes: generator": "A generator of nodes in a depth-first-search post-ordering."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "If a source is not specified then a source is chosen arbitrarily and\nrepeatedly until all components in the graph are searched. The implementation of this function is adapted from David Eppstein\u2019s\ndepth-first search function in PADS , with modifications\nto allow depth limits based on the Wikipedia article\n\u201c Depth-limited search \u201d.",
            "Examples": "G=nx.path_graph(5)\nlist(nx.dfs_postorder_nodes(G,source=0))\n# [4, 3, 2, 1, 0]\nlist(nx.dfs_postorder_nodes(G,source=0,depth_limit=2))\n# [1, 0]"
        }
    },
    {
        "Section ID": "tree_broadcast_center",
        "Description": [
            "Return the Broadcast Center of the tree G .",
            "The broadcast center of a graph G denotes the set of nodes having\nminimum broadcast time [1] . This is a linear algorithm for determining\nthe broadcast center of a tree with N nodes, as a by-product it also\ndetermines the broadcast time from the broadcast center."
        ],
        "Field List": {
            "Parameters:": {
                "G : undirected graph": "The graph should be an undirected tree"
            },
            "Returns:": {
                "BC : (int, set) tuple": "minimum broadcast number of the tree, set of broadcast centers"
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the graph is directed or is a multigraph."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Slater, P.J., Cockayne, E.J., Hedetniemi, S.T,\nInformation dissemination in trees. SIAM J.Comput. 10(4), 692\u2013701 (1981)"
        }
    },
    {
        "Section ID": "mycielski_graph",
        "Description": [
            "Generator for the n_th Mycielski Graph.",
            "The Mycielski family of graphs is an infinite set of graphs. \\(M_1\\) is the singleton graph, \\(M_2\\) is two vertices with an\nedge, and, for \\(i > 2\\) , \\(M_i\\) is the Mycielskian of \\(M_{i-1}\\) .",
            "More information can be found at http://mathworld.wolfram.com/MycielskiGraph.html"
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The desired Mycielski Graph."
            },
            "Returns:": {
                "M : graph": "The n_th Mycielski Graph"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The first graph in the Mycielski sequence is the singleton graph.\nThe Mycielskian of this graph is not the \\(P_2\\) graph, but rather the \\(P_2\\) graph with an extra, isolated vertex. The second Mycielski\ngraph is the \\(P_2\\) graph, so the first two are hard coded.\nThe remaining graphs are generated using the Mycielski operation."
        }
    },
    {
        "Section ID": "hits",
        "Description": [
            "Returns HITS hubs and authorities values for nodes.",
            "The HITS algorithm computes two numbers for a node.\nAuthorities estimates the node value based on the incoming links.\nHubs estimates the node value based on outgoing links."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "max_iter : integer, optional": "Maximum number of iterations in power method.",
                "tol : float, optional": "Error tolerance used to check convergence in power method iteration.",
                "nstart : dictionary, optional": "Starting value of each node for power method iteration.",
                "normalized : bool (default=True)": "Normalize results by the sum of all of the values."
            },
            "Returns:": {
                "(hubs,authorities) : two-tuple of dictionaries": "Two dictionaries keyed by node containing the hub and authority\nvalues."
            },
            "Raises:": {
                "PowerIterationFailedConvergence": "If the algorithm fails to converge to the specified tolerance\nwithin the specified number of iterations of the power iteration\nmethod."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The eigenvector calculation is done by the power iteration method\nand has no guarantee of convergence.  The iteration will stop\nafter max_iter iterations or an error tolerance of\nnumber_of_nodes(G)*tol has been reached. The HITS algorithm was designed for directed graphs but this\nalgorithm does not check if the input graph is directed and will\nexecute on undirected graphs.",
            "References": "[1]A. Langville and C. Meyer,\n\u201cA survey of eigenvector methods of web information retrieval.\u201dhttp://citeseer.ist.psu.edu/713792.html  [2]Jon Kleinberg,\nAuthoritative sources in a hyperlinked environment\nJournal of the ACM 46 (5): 604-32, 1999.\ndoi:10.1145/324133.324140.\nhttp://www.cs.cornell.edu/home/kleinber/auth.pdf.",
            "Examples": "G=nx.path_graph(4)\nh,a=nx.hits(G)"
        }
    },
    {
        "Section ID": "transitive_closure_dag",
        "Description": [
            "Returns the transitive closure of a directed acyclic graph.",
            "This function is faster than the function transitive_closure , but fails\nif the graph has a cycle.",
            "The transitive closure of G = (V,E) is a graph G+ = (V,E+) such that\nfor all v, w in V there is an edge (v, w) in E+ if and only if there\nis a non-null path from v to w in G."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX DiGraph": "A directed acyclic graph (DAG)",
                "topo_order: list or tuple, optional": "A topological order for G (if None, the function will compute one)"
            },
            "Returns:": {
                "NetworkX DiGraph": "The transitive closure ofG"
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis not directed",
                "NetworkXUnfeasible": "IfGhas a cycle"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm is probably simple enough to be well-known but I didn\u2019t find\na mention in the literature.",
            "Examples": "DG=nx.DiGraph([(1,2),(2,3)])\nTC=nx.transitive_closure_dag(DG)\nTC.edges()\n# OutEdgeView([(1, 2), (1, 3), (2, 3)])"
        }
    },
    {
        "Section ID": "kamada_kawai_layout",
        "Description": [
            "Position nodes using Kamada-Kawai path-length cost-function."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph or list of nodes": "A position will be assigned to every node in G.",
                "dist : dict (default=None)": "A two-level dictionary of optimal distances between nodes,\nindexed by source and destination node.\nIf None, the distance is computed using shortest_path_length().",
                "pos : dict or None  optional (default=None)": "Initial positions for nodes as a dictionary with node as keys\nand values as a coordinate list or tuple.  If None, then use\ncircular_layout() for dim >= 2 and a linear layout for dim == 1.",
                "weight : string or None   optional (default=\u2019weight\u2019)": "The edge attribute that holds the numerical value used for\nthe edge weight.  If None, then all edge weights are 1.",
                "scale : number (default: 1)": "Scale factor for positions.",
                "center : array-like or None": "Coordinate pair around which to center the layout.",
                "dim : int": "Dimension of layout."
            },
            "Returns:": {
                "pos : dict": "A dictionary of positions keyed by node"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.path_graph(4)\npos=nx.kamada_kawai_layout(G)"
        }
    },
    {
        "Section ID": "minimum_cut",
        "Description": [
            "Compute the value and the node partition of a minimum (s, t)-cut.",
            "Use the max-flow min-cut theorem, i.e., the capacity of a minimum\ncapacity cut is equal to the flow value of a maximum flow."
        ],
        "Field List": {
            "Parameters:": {
                "flowG : NetworkX graph": "Edges of the graph are expected to have an attribute called\n\u2018capacity\u2019. If this attribute is not present, the edge is\nconsidered to have infinite capacity.",
                "_s : node": "Source node for the flow.",
                "_t : node": "Sink node for the flow.",
                "capacity : string": "Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: \u2018capacity\u2019.",
                "flow_func : function": "A function for computing the maximum flow among a pair of nodes\nin a capacitated graph. The function has to accept at least three\nparameters: a Graph or Digraph, a source node, and a target node.\nAnd return a residual network that follows NetworkX conventions\n(see Notes). If flow_func is None, the default maximum\nflow function (preflow_push()) is used. See below for\nalternative algorithms. The choice of the default function may change\nfrom version to version and should not be relied on. Default value:\nNone.",
                "kwargs : Any other keyword parameter is passed to the function that": "computes the maximum flow."
            },
            "Returns:": {
                "cut_value : integer, float": "Value of the minimum cut.",
                "partition : pair of node sets": "A partitioning of the nodes that defines a minimum cut."
            },
            "Raises:": {
                "NetworkXUnbounded": "If the graph has a path of infinite capacity, all cuts have\ninfinite capacity and the function raises a NetworkXError."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The function used in the flow_func parameter has to return a residual\nnetwork that follows NetworkX conventions: The residual network R from an input graph G has the\nsame nodes as G . R is a DiGraph that contains a pair\nof edges (u,v) and (v,u) iff (u,v) is not a\nself-loop, and at least one of (u,v) and (v,u) exists\nin G . For each edge (u,v) in R , R[u][v]['capacity'] is equal to the capacity of (u,v) in G if it exists\nin G or zero otherwise. If the capacity is infinite, R[u][v]['capacity'] will have a high arbitrary finite value\nthat does not affect the solution of the problem. This value is stored in R.graph['inf'] . For each edge (u,v) in R , R[u][v]['flow'] represents the flow function of (u,v) and\nsatisfies R[u][v]['flow']==-R[v][u]['flow'] . The flow value, defined as the total flow into t , the sink, is\nstored in R.graph['flow_value'] . Reachability to t using\nonly edges (u,v) such that R[u][v]['flow']<R[u][v]['capacity'] induces a minimum s - t cut. Specific algorithms may store extra data in R . The function should supports an optional boolean parameter value_only. When\nTrue, it can optionally terminate the algorithm as soon as the maximum flow\nvalue and the minimum cut can be determined.",
            "Examples": "G=nx.DiGraph()\nG.add_edge(\"x\",\"a\",capacity=3.0)\nG.add_edge(\"x\",\"b\",capacity=1.0)\nG.add_edge(\"a\",\"c\",capacity=3.0)\nG.add_edge(\"b\",\"c\",capacity=5.0)\nG.add_edge(\"b\",\"d\",capacity=4.0)\nG.add_edge(\"d\",\"e\",capacity=2.0)\nG.add_edge(\"c\",\"y\",capacity=2.0)\nG.add_edge(\"e\",\"y\",capacity=3.0)\nminimum_cut computes both the value of the\nminimum cut and the node partition:\ncut_value,partition=nx.minimum_cut(G,\"x\",\"y\")\nreachable,non_reachable=partition\n\u2018partition\u2019 here is a tuple with the two sets of nodes that define\nthe minimum cut. You can compute the cut set of edges that induce\nthe minimum cut as follows:\ncutset=set()\nforu,nbrsin((n,G[n])forninreachable):\ncutset.update((u,v)forvinnbrsifvinnon_reachable)\nprint(sorted(cutset))\n# [('c', 'y'), ('x', 'b')]\ncut_value==sum(G.edges[u,v][\"capacity\"]for(u,v)incutset)\n# True\nYou can also use alternative algorithms for computing the\nminimum cut by using the flow_func parameter.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\ncut_value==nx.minimum_cut(G,\"x\",\"y\",flow_func=shortest_augmenting_path)[0]\n# True"
        }
    },
    {
        "Section ID": "UnionMultiAdjacency",
        "Description": [
            "A read-only union of two dict MultiAdjacencies.",
            "The two input dict-of-dict-of-dict-of-dicts represent the union of G.succ and G.pred for MultiDiGraphs. Return values are UnionAdjacency.\nThe inner level of dict is read-write. But the outer levels are read-only."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "local_constraint",
        "Description": [
            "Returns the local constraint on the node u with respect to\nthe node v in the graph G .",
            "Formally, the local constraint on u with respect to v , denoted \\(\\ell(u, v)\\) , is defined by",
            "where \\(N(v)\\) is the set of neighbors of \\(v\\) and \\(p_{uv}\\) is the\nnormalized mutual weight of the (directed or undirected) edges\njoining \\(u\\) and \\(v\\) , for each vertex \\(u\\) and \\(v\\)  [1] . The mutual\nweight of \\(u\\) and \\(v\\) is the sum of the weights of edges joining\nthem (edge weights are assumed to be one if the graph is\nunweighted)."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "The graph containinguandv. This can be either\ndirected or undirected.",
                "u : node": "A node in the graphG.",
                "v : node": "A node in the graphG.",
                "weight : None or string, optional": "If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight."
            },
            "Returns:": {
                "float": "The constraint of the nodevin the graphG."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Burt, Ronald S.\n\u201cStructural holes and good ideas\u201d.\nAmerican Journal of Sociology (110): 349\u2013399."
        }
    },
    {
        "Section ID": "mycielskian",
        "Description": [
            "Returns the Mycielskian of a simple, undirected graph G",
            "The Mycielskian of graph preserves a graph\u2019s triangle free\nproperty while increasing the chromatic number by 1.",
            "The Mycielski Operation on a graph, \\(G=(V, E)\\) , constructs a new\ngraph with \\(2|V| + 1\\) nodes and \\(3|E| + |V|\\) edges.",
            "The construction is as follows:",
            "Let \\(V = {0, ..., n-1}\\) . Construct another vertex set \\(U = {n, ..., 2n}\\) and a vertex, w .\nConstruct a new graph, M , with vertices \\(U \\bigcup V \\bigcup w\\) .\nFor edges, \\((u, v) \\in E\\) add edges \\((u, v), (u, v + n)\\) , and \\((u + n, v)\\) to M. Finally, for all vertices \\(u \\in U\\) , add\nedge \\((u, w)\\) to M.",
            "The Mycielski Operation can be done multiple times by repeating the above\nprocess iteratively.",
            "More information can be found at https://en.wikipedia.org/wiki/Mycielskian"
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A simple, undirected NetworkX graph",
                "iterations : int": "The number of iterations of the Mycielski operation to\nperform on G. Defaults to 1. Must be a non-negative integer."
            },
            "Returns:": {
                "M : graph": "The Mycielskian of G after the specified number of iterations."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Graph, node, and edge data are not necessarily propagated to the new graph."
        }
    },
    {
        "Section ID": "from_dict_of_lists",
        "Description": [
            "Returns a graph from a dictionary of lists."
        ],
        "Field List": {
            "Parameters:": {
                "d : dictionary of lists": "A dictionary of lists adjacency representation.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "dol={0:[1]}# single edge (0,1)\nG=nx.from_dict_of_lists(dol)\nor\nG=nx.Graph(dol)# use Graph constructor"
        }
    },
    {
        "Section ID": "tadpole_graph",
        "Description": [
            "Returns the (m,n)-tadpole graph; C_m connected to P_n .",
            "This graph on m+n nodes connects a cycle of size m to a path of length n .\nIt looks like a tadpole. It is also called a kite graph or a dragon graph.",
            "( Sourcecode , png )"
        ],
        "Field List": {
            "Parameters:": {
                "m, n : int or iterable container of nodes": "If an integer, nodes are fromrange(m)andrange(m,m+n).\nIf a container of nodes, those nodes appear in the graph.\nWarning:mandnare not checked for duplicates and if present the\nresulting graph may not be as desired.The nodes formappear in the cycle graph\\(C_m\\)and the nodes\nfornappear in the path\\(P_n\\).",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "Networkx graph": "A cycle of sizemconnected to a path of lengthn."
            },
            "Raises:": {
                "NetworkXError": "Ifm<2. The tadpole graph is undefined form<2."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The 2 subgraphs are joined via an edge (m-1,m) .\nIf n=0 , this is a cycle graph. m and/or n can be a container of nodes instead of an integer."
        }
    },
    {
        "Section ID": "generate_adjlist",
        "Description": [
            "Generate a single line of the graph G in adjacency list format."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "delimiter : string, optional": "Separator for node labels"
            },
            "Returns:": {
                "lines : string": "Lines of data in adjlist format."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The default delimiter=\"\" will result in unexpected results if node names contain\nwhitespace characters. To avoid this problem, specify an alternate delimiter when spaces are\nvalid in node names. NB: This option is not available for data that isn\u2019t user-generated.",
            "Examples": "G=nx.lollipop_graph(4,3)\nforlineinnx.generate_adjlist(G):\nprint(line)\n# 0 1 2 3\n# 1 2 3\n# 2 3\n# 3 4\n# 4 5\n# 5 6\n# 6"
        }
    },
    {
        "Section ID": "lollipop_graph",
        "Description": [
            "Returns the Lollipop Graph; K_m connected to P_n .",
            "This is the Barbell Graph without the right barbell.",
            "( Sourcecode , png )"
        ],
        "Field List": {
            "Parameters:": {
                "m, n : int or iterable container of nodes": "If an integer, nodes are fromrange(m)andrange(m,m+n).\nIf a container of nodes, those nodes appear in the graph.\nWarning:mandnare not checked for duplicates and if present the\nresulting graph may not be as desired. Make sure you have no duplicates.The nodes formappear in the complete graph\\(K_m\\)and the nodes\nfornappear in the path\\(P_n\\)",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "Networkx graph": "A complete graph withmnodes connected to a path of lengthn."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The 2 subgraphs are joined via an edge (m-1,m) .\nIf n=0 , this is merely a complete graph. (This graph is an extremal example in David Aldous and Jim\nFill\u2019s etext on Random Walks on Graphs.)"
        }
    },
    {
        "Section ID": "FilterMultiAdjacency",
        "Description": [
            "A read-only Mapping of Mappings with filtering criteria\nfor nodes and edges.",
            "It is a view into a dict-of-dict-of-dict-of-dict data structure,\nand it selects nodes and edges that satisfy specific criteria\ndefined by NODE_OK and EDGE_OK , respectively."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "greedy_color",
        "Description": [
            "Color a graph using various strategies of greedy graph coloring.",
            "Attempts to color a graph using as few colors as possible, where no\nneighbors of a node can have same color as the node itself. The\ngiven strategy determines the order in which nodes are colored.",
            "The strategies are described in [1] , and smallest-last is based on [2] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "strategy : string or function(G, colors)": "A function (or a string representing a function) that provides\nthe coloring strategy, by returning nodes in the ordering they\nshould be colored.Gis the graph, andcolorsis a\ndictionary of the currently assigned colors, keyed by nodes. The\nfunction must return an iterable over all the nodes inG.If the strategy function is an iterator generator (that is, a\nfunction withyieldstatements), keep in mind that thecolorsdictionary will be updated after eachyield, since\nthis function chooses colors greedily.Ifstrategyis a string, it must be one of the following,\neach of which represents one of the built-in strategy functions.'largest_first''random_sequential''smallest_last''independent_set''connected_sequential_bfs''connected_sequential_dfs''connected_sequential'(alias for the previous strategy)'saturation_largest_first''DSATUR'(alias for the previous strategy)",
                "interchange: bool": "Will use the color interchange algorithm described by[3]if set\ntoTrue.Note thatsaturation_largest_firstandindependent_setdo not work with interchange. Furthermore, if you use\ninterchange with your own strategy function, you cannot rely\non the values in thecolorsargument."
            },
            "Returns:": {
                "A dictionary with keys representing nodes and values representing": "",
                "corresponding coloring.": ""
            },
            "Raises:": {
                "NetworkXPointlessConcept": "Ifstrategyissaturation_largest_firstorindependent_setandinterchangeisTrue."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Adrian Kosowski, and Krzysztof Manuszewski,\nClassical Coloring of Graphs, Graph Colorings, 2-19, 2004.\nISBN 0-8218-3458-4.  [2]David W. Matula, and Leland L. Beck, \u201cSmallest-last\nordering and clustering and graph coloring algorithms.\u201dJ. ACM30,\n3 (July 1983), 417\u2013427. <https://doi.org/10.1145/2402.322385>  [3]Maciej M. Sys\u0142o, Narsingh Deo, Janusz S. Kowalik,\nDiscrete Optimization Algorithms with Pascal Programs, 415-424, 1983.\nISBN 0-486-45353-7.",
            "Examples": "G=nx.cycle_graph(4)\nd=nx.coloring.greedy_color(G,strategy=\"largest_first\")\ndin[{0:0,1:1,2:0,3:1},{0:1,1:0,2:1,3:0}]\n# True"
        }
    },
    {
        "Section ID": "shortest_augmenting_path",
        "Description": [
            "Find a maximum single-commodity flow using the shortest augmenting path\nalgorithm.",
            "This function returns the residual network resulting after computing\nthe maximum flow. See below for details about the conventions\nNetworkX uses for defining residual networks.",
            "This algorithm has a running time of \\(O(n^2 m)\\) for \\(n\\) nodes and \\(m\\) edges."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Edges of the graph are expected to have an attribute called\n\u2018capacity\u2019. If this attribute is not present, the edge is\nconsidered to have infinite capacity.",
                "s : node": "Source node for the flow.",
                "t : node": "Sink node for the flow.",
                "capacity : string": "Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: \u2018capacity\u2019.",
                "residual : NetworkX graph": "Residual network on which the algorithm is to be executed. If None, a\nnew residual network is created. Default value: None.",
                "value_only : bool": "If True compute only the value of the maximum flow. This parameter\nwill be ignored by this algorithm because it is not applicable.",
                "two_phase : bool": "If True, a two-phase variant is used. The two-phase variant improves\nthe running time on unit-capacity networks from\\(O(nm)\\)to\\(O(\\min(n^{2/3}, m^{1/2}) m)\\). Default value: False.",
                "cutoff : integer, float": "If specified, the algorithm will terminate when the flow value reaches\nor exceeds the cutoff. In this case, it may be unable to immediately\ndetermine a minimum cut. Default value: None."
            },
            "Returns:": {
                "R : NetworkX DiGraph": "Residual network after computing the maximum flow."
            },
            "Raises:": {
                "NetworkXError": "The algorithm does not support MultiGraph and MultiDiGraph. If\nthe input graph is an instance of one of these two classes, a\nNetworkXError is raised.",
                "NetworkXUnbounded": "If the graph has a path of infinite capacity, the value of a\nfeasible flow on the graph is unbounded above and the function\nraises a NetworkXUnbounded."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The residual network R from an input graph G has the\nsame nodes as G . R is a DiGraph that contains a pair\nof edges (u,v) and (v,u) iff (u,v) is not a\nself-loop, and at least one of (u,v) and (v,u) exists\nin G . For each edge (u,v) in R , R[u][v]['capacity'] is equal to the capacity of (u,v) in G if it exists\nin G or zero otherwise. If the capacity is infinite, R[u][v]['capacity'] will have a high arbitrary finite value\nthat does not affect the solution of the problem. This value is stored in R.graph['inf'] . For each edge (u,v) in R , R[u][v]['flow'] represents the flow function of (u,v) and\nsatisfies R[u][v]['flow']==-R[v][u]['flow'] . The flow value, defined as the total flow into t , the sink, is\nstored in R.graph['flow_value'] . If cutoff is not\nspecified, reachability to t using only edges (u,v) such\nthat R[u][v]['flow']<R[u][v]['capacity'] induces a minimum s - t cut.",
            "Examples": "fromnetworkx.algorithms.flowimportshortest_augmenting_path\nThe functions that implement flow algorithms and output a residual\nnetwork, such as this one, are not imported to the base NetworkX\nnamespace, so you have to explicitly import them from the flow package.\nG=nx.DiGraph()\nG.add_edge(\"x\",\"a\",capacity=3.0)\nG.add_edge(\"x\",\"b\",capacity=1.0)\nG.add_edge(\"a\",\"c\",capacity=3.0)\nG.add_edge(\"b\",\"c\",capacity=5.0)\nG.add_edge(\"b\",\"d\",capacity=4.0)\nG.add_edge(\"d\",\"e\",capacity=2.0)\nG.add_edge(\"c\",\"y\",capacity=2.0)\nG.add_edge(\"e\",\"y\",capacity=3.0)\nR=shortest_augmenting_path(G,\"x\",\"y\")\nflow_value=nx.maximum_flow_value(G,\"x\",\"y\")\nflow_value\n# 3.0\nflow_value==R.graph[\"flow_value\"]\n# True"
        }
    },
    {
        "Section ID": "fast_could_be_isomorphic",
        "Description": [
            "Returns False if graphs are definitely not isomorphic.",
            "True does NOT guarantee isomorphism."
        ],
        "Field List": {
            "Parameters:": {
                "G1, G2 : graphs": "The two graphs G1 and G2 must be the same type."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Checks for matching degree and triangle sequences. The triangle\nsequence contains the number of triangles each node is part of."
        }
    },
    {
        "Section ID": "directed_havel_hakimi_graph",
        "Description": [
            "Returns a directed graph with the given degree sequences."
        ],
        "Field List": {
            "Parameters:": {
                "in_deg_sequence : list of integers": "Each list entry corresponds to the in-degree of a node.",
                "out_deg_sequence : list of integers": "Each list entry corresponds to the out-degree of a node.",
                "create_using : NetworkX graph constructor, optional (default DiGraph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : DiGraph": "A graph with the specified degree sequences.\nNodes are labeled starting at 0 with an index\ncorresponding to the position in deg_sequence"
            },
            "Raises:": {
                "NetworkXError": "If the degree sequences are not digraphical."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Algorithm as described by Kleitman and Wang [1] .",
            "References": "[1]D.J. Kleitman and D.L. Wang\nAlgorithms for Constructing Graphs and Digraphs with Given Valences\nand Factors Discrete Mathematics, 6(1), pp. 79-88 (1973)"
        }
    },
    {
        "Section ID": "random_unlabeled_tree",
        "Description": [
            "Returns a tree or list of trees chosen randomly.",
            "Returns one or more (depending on number_of_trees )\nunlabeled trees with n nodes drawn uniformly at random."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes",
                "number_of_trees : int or None (default)": "If not None, this number of trees is generated and returned.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "networkx.Graph : or list of : networkx.Graph": "A singlenetworkx.Graph(or a list thereof, ifnumber_of_treesis specified) with nodes in the set {0, \u2026,n- 1}."
            },
            "Raises:": {
                "NetworkXPointlessConcept": "Ifnis zero (because the null graph is not a tree)."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This function generates an unlabeled tree uniformly at random using\nWilf\u2019s algorithm \u201cFree\u201d of [1] . The algorithm needs to\ncompute some counting functions that are relatively expensive:\nin case several trees are needed, it is advisable to use the number_of_trees optional argument to reuse the counting\nfunctions.",
            "References": "[1]Wilf, Herbert S. \u201cThe uniform selection of free trees.\u201d\nJournal of Algorithms 2.2 (1981): 204-207.https://doi.org/10.1016/0196-6774(81)90021-3"
        }
    },
    {
        "Section ID": "betweenness_centrality",
        "Description": [
            "Compute betweenness centrality for nodes in a bipartite network.",
            "Betweenness centrality of a node v is the sum of the\nfraction of all-pairs shortest paths that pass through v .",
            "Values of betweenness are normalized by the maximum possible\nvalue which for bipartite graphs is limited by the relative size\nof the two node sets [1] .",
            "Let n be the number of nodes in the node set U and m be the number of nodes in the node set V , then\nnodes in U are normalized by dividing by",
            "where",
            "and nodes in V are normalized by dividing by",
            "where,"
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A bipartite graph",
                "nodes : list or container": "Container with all nodes in one bipartite node set."
            },
            "Returns:": {
                "betweenness : dictionary": "Dictionary keyed by node with bipartite betweenness centrality\nas the value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The nodes input parameter must contain all nodes in one bipartite node set,\nbut the dictionary returned contains all nodes from both node sets.\nSee bipartitedocumentation for further details on how bipartite graphs are handled in NetworkX.",
            "References": "[1]Borgatti, S.P. and Halgin, D. In press. \u201cAnalyzing Affiliation\nNetworks\u201d. In Carrington, P. and Scott, J. (eds) The Sage Handbook\nof Social Network Analysis. Sage Publications.https://dx.doi.org/10.4135/9781446294413.n28",
            "Examples": "G=nx.cycle_graph(4)\ntop_nodes={1,2}\nnx.bipartite.betweenness_centrality(G,nodes=top_nodes)\n# {0: 0.25, 1: 0.25, 2: 0.25, 3: 0.25}"
        }
    },
    {
        "Section ID": "modularity",
        "Description": [
            "Returns the modularity of the given partition of the graph.",
            "Modularity is defined in [1] as",
            "where \\(m\\) is the number of edges (or sum of all edge weights as in [5] ), \\(A\\) is the adjacency matrix of G , \\(k_i\\) is the (weighted) degree of \\(i\\) , \\(\\gamma\\) is the resolution parameter, and \\(\\delta(c_i, c_j)\\) is 1 if \\(i\\) and \\(j\\) are in the same community else 0.",
            "According to [2] (and verified by some algebra) this can be reduced to",
            "where the sum iterates over all communities \\(c\\) , \\(m\\) is the number of edges, \\(L_c\\) is the number of intra-community links for community \\(c\\) , \\(k_c\\) is the sum of degrees of the nodes in community \\(c\\) ,\nand \\(\\gamma\\) is the resolution parameter.",
            "The resolution parameter sets an arbitrary tradeoff between intra-group\nedges and inter-group edges. More complex grouping patterns can be\ndiscovered by analyzing the same network with multiple values of gamma\nand then combining the results [3] . That said, it is very common to\nsimply use gamma=1. More on the choice of gamma is in [4] .",
            "The second formula is the one actually used in calculation of the modularity.\nFor directed graphs the second formula replaces \\(k_c\\) with \\(k^{in}_c k^{out}_c\\) ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "",
                "communities : list or iterable of set of nodes": "These node sets must represent a partition of G\u2019s nodes.",
                "weight : string or None, optional (default=\u201dweight\u201d)": "The edge attribute that holds the numerical value used\nas a weight. If None or an edge does not have that attribute,\nthen that edge has weight 1.",
                "resolution : float (default=1)": "If resolution is less than 1, modularity favors larger communities.\nGreater than 1 favors smaller communities."
            },
            "Returns:": {
                "Q : float": "The modularity of the partition."
            },
            "Raises:": {
                "NotAPartition": "Ifcommunitiesis not a partition of the nodes ofG."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]M. E. J. Newman \u201cNetworks: An Introduction\u201d, page 224.\nOxford University Press, 2011.  [2]Clauset, Aaron, Mark EJ Newman, and Cristopher Moore.\n\u201cFinding community structure in very large networks.\u201d\nPhys. Rev. E 70.6 (2004). <https://arxiv.org/abs/cond-mat/0408187>  [3]Reichardt and Bornholdt \u201cStatistical Mechanics of Community Detection\u201d\nPhys. Rev. E 74, 016110, 2006.https://doi.org/10.1103/PhysRevE.74.016110  [4]M. E. J. Newman, \u201cEquivalence between modularity optimization and\nmaximum likelihood methods for community detection\u201d\nPhys. Rev. E 94, 052315, 2016.https://doi.org/10.1103/PhysRevE.94.052315  [5]Blondel, V.D. et al. \u201cFast unfolding of communities in large\nnetworks\u201d J. Stat. Mech 10008, 1-12 (2008).https://doi.org/10.1088/1742-5468/2008/10/P10008",
            "Examples": "G=nx.barbell_graph(3,0)\nnx.community.modularity(G,[{0,1,2},{3,4,5}])\n# 0.35714285714285715\nnx.community.modularity(G,nx.community.label_propagation_communities(G))\n# 0.35714285714285715"
        }
    },
    {
        "Section ID": "dfs_edges",
        "Description": [
            "Iterate over edges in a depth-first-search (DFS).",
            "Perform a depth-first-search over the nodes of G and yield\nthe edges in order. This may not generate all edges in G (see edge_dfs )."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node, optional": "Specify starting node for depth-first search and yield edges in\nthe component reachable from source.",
                "depth_limit : int, optional (default=len(G))": "Specify the maximum search depth.",
                "sort_neighbors : function (default=None)": "A function that takes an iterator over nodes as the input, and\nreturns an iterable of the same nodes with a custom ordering.\nFor example,sortedwill sort the nodes in increasing order."
            },
            "Yields:": {
                "edge: 2-tuple of nodes": "Yields edges resulting from the depth-first-search."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "If a source is not specified then a source is chosen arbitrarily and\nrepeatedly until all components in the graph are searched. The implementation of this function is adapted from David Eppstein\u2019s\ndepth-first search function in PADS [1] , with modifications\nto allow depth limits based on the Wikipedia article\n\u201cDepth-limited search\u201d [2] .",
            "References": "[1]http://www.ics.uci.edu/~eppstein/PADS  [2]https://en.wikipedia.org/wiki/Depth-limited_search",
            "Examples": "G=nx.path_graph(5)\nlist(nx.dfs_edges(G,source=0))\n# [(0, 1), (1, 2), (2, 3), (3, 4)]\nlist(nx.dfs_edges(G,source=0,depth_limit=2))\n# [(0, 1), (1, 2)]"
        }
    },
    {
        "Section ID": "write_gml",
        "Description": [
            "Write a graph G in GML format to the file or file handle path ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "The graph to be converted to GML.",
                "path : filename or filehandle": "The filename or filehandle to write. Files whose names end with .gz or\n.bz2 will be compressed.",
                "stringizer : callable, optional": "Astringizerwhich converts non-int/non-float/non-dict values into\nstrings. If it cannot convert a value into a string, it should raise aValueErrorto indicate that. Default value: None."
            },
            "Raises:": {
                "NetworkXError": "Ifstringizercannot convert a value into a string, or the value to\nconvert is not a string whilestringizeris None."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Graph attributes named \u2018directed\u2019, \u2018multigraph\u2019, \u2018node\u2019 or\n\u2018edge\u2019, node attributes named \u2018id\u2019 or \u2018label\u2019, edge attributes\nnamed \u2018source\u2019 or \u2018target\u2019 (or \u2018key\u2019 if G is a multigraph)\nare ignored because these attribute names are used to encode the graph\nstructure. GML files are stored using a 7-bit ASCII encoding with any extended\nASCII characters (iso8859-1) appearing as HTML character entities.\nWithout specifying a stringizer / destringizer , the code is capable of\nwriting int / float / str / dict / list data as required by the GML\nspecification.  For writing other data types, and for reading data other\nthan str you need to explicitly supply a stringizer / destringizer . Note that while we allow non-standard GML to be read from a file, we make\nsure to write GML format. In particular, underscores are not allowed in\nattribute names.\nFor additional documentation on the GML file format, please see the GML url . See the module docstring networkx.readwrite.gml for more details.",
            "Examples": "G=nx.path_graph(4)\nnx.write_gml(G,\"test.gml\")\nFilenames ending in .gz or .bz2 will be compressed.\nnx.write_gml(G,\"test.gml.gz\")"
        }
    },
    {
        "Section ID": "predecessor",
        "Description": [
            "Returns dict of predecessors for the path from source to all nodes in G."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node label": "Starting node for path",
                "target : node label, optional": "Ending node for path. If provided only predecessors between\nsource and target are returned",
                "cutoff : integer, optional": "Depth to stop the search. Only paths of length <= cutoff are returned.",
                "return_seen : bool, optional (default=None)": "Whether to return a dictionary, keyed by node, of the level (number of\nhops) to reach the node (as seen during breadth-first-search)."
            },
            "Returns:": {
                "pred : dictionary": "Dictionary, keyed by node, of predecessors in the shortest path.",
                "(pred, seen): tuple of dictionaries": "Ifreturn_seenargument is set toTrue, then a tuple of dictionaries\nis returned. The first element is the dictionary, keyed by node, of\npredecessors in the shortest path. The second element is the dictionary,\nkeyed by node, of the level (number of hops) to reach the node (as seen\nduring breadth-first-search)."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.path_graph(4)\nlist(G)\n# [0, 1, 2, 3]\nnx.predecessor(G,0)\n# {0: [], 1: [0], 2: [1], 3: [2]}\nnx.predecessor(G,0,return_seen=True)\n# ({0: [], 1: [0], 2: [1], 3: [2]}, {0: 0, 1: 1, 2: 2, 3: 3})"
        }
    },
    {
        "Section ID": "to_pydot",
        "Description": [
            "Returns a pydot graph from a NetworkX graph N."
        ],
        "Field List": {
            "Parameters:": {
                "N : NetworkX graph": "A graph created with NetworkX"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "K5=nx.complete_graph(5)\nP=nx.nx_pydot.to_pydot(K5)"
        }
    },
    {
        "Section ID": "goldberg_radzik",
        "Description": [
            "Compute shortest path lengths and predecessors on shortest paths\nin weighted graphs.",
            "The algorithm has a running time of \\(O(mn)\\) where \\(n\\) is the number of\nnodes and \\(m\\) is the number of edges.  It is slower than Dijkstra but\ncan handle negative edge weights."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "The algorithm works for all types of graphs, including directed\ngraphs and multigraphs.",
                "source: node label": "Starting node for path",
                "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number."
            },
            "Returns:": {
                "pred, dist : dictionaries": "Returns two dictionaries keyed by node to predecessor in the\npath and to the distance from the source respectively."
            },
            "Raises:": {
                "NodeNotFound": "Ifsourceis not inG.",
                "NetworkXUnbounded": "If the (di)graph contains a negative (di)cycle, the\nalgorithm raises an exception to indicate the presence of the\nnegative (di)cycle.  Note: any negative weight edge in an\nundirected graph is a negative cycle.As of NetworkX v3.2, a zero weight cycle is no longer\nincorrectly reported as a negative weight cycle."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The dictionaries returned only have keys for nodes reachable from\nthe source. In the case where the (di)graph is not connected, if a component\nnot containing the source contains a negative (di)cycle, it\nwill not be detected.",
            "Examples": "G=nx.path_graph(5,create_using=nx.DiGraph())\npred,dist=nx.goldberg_radzik(G,0)\nsorted(pred.items())\n# [(0, None), (1, 0), (2, 1), (3, 2), (4, 3)]\nsorted(dist.items())\n# [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]\nG=nx.cycle_graph(5,create_using=nx.DiGraph())\nG[1][2][\"weight\"]=-7\nnx.goldberg_radzik(G,0)Traceback (most recent call last):    ...networkx.exception.NetworkXUnboundedNegative cycle detected."
        }
    },
    {
        "Section ID": "flatten",
        "Description": [
            "Return flattened version of (possibly nested) iterable object."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "louvain_communities",
        "Description": [
            "Find the best partition of a graph using the Louvain Community Detection\nAlgorithm.",
            "Louvain Community Detection Algorithm is a simple method to extract the community\nstructure of a network. This is a heuristic method based on modularity optimization. [1]",
            "The algorithm works in 2 steps. On the first step it assigns every node to be\nin its own community and then for each node it tries to find the maximum positive\nmodularity gain by moving each node to all of its neighbor communities. If no positive\ngain is achieved the node remains in its original community.",
            "The modularity gain obtained by moving an isolated node \\(i\\) into a community \\(C\\) can\neasily be calculated by the following formula (combining [1]  [2] and some algebra):",
            "where \\(m\\) is the size of the graph, \\(k_{i,in}\\) is the sum of the weights of the links\nfrom \\(i\\) to nodes in \\(C\\) , \\(k_i\\) is the sum of the weights of the links incident to node \\(i\\) , \\(\\Sigma_{tot}\\) is the sum of the weights of the links incident to nodes in \\(C\\) and \\(\\gamma\\) is the resolution parameter.",
            "For the directed case the modularity gain can be computed using this formula according to [3]",
            "where \\(k_i^{out}\\) , \\(k_i^{in}\\) are the outer and inner weighted degrees of node \\(i\\) and \\(\\Sigma_{tot}^{in}\\) , \\(\\Sigma_{tot}^{out}\\) are the sum of in-going and out-going links incident\nto nodes in \\(C\\) .",
            "The first phase continues until no individual move can improve the modularity.",
            "The second phase consists in building a new network whose nodes are now the communities\nfound in the first phase. To do so, the weights of the links between the new nodes are given by\nthe sum of the weight of the links between nodes in the corresponding two communities. Once this\nphase is complete it is possible to reapply the first phase creating bigger communities with\nincreased modularity.",
            "The above two phases are executed until no modularity gain is achieved (or is less than\nthe threshold , or until max_levels is reached).",
            "Be careful with self-loops in the input graph. These are treated as\npreviously reduced communities \u2013 as if the process had been started\nin the middle of the algorithm. Large self-loop edge weights thus\nrepresent strong communities and in practice may be hard to add\nother nodes to.  If your input graph edge weights for self-loops\ndo not represent already reduced communities you may want to remove\nthe self-loops before inputting that graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "weight : string or None, optional (default=\u201dweight\u201d)": "The name of an edge attribute that holds the numerical value\nused as a weight. If None then each edge has weight 1.",
                "resolution : float, optional (default=1)": "If resolution is less than 1, the algorithm favors larger communities.\nGreater than 1 favors smaller communities",
                "threshold : float, optional (default=0.0000001)": "Modularity gain threshold for each level. If the gain of modularity\nbetween 2 levels of the algorithm is less than the given threshold\nthen the algorithm stops and returns the resulting communities.",
                "max_level : int or None, optional (default=None)": "The maximum number of levels (steps of the algorithm) to compute.\nMust be a positive integer or None. If None, then there is no max\nlevel and the threshold parameter determines the stopping condition.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "list": "A list of sets (partition ofG). Each set represents one community and contains\nall the nodes that constitute it."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The order in which the nodes are considered can affect the final output. In the algorithm\nthe ordering happens using a random shuffle.",
            "References": "[1](1,2)Blondel, V.D. et al. Fast unfolding of communities in\nlarge networks. J. Stat. Mech 10008, 1-12(2008).https://doi.org/10.1088/1742-5468/2008/10/P10008  [2]Traag, V.A., Waltman, L. & van Eck, N.J. From Louvain to Leiden: guaranteeing\nwell-connected communities. Sci Rep 9, 5233 (2019).https://doi.org/10.1038/s41598-019-41695-z  [3]Nicolas Dugu\u00e9, Anthony Perez. Directed Louvain : maximizing modularity in directed networks.\n[Research Report] Universit\u00e9 d\u2019Orl\u00e9ans. 2015. hal-01231784.https://hal.archives-ouvertes.fr/hal-01231784",
            "Examples": "importnetworkxasnx\nG=nx.petersen_graph()\nnx.community.louvain_communities(G,seed=123)\n# [{0, 4, 5, 7, 9}, {1, 2, 3, 6, 8}]"
        }
    },
    {
        "Section ID": "dijkstra_predecessor_and_distance",
        "Description": [
            "Compute weighted shortest path length and predecessors.",
            "Uses Dijkstra\u2019s Method to obtain the shortest weighted paths\nand return dictionaries of predecessors for each node and\ndistance for each node from the source ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node label": "Starting node for path",
                "cutoff : integer or float, optional": "Length (sum of edge weights) at which the search is stopped.\nIf cutoff is provided, only return paths with summed weight <= cutoff.",
                "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge."
            },
            "Returns:": {
                "pred, distance : dictionaries": "Returns two dictionaries representing a list of predecessors\nof a node and the distance to each node."
            },
            "Raises:": {
                "NodeNotFound": "Ifsourceis not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The list of predecessors contains more than one element only when\nthere are more than one shortest paths to the key node.",
            "Examples": "G=nx.path_graph(5,create_using=nx.DiGraph())\npred,dist=nx.dijkstra_predecessor_and_distance(G,0)\nsorted(pred.items())\n# [(0, []), (1, [0]), (2, [1]), (3, [2]), (4, [3])]\nsorted(dist.items())\n# [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]\npred,dist=nx.dijkstra_predecessor_and_distance(G,0,1)\nsorted(pred.items())\n# [(0, []), (1, [0])]\nsorted(dist.items())\n# [(0, 0), (1, 1)]"
        }
    },
    {
        "Section ID": "has_path",
        "Description": [
            "Returns True if G has a path from source to target ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node": "Starting node for path",
                "target : node": "Ending node for path"
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "gn_graph",
        "Description": [
            "Returns the growing network (GN) digraph with n nodes.",
            "The GN graph is built by adding nodes one at a time with a link to one\npreviously added node.  The target node for the link is chosen with\nprobability based on degree.  The default attachment kernel is a linear\nfunction of the degree of a node.",
            "The graph is always a (directed) tree."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes for the generated graph.",
                "kernel : function": "The attachment kernel.",
                "create_using : NetworkX graph constructor, optional (default DiGraph)": "Graph type to create. If graph instance, then cleared before populated.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]P. L. Krapivsky and S. Redner,\nOrganization of Growing Random Networks,\nPhys. Rev. E, 63, 066123, 2001.",
            "Examples": "To create the undirected GN graph, use theto_directed()method:\nD=nx.gn_graph(10)# the GN graph\nG=D.to_undirected()# the undirected version\nTo specify an attachment kernel, use thekernelkeyword argument:\nD=nx.gn_graph(10,kernel=lambdax:x**1.5)# A_k = k^1.5"
        }
    },
    {
        "Section ID": "group_betweenness_centrality",
        "Description": [
            "Compute the group betweenness centrality for a group of nodes.",
            "Group betweenness centrality of a group of nodes \\(C\\) is the sum of the\nfraction of all-pairs shortest paths that pass through any vertex in \\(C\\)",
            "where \\(V\\) is the set of nodes, \\(\\sigma(s, t)\\) is the number of\nshortest \\((s, t)\\) -paths, and \\(\\sigma(s, t|C)\\) is the number of\nthose paths passing through some node in group \\(C\\) . Note that \\((s, t)\\) are not members of the group ( \\(V-C\\) is the set of nodes\nin \\(V\\) that are not in \\(C\\) )."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.",
                "C : list or set or list of lists or list of sets": "A group or a list of groups containing nodes which belong to G, for which group betweenness\ncentrality is to be calculated.",
                "normalized : bool, optional (default=True)": "If True, group betweenness is normalized by1/((|V|-|C|)(|V|-|C|-1))where|V|is the number of nodes in G and|C|is the number of nodes in C.",
                "weight : None or string, optional (default=None)": "If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight.\nThe weight of an edge is treated as the length or distance between the two sides.",
                "endpoints : bool, optional (default=False)": "If True include the endpoints in the shortest path counts."
            },
            "Returns:": {
                "betweenness : list of floats or float": "If C is a single group then return a float. If C is a list with\nseveral groups then return a list of group betweenness centralities."
            },
            "Raises:": {
                "NodeNotFound": "If node(s) in C are not present in G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Group betweenness centrality is described in [1] and its importance discussed in [3] .\nThe initial implementation of the algorithm is mentioned in [2] . This function uses\nan improved algorithm presented in [4] . The number of nodes in the group must be a maximum of n - 2 where n is the total number of nodes in the graph. For weighted graphs the edge weights must be greater than zero.\nZero edge weights can produce an infinite number of equal length\npaths between pairs of nodes. The total number of paths between source and target is counted\ndifferently for directed and undirected graphs. Directed paths\nbetween \u201cu\u201d and \u201cv\u201d are counted as two possible paths (one each\ndirection) while undirected paths between \u201cu\u201d and \u201cv\u201d are counted\nas one path. Said another way, the sum in the expression above is\nover all s!=t for directed graphs and for s<t for undirected graphs.",
            "References": "[1]M G Everett and S P Borgatti:\nThe Centrality of Groups and Classes.\nJournal of Mathematical Sociology. 23(3): 181-201. 1999.http://www.analytictech.com/borgatti/group_centrality.htm  [2]Ulrik Brandes:\nOn Variants of Shortest-Path Betweenness\nCentrality and their Generic Computation.\nSocial Networks 30(2):136-145, 2008.http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.72.9610&rep=rep1&type=pdf  [3]Sourav Medya et. al.:\nGroup Centrality Maximization via Network Design.\nSIAM International Conference on Data Mining, SDM 2018, 126\u2013134.https://sites.cs.ucsb.edu/~arlei/pubs/sdm18.pdf  [4]Rami Puzis, Yuval Elovici, and Shlomi Dolev.\n\u201cFast algorithm for successive computation of group betweenness centrality.\u201dhttps://journals.aps.org/pre/pdf/10.1103/PhysRevE.76.056709"
        }
    },
    {
        "Section ID": "to_latex_raw",
        "Description": [
            "Return a string of the LaTeX/TikZ code to draw G",
            "This function produces just the code for the tikzpicture\nwithout any enclosing environment."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "The NetworkX graph to be drawn",
                "pos : string or dict (default \u201cpos\u201d)": "The name of the node attribute onGthat holds the position of each node.\nPositions can be sequences of length 2 with numbers for (x,y) coordinates.\nThey can also be strings to denote positions in TikZ style, such as (x, y)\nor (angle:radius).\nIf a dict, it should be keyed by node to a position.\nIf an empty dict, a circular layout is computed by TikZ.",
                "tikz_options : string": "The tikzpicture options description defining the options for the picture.\nOften large scale options like[scale=2].",
                "default_node_options : string": "The draw options for a path of nodes. Individual node options override these.",
                "node_options : string or dict": "The name of the node attribute onGthat holds the options for each node.\nOr a dict keyed by node to a string holding the options for that node.",
                "node_label : string or dict": "The name of the node attribute onGthat holds the node label (text)\ndisplayed for each node. If the attribute is \u201c\u201d or not present, the node\nitself is drawn as a string. LaTeX processing such as\"$A_1$\"is allowed.\nOr a dict keyed by node to a string holding the label for that node.",
                "default_edge_options : string": "The options for the scope drawing all edges. The default is \u201c[-]\u201d for\nundirected graphs and \u201c[->]\u201d for directed graphs.",
                "edge_options : string or dict": "The name of the edge attribute onGthat holds the options for each edge.\nIf the edge is a self-loop and\"loop\"notinedge_optionsthe option\n\u201cloop,\u201d is added to the options for the self-loop edge. Hence you can\nuse \u201c[loop above]\u201d explicitly, but the default is \u201c[loop]\u201d.\nOr a dict keyed by edge to a string holding the options for that edge.",
                "edge_label : string or dict": "The name of the edge attribute onGthat holds the edge label (text)\ndisplayed for each edge. If the attribute is \u201c\u201d or not present, no edge\nlabel is drawn.\nOr a dict keyed by edge to a string holding the label for that edge.",
                "edge_label_options : string or dict": "The name of the edge attribute onGthat holds the label options for\neach edge. For example, \u201c[sloped,above,blue]\u201d. The default is no options.\nOr a dict keyed by edge to a string holding the label options for that edge."
            },
            "Returns:": {
                "latex_code : string": "The text string which draws the desired graph(s) when compiled by LaTeX."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "draw_networkx",
        "Description": [
            "Draw the graph G using Matplotlib.",
            "Draw the graph with Matplotlib with options for node positions,\nlabeling, titles, and many other drawing features.\nSee draw() for simple drawing without labels or axes."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph",
                "pos : dictionary, optional": "A dictionary with nodes as keys and positions as values.\nIf not specified a spring layout positioning will be computed.\nSeenetworkx.drawing.layoutfor functions that\ncompute node positions.",
                "arrows : bool or None, optional (default=None)": "IfNone, directed graphs draw arrowheads withFancyArrowPatch, while undirected graphs draw edges\nviaLineCollectionfor speed.\nIfTrue, draw arrowheads with FancyArrowPatches (bendable and stylish).\nIfFalse, draw edges using LineCollection (linear and fast).\nFor directed graphs, if True draw arrowheads.\nNote: Arrows will be the same color as edges.",
                "arrowstyle : str (default=\u2019-|>\u2019 for directed graphs)": "For directed graphs, choose the style of the arrowsheads.\nFor undirected graphs default to \u2018-\u2019Seematplotlib.patches.ArrowStylefor more options.",
                "arrowsize : int or list (default=10)": "For directed graphs, choose the size of the arrow head\u2019s length and\nwidth. A list of values can be passed in to assign a different size for arrow head\u2019s length and width.\nSeematplotlib.patches.FancyArrowPatchfor attributemutation_scalefor more info.",
                "with_labels : bool (default=True)": "Set to True to draw labels on the nodes.",
                "ax : Matplotlib Axes object, optional": "Draw the graph in the specified Matplotlib axes.",
                "nodelist : list (default=list(G))": "Draw only specified nodes",
                "edgelist : list (default=list(G.edges()))": "Draw only specified edges",
                "node_size : scalar or array (default=300)": "Size of nodes.  If an array is specified it must be the\nsame length as nodelist.",
                "node_color : color or array of colors (default=\u2019#1f78b4\u2019)": "Node color. Can be a single color or a sequence of colors with the same\nlength as nodelist. Color can be string or rgb (or rgba) tuple of\nfloats from 0-1. If numeric values are specified they will be\nmapped to colors using the cmap and vmin,vmax parameters. See\nmatplotlib.scatter for more details.",
                "node_shape : string (default=\u2019o\u2019)": "The shape of the node.  Specification is as matplotlib.scatter\nmarker, one of \u2018so^>v<dph8\u2019.",
                "alpha : float or None (default=None)": "The node and edge transparency",
                "cmap : Matplotlib colormap, optional": "Colormap for mapping intensities of nodes",
                "vmin,vmax : float, optional": "Minimum and maximum for node colormap scaling",
                "linewidths : scalar or sequence (default=1.0)": "Line width of symbol border",
                "width : float or array of floats (default=1.0)": "Line width of edges",
                "edge_color : color or array of colors (default=\u2019k\u2019)": "Edge color. Can be a single color or a sequence of colors with the same\nlength as edgelist. Color can be string or rgb (or rgba) tuple of\nfloats from 0-1. If numeric values are specified they will be\nmapped to colors using the edge_cmap and edge_vmin,edge_vmax parameters.",
                "edge_cmap : Matplotlib colormap, optional": "Colormap for mapping intensities of edges",
                "edge_vmin,edge_vmax : floats, optional": "Minimum and maximum for edge colormap scaling",
                "style : string (default=solid line)": "Edge line style e.g.: \u2018-\u2019, \u2018\u2013\u2019, \u2018-.\u2019, \u2018:\u2019\nor words like \u2018solid\u2019 or \u2018dashed\u2019.\n(Seematplotlib.patches.FancyArrowPatch:linestyle)",
                "labels : dictionary (default=None)": "Node labels in a dictionary of text labels keyed by node",
                "font_size : int (default=12 for nodes, 10 for edges)": "Font size for text labels",
                "font_color : color (default=\u2019k\u2019 black)": "Font color string. Color can be string or rgb (or rgba) tuple of\nfloats from 0-1.",
                "font_weight : string (default=\u2019normal\u2019)": "Font weight",
                "font_family : string (default=\u2019sans-serif\u2019)": "Font family",
                "label : string, optional": "Label for graph legend",
                "hide_ticks : bool, optional": "Hide ticks of axes. WhenTrue(the default), ticks and ticklabels\nare removed from the axes. To set ticks and tick labels to the pyplot default,\nusehide_ticks=False.",
                "kwds : optional keywords": "See networkx.draw_networkx_nodes(), networkx.draw_networkx_edges(), and\nnetworkx.draw_networkx_labels() for a description of optional keywords."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For directed graphs, arrows  are drawn at the head end.  Arrows can be\nturned off with keyword arrows=False.",
            "Examples": "G=nx.dodecahedral_graph()\nnx.draw(G)\nnx.draw(G,pos=nx.spring_layout(G))# use spring layout\nimportmatplotlib.pyplotasplt\nlimits=plt.axis(\"off\")# turn off axis\nAlso see the NetworkX drawing examples athttps://networkx.org/documentation/latest/auto_examples/index.html"
        }
    },
    {
        "Section ID": "parse_edgelist",
        "Description": [
            "Parse lines of an edge list representation of a graph."
        ],
        "Field List": {
            "Parameters:": {
                "lines : list or iterator of strings": "Input data in edgelist format",
                "comments : string, optional": "Marker for comment lines. Default is'#'. To specify that no character\nshould be treated as a comment, usecomments=None.",
                "delimiter : string, optional": "Separator for node labels. Default isNone, meaning any whitespace.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated.",
                "nodetype : Python type, optional": "Convert nodes to this type. Default isNone, meaning no conversion is\nperformed.",
                "data : bool or list of (label,type) tuples": "IfFalsegenerate no edge data or ifTrueuse a dictionary\nrepresentation of edge data or a list tuples specifying dictionary\nkey names and types for edge data."
            },
            "Returns:": {
                "G: NetworkX Graph": "The graph corresponding to lines"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "Edgelist with no data:\nlines=[\"1 2\",\"2 3\",\"3 4\"]\nG=nx.parse_edgelist(lines,nodetype=int)\nlist(G)\n# [1, 2, 3, 4]\nlist(G.edges())\n# [(1, 2), (2, 3), (3, 4)]\nEdgelist with data in Python dictionary representation:\nlines=[\"1 2 {'weight': 3}\",\"2 3 {'weight': 27}\",\"3 4 {'weight': 3.0}\"]\nG=nx.parse_edgelist(lines,nodetype=int)\nlist(G)\n# [1, 2, 3, 4]\nlist(G.edges(data=True))\n# [(1, 2, {'weight': 3}), (2, 3, {'weight': 27}), (3, 4, {'weight': 3.0})]\nEdgelist with data in a list:\nlines=[\"1 2 3\",\"2 3 27\",\"3 4 3.0\"]\nG=nx.parse_edgelist(lines,nodetype=int,data=((\"weight\",float),))\nlist(G)\n# [1, 2, 3, 4]\nlist(G.edges(data=True))\n# [(1, 2, {'weight': 3.0}), (2, 3, {'weight': 27.0}), (3, 4, {'weight': 3.0})]"
        }
    },
    {
        "Section ID": "FilterMultiInner",
        "Description": [
            "A read-only Mapping of Mappings with filtering criteria for nodes and edges.",
            "It is a view into a dict-of-dict-of-dict-of-dict data structure, and it selects nodes\nand edges that meet specific criteria defined by NODE_OK and EDGE_OK ."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "hide_multidiedges",
        "Description": [
            "Returns a filter function that hides specific multi-directed edges."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "random_shell_graph",
        "Description": [
            "Returns a random shell graph for the constructor given."
        ],
        "Field List": {
            "Parameters:": {
                "constructor : list of three-tuples": "Represents the parameters for a shell, starting at the center\nshell.  Each element of the list must be of the form(n,m,d), wherenis the number of nodes in the shell,mis\nthe number of edges in the shell, anddis the ratio of\ninter-shell (next) edges to intra-shell edges. Ifdis zero,\nthere will be no intra-shell edges, and ifdis one there\nwill be all possible intra-shell edges.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "constructor=[(10,20,0.8),(20,40,0.8)]\nG=nx.random_shell_graph(constructor)"
        }
    },
    {
        "Section ID": "joint_degree_graph",
        "Description": [
            "Generates a random simple graph with the given joint degree dictionary."
        ],
        "Field List": {
            "Parameters:": {
                "joint_degrees : dictionary of dictionary of integers": "A joint degree dictionary in which entryjoint_degrees[k][l]is the\nnumber of edges joining nodes of degreekwith nodes of degreel.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "G : Graph": "A graph with the specified joint degree dictionary."
            },
            "Raises:": {
                "NetworkXError": "Ifjoint_degreesdictionary is not realizable."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "In each iteration of the \u201cwhile loop\u201d the algorithm picks two disconnected\nnodes v and w , of degree k and l correspondingly,  for which joint_degrees[k][l] has not reached its target yet. It then adds\nedge ( v , w ) and increases the number of edges in graph G by one. The intelligence of the algorithm lies in the fact that  it is always\npossible to add an edge between such disconnected nodes v and w ,\neven if one or both nodes do not have free stubs. That is made possible by\nexecuting a \u201cneighbor switch\u201d, an edge rewiring move that releases\na free stub while keeping the joint degree of G the same. The algorithm continues for E (number of edges) iterations of\nthe \u201cwhile loop\u201d, at the which point all entries of the given joint_degrees[k][l] have reached their target values and the\nconstruction is complete.",
            "References": "[1]M. Gjoka, B. Tillman, A. Markopoulou, \u201cConstruction of Simple\nGraphs with a Target Joint Degree Matrix and Beyond\u201d, IEEE Infocom, \u201815",
            "Examples": "joint_degrees={\n1:{4:1},\n2:{2:2,3:2,4:2},\n3:{2:2,4:1},\n4:{1:1,2:2,3:1},\n}\nG=nx.joint_degree_graph(joint_degrees)"
        }
    },
    {
        "Section ID": "cumulative_distribution",
        "Description": [
            "Returns normalized cumulative distribution from discrete distribution."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "waxman_graph",
        "Description": [
            "Returns a Waxman random graph.",
            "The Waxman random graph model places n nodes uniformly at random\nin a rectangular domain. Each pair of nodes at distance d is\njoined by an edge with probability",
            "This function implements both Waxman models, using the L keyword\nargument."
        ],
        "Field List": {
            "Parameters:": {
                "n : int or iterable": "Number of nodes or iterable of nodes",
                "beta: float": "Model parameter",
                "alpha: float": "Model parameter",
                "L : float, optional": "Maximum distance between nodes.  If not specified, the actual distance\nis calculated.",
                "domain : four-tuple of numbers, optional": "Domain size, given as a tuple of the form(x_min,y_min,x_max,y_max).",
                "metric : function": "A metric on vectors of numbers (represented as lists or\ntuples). This must be a function that accepts two lists (or\ntuples) as input and yields a number as output. The function\nmust also satisfy the four requirements of ametric.\nSpecifically, if\\(d\\)is the function and\\(x\\),\\(y\\),\nand\\(z\\)are vectors in the graph, then\\(d\\)must satisfy\\(d(x, y) \\ge 0\\),\\(d(x, y) = 0\\)if and only if\\(x = y\\),\\(d(x, y) = d(y, x)\\),\\(d(x, z) \\le d(x, y) + d(y, z)\\).If this argument is not specified, the Euclidean distance metric is\nused.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "pos_name : string, default=\u201dpos\u201d": "The name of the node attribute which represents the position\nin 2D coordinates of the node in the returned graph."
            },
            "Returns:": {
                "Graph": "A random Waxman graph, undirected and without self-loops. Each\nnode has a node attribute'pos'that stores the position of\nthat node in Euclidean space as generated by this function."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Starting in NetworkX 2.0 the parameters alpha and beta align with their\nusual roles in the probability distribution. In earlier versions their\npositions in the expression were reversed. Their position in the calling\nsequence reversed as well to minimize backward incompatibility.",
            "References": "[1]B. M. Waxman,Routing of multipoint connections.\nIEEE J. Select. Areas Commun. 6(9),(1988) 1617\u20131622.",
            "Examples": "Specify an alternate distance metric using themetrickeyword\nargument. For example, to use the \u201ctaxicab metric\u201d instead of the\ndefaultEuclidean metric:\ndist=lambdax,y:sum(abs(a-b)fora,binzip(x,y))\nG=nx.waxman_graph(10,0.5,0.1,metric=dist)"
        }
    },
    {
        "Section ID": "restricted_view",
        "Description": [
            "Returns a view of G with hidden nodes and edges.",
            "The resulting subgraph filters out node nodes and edges edges .\nFiltered out nodes also filter out any of their edges."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "",
                "nodes : iterable": "An iterable of nodes. Nodes not present inGare ignored.",
                "edges : iterable": "An iterable of edges. Edges not present inGare ignored."
            },
            "Returns:": {
                "subgraph : SubGraph View": "A read-only restricted view ofGfiltering out nodes and edges.\nChanges toGare reflected in the view."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "To create a mutable subgraph with its own copies of nodes\nedges and attributes use subgraph.copy() or Graph(subgraph) If you create a subgraph of a subgraph recursively you may end up\nwith a chain of subgraph views. Such chains can get quite slow\nfor lengths near 15. To avoid long chains, try to make your subgraph\nbased on the original graph.  We do not rule out chains programmatically\nso that odd cases like an edge_subgraph of a restricted_view can be created.",
            "Examples": "G=nx.path_graph(5)\nH=nx.restricted_view(G,[0],[(1,2),(3,4)])\nlist(H.nodes)\n# [1, 2, 3, 4]\nlist(H.edges)\n# [(2, 3)]"
        }
    },
    {
        "Section ID": "show_nodes",
        "Description": [
            "Filter class to show specific nodes."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "bfs_layers",
        "Description": [
            "Returns an iterator of all the layers in breadth-first search traversal."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A graph over which to find the layers using breadth-first search.",
                "sources : node inGor list of nodes inG": "Specify starting nodes for single source or multiple sources breadth-first search"
            },
            "Yields:": {
                "layer: list of nodes": "Yields list of nodes at the same distance from sources"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.path_graph(5)\ndict(enumerate(nx.bfs_layers(G,[0,4])))\n# {0: [0, 4], 1: [1, 3], 2: [2]}\nH=nx.Graph()\nH.add_edges_from([(0,1),(0,2),(1,3),(1,4),(2,5),(2,6)])\ndict(enumerate(nx.bfs_layers(H,[1])))\n# {0: [1], 1: [0, 3, 4], 2: [2], 3: [5, 6]}\ndict(enumerate(nx.bfs_layers(H,[1,6])))\n# {0: [1, 6], 1: [0, 3, 4, 2], 2: [5]}"
        }
    },
    {
        "Section ID": "write_dot",
        "Description": [
            "Write NetworkX graph G to Graphviz dot format on path."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph",
                "path : filename": "Filename or file handle to write"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "To use a specific graph layout, call A.layout prior to write_dot .\nNote that some graphviz layouts are not guaranteed to be deterministic,\nsee graphviz/graphviz#1767 for more info."
        }
    },
    {
        "Section ID": "groups",
        "Description": [
            "Converts a many-to-one mapping into a one-to-many mapping.",
            "many_to_one must be a dictionary whose keys and values are all hashable .",
            "The return value is a dictionary mapping values from many_to_one to sets of keys from many_to_one that have that value.",
            "Examples"
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {
            "Examples": "fromnetworkx.utilsimportgroups\nmany_to_one={\"a\":1,\"b\":1,\"c\":2,\"d\":3,\"e\":3}\ngroups(many_to_one)\n# {1: {'a', 'b'}, 2: {'c'}, 3: {'e', 'd'}}"
        }
    },
    {
        "Section ID": "is_pseudographical",
        "Description": [
            "Returns True if some pseudograph can realize the sequence.",
            "Every nonnegative integer sequence with an even sum is pseudographical\n(see [1] )."
        ],
        "Field List": {
            "Parameters:": {
                "sequence : list or iterable container": "A sequence of integer node degrees"
            },
            "Returns:": {
                "valid : bool": "True if the sequence is a pseudographic degree sequence and False if not."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The worst-case run time is \\(O(n)\\) where n is the length of the sequence.",
            "References": "[1]F. Boesch and F. Harary. \u201cLine removal algorithms for graphs\nand their degree lists\u201d, IEEE Trans. Circuits and Systems, CAS-23(12),\npp. 778-782 (1976).",
            "Examples": "G=nx.Graph([(1,2),(1,3),(2,3),(3,4),(4,2),(5,1),(5,4)])\nsequence=(dfor_,dinG.degree())\nnx.is_pseudographical(sequence)\n# True\nTo test a non-pseudographical sequence:\n>>> sequence_list = [d for _, d in G.degree()]\n>>> sequence_list[-1] += 1\n>>> nx.is_pseudographical(sequence_list)\nFalse"
        }
    },
    {
        "Section ID": "adjacency_graph",
        "Description": [
            "Returns graph from adjacency data format."
        ],
        "Field List": {
            "Parameters:": {
                "data : dict": "Adjacency list formatted graph data",
                "directed : bool": "If True, and direction not specified in data, return a directed graph.",
                "multigraph : bool": "If True, and multigraph not specified in data, return a multigraph.",
                "attrs : dict": "A dictionary that contains two keys \u2018id\u2019 and \u2018key\u2019. The corresponding\nvalues provide the attribute names for storing NetworkX-internal graph\ndata. The values should be unique. Default value:dict(id='id',key='key')."
            },
            "Returns:": {
                "G : NetworkX graph": "A NetworkX graph object"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The default value of attrs will be changed in a future release of NetworkX.",
            "Examples": "fromnetworkx.readwriteimportjson_graph\nG=nx.Graph([(1,2)])\ndata=json_graph.adjacency_data(G)\nH=json_graph.adjacency_graph(data)"
        }
    },
    {
        "Section ID": "edge_betweenness_partition",
        "Description": [
            "Partition created by iteratively removing the highest edge betweenness edge.",
            "This algorithm works by calculating the edge betweenness for all\nedges and removing the edge with the highest value. It is then\ndetermined whether the graph has been broken into at least number_of_sets connected components.\nIf not the process is repeated."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph, DiGraph or MultiGraph": "Graph to be partitioned",
                "number_of_sets : int": "Number of sets in the desired partition of the graph",
                "weight : key, optional, default=None": "The key to use if using weights for edge betweenness calculation"
            },
            "Returns:": {
                "C : list of sets": "Partition of the nodes of G"
            },
            "Raises:": {
                "NetworkXError": "If number_of_sets is <= 0 or if number_of_sets > len(G)"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm is fairly slow, as both the calculation of connected\ncomponents and edge betweenness relies on all pairs shortest\npath algorithms. They could potentially be combined to cut down\non overall computation time.",
            "References": "[1]Santo Fortunato \u2018Community Detection in Graphs\u2019 Physical Reports\nVolume 486, Issue 3-5 p. 75-174http://arxiv.org/abs/0906.0612",
            "Examples": "G=nx.karate_club_graph()\npart=nx.community.edge_betweenness_partition(G,2)\n{0,1,3,4,5,6,7,10,11,12,13,16,17,19,21}inpart\n# True\n{2,8,9,14,15,18,20,22,23,24,25,26,27,28,29,30,31,32,33}inpart\n# True"
        }
    },
    {
        "Section ID": "minimum_spanning_edges",
        "Description": [
            "Generate edges in a minimum spanning forest of an undirected\nweighted graph.",
            "A minimum spanning tree is a subgraph of the graph (a tree)\nwith the minimum sum of edge weights.  A spanning forest is a\nunion of the spanning trees for each connected component of the graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : undirected Graph": "An undirected graph. IfGis connected, then the algorithm finds a\nspanning tree. Otherwise, a spanning forest is found.",
                "algorithm : string": "The algorithm to use when finding a minimum spanning tree. Valid\nchoices are \u2018kruskal\u2019, \u2018prim\u2019, or \u2018boruvka\u2019. The default is \u2018kruskal\u2019.",
                "weight : string": "Edge data key to use for weight (default \u2018weight\u2019).",
                "keys : bool": "Whether to yield edge key in multigraphs in addition to the edge.\nIfGis not a multigraph, this is ignored.",
                "data : bool, optional": "If True yield the edge data along with the edge.",
                "ignore_nan : bool (default: False)": "If a NaN is found as an edge weight normally an exception is raised.\nIfignore_nanisTruethen that edge is ignored instead."
            },
            "Returns:": {
                "edges : iterator": "An iterator over edges in a maximum spanning tree ofG.\nEdges connecting nodesuandvare represented as tuples:(u,v,k,d)or(u,v,k)or(u,v,d)or(u,v)IfGis a multigraph,keysindicates whether the edge keykwill\nbe reported in the third position in the edge tuple.dataindicates\nwhether the edge datadictdwill appear at the end of the edge tuple.IfGis not a multigraph, the tuples are(u,v,d)ifdatais True\nor(u,v)ifdatais False."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For Bor\u016fvka\u2019s algorithm, each edge must have a weight attribute, and\neach edge weight must be distinct. For the other algorithms, if the graph edges do not have a weight\nattribute a default weight of 1 will be used. Modified code from David Eppstein, April 2006 http://www.ics.uci.edu/~eppstein/PADS/",
            "Examples": "fromnetworkx.algorithmsimporttree\nFind minimum spanning edges by Kruskal\u2019s algorithm\nG=nx.cycle_graph(4)\nG.add_edge(0,3,weight=2)\nmst=tree.minimum_spanning_edges(G,algorithm=\"kruskal\",data=False)\nedgelist=list(mst)\nsorted(sorted(e)foreinedgelist)\n# [[0, 1], [1, 2], [2, 3]]\nFind minimum spanning edges by Prim\u2019s algorithm\nG=nx.cycle_graph(4)\nG.add_edge(0,3,weight=2)\nmst=tree.minimum_spanning_edges(G,algorithm=\"prim\",data=False)\nedgelist=list(mst)\nsorted(sorted(e)foreinedgelist)\n# [[0, 1], [1, 2], [2, 3]]"
        }
    },
    {
        "Section ID": "generate_pajek",
        "Description": [
            "Generate lines in Pajek graph format."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A Networkx graph"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "See http://vlado.fmf.uni-lj.si/pub/networks/pajek/doc/draweps.htm for format information."
        }
    },
    {
        "Section ID": "write_pajek",
        "Description": [
            "Write graph in Pajek format to path."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A Networkx graph",
                "path : file or string": "File or filename to write.\nFilenames ending in .gz or .bz2 will be compressed."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "See http://vlado.fmf.uni-lj.si/pub/networks/pajek/doc/draweps.htm for format information.",
            "Examples": "G=nx.path_graph(4)\nnx.write_pajek(G,\"test.net\")"
        }
    },
    {
        "Section ID": "AtlasView",
        "Description": [
            "An AtlasView is a Read-only Mapping of Mappings.",
            "It is a View into a dict-of-dict data structure.\nThe inner level of dict is read-write. But the\nouter level is read-only."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "diameter",
        "Description": [
            "Returns a lower bound on the diameter of the graph G.",
            "The function computes a lower bound on the diameter (i.e., the maximum eccentricity)\nof a directed or undirected graph G. The procedure used varies depending on the graph\nbeing directed or not.",
            "If G is an undirected graph, then the function uses the 2-sweep algorithm [1] .\nThe main idea is to pick the farthest node from a random node and return its eccentricity.",
            "Otherwise, if G is a directed graph, the function uses the 2-dSweep algorithm [2] ,\nThe procedure starts by selecting a random source node \\(s\\) from which it performs a\nforward and a backward BFS. Let \\(a_1\\) and \\(a_2\\) be the farthest nodes in the forward and\nbackward cases, respectively. Then, it computes the backward eccentricity of \\(a_1\\) using\na backward BFS and the forward eccentricity of \\(a_2\\) using a forward BFS.\nFinally, it returns the best lower bound between the two.",
            "In both cases, the time complexity is linear with respect to the size of G."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "d : integer": "Lower Bound on the Diameter of G"
            },
            "Raises:": {
                "NetworkXError": "If the graph is empty or\nIf the graph is undirected and not connected or\nIf the graph is directed and not strongly connected."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Magnien, Cl\u00e9mence, Matthieu Latapy, and Michel Habib.Fast computation of empirically tight bounds for the diameter of massive graphs.Journal of Experimental Algorithmics (JEA), 2009.https://arxiv.org/pdf/0904.2728.pdf  [2]Crescenzi, Pierluigi, Roberto Grossi, Leonardo Lanzi, and Andrea Marino.On computing the diameter of real-world directed (weighted) graphs.International Symposium on Experimental Algorithms. Springer, Berlin, Heidelberg, 2012.https://courses.cs.ut.ee/MTAT.03.238/2014_fall/uploads/Main/diameter.pdf",
            "Examples": "G=nx.path_graph(10)# undirected graph\nnx.diameter(G)\n# 9\nG=nx.cycle_graph(3,create_using=nx.DiGraph)# directed graph\nnx.diameter(G)\n# 2"
        }
    },
    {
        "Section ID": "uniform_random_intersection_graph",
        "Description": [
            "Returns a uniform random intersection graph."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes in the first bipartite set (nodes)",
                "m : int": "The number of nodes in the second bipartite set (attributes)",
                "p : float": "Probability of connecting nodes between bipartite sets",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]K.B. Singer-Cohen, Random Intersection Graphs, 1995,\nPhD thesis, Johns Hopkins University  [2]Fill, J. A., Scheinerman, E. R., and Singer-Cohen, K. B.,\nRandom intersection graphs when m = !(n):\nAn equivalence theorem relating the evolution of the g(n, m, p)\nand g(n, p) models. Random Struct. Algorithms 16, 2 (2000), 156\u2013176."
        }
    },
    {
        "Section ID": "SpanningTreeIterator",
        "Description": [
            "Iterate over all spanning trees of a graph in either increasing or\ndecreasing cost.",
            "Notes",
            "This iterator uses the partition scheme from [1] (included edges,\nexcluded edges and open edges) as well as a modified Kruskal\u2019s Algorithm\nto generate minimum spanning trees which respect the partition of edges.\nFor spanning trees with the same weight, ties are broken arbitrarily.",
            "References"
        ],
        "Field List": {
            "Parameters:": {
                "G : nx.Graph": "The directed graph which we need to iterate trees over",
                "weight : String, default = \u201cweight\u201d": "The edge attribute used to store the weight of the edge",
                "minimum : bool, default = True": "Return the trees in increasing order while true and decreasing order\nwhile false.",
                "ignore_nan : bool, default = False": "If a NaN is found as an edge weight normally an exception is raised.\nIfignore_nanisTruethen that edge is ignored instead."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This iterator uses the partition scheme from [1] (included edges,\nexcluded edges and open edges) as well as a modified Kruskal\u2019s Algorithm\nto generate minimum spanning trees which respect the partition of edges.\nFor spanning trees with the same weight, ties are broken arbitrarily.",
            "References": "[1]G.K. Janssens, K. S\u00f6rensen, An algorithm to generate all spanning\ntrees in order of increasing cost, Pesquisa Operacional, 2005-08,\nVol. 25 (2), p. 219-229,https://www.scielo.br/j/pope/a/XHswBwRwJyrfL88dmMwYNWp/?lang=en"
        }
    },
    {
        "Section ID": "estrada_index",
        "Description": [
            "Returns the Estrada index of a the graph G.",
            "The Estrada Index is a topological index of folding or 3D \u201ccompactness\u201d ( [1] )."
        ],
        "Field List": {
            "Parameters:": {
                "G: graph": ""
            },
            "Returns:": {
                "estrada index: float": ""
            },
            "Raises:": {
                "NetworkXError": "If the graph is not undirected and simple."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Let G=(V,E) be a simple undirected graph with n nodes  and let lambda_{1}leqlambda_{2}leqcdotslambda_{n} be a non-increasing ordering of the eigenvalues of its adjacency\nmatrix A . The Estrada index is ( [1] , [2] )",
            "References": "[1](1,2)E. Estrada, \u201cCharacterization of 3D molecular structure\u201d,\nChem. Phys. Lett. 319, 713 (2000).https://doi.org/10.1016/S0009-2614(00)00158-5  [2]Jos\u00e9 Antonio de la Pe\u00f1aa, Ivan Gutman, Juan Rada,\n\u201cEstimating the Estrada index\u201d,\nLinear Algebra and its Applications. 427, 1 (2007).https://doi.org/10.1016/j.laa.2007.06.020",
            "Examples": "G=nx.Graph([(0,1),(1,2),(1,5),(5,4),(2,4),(2,3),(4,3),(3,6)])\nei=nx.estrada_index(G)\nprint(f\"{ei:0.5}\")\n# 20.55"
        }
    },
    {
        "Section ID": "add_cycle",
        "Description": [
            "Add a cycle to the Graph G_to_add_to."
        ],
        "Field List": {
            "Parameters:": {
                "G_to_add_to : graph": "A NetworkX graph",
                "nodes_for_cycle: iterable container": "A container of nodes.  A cycle will be constructed from\nthe nodes (in order) and added to the graph.",
                "attr : keyword arguments, optional (default= no attributes)": "Attributes to add to every edge in cycle."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nnx.add_cycle(G,[0,1,2,3])\nnx.add_cycle(G,[10,11,12],weight=7)"
        }
    },
    {
        "Section ID": "random_degree_sequence_graph",
        "Description": [
            "Returns a simple random graph with the given degree sequence.",
            "If the maximum degree \\(d_m\\) in the sequence is \\(O(m^{1/4})\\) then the\nalgorithm produces almost uniform random graphs in \\(O(m d_m)\\) time\nwhere \\(m\\) is the number of edges."
        ],
        "Field List": {
            "Parameters:": {
                "sequence : list of integers": "Sequence of degrees",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "tries : int, optional": "Maximum number of tries to create a graph"
            },
            "Returns:": {
                "G : Graph": "A graph with the specified degree sequence.\nNodes are labeled starting at 0 with an index\ncorresponding to the position in the sequence."
            },
            "Raises:": {
                "NetworkXUnfeasible": "If the degree sequence is not graphical.",
                "NetworkXError": "If a graph is not produced in specified number of tries"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The generator algorithm [1] is not guaranteed to produce a graph.",
            "References": "[1]Moshen Bayati, Jeong Han Kim, and Amin Saberi,\nA sequential algorithm for generating random graphs.\nAlgorithmica, Volume 58, Number 4, 860-910,\nDOI: 10.1007/s00453-009-9340-1",
            "Examples": "sequence=[1,2,2,3]\nG=nx.random_degree_sequence_graph(sequence,seed=42)\nsorted(dforn,dinG.degree())\n# [1, 2, 2, 3]"
        }
    },
    {
        "Section ID": "all_simple_paths",
        "Description": [
            "Generate all simple paths in the graph G from source to target.",
            "A simple path is a path with no repeated nodes."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node": "Starting node for path",
                "target : nodes": "Single node or iterable of nodes at which to end path",
                "cutoff : integer, optional": "Depth to stop the search. Only paths of length <= cutoff are returned."
            },
            "Returns:": {
                "path_generator: generator": "A generator that produces lists of simple paths.  If there are no paths\nbetween the source and target within the given cutoff the generator\nproduces no output. If it is possible to traverse the same sequence of\nnodes in multiple ways, namely through parallel edges, then it will be\nreturned multiple times (once for each viable edge combination)."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm uses a modified depth-first search to generate the\npaths [1] .  A single path can be found in \\(O(V+E)\\) time but the\nnumber of simple paths in a graph can be very large, e.g. \\(O(n!)\\) in\nthe complete graph of order \\(n\\) . This function does not check that a path exists between source and target . For large graphs, this may result in very long runtimes.\nConsider using has_path to check that a path exists between source and target before calling this function on large graphs.",
            "References": "[1]R. Sedgewick, \u201cAlgorithms in C, Part 5: Graph Algorithms\u201d,\nAddison Wesley Professional, 3rd ed., 2001.",
            "Examples": "This iterator generates lists of nodes:\nG=nx.complete_graph(4)\nforpathinnx.all_simple_paths(G,source=0,target=3):\nprint(path)\n\n# [0, 1, 2, 3]\n# [0, 1, 3]\n# [0, 2, 1, 3]\n# [0, 2, 3]\n# [0, 3]\nYou can generate only those paths that are shorter than a certain\nlength by using thecutoffkeyword argument:\npaths=nx.all_simple_paths(G,source=0,target=3,cutoff=2)\nprint(list(paths))\n# [[0, 1, 3], [0, 2, 3], [0, 3]]\nTo get each path as the corresponding list of edges, you can use thenetworkx.utils.pairwise()helper function:\npaths=nx.all_simple_paths(G,source=0,target=3)\nforpathinmap(nx.utils.pairwise,paths):\nprint(list(path))\n# [(0, 1), (1, 2), (2, 3)]\n# [(0, 1), (1, 3)]\n# [(0, 2), (2, 1), (1, 3)]\n# [(0, 2), (2, 3)]\n# [(0, 3)]\nPass an iterable of nodes as target to generate all paths ending in any of several nodes:\nG=nx.complete_graph(4)\nforpathinnx.all_simple_paths(G,source=0,target=[3,2]):\nprint(path)\n\n# [0, 1, 2]\n# [0, 1, 2, 3]\n# [0, 1, 3]\n# [0, 1, 3, 2]\n# [0, 2]\n# [0, 2, 1, 3]\n# [0, 2, 3]\n# [0, 3]\n# [0, 3, 1, 2]\n# [0, 3, 2]\nThe singleton path fromsourceto itself is considered a simple path and is\nincluded in the results:\nG=nx.empty_graph(5)\nlist(nx.all_simple_paths(G,source=0,target=0))\n# [[0]]\nG=nx.path_graph(3)\nlist(nx.all_simple_paths(G,source=0,target={0,1,2}))\n# [[0], [0, 1], [0, 1, 2]]\nIterate over each path from the root nodes to the leaf nodes in a\ndirected acyclic graph using a functional programming approach:\nfromitertoolsimportchain\nfromitertoolsimportproduct\nfromitertoolsimportstarmap\nfromfunctoolsimportpartial\n\nchaini=chain.from_iterable\n\nG=nx.DiGraph([(0,1),(1,2),(0,3),(3,2)])\nroots=(vforv,dinG.in_degree()ifd==0)\nleaves=(vforv,dinG.out_degree()ifd==0)\nall_paths=partial(nx.all_simple_paths,G)\nlist(chaini(starmap(all_paths,product(roots,leaves))))\n# [[0, 1, 2], [0, 3, 2]]\nThe same list computed using an iterative approach:\nG=nx.DiGraph([(0,1),(1,2),(0,3),(3,2)])\nroots=(vforv,dinG.in_degree()ifd==0)\nleaves=(vforv,dinG.out_degree()ifd==0)\nall_paths=[]\nforrootinroots:\nforleafinleaves:\npaths=nx.all_simple_paths(G,root,leaf)\nall_paths.extend(paths)\nall_paths\n# [[0, 1, 2], [0, 3, 2]]\nIterate over each path from the root nodes to the leaf nodes in a\ndirected acyclic graph passing all leaves together to avoid unnecessary\ncompute:\nG=nx.DiGraph([(0,1),(2,1),(1,3),(1,4)])\nroots=(vforv,dinG.in_degree()ifd==0)\nleaves=[vforv,dinG.out_degree()ifd==0]\nall_paths=[]\nforrootinroots:\npaths=nx.all_simple_paths(G,root,leaves)\nall_paths.extend(paths)\nall_paths\n# [[0, 1, 3], [0, 1, 4], [2, 1, 3], [2, 1, 4]]\nIf parallel edges offer multiple ways to traverse a given sequence of\nnodes, this sequence of nodes will be returned multiple times:\nG=nx.MultiDiGraph([(0,1),(0,1),(1,2)])\nlist(nx.all_simple_paths(G,0,2))\n# [[0, 1, 2], [0, 1, 2]]"
        }
    },
    {
        "Section ID": "overlap_weighted_projected_graph",
        "Description": [
            "Overlap weighted projection of B onto one of its node sets.",
            "The overlap weighted projection is the projection of the bipartite\nnetwork B onto the specified nodes with weights representing\nthe Jaccard index between the neighborhoods of the two nodes in the\noriginal bipartite network [1] :",
            "or if the parameter \u2018jaccard\u2019 is False, the fraction of common\nneighbors by minimum of both nodes degree in the original\nbipartite graph [1] :",
            "The nodes retain their attributes and are connected in the resulting\ngraph if have an edge to a common node in the original bipartite graph."
        ],
        "Field List": {
            "Parameters:": {
                "B : NetworkX graph": "The input graph should be bipartite.",
                "nodes : list or iterable": "Nodes to project onto (the \u201cbottom\u201d nodes).",
                "jaccard: Bool (default=True)": ""
            },
            "Returns:": {
                "Graph : NetworkX graph": "A graph that is the projection onto the given nodes."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "No attempt is made to verify that the input graph B is bipartite.\nThe graph and node properties are (shallow) copied to the projected graph. See bipartitedocumentation for further details on how bipartite graphs are handled in NetworkX.",
            "References": "[1](1,2)Borgatti, S.P. and Halgin, D. In press. Analyzing Affiliation\nNetworks. In Carrington, P. and Scott, J. (eds) The Sage Handbook\nof Social Network Analysis. Sage Publications.",
            "Examples": "fromnetworkx.algorithmsimportbipartite\nB=nx.path_graph(5)\nnodes=[0,2,4]\nG=bipartite.overlap_weighted_projected_graph(B,nodes)\nlist(G)\n# [0, 2, 4]\nlist(G.edges(data=True))\n# [(0, 2, {'weight': 0.5}), (2, 4, {'weight': 0.5})]\nG=bipartite.overlap_weighted_projected_graph(B,nodes,jaccard=False)\nlist(G.edges(data=True))\n# [(0, 2, {'weight': 1.0}), (2, 4, {'weight': 1.0})]"
        }
    },
    {
        "Section ID": "reciprocity",
        "Description": [
            "Compute the reciprocity in a directed graph.",
            "The reciprocity of a directed graph is defined as the ratio\nof the number of edges pointing in both directions to the total\nnumber of edges in the graph.\nFormally, \\(r = |{(u,v) \\in G|(v,u) \\in G}| / |{(u,v) \\in G}|\\) .",
            "The reciprocity of a single node u is defined similarly,\nit is the ratio of the number of edges in both directions to\nthe total number of edges attached to node u."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx directed graph",
                "nodes : container of nodes, optional (default=whole graph)": "Compute reciprocity for nodes in this container."
            },
            "Returns:": {
                "out : dictionary": "Reciprocity keyed by node label."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The reciprocity is not defined for isolated nodes.\nIn such cases this function will return None."
        }
    },
    {
        "Section ID": "articulation_points",
        "Description": [
            "Yield the articulation points, or cut vertices, of a graph.",
            "An articulation point or cut vertex is any node whose removal (along with\nall its incident edges) increases the number of connected components of\na graph.  An undirected connected graph without articulation points is\nbiconnected. Articulation points belong to more than one biconnected\ncomponent of a graph.",
            "Notice that by convention a dyad is considered a biconnected component."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "An undirected graph."
            },
            "Yields:": {
                "node": "An articulation point in the graph."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the input graph is not undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The algorithm to find articulation points and biconnected\ncomponents is implemented using a non-recursive depth-first-search\n(DFS) that keeps track of the highest level that back edges reach\nin the DFS tree.  A node n is an articulation point if, and only\nif, there exists a subtree rooted at n such that there is no\nback edge from any successor of n that links to a predecessor of n in the DFS tree.  By keeping track of all the edges traversed\nby the DFS we can obtain the biconnected components because all\nedges of a bicomponent will be traversed consecutively between\narticulation points.",
            "References": "[1]Hopcroft, J.; Tarjan, R. (1973).\n\u201cEfficient algorithms for graph manipulation\u201d.\nCommunications of the ACM 16: 372\u2013378. doi:10.1145/362248.362272",
            "Examples": "G=nx.barbell_graph(4,2)\nprint(nx.is_biconnected(G))\n# False\nlen(list(nx.articulation_points(G)))\n# 4\nG.add_edge(2,8)\nprint(nx.is_biconnected(G))\n# True\nlen(list(nx.articulation_points(G)))\n# 0"
        }
    },
    {
        "Section ID": "all_neighbors",
        "Description": [
            "Returns all of the neighbors of a node in the graph.",
            "If the graph is directed returns predecessors as well as successors."
        ],
        "Field List": {
            "Parameters:": {
                "graph : NetworkX graph": "Graph to find neighbors.",
                "node : node": "The node whose neighbors will be returned."
            },
            "Returns:": {
                "neighbors : iterator": "Iterator of neighbors"
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "newman_watts_strogatz_graph",
        "Description": [
            "Returns a Newman\u2013Watts\u2013Strogatz small-world graph."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes.",
                "k : int": "Each node is joined with itsknearest neighbors in a ring\ntopology.",
                "p : float": "The probability of adding a new edge for each edge.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "First create a ring over \\(n\\) nodes [1] .  Then each node in the ring is\nconnected with its \\(k\\) nearest neighbors (or \\(k - 1\\) neighbors if \\(k\\) is odd).  Then shortcuts are created by adding new edges as follows: for\neach edge \\((u, v)\\) in the underlying \u201c \\(n\\) -ring with \\(k\\) nearest\nneighbors\u201d with probability \\(p\\) add a new edge \\((u, w)\\) with\nrandomly-chosen existing node \\(w\\) .  In contrast with watts_strogatz_graph() , no edges are removed.",
            "References": "[1]M. E. J. Newman and D. J. Watts,\nRenormalization group analysis of the small-world network model,\nPhysics Letters A, 263, 341, 1999.https://doi.org/10.1016/S0375-9601(99)00757-4"
        }
    },
    {
        "Section ID": "bellman_ford_predecessor_and_distance",
        "Description": [
            "Compute shortest path lengths and predecessors on shortest paths\nin weighted graphs.",
            "The algorithm has a running time of \\(O(mn)\\) where \\(n\\) is the number of\nnodes and \\(m\\) is the number of edges.  It is slower than Dijkstra but\ncan handle negative edge weights.",
            "If a negative cycle is detected, you can use find_negative_cycle() to return the cycle and examine it. Shortest paths are not defined when\na negative cycle exists because once reached, the path can cycle forever\nto build up arbitrarily low weights."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "The algorithm works for all types of graphs, including directed\ngraphs and multigraphs.",
                "source: node label": "Starting node for path",
                "target : node label, optional": "Ending node for path",
                "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number.",
                "heuristic : bool": "Determines whether to use a heuristic to early detect negative\ncycles at a hopefully negligible cost."
            },
            "Returns:": {
                "pred, dist : dictionaries": "Returns two dictionaries keyed by node to predecessor in the\npath and to the distance from the source respectively."
            },
            "Raises:": {
                "NodeNotFound": "Ifsourceis not inG.",
                "NetworkXUnbounded": "If the (di)graph contains a negative (di)cycle, the\nalgorithm raises an exception to indicate the presence of the\nnegative (di)cycle.  Note: any negative weight edge in an\nundirected graph is a negative cycle."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The dictionaries returned only have keys for nodes reachable from\nthe source. In the case where the (di)graph is not connected, if a component\nnot containing the source contains a negative (di)cycle, it\nwill not be detected. In NetworkX v2.1 and prior, the source node had predecessor [None] .\nIn NetworkX v2.2 this changed to the source node having predecessor []",
            "Examples": "G=nx.path_graph(5,create_using=nx.DiGraph())\npred,dist=nx.bellman_ford_predecessor_and_distance(G,0)\nsorted(pred.items())\n# [(0, []), (1, [0]), (2, [1]), (3, [2]), (4, [3])]\nsorted(dist.items())\n# [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]\npred,dist=nx.bellman_ford_predecessor_and_distance(G,0,1)\nsorted(pred.items())\n# [(0, []), (1, [0]), (2, [1]), (3, [2]), (4, [3])]\nsorted(dist.items())\n# [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]\nG=nx.cycle_graph(5,create_using=nx.DiGraph())\nG[1][2][\"weight\"]=-7\nnx.bellman_ford_predecessor_and_distance(G,0)Traceback (most recent call last):    ...networkx.exception.NetworkXUnboundedNegative cycle detected."
        }
    },
    {
        "Section ID": "eccentricity",
        "Description": [
            "Returns the eccentricity of nodes in G.",
            "The eccentricity of a node v is the maximum distance from v to\nall other nodes in G."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A graph",
                "v : node, optional": "Return value of specified node",
                "sp : dict of dicts, optional": "All pairs shortest path lengths as a dictionary of dictionaries",
                "weight : string, function, or None (default=None)": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number.If this is None, every edge has weight/distance/cost 1.Weights stored as floating point values can lead to small round-off\nerrors in distances. Use integer weights to avoid this.Weights should be positive, since they are distances."
            },
            "Returns:": {
                "ecc : dictionary": "A dictionary of eccentricity values keyed by node."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph([(1,2),(1,3),(1,4),(3,4),(3,5),(4,5)])\ndict(nx.eccentricity(G))\n# {1: 2, 2: 3, 3: 2, 4: 2, 5: 3}\ndict(nx.eccentricity(G,v=[1,5]))# This returns the eccentricity of node 1 & 5\n# {1: 2, 5: 3}"
        }
    },
    {
        "Section ID": "UnionMultiInner",
        "Description": [
            "A read-only union of two inner dicts of MultiAdjacencies.",
            "The two input dict-of-dict-of-dicts represent the union of G.succ[node] and G.pred[node] for MultiDiGraphs.\nReturn values are UnionAtlas.\nThe inner level of dict is read-write. But the outer levels are read-only."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "generalized_degree",
        "Description": [
            "Compute the generalized degree for nodes.",
            "For each node, the generalized degree shows how many edges of given\ntriangle multiplicity the node is connected to. The triangle multiplicity\nof an edge is the number of triangles an edge participates in. The\ngeneralized degree of node \\(i\\) can be written as a vector \\(\\mathbf{k}_i=(k_i^{(0)}, \\dotsc, k_i^{(N-2)})\\) where \\(k_i^{(j)}\\) is the number of edges attached to node \\(i\\) that\nparticipate in \\(j\\) triangles."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "",
                "nodes : container of nodes, optional (default=all nodes in G)": "Compute the generalized degree for nodes in this container."
            },
            "Returns:": {
                "out : Counter, or dictionary of Counters": "Generalized degree of specified nodes. The Counter is keyed by edge\ntriangle multiplicity."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Self loops are ignored. In a network of N nodes, the highest triangle multiplicity an edge can have\nis N-2. The return value does not include a zero entry if no edges of a\nparticular triangle multiplicity are present. The number of triangles node \\(i\\) is attached to can be recovered from\nthe generalized degree \\(\\mathbf{k}_i=(k_i^{(0)}, \\dotsc,\nk_i^{(N-2)})\\) by \\((k_i^{(1)}+2k_i^{(2)}+\\dotsc +(N-2)k_i^{(N-2)})/2\\) .",
            "References": "[1]Networks with arbitrary edge multiplicities by V. Zlati\u0107,\nD. Garlaschelli and G. Caldarelli, EPL (Europhysics Letters),\nVolume 97, Number 2 (2012).https://iopscience.iop.org/article/10.1209/0295-5075/97/28005",
            "Examples": "G=nx.complete_graph(5)\nprint(nx.generalized_degree(G,0))\n# Counter({3: 4})\nprint(nx.generalized_degree(G))\n# {0: Counter({3: 4}), 1: Counter({3: 4}), 2: Counter({3: 4}), 3: Counter({3: 4}), 4: Counter({3: 4})}\nTo recover the number of triangles attached to a node:\nk1=nx.generalized_degree(G,0)\nsum([k*vfork,vink1.items()])/2==nx.triangles(G,0)\n# True"
        }
    },
    {
        "Section ID": "number_of_edges",
        "Description": [
            "Returns the number of edges in the graph.",
            "This function wraps the G.number_of_edges function."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "read_graphml",
        "Description": [
            "Read graph in GraphML format from path."
        ],
        "Field List": {
            "Parameters:": {
                "path : file or string": "File or filename to write.\nFilenames ending in .gz or .bz2 will be compressed.",
                "node_type: Python type (default: str)": "Convert node ids to this type",
                "edge_key_type: Python type (default: int)": "Convert graphml edge ids to this type. Multigraphs use id as edge key.\nNon-multigraphs add to edge attribute dict with name \u201cid\u201d.",
                "force_multigraph : bool (default: False)": "If True, return a multigraph with edge keys. If False (the default)\nreturn a multigraph when multiedges are in the graph."
            },
            "Returns:": {
                "graph: NetworkX graph": "If parallel edges are present orforce_multigraph=Truethen\na MultiGraph or MultiDiGraph is returned. Otherwise a Graph/DiGraph.\nThe returned graph is directed if the file indicates it should be."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Default node and edge attributes are not propagated to each node and edge.\nThey can be obtained from G.graph and applied to node and edge attributes\nif desired using something like this:"
        }
    },
    {
        "Section ID": "draw_random",
        "Description": [
            "Draw the graph G with a random layout.",
            "This is a convenience function equivalent to:"
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph",
                "kwargs : optional keywords": "Seedraw_networkxfor a description of optional keywords."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The layout is computed each time this function is called.\nFor repeated drawing it is much more efficient to call random_layout directly and reuse the result:",
            "Examples": "G=nx.lollipop_graph(4,3)\nnx.draw_random(G)"
        }
    },
    {
        "Section ID": "average_clustering",
        "Description": [
            "Compute the average bipartite clustering coefficient.",
            "A clustering coefficient for the whole graph is the average,",
            "where n is the number of nodes in G .",
            "Similar measures for the two bipartite sets can be defined [1]",
            "where X is a bipartite set of G ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "a bipartite graph",
                "nodes : list or iterable, optional": "A container of nodes to use in computing the average.\nThe nodes should be either the entire graph (the default) or one of the\nbipartite sets.",
                "mode : string": "The pairwise bipartite clustering method.\nIt must be \u201cdot\u201d, \u201cmax\u201d, or \u201cmin\u201d"
            },
            "Returns:": {
                "clustering : float": "The average bipartite clustering for the given set of nodes or the\nentire graph if no nodes are specified."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The container of nodes passed to this function must contain all of the nodes\nin one of the bipartite sets (\u201ctop\u201d or \u201cbottom\u201d) in order to compute\nthe correct average bipartite clustering coefficients.\nSee bipartitedocumentation for further details on how bipartite graphs are handled in NetworkX.",
            "References": "[1]Latapy, Matthieu, Cl\u00e9mence Magnien, and Nathalie Del Vecchio (2008).\nBasic notions for the analysis of large two-mode networks.\nSocial Networks 30(1), 31\u201348.",
            "Examples": "fromnetworkx.algorithmsimportbipartite\nG=nx.star_graph(3)# star graphs are bipartite\nbipartite.average_clustering(G)\n# 0.75\nX,Y=bipartite.sets(G)\nbipartite.average_clustering(G,X)\n# 0.0\nbipartite.average_clustering(G,Y)\n# 1.0"
        }
    },
    {
        "Section ID": "astar_path",
        "Description": [
            "Returns a list of nodes in a shortest path between source and target\nusing the A* (\u201cA-star\u201d) algorithm.",
            "There may be more than one shortest path.  This returns only one."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node": "Starting node for path",
                "target : node": "Ending node for path",
                "heuristic : function": "A function to evaluate the estimate of the distance\nfrom the a node to the target.  The function takes\ntwo nodes arguments and must return a number.\nIf the heuristic is inadmissible (if it might\noverestimate the cost of reaching the goal from a node),\nthe result may not be a shortest path.\nThe algorithm does not support updating heuristic\nvalues for the same node due to caching the first\nheuristic calculation per node.",
                "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.\nIf this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge.",
                "cutoff : float, optional": "If this is provided, the search will be bounded to this value. I.e. if\nthe evaluation function surpasses this value for a node n, the node will not\nbe expanded further and will be ignored. More formally, let h\u2019(n) be the\nheuristic function, and g(n) be the cost of reaching n from the source node. Then,\nif g(n) + h\u2019(n) > cutoff, the node will not be explored further.\nNote that if the heuristic is inadmissible, it is possible that paths\nare ignored even though they satisfy the cutoff."
            },
            "Raises:": {
                "NetworkXNoPath": "If no path exists between source and target."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The weight function can be used to hide edges by returning None.\nSo weight=lambdau,v,d:1ifd['color']==\"red\"elseNone will find the shortest red path.",
            "Examples": "G=nx.path_graph(5)\nprint(nx.astar_path(G,0,4))\n# [0, 1, 2, 3, 4]\nG=nx.grid_graph(dim=[3,3])# nodes are two-tuples (x,y)\nnx.set_edge_attributes(G,{e:e[1][0]*2foreinG.edges()},\"cost\")\ndefdist(a,b):\n(x1,y1)=a\n(x2,y2)=b\nreturn((x1-x2)**2+(y1-y2)**2)**0.5\nprint(nx.astar_path(G,(0,0),(2,2),heuristic=dist,weight=\"cost\"))\n# [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)]"
        }
    },
    {
        "Section ID": "eigenvector_centrality",
        "Description": [
            "Compute the eigenvector centrality for the graph G.",
            "Eigenvector centrality computes the centrality for a node by adding\nthe centrality of its predecessors. The centrality for node \\(i\\) is the \\(i\\) -th element of a left eigenvector associated with the eigenvalue \\(\\lambda\\) of maximum modulus that is positive. Such an eigenvector \\(x\\) is\ndefined up to a multiplicative constant by the equation",
            "where \\(A\\) is the adjacency matrix of the graph G. By definition of\nrow-column product, the equation above is equivalent to",
            "That is, adding the eigenvector centralities of the predecessors of \\(i\\) one obtains the eigenvector centrality of \\(i\\) multiplied by \\(\\lambda\\) . In the case of undirected graphs, \\(x\\) also solves the familiar\nright-eigenvector equation \\(Ax = \\lambda x\\) .",
            "By virtue of the Perron\u2013Frobenius theorem [1] , if G is strongly\nconnected there is a unique eigenvector \\(x\\) , and all its entries\nare strictly positive.",
            "If G is not strongly connected there might be several left\neigenvectors associated with \\(\\lambda\\) , and some of their elements\nmight be zero."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph.",
                "max_iter : integer, optional (default=100)": "Maximum number of power iterations.",
                "tol : float, optional (default=1.0e-6)": "Error tolerance (in Euclidean norm) used to check convergence in\npower iteration.",
                "nstart : dictionary, optional (default=None)": "Starting value of power iteration for each node. Must have a nonzero\nprojection on the desired eigenvector for the power method to converge.\nIf None, this implementation uses an all-ones vector, which is a safe\nchoice.",
                "weight : None or string, optional (default=None)": "If None, all edge weights are considered equal. Otherwise holds the\nname of the edge attribute used as weight. In this measure the\nweight is interpreted as the connection strength."
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of nodes with eigenvector centrality as the value. The\nassociated vector has unit Euclidean norm and the values are\nnonegative."
            },
            "Raises:": {
                "NetworkXPointlessConcept": "If the graph G is the null graph.",
                "NetworkXError": "If each value innstartis zero.",
                "PowerIterationFailedConvergence": "If the algorithm fails to converge to the specified tolerance\nwithin the specified number of iterations of the power iteration\nmethod."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Eigenvector centrality was introduced by Landau [2] for chess\ntournaments. It was later rediscovered by Wei [3] and then\npopularized by Kendall [4] in the context of sport ranking. Berge\nintroduced a general definition for graphs based on social connections [5] . Bonacich [6] reintroduced again eigenvector centrality and made\nit popular in link analysis. This function computes the left dominant eigenvector, which corresponds\nto adding the centrality of predecessors: this is the usual approach.\nTo add the centrality of successors first reverse the graph with G.reverse() . The implementation uses power iteration [7] to compute a dominant\neigenvector starting from the provided vector nstart . Convergence is\nguaranteed as long as nstart has a nonzero projection on a dominant\neigenvector, which certainly happens using the default value. The method stops when the change in the computed vector between two\niterations is smaller than an error tolerance of G.number_of_nodes()*tol or after max_iter iterations, but in the second case it\nraises an exception. This implementation uses \\((A + I)\\) rather than the adjacency matrix \\(A\\) because the change preserves eigenvectors, but it shifts the\nspectrum, thus guaranteeing convergence even for networks with\nnegative eigenvalues of maximum modulus.",
            "References": "[1]Abraham Berman and Robert J. Plemmons.\n\u201cNonnegative Matrices in the Mathematical Sciences.\u201d\nClassics in Applied Mathematics. SIAM, 1994.  [2]Edmund Landau.\n\u201cZur relativen Wertbemessung der Turnierresultate.\u201d\nDeutsches Wochenschach, 11:366\u2013369, 1895.  [3]Teh-Hsing Wei.\n\u201cThe Algebraic Foundations of Ranking Theory.\u201d\nPhD thesis, University of Cambridge, 1952.  [4]Maurice G. Kendall.\n\u201cFurther contributions to the theory of paired comparisons.\u201d\nBiometrics, 11(1):43\u201362, 1955.https://www.jstor.org/stable/3001479  [5]Claude Berge\n\u201cTh\u00e9orie des graphes et ses applications.\u201d\nDunod, Paris, France, 1958.  [6]Phillip Bonacich.\n\u201cTechnique for analyzing overlapping memberships.\u201d\nSociological Methodology, 4:176\u2013185, 1972.https://www.jstor.org/stable/270732  [7]Power iteration::https://en.wikipedia.org/wiki/Power_iteration",
            "Examples": "G=nx.path_graph(4)\ncentrality=nx.eigenvector_centrality(G)\nsorted((v,f\"{c:0.2f}\")forv,cincentrality.items())\n# [(0, '0.37'), (1, '0.60'), (2, '0.60'), (3, '0.37')]"
        }
    },
    {
        "Section ID": "diameter",
        "Description": [
            "Returns the diameter of the graph G.",
            "The diameter is the maximum eccentricity."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A graph",
                "e : eccentricity dictionary, optional": "A precomputed dictionary of eccentricities.",
                "weight : string, function, or None": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number.If this is None, every edge has weight/distance/cost 1.Weights stored as floating point values can lead to small round-off\nerrors in distances. Use integer weights to avoid this.Weights should be positive, since they are distances."
            },
            "Returns:": {
                "d : integer": "Diameter of graph"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph([(1,2),(1,3),(1,4),(3,4),(3,5),(4,5)])\nnx.diameter(G)\n# 3"
        }
    },
    {
        "Section ID": "modularity_spectrum",
        "Description": [
            "Returns eigenvalues of the modularity matrix of G."
        ],
        "Field List": {
            "Parameters:": {
                "G : Graph": "A NetworkX Graph or DiGraph"
            },
            "Returns:": {
                "evals : NumPy array": "Eigenvalues"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]M. E. J. Newman, \u201cModularity and community structure in networks\u201d,\nProc. Natl. Acad. Sci. USA, vol. 103, pp. 8577-8582, 2006."
        }
    },
    {
        "Section ID": "induced_subgraph",
        "Description": [
            "Returns a SubGraph view of G showing only nodes in nbunch.",
            "The induced subgraph of a graph on a set of nodes N is the\ngraph with nodes N and edges from G which have both ends in N."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "",
                "nbunch : node, container of nodes or None (for all nodes)": ""
            },
            "Returns:": {
                "subgraph : SubGraph View": "A read-only view of the subgraph inGinduced by the nodes.\nChanges to the graphGwill be reflected in the view."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "To create a mutable subgraph with its own copies of nodes\nedges and attributes use subgraph.copy() or Graph(subgraph) For an inplace reduction of a graph to a subgraph you can remove nodes: G.remove_nodes_from(ninGifnnotinset(nbunch)) If you are going to compute subgraphs of your subgraphs you could\nend up with a chain of views that can be very slow once the chain\nhas about 15 views in it. If they are all induced subgraphs, you\ncan short-cut the chain by making them all subgraphs of the original\ngraph. The graph class method G.subgraph does this when G is\na subgraph. In contrast, this function allows you to choose to build\nchains or not, as you wish. The returned subgraph is a view on G .",
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nH=nx.induced_subgraph(G,[0,1,3])\nlist(H.edges)\n# [(0, 1)]\nlist(H.nodes)\n# [0, 1, 3]"
        }
    },
    {
        "Section ID": "sigma",
        "Description": [
            "Returns the small-world coefficient (sigma) of the given graph.",
            "The small-world coefficient is defined as:\nsigma = C/Cr / L/Lr\nwhere C and L are respectively the average clustering coefficient and\naverage shortest path length of G. Cr and Lr are respectively the average\nclustering coefficient and average shortest path length of an equivalent\nrandom graph.",
            "A graph is commonly classified as small-world if sigma>1."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "An undirected graph.",
                "niter : integer (optional, default=100)": "Approximate number of rewiring per edge to compute the equivalent\nrandom graph.",
                "nrand : integer (optional, default=10)": "Number of random graphs generated to compute the average clustering\ncoefficient (Cr) and average shortest path length (Lr).",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "sigma : float": "The small-world coefficient of G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The implementation is adapted from Humphries et al. [1]  [2] .",
            "References": "[1]The brainstem reticular formation is a small-world, not scale-free,\nnetwork M. D. Humphries, K. Gurney and T. J. Prescott,\nProc. Roy. Soc. B 2006 273, 503-511, doi:10.1098/rspb.2005.3354.  [2]Humphries and Gurney (2008).\n\u201cNetwork \u2018Small-World-Ness\u2019: A Quantitative Method for Determining\nCanonical Network Equivalence\u201d.\nPLoS One. 3 (4). PMID 18446219. doi:10.1371/journal.pone.0002051."
        }
    },
    {
        "Section ID": "erdos_renyi_graph",
        "Description": [
            "Returns a \\(G_{n,p}\\) random graph, also known as an Erd\u0151s-R\u00e9nyi graph\nor a binomial graph.",
            "The \\(G_{n,p}\\) model chooses each of the possible edges with probability \\(p\\) ."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes.",
                "p : float": "Probability for edge creation.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "directed : bool, optional (default=False)": "If True, this function returns a directed graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm [2] runs in \\(O(n^2)\\) time.  For sparse graphs (that is, for\nsmall values of \\(p\\) ), fast_gnp_random_graph() is a faster algorithm. binomial_graph() and erdos_renyi_graph() are\naliases for gnp_random_graph() .",
            "References": "[1]Erd\u0151s and A. R\u00e9nyi, On Random Graphs, Publ. Math. 6, 290 (1959).  [2]Gilbert, Random Graphs, Ann. Math. Stat., 30, 1141 (1959)."
        }
    },
    {
        "Section ID": "draw_planar",
        "Description": [
            "Draw a planar networkx graph G with planar layout.",
            "This is a convenience function equivalent to:"
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A planar networkx graph",
                "kwargs : optional keywords": "Seedraw_networkxfor a description of optional keywords."
            },
            "Raises:": {
                "NetworkXException": "WhenGis not planar"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The layout is computed each time this function is called.\nFor repeated drawing it is much more efficient to call planar_layout directly and reuse the result:",
            "Examples": "G=nx.path_graph(4)\nnx.draw_planar(G)"
        }
    },
    {
        "Section ID": "to_directed",
        "Description": [
            "Returns a directed view of the graph graph .",
            "Identical to graph.to_directed(as_view=True)\nNote that graph.to_directed defaults to as_view=False while this function always provides a view."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "node_boundary",
        "Description": [
            "Returns the node boundary of nbunch1 .",
            "The node boundary of a set S with respect to a set T is the\nset of nodes v in T such that for some u in S , there is an\nedge joining u to v . If T is not specified, it is assumed to\nbe the set of all nodes not in S ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "nbunch1 : iterable": "Iterable of nodes in the graph representing the set of nodes\nwhose node boundary will be returned. (This is the setSfrom\nthe definition above.)",
                "nbunch2 : iterable": "Iterable of nodes representing the target (or \u201cexterior\u201d) set of\nnodes. (This is the setTfrom the definition above.) If not\nspecified, this is assumed to be the set of all nodes inGnot innbunch1."
            },
            "Returns:": {
                "set": "The node boundary ofnbunch1with respect tonbunch2."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Any element of nbunch that is not in the graph G will be\nignored. nbunch1 and nbunch2 are usually meant to be disjoint, but in\nthe interest of speed and generality, that is not required here.",
            "Examples": "G=nx.wheel_graph(6)\nWhen nbunch2=None:\nlist(nx.node_boundary(G,(3,4)))\n# [0, 2, 5]\nWhen nbunch2 is given:\nlist(nx.node_boundary(G,(3,4),(0,1,5)))\n# [0, 5]"
        }
    },
    {
        "Section ID": "metric_closure",
        "Description": [
            "Return the metric closure of a graph.",
            "The metric closure of a graph G is the complete graph in which each edge\nis weighted by the shortest path distance between the nodes in G ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": ""
            },
            "Returns:": {
                "NetworkX graph": "Metric closure of the graphG."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "find_negative_cycle",
        "Description": [
            "Returns a cycle with negative total weight if it exists.",
            "Bellman-Ford is used to find shortest_paths. That algorithm\nstops if there exists a negative cycle. This algorithm\npicks up from there and returns the found negative cycle.",
            "The cycle consists of a list of nodes in the cycle order. The last\nnode equals the first to make it a cycle.\nYou can look up the edge weights in the original graph. In the case\nof multigraphs the relevant edge is the minimal weight edge between\nthe nodes in the 2-tuple.",
            "If the graph has no negative cycle, a NetworkXError is raised."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source: node label": "The search for the negative cycle will start from this node.",
                "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number."
            },
            "Returns:": {
                "cycle : list": "A list of nodes in the order of the cycle found. The last node\nequals the first to indicate a cycle."
            },
            "Raises:": {
                "NetworkXError": "If no negative cycle is found."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.DiGraph()\nG.add_weighted_edges_from([(0,1,2),(1,2,2),(2,0,1),(1,4,2),(4,0,-5)])\nnx.find_negative_cycle(G,0)\n# [4, 0, 1, 4]"
        }
    },
    {
        "Section ID": "py_random_state",
        "Description": [
            "Decorator to generate a random.Random instance (or equiv).",
            "This decorator processes random_state_argument using nx.utils.create_py_random_state() .\nThe input value can be a seed (integer), or a random number generator:"
        ],
        "Field List": {
            "Parameters:": {
                "random_state_argument : string or int": "The name of the argument or the index of the argument in args that is\nto be converted to the random.Random instance or numpy.random.RandomState\ninstance that mimics basic methods of random.Random."
            },
            "Returns:": {
                "_random_state : function": "Function whose random_state_argument is converted to a Random instance."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "Decorate functions like this:\n@py_random_state(\"random_state\")defrandom_float(random_state=None):returnrandom_state.rand()@py_random_state(0)defrandom_float(rng=None):returnrng.rand()@py_random_state(1)defrandom_array(dims,seed=12345):returnseed.rand(*dims)"
        }
    },
    {
        "Section ID": "NotATree",
        "Description": [],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "all_pairs_node_connectivity",
        "Description": [
            "Compute node connectivity between all pairs of nodes.",
            "Pairwise or local node connectivity between two distinct and nonadjacent\nnodes is the minimum number of nodes that must be removed (minimum\nseparating cutset) to disconnect them. By Menger\u2019s theorem, this is equal\nto the number of node independent paths (paths that share no nodes other\nthan source and target). Which is what we compute in this function.",
            "This algorithm is a fast approximation that gives an strict lower\nbound on the actual number of node independent paths between two nodes [1] .\nIt works for both directed and undirected graphs."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "nbunch: container": "Container of nodes. If provided node connectivity will be computed\nonly over pairs of nodes in nbunch.",
                "cutoff : integer": "Maximum node connectivity to consider. If None, the minimum degree\nof source or target is used as a cutoff in each pair of nodes.\nDefault value None."
            },
            "Returns:": {
                "K : dictionary": "Dictionary, keyed by source and target, of pairwise node connectivity"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]White, Douglas R., and Mark Newman. 2001 A Fast Algorithm for\nNode-Independent Paths. Santa Fe Institute Working Paper #01-07-035http://eclectic.ss.uci.edu/~drwhite/working.pdf",
            "Examples": "A 3 node cycle with one extra node attached has connectivity 2 between all\nnodes in the cycle and connectivity 1 between the extra node and the rest:\nG=nx.cycle_graph(3)\nG.add_edge(2,3)\nimportpprint# for nice dictionary formatting\npprint.pprint(nx.all_pairs_node_connectivity(G))\n# {0: {1: 2, 2: 2, 3: 1},\n#  1: {0: 2, 2: 2, 3: 1},\n#  2: {0: 2, 1: 2, 3: 1},\n#  3: {0: 1, 1: 1, 2: 1}}"
        }
    },
    {
        "Section ID": "google_matrix",
        "Description": [
            "Returns the Google matrix of the graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.  Undirected graphs will be converted to a directed\ngraph with two directed edges for each undirected edge.",
                "alpha : float": "The damping factor.",
                "personalization: dict, optional": "The \u201cpersonalization vector\u201d consisting of a dictionary with a\nkey some subset of graph nodes and personalization value each of those.\nAt least one personalization value must be non-zero.\nIf not specified, a nodes personalization value will be zero.\nBy default, a uniform distribution is used.",
                "nodelist : list, optional": "The rows and columns are ordered according to the nodes in nodelist.\nIf nodelist is None, then the ordering is produced by G.nodes().",
                "weight : key, optional": "Edge data key to use as weight.  If None weights are set to 1.",
                "dangling: dict, optional": "The outedges to be assigned to any \u201cdangling\u201d nodes, i.e., nodes without\nany outedges. The dict key is the node the outedge points to and the dict\nvalue is the weight of that outedge. By default, dangling nodes are given\noutedges according to the personalization vector (uniform if not\nspecified) This must be selected to result in an irreducible transition\nmatrix (see notes below). It may be common to have the dangling dict to\nbe the same as the personalization dict."
            },
            "Returns:": {
                "A : 2D NumPy ndarray": "Google matrix of the graph"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The array returned represents the transition matrix that describes the\nMarkov chain used in PageRank. For PageRank to converge to a unique\nsolution (i.e., a unique stationary distribution in a Markov chain), the\ntransition matrix must be irreducible. In other words, it must be that\nthere exists a path between every pair of nodes in the graph, or else there\nis the potential of \u201crank sinks.\u201d This implementation works with Multi(Di)Graphs. For multigraphs the\nweight between two nodes is set to be the sum of all edge weights\nbetween those nodes."
        }
    },
    {
        "Section ID": "min_edge_cover",
        "Description": [
            "Returns the min cardinality edge cover of the graph as a set of edges.",
            "A smallest edge cover can be found in polynomial time by finding\na maximum matching and extending it greedily so that all nodes\nare covered. This function follows that process. A maximum matching\nalgorithm can be specified for the first step of the algorithm.\nThe resulting set may return a set with one 2-tuple for each edge,\n(the usual case) or with both 2-tuples (u,v) and (v,u) for\neach edge. The latter is only done when a bipartite matching algorithm\nis specified as matching_algorithm ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "An undirected graph.",
                "matching_algorithm : function": "A function that returns a maximum cardinality matching forG.\nThe function must take one input, the graphG, and return\neither a set of edges (with only one direction for the pair of nodes)\nor a dictionary mapping each node to its mate. If not specified,max_weight_matching()is used.\nCommon bipartite matching functions includehopcroft_karp_matching()oreppstein_matching()."
            },
            "Returns:": {
                "min_cover : set": "A set of the edges in a minimum edge cover in the form of tuples.\nIt contains only one of the equivalent 2-tuples(u,v)and(v,u)for each edge. If a bipartite method is used to compute the matching,\nthe returned set contains both the 2-tuples(u,v)and(v,u)for each edge of a minimum edge cover."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "An edge cover of a graph is a set of edges such that every node of\nthe graph is incident to at least one edge of the set.\nThe minimum edge cover is an edge covering of smallest cardinality. Due to its implementation, the worst-case running time of this algorithm\nis bounded by the worst-case running time of the function matching_algorithm . Minimum edge cover for G can also be found using the min_edge_covering function in networkx.algorithms.bipartite.covering which is\nsimply this function with a default matching algorithm of hopcraft_karp_matching()",
            "Examples": "G=nx.Graph([(0,1),(0,2),(0,3),(1,2),(1,3)])\nsorted(nx.min_edge_cover(G))\n# [(2, 1), (3, 0)]"
        }
    },
    {
        "Section ID": "is_directed",
        "Description": [
            "Return True if graph is directed."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "bfs_successors",
        "Description": [
            "Returns an iterator of successors in breadth-first-search from source."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node": "Specify starting node for breadth-first search",
                "depth_limit : int, optional(default=len(G))": "Specify the maximum search depth",
                "sort_neighbors : function (default=None)": "A function that takes an iterator over nodes as the input, and\nreturns an iterable of the same nodes with a custom ordering.\nFor example,sortedwill sort the nodes in increasing order."
            },
            "Returns:": {
                "succ: iterator": "(node, successors) iterator wheresuccessorsis the non-empty list of\nsuccessors ofnodein a breadth first search fromsource.\nTo appear in the iterator,nodemust have successors."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Based on http://www.ics.uci.edu/~eppstein/PADS/BFS.py by D. Eppstein, July 2004.The modifications\nto allow depth limits based on the Wikipedia article\n\u201c Depth-limited-search \u201d.",
            "Examples": "G=nx.path_graph(3)\ndict(nx.bfs_successors(G,0))\n# {0: [1], 1: [2]}\nH=nx.Graph()\nH.add_edges_from([(0,1),(0,2),(1,3),(1,4),(2,5),(2,6)])\ndict(nx.bfs_successors(H,0))\n# {0: [1, 2], 1: [3, 4], 2: [5, 6]}\nG=nx.Graph()\nnx.add_path(G,[0,1,2,3,4,5,6])\nnx.add_path(G,[2,7,8,9,10])\ndict(nx.bfs_successors(G,source=1,depth_limit=3))\n# {1: [0, 2], 2: [3, 7], 3: [4], 7: [8]}\nG=nx.DiGraph()\nnx.add_path(G,[0,1,2,3,4,5])\ndict(nx.bfs_successors(G,source=3))\n# {3: [4], 4: [5]}"
        }
    },
    {
        "Section ID": "average_node_connectivity",
        "Description": [
            "Returns the average connectivity of a graph G.",
            "The average connectivity bar{kappa} of a graph G is the average\nof local node connectivity over all pairs of nodes of G [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected graph",
                "flow_func : function": "A function for computing the maximum flow among a pair of nodes.\nThe function has to accept at least three parameters: a Digraph,\na source node, and a target node. And return a residual network\nthat follows NetworkX conventions (seemaximum_flow()for\ndetails). If flow_func is None, the default maximum flow function\n(edmonds_karp()) is used. Seelocal_node_connectivity()for details. The choice of the default function may change from\nversion to version and should not be relied on. Default value: None."
            },
            "Returns:": {
                "K : float": "Average node connectivity"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Beineke, L., O. Oellermann, and R. Pippert (2002). The average\nconnectivity of a graph. Discrete mathematics 252(1-3), 31-45.http://www.sciencedirect.com/science/article/pii/S0012365X01001807"
        }
    },
    {
        "Section ID": "hexagonal_lattice_graph",
        "Description": [
            "Returns an m by n hexagonal lattice graph.",
            "The hexagonal lattice graph is a graph whose nodes and edges are\nthe hexagonal tiling of the plane.",
            "The returned graph will have m rows and n columns of hexagons. Odd numbered columns are shifted up relative to even numbered columns.",
            "Positions of nodes are computed by default or with_positionsisTrue .\nNode positions creating the standard embedding in the plane\nwith sidelength 1 and are stored in the node attribute \u2018pos\u2019. pos=nx.get_node_attributes(G,'pos') creates a dict ready for drawing."
        ],
        "Field List": {
            "Parameters:": {
                "m : int": "The number of rows of hexagons in the lattice.",
                "n : int": "The number of columns of hexagons in the lattice.",
                "periodic : bool": "Whether to make a periodic grid by joining the boundary vertices.\nFor this to worknmust be even and bothn>1andm>1.\nThe periodic connections create another row and column of hexagons\nso these graphs have fewer nodes as boundary nodes are identified.",
                "with_positions : bool (default: True)": "Store the coordinates of each node in the graph node attribute \u2018pos\u2019.\nThe coordinates provide a lattice with vertical columns of hexagons\noffset to interleave and cover the plane.\nPeriodic positions shift the nodes vertically in a nonlinear way so\nthe edges don\u2019t overlap so much.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated.\nIf graph is directed, edges will point up or right."
            },
            "Returns:": {
                "NetworkX graph": "Thembynhexagonal lattice graph."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "k_random_intersection_graph",
        "Description": [
            "Returns a intersection graph with randomly chosen attribute sets for\neach node that are of equal size (k)."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes in the first bipartite set (nodes)",
                "m : int": "The number of nodes in the second bipartite set (attributes)",
                "k : float": "Size of attribute set to assign to each node.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Godehardt, E., and Jaworski, J.\nTwo models of random intersection graphs and their applications.\nElectronic Notes in Discrete Mathematics 10 (2001), 129\u2013132."
        }
    },
    {
        "Section ID": "nodes",
        "Description": [
            "Returns a NodeView over the graph nodes.",
            "This function wraps the G.nodes property."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "subgraph_centrality_exp",
        "Description": [
            "Returns the subgraph centrality for each node of G.",
            "Subgraph centrality  of a node n is the sum of weighted closed\nwalks of all lengths starting and ending at node n . The weights\ndecrease with path length. Each closed walk is associated with a\nconnected subgraph ( [1] )."
        ],
        "Field List": {
            "Parameters:": {
                "G: graph": ""
            },
            "Returns:": {
                "nodes:dictionary": "Dictionary of nodes with subgraph centrality as the value."
            },
            "Raises:": {
                "NetworkXError": "If the graph is not undirected and simple."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This version of the algorithm exponentiates the adjacency matrix. The subgraph centrality of a node u in G can be found using\nthe matrix exponential of the adjacency matrix of G [1] ,",
            "References": "[1](1,2,3)Ernesto Estrada, Juan A. Rodriguez-Velazquez,\n\u201cSubgraph centrality in complex networks\u201d,\nPhysical Review E 71, 056103 (2005).https://arxiv.org/abs/cond-mat/0504730",
            "Examples": "(Example from[1])\n>>> G = nx.Graph(\n\u2026     [\n\u2026         (1, 2),\n\u2026         (1, 5),\n\u2026         (1, 8),\n\u2026         (2, 3),\n\u2026         (2, 8),\n\u2026         (3, 4),\n\u2026         (3, 6),\n\u2026         (4, 5),\n\u2026         (4, 7),\n\u2026         (5, 6),\n\u2026         (6, 7),\n\u2026         (7, 8),\n\u2026     ]\n\u2026 )\n>>> sc = nx.subgraph_centrality_exp(G)\n>>> print([f\u201d{node} {sc[node]:0.2f}\u201d for node in sorted(sc)])\n[\u20181 3.90\u2019, \u20182 3.90\u2019, \u20183 3.64\u2019, \u20184 3.71\u2019, \u20185 3.64\u2019, \u20186 3.71\u2019, \u20187 3.64\u2019, \u20188 3.90\u2019]"
        }
    },
    {
        "Section ID": "maximum_spanning_arborescence",
        "Description": [
            "Returns a maximum spanning arborescence from G."
        ],
        "Field List": {
            "Parameters:": {
                "G : (multi)digraph-like": "The graph to be searched.",
                "attr : str": "The edge attribute used to in determining optimality.",
                "default : float": "The value of the edge attribute used if an edge does not have\nthe attributeattr.",
                "preserve_attrs : bool": "If True, preserve the other attributes of the original graph (that are not\npassed toattr)",
                "partition : str": "The key for the edge attribute containing the partition\ndata on the graph. Edges can be included, excluded or open using theEdgePartitionenum."
            },
            "Returns:": {
                "B : (multi)digraph-like": "A maximum spanning arborescence."
            },
            "Raises:": {
                "NetworkXException": "If the graph does not contain a maximum spanning arborescence."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "laplacian_spectrum",
        "Description": [
            "Returns eigenvalues of the Laplacian of G"
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "weight : string or None, optional (default=\u2019weight\u2019)": "The edge data key used to compute each value in the matrix.\nIf None, then each edge has weight 1."
            },
            "Returns:": {
                "evals : NumPy array": "Eigenvalues"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For MultiGraph/MultiDiGraph, the edges weights are summed.\nSee to_numpy_array() for other options.",
            "Examples": "The multiplicity of 0 as an eigenvalue of the laplacian matrix is equal\nto the number of connected components of G.\nG=nx.Graph()# Create a graph with 5 nodes and 3 connected components\nG.add_nodes_from(range(5))\nG.add_edges_from([(0,2),(3,4)])\nnx.laplacian_spectrum(G)\n# array([0., 0., 0., 2., 2.])"
        }
    },
    {
        "Section ID": "edge_expansion",
        "Description": [
            "Returns the edge expansion between two node sets.",
            "The edge expansion is the quotient of the cut size and the smaller\nof the cardinalities of the two sets. [1]"
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "S : collection": "A collection of nodes inG.",
                "T : collection": "A collection of nodes inG.",
                "weight : object": "Edge attribute key to use as weight. If not specified, edges\nhave weight one."
            },
            "Returns:": {
                "number": "The edge expansion between the two setsSandT."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Fan Chung.Spectral Graph Theory.\n(CBMS Regional Conference Series in Mathematics, No. 92),\nAmerican Mathematical Society, 1997, ISBN 0-8218-0315-8\n<http://www.math.ucsd.edu/~fan/research/revised.html>"
        }
    },
    {
        "Section ID": "adjacency_data",
        "Description": [
            "Returns data in adjacency format that is suitable for JSON serialization\nand use in JavaScript documents."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "attrs : dict": "A dictionary that contains two keys \u2018id\u2019 and \u2018key\u2019. The corresponding\nvalues provide the attribute names for storing NetworkX-internal graph\ndata. The values should be unique. Default value:dict(id='id',key='key').If some user-defined graph data use these attribute names as data keys,\nthey may be silently dropped."
            },
            "Returns:": {
                "data : dict": "A dictionary with adjacency formatted data."
            },
            "Raises:": {
                "NetworkXError": "If values in attrs are not unique."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Graph, node, and link attributes will be written when using this format\nbut attribute keys must be strings if you want to serialize the resulting\ndata with JSON. The default value of attrs will be changed in a future release of NetworkX.",
            "Examples": "fromnetworkx.readwriteimportjson_graph\nG=nx.Graph([(1,2)])\ndata=json_graph.adjacency_data(G)\nTo serialize with json\nimportjson\ns=json.dumps(data)"
        }
    },
    {
        "Section ID": "max_flow_min_cost",
        "Description": [
            "Returns a maximum (s, t)-flow of minimum cost.",
            "G is a digraph with edge costs and capacities. There is a source\nnode s and a sink node t. This function finds a maximum flow from\ns to t whose total cost is minimized."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "DiGraph on which a minimum cost flow satisfying all demands is\nto be found.",
                "s: node label": "Source of the flow.",
                "t: node label": "Destination of the flow.",
                "capacity: string": "Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: \u2018capacity\u2019.",
                "weight: string": "Edges of the graph G are expected to have an attribute weight\nthat indicates the cost incurred by sending one unit of flow on\nthat edge. If not present, the weight is considered to be 0.\nDefault value: \u2018weight\u2019."
            },
            "Returns:": {
                "flowDict: dictionary": "Dictionary of dictionaries keyed by nodes such that\nflowDict[u][v] is the flow edge (u, v)."
            },
            "Raises:": {
                "NetworkXError": "This exception is raised if the input graph is not directed or\nnot connected.",
                "NetworkXUnbounded": "This exception is raised if there is an infinite capacity path\nfrom s to t in G. In this case there is no maximum flow. This\nexception is also raised if the digraph G has a cycle of\nnegative cost and infinite capacity. Then, the cost of a flow\nis unbounded below."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm is not guaranteed to work if edge weights or demands\nare floating point numbers (overflows and roundoff errors can\ncause problems). As a workaround you can use integer numbers by\nmultiplying the relevant edge attributes by a convenient\nconstant factor (eg 100).",
            "Examples": "G=nx.DiGraph()\nG.add_edges_from(\n[\n(1,2,{\"capacity\":12,\"weight\":4}),\n(1,3,{\"capacity\":20,\"weight\":6}),\n(2,3,{\"capacity\":6,\"weight\":-3}),\n(2,6,{\"capacity\":14,\"weight\":1}),\n(3,4,{\"weight\":9}),\n(3,5,{\"capacity\":10,\"weight\":5}),\n(4,2,{\"capacity\":19,\"weight\":13}),\n(4,5,{\"capacity\":4,\"weight\":0}),\n(5,7,{\"capacity\":28,\"weight\":2}),\n(6,5,{\"capacity\":11,\"weight\":1}),\n(6,7,{\"weight\":8}),\n(7,4,{\"capacity\":6,\"weight\":6}),\n]\n)\nmincostFlow=nx.max_flow_min_cost(G,1,7)\nmincost=nx.cost_of_flow(G,mincostFlow)\nmincost\n# 373\nfromnetworkx.algorithms.flowimportmaximum_flow\nmaxFlow=maximum_flow(G,1,7)[1]\nnx.cost_of_flow(G,maxFlow)>=mincost\n# True\nmincostFlowValue=sum((mincostFlow[u][7]foruinG.predecessors(7)))-sum(\n(mincostFlow[7][v]forvinG.successors(7))\n)\nmincostFlowValue==nx.maximum_flow_value(G,1,7)\n# True"
        }
    },
    {
        "Section ID": "node_connectivity",
        "Description": [
            "Returns node connectivity for a graph or digraph G.",
            "Node connectivity is equal to the minimum number of nodes that\nmust be removed to disconnect G or render it trivial. If source\nand target nodes are provided, this function returns the local node\nconnectivity: the minimum number of nodes that must be removed to break\nall paths from source to target in G."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected graph",
                "s : node": "Source node. Optional. Default value: None.",
                "t : node": "Target node. Optional. Default value: None.",
                "flow_func : function": "A function for computing the maximum flow among a pair of nodes.\nThe function has to accept at least three parameters: a Digraph,\na source node, and a target node. And return a residual network\nthat follows NetworkX conventions (seemaximum_flow()for\ndetails). If flow_func is None, the default maximum flow function\n(edmonds_karp()) is used. See below for details. The\nchoice of the default function may change from version\nto version and should not be relied on. Default value: None."
            },
            "Returns:": {
                "K : integer": "Node connectivity of G, or local node connectivity if source\nand target are provided."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This is a flow based implementation of node connectivity. The\nalgorithm works by solving \\(O((n-\\delta-1+\\delta(\\delta-1)/2))\\) maximum flow problems on an auxiliary digraph. Where \\(\\delta\\) is the minimum degree of G. For details about the auxiliary\ndigraph and the computation of local node connectivity see local_node_connectivity() . This implementation is based\non algorithm 11 in [1] .",
            "References": "[1]Abdol-Hossein Esfahanian. Connectivity Algorithms.http://www.cse.msu.edu/~cse835/Papers/Graph_connectivity_revised.pdf",
            "Examples": "# Platonic icosahedral graph is 5-node-connected\nG=nx.icosahedral_graph()\nnx.node_connectivity(G)\n# 5\nYou can use alternative flow algorithms for the underlying maximum\nflow computation. In dense networks the algorithmshortest_augmenting_path()will usually perform better\nthan the defaultedmonds_karp(), which is faster for\nsparse networks with highly skewed degree distributions. Alternative\nflow functions have to be explicitly imported from the flow package.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\nnx.node_connectivity(G,flow_func=shortest_augmenting_path)\n# 5\nIf you specify a pair of nodes (source and target) as parameters,\nthis function returns the value of local node connectivity.\nnx.node_connectivity(G,3,7)\n# 5\nIf you need to perform several local computations among different\npairs of nodes on the same graph, it is recommended that you reuse\nthe data structures used in the maximum flow computations. Seelocal_node_connectivity()for details."
        }
    },
    {
        "Section ID": "hide_diedges",
        "Description": [
            "Returns a filter function that hides specific directed edges."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "in_degree_centrality",
        "Description": [
            "Compute the in-degree centrality for nodes.",
            "The in-degree centrality for a node v is the fraction of nodes its\nincoming edges are connected to."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph"
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of nodes with in-degree centrality as values."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The degree centrality values are normalized by dividing by the maximum\npossible degree in a simple graph n-1 where n is the number of nodes in G. For multigraphs or graphs with self loops the maximum degree might\nbe higher than n-1 and values of degree centrality greater than 1\nare possible.",
            "Examples": "G=nx.DiGraph([(0,1),(0,2),(0,3),(1,2),(1,3)])\nnx.in_degree_centrality(G)\n# {0: 0.0, 1: 0.3333333333333333, 2: 0.6666666666666666, 3: 0.6666666666666666}"
        }
    },
    {
        "Section ID": "is_at_free",
        "Description": [
            "Check if a graph is AT-free.",
            "The method uses the find_asteroidal_triple method to recognize\nan AT-free graph. If no asteroidal triple is found the graph is\nAT-free and True is returned. If at least one asteroidal triple is\nfound the graph is not AT-free and False is returned."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "The graph to check whether is AT-free or not."
            },
            "Returns:": {
                "bool": "True if G is AT-free and False otherwise."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph([(0,1),(0,2),(1,2),(1,3),(1,4),(4,5)])\nnx.is_at_free(G)\n# True\nG=nx.cycle_graph(6)\nnx.is_at_free(G)\n# False"
        }
    },
    {
        "Section ID": "strong_product",
        "Description": [
            "Returns the strong product of G and H.",
            "The strong product \\(P\\) of the graphs \\(G\\) and \\(H\\) has a node set that\nis the Cartesian product of the node sets, \\(V(P)=V(G) \\times V(H)\\) . \\(P\\) has an edge \\(((u,v), (x,y))\\) if and only if \\(u==v\\) and \\((x,y)\\) is an edge in \\(H\\) , or \\(x==y\\) and \\((u,v)\\) is an edge in \\(G\\) , or \\((u,v)\\) is an edge in \\(G\\) and \\((x,y)\\) is an edge in \\(H\\) ."
        ],
        "Field List": {
            "Parameters:": {
                "G, H: graphs": "Networkx graphs."
            },
            "Returns:": {
                "P: NetworkX graph": "The Cartesian product of G and H. P will be a multi-graph if either G\nor H is a multi-graph. Will be a directed if G and H are directed,\nand undirected if G and H are undirected."
            },
            "Raises:": {
                "NetworkXError": "If G and H are not both directed or both undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Node attributes in P are two-tuple of the G and H node attributes.\nMissing attributes are assigned None.",
            "Examples": "G=nx.Graph()\nH=nx.Graph()\nG.add_node(0,a1=True)\nH.add_node(\"a\",a2=\"Spam\")\nP=nx.strong_product(G,H)\nlist(P)\n# [(0, 'a')]\nEdge attributes and edge keys (for multigraphs) are also copied to the\nnew product graph"
        }
    },
    {
        "Section ID": "current_flow_betweenness_centrality",
        "Description": [
            "Compute current-flow betweenness centrality for nodes.",
            "Current-flow betweenness centrality uses an electrical current\nmodel for information spreading in contrast to betweenness\ncentrality which uses shortest paths.",
            "Current-flow betweenness centrality is also known as\nrandom-walk betweenness centrality [2] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "normalized : bool, optional (default=True)": "If True the betweenness values are normalized by 2/[(n-1)(n-2)] where\nn is the number of nodes in G.",
                "weight : string or None, optional (default=None)": "Key for edge data used as the edge weight.\nIf None, then use 1 as each edge weight.\nThe weight reflects the capacity or the strength of the\nedge.",
                "dtype : data type (float)": "Default data type for internal matrices.\nSet to np.float32 for lower memory consumption.",
                "solver : string (default=\u2019full\u2019)": "Type of linear solver to use for computing the flow matrix.\nOptions are \u201cfull\u201d (uses most memory), \u201clu\u201d (recommended), and\n\u201ccg\u201d (uses least memory)."
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of nodes with betweenness centrality as the value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Current-flow betweenness can be computed in \\(O(I(n-1)+mn \\log n)\\) time [1] , where \\(I(n-1)\\) is the time needed to compute the\ninverse Laplacian.  For a full matrix this is \\(O(n^3)\\) but using\nsparse methods you can achieve \\(O(nm{\\sqrt k})\\) where \\(k\\) is the\nLaplacian matrix condition number. The space required is \\(O(nw)\\) where \\(w\\) is the width of the sparse\nLaplacian matrix.  Worse case is \\(w=n\\) for \\(O(n^2)\\) . If the edges have a \u2018weight\u2019 attribute they will be used as\nweights in this algorithm.  Unspecified weights are set to 1.",
            "References": "[1]Centrality Measures Based on Current Flow.\nUlrik Brandes and Daniel Fleischer,\nProc. 22nd Symp. Theoretical Aspects of Computer Science (STACS \u201805).\nLNCS 3404, pp. 533-544. Springer-Verlag, 2005.https://doi.org/10.1007/978-3-540-31856-9_44  [2]A measure of betweenness centrality based on random walks,\nM. E. J. Newman, Social Networks 27, 39-54 (2005)."
        }
    },
    {
        "Section ID": "nodes_with_selfloops",
        "Description": [
            "Returns an iterator over nodes with self loops.",
            "A node with a self loop has an edge with both ends adjacent\nto that node."
        ],
        "Field List": {
            "Returns:": {
                "nodelist : iterator": "A iterator over nodes with self loops."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_edge(1,1)\nG.add_edge(1,2)\nlist(nx.nodes_with_selfloops(G))\n# [1]"
        }
    },
    {
        "Section ID": "from_nested_tuple",
        "Description": [
            "Returns the rooted tree corresponding to the given nested tuple.",
            "The nested tuple representation of a tree is defined\nrecursively. The tree with one node and no edges is represented by\nthe empty tuple, () . A tree with k subtrees is represented\nby a tuple of length k in which each element is the nested tuple\nrepresentation of a subtree."
        ],
        "Field List": {
            "Parameters:": {
                "sequence : tuple": "A nested tuple representing a rooted tree.",
                "sensible_relabeling : bool": "Whether to relabel the nodes of the tree so that nodes are\nlabeled in increasing order according to their breadth-first\nsearch order from the root node."
            },
            "Returns:": {
                "NetworkX graph": "The tree corresponding to the given nested tuple, whose root\nnode is node 0. Ifsensible_labelingisTrue, nodes will\nbe labeled in breadth-first search order starting from the root\nnode."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This function is not the inverse of to_nested_tuple() ; the\nonly guarantee is that the rooted trees are isomorphic.",
            "Examples": "Sensible relabeling ensures that the nodes are labeled from the root\nstarting at 0:\nbalanced=(((),()),((),()))\nT=nx.from_nested_tuple(balanced,sensible_relabeling=True)\nedges=[(0,1),(0,2),(1,3),(1,4),(2,5),(2,6)]\nall((u,v)inT.edges()or(v,u)inT.edges()for(u,v)inedges)\n# True"
        }
    },
    {
        "Section ID": "frucht_graph",
        "Description": [
            "Returns the Frucht Graph.",
            "The Frucht Graph is the smallest cubical graph whose\nautomorphism group consists only of the identity element [1] .\nIt has 12 nodes and 18 edges and no nontrivial symmetries.\nIt is planar and Hamiltonian [2] ."
        ],
        "Field List": {
            "Parameters:": {
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : networkx Graph": "Frucht Graph with 12 nodes and 18 edges"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://en.wikipedia.org/wiki/Frucht_graph  [2]https://mathworld.wolfram.com/FruchtGraph.html"
        }
    },
    {
        "Section ID": "from_scipy_sparse_array",
        "Description": [
            "Creates a new graph from an adjacency matrix given as a SciPy sparse\narray."
        ],
        "Field List": {
            "Parameters:": {
                "A: scipy.sparse array": "An adjacency matrix representation of a graph",
                "parallel_edges : Boolean": "If this is True,create_usingis a multigraph, andAis an\ninteger matrix, then entry(i, j)in the matrix is interpreted as the\nnumber of parallel edges joining verticesiandjin the graph.\nIf it is False, then the entries in the matrix are interpreted as\nthe weight of a single edge joining the vertices.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated.",
                "edge_attribute: string": "Name of edge attribute to store matrix numeric value. The data will\nhave the same type as the matrix entry (int, float, (real,imag))."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For directed graphs, explicitly mention create_using=nx.DiGraph,\nand entry i,j of A corresponds to an edge from i to j. If create_using is networkx.MultiGraph or networkx.MultiDiGraph , parallel_edges is True, and the\nentries of A are of type int , then this function returns a\nmultigraph (constructed from create_using ) with parallel edges.\nIn this case, edge_attribute will be ignored. If create_using indicates an undirected multigraph, then only the edges\nindicated by the upper triangle of the matrix A will be added to the\ngraph.",
            "Examples": "importscipyassp\nA=sp.sparse.eye(2,2,1)\nG=nx.from_scipy_sparse_array(A)\nIfcreate_usingindicates a multigraph and the matrix has only integer\nentries andparallel_edgesis False, then the entries will be treated\nas weights for edges joining the nodes (without creating parallel edges):\nA=sp.sparse.csr_array([[1,1],[1,2]])\nG=nx.from_scipy_sparse_array(A,create_using=nx.MultiGraph)\nG[1][1]\n# AtlasView({0: {'weight': 2}})\nIfcreate_usingindicates a multigraph and the matrix has only integer\nentries andparallel_edgesis True, then the entries will be treated\nas the number of parallel edges joining those two vertices:\nA=sp.sparse.csr_array([[1,1],[1,2]])\nG=nx.from_scipy_sparse_array(A,parallel_edges=True,create_using=nx.MultiGraph)\nG[1][1]\n# AtlasView({0: {'weight': 1}, 1: {'weight': 1}})"
        }
    },
    {
        "Section ID": "disjoint_union_all",
        "Description": [
            "Returns the disjoint union of all graphs.",
            "This operation forces distinct integer node labels starting with 0\nfor the first graph in the list and numbering consecutively."
        ],
        "Field List": {
            "Parameters:": {
                "graphs : iterable": "Iterable of NetworkX graphs"
            },
            "Returns:": {
                "U : A graph with the same type as the first graph in list": ""
            },
            "Raises:": {
                "ValueError": "Ifgraphsis an empty list.",
                "NetworkXError": "In case of mixed type graphs, like MultiGraph and Graph, or directed and undirected graphs."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For operating on mixed type graphs, they should be converted to the same type. Graph, edge, and node attributes are propagated to the union graph.\nIf a graph attribute is present in multiple graphs, then the value\nfrom the last graph in the list with that attribute is used.",
            "Examples": "G1=nx.Graph([(1,2),(2,3)])\nG2=nx.Graph([(4,5),(5,6)])\nU=nx.disjoint_union_all([G1,G2])\nlist(U.nodes())\n# [0, 1, 2, 3, 4, 5]\nlist(U.edges())\n# [(0, 1), (1, 2), (3, 4), (4, 5)]"
        }
    },
    {
        "Section ID": "hide_nodes",
        "Description": [
            "Returns a filter function that hides specific nodes."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "cubical_graph",
        "Description": [
            "Returns the 3-regular Platonic Cubical Graph",
            "The skeleton of the cube (the nodes and edges) form a graph, with 8\nnodes, and 12 edges. It is a special case of the hypercube graph.\nIt is one of 5 Platonic graphs, each a skeleton of its\nPlatonic solid [1] .\nSuch graphs arise in parallel processing in computers."
        ],
        "Field List": {
            "Parameters:": {
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : networkx Graph": "A cubical graph with 8 nodes and 12 edges"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://en.wikipedia.org/wiki/Cube#Cubical_graph"
        }
    },
    {
        "Section ID": "k_corona",
        "Description": [
            "Returns the k-corona of G.",
            "The k-corona is the subgraph of nodes in the k-core which have\nexactly k neighbors in the k-core."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A graph or directed graph",
                "k : int": "The order of the corona.",
                "core_number : dictionary, optional": "Precomputed core numbers for the graph G."
            },
            "Returns:": {
                "G : NetworkX graph": "The k-corona subgraph"
            },
            "Raises:": {
                "NetworkXNotImplemented": "The k-corona is not defined for multigraphs or graphs with self loops."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For directed graphs the node degree is defined to be the\nin-degree + out-degree. Graph, node, and edge attributes are copied to the subgraph.",
            "References": "[1]k -core (bootstrap) percolation on complex networks:\nCritical phenomena and nonlocal effects,\nA. V. Goltsev, S. N. Dorogovtsev, and J. F. F. Mendes,\nPhys. Rev. E 73, 056101 (2006)http://link.aps.org/doi/10.1103/PhysRevE.73.056101",
            "Examples": "degrees=[0,1,2,2,2,2,3]\nH=nx.havel_hakimi_graph(degrees)\nH.degree\n# DegreeView({0: 1, 1: 2, 2: 2, 3: 2, 4: 2, 5: 3, 6: 0})\nnx.k_corona(H,k=2).nodes\n# NodeView((1, 2, 3, 5))"
        }
    },
    {
        "Section ID": "all_triads",
        "Description": [
            "A generator of all possible triads in G."
        ],
        "Field List": {
            "Parameters:": {
                "G : digraph": "A NetworkX DiGraph"
            },
            "Returns:": {
                "all_triads : generator of DiGraphs": "Generator of triads (order-3 DiGraphs)"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.DiGraph([(1,2),(2,3),(3,1),(3,4),(4,1),(4,2)])\nfortriadinnx.all_triads(G):\nprint(triad.edges)\n# [(1, 2), (2, 3), (3, 1)]\n# [(1, 2), (4, 1), (4, 2)]\n# [(3, 1), (3, 4), (4, 1)]\n# [(2, 3), (3, 4), (4, 2)]"
        }
    },
    {
        "Section ID": "average_degree_connectivity",
        "Description": [
            "Compute the average degree connectivity of graph.",
            "The average degree connectivity is the average nearest neighbor degree of\nnodes with degree k. For weighted graphs, an analogous measure can\nbe computed using the weighted average neighbors degree defined in [1] , for a node i , as",
            "where s_i is the weighted degree of node i , w_{ij} is the weight of the edge that links i and j ,\nand N(i) are the neighbors of node i ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : \u201cin\u201d|\u201dout\u201d|\u201din+out\u201d (default:\u201din+out\u201d)": "Directed graphs only. Use \u201cin\u201d- or \u201cout\u201d-degree for source node.",
                "target : \u201cin\u201d|\u201dout\u201d|\u201din+out\u201d (default:\u201din+out\u201d": "Directed graphs only. Use \u201cin\u201d- or \u201cout\u201d-degree for target node.",
                "nodes : list or iterable (optional)": "Compute neighbor connectivity for these nodes. The default is all\nnodes.",
                "weight : string or None, optional (default=None)": "The edge attribute that holds the numerical value used as a weight.\nIf None, then each edge has weight 1."
            },
            "Returns:": {
                "d : dict": "A dictionary keyed by degree k with the value of average connectivity."
            },
            "Raises:": {
                "NetworkXError": "If eithersourceortargetare not one of \u2018in\u2019,\n\u2018out\u2019, or \u2018in+out\u2019.\nIf eithersourceortargetis passed for an undirected graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]A. Barrat, M. Barth\u00e9lemy, R. Pastor-Satorras, and A. Vespignani,\n\u201cThe architecture of complex weighted networks\u201d.\nPNAS 101 (11): 3747\u20133752 (2004).",
            "Examples": "G=nx.path_graph(4)\nG.edges[1,2][\"weight\"]=3\nnx.average_degree_connectivity(G)\n# {1: 2.0, 2: 1.5}\nnx.average_degree_connectivity(G,weight=\"weight\")\n# {1: 2.0, 2: 1.75}"
        }
    },
    {
        "Section ID": "reverse",
        "Description": [
            "Returns the reverse directed graph of G."
        ],
        "Field List": {
            "Parameters:": {
                "G : directed graph": "A NetworkX directed graph",
                "copy : bool": "If True, then a new graph is returned. If False, then the graph is\nreversed in place."
            },
            "Returns:": {
                "H : directed graph": "The reversed G."
            },
            "Raises:": {
                "NetworkXError": "If graph is undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.DiGraph([(1,2),(1,3),(2,3),(3,4),(3,5)])\nG_reversed=nx.reverse(G)\nG_reversed.edges()\n# OutEdgeView([(2, 1), (3, 1), (3, 2), (4, 3), (5, 3)])"
        }
    },
    {
        "Section ID": "average_neighbor_degree",
        "Description": [
            "Returns the average degree of the neighborhood of each node.",
            "In an undirected graph, the neighborhood N(i) of node i contains the\nnodes that are connected to i by an edge.",
            "For directed graphs, N(i) is defined according to the parameter source :",
            "The average neighborhood degree of a node i is",
            "where N(i) are the neighbors of node i and k_j is\nthe degree of node j which belongs to N(i) . For weighted\ngraphs, an analogous measure can be defined [1] ,",
            "where s_i is the weighted degree of node i , w_{ij} is the weight of the edge that links i and j and N(i) are the neighbors of node i ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : string (\u201cin\u201d|\u201dout\u201d|\u201din+out\u201d), optional (default=\u201dout\u201d)": "Directed graphs only.\nUse \u201cin\u201d- or \u201cout\u201d-neighbors of source node.",
                "target : string (\u201cin\u201d|\u201dout\u201d|\u201din+out\u201d), optional (default=\u201dout\u201d)": "Directed graphs only.\nUse \u201cin\u201d- or \u201cout\u201d-degree for target node.",
                "nodes : list or iterable, optional (default=G.nodes)": "Compute neighbor degree only for specified nodes.",
                "weight : string or None, optional (default=None)": "The edge attribute that holds the numerical value used as a weight.\nIf None, then each edge has weight 1."
            },
            "Returns:": {
                "d: dict": "A dictionary keyed by node to the average degree of its neighbors."
            },
            "Raises:": {
                "NetworkXError": "If eithersourceortargetare not one of \u2018in\u2019, \u2018out\u2019, or \u2018in+out\u2019.\nIf eithersourceortargetis passed for an undirected graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]A. Barrat, M. Barth\u00e9lemy, R. Pastor-Satorras, and A. Vespignani,\n\u201cThe architecture of complex weighted networks\u201d.\nPNAS 101 (11): 3747\u20133752 (2004).",
            "Examples": "G=nx.path_graph(4)\nG.edges[0,1][\"weight\"]=5\nG.edges[2,3][\"weight\"]=3\nnx.average_neighbor_degree(G)\n# {0: 2.0, 1: 1.5, 2: 1.5, 3: 2.0}\nnx.average_neighbor_degree(G,weight=\"weight\")\n# {0: 2.0, 1: 1.1666666666666667, 2: 1.25, 3: 2.0}\nG=nx.DiGraph()\nnx.add_path(G,[0,1,2,3])\nnx.average_neighbor_degree(G,source=\"in\",target=\"in\")\n# {0: 0.0, 1: 0.0, 2: 1.0, 3: 1.0}\nnx.average_neighbor_degree(G,source=\"out\",target=\"out\")\n# {0: 1.0, 1: 1.0, 2: 0.0, 3: 0.0}"
        }
    },
    {
        "Section ID": "weakly_connected_components",
        "Description": [
            "Generate weakly connected components of G."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A directed graph"
            },
            "Returns:": {
                "comp : generator of sets": "A generator of sets of nodes, one for each weakly connected\ncomponent of G."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For directed graphs only.",
            "Examples": "Generate a sorted list of weakly connected components, largest first.\nG=nx.path_graph(4,create_using=nx.DiGraph())\nnx.add_path(G,[10,11,12])\n[len(c)forcinsorted(nx.weakly_connected_components(G),key=len,reverse=True)]\n# [4, 3]\nIf you only want the largest component, it\u2019s more efficient to\nuse max instead of sort:\nlargest_cc=max(nx.weakly_connected_components(G),key=len)"
        }
    },
    {
        "Section ID": "degree_sequence_tree",
        "Description": [
            "Make a tree for the given degree sequence.",
            "A tree has #nodes-#edges=1 so\nthe degree sequence must have\nlen(deg_sequence)-sum(deg_sequence)/2=1"
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "contracted_nodes",
        "Description": [
            "Returns the graph that results from contracting u and v .",
            "Node contraction identifies the two nodes as a single node incident to any\nedge that was incident to the original two nodes."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "The graph whose nodes will be contracted.",
                "u, v : nodes": "Must be nodes inG.",
                "self_loops : Boolean": "If this is True, any edges joininguandvinGbecome\nself-loops on the new node in the returned graph.",
                "copy : Boolean": "If this is True (default True), make a copy ofGand return that instead of directly changingG."
            },
            "Returns:": {
                "Networkx graph": "If Copy is True,\nA new graph object of the same type asG(leavingGunmodified)\nwithuandvidentified in a single node. The right nodevwill be merged into the nodeu, so onlyuwill appear in the\nreturned graph.\nIf copy is False,\nModifiesGwithuandvidentified in a single node.\nThe right nodevwill be merged into the nodeu, so\nonlyuwill appear in the returned graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For multigraphs, the edge keys for the realigned edges may\nnot be the same as the edge keys for the old edges. This is\nnatural because edge keys are unique only within each pair of nodes. For non-multigraphs where u and v are adjacent to a third node w , the edge ( v , w ) will be contracted into the edge ( u , w ) with its attributes stored into a \u201ccontraction\u201d attribute. This function is also available as identified_nodes .",
            "Examples": "Contracting two nonadjacent nodes of the cycle graph on four nodesC_4yields the path graph (ignoring parallel edges):\nG=nx.cycle_graph(4)\nM=nx.contracted_nodes(G,1,3)\nP3=nx.path_graph(3)\nnx.is_isomorphic(M,P3)\n# True\nG=nx.MultiGraph(P3)\nM=nx.contracted_nodes(G,0,2)\nM.edges\n# MultiEdgeView([(0, 1, 0), (0, 1, 1)])\nG=nx.Graph([(1,2),(2,2)])\nH=nx.contracted_nodes(G,1,2,self_loops=False)\nlist(H.nodes())\n# [1]\nlist(H.edges())\n# [(1, 1)]\nIn aMultiDiGraphwith a self loop, the in and out edges will\nbe treated separately as edges, so while contracting a node which\nhas a self loop the contraction will add multiple edges:\nG=nx.MultiDiGraph([(1,2),(2,2)])\nH=nx.contracted_nodes(G,1,2)\nlist(H.edges())# edge 1->2, 2->2, 2<-2 from the original Graph G\n# [(1, 1), (1, 1), (1, 1)]\nH=nx.contracted_nodes(G,1,2,self_loops=False)\nlist(H.edges())# edge 2->2, 2<-2 from the original Graph G\n# [(1, 1), (1, 1)]"
        }
    },
    {
        "Section ID": "is_isolate",
        "Description": [
            "Determines whether a node is an isolate.",
            "An isolate is a node with no neighbors (that is, with degree\nzero). For directed graphs, this means no in-neighbors and no\nout-neighbors."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "n : node": "A node inG."
            },
            "Returns:": {
                "is_isolate : bool": "True if and only ifnhas no neighbors."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph()\nG.add_edge(1,2)\nG.add_node(3)\nnx.is_isolate(G,2)\n# False\nnx.is_isolate(G,3)\n# True"
        }
    },
    {
        "Section ID": "transitive_reduction",
        "Description": [
            "Returns transitive reduction of a directed graph",
            "The transitive reduction of G = (V,E) is a graph G- = (V,E-) such that\nfor all v,w in V there is an edge (v,w) in E- if and only if (v,w) is\nin E and there is no path from v to w in G with length greater than 1."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX DiGraph": "A directed acyclic graph (DAG)"
            },
            "Returns:": {
                "NetworkX DiGraph": "The transitive reduction ofG"
            },
            "Raises:": {
                "NetworkXError": "IfGis not a directed acyclic graph (DAG) transitive reduction is\nnot uniquely defined and aNetworkXErrorexception is raised."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "https://en.wikipedia.org/wiki/Transitive_reduction",
            "Examples": "To perform transitive reduction on a DiGraph:\nDG=nx.DiGraph([(1,2),(2,3),(1,3)])\nTR=nx.transitive_reduction(DG)\nlist(TR.edges)\n# [(1, 2), (2, 3)]\nTo avoid unnecessary data copies, this implementation does not return a\nDiGraph with node/edge data.\nTo perform transitive reduction on a DiGraph and transfer node/edge data:\nDG=nx.DiGraph()\nDG.add_edges_from([(1,2),(2,3),(1,3)],color=\"red\")\nTR=nx.transitive_reduction(DG)\nTR.add_nodes_from(DG.nodes(data=True))\nTR.add_edges_from((u,v,DG.edges[u,v])foru,vinTR.edges)\nlist(TR.edges(data=True))\n# [(1, 2, {'color': 'red'}), (2, 3, {'color': 'red'})]"
        }
    },
    {
        "Section ID": "write_multiline_adjlist",
        "Description": [
            "Write the graph G in multiline adjacency list format to path"
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "path : string or file": "Filename or file handle to write to.\nFilenames ending in .gz or .bz2 will be compressed.",
                "comments : string, optional": "Marker for comment lines",
                "delimiter : string, optional": "Separator for node labels",
                "encoding : string, optional": "Text encoding."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.path_graph(4)\nnx.write_multiline_adjlist(G,\"test.adjlist\")\nThe path can be a file handle or a string with the name of the file. If a\nfile handle is provided, it has to be opened in \u2018wb\u2019 mode.\nfh=open(\"test.adjlist\",\"wb\")\nnx.write_multiline_adjlist(G,fh)\nFilenames ending in .gz or .bz2 will be compressed.\nnx.write_multiline_adjlist(G,\"test.adjlist.gz\")"
        }
    },
    {
        "Section ID": "optimal_edit_paths",
        "Description": [
            "Returns all minimum-cost edit paths transforming G1 to G2.",
            "Graph edit path is a sequence of node and edge edit operations\ntransforming graph G1 to graph isomorphic to G2.  Edit operations\ninclude substitutions, deletions, and insertions."
        ],
        "Field List": {
            "Parameters:": {
                "G1, G2: graphs": "The two graphs G1 and G2 must be of the same type.",
                "node_match : callable": "A function that returns True if node n1 in G1 and n2 in G2\nshould be considered equal during matching.The function will be called likenode_match(G1.nodes[n1], G2.nodes[n2]).That is, the function will receive the node attribute\ndictionaries for n1 and n2 as inputs.Ignored if node_subst_cost is specified.  If neither\nnode_match nor node_subst_cost are specified then node\nattributes are not considered.",
                "edge_match : callable": "A function that returns True if the edge attribute dictionaries\nfor the pair of nodes (u1, v1) in G1 and (u2, v2) in G2 should\nbe considered equal during matching.The function will be called likeedge_match(G1[u1][v1], G2[u2][v2]).That is, the function will receive the edge attribute\ndictionaries of the edges under consideration.Ignored if edge_subst_cost is specified.  If neither\nedge_match nor edge_subst_cost are specified then edge\nattributes are not considered.",
                "node_subst_cost, node_del_cost, node_ins_cost : callable": "Functions that return the costs of node substitution, node\ndeletion, and node insertion, respectively.The functions will be called likenode_subst_cost(G1.nodes[n1], G2.nodes[n2]),\nnode_del_cost(G1.nodes[n1]),\nnode_ins_cost(G2.nodes[n2]).That is, the functions will receive the node attribute\ndictionaries as inputs.  The functions are expected to return\npositive numeric values.Function node_subst_cost overrides node_match if specified.\nIf neither node_match nor node_subst_cost are specified then\ndefault node substitution cost of 0 is used (node attributes\nare not considered during matching).If node_del_cost is not specified then default node deletion\ncost of 1 is used.  If node_ins_cost is not specified then\ndefault node insertion cost of 1 is used.",
                "edge_subst_cost, edge_del_cost, edge_ins_cost : callable": "Functions that return the costs of edge substitution, edge\ndeletion, and edge insertion, respectively.The functions will be called likeedge_subst_cost(G1[u1][v1], G2[u2][v2]),\nedge_del_cost(G1[u1][v1]),\nedge_ins_cost(G2[u2][v2]).That is, the functions will receive the edge attribute\ndictionaries as inputs.  The functions are expected to return\npositive numeric values.Function edge_subst_cost overrides edge_match if specified.\nIf neither edge_match nor edge_subst_cost are specified then\ndefault edge substitution cost of 0 is used (edge attributes\nare not considered during matching).If edge_del_cost is not specified then default edge deletion\ncost of 1 is used.  If edge_ins_cost is not specified then\ndefault edge insertion cost of 1 is used.",
                "upper_bound : numeric": "Maximum edit distance to consider."
            },
            "Returns:": {
                "edit_paths : list of tuples (node_edit_path, edge_edit_path)": "node_edit_path : list of tuples (u, v)\nedge_edit_path : list of tuples ((u1, v1), (u2, v2))",
                "cost : numeric": "Optimal edit path cost (graph edit distance). When the cost\nis zero, it indicates thatG1andG2are isomorphic."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "To transform G1 into a graph isomorphic to G2 , apply the node\nand edge edits in the returned edit_paths .\nIn the case of isomorphic graphs, the cost is zero, and the paths\nrepresent different isomorphic mappings (isomorphisms). That is, the\nedits involve renaming nodes and edges to match the structure of G2 .",
            "References": "[1]Zeina Abu-Aisheh, Romain Raveaux, Jean-Yves Ramel, Patrick\nMartineau. An Exact Graph Edit Distance Algorithm for Solving\nPattern Recognition Problems. 4th International Conference on\nPattern Recognition Applications and Methods 2015, Jan 2015,\nLisbon, Portugal. 2015,\n<10.5220/0005209202710278>. <hal-01168816>https://hal.archives-ouvertes.fr/hal-01168816",
            "Examples": "G1=nx.cycle_graph(4)\nG2=nx.wheel_graph(5)\npaths,cost=nx.optimal_edit_paths(G1,G2)\nlen(paths)\n# 40\ncost\n# 5.0"
        }
    },
    {
        "Section ID": "bellman_ford_path",
        "Description": [
            "Returns the shortest path from source to target in a weighted graph G."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node": "Starting node",
                "target : node": "Ending node",
                "weight : string or function (default=\u201dweight\u201d)": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number."
            },
            "Returns:": {
                "path : list": "List of nodes in a shortest path."
            },
            "Raises:": {
                "NodeNotFound": "Ifsourceis not inG.",
                "NetworkXNoPath": "If no path exists between source and target."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.",
            "Examples": "G=nx.path_graph(5)\nnx.bellman_ford_path(G,0,4)\n# [0, 1, 2, 3, 4]"
        }
    },
    {
        "Section ID": "dfs_preorder_nodes",
        "Description": [
            "Generate nodes in a depth-first-search pre-ordering starting at source."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node, optional": "Specify starting node for depth-first search and return nodes in\nthe component reachable from source.",
                "depth_limit : int, optional (default=len(G))": "Specify the maximum search depth.",
                "sort_neighbors : function (default=None)": "A function that takes an iterator over nodes as the input, and\nreturns an iterable of the same nodes with a custom ordering.\nFor example,sortedwill sort the nodes in increasing order."
            },
            "Returns:": {
                "nodes: generator": "A generator of nodes in a depth-first-search pre-ordering."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "If a source is not specified then a source is chosen arbitrarily and\nrepeatedly until all components in the graph are searched. The implementation of this function is adapted from David Eppstein\u2019s\ndepth-first search function in PADS , with modifications\nto allow depth limits based on the Wikipedia article\n\u201c Depth-limited search \u201d.",
            "Examples": "G=nx.path_graph(5)\nlist(nx.dfs_preorder_nodes(G,source=0))\n# [0, 1, 2, 3, 4]\nlist(nx.dfs_preorder_nodes(G,source=0,depth_limit=2))\n# [0, 1, 2]"
        }
    },
    {
        "Section ID": "voronoi_cells",
        "Description": [
            "Returns the Voronoi cells centered at center_nodes with respect\nto the shortest-path distance metric.",
            "If \\(C\\) is a set of nodes in the graph and \\(c\\) is an element of \\(C\\) ,\nthe Voronoi cell centered at a node \\(c\\) is the set of all nodes \\(v\\) that are closer to \\(c\\) than to any other center node in \\(C\\) with\nrespect to the shortest-path distance metric. [1]",
            "For directed graphs, this will compute the \u201coutward\u201d Voronoi cells,\nas defined in [1] , in which distance is measured from the center\nnodes to the target node. For the \u201cinward\u201d Voronoi cells, use the DiGraph.reverse() method to reverse the orientation of the\nedges before invoking this function on the directed graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "center_nodes : set": "A nonempty set of nodes in the graphGthat represent the\ncenter of the Voronoi cells.",
                "weight : string or function": "The edge attribute (or an arbitrary function) representing the\nweight of an edge. This keyword argument is as described in the\ndocumentation formulti_source_dijkstra_path(),\nfor example."
            },
            "Returns:": {
                "dictionary": "A mapping from center node to set of all nodes in the graph\ncloser to that center node than to any other center node. The\nkeys of the dictionary are the element ofcenter_nodes, and\nthe values of the dictionary form a partition of the nodes ofG."
            },
            "Raises:": {
                "ValueError": "Ifcenter_nodesis empty."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1](1,2)Erwig, Martin. (2000),\u201dThe graph Voronoi diagram with applications.\u201dNetworks, 36: 156\u2013163.https://doi.org/10.1002/1097-0037(200010)36:3<156::AID-NET2>3.0.CO;2-L",
            "Examples": "To get only the partition of the graph induced by the Voronoi cells,\ntake the collection of all values in the returned dictionary:\nG=nx.path_graph(6)\ncenter_nodes={0,3}\ncells=nx.voronoi_cells(G,center_nodes)\npartition=set(map(frozenset,cells.values()))\nsorted(map(sorted,partition))\n# [[0, 1], [2, 3, 4, 5]]"
        }
    },
    {
        "Section ID": "collaboration_weighted_projected_graph",
        "Description": [
            "Newman\u2019s weighted projection of B onto one of its node sets.",
            "The collaboration weighted projection is the projection of the\nbipartite network B onto the specified nodes with weights assigned\nusing Newman\u2019s collaboration model [1] :",
            "where u and v are nodes from the bottom bipartite node set,\nand k is a node of the top node set.\nThe value d_k is the degree of node k in the bipartite\nnetwork and delta_{u}^{k} is 1 if node u is\nlinked to node k in the original bipartite graph or 0 otherwise.",
            "The nodes retain their attributes and are connected in the resulting\ngraph if have an edge to a common node in the original bipartite\ngraph."
        ],
        "Field List": {
            "Parameters:": {
                "B : NetworkX graph": "The input graph should be bipartite.",
                "nodes : list or iterable": "Nodes to project onto (the \u201cbottom\u201d nodes)."
            },
            "Returns:": {
                "Graph : NetworkX graph": "A graph that is the projection onto the given nodes."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "No attempt is made to verify that the input graph B is bipartite.\nThe graph and node properties are (shallow) copied to the projected graph. See bipartitedocumentation for further details on how bipartite graphs are handled in NetworkX.",
            "References": "[1]Scientific collaboration networks: II.\nShortest paths, weighted networks, and centrality,\nM. E. J. Newman, Phys. Rev. E 64, 016132 (2001).",
            "Examples": "fromnetworkx.algorithmsimportbipartite\nB=nx.path_graph(5)\nB.add_edge(1,5)\nG=bipartite.collaboration_weighted_projected_graph(B,[0,2,4,5])\nlist(G)\n# [0, 2, 4, 5]\nforedgeinsorted(G.edges(data=True)):\nprint(edge)\n# (0, 2, {'weight': 0.5})\n# (0, 5, {'weight': 0.5})\n# (2, 4, {'weight': 1.0})\n# (2, 5, {'weight': 0.5})"
        }
    },
    {
        "Section ID": "information_centrality",
        "Description": [
            "Compute current-flow closeness centrality for nodes.",
            "Current-flow closeness centrality is variant of closeness\ncentrality based on effective resistance between nodes in\na network. This metric is also known as information centrality."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.",
                "weight : None or string, optional (default=None)": "If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight.\nThe weight reflects the capacity or the strength of the\nedge.",
                "dtype: data type (default=float)": "Default data type for internal matrices.\nSet to np.float32 for lower memory consumption.",
                "solver: string (default=\u2019lu\u2019)": "Type of linear solver to use for computing the flow matrix.\nOptions are \u201cfull\u201d (uses most memory), \u201clu\u201d (recommended), and\n\u201ccg\u201d (uses least memory)."
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of nodes with current flow closeness centrality as the value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The algorithm is from Brandes [1] . See also [2] for the original definition of information centrality.",
            "References": "[1]Ulrik Brandes and Daniel Fleischer,\nCentrality Measures Based on Current Flow.\nProc. 22nd Symp. Theoretical Aspects of Computer Science (STACS \u201805).\nLNCS 3404, pp. 533-544. Springer-Verlag, 2005.https://doi.org/10.1007/978-3-540-31856-9_44  [2]Karen Stephenson and Marvin Zelen:\nRethinking centrality: Methods and examples.\nSocial Networks 11(1):1-37, 1989.https://doi.org/10.1016/0378-8733(89)90016-6"
        }
    },
    {
        "Section ID": "minimum_cycle_basis",
        "Description": [
            "Returns a minimum weight cycle basis for G",
            "Minimum weight means a cycle basis for which the total weight\n(length for unweighted graphs) of all the cycles is minimum."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "",
                "weight: string": "name of the edge attribute to use for edge weights"
            },
            "Returns:": {
                "A list of cycle lists.  Each cycle list is a list of nodes": "",
                "which forms a cycle (loop) in G. Note that the nodes are not": "",
                "necessarily returned in a order by which they appear in the cycle": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph()\nnx.add_cycle(G,[0,1,2,3])\nnx.add_cycle(G,[0,3,4,5])\nnx.minimum_cycle_basis(G)\n# [[5, 4, 3, 0], [3, 2, 1, 0]]"
        }
    },
    {
        "Section ID": "k_core",
        "Description": [
            "Returns the k-core of G.",
            "A k-core is a maximal subgraph that contains nodes of degree k or more."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A graph or directed graph",
                "k : int, optional": "The order of the core. If not specified return the main core.",
                "core_number : dictionary, optional": "Precomputed core numbers for the graph G."
            },
            "Returns:": {
                "G : NetworkX graph": "The k-core subgraph"
            },
            "Raises:": {
                "NetworkXNotImplemented": "The k-core is not defined for multigraphs or graphs with self loops."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The main core is the core with k as the largest core_number. For directed graphs the node degree is defined to be the\nin-degree + out-degree. Graph, node, and edge attributes are copied to the subgraph.",
            "References": "[1]An O(m) Algorithm for Cores Decomposition of Networks\nVladimir Batagelj and Matjaz Zaversnik,  2003.https://arxiv.org/abs/cs.DS/0310049",
            "Examples": "degrees=[0,1,2,2,2,2,3]\nH=nx.havel_hakimi_graph(degrees)\nH.degree\n# DegreeView({0: 1, 1: 2, 2: 2, 3: 2, 4: 2, 5: 3, 6: 0})\nnx.k_core(H).nodes\n# NodeView((1, 2, 3, 5))"
        }
    },
    {
        "Section ID": "total_spanning_tree_weight",
        "Description": [
            "Returns the total weight of all spanning trees of G .",
            "Kirchoff\u2019s Tree Matrix Theorem [1] , [2] states that the determinant of any\ncofactor of the Laplacian matrix of a graph is the number of spanning trees\nin the graph. For a weighted Laplacian matrix, it is the sum across all\nspanning trees of the multiplicative weight of each tree. That is, the\nweight of each tree is the product of its edge weights.",
            "For unweighted graphs, the total weight equals the number of spanning trees in G .",
            "For directed graphs, the total weight follows by summing over all directed\nspanning trees in G that start in the root node [3] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "",
                "weight : string or None, optional (default=None)": "The key for the edge attribute holding the edge weight.\nIf None, then each edge has weight 1.",
                "root : node (only required for directed graphs)": "A node in the directed graphG."
            },
            "Returns:": {
                "total_weight : float": "Undirected graphs:The sum of the total multiplicative weights for all spanning trees inG.Directed graphs:The sum of the total multiplicative weights for all spanning trees ofG,\nrooted at noderoot.",
                "Undirected graphs:": "The sum of the total multiplicative weights for all spanning trees inG.",
                "Directed graphs:": "The sum of the total multiplicative weights for all spanning trees ofG,\nrooted at noderoot."
            },
            "Raises:": {
                "NetworkXPointlessConcept": "IfGdoes not contain any nodes.",
                "NetworkXError": "If the graphGis not (weakly) connected,\nor ifGis directed and the root node is not specified or not in G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Self-loops are excluded. Multi-edges are contracted in one edge\nequal to the sum of the weights.",
            "References": "[1]Wikipedia\n\u201cKirchhoff\u2019s theorem.\u201dhttps://en.wikipedia.org/wiki/Kirchhoff%27s_theorem  [2]Kirchhoff, G. R.\n\u00dcber die Aufl\u00f6sung der Gleichungen, auf welche man\nbei der Untersuchung der linearen Vertheilung\nGalvanischer Str\u00f6me gef\u00fchrt wird\nAnnalen der Physik und Chemie, vol. 72, pp. 497-508, 1847.  [3]Margoliash, J.\n\u201cMatrix-Tree Theorem for Directed Graphs\u201dhttps://www.math.uchicago.edu/~may/VIGRE/VIGRE2010/REUPapers/Margoliash.pdf",
            "Examples": "G=nx.complete_graph(5)\nround(nx.total_spanning_tree_weight(G))\n# 125\nG=nx.Graph()\nG.add_edge(1,2,weight=2)\nG.add_edge(1,3,weight=1)\nG.add_edge(2,3,weight=1)\nround(nx.total_spanning_tree_weight(G,\"weight\"))\n# 5"
        }
    },
    {
        "Section ID": "node_redundancy",
        "Description": [
            "Computes the node redundancy coefficients for the nodes in the bipartite\ngraph G .",
            "The redundancy coefficient of a node v is the fraction of pairs of\nneighbors of v that are both linked to other nodes. In a one-mode\nprojection these nodes would be linked together even if v were\nnot there.",
            "More formally, for any vertex v , the redundancy coefficient of `v` is\ndefined by",
            "where N(v) is the set of neighbors of v in G ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A bipartite graph",
                "nodes : list or iterable (optional)": "Compute redundancy for these nodes. The default is all nodes in G."
            },
            "Returns:": {
                "redundancy : dictionary": "A dictionary keyed by node with the node redundancy value."
            },
            "Raises:": {
                "NetworkXError": "If any of the nodes in the graph (or innodes, if specified) has\n(out-)degree less than two (which would result in division by zero,\naccording to the definition of the redundancy coefficient)."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Latapy, Matthieu, Cl\u00e9mence Magnien, and Nathalie Del Vecchio (2008).\nBasic notions for the analysis of large two-mode networks.\nSocial Networks 30(1), 31\u201348.",
            "Examples": "Compute the redundancy coefficient of each node in a graph:\nfromnetworkx.algorithmsimportbipartite\nG=nx.cycle_graph(4)\nrc=bipartite.node_redundancy(G)\nrc[0]\n# 1.0\nCompute the average redundancy for the graph:\nfromnetworkx.algorithmsimportbipartite\nG=nx.cycle_graph(4)\nrc=bipartite.node_redundancy(G)\nsum(rc.values())/len(G)\n# 1.0\nCompute the average redundancy for a set of nodes:\nfromnetworkx.algorithmsimportbipartite\nG=nx.cycle_graph(4)\nrc=bipartite.node_redundancy(G)\nnodes=[0,2]\nsum(rc[n]forninnodes)/len(nodes)\n# 1.0"
        }
    },
    {
        "Section ID": "compose_all",
        "Description": [
            "Returns the composition of all graphs.",
            "Composition is the simple union of the node sets and edge sets.\nThe node sets of the supplied graphs need not be disjoint."
        ],
        "Field List": {
            "Parameters:": {
                "graphs : iterable": "Iterable of NetworkX graphs"
            },
            "Returns:": {
                "C : A graph with the same type as the first graph in list": ""
            },
            "Raises:": {
                "ValueError": "Ifgraphsis an empty list.",
                "NetworkXError": "In case of mixed type graphs, like MultiGraph and Graph, or directed and undirected graphs."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For operating on mixed type graphs, they should be converted to the same type. Graph, edge, and node attributes are propagated to the union graph.\nIf a graph attribute is present in multiple graphs, then the value\nfrom the last graph in the list with that attribute is used.",
            "Examples": "G1=nx.Graph([(1,2),(2,3)])\nG2=nx.Graph([(3,4),(5,6)])\nC=nx.compose_all([G1,G2])\nlist(C.nodes())\n# [1, 2, 3, 4, 5, 6]\nlist(C.edges())\n# [(1, 2), (2, 3), (3, 4), (5, 6)]"
        }
    },
    {
        "Section ID": "maximum_independent_set",
        "Description": [
            "Returns an approximate maximum independent set.",
            "Independent set or stable set is a set of vertices in a graph, no two of\nwhich are adjacent. That is, it is a set I of vertices such that for every\ntwo vertices in I, there is no edge connecting the two. Equivalently, each\nedge in the graph has at most one endpoint in I. The size of an independent\nset is the number of vertices it contains [1] .",
            "A maximum independent set is a largest independent set for a given graph G\nand its size is denoted \\(\\alpha(G)\\) . The problem of finding such a set is called\nthe maximum independent set problem and is an NP-hard optimization problem.\nAs such, it is unlikely that there exists an efficient algorithm for finding\na maximum independent set of a graph.",
            "The Independent Set algorithm is based on [2] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected graph"
            },
            "Returns:": {
                "iset : Set": "The apx-maximum independent set"
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the graph is directed or is a multigraph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Finds the \\(O(|V|/(log|V|)^2)\\) apx of independent set in the worst case.",
            "References": "[1]Wikipedia: Independent set  [2]Boppana, R., & Halld\u00f3rsson, M. M. (1992).\nApproximating maximum independent sets by excluding subgraphs.\nBIT Numerical Mathematics, 32(2), 180\u2013196. Springer.",
            "Examples": "G=nx.path_graph(10)\nnx.approximation.maximum_independent_set(G)\n# {0, 2, 4, 6, 9}"
        }
    },
    {
        "Section ID": "read_dot",
        "Description": [
            "Returns a NetworkX graph from a dot file on path."
        ],
        "Field List": {
            "Parameters:": {
                "path : file or string": "File name or file handle to read."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "read_weighted_edgelist",
        "Description": [
            "Read a graph as list of edges with numeric weights."
        ],
        "Field List": {
            "Parameters:": {
                "path : file or string": "File or filename to read. If a file is provided, it must be\nopened in \u2018rb\u2019 mode.\nFilenames ending in .gz or .bz2 will be uncompressed.",
                "comments : string, optional": "The character used to indicate the start of a comment.",
                "delimiter : string, optional": "The string used to separate values.  The default is whitespace.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated.",
                "nodetype : int, float, str, Python type, optional": "Convert node data from strings to specified type",
                "encoding: string, optional": "Specify which encoding to use when reading file."
            },
            "Returns:": {
                "G : graph": "A networkx Graph or other type specified with create_using"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Since nodes must be hashable, the function nodetype must return hashable\ntypes (e.g. int, float, str, frozenset - or tuples of those, etc.) Example edgelist file format. With numeric edge data:"
        }
    },
    {
        "Section ID": "circular_ladder_graph",
        "Description": [
            "Returns the circular ladder graph \\(CL_n\\) of length n.",
            "\\(CL_n\\) consists of two concentric n-cycles in which\neach of the n pairs of concentric nodes are joined by an edge.",
            "Node labels are the integers 0 to n-1",
            "( Sourcecode , png )"
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "node_attribute_xy",
        "Description": [
            "Returns iterator of node-attribute pairs for all edges in G."
        ],
        "Field List": {
            "Parameters:": {
                "G: NetworkX graph": "",
                "attribute: key": "The node attribute key.",
                "nodes: list or iterable (optional)": "Use only edges that are incident to specified nodes.\nThe default is all nodes."
            },
            "Returns:": {
                "(x, y): 2-tuple": "Generates 2-tuple of (attribute, attribute) values."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For undirected graphs each edge is produced twice, once for each edge\nrepresentation (u, v) and (v, u), with the exception of self-loop edges\nwhich only appear once.",
            "Examples": "G=nx.DiGraph()\nG.add_node(1,color=\"red\")\nG.add_node(2,color=\"blue\")\nG.add_edge(1,2)\nlist(nx.node_attribute_xy(G,\"color\"))\n# [('red', 'blue')]"
        }
    },
    {
        "Section ID": "watts_strogatz_graph",
        "Description": [
            "Returns a Watts\u2013Strogatz small-world graph."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes",
                "k : int": "Each node is joined with itsknearest neighbors in a ring\ntopology.",
                "p : float": "The probability of rewiring each edge",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "First create a ring over \\(n\\) nodes [1] .  Then each node in the ring is joined\nto its \\(k\\) nearest neighbors (or \\(k - 1\\) neighbors if \\(k\\) is odd).\nThen shortcuts are created by replacing some edges as follows: for each\nedge \\((u, v)\\) in the underlying \u201c \\(n\\) -ring with \\(k\\) nearest neighbors\u201d\nwith probability \\(p\\) replace it with a new edge \\((u, w)\\) with uniformly\nrandom choice of existing node \\(w\\) . In contrast with newman_watts_strogatz_graph() , the random rewiring\ndoes not increase the number of edges. The rewired graph is not guaranteed\nto be connected as in connected_watts_strogatz_graph() .",
            "References": "[1]Duncan J. Watts and Steven H. Strogatz,\nCollective dynamics of small-world networks,\nNature, 393, pp. 440\u2013442, 1998."
        }
    },
    {
        "Section ID": "current_flow_betweenness_centrality_subset",
        "Description": [
            "Compute current-flow betweenness centrality for subsets of nodes.",
            "Current-flow betweenness centrality uses an electrical current\nmodel for information spreading in contrast to betweenness\ncentrality which uses shortest paths.",
            "Current-flow betweenness centrality is also known as\nrandom-walk betweenness centrality [2] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "sources: list of nodes": "Nodes to use as sources for current",
                "targets: list of nodes": "Nodes to use as sinks for current",
                "normalized : bool, optional (default=True)": "If True the betweenness values are normalized by b=b/(n-1)(n-2) where\nn is the number of nodes in G.",
                "weight : string or None, optional (default=None)": "Key for edge data used as the edge weight.\nIf None, then use 1 as each edge weight.\nThe weight reflects the capacity or the strength of the\nedge.",
                "dtype: data type (float)": "Default data type for internal matrices.\nSet to np.float32 for lower memory consumption.",
                "solver: string (default=\u2019lu\u2019)": "Type of linear solver to use for computing the flow matrix.\nOptions are \u201cfull\u201d (uses most memory), \u201clu\u201d (recommended), and\n\u201ccg\u201d (uses least memory)."
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of nodes with betweenness centrality as the value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Current-flow betweenness can be computed in \\(O(I(n-1)+mn \\log n)\\) time [1] , where \\(I(n-1)\\) is the time needed to compute the\ninverse Laplacian.  For a full matrix this is \\(O(n^3)\\) but using\nsparse methods you can achieve \\(O(nm{\\sqrt k})\\) where \\(k\\) is the\nLaplacian matrix condition number. The space required is \\(O(nw)\\) where \\(w\\) is the width of the sparse\nLaplacian matrix.  Worse case is \\(w=n\\) for \\(O(n^2)\\) . If the edges have a \u2018weight\u2019 attribute they will be used as\nweights in this algorithm.  Unspecified weights are set to 1.",
            "References": "[1]Centrality Measures Based on Current Flow.\nUlrik Brandes and Daniel Fleischer,\nProc. 22nd Symp. Theoretical Aspects of Computer Science (STACS \u201805).\nLNCS 3404, pp. 533-544. Springer-Verlag, 2005.https://doi.org/10.1007/978-3-540-31856-9_44  [2]A measure of betweenness centrality based on random walks,\nM. E. J. Newman, Social Networks 27, 39-54 (2005)."
        }
    },
    {
        "Section ID": "create_random_state",
        "Description": [
            "Returns a numpy.random.RandomState or numpy.random.Generator instance\ndepending on input."
        ],
        "Field List": {
            "Parameters:": {
                "random_state : int or NumPy RandomState or Generator instance, optional (default=None)": "If int, return a numpy.random.RandomState instance set with seed=int.\nifnumpy.random.RandomStateinstance, return it.\nifnumpy.random.Generatorinstance, return it.\nif None or numpy.random, return the global random number generator used\nby numpy.random."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "bfs_predecessors",
        "Description": [
            "Returns an iterator of predecessors in breadth-first-search from source."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node": "Specify starting node for breadth-first search",
                "depth_limit : int, optional(default=len(G))": "Specify the maximum search depth",
                "sort_neighbors : function (default=None)": "A function that takes an iterator over nodes as the input, and\nreturns an iterable of the same nodes with a custom ordering.\nFor example,sortedwill sort the nodes in increasing order."
            },
            "Returns:": {
                "pred: iterator": "(node, predecessor) iterator wherepredecessoris the predecessor ofnodein a breadth first search starting fromsource."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Based on http://www.ics.uci.edu/~eppstein/PADS/BFS.py by D. Eppstein, July 2004. The modifications\nto allow depth limits based on the Wikipedia article\n\u201c Depth-limited-search \u201d.",
            "Examples": "G=nx.path_graph(3)\ndict(nx.bfs_predecessors(G,0))\n# {1: 0, 2: 1}\nH=nx.Graph()\nH.add_edges_from([(0,1),(0,2),(1,3),(1,4),(2,5),(2,6)])\ndict(nx.bfs_predecessors(H,0))\n# {1: 0, 2: 0, 3: 1, 4: 1, 5: 2, 6: 2}\nM=nx.Graph()\nnx.add_path(M,[0,1,2,3,4,5,6])\nnx.add_path(M,[2,7,8,9,10])\nsorted(nx.bfs_predecessors(M,source=1,depth_limit=3))\n# [(0, 1), (2, 1), (3, 2), (4, 3), (7, 2), (8, 7)]\nN=nx.DiGraph()\nnx.add_path(N,[0,1,2,3,4,7])\nnx.add_path(N,[3,5,6,7])\nsorted(nx.bfs_predecessors(N,source=2))\n# [(3, 2), (4, 3), (5, 3), (6, 5), (7, 4)]"
        }
    },
    {
        "Section ID": "pydot_layout",
        "Description": [
            "Create node positions using pydot and Graphviz."
        ],
        "Field List": {
            "Parameters:": {
                "G : Graph": "NetworkX graph to be laid out.",
                "prog : string  (default: \u2018neato\u2019)": "Name of the GraphViz command to use for layout.\nOptions depend on GraphViz version but may include:\n\u2018dot\u2019, \u2018twopi\u2019, \u2018fdp\u2019, \u2018sfdp\u2019, \u2018circo\u2019",
                "root : Node from G or None (default: None)": "The node of G from which to start some layout algorithms."
            },
            "Returns:": {
                "dict": "Dictionary of positions keyed by node."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "If you use complex node objects, they may have the same string\nrepresentation and GraphViz could treat them as the same node.\nThe layout may assign both nodes a single location. See Issue #1568\nIf this occurs in your case, consider relabeling the nodes just\nfor the layout computation using something similar to:",
            "Examples": "G=nx.complete_graph(4)\npos=nx.nx_pydot.pydot_layout(G)\npos=nx.nx_pydot.pydot_layout(G,prog=\"dot\")"
        }
    },
    {
        "Section ID": "power",
        "Description": [
            "Returns the specified power of a graph.",
            "The \\(k`th power of a simple graph :math:`G\\) , denoted \\(G^k\\) , is a\ngraph on the same set of nodes in which two distinct nodes \\(u\\) and \\(v\\) are adjacent in \\(G^k\\) if and only if the shortest path\ndistance between \\(u\\) and \\(v\\) in \\(G\\) is at most \\(k\\) ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX simple graph object.",
                "k : positive integer": "The power to which to raise the graphG."
            },
            "Returns:": {
                "NetworkX simple graph": "Gto the powerk."
            },
            "Raises:": {
                "ValueError": "If the exponentkis not positive.",
                "NetworkXNotImplemented": "IfGis not a simple graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This definition of \u201cpower graph\u201d comes from Exercise 3.1.6 of Graph Theory by Bondy and Murty [1] .",
            "References": "[1]Bondy, U. S. R. Murty,Graph Theory. Springer, 2008.",
            "Examples": "The number of edges will never decrease when taking successive\npowers:\nG=nx.path_graph(4)\nlist(nx.power(G,2).edges)\n# [(0, 1), (0, 2), (1, 2), (1, 3), (2, 3)]\nlist(nx.power(G,3).edges)\n# [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]\nThekth power of a cycle graph onnnodes is the complete graph\nonnnodes, ifkis at leastn//2:\nG=nx.cycle_graph(5)\nH=nx.complete_graph(5)\nnx.is_isomorphic(nx.power(G,2),H)\n# True\nG=nx.cycle_graph(8)\nH=nx.complete_graph(8)\nnx.is_isomorphic(nx.power(G,4),H)\n# True"
        }
    },
    {
        "Section ID": "cuthill_mckee_ordering",
        "Description": [
            "Generate an ordering (permutation) of the graph nodes to make\na sparse matrix.",
            "Uses the Cuthill-McKee heuristic (based on breadth-first search) [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "heuristic : function, optional": "Function to choose starting node for RCM algorithm.  If None\na node from a pseudo-peripheral pair is used.  A user-defined function\ncan be supplied that takes a graph object and returns a single node."
            },
            "Returns:": {
                "nodes : generator": "Generator of nodes in Cuthill-McKee ordering."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The optimal solution the bandwidth reduction is NP-complete [2] .",
            "References": "[1]E. Cuthill and J. McKee.\nReducing the bandwidth of sparse symmetric matrices,\nIn Proc. 24th Nat. Conf. ACM, pages 157-172, 1969.http://doi.acm.org/10.1145/800195.805928  [2]Steven S. Skiena. 1997. The Algorithm Design Manual.\nSpringer-Verlag New York, Inc., New York, NY, USA.",
            "Examples": "fromnetworkx.utilsimportcuthill_mckee_ordering\nG=nx.path_graph(4)\nrcm=list(cuthill_mckee_ordering(G))\nA=nx.adjacency_matrix(G,nodelist=rcm)\nSmallest degree node as heuristic function:\ndefsmallest_degree(G):\nreturnmin(G,key=G.degree)\nrcm=list(cuthill_mckee_ordering(G,heuristic=smallest_degree))"
        }
    },
    {
        "Section ID": "expected_degree_graph",
        "Description": [
            "Returns a random graph with given expected degrees.",
            "Given a sequence of expected degrees \\(W=(w_0,w_1,\\ldots,w_{n-1})\\) of length \\(n\\) this algorithm assigns an edge between node \\(u\\) and\nnode \\(v\\) with probability"
        ],
        "Field List": {
            "Parameters:": {
                "w : list": "The list of expected degrees.",
                "selfloops: bool (default=True)": "Set to False to remove the possibility of self-loop edges.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "Graph": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The nodes have integer labels corresponding to index of expected degrees\ninput sequence. The complexity of this algorithm is \\(\\mathcal{O}(n+m)\\) where \\(n\\) is the\nnumber of nodes and \\(m\\) is the expected number of edges. The model in [1] includes the possibility of self-loop edges.\nSet selfloops=False to produce a graph without self loops. For finite graphs this model doesn\u2019t produce exactly the given\nexpected degree sequence.  Instead the expected degrees are as\nfollows. For the case without self loops (selfloops=False),",
            "References": "[1]Fan Chung and L. Lu, Connected components in random graphs with\ngiven expected degree sequences, Ann. Combinatorics, 6,\npp. 125-145, 2002.  [2]Joel Miller and Aric Hagberg,\nEfficient generation of networks with given expected degrees,\nin Algorithms and Models for the Web-Graph (WAW 2011),\nAlan Frieze, Paul Horn, and Pawe\u0142 Pra\u0142at (Eds), LNCS 6732,\npp. 115-126, 2011.",
            "Examples": "z=[10foriinrange(100)]\nG=nx.expected_degree_graph(z)"
        }
    },
    {
        "Section ID": "hamiltonian_path",
        "Description": [
            "Returns a Hamiltonian path in the given tournament graph.",
            "Each tournament has a Hamiltonian path. If furthermore, the\ntournament is strongly connected, then the returned Hamiltonian path\nis a Hamiltonian cycle (by joining the endpoints of the path)."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A directed graph representing a tournament."
            },
            "Returns:": {
                "path : list": "A list of nodes which form a Hamiltonian path inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This is a recursive implementation with an asymptotic running time\nof \\(O(n^2)\\) , ignoring multiplicative polylogarithmic factors, where \\(n\\) is the number of nodes in the graph.",
            "Examples": "G=nx.DiGraph([(0,1),(0,2),(0,3),(1,2),(1,3),(2,3)])\nnx.is_tournament(G)\n# True\nnx.tournament.hamiltonian_path(G)\n# [0, 1, 2, 3]"
        }
    },
    {
        "Section ID": "trophic_differences",
        "Description": [
            "Compute the trophic differences of the edges of a directed graph.",
            "The trophic difference \\(x_ij\\) for each edge is defined in Johnson et al. [1] as:",
            "Where \\(s_i\\) is the trophic level of node \\(i\\) ."
        ],
        "Field List": {
            "Parameters:": {
                "G : DiGraph": "A directed networkx graph"
            },
            "Returns:": {
                "diffs : dict": "Dictionary of edges with trophic differences as the value."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Samuel Johnson, Virginia Dominguez-Garcia, Luca Donetti, Miguel A.\nMunoz (2014) PNAS \u201cTrophic coherence determines food-web stability\u201d"
        }
    },
    {
        "Section ID": "tetrahedral_graph",
        "Description": [
            "Returns the 3-regular Platonic Tetrahedral graph.",
            "Tetrahedral graph has 4 nodes and 6 edges. It is a\nspecial case of the complete graph, K4, and wheel graph, W4.\nIt is one of the 5 platonic graphs [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : networkx Graph": "Tetrahedral Graph"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://en.wikipedia.org/wiki/Tetrahedron#Tetrahedral_graph"
        }
    },
    {
        "Section ID": "is_eulerian",
        "Description": [
            "Returns True if and only if G is Eulerian.",
            "A graph is Eulerian if it has an Eulerian circuit. An Eulerian\ncircuit is a closed walk that includes each edge of a graph exactly\nonce.",
            "Graphs with isolated vertices (i.e. vertices with zero degree) are not\nconsidered to have Eulerian circuits. Therefore, if the graph is not\nconnected (or not strongly connected, for directed graphs), this function\nreturns False."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A graph, either directed or undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "nx.is_eulerian(nx.DiGraph({0:[3],1:[2],2:[3],3:[0,1]}))\n# True\nnx.is_eulerian(nx.complete_graph(5))\n# True\nnx.is_eulerian(nx.petersen_graph())\n# False\nIf you prefer to allow graphs with isolated vertices to have Eulerian circuits,\nyou can first remove such vertices and then callis_eulerianas below example shows.\nG=nx.Graph([(0,1),(1,2),(0,2)])\nG.add_node(3)\nnx.is_eulerian(G)\n# False\nG.remove_nodes_from(list(nx.isolates(G)))\nnx.is_eulerian(G)\n# True"
        }
    },
    {
        "Section ID": "triad_graph",
        "Description": [
            "Returns the triad graph with the given name.",
            "Each string in the following tuple is a valid triad name:",
            "Each triad name corresponds to one of the possible valid digraph on\nthree nodes."
        ],
        "Field List": {
            "Parameters:": {
                "triad_name : string": "The name of a triad, as described above."
            },
            "Returns:": {
                "DiGraph": "The digraph on three nodes with the given name. The nodes of the\ngraph are the single-character strings \u2018a\u2019, \u2018b\u2019, and \u2018c\u2019."
            },
            "Raises:": {
                "ValueError": "Iftriad_nameis not the name of a triad."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "minimum_weight_full_matching",
        "Description": [
            "Returns a minimum weight full matching of the bipartite graph G .",
            "Let \\(G = ((U, V), E)\\) be a weighted bipartite graph with real weights \\(w : E \\to \\mathbb{R}\\) . This function then produces a matching \\(M \\subseteq E\\) with cardinality",
            "which minimizes the sum of the weights of the edges included in the\nmatching, \\(\\sum_{e \\in M} w(e)\\) , or raises an error if no such\nmatching exists.",
            "When \\(\\lvert U \\rvert = \\lvert V \\rvert\\) , this is commonly\nreferred to as a perfect matching; here, since we allow \\(\\lvert U \\rvert\\) and \\(\\lvert V \\rvert\\) to differ, we\nfollow Karp [1] and refer to the matching as full ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected bipartite graph",
                "top_nodes : container": "Container with all nodes in one bipartite node set. If not supplied\nit will be computed.",
                "weight : string, optional (default=\u2019weight\u2019)": "The edge data key used to provide each value in the matrix.\nIf None, then each edge has weight 1."
            },
            "Returns:": {
                "matches : dictionary": "The matching is returned as a dictionary,matches, such thatmatches[v]==wif nodevis matched to nodew. Unmatched\nnodes do not occur as a key inmatches."
            },
            "Raises:": {
                "ValueError": "Raised if no full matching exists.",
                "ImportError": "Raised if SciPy is not available."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The problem of determining a minimum weight full matching is also known as\nthe rectangular linear assignment problem. This implementation defers the\ncalculation of the assignment to SciPy.",
            "References": "[1]Richard Manning Karp:\nAn algorithm to Solve the m x n Assignment Problem in Expected Time\nO(mn log n).\nNetworks, 10(2):143\u2013152, 1980."
        }
    },
    {
        "Section ID": "load_centrality",
        "Description": [
            "Compute load centrality for nodes.",
            "The load centrality of a node is the fraction of all shortest\npaths that pass through that node."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph.",
                "normalized : bool, optional (default=True)": "If True the betweenness values are normalized by b=b/(n-1)(n-2) where\nn is the number of nodes in G.",
                "weight : None or string, optional (default=None)": "If None, edge weights are ignored.\nOtherwise holds the name of the edge attribute used as weight.\nThe weight of an edge is treated as the length or distance between the two sides.",
                "cutoff : bool, optional (default=None)": "If specified, only consider paths of length <= cutoff."
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of nodes with centrality as the value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Load centrality is slightly different than betweenness. It was originally\nintroduced by [2] . For this load algorithm see [1] .",
            "References": "[1]Mark E. J. Newman:\nScientific collaboration networks. II.\nShortest paths, weighted networks, and centrality.\nPhysical Review E 64, 016132, 2001.http://journals.aps.org/pre/abstract/10.1103/PhysRevE.64.016132  [2]Kwang-Il Goh, Byungnam Kahng and Doochul Kim\nUniversal behavior of Load Distribution in Scale-Free Networks.\nPhysical Review Letters 87(27):1\u20134, 2001.https://doi.org/10.1103/PhysRevLett.87.278701"
        }
    },
    {
        "Section ID": "girvan_newman",
        "Description": [
            "Finds communities in a graph using the Girvan\u2013Newman method."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "most_valuable_edge : function": "Function that takes a graph as input and outputs an edge. The\nedge returned by this function will be recomputed and removed at\neach iteration of the algorithm.If not specified, the edge with the highestnetworkx.edge_betweenness_centrality()will be used."
            },
            "Returns:": {
                "iterator": "Iterator over tuples of sets of nodes inG. Each set of node\nis a community, each tuple is a sequence of communities at a\nparticular level of the algorithm."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The Girvan\u2013Newman algorithm detects communities by progressively\nremoving edges from the original graph. The algorithm removes the\n\u201cmost valuable\u201d edge, traditionally the edge with the highest\nbetweenness centrality, at each step. As the graph breaks down into\npieces, the tightly knit community structure is exposed and the\nresult can be depicted as a dendrogram.",
            "Examples": "To get the first pair of communities:\nG=nx.path_graph(10)\ncomp=nx.community.girvan_newman(G)\ntuple(sorted(c)forcinnext(comp))\n# ([0, 1, 2, 3, 4], [5, 6, 7, 8, 9])\nTo get only the firstktuples of communities, useitertools.islice():\nimportitertools\nG=nx.path_graph(8)\nk=2\ncomp=nx.community.girvan_newman(G)\nforcommunitiesinitertools.islice(comp,k):\nprint(tuple(sorted(c)forcincommunities))\n\n# ([0, 1, 2, 3], [4, 5, 6, 7])\n# ([0, 1], [2, 3], [4, 5, 6, 7])\nTo stop getting tuples of communities once the number of communities\nis greater thank, useitertools.takewhile():\nimportitertools\nG=nx.path_graph(8)\nk=4\ncomp=nx.community.girvan_newman(G)\nlimited=itertools.takewhile(lambdac:len(c)<=k,comp)\nforcommunitiesinlimited:\nprint(tuple(sorted(c)forcincommunities))\n\n# ([0, 1, 2, 3], [4, 5, 6, 7])\n# ([0, 1], [2, 3], [4, 5, 6, 7])\n# ([0, 1], [2, 3], [4, 5], [6, 7])\nTo just choose an edge to remove based on the weight:\nfromoperatorimportitemgetter\nG=nx.path_graph(10)\nedges=G.edges()\nnx.set_edge_attributes(G,{(u,v):vforu,vinedges},\"weight\")\ndefheaviest(G):\nu,v,w=max(G.edges(data=\"weight\"),key=itemgetter(2))\nreturn(u,v)\n\ncomp=nx.community.girvan_newman(G,most_valuable_edge=heaviest)\ntuple(sorted(c)forcinnext(comp))\n# ([0, 1, 2, 3, 4, 5, 6, 7, 8], [9])\nTo utilize edge weights when choosing an edge with, for example, the\nhighest betweenness centrality:\nfromnetworkximportedge_betweenness_centralityasbetweenness\ndefmost_central_edge(G):\ncentrality=betweenness(G,weight=\"weight\")\nreturnmax(centrality,key=centrality.get)\n\nG=nx.path_graph(10)\ncomp=nx.community.girvan_newman(G,most_valuable_edge=most_central_edge)\ntuple(sorted(c)forcinnext(comp))\n# ([0, 1, 2, 3, 4], [5, 6, 7, 8, 9])\nTo specify a different ranking algorithm for edges, use themost_valuable_edgekeyword argument:\nfromnetworkximportedge_betweenness_centrality\nfromrandomimportrandom\ndefmost_central_edge(G):\ncentrality=edge_betweenness_centrality(G)\nmax_cent=max(centrality.values())\n# Scale the centrality values so they are between 0 and 1,\n# and add some random noise.\ncentrality={e:c/max_centfore,cincentrality.items()}\n# Add some random noise.\ncentrality={e:c+random()fore,cincentrality.items()}\nreturnmax(centrality,key=centrality.get)\n\nG=nx.path_graph(10)\ncomp=nx.community.girvan_newman(G,most_valuable_edge=most_central_edge)"
        }
    },
    {
        "Section ID": "edge_bfs",
        "Description": [
            "A directed, breadth-first-search of edges in G , beginning at source .",
            "Yield the edges of G in a breadth-first-search order continuing until\nall edges are generated."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A directed/undirected graph/multigraph.",
                "source : node, list of nodes": "The node from which the traversal begins. If None, then a source\nis chosen arbitrarily and repeatedly until all edges from each node in\nthe graph are searched.",
                "orientation : None | \u2018original\u2019 | \u2018reverse\u2019 | \u2018ignore\u2019 (default: None)": "For directed graphs and directed multigraphs, edge traversals need not\nrespect the original orientation of the edges.\nWhen set to \u2018reverse\u2019 every edge is traversed in the reverse direction.\nWhen set to \u2018ignore\u2019, every edge is treated as undirected.\nWhen set to \u2018original\u2019, every edge is treated as directed.\nIn all three cases, the yielded edge tuples add a last entry to\nindicate the direction in which that edge was traversed.\nIf orientation is None, the yielded edge has no direction indicated.\nThe direction is respected, but not reported."
            },
            "Yields:": {
                "edge : directed edge": "A directed edge indicating the path taken by the breadth-first-search.\nFor graphs,edgeis of the form(u,v)whereuandvare the tail and head of the edge as determined by the traversal.\nFor multigraphs,edgeis of the form(u,v,key), wherekeyis\nthe key of the edge. When the graph is directed, thenuandvare always in the order of the actual directed edge.\nIf orientation is not None then the edge tuple is extended to include\nthe direction of traversal (\u2018forward\u2019 or \u2018reverse\u2019) on that edge."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The goal of this function is to visit edges. It differs from the more\nfamiliar breadth-first-search of nodes, as provided by networkx.algorithms.traversal.breadth_first_search.bfs_edges() , in\nthat it does not stop once every node has been visited. In a directed graph\nwith edges [(0, 1), (1, 2), (2, 1)], the edge (2, 1) would not be visited\nif not for the functionality provided by this function. The naming of this function is very similar to bfs_edges. The difference\nis that \u2018edge_bfs\u2019 yields edges even if they extend back to an already\nexplored node while \u2018bfs_edges\u2019 yields the edges of the tree that results\nfrom a breadth-first-search (BFS) so no edges are reported if they extend\nto already explored nodes. That means \u2018edge_bfs\u2019 reports all edges while\n\u2018bfs_edges\u2019 only report those traversed by a node-based BFS. Yet another\ndescription is that \u2018bfs_edges\u2019 reports the edges traversed during BFS\nwhile \u2018edge_bfs\u2019 reports all edges in the order they are explored.",
            "Examples": "nodes=[0,1,2,3]\nedges=[(0,1),(1,0),(1,0),(2,0),(2,1),(3,1)]\nlist(nx.edge_bfs(nx.Graph(edges),nodes))\n# [(0, 1), (0, 2), (1, 2), (1, 3)]\nlist(nx.edge_bfs(nx.DiGraph(edges),nodes))\n# [(0, 1), (1, 0), (2, 0), (2, 1), (3, 1)]\nlist(nx.edge_bfs(nx.MultiGraph(edges),nodes))\n# [(0, 1, 0), (0, 1, 1), (0, 1, 2), (0, 2, 0), (1, 2, 0), (1, 3, 0)]\nlist(nx.edge_bfs(nx.MultiDiGraph(edges),nodes))\n# [(0, 1, 0), (1, 0, 0), (1, 0, 1), (2, 0, 0), (2, 1, 0), (3, 1, 0)]\nlist(nx.edge_bfs(nx.DiGraph(edges),nodes,orientation=\"ignore\"))\n# [(0, 1, 'forward'), (1, 0, 'reverse'), (2, 0, 'reverse'), (2, 1, 'reverse'), (3, 1, 'reverse')]\nlist(nx.edge_bfs(nx.MultiDiGraph(edges),nodes,orientation=\"ignore\"))\n# [(0, 1, 0, 'forward'), (1, 0, 0, 'reverse'), (1, 0, 1, 'reverse'), (2, 0, 0, 'reverse'), (2, 1, 0, 'reverse'), (3, 1, 0, 'reverse')]"
        }
    },
    {
        "Section ID": "strategy_random_sequential",
        "Description": [
            "Returns a random permutation of the nodes of G as a list.",
            "G is a NetworkX graph. colors is ignored."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "number_of_nodes",
        "Description": [
            "Returns the number of nodes in the graph.",
            "This function wraps the G.number_of_nodes function."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "strategy_largest_first",
        "Description": [
            "Returns a list of the nodes of G in decreasing order by\ndegree.",
            "G is a NetworkX graph. colors is ignored."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "moral_graph",
        "Description": [
            "Return the Moral Graph",
            "Returns the moralized graph of a given directed graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Directed graph"
            },
            "Returns:": {
                "H : NetworkX graph": "The undirected moralized graph of G"
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "A moral graph is an undirected graph H = (V, E) generated from a\ndirected Graph, where if a node has more than one parent node, edges\nbetween these parent nodes are inserted and all directed edges become\nundirected. https://en.wikipedia.org/wiki/Moral_graph",
            "References": "[1]Wray L. Buntine. 1995. Chain graphs for learning.\nIn Proceedings of the Eleventh conference on Uncertainty\nin artificial intelligence (UAI\u201995)",
            "Examples": "G=nx.DiGraph([(1,2),(2,3),(2,5),(3,4),(4,3)])\nG_moral=nx.moral_graph(G)\nG_moral.edges()\n# EdgeView([(1, 2), (2, 3), (2, 5), (2, 4), (3, 4)])"
        }
    },
    {
        "Section ID": "strategy_smallest_last",
        "Description": [
            "Returns a deque of the nodes of G , \u201csmallest\u201d last.",
            "Specifically, the degrees of each node are tracked in a bucket queue.\nFrom this, the node of minimum degree is repeatedly popped from the\ngraph, updating its neighbors\u2019 degrees.",
            "G is a NetworkX graph. colors is ignored.",
            "This implementation of the strategy runs in \\(O(n + m)\\) time\n(ignoring polylogarithmic factors), where \\(n\\) is the number of nodes\nand \\(m\\) is the number of edges.",
            "This strategy is related to strategy_independent_set() : if we\ninterpret each node removed as an independent set of size one, then\nthis strategy chooses an independent set of size one instead of a\nmaximal independent set."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "minimum_branching",
        "Description": [
            "Returns a minimum branching from G."
        ],
        "Field List": {
            "Parameters:": {
                "G : (multi)digraph-like": "The graph to be searched.",
                "attr : str": "The edge attribute used to in determining optimality.",
                "default : float": "The value of the edge attribute used if an edge does not have\nthe attributeattr.",
                "preserve_attrs : bool": "If True, preserve the other attributes of the original graph (that are not\npassed toattr)",
                "partition : str": "The key for the edge attribute containing the partition\ndata on the graph. Edges can be included, excluded or open using theEdgePartitionenum."
            },
            "Returns:": {
                "B : (multi)digraph-like": "A minimum branching."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "configuration_model",
        "Description": [
            "Returns a random graph with the given degree sequence.",
            "The configuration model generates a random pseudograph (graph with\nparallel edges and self loops) by randomly assigning edges to\nmatch the given degree sequence."
        ],
        "Field List": {
            "Parameters:": {
                "deg_sequence : list of nonnegative integers": "Each list entry corresponds to the degree of a node.",
                "create_using : NetworkX graph constructor, optional (default MultiGraph)": "Graph type to create. If graph instance, then cleared before populated.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "G : MultiGraph": "A graph with the specified degree sequence.\nNodes are labeled starting at 0 with an index\ncorresponding to the position in deg_sequence."
            },
            "Raises:": {
                "NetworkXError": "If the degree sequence does not have an even sum."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "As described by Newman [1] . A non-graphical degree sequence (not realizable by some simple\ngraph) is allowed since this function returns graphs with self\nloops and parallel edges.  An exception is raised if the degree\nsequence does not have an even sum. This configuration model construction process can lead to\nduplicate edges and loops.  You can remove the self-loops and\nparallel edges (see below) which will likely result in a graph\nthat doesn\u2019t have the exact degree sequence specified. The density of self-loops and parallel edges tends to decrease as\nthe number of nodes increases. However, typically the number of\nself-loops will approach a Poisson distribution with a nonzero mean,\nand similarly for the number of parallel edges.  Consider a node\nwith k stubs. The probability of being joined to another stub of\nthe same node is basically ( k - 1 ) / N , where k is the\ndegree and N is the number of nodes. So the probability of a\nself-loop scales like c / N for some constant c . As N grows,\nthis means we expect c self-loops. Similarly for parallel edges.",
            "References": "[1]M.E.J. Newman, \u201cThe structure and function of complex networks\u201d,\nSIAM REVIEW 45-2, pp 167-256, 2003.",
            "Examples": "You can create a degree sequence following a particular distribution\nby using the one of the distribution functions inrandom_sequence(or one of your own). For\nexample, to create an undirected multigraph on one hundred nodes\nwith degree sequence chosen from the power law distribution:\nsequence=nx.random_powerlaw_tree_sequence(100,tries=5000)\nG=nx.configuration_model(sequence)\nlen(G)\n# 100\nactual_degrees=[dforv,dinG.degree()]\nactual_degrees==sequence\n# True\nThe returned graph is a multigraph, which may have parallel\nedges. To remove any parallel edges from the returned graph:\nG=nx.Graph(G)\nSimilarly, to remove self-loops:\nG.remove_edges_from(nx.selfloop_edges(G))"
        }
    },
    {
        "Section ID": "asyn_lpa_communities",
        "Description": [
            "Returns communities in G as detected by asynchronous label\npropagation.",
            "The asynchronous label propagation algorithm is described in [1] . The algorithm is probabilistic and the found communities may\nvary on different executions.",
            "The algorithm proceeds as follows. After initializing each node with\na unique label, the algorithm repeatedly sets the label of a node to\nbe the label that appears most frequently among that nodes\nneighbors. The algorithm halts when each node has the label that\nappears most frequently among its neighbors. The algorithm is\nasynchronous because each node is updated without waiting for\nupdates on the remaining nodes.",
            "This generalized version of the algorithm in [1] accepts edge\nweights."
        ],
        "Field List": {
            "Parameters:": {
                "G : Graph": "",
                "weight : string": "The edge attribute representing the weight of an edge.\nIf None, each edge is assumed to have weight one. In this\nalgorithm, the weight of an edge is used in determining the\nfrequency with which a label appears among the neighbors of a\nnode: a higher weight means the label appears more often.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "communities : iterable": "Iterable of communities given as sets of nodes."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.",
            "References": "[1](1,2)Raghavan, Usha Nandini, R\u00e9ka Albert, and Soundar Kumara. \u201cNear\nlinear time algorithm to detect community structures in large-scale\nnetworks.\u201d Physical Review E 76.3 (2007): 036106."
        }
    },
    {
        "Section ID": "edge_connectivity",
        "Description": [
            "Returns the edge connectivity of the graph or digraph G.",
            "The edge connectivity is equal to the minimum number of edges that\nmust be removed to disconnect G or render it trivial. If source\nand target nodes are provided, this function returns the local edge\nconnectivity: the minimum number of edges that must be removed to\nbreak all paths from source to target in G."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected or directed graph",
                "s : node": "Source node. Optional. Default value: None.",
                "t : node": "Target node. Optional. Default value: None.",
                "flow_func : function": "A function for computing the maximum flow among a pair of nodes.\nThe function has to accept at least three parameters: a Digraph,\na source node, and a target node. And return a residual network\nthat follows NetworkX conventions (seemaximum_flow()for\ndetails). If flow_func is None, the default maximum flow function\n(edmonds_karp()) is used. See below for details. The\nchoice of the default function may change from version\nto version and should not be relied on. Default value: None.",
                "cutoff : integer, float, or None (default: None)": "If specified, the maximum flow algorithm will terminate when the\nflow value reaches or exceeds the cutoff. This only works for flows\nthat support the cutoff parameter (most do) and is ignored otherwise."
            },
            "Returns:": {
                "K : integer": "Edge connectivity for G, or local edge connectivity if source\nand target were provided"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This is a flow based implementation of global edge connectivity.\nFor undirected graphs the algorithm works by finding a \u2018small\u2019\ndominating set of nodes of G (see algorithm 7 in [1] ) and\ncomputing local maximum flow (see local_edge_connectivity() )\nbetween an arbitrary node in the dominating set and the rest of\nnodes in it. This is an implementation of algorithm 6 in [1] .\nFor directed graphs, the algorithm does n calls to the maximum\nflow function. This is an implementation of algorithm 8 in [1] .",
            "References": "[1](1,2,3)Abdol-Hossein Esfahanian. Connectivity Algorithms.http://www.cse.msu.edu/~cse835/Papers/Graph_connectivity_revised.pdf",
            "Examples": "# Platonic icosahedral graph is 5-edge-connected\nG=nx.icosahedral_graph()\nnx.edge_connectivity(G)\n# 5\nYou can use alternative flow algorithms for the underlying\nmaximum flow computation. In dense networks the algorithmshortest_augmenting_path()will usually perform better\nthan the defaultedmonds_karp(), which is faster for\nsparse networks with highly skewed degree distributions.\nAlternative flow functions have to be explicitly imported\nfrom the flow package.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\nnx.edge_connectivity(G,flow_func=shortest_augmenting_path)\n# 5\nIf you specify a pair of nodes (source and target) as parameters,\nthis function returns the value of local edge connectivity.\nnx.edge_connectivity(G,3,7)\n# 5\nIf you need to perform several local computations among different\npairs of nodes on the same graph, it is recommended that you reuse\nthe data structures used in the maximum flow computations. Seelocal_edge_connectivity()for details."
        }
    },
    {
        "Section ID": "latapy_clustering",
        "Description": [
            "Compute a bipartite clustering coefficient for nodes.",
            "The bipartite clustering coefficient is a measure of local density\nof connections defined as [1] :",
            "where N(N(u)) are the second order neighbors of u in G excluding u ,\nand c_{uv} is the pairwise clustering coefficient between nodes u and v .",
            "The mode selects the function for c_{uv} which can be:",
            "dot :",
            "min :",
            "max :"
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A bipartite graph",
                "nodes : list or iterable (optional)": "Compute bipartite clustering for these nodes. The default\nis all nodes in G.",
                "mode : string": "The pairwise bipartite clustering method to be used in the computation.\nIt must be \u201cdot\u201d, \u201cmax\u201d, or \u201cmin\u201d."
            },
            "Returns:": {
                "clustering : dictionary": "A dictionary keyed by node with the clustering coefficient value."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Latapy, Matthieu, Cl\u00e9mence Magnien, and Nathalie Del Vecchio (2008).\nBasic notions for the analysis of large two-mode networks.\nSocial Networks 30(1), 31\u201348.",
            "Examples": "fromnetworkx.algorithmsimportbipartite\nG=nx.path_graph(4)# path graphs are bipartite\nc=bipartite.clustering(G)\nc[0]\n# 0.5\nc=bipartite.clustering(G,mode=\"min\")\nc[0]\n# 1.0"
        }
    },
    {
        "Section ID": "topological_generations",
        "Description": [
            "Stratifies a DAG into generations.",
            "A topological generation is node collection in which ancestors of a node in each\ngeneration are guaranteed to be in a previous generation, and any descendants of\na node are guaranteed to be in a following generation. Nodes are guaranteed to\nbe in the earliest possible generation that they can belong to."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX digraph": "A directed acyclic graph (DAG)"
            },
            "Yields:": {
                "sets of nodes": "Yields sets of nodes representing each generation."
            },
            "Raises:": {
                "NetworkXError": "Generations are defined for directed graphs only. If the graphGis undirected, aNetworkXErroris raised.",
                "NetworkXUnfeasible": "IfGis not a directed acyclic graph (DAG) no topological generations\nexist and aNetworkXUnfeasibleexception is raised.  This can also\nbe raised ifGis changed while the returned iterator is being processed",
                "RuntimeError": "IfGis changed while the returned iterator is being processed."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The generation in which a node resides can also be determined by taking the\nmax-path-distance from the node to the farthest leaf node. That value can\nbe obtained with this function using enumerate(topological_generations(G)) .",
            "Examples": "DG=nx.DiGraph([(2,1),(3,1)])\n[sorted(generation)forgenerationinnx.topological_generations(DG)]\n# [[2, 3], [1]]"
        }
    },
    {
        "Section ID": "FilterAdjacency",
        "Description": [
            "A read-only Mapping of Mappings with filtering criteria for nodes and edges.",
            "It is a view into a dict-of-dict-of-dict data structure, and it selects nodes\nand edges that satisfy specific criteria defined by NODE_OK and EDGE_OK ,\nrespectively."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "attr_sparse_matrix",
        "Description": [
            "Returns a SciPy sparse array using attributes from G.",
            "If only G is passed in, then the adjacency matrix is constructed.",
            "Let A be a discrete set of values for the node attribute node_attr . Then\nthe elements of A represent the rows and columns of the constructed matrix.\nNow, iterate through every edge e=(u,v) in G and consider the value\nof the edge attribute edge_attr .  If ua and va are the values of the\nnode attribute node_attr for u and v, respectively, then the value of\nthe edge attribute is added to the matrix element at (ua, va)."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "The NetworkX graph used to construct the NumPy matrix.",
                "edge_attr : str, optional": "Each element of the matrix represents a running total of the\nspecified edge attribute for edges whose node attributes correspond\nto the rows/cols of the matrix. The attribute must be present for\nall edges in the graph. If no attribute is specified, then we\njust count the number of edges whose node attributes correspond\nto the matrix element.",
                "node_attr : str, optional": "Each row and column in the matrix represents a particular value\nof the node attribute.  The attribute must be present for all nodes\nin the graph. Note, the values of this attribute should be reliably\nhashable. So, float values are not recommended. If no attribute is\nspecified, then the rows and columns will be the nodes of the graph.",
                "normalized : bool, optional": "If True, then each row is normalized by the summation of its values.",
                "rc_order : list, optional": "A list of the node attribute values. This list specifies the ordering\nof rows and columns of the array. If no ordering is provided, then\nthe ordering will be random (and also, a return value)."
            },
            "Returns:": {
                "M : SciPy sparse array": "The attribute matrix.",
                "ordering : list": "Ifrc_orderwas specified, then only the matrix is returned.\nHowever, ifrc_orderwas None, then the ordering used to construct\nthe matrix is returned as well."
            },
            "Other Parameters:": {
                "dtype : NumPy data-type, optional": "A valid NumPy dtype used to initialize the array. Keep in mind certain\ndtypes can yield unexpected results if the array is to be normalized.\nThe parameter is passed to numpy.zeros(). If unspecified, the NumPy\ndefault is used."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "Construct an adjacency matrix:\nG=nx.Graph()\nG.add_edge(0,1,thickness=1,weight=3)\nG.add_edge(0,2,thickness=2)\nG.add_edge(1,2,thickness=3)\nM=nx.attr_sparse_matrix(G,rc_order=[0,1,2])\nM.toarray()\n# array([[0., 1., 1.],\n#        [1., 0., 1.],\n#        [1., 1., 0.]])\nAlternatively, we can obtain the matrix describing edge thickness.\nM=nx.attr_sparse_matrix(G,edge_attr=\"thickness\",rc_order=[0,1,2])\nM.toarray()\n# array([[0., 1., 2.],\n#        [1., 0., 3.],\n#        [2., 3., 0.]])\nWe can also color the nodes and ask for the probability distribution over\nall edges (u,v) describing:"
        }
    },
    {
        "Section ID": "eulerian_circuit",
        "Description": [
            "Returns an iterator over the edges of an Eulerian circuit in G .",
            "An Eulerian circuit is a closed walk that includes each edge of a\ngraph exactly once."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A graph, either directed or undirected.",
                "source : node, optional": "Starting node for circuit.",
                "keys : bool": "If False, edges generated by this function will be of the form(u,v). Otherwise, edges will be of the form(u,v,k).\nThis option is ignored unlessGis a multigraph."
            },
            "Returns:": {
                "edges : iterator": "An iterator over edges in the Eulerian circuit."
            },
            "Raises:": {
                "NetworkXError": "If the graph is not Eulerian."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This is a linear time implementation of an algorithm adapted from [1] . For general information about Euler tours, see [2] .",
            "References": "[1]J. Edmonds, E. L. Johnson.\nMatching, Euler tours and the Chinese postman.\nMathematical programming, Volume 5, Issue 1 (1973), 111-114.  [2]https://en.wikipedia.org/wiki/Eulerian_path",
            "Examples": "To get an Eulerian circuit in an undirected graph:\nG=nx.complete_graph(3)\nlist(nx.eulerian_circuit(G))\n# [(0, 2), (2, 1), (1, 0)]\nlist(nx.eulerian_circuit(G,source=1))\n# [(1, 2), (2, 0), (0, 1)]\nTo get the sequence of vertices in an Eulerian circuit:\n[uforu,vinnx.eulerian_circuit(G)]\n# [0, 2, 1]"
        }
    },
    {
        "Section ID": "is_regular",
        "Description": [
            "Determines whether the graph G is a regular graph.",
            "A regular graph is a graph where each vertex has the same degree. A\nregular digraph is a graph where the indegree and outdegree of each\nvertex are equal."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": ""
            },
            "Returns:": {
                "bool": "Whether the given graph or digraph is regular."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.DiGraph([(1,2),(2,3),(3,4),(4,1)])\nnx.is_regular(G)\n# True"
        }
    },
    {
        "Section ID": "random_lobster",
        "Description": [
            "Returns a random lobster graph.",
            "A lobster is a tree that reduces to a caterpillar when pruning all\nleaf nodes. A caterpillar is a tree that reduces to a path graph\nwhen pruning all leaf nodes; setting p2 to zero produces a caterpillar.",
            "This implementation iterates on the probabilities p1 and p2 to add\nedges at levels 1 and 2, respectively. Graphs are therefore constructed\niteratively with uniform randomness at each level rather than being selected\nuniformly at random from the set of all possible lobsters."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The expected number of nodes in the backbone",
                "p1 : float": "Probability of adding an edge to the backbone",
                "p2 : float": "Probability of adding an edge one level beyond backbone",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Raises:": {
                "NetworkXError": "Ifp1orp2parameters are >= 1 because the while loops would never finish."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "maximal_matching",
        "Description": [
            "Find a maximal matching in the graph.",
            "A matching is a subset of edges in which no node occurs more than once.\nA maximal matching cannot add more edges and still be a matching."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected graph"
            },
            "Returns:": {
                "matching : set": "A maximal matching of the graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The algorithm greedily selects a maximal matching M of the graph G\n(i.e. no superset of M exists). It runs in \\(O(|E|)\\) time.",
            "Examples": "G=nx.Graph([(1,2),(1,3),(2,3),(2,4),(3,5),(4,5)])\nsorted(nx.maximal_matching(G))\n# [(1, 2), (3, 5)]"
        }
    },
    {
        "Section ID": "local_bridges",
        "Description": [
            "Iterate over local bridges of G optionally computing the span",
            "A local bridge is an edge whose endpoints have no common neighbors.\nThat is, the edge is not part of a triangle in the graph.",
            "The span of a local bridge is the shortest path length between\nthe endpoints if the local bridge is removed."
        ],
        "Field List": {
            "Parameters:": {
                "G : undirected graph": "",
                "with_span : bool": "If True, yield a 3-tuple(u,v,span)",
                "weight : function, string or None (default: None)": "If function, used to compute edge weights for the span.\nIf string, the edge data attribute used in calculating span.\nIf None, all edges have weight 1."
            },
            "Yields:": {
                "e : edge": "The local bridges as an edge 2-tuple of nodes(u,v)or\nas a 3-tuple(u,v,span)whenwith_spanisTrue."
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis a directed graph or multigraph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "A cycle graph has every edge a local bridge with span N-1.\nG=nx.cycle_graph(9)\n(0,8,8)inset(nx.local_bridges(G))\n# True"
        }
    },
    {
        "Section ID": "is_strongly_connected",
        "Description": [
            "Decides whether the given tournament is strongly connected.",
            "This function is more theoretically efficient than the is_strongly_connected() function.",
            "The given graph must be a tournament, otherwise this function\u2019s\nbehavior is undefined."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A directed graph representing a tournament."
            },
            "Returns:": {
                "bool": "Whether the tournament is strongly connected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Although this function is more theoretically efficient than the\ngeneric strong connectivity function, a speedup requires the use of\nparallelism. Though it may in the future, the current implementation\ndoes not use parallelism, thus you may not see much of a speedup. This algorithm comes from [1].",
            "References": "[1]Tantau, Till.\n\u201cA note on the complexity of the reachability problem for\ntournaments.\u201dElectronic Colloquium on Computational Complexity. 2001.\n<http://eccc.hpi-web.de/report/2001/092/>",
            "Examples": "G=nx.DiGraph([(0,1),(0,2),(1,2),(1,3),(2,3),(3,0)])\nnx.is_tournament(G)\n# True\nnx.tournament.is_strongly_connected(G)\n# True\nG.remove_edge(3,0)\nG.add_edge(0,3)\nnx.is_tournament(G)\n# True\nnx.tournament.is_strongly_connected(G)\n# False"
        }
    },
    {
        "Section ID": "pairwise",
        "Description": [
            "s -> (s0, s1), (s1, s2), (s2, s3), \u2026"
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "random_regular_expander_graph",
        "Description": [
            "Returns a random regular expander graph on \\(n\\) nodes with degree \\(d\\) .",
            "An expander graph is a sparse graph with strong connectivity properties. [1]",
            "More precisely the returned graph is a \\((n, d, \\lambda)\\) -expander with \\(\\lambda = 2 \\sqrt{d - 1} + \\epsilon\\) , close to the Alon-Boppana bound. [2]",
            "In the case where \\(\\epsilon = 0\\) it returns a Ramanujan graph.\nA Ramanujan graph has spectral gap almost as large as possible,\nwhich makes them excellent expanders. [3]"
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes.",
                "d : int": "The degree of each node.",
                "epsilon : int, float, default=0": "",
                "max_tries : int, (default: 100)": "The number of allowed loops, also used in the maybe_regular_expander utility",
                "seed : (default: None)": "Seed used to set random number generation state. See :ref`Randomness<randomness>`."
            },
            "Raises:": {
                "NetworkXError": "If max_tries is reached"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This loops over maybe_regular_expander and can be slow when \\(n\\) is too big or \\(\\epsilon\\) too small.",
            "References": "[1]Expander graph,https://en.wikipedia.org/wiki/Expander_graph  [2]Alon-Boppana bound,https://en.wikipedia.org/wiki/Alon%E2%80%93Boppana_bound  [3]Ramanujan graphs,https://en.wikipedia.org/wiki/Ramanujan_graph",
            "Examples": "G=nx.random_regular_expander_graph(20,4)\nnx.is_regular_expander(G)\n# True"
        }
    },
    {
        "Section ID": "edge_current_flow_betweenness_partition",
        "Description": [
            "Partition created by removing the highest edge current flow betweenness edge.",
            "This algorithm works by calculating the edge current flow\nbetweenness for all edges and removing the edge with the\nhighest value. It is then determined whether the graph has\nbeen broken into at least number_of_sets connected\ncomponents. If not the process is repeated."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph, DiGraph or MultiGraph": "Graph to be partitioned",
                "number_of_sets : int": "Number of sets in the desired partition of the graph",
                "weight : key, optional (default=None)": "The edge attribute key to use as weights for\nedge current flow betweenness calculations"
            },
            "Returns:": {
                "C : list of sets": "Partition of G"
            },
            "Raises:": {
                "NetworkXError": "If number_of_sets is <= 0 or number_of_sets > len(G)"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm is extremely slow, as the recalculation of the edge\ncurrent flow betweenness is extremely slow.",
            "References": "[1]Santo Fortunato \u2018Community Detection in Graphs\u2019 Physical Reports\nVolume 486, Issue 3-5 p. 75-174http://arxiv.org/abs/0906.0612",
            "Examples": "G=nx.karate_club_graph()\npart=nx.community.edge_current_flow_betweenness_partition(G,2)\n{0,1,2,3,4,5,6,7,9,10,11,12,13,16,17,19,21}inpart\n# True\n{8,14,15,18,20,22,23,24,25,26,27,28,29,30,31,32,33}inpart\n# True"
        }
    },
    {
        "Section ID": "connected_caveman_graph",
        "Description": [
            "Returns a connected caveman graph of l cliques of size k .",
            "The connected caveman graph is formed by creating n cliques of size k , then a single edge in each clique is rewired to a node in an\nadjacent clique."
        ],
        "Field List": {
            "Parameters:": {
                "l : int": "number of cliques",
                "k : int": "size of cliques (k at least 2 or NetworkXError is raised)"
            },
            "Returns:": {
                "G : NetworkX Graph": "connected caveman graph"
            },
            "Raises:": {
                "NetworkXError": "If the size of cliqueskis smaller than 2."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This returns an undirected graph, it can be converted to a directed\ngraph using nx.to_directed() , or a multigraph using nx.MultiGraph(nx.caveman_graph(l,k)) . Only the undirected version is\ndescribed in [1] and it is unclear which of the directed\ngeneralizations is most useful.",
            "References": "[1]Watts, D. J. \u2018Networks, Dynamics, and the Small-World Phenomenon.\u2019\nAmer. J. Soc. 105, 493-527, 1999.",
            "Examples": "G=nx.connected_caveman_graph(3,3)"
        }
    },
    {
        "Section ID": "single_source_shortest_path",
        "Description": [
            "Compute shortest path between source\nand all other nodes reachable from source."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node label": "Starting node for path",
                "cutoff : integer, optional": "Depth to stop the search. Only paths of length <= cutoff are returned."
            },
            "Returns:": {
                "paths : dictionary": "Dictionary, keyed by target, of shortest paths."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The shortest path is not necessarily unique. So there can be multiple\npaths between the source and each target node, all of which have the\nsame \u2018shortest\u2019 length. For each target node, this function returns\nonly one of those paths.",
            "Examples": "G=nx.path_graph(5)\npath=nx.single_source_shortest_path(G,0)\npath[4]\n# [0, 1, 2, 3, 4]"
        }
    },
    {
        "Section ID": "to_numpy_array",
        "Description": [
            "Returns the graph adjacency matrix as a NumPy array."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "The NetworkX graph used to construct the NumPy array.",
                "nodelist : list, optional": "The rows and columns are ordered according to the nodes innodelist.\nIfnodelistisNone, then the ordering is produced byG.nodes().",
                "dtype : NumPy data type, optional": "A NumPy data type used to initialize the array. If None, then the NumPy\ndefault is used. The dtype can be structured ifweight=None, in which\ncase the dtype field names are used to look up edge attributes. The\nresult is a structured array where each named field in the dtype\ncorresponds to the adjacency for that edge attribute. See examples for\ndetails.",
                "order : {\u2018C\u2019, \u2018F\u2019}, optional": "Whether to store multidimensional data in C- or Fortran-contiguous\n(row- or column-wise) order in memory. If None, then the NumPy default\nis used.",
                "multigraph_weight : callable, optional": "An function that determines how weights in multigraphs are handled.\nThe function should accept a sequence of weights and return a single\nvalue. The default is to sum the weights of the multiple edges.",
                "weight : string or None optional (default = \u2018weight\u2019)": "The edge attribute that holds the numerical value used for\nthe edge weight. If an edge does not have that attribute, then the\nvalue 1 is used instead.weightmust beNoneif a structured\ndtype is used.",
                "nonedge : array_like (default = 0.0)": "The value used to represent non-edges in the adjacency matrix.\nThe array values corresponding to nonedges are typically set to zero.\nHowever, this could be undesirable if there are array values\ncorresponding to actual edges that also have the value zero. If so,\none might prefer nonedges to have some other value, such asnan."
            },
            "Returns:": {
                "A : NumPy ndarray": "Graph adjacency matrix"
            },
            "Raises:": {
                "NetworkXError": "Ifdtypeis a structured dtype andGis a multigraph",
                "ValueError": "Ifdtypeis a structured dtype andweightis notNone"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For directed graphs, entry i,j corresponds to an edge from i to j . Entries in the adjacency matrix are given by the weight edge attribute.\nWhen an edge does not have a weight attribute, the value of the entry is\nset to the number 1.  For multiple (parallel) edges, the values of the\nentries are determined by the multigraph_weight parameter. The default is\nto sum the weight attributes for each of the parallel edges. When nodelist does not contain every node in G , the adjacency matrix is\nbuilt from the subgraph of G that is induced by the nodes in nodelist . The convention used for self-loop edges in graphs is to assign the\ndiagonal array entry value to the weight attribute of the edge\n(or the number 1 if the edge has no weight attribute). If the\nalternate convention of doubling the edge weight is desired the\nresulting NumPy array can be modified as follows:",
            "Examples": "G=nx.MultiDiGraph()\nG.add_edge(0,1,weight=2)\n# 0\nG.add_edge(1,0)\n# 0\nG.add_edge(2,2,weight=3)\n# 0\nG.add_edge(2,2)\n# 1\nnx.to_numpy_array(G,nodelist=[0,1,2])\n# array([[0., 2., 0.],\n#        [1., 0., 0.],\n#        [0., 0., 4.]])\nWhennodelistargument is used, nodes ofGwhich do not appear in thenodelistand their edges are not included in the adjacency matrix. Here is an example:\nG=nx.Graph()\nG.add_edge(3,1)\nG.add_edge(2,0)\nG.add_edge(2,1)\nG.add_edge(3,0)\nnx.to_numpy_array(G,nodelist=[1,2,3])\n# array([[0., 1., 1.],\n#        [1., 0., 0.],\n#        [1., 0., 0.]])\nThis function can also be used to create adjacency matrices for multiple\nedge attributes with structured dtypes:\nG=nx.Graph()\nG.add_edge(0,1,weight=10)\nG.add_edge(1,2,cost=5)\nG.add_edge(2,3,weight=3,cost=-4.0)\ndtype=np.dtype([(\"weight\",int),(\"cost\",float)])\nA=nx.to_numpy_array(G,dtype=dtype,weight=None)\nA[\"weight\"]\n# array([[ 0, 10,  0,  0],\n#        [10,  0,  1,  0],\n#        [ 0,  1,  0,  3],\n#        [ 0,  0,  3,  0]])\nA[\"cost\"]\n# array([[ 0.,  1.,  0.,  0.],\n#        [ 1.,  0.,  5.,  0.],\n#        [ 0.,  5.,  0., -4.],\n#        [ 0.,  0., -4.,  0.]])\nAs stated above, the argument \u201cnonedge\u201d is useful especially when there are\nactually edges with weight 0 in the graph. Setting a nonedge value different than 0,\nmakes it much clearer to differentiate such 0-weighted edges and actual nonedge values.\nG=nx.Graph()\nG.add_edge(3,1,weight=2)\nG.add_edge(2,0,weight=0)\nG.add_edge(2,1,weight=0)\nG.add_edge(3,0,weight=1)\nnx.to_numpy_array(G,nonedge=-1.0)\n# array([[-1.,  2., -1.,  1.],\n#        [ 2., -1.,  0., -1.],\n#        [-1.,  0., -1.,  0.],\n#        [ 1., -1.,  0., -1.]])"
        }
    },
    {
        "Section ID": "write_adjlist",
        "Description": [
            "Write graph G in single-line adjacency-list format to path."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "path : string or file": "Filename or file handle for data output.\nFilenames ending in .gz or .bz2 will be compressed.",
                "comments : string, optional": "Marker for comment lines",
                "delimiter : string, optional": "Separator for node labels",
                "encoding : string, optional": "Text encoding."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The default delimiter=\"\" will result in unexpected results if node names contain\nwhitespace characters. To avoid this problem, specify an alternate delimiter when spaces are\nvalid in node names.\nNB: This option is not available for data that isn\u2019t user-generated. This format does not store graph, node, or edge data.",
            "Examples": "G=nx.path_graph(4)\nnx.write_adjlist(G,\"test.adjlist\")\nThe path can be a filehandle or a string with the name of the file. If a\nfilehandle is provided, it has to be opened in \u2018wb\u2019 mode.\nfh=open(\"test.adjlist\",\"wb\")\nnx.write_adjlist(G,fh)"
        }
    },
    {
        "Section ID": "make_list_of_ints",
        "Description": [
            "Return list of ints from sequence of integral numbers.",
            "All elements of the sequence must satisfy int(element) == element\nor a ValueError is raised. Sequence is iterated through once.",
            "If sequence is a list, the non-int values are replaced with ints.\nSo, no new list is created"
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "triangular_lattice_graph",
        "Description": [
            "Returns the \\(m\\) by \\(n\\) triangular lattice graph.",
            "The triangular lattice graph is a two-dimensional grid graph in\nwhich each square unit has a diagonal edge (each grid unit has a chord).",
            "The returned graph has \\(m\\) rows and \\(n\\) columns of triangles. Rows and\ncolumns include both triangles pointing up and down. Rows form a strip\nof constant height. Columns form a series of diamond shapes, staggered\nwith the columns on either side. Another way to state the size is that\nthe nodes form a grid of m+1 rows and (n+1)//2 columns.\nThe odd row nodes are shifted horizontally relative to the even rows.",
            "Directed graph types have edges pointed up or right.",
            "Positions of nodes are computed by default or with_positionsisTrue .\nThe position of each node (embedded in a euclidean plane) is stored in\nthe graph using equilateral triangles with sidelength 1.\nThe height between rows of nodes is thus \\(\\sqrt(3)/2\\) .\nNodes lie in the first quadrant with the node \\((0, 0)\\) at the origin."
        ],
        "Field List": {
            "Parameters:": {
                "m : int": "The number of rows in the lattice.",
                "n : int": "The number of columns in the lattice.",
                "periodic : bool (default: False)": "If True, join the boundary vertices of the grid using periodic\nboundary conditions. The join between boundaries is the final row\nand column of triangles. This means there is one row and one column\nfewer nodes for the periodic lattice. Periodic lattices requirem>=3,n>=5and are allowed but misaligned ifmornare odd",
                "with_positions : bool (default: True)": "Store the coordinates of each node in the graph node attribute \u2018pos\u2019.\nThe coordinates provide a lattice with equilateral triangles.\nPeriodic positions shift the nodes vertically in a nonlinear way so\nthe edges don\u2019t overlap so much.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "NetworkX graph": "Thembyntriangular lattice graph."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "random_partition_graph",
        "Description": [
            "Returns the random partition graph with a partition of sizes.",
            "A partition graph is a graph of communities with sizes defined by\ns in sizes. Nodes in the same group are connected with probability\np_in and nodes of different groups are connected with probability\np_out."
        ],
        "Field List": {
            "Parameters:": {
                "sizes : list of ints": "Sizes of groups",
                "p_in : float": "probability of edges with in groups",
                "p_out : float": "probability of edges between groups",
                "directed : boolean optional, default=False": "Whether to create a directed graph",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "G : NetworkX Graph or DiGraph": "random partition graph of size sum(gs)"
            },
            "Raises:": {
                "NetworkXError": "If p_in or p_out is not in [0,1]"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This is a generalization of the planted-l-partition described in [1] .  It allows for the creation of groups of any size. The partition is store as a graph attribute \u2018partition\u2019.",
            "References": "[1]Santo Fortunato \u2018Community Detection in Graphs\u2019 Physical Reports\nVolume 486, Issue 3-5 p. 75-174.https://arxiv.org/abs/0906.0612",
            "Examples": "G=nx.random_partition_graph([10,10,10],0.25,0.01)\nlen(G)\n# 30\npartition=G.graph[\"partition\"]\nlen(partition)\n# 3"
        }
    },
    {
        "Section ID": "edge_boundary",
        "Description": [
            "Returns the edge boundary of nbunch1 .",
            "The edge boundary of a set S with respect to a set T is the\nset of edges ( u , v ) such that u is in S and v is in T .\nIf T is not specified, it is assumed to be the set of all nodes\nnot in S ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "nbunch1 : iterable": "Iterable of nodes in the graph representing the set of nodes\nwhose edge boundary will be returned. (This is the setSfrom\nthe definition above.)",
                "nbunch2 : iterable": "Iterable of nodes representing the target (or \u201cexterior\u201d) set of\nnodes. (This is the setTfrom the definition above.) If not\nspecified, this is assumed to be the set of all nodes inGnot innbunch1.",
                "keys : bool": "This parameter has the same meaning as inMultiGraph.edges().",
                "data : bool or object": "This parameter has the same meaning as inMultiGraph.edges().",
                "default : object": "This parameter has the same meaning as inMultiGraph.edges()."
            },
            "Returns:": {
                "iterator": "An iterator over the edges in the boundary ofnbunch1with\nrespect tonbunch2. Ifkeys,data, ordefaultare specified andGis a multigraph, then edges are returned\nwith keys and/or data, as inMultiGraph.edges()."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Any element of nbunch that is not in the graph G will be\nignored. nbunch1 and nbunch2 are usually meant to be disjoint, but in\nthe interest of speed and generality, that is not required here.",
            "Examples": "G=nx.wheel_graph(6)\nWhen nbunch2=None:\nlist(nx.edge_boundary(G,(1,3)))\n# [(1, 0), (1, 2), (1, 5), (3, 0), (3, 2), (3, 4)]\nWhen nbunch2 is given:\nlist(nx.edge_boundary(G,(1,3),(2,0)))\n# [(1, 0), (1, 2), (3, 0), (3, 2)]"
        }
    },
    {
        "Section ID": "read_edgelist",
        "Description": [
            "Read a bipartite graph from a list of edges."
        ],
        "Field List": {
            "Parameters:": {
                "path : file or string": "File or filename to read. If a file is provided, it must be\nopened in \u2018rb\u2019 mode.\nFilenames ending in .gz or .bz2 will be uncompressed.",
                "comments : string, optional": "The character used to indicate the start of a comment.",
                "delimiter : string, optional": "The string used to separate values.  The default is whitespace.",
                "create_using : Graph container, optional,": "Use specified container to build graph.  The default is networkx.Graph,\nan undirected graph.",
                "nodetype : int, float, str, Python type, optional": "Convert node data from strings to specified type",
                "data : bool or list of (label,type) tuples": "Tuples specifying dictionary key names and types for edge data",
                "edgetype : int, float, str, Python type, optional OBSOLETE": "Convert edge data from strings to specified type and use as \u2018weight\u2019",
                "encoding: string, optional": "Specify which encoding to use when reading file."
            },
            "Returns:": {
                "G : graph": "A networkx Graph or other type specified with create_using"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Since nodes must be hashable, the function nodetype must return hashable\ntypes (e.g. int, float, str, frozenset - or tuples of those, etc.)",
            "Examples": "fromnetworkx.algorithmsimportbipartite\nG=nx.path_graph(4)\nG.add_nodes_from([0,2],bipartite=0)\nG.add_nodes_from([1,3],bipartite=1)\nbipartite.write_edgelist(G,\"test.edgelist\")\nG=bipartite.read_edgelist(\"test.edgelist\")\nfh=open(\"test.edgelist\",\"rb\")\nG=bipartite.read_edgelist(fh)\nfh.close()\nG=bipartite.read_edgelist(\"test.edgelist\",nodetype=int)\nEdgelist with data in a list:\ntextline=\"1 2 3\"\nfh=open(\"test.edgelist\",\"w\")\nd=fh.write(textline)\nfh.close()\nG=bipartite.read_edgelist(\n\"test.edgelist\",nodetype=int,data=((\"weight\",float),)\n)\nlist(G)\n# [1, 2]\nlist(G.edges(data=True))\n# [(1, 2, {'weight': 3.0})]\nSee parse_edgelist() for more examples of formatting."
        }
    },
    {
        "Section ID": "random_labeled_rooted_forest",
        "Description": [
            "Returns a labeled rooted forest with n nodes.",
            "The returned forest is chosen uniformly at random using a\ngeneralization of Pr\u00fcfer sequences [1] in the form described in [2] ."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes.",
                "seed : random_state": "SeeRandomness."
            },
            "Returns:": {
                "networkx.Graph": "Anetworkx.Graphwith integer nodes 0 <= node <=n- 1.\nThe \u201croots\u201d graph attribute is a set of integers containing the roots."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Knuth, Donald E. \u201cAnother Enumeration of Trees.\u201d\nCanadian Journal of Mathematics, 20 (1968): 1077-1086.https://doi.org/10.4153/CJM-1968-104-8  [2]Rubey, Martin. \u201cCounting Spanning Trees\u201d. Diplomarbeit\nzur Erlangung des akademischen Grades Magister der\nNaturwissenschaften an der Formal- und Naturwissenschaftlichen\nFakult\u00e4t der Universit\u00e4t Wien. Wien, May 2000."
        }
    },
    {
        "Section ID": "omega",
        "Description": [
            "Returns the small-world coefficient (omega) of a graph",
            "The small-world coefficient of a graph G is:",
            "omega = Lr/L - C/Cl",
            "where C and L are respectively the average clustering coefficient and\naverage shortest path length of G. Lr is the average shortest path length\nof an equivalent random graph and Cl is the average clustering coefficient\nof an equivalent lattice graph.",
            "The small-world coefficient (omega) measures how much G is like a lattice\nor a random graph. Negative values mean G is similar to a lattice whereas\npositive values mean G is a random graph.\nValues close to 0 mean that G has small-world characteristics."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "An undirected graph.",
                "niter: integer (optional, default=5)": "Approximate number of rewiring per edge to compute the equivalent\nrandom graph.",
                "nrand: integer (optional, default=10)": "Number of random graphs generated to compute the maximal clustering\ncoefficient (Cr) and average shortest path length (Lr).",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "omega : float": "The small-world coefficient (omega)"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The implementation is adapted from the algorithm by Telesford et al. [1] .",
            "References": "[1]Telesford, Joyce, Hayasaka, Burdette, and Laurienti (2011).\n\u201cThe Ubiquity of Small-World Networks\u201d.\nBrain Connectivity. 1 (0038): 367-75.  PMC 3604768. PMID 22432451.\ndoi:10.1089/brain.2011.0038."
        }
    },
    {
        "Section ID": "minimum_spanning_tree",
        "Description": [
            "Returns a minimum spanning tree or forest on an undirected graph G ."
        ],
        "Field List": {
            "Parameters:": {
                "G : undirected graph": "An undirected graph. IfGis connected, then the algorithm finds a\nspanning tree. Otherwise, a spanning forest is found.",
                "weight : str": "Data key to use for edge weights.",
                "algorithm : string": "The algorithm to use when finding a minimum spanning tree. Valid\nchoices are \u2018kruskal\u2019, \u2018prim\u2019, or \u2018boruvka\u2019. The default is\n\u2018kruskal\u2019.",
                "ignore_nan : bool (default: False)": "If a NaN is found as an edge weight normally an exception is raised.\nIfignore_nanisTruethen that edge is ignored instead."
            },
            "Returns:": {
                "G : NetworkX Graph": "A minimum spanning tree or forest."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For Bor\u016fvka\u2019s algorithm, each edge must have a weight attribute, and\neach edge weight must be distinct. For the other algorithms, if the graph edges do not have a weight\nattribute a default weight of 1 will be used. There may be more than one tree with the same minimum or maximum weight.\nSee networkx.tree.recognition for more detailed definitions. Isolated nodes with self-loops are in the tree as edgeless isolated nodes.",
            "Examples": "G=nx.cycle_graph(4)\nG.add_edge(0,3,weight=2)\nT=nx.minimum_spanning_tree(G)\nsorted(T.edges(data=True))\n# [(0, 1, {}), (1, 2, {}), (2, 3, {})]"
        }
    },
    {
        "Section ID": "is_forest",
        "Description": [
            "Returns True if G is a forest.",
            "A forest is a graph with no undirected cycles.",
            "For directed graphs, G is a forest if the underlying graph is a forest.\nThe underlying graph is obtained by treating each directed edge as a single\nundirected edge in a multigraph."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "The graph to test."
            },
            "Returns:": {
                "b : bool": "A boolean that is True ifGis a forest."
            },
            "Raises:": {
                "NetworkXPointlessConcept": "IfGis empty."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "In another convention, a directed forest is known as a polyforest and\nthen forest corresponds to a branching .",
            "Examples": "G=nx.Graph()\nG.add_edges_from([(1,2),(1,3),(2,4),(2,5)])\nnx.is_forest(G)\n# True\nG.add_edge(4,1)\nnx.is_forest(G)\n# False"
        }
    },
    {
        "Section ID": "group_closeness_centrality",
        "Description": [
            "Compute the group closeness centrality for a group of nodes.",
            "Group closeness centrality of a group of nodes \\(S\\) is a measure\nof how close the group is to the other nodes in the graph.",
            "where \\(V\\) is the set of nodes, \\(d_{S, v}\\) is the distance of\nthe group \\(S\\) from \\(v\\) defined as above. ( \\(V-S\\) is the set of nodes\nin \\(V\\) that are not in \\(S\\) )."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.",
                "S : list or set": "S is a group of nodes which belong to G, for which group closeness\ncentrality is to be calculated.",
                "weight : None or string, optional (default=None)": "If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight.\nThe weight of an edge is treated as the length or distance between the two sides."
            },
            "Returns:": {
                "closeness : float": "Group closeness centrality of the group S."
            },
            "Raises:": {
                "NodeNotFound": "If node(s) in S are not present in G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The measure was introduced in [1] .\nThe formula implemented here is described in [2] . Higher values of closeness indicate greater centrality. It is assumed that 1 / 0 is 0 (required in the case of directed graphs,\nor when a shortest path length is 0). The number of nodes in the group must be a maximum of n - 1 where n is the total number of nodes in the graph. For directed graphs, the incoming distance is utilized here. To use the\noutward distance, act on G.reverse() . For weighted graphs the edge weights must be greater than zero.\nZero edge weights can produce an infinite number of equal length\npaths between pairs of nodes.",
            "References": "[1]M G Everett and S P Borgatti:\nThe Centrality of Groups and Classes.\nJournal of Mathematical Sociology. 23(3): 181-201. 1999.http://www.analytictech.com/borgatti/group_centrality.htm  [2]J. Zhao et. al.:\nMeasuring and Maximizing Group Closeness Centrality over\nDisk Resident Graphs.\nWWWConference Proceedings, 2014. 689-694.https://doi.org/10.1145/2567948.2579356"
        }
    },
    {
        "Section ID": "volume",
        "Description": [
            "Returns the volume of a set of nodes.",
            "The volume of a set S is the sum of the (out-)degrees of nodes\nin S (taking into account parallel edges in multigraphs). [1]"
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "S : collection": "A collection of nodes inG.",
                "weight : object": "Edge attribute key to use as weight. If not specified, edges\nhave weight one."
            },
            "Returns:": {
                "number": "The volume of the set of nodes represented bySin the graphG."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]David Gleich.Hierarchical Directed Spectral Graph Partitioning.\n<https://www.cs.purdue.edu/homes/dgleich/publications/Gleich%202005%20-%20hierarchical%20directed%20spectral.pdf>"
        }
    },
    {
        "Section ID": "harmonic_centrality",
        "Description": [
            "Compute harmonic centrality for nodes.",
            "Harmonic centrality [1] of a node u is the sum of the reciprocal\nof the shortest path distances from all other nodes to u",
            "where d(v,u) is the shortest-path distance between v and u .",
            "If sources is given as an argument, the returned harmonic centrality\nvalues are calculated as the sum of the reciprocals of the shortest\npath distances from the nodes specified in sources to u instead\nof from all nodes to u .",
            "Notice that higher values indicate higher centrality."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "nbunch : container (default: all nodes in G)": "Container of nodes for which harmonic centrality values are calculated.",
                "sources : container (default: all nodes in G)": "Container of nodesvover which reciprocal distances are computed.\nNodes not inGare silently ignored.",
                "distance : edge attribute key, optional (default=None)": "Use the specified edge attribute as the edge distance in shortest\npath calculations.  IfNone, then each edge will have distance equal to 1."
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of nodes with harmonic centrality as the value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "If the \u2018distance\u2019 keyword is set to an edge attribute key then the\nshortest-path length will be computed using Dijkstra\u2019s algorithm with\nthat edge attribute as the edge weight.",
            "References": "[1]Boldi, Paolo, and Sebastiano Vigna. \u201cAxioms for centrality.\u201d\nInternet Mathematics 10.3-4 (2014): 222-262."
        }
    },
    {
        "Section ID": "pygraphviz_layout",
        "Description": [
            "Create node positions for G using Graphviz."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A graph created with NetworkX",
                "prog : string": "Name of Graphviz layout program",
                "root : string, optional": "Root node for twopi layout",
                "args : string, optional": "Extra arguments to Graphviz layout program"
            },
            "Returns:": {
                "node_pos : dict": "Dictionary of x, y, positions keyed by node."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "If you use complex node objects, they may have the same string\nrepresentation and GraphViz could treat them as the same node.\nThe layout may assign both nodes a single location. See Issue #1568\nIf this occurs in your case, consider relabeling the nodes just\nfor the layout computation using something similar to:",
            "Examples": "G=nx.petersen_graph()\npos=nx.nx_agraph.graphviz_layout(G)\npos=nx.nx_agraph.graphviz_layout(G,prog=\"dot\")"
        }
    },
    {
        "Section ID": "average_clustering",
        "Description": [
            "Estimates the average clustering coefficient of G.",
            "The local clustering of each node in G is the fraction of triangles\nthat actually exist over all possible triangles in its neighborhood.\nThe average clustering coefficient of a graph G is the mean of\nlocal clusterings.",
            "This function finds an approximate average clustering coefficient\nfor G by repeating n times (defined in trials ) the following\nexperiment: choose a node at random, choose two of its neighbors\nat random, and check if they are connected. The approximate\ncoefficient is the fraction of triangles found over the number\nof trials [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "trials : integer": "Number of trials to perform (default 1000).",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "c : float": "Approximated average clustering coefficient."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is directed."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Schank, Thomas, and Dorothea Wagner. Approximating clustering\ncoefficient and transitivity. Universit\u00e4t Karlsruhe, Fakult\u00e4t f\u00fcr\nInformatik, 2004.https://doi.org/10.5445/IR/1000001239",
            "Examples": "fromnetworkx.algorithmsimportapproximation\nG=nx.erdos_renyi_graph(10,0.2,seed=10)\napproximation.average_clustering(G,trials=1000,seed=10)\n# 0.214"
        }
    },
    {
        "Section ID": "circulant_graph",
        "Description": [
            "Returns the circulant graph \\(Ci_n(x_1, x_2, ..., x_m)\\) with \\(n\\) nodes.",
            "The circulant graph \\(Ci_n(x_1, ..., x_m)\\) consists of \\(n\\) nodes \\(0, ..., n-1\\) such that node \\(i\\) is connected to nodes \\((i + x) \\mod n\\) and \\((i - x) \\mod n\\) for all \\(x\\) in \\(x_1, ..., x_m\\) . Thus \\(Ci_n(1)\\) is a cycle graph.",
            "( Sourcecode , png )"
        ],
        "Field List": {
            "Parameters:": {
                "n : integer": "The number of nodes in the graph.",
                "offsets : list of integers": "A list of node offsets,\\(x_1\\)up to\\(x_m\\), as described above.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "NetworkX Graph of type create_using": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "Many well-known graph families are subfamilies of the circulant graphs;\nfor example, to create the cycle graph on n points, we connect every\nnode to nodes on either side (with offset plus or minus one). For n = 10,\nG=nx.circulant_graph(10,[1])\nedges=[\n(0,9),\n(0,1),\n(1,2),\n(2,3),\n(3,4),\n(4,5),\n(5,6),\n(6,7),\n(7,8),\n(8,9),\n]\nsorted(edges)==sorted(G.edges())\n# True\nSimilarly, we can create the complete graph\non 5 points with the set of offsets [1, 2]:\nG=nx.circulant_graph(5,[1,2])\nedges=[\n(0,1),\n(0,2),\n(0,3),\n(0,4),\n(1,2),\n(1,3),\n(1,4),\n(2,3),\n(2,4),\n(3,4),\n]\nsorted(edges)==sorted(G.edges())\n# True"
        }
    },
    {
        "Section ID": "strategy_saturation_largest_first",
        "Description": [
            "Iterates over all the nodes of G in \u201csaturation order\u201d (also\nknown as \u201cDSATUR\u201d).",
            "G is a NetworkX graph. colors is a dictionary mapping nodes of G to colors, for those nodes that have already been colored."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "parse_leda",
        "Description": [
            "Read graph in LEDA format from string or iterable."
        ],
        "Field List": {
            "Parameters:": {
                "lines : string or iterable": "Data in LEDA format."
            },
            "Returns:": {
                "G : NetworkX graph": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]http://www.algorithmic-solutions.info/leda_guide/graphs/leda_native_graph_fileformat.html",
            "Examples": "G=nx.parse_leda(string)"
        }
    },
    {
        "Section ID": "draw_networkx_nodes",
        "Description": [
            "Draw the nodes of the graph G.",
            "This draws only the nodes of the graph G."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph",
                "pos : dictionary": "A dictionary with nodes as keys and positions as values.\nPositions should be sequences of length 2.",
                "ax : Matplotlib Axes object, optional": "Draw the graph in the specified Matplotlib axes.",
                "nodelist : list (default list(G))": "Draw only specified nodes",
                "node_size : scalar or array (default=300)": "Size of nodes.  If an array it must be the same length as nodelist.",
                "node_color : color or array of colors (default=\u2019#1f78b4\u2019)": "Node color. Can be a single color or a sequence of colors with the same\nlength as nodelist. Color can be string or rgb (or rgba) tuple of\nfloats from 0-1. If numeric values are specified they will be\nmapped to colors using the cmap and vmin,vmax parameters. See\nmatplotlib.scatter for more details.",
                "node_shape : string (default=\u2019o\u2019)": "The shape of the node.  Specification is as matplotlib.scatter\nmarker, one of \u2018so^>v<dph8\u2019.",
                "alpha : float or array of floats (default=None)": "The node transparency.  This can be a single alpha value,\nin which case it will be applied to all the nodes of color. Otherwise,\nif it is an array, the elements of alpha will be applied to the colors\nin order (cycling through alpha multiple times if necessary).",
                "cmap : Matplotlib colormap (default=None)": "Colormap for mapping intensities of nodes",
                "vmin,vmax : floats or None (default=None)": "Minimum and maximum for node colormap scaling",
                "linewidths : [None | scalar | sequence] (default=1.0)": "Line width of symbol border",
                "edgecolors : [None | scalar | sequence] (default = node_color)": "Colors of node borders. Can be a single color or a sequence of colors with the\nsame length as nodelist. Color can be string or rgb (or rgba) tuple of floats\nfrom 0-1. If numeric values are specified they will be mapped to colors\nusing the cmap and vmin,vmax parameters. Seescatterfor more details.",
                "label : [None | string]": "Label for legend",
                "margins : float or 2-tuple, optional": "Sets the padding for axis autoscaling. Increase margin to prevent\nclipping for nodes that are near the edges of an image. Values should\nbe in the range[0,1]. Seematplotlib.axes.Axes.margins()for details. The default isNone, which uses the Matplotlib default.",
                "hide_ticks : bool, optional": "Hide ticks of axes. WhenTrue(the default), ticks and ticklabels\nare removed from the axes. To set ticks and tick labels to the pyplot default,\nusehide_ticks=False."
            },
            "Returns:": {
                "matplotlib.collections.PathCollection": "PathCollectionof the nodes."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.dodecahedral_graph()\nnodes=nx.draw_networkx_nodes(G,pos=nx.spring_layout(G))\nAlso see the NetworkX drawing examples athttps://networkx.org/documentation/latest/auto_examples/index.html"
        }
    },
    {
        "Section ID": "is_semieulerian",
        "Description": [
            "Return True iff G is semi-Eulerian.",
            "G is semi-Eulerian if it has an Eulerian path but no Eulerian circuit."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "equitable_color",
        "Description": [
            "Provides an equitable coloring for nodes of G .",
            "Attempts to color a graph using num_colors colors, where no neighbors of\na node can have same color as the node itself and the number of nodes with\neach color differ by at most 1. num_colors must be greater than the\nmaximum degree of G . The algorithm is described in [1] and has\ncomplexity O(num_colors * n**2)."
        ],
        "Field List": {
            "Parameters:": {
                "G : networkX graph": "The nodes of this graph will be colored.",
                "num_colors : number of colors to use": "This number must be at least one more than the maximum degree of nodes\nin the graph."
            },
            "Returns:": {
                "A dictionary with keys representing nodes and values representing": "",
                "corresponding coloring.": ""
            },
            "Raises:": {
                "NetworkXAlgorithmError": "Ifnum_colorsis not at least the maximum degree of the graphG"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Kierstead, H. A., Kostochka, A. V., Mydlarz, M., & Szemer\u00e9di, E.\n(2010). A fast algorithm for equitable coloring. Combinatorica, 30(2),\n217-224.",
            "Examples": "G=nx.cycle_graph(4)\nnx.coloring.equitable_color(G,num_colors=3)\n# {0: 2, 1: 1, 2: 2, 3: 0}"
        }
    },
    {
        "Section ID": "parse_adjlist",
        "Description": [
            "Parse lines of a graph adjacency list representation."
        ],
        "Field List": {
            "Parameters:": {
                "lines : list or iterator of strings": "Input data in adjlist format",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated.",
                "nodetype : Python type, optional": "Convert nodes to this type.",
                "comments : string, optional": "Marker for comment lines",
                "delimiter : string, optional": "Separator for node labels.  The default is whitespace."
            },
            "Returns:": {
                "G: NetworkX graph": "The graph corresponding to the lines in adjacency list format."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "lines=[\"1 2 5\",\"2 3 4\",\"3 5\",\"4\",\"5\"]\nG=nx.parse_adjlist(lines,nodetype=int)\nnodes=[1,2,3,4,5]\nall(nodeinGfornodeinnodes)\n# True\nedges=[(1,2),(1,5),(2,3),(2,4),(3,5)]\nall((u,v)inG.edges()or(v,u)inG.edges()for(u,v)inedges)\n# True"
        }
    },
    {
        "Section ID": "connected_watts_strogatz_graph",
        "Description": [
            "Returns a connected Watts\u2013Strogatz small-world graph.",
            "Attempts to generate a connected graph by repeated generation of\nWatts\u2013Strogatz small-world graphs.  An exception is raised if the maximum\nnumber of tries is exceeded."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes",
                "k : int": "Each node is joined with itsknearest neighbors in a ring\ntopology.",
                "p : float": "The probability of rewiring each edge",
                "tries : int": "Number of attempts to generate a connected graph.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "First create a ring over \\(n\\) nodes [1] .  Then each node in the ring is joined\nto its \\(k\\) nearest neighbors (or \\(k - 1\\) neighbors if \\(k\\) is odd).\nThen shortcuts are created by replacing some edges as follows: for each\nedge \\((u, v)\\) in the underlying \u201c \\(n\\) -ring with \\(k\\) nearest neighbors\u201d\nwith probability \\(p\\) replace it with a new edge \\((u, w)\\) with uniformly\nrandom choice of existing node \\(w\\) .\nThe entire process is repeated until a connected graph results.",
            "References": "[1]Duncan J. Watts and Steven H. Strogatz,\nCollective dynamics of small-world networks,\nNature, 393, pp. 440\u2013442, 1998."
        }
    },
    {
        "Section ID": "intersection_all",
        "Description": [
            "Returns a new graph that contains only the nodes and the edges that exist in\nall graphs."
        ],
        "Field List": {
            "Parameters:": {
                "graphs : iterable": "Iterable of NetworkX graphs"
            },
            "Returns:": {
                "R : A new graph with the same type as the first graph in list": ""
            },
            "Raises:": {
                "ValueError": "Ifgraphsis an empty list.",
                "NetworkXError": "In case of mixed type graphs, like MultiGraph and Graph, or directed and undirected graphs."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For operating on mixed type graphs, they should be converted to the same type. Attributes from the graph, nodes, and edges are not copied to the new\ngraph. The resulting graph can be updated with attributes if desired. For example, code which adds the minimum attribute for each node across all graphs could work.\n>>> g = nx.Graph()\n>>> g.add_node(0, capacity=4)\n>>> g.add_node(1, capacity=3)\n>>> g.add_edge(0, 1)",
            "Examples": "G1=nx.Graph([(1,2),(2,3)])\nG2=nx.Graph([(2,3),(3,4)])\nR=nx.intersection_all([G1,G2])\nlist(R.nodes())\n# [2, 3]\nlist(R.edges())\n# [(2, 3)]"
        }
    },
    {
        "Section ID": "conductance",
        "Description": [
            "Returns the conductance of two sets of nodes.",
            "The conductance is the quotient of the cut size and the smaller of\nthe volumes of the two sets. [1]"
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "S : collection": "A collection of nodes inG.",
                "T : collection": "A collection of nodes inG.",
                "weight : object": "Edge attribute key to use as weight. If not specified, edges\nhave weight one."
            },
            "Returns:": {
                "number": "The conductance between the two setsSandT."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]David Gleich.Hierarchical Directed Spectral Graph Partitioning.\n<https://www.cs.purdue.edu/homes/dgleich/publications/Gleich%202005%20-%20hierarchical%20directed%20spectral.pdf>"
        }
    },
    {
        "Section ID": "random_triad",
        "Description": [
            "Returns a random triad from a directed graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : digraph": "A NetworkX DiGraph",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "G2 : subgraph": "A randomly selected triad (order-3 NetworkX DiGraph)"
            },
            "Raises:": {
                "NetworkXError": "If the input Graph has less than 3 nodes."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.DiGraph([(1,2),(1,3),(2,3),(3,1),(5,6),(5,4),(6,7)])\ntriad=nx.random_triad(G,seed=1)\ntriad.edges\n# OutEdgeView([(1, 2)])"
        }
    },
    {
        "Section ID": "local_edge_connectivity",
        "Description": [
            "Returns local edge connectivity for nodes s and t in G.",
            "Local edge connectivity for two nodes s and t is the minimum number\nof edges that must be removed to disconnect them.",
            "This is a flow based implementation of edge connectivity. We compute the\nmaximum flow on an auxiliary digraph build from the original\nnetwork (see below for details). This is equal to the local edge\nconnectivity because the value of a maximum s-t-flow is equal to the\ncapacity of a minimum s-t-cut (Ford and Fulkerson theorem) [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected or directed graph",
                "s : node": "Source node",
                "t : node": "Target node",
                "flow_func : function": "A function for computing the maximum flow among a pair of nodes.\nThe function has to accept at least three parameters: a Digraph,\na source node, and a target node. And return a residual network\nthat follows NetworkX conventions (seemaximum_flow()for\ndetails). If flow_func is None, the default maximum flow function\n(edmonds_karp()) is used. See below for details. The\nchoice of the default function may change from version\nto version and should not be relied on. Default value: None.",
                "auxiliary : NetworkX DiGraph": "Auxiliary digraph for computing flow based edge connectivity. If\nprovided it will be reused instead of recreated. Default value: None.",
                "residual : NetworkX DiGraph": "Residual network to compute maximum flow. If provided it will be\nreused instead of recreated. Default value: None.",
                "cutoff : integer, float, or None (default: None)": "If specified, the maximum flow algorithm will terminate when the\nflow value reaches or exceeds the cutoff. This only works for flows\nthat support the cutoff parameter (most do) and is ignored otherwise."
            },
            "Returns:": {
                "K : integer": "local edge connectivity for nodes s and t."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This is a flow based implementation of edge connectivity. We compute the\nmaximum flow using, by default, the edmonds_karp() algorithm on an\nauxiliary digraph build from the original input graph: If the input graph is undirected, we replace each edge ( u ,`v`) with\ntwo reciprocal arcs ( u , v ) and ( v , u ) and then we set the attribute\n\u2018capacity\u2019 for each arc to 1. If the input graph is directed we simply\nadd the \u2018capacity\u2019 attribute. This is an implementation of algorithm 1\nin [1] . The maximum flow in the auxiliary network is equal to the local edge\nconnectivity because the value of a maximum s-t-flow is equal to the\ncapacity of a minimum s-t-cut (Ford and Fulkerson theorem).",
            "References": "[1](1,2)Abdol-Hossein Esfahanian. Connectivity Algorithms.http://www.cse.msu.edu/~cse835/Papers/Graph_connectivity_revised.pdf",
            "Examples": "This function is not imported in the base NetworkX namespace, so you\nhave to explicitly import it from the connectivity package:\nfromnetworkx.algorithms.connectivityimportlocal_edge_connectivity\nWe use in this example the platonic icosahedral graph, which has edge\nconnectivity 5.\nG=nx.icosahedral_graph()\nlocal_edge_connectivity(G,0,6)\n# 5\nIf you need to compute local connectivity on several pairs of\nnodes in the same graph, it is recommended that you reuse the\ndata structures that NetworkX uses in the computation: the\nauxiliary digraph for edge connectivity, and the residual\nnetwork for the underlying maximum flow computation.\nExample of how to compute local edge connectivity among\nall pairs of nodes of the platonic icosahedral graph reusing\nthe data structures.\nimportitertools\n# You also have to explicitly import the function for\n# building the auxiliary digraph from the connectivity package\nfromnetworkx.algorithms.connectivityimportbuild_auxiliary_edge_connectivity\nH=build_auxiliary_edge_connectivity(G)\n# And the function for building the residual network from the\n# flow package\nfromnetworkx.algorithms.flowimportbuild_residual_network\n# Note that the auxiliary digraph has an edge attribute named capacity\nR=build_residual_network(H,\"capacity\")\nresult=dict.fromkeys(G,dict())\n# Reuse the auxiliary digraph and the residual network by passing them\n# as parameters\nforu,vinitertools.combinations(G,2):\nk=local_edge_connectivity(G,u,v,auxiliary=H,residual=R)\nresult[u][v]=k\nall(result[u][v]==5foru,vinitertools.combinations(G,2))\n# True\nYou can also use alternative flow algorithms for computing edge\nconnectivity. For instance, in dense networks the algorithmshortest_augmenting_path()will usually perform better than\nthe defaultedmonds_karp()which is faster for sparse\nnetworks with highly skewed degree distributions. Alternative flow\nfunctions have to be explicitly imported from the flow package.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\nlocal_edge_connectivity(G,0,6,flow_func=shortest_augmenting_path)\n# 5"
        }
    },
    {
        "Section ID": "snap_aggregation",
        "Description": [
            "Creates a summary graph based on attributes and connectivity.",
            "This function uses the Summarization by Grouping Nodes on Attributes\nand Pairwise edges (SNAP) algorithm for summarizing a given\ngraph by grouping nodes by node attributes and their edge attributes\ninto supernodes in a summary graph.  This name SNAP should not be\nconfused with the Stanford Network Analysis Project (SNAP).",
            "Here is a high-level view of how this algorithm works:",
            "2) Iteratively split groups until all nodes in each group have edges\nto nodes in the same groups. That is, until all the groups are homogeneous\nin their member nodes\u2019 edges to other groups.  For example,\nif all the nodes in group A only have edge to nodes in group B, then the\ngroup is homogeneous and does not need to be split. If all nodes in group B\nhave edges with nodes in groups {A, C}, but some also have edges with other\nnodes in B, then group B is not homogeneous and needs to be split into\ngroups have edges with {A, C} and a group of nodes having\nedges with {A, B, C}.  This way, viewers of the summary graph can\nassume that all nodes in the group have the exact same node attributes and\nthe exact same edges.",
            "3) Build the output summary graph, where the groups are represented by\nsuper-nodes. Edges represent the edges shared between all the nodes in each\nrespective groups.",
            "A SNAP summary graph can be used to visualize graphs that are too large to display\nor visually analyze, or to efficiently identify sets of similar nodes with similar connectivity\npatterns to other sets of similar nodes based on specified node and/or edge attributes in a graph."
        ],
        "Field List": {
            "Parameters:": {
                "G: graph": "Networkx Graph to be summarized",
                "node_attributes: iterable, required": "An iterable of the node attributes used to group nodes in the summarization process. Nodes\nwith the same values for these attributes will be grouped together in the summary graph.",
                "edge_attributes: iterable, optional": "An iterable of the edge attributes considered in the summarization process.  If provided, unique\ncombinations of the attribute values found in the graph are used to\ndetermine the edge types in the graph.  If not provided, all edges\nare considered to be of the same type.",
                "prefix: str": "The prefix used to denote supernodes in the summary graph. Defaults to \u2018Supernode-\u2018.",
                "supernode_attribute: str": "The node attribute for recording the supernode groupings of nodes. Defaults to \u2018group\u2019.",
                "superedge_attribute: str": "The edge attribute for recording the edge types of multiple edges. Defaults to \u2018types\u2019."
            },
            "Returns:": {
                "networkx.Graph: summary graph": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The summary graph produced is called a maximum Attribute-edge\ncompatible (AR-compatible) grouping.  According to [1] , an\nAR-compatible grouping means that all nodes in each group have the same\nexact node attribute values and the same exact edges and\nedge types to one or more nodes in the same groups.  The maximal\nAR-compatible grouping is the grouping with the minimal cardinality. The AR-compatible grouping is the most detailed grouping provided by\nany of the SNAP algorithms.",
            "References": "[1]Y. Tian, R. A. Hankins, and J. M. Patel. Efficient aggregation\nfor graph summarization. In Proc. 2008 ACM-SIGMOD Int. Conf.\nManagement of Data (SIGMOD\u201908), pages 567\u2013580, Vancouver, Canada,\nJune 2008.",
            "Examples": "SNAP aggregation takes a graph and summarizes it in the context of user-provided\nnode and edge attributes such that a viewer can more easily extract and\nanalyze the information represented by the graph\nnodes={\n\"A\":dict(color=\"Red\"),\n\"B\":dict(color=\"Red\"),\n\"C\":dict(color=\"Red\"),\n\"D\":dict(color=\"Red\"),\n\"E\":dict(color=\"Blue\"),\n\"F\":dict(color=\"Blue\"),\n}\nedges=[\n(\"A\",\"E\",\"Strong\"),\n(\"B\",\"F\",\"Strong\"),\n(\"C\",\"E\",\"Weak\"),\n(\"D\",\"F\",\"Weak\"),\n]\nG=nx.Graph()\nfornodeinnodes:\nattributes=nodes[node]\nG.add_node(node,**attributes)\nforsource,target,typeinedges:\nG.add_edge(source,target,type=type)\nnode_attributes=(\"color\",)\nedge_attributes=(\"type\",)\nsummary_graph=nx.snap_aggregation(\nG,node_attributes=node_attributes,edge_attributes=edge_attributes\n)"
        }
    },
    {
        "Section ID": "average_clustering",
        "Description": [
            "Compute the average clustering coefficient for the graph G.",
            "The clustering coefficient for the graph is the average,",
            "where \\(n\\) is the number of nodes in G ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "",
                "nodes : container of nodes, optional (default=all nodes in G)": "Compute average clustering for nodes in this container.",
                "weight : string or None, optional (default=None)": "The edge attribute that holds the numerical value used as a weight.\nIf None, then each edge has weight 1.",
                "count_zeros : bool": "If False include only the nodes with nonzero clustering in the average."
            },
            "Returns:": {
                "avg : float": "Average clustering"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This is a space saving routine; it might be faster\nto use the clustering function to get a list and then take the average. Self loops are ignored.",
            "References": "[1]Generalizations of the clustering coefficient to weighted\ncomplex networks by J. Saram\u00e4ki, M. Kivel\u00e4, J.-P. Onnela,\nK. Kaski, and J. Kert\u00e9sz, Physical Review E, 75 027105 (2007).http://jponnela.com/web_documents/a9.pdf  [2]Marcus Kaiser,  Mean clustering coefficients: the role of isolated\nnodes and leafs on clustering measures for small-world networks.https://arxiv.org/abs/0802.2512",
            "Examples": "G=nx.complete_graph(5)\nprint(nx.average_clustering(G))\n# 1.0"
        }
    },
    {
        "Section ID": "is_connected",
        "Description": [
            "Returns True if the graph is connected, False otherwise."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "An undirected graph."
            },
            "Returns:": {
                "connected : bool": "True if the graph is connected, false otherwise."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is directed."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For undirected graphs only.",
            "Examples": "G=nx.path_graph(4)\nprint(nx.is_connected(G))\n# True"
        }
    },
    {
        "Section ID": "soft_random_geometric_graph",
        "Description": [
            "Returns a soft random geometric graph in the unit cube.",
            "The soft random geometric graph [1] model places n nodes uniformly at\nrandom in the unit cube in dimension dim . Two nodes of distance, dist ,\ncomputed by the p -Minkowski distance metric are joined by an edge with\nprobability p_dist if the computed distance metric value of the nodes\nis at most radius , otherwise they are not joined.",
            "Edges within radius of each other are determined using a KDTree when\nSciPy is available. This reduces the time complexity from \\(O(n^2)\\) to \\(O(n)\\) ."
        ],
        "Field List": {
            "Parameters:": {
                "n : int or iterable": "Number of nodes or iterable of nodes",
                "radius: float": "Distance threshold value",
                "dim : int, optional": "Dimension of graph",
                "pos : dict, optional": "A dictionary keyed by node with node positions as values.",
                "p : float, optional": "Which Minkowski distance metric to use.phas to meet the condition1<=p<=infinity.If this argument is not specified, the\\(L^2\\)metric\n(the Euclidean distance metric), p = 2 is used.This should not be confused with thepof an Erd\u0151s-R\u00e9nyi random\ngraph, which represents probability.",
                "p_dist : function, optional": "A probability density function computing the probability of\nconnecting two nodes that are of distance, dist, computed by the\nMinkowski distance metric. The probability density function,p_dist,\nmust be any function that takes the metric value as input\nand outputs a single probability value between 0-1. The scipy.stats\npackage has many probability distribution functions implemented and\ntools for custom probability distribution definitions [2], and passing\nthe .pdf method of scipy.stats distributions can be used here.  If the\nprobability function,p_dist, is not supplied, the default function\nis an exponential distribution with rate parameter\\(\\lambda=1\\).",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "pos_name : string, default=\u201dpos\u201d": "The name of the node attribute which represents the position\nin 2D coordinates of the node in the returned graph."
            },
            "Returns:": {
                "Graph": "A soft random geometric graph, undirected and without self-loops.\nEach node has a node attribute'pos'that stores the\nposition of that node in Euclidean space as provided by theposkeyword argument or, ifposwas not provided, as\ngenerated by this function."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This uses a k -d tree to build the graph. The pos keyword argument can be used to specify node positions so you\ncan create an arbitrary distribution and domain for positions. For example, to use a 2D Gaussian distribution of node positions with mean\n(0, 0) and standard deviation 2 The scipy.stats package can be used to define the probability distribution\nwith the .pdf method used as p_dist .",
            "References": "[1]Penrose, Mathew D. \u201cConnectivity of soft random geometric graphs.\u201d\nThe Annals of Applied Probability 26.2 (2016): 986-1028.  [2]scipy.stats -https://docs.scipy.org/doc/scipy/reference/tutorial/stats.html",
            "Examples": "Default Graph:\nG = nx.soft_random_geometric_graph(50, 0.2)\nCustom Graph:\nCreate a soft random geometric graph on 100 uniformly distributed nodes\nwhere nodes are joined by an edge with probability computed from an\nexponential distribution with rate parameter\\(\\lambda=1\\)if their\nEuclidean distance is at most 0.2."
        }
    },
    {
        "Section ID": "k_clique_communities",
        "Description": [
            "Find k-clique communities in graph using the percolation method.",
            "A k-clique community is the union of all cliques of size k that\ncan be reached through adjacent (sharing k-1 nodes) k-cliques."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "k : int": "Size of smallest clique",
                "cliques: list or generator": "Precomputed cliques (use networkx.find_cliques(G))"
            },
            "Returns:": {
                "Yields sets of nodes, one for each k-clique community.": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Gergely Palla, Imre Der\u00e9nyi, Ill\u00e9s Farkas1, and Tam\u00e1s Vicsek,\nUncovering the overlapping community structure of complex networks\nin nature and society Nature 435, 814-818, 2005,\ndoi:10.1038/nature03607",
            "Examples": "G=nx.complete_graph(5)\nK5=nx.convert_node_labels_to_integers(G,first_label=2)\nG.add_edges_from(K5.edges())\nc=list(nx.community.k_clique_communities(G,4))\nsorted(list(c[0]))\n# [0, 1, 2, 3, 4, 5, 6]\nlist(nx.community.k_clique_communities(G,6))\n# []"
        }
    },
    {
        "Section ID": "junction_tree",
        "Description": [
            "Returns a junction tree of a given graph.",
            "A junction tree (or clique tree) is constructed from a (un)directed graph G.\nThe tree is constructed based on a moralized and triangulated version of G.\nThe tree\u2019s nodes consist of maximal cliques and sepsets of the revised graph.\nThe sepset of two cliques is the intersection of the nodes of these cliques,\ne.g. the sepset of (A,B,C) and (A,C,E,F) is (A,C). These nodes are often called\n\u201cvariables\u201d in this literature. The tree is bipartite with each sepset\nconnected to its two cliques.",
            "Junction Trees are not unique as the order of clique consideration determines\nwhich sepsets are included.",
            "The junction tree algorithm consists of five steps [1] :"
        ],
        "Field List": {
            "Parameters:": {
                "G : networkx.Graph": "Directed or undirected graph."
            },
            "Returns:": {
                "junction_tree : networkx.Graph": "The corresponding junction tree ofG."
            },
            "Raises:": {
                "NetworkXNotImplemented": "Raised ifGis an instance ofMultiGraphorMultiDiGraph."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Junction tree algorithm:https://en.wikipedia.org/wiki/Junction_tree_algorithm  [2]Finn V. Jensen and Frank Jensen. 1994. Optimal\njunction trees. In Proceedings of the Tenth international\nconference on Uncertainty in artificial intelligence (UAI\u201994).\nMorgan Kaufmann Publishers Inc., San Francisco, CA, USA, 360\u2013366."
        }
    },
    {
        "Section ID": "read_multiline_adjlist",
        "Description": [
            "Read graph in multi-line adjacency list format from path."
        ],
        "Field List": {
            "Parameters:": {
                "path : string or file": "Filename or file handle to read.\nFilenames ending in .gz or .bz2 will be uncompressed.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated.",
                "nodetype : Python type, optional": "Convert nodes to this type.",
                "edgetype : Python type, optional": "Convert edge data to this type.",
                "comments : string, optional": "Marker for comment lines",
                "delimiter : string, optional": "Separator for node labels.  The default is whitespace."
            },
            "Returns:": {
                "G: NetworkX graph": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This format does not store graph, node, or edge data.",
            "Examples": "G=nx.path_graph(4)\nnx.write_multiline_adjlist(G,\"test.adjlist\")\nG=nx.read_multiline_adjlist(\"test.adjlist\")\nThe path can be a file or a string with the name of the file. If a\nfile s provided, it has to be opened in \u2018rb\u2019 mode.\nfh=open(\"test.adjlist\",\"rb\")\nG=nx.read_multiline_adjlist(fh)\nFilenames ending in .gz or .bz2 will be compressed.\nnx.write_multiline_adjlist(G,\"test.adjlist.gz\")\nG=nx.read_multiline_adjlist(\"test.adjlist.gz\")\nThe optional nodetype is a function to convert node strings to nodetype.\nFor example\nG=nx.read_multiline_adjlist(\"test.adjlist\",nodetype=int)\nwill attempt to convert all nodes to integer type.\nThe optional edgetype is a function to convert edge data strings to\nedgetype.\nG=nx.read_multiline_adjlist(\"test.adjlist\")\nThe optional create_using parameter is a NetworkX graph container.\nThe default is Graph(), an undirected graph.  To read the data as\na directed graph use\nG=nx.read_multiline_adjlist(\"test.adjlist\",create_using=nx.DiGraph)"
        }
    },
    {
        "Section ID": "incidence_matrix",
        "Description": [
            "Returns incidence matrix of G.",
            "The incidence matrix assigns each row to a node and each column to an edge.\nFor a standard incidence matrix a 1 appears wherever a row\u2019s node is\nincident on the column\u2019s edge.  For an oriented incidence matrix each\nedge is assigned an orientation (arbitrarily for undirected and aligning to\ndirection for directed).  A -1 appears for the source (tail) of an edge and\n1 for the destination (head) of the edge.  The elements are zero otherwise."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "nodelist : list, optional   (default= all nodes in G)": "The rows are ordered according to the nodes in nodelist.\nIf nodelist is None, then the ordering is produced by G.nodes().",
                "edgelist : list, optional (default= all edges in G)": "The columns are ordered according to the edges in edgelist.\nIf edgelist is None, then the ordering is produced by G.edges().",
                "oriented: bool, optional (default=False)": "If True, matrix elements are +1 or -1 for the head or tail node\nrespectively of each edge.  If False, +1 occurs at both nodes.",
                "weight : string or None, optional (default=None)": "The edge data key used to provide each value in the matrix.\nIf None, then each edge has weight 1.  Edge weights, if used,\nshould be positive so that the orientation can provide the sign.",
                "dtype : a NumPy dtype or None (default=None)": "The dtype of the output sparse array. This type should be a compatible\ntype of the weight argument, eg. if weight would return a float this\nargument should also be a float.\nIf None, then the default for SciPy is used."
            },
            "Returns:": {
                "A : SciPy sparse array": "The incidence matrix of G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For MultiGraph/MultiDiGraph, the edges in edgelist should be\n(u,v,key) 3-tuples. \u201cNetworks are the best discrete model for so many problems in\napplied mathematics\u201d [1] .",
            "References": "[1]Gil Strang, Network applications: A = incidence matrix,http://videolectures.net/mit18085f07_strang_lec03/"
        }
    },
    {
        "Section ID": "build_auxiliary_node_connectivity",
        "Description": [
            "Creates a directed graph D from an undirected graph G to compute flow\nbased node connectivity.",
            "For an undirected graph G having n nodes and m edges we derive a\ndirected graph D with 2n nodes and 2m+n arcs by replacing each\noriginal node v with two nodes vA , vB linked by an (internal)\narc in D. Then for each edge ( u , v ) in G we add two arcs ( uB , vA )\nand ( vB , uA ) in D. Finally we set the attribute capacity = 1 for each\narc in D [1] .",
            "For a directed graph having n nodes and m arcs we derive a\ndirected graph D with 2n nodes and m+n arcs by replacing each\noriginal node v with two nodes vA , vB linked by an (internal)\narc ( vA , vB ) in D. Then for each arc ( u , v ) in G we add one\narc ( uB , vA ) in D. Finally we set the attribute capacity = 1 for\neach arc in D.",
            "A dictionary with a mapping between nodes in the original graph and the\nauxiliary digraph is stored as a graph attribute: D.graph[\u2018mapping\u2019].",
            "References"
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Kammer, Frank and Hanjo Taubig. Graph Connectivity. in Brandes and\nErlebach, \u2018Network Analysis: Methodological Foundations\u2019, Lecture\nNotes in Computer Science, Volume 3418, Springer-Verlag, 2005.https://doi.org/10.1007/978-3-540-31955-9_7"
        }
    },
    {
        "Section ID": "chordal_cycle_graph",
        "Description": [
            "Returns the chordal cycle graph on p nodes.",
            "The returned graph is a cycle graph on p nodes with chords joining each\nvertex x to its inverse modulo p . This graph is a (mildly explicit)\n3-regular expander [1] .",
            "p  must be a prime number."
        ],
        "Field List": {
            "Parameters:": {
                "p : a prime number": "The number of vertices in the graph. This also indicates where the\nchordal edges in the cycle will be created.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : graph": "The constructed undirected multigraph."
            },
            "Raises:": {
                "NetworkXError": "Ifcreate_usingindicates directed or not a multigraph."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Theorem 4.4.2 in A. Lubotzky. \u201cDiscrete groups, expanding graphs and\ninvariant measures\u201d, volume 125 of Progress in Mathematics.\nBirkh\u00e4user Verlag, Basel, 1994."
        }
    },
    {
        "Section ID": "ArborescenceIterator",
        "Description": [
            "Iterate over all spanning arborescences of a graph in either increasing or\ndecreasing cost.",
            "Notes",
            "This iterator uses the partition scheme from [1] (included edges,\nexcluded edges and open edges). It generates minimum spanning\narborescences using a modified Edmonds\u2019 Algorithm which respects the\npartition of edges. For arborescences with the same weight, ties are\nbroken arbitrarily.",
            "References"
        ],
        "Field List": {
            "Parameters:": {
                "G : nx.DiGraph": "The directed graph which we need to iterate trees over",
                "weight : String, default = \u201cweight\u201d": "The edge attribute used to store the weight of the edge",
                "minimum : bool, default = True": "Return the trees in increasing order while true and decreasing order\nwhile false.",
                "init_partition : tuple, default = None": "In the case that certain edges have to be included or excluded from\nthe arborescences,init_partitionshould be in the form(included_edges,excluded_edges)where each edges is a(u,v)-tuple inside an iterable such as a list or set."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This iterator uses the partition scheme from [1] (included edges,\nexcluded edges and open edges). It generates minimum spanning\narborescences using a modified Edmonds\u2019 Algorithm which respects the\npartition of edges. For arborescences with the same weight, ties are\nbroken arbitrarily.",
            "References": "[1]G.K. Janssens, K. S\u00f6rensen, An algorithm to generate all spanning\ntrees in order of increasing cost, Pesquisa Operacional, 2005-08,\nVol. 25 (2), p. 219-229,https://www.scielo.br/j/pope/a/XHswBwRwJyrfL88dmMwYNWp/?lang=en"
        }
    },
    {
        "Section ID": "make_max_clique_graph",
        "Description": [
            "Returns the maximal clique graph of the given graph.",
            "The nodes of the maximal clique graph of G are the cliques of G and an edge joins two cliques if the cliques are not disjoint."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "NetworkX graph": "A graph whose nodes are the cliques ofGand whose edges\njoin two cliques if they are not disjoint."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This function behaves like the following code:"
        }
    },
    {
        "Section ID": "is_valid_directed_joint_degree",
        "Description": [
            "Checks whether the given directed joint degree input is realizable"
        ],
        "Field List": {
            "Parameters:": {
                "in_degrees : list of integers": "in degree sequence contains the in degrees of nodes.",
                "out_degrees : list of integers": "out degree sequence contains the out degrees of nodes.",
                "nkk : dictionary of dictionary of integers": "directed joint degree dictionary. for nodes of out degree k (first\nlevel of dict) and nodes of in degree l (second level of dict)\ndescribes the number of edges."
            },
            "Returns:": {
                "boolean": "returns true if given input is realizable, else returns false."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Here is the list of conditions that the inputs (in/out degree sequences,\nnkk) need to satisfy for simple directed graph realizability:",
            "References": "[1] B. Tillman, A. Markopoulou, C. T. Butts & M. Gjoka, \u201cConstruction of Directed 2K Graphs\u201d. In Proc. of KDD 2017."
        }
    },
    {
        "Section ID": "common_neighbor_centrality",
        "Description": [
            "Return the CCPA score for each pair of nodes.",
            "Compute the Common Neighbor and Centrality based Parameterized Algorithm(CCPA)\nscore of all node pairs in ebunch.",
            "CCPA score of u and v is defined as",
            "where \\(\\Gamma(u)\\) denotes the set of neighbors of \\(u\\) , \\(\\Gamma(v)\\) denotes the\nset of neighbors of \\(v\\) , \\(\\alpha\\) is  parameter varies between [0,1], \\(N\\) denotes\ntotal number of nodes in the Graph and \\({d}_{uv}\\) denotes shortest distance\nbetween \\(u\\) and \\(v\\) .",
            "This algorithm is based on two vital properties of nodes, namely the number\nof common neighbors and their centrality. Common neighbor refers to the common\nnodes between two nodes. Centrality refers to the prestige that a node enjoys\nin a network."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "NetworkX undirected graph.",
                "ebunch : iterable of node pairs, optional (default = None)": "Preferential attachment score will be computed for each pair of\nnodes given in the iterable. The pairs must be given as\n2-tuples (u, v) where u and v are nodes in the graph. If ebunch\nis None then all nonexistent edges in the graph will be used.\nDefault value: None.",
                "alpha : Parameter defined for participation of Common Neighbor": "and Centrality Algorithm share. Values for alpha should\nnormally be between 0 and 1. Default value set to 0.8\nbecause author found better performance at 0.8 for all the\ndataset.\nDefault value: 0.8"
            },
            "Returns:": {
                "piter : iterator": "An iterator of 3-tuples in the form (u, v, p) where (u, v) is a\npair of nodes and p is their Common Neighbor and Centrality based\nParameterized Algorithm(CCPA) score."
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis aDiGraph, aMultigraphor aMultiDiGraph.",
                "NetworkXAlgorithmError": "If self loops exsists inebunchor inG(ifebunchisNone).",
                "NodeNotFound": "Ifebunchhas a node that is not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Ahmad, I., Akhtar, M.U., Noor, S. et al.\nMissing Link Prediction using Common Neighbor and Centrality based Parameterized Algorithm.\nSci Rep 10, 364 (2020).https://doi.org/10.1038/s41598-019-57304-y",
            "Examples": "G=nx.complete_graph(5)\npreds=nx.common_neighbor_centrality(G,[(0,1),(2,3)])\nforu,v,pinpreds:\nprint(f\"({u}, {v}) -> {p}\")\n# (0, 1) -> 3.4000000000000004\n# (2, 3) -> 3.4000000000000004"
        }
    },
    {
        "Section ID": "rescale_layout",
        "Description": [
            "Returns scaled position array to (-scale, scale) in all axes.",
            "The function acts on NumPy arrays which hold position information.\nEach position is one row of the array. The dimension of the space\nequals the number of columns. Each coordinate in one column.",
            "To rescale, the mean (center) is subtracted from each axis separately.\nThen all values are scaled so that the largest magnitude value\nfrom all axes equals scale (thus, the aspect ratio is preserved).\nThe resulting NumPy Array is returned (order of rows unchanged)."
        ],
        "Field List": {
            "Parameters:": {
                "pos : numpy array": "positions to be scaled. Each row is a position.",
                "scale : number (default: 1)": "The size of the resulting extent in all directions."
            },
            "Returns:": {
                "pos : numpy array": "scaled positions. Each row is a position."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "single_source_dijkstra",
        "Description": [
            "Find shortest weighted paths and lengths from a source node.",
            "Compute the shortest path length between source and all other\nreachable nodes for a weighted graph.",
            "Uses Dijkstra\u2019s algorithm to compute shortest paths and lengths\nbetween a source and all other reachable nodes in a weighted graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node label": "Starting node for path",
                "target : node label, optional": "Ending node for path",
                "cutoff : integer or float, optional": "Length (sum of edge weights) at which the search is stopped.\nIf cutoff is provided, only return paths with summed weight <= cutoff.",
                "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge."
            },
            "Returns:": {
                "distance, path : pair of dictionaries, or numeric and list.": "If target is None, paths and lengths to all nodes are computed.\nThe return value is a tuple of two dictionaries keyed by target nodes.\nThe first dictionary stores distance to each target node.\nThe second stores the path to each target node.\nIf target is not None, returns a tuple (distance, path), where\ndistance is the distance from source to target and path is a list\nrepresenting the path from source to target."
            },
            "Raises:": {
                "NodeNotFound": "Ifsourceis not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The weight function can be used to hide edges by returning None.\nSo weight=lambdau,v,d:1ifd['color']==\"red\"elseNone will find the shortest red path. Based on the Python cookbook recipe (119466) at https://code.activestate.com/recipes/119466/ This algorithm is not guaranteed to work if edge weights\nare negative or are floating point numbers\n(overflows and roundoff errors can cause problems).",
            "Examples": "G=nx.path_graph(5)\nlength,path=nx.single_source_dijkstra(G,0)\nlength[4]\n# 4\nfornodein[0,1,2,3,4]:\nprint(f\"{node}: {length[node]}\")\n# 0: 0\n# 1: 1\n# 2: 2\n# 3: 3\n# 4: 4\npath[4]\n# [0, 1, 2, 3, 4]\nlength,path=nx.single_source_dijkstra(G,0,1)\nlength\n# 1\npath\n# [0, 1]"
        }
    },
    {
        "Section ID": "les_miserables_graph",
        "Description": [
            "Returns coappearance network of characters in the novel Les Miserables.",
            "References"
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]D. E. Knuth, 1993.\nThe Stanford GraphBase: a platform for combinatorial computing,\npp. 74-87. New York: AcM Press."
        }
    },
    {
        "Section ID": "visibility_graph",
        "Description": [
            "Return a Visibility Graph of an input Time Series.",
            "A visibility graph converts a time series into a graph. The constructed graph\nuses integer nodes to indicate which event in the series the node represents.\nEdges are formed as follows: consider a bar plot of the series and view that\nas a side view of a landscape with a node at the top of each bar. An edge\nmeans that the nodes can be connected by a straight \u201cline-of-sight\u201d without\nbeing obscured by any bars between the nodes.",
            "The resulting graph inherits several properties of the series in its structure.\nThereby, periodic series convert into regular graphs, random series convert\ninto random graphs, and fractal series convert into scale-free networks [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "series : Sequence[Number]": "A Time Series sequence (iterable and sliceable) of numeric values\nrepresenting times."
            },
            "Returns:": {
                "NetworkX Graph": "The Visibility Graph of the input series"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Lacasa, Lucas, Bartolo Luque, Fernando Ballesteros, Jordi Luque, and Juan Carlos Nuno.\n\u201cFrom time series to complex networks: The visibility graph.\u201d Proceedings of the\nNational Academy of Sciences 105, no. 13 (2008): 4972-4975.https://www.pnas.org/doi/10.1073/pnas.0709247105",
            "Examples": "series_list=[range(10),[2,1,3,2,1,3,2,1,3,2,1,3]]\nforsinseries_list:\ng=nx.visibility_graph(s)\nprint(g)\n# Graph with 10 nodes and 9 edges\n# Graph with 12 nodes and 18 edges"
        }
    },
    {
        "Section ID": "is_maximal_matching",
        "Description": [
            "Return True if matching is a maximal matching of G",
            "A maximal matching in a graph is a matching in which adding any\nedge would cause the set to no longer be a valid matching."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "matching : dict or set": "A dictionary or set representing a matching. If a dictionary, it\nmust havematching[u]==vandmatching[v]==ufor each\nedge(u,v)in the matching. If a set, it must have elements\nof the form(u,v), where(u,v)is an edge in the\nmatching."
            },
            "Returns:": {
                "bool": "Whether the given set or dictionary represents a valid maximal\nmatching in the graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph([(1,2),(1,3),(2,3),(3,4),(3,5)])\nnx.is_maximal_matching(G,{(1,2),(3,4)})\n# True"
        }
    },
    {
        "Section ID": "spectral_bipartivity",
        "Description": [
            "Returns the spectral bipartivity."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "nodes : list or container  optional(default is all nodes)": "Nodes to return value of spectral bipartivity contribution.",
                "weight : string or None  optional (default = \u2018weight\u2019)": "Edge data key to use for edge weights. If None, weights set to 1."
            },
            "Returns:": {
                "sb : float or dict": "A single number if the keyword nodes is not specified, or\na dictionary keyed by node with the spectral bipartivity contribution\nof that node as the value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This implementation uses Numpy (dense) matrices which are not efficient\nfor storing large sparse graphs.",
            "References": "[1]E. Estrada and J. A. Rodr\u00edguez-Vel\u00e1zquez, \u201cSpectral measures of\nbipartivity in complex networks\u201d, PhysRev E 72, 046105 (2005)",
            "Examples": "fromnetworkx.algorithmsimportbipartite\nG=nx.path_graph(4)\nbipartite.spectral_bipartivity(G)\n# 1.0"
        }
    },
    {
        "Section ID": "louvain_partitions",
        "Description": [
            "Yields partitions for each level of the Louvain Community Detection Algorithm",
            "Louvain Community Detection Algorithm is a simple method to extract the community\nstructure of a network. This is a heuristic method based on modularity optimization. [1]",
            "The partitions at each level (step of the algorithm) form a dendrogram of communities.\nA dendrogram is a diagram representing a tree and each level represents\na partition of the G graph. The top level contains the smallest communities\nand as you traverse to the bottom of the tree the communities get bigger\nand the overall modularity increases making the partition better.",
            "Each level is generated by executing the two phases of the Louvain Community\nDetection Algorithm.",
            "Be careful with self-loops in the input graph. These are treated as\npreviously reduced communities \u2013 as if the process had been started\nin the middle of the algorithm. Large self-loop edge weights thus\nrepresent strong communities and in practice may be hard to add\nother nodes to.  If your input graph edge weights for self-loops\ndo not represent already reduced communities you may want to remove\nthe self-loops before inputting that graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "weight : string or None, optional (default=\u201dweight\u201d)": "The name of an edge attribute that holds the numerical value\nused as a weight. If None then each edge has weight 1.",
                "resolution : float, optional (default=1)": "If resolution is less than 1, the algorithm favors larger communities.\nGreater than 1 favors smaller communities",
                "threshold : float, optional (default=0.0000001)": "Modularity gain threshold for each level. If the gain of modularity\nbetween 2 levels of the algorithm is less than the given threshold\nthen the algorithm stops and returns the resulting communities.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Yields:": {
                "list": "A list of sets (partition ofG). Each set represents one community and contains\nall the nodes that constitute it."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Blondel, V.D. et al. Fast unfolding of communities in\nlarge networks. J. Stat. Mech 10008, 1-12(2008)"
        }
    },
    {
        "Section ID": "find_cycle",
        "Description": [
            "Returns a cycle found via depth-first traversal.",
            "The cycle is a list of edges indicating the cyclic path.\nOrientation of directed edges is controlled by orientation ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A directed/undirected graph/multigraph.",
                "source : node, list of nodes": "The node from which the traversal begins. If None, then a source\nis chosen arbitrarily and repeatedly until all edges from each node in\nthe graph are searched.",
                "orientation : None | \u2018original\u2019 | \u2018reverse\u2019 | \u2018ignore\u2019 (default: None)": "For directed graphs and directed multigraphs, edge traversals need not\nrespect the original orientation of the edges.\nWhen set to \u2018reverse\u2019 every edge is traversed in the reverse direction.\nWhen set to \u2018ignore\u2019, every edge is treated as undirected.\nWhen set to \u2018original\u2019, every edge is treated as directed.\nIn all three cases, the yielded edge tuples add a last entry to\nindicate the direction in which that edge was traversed.\nIf orientation is None, the yielded edge has no direction indicated.\nThe direction is respected, but not reported."
            },
            "Returns:": {
                "edges : directed edges": "A list of directed edges indicating the path taken for the loop.\nIf no cycle is found, then an exception is raised.\nFor graphs, an edge is of the form(u,v)whereuandvare the tail and head of the edge as determined by the traversal.\nFor multigraphs, an edge is of the form(u,v,key), wherekeyis\nthe key of the edge. When the graph is directed, thenuandvare always in the order of the actual directed edge.\nIf orientation is not None then the edge tuple is extended to include\nthe direction of traversal (\u2018forward\u2019 or \u2018reverse\u2019) on that edge."
            },
            "Raises:": {
                "NetworkXNoCycle": "If no cycle was found."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "In this example, we construct a DAG and find, in the first call, that there\nare no directed cycles, and so an exception is raised. In the second call,\nwe ignore edge orientations and find that there is an undirected cycle.\nNote that the second call finds a directed cycle while effectively\ntraversing an undirected graph, and so, we found an \u201cundirected cycle\u201d.\nThis means that this DAG structure does not form a directed tree (which\nis also known as a polytree).\nG=nx.DiGraph([(0,1),(0,2),(1,2)])\nnx.find_cycle(G,orientation=\"original\")Traceback (most recent call last):    ...networkx.exception.NetworkXNoCycleNo cycle found.\nlist(nx.find_cycle(G,orientation=\"ignore\"))\n# [(0, 1, 'forward'), (1, 2, 'forward'), (0, 2, 'reverse')]"
        }
    },
    {
        "Section ID": "is_frozen",
        "Description": [
            "Returns True if graph is frozen."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph"
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "ladder_graph",
        "Description": [
            "Returns the Ladder graph of length n.",
            "This is two paths of n nodes, with\neach pair connected by a single edge.",
            "Node labels are the integers 0 to 2*n - 1.",
            "( Sourcecode , png )"
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "within_inter_cluster",
        "Description": [
            "Compute the ratio of within- and inter-cluster common neighbors\nof all node pairs in ebunch.",
            "For two nodes u and v , if a common neighbor w belongs to the\nsame community as them, w is considered as within-cluster common\nneighbor of u and v . Otherwise, it is considered as\ninter-cluster common neighbor of u and v . The ratio between the\nsize of the set of within- and inter-cluster common neighbors is\ndefined as the WIC measure. [1]"
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX undirected graph.",
                "ebunch : iterable of node pairs, optional (default = None)": "The WIC measure will be computed for each pair of nodes given in\nthe iterable. The pairs must be given as 2-tuples (u, v) where\nu and v are nodes in the graph. If ebunch is None then all\nnonexistent edges in the graph will be used.\nDefault value: None.",
                "delta : float, optional (default = 0.001)": "Value to prevent division by zero in case there is no\ninter-cluster common neighbor between two nodes. See[1]for\ndetails. Default value: 0.001.",
                "community : string, optional (default = \u2018community\u2019)": "Nodes attribute name containing the community information.\nG[u][community] identifies which community u belongs to. Each\nnode belongs to at most one community. Default value: \u2018community\u2019."
            },
            "Returns:": {
                "piter : iterator": "An iterator of 3-tuples in the form (u, v, p) where (u, v) is a\npair of nodes and p is their WIC measure."
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis aDiGraph, aMultigraphor aMultiDiGraph.",
                "NetworkXAlgorithmError": "Ifdeltais less than or equal to zero.If no community information is available for a node inebunchor inG(ifebunchisNone).",
                "NodeNotFound": "Ifebunchhas a node that is not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1](1,2)Jorge Carlos Valverde-Rebaza and Alneu de Andrade Lopes.\nLink prediction in complex networks based on cluster information.\nIn Proceedings of the 21st Brazilian conference on Advances in\nArtificial Intelligence (SBIA\u201912)https://doi.org/10.1007/978-3-642-34459-6_10",
            "Examples": "G=nx.Graph()\nG.add_edges_from([(0,1),(0,2),(0,3),(1,4),(2,4),(3,4)])\nG.nodes[0][\"community\"]=0\nG.nodes[1][\"community\"]=1\nG.nodes[2][\"community\"]=0\nG.nodes[3][\"community\"]=0\nG.nodes[4][\"community\"]=0\npreds=nx.within_inter_cluster(G,[(0,4)])\nforu,v,pinpreds:\nprint(f\"({u}, {v}) -> {p:.8f}\")\n# (0, 4) -> 1.99800200\npreds=nx.within_inter_cluster(G,[(0,4)],delta=0.5)\nforu,v,pinpreds:\nprint(f\"({u}, {v}) -> {p:.8f}\")\n# (0, 4) -> 1.33333333"
        }
    },
    {
        "Section ID": "random_k_out_graph",
        "Description": [
            "Returns a random k -out graph with preferential attachment.",
            "A random k -out graph with preferential attachment is a\nmultidigraph generated by the following algorithm.",
            "For more information on this model of random graph, see [1]."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes in the returned graph.",
                "k : int": "The out-degree of each node in the returned graph.",
                "alpha : float": "A positivefloatrepresenting the initial weight of\neach vertex. A higher number means that in step 3 above, nodes\nwill be chosen more like a true uniformly random sample, and a\nlower number means that nodes are more likely to be chosen as\ntheir in-degree increases. If this parameter is not positive, aValueErroris raised.",
                "self_loops : bool": "If True, self-loops are allowed when generating the graph.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "MultiDiGraph": "Ak-out-regular multidigraph generated according to the above\nalgorithm."
            },
            "Raises:": {
                "ValueError": "Ifalphais not positive."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The returned multidigraph may not be strongly connected, or even\nweakly connected.",
            "References": "[1]: Peterson, Nicholas R., and Boris Pittel. \u201cDistance between two randomk-out digraphs, with and without\npreferential attachment.\u201d\narXiv preprint arXiv:1311.5961 (2013).\n<https://arxiv.org/abs/1311.5961>"
        }
    },
    {
        "Section ID": "LCF_graph",
        "Description": [
            "Return the cubic graph specified in LCF notation.",
            "LCF (Lederberg-Coxeter-Fruchte) notation[R8553aaaa836a-1]_ is a compressed\nnotation used in the generation of various cubic Hamiltonian\ngraphs of high symmetry. See, for example, dodecahedral_graph , desargues_graph , heawood_graph and pappus_graph .",
            "Nodes are drawn from range(n) . Each node n_i is connected with\nnode n_i+shift%n where shift is given by cycling through\nthe input shift_list  repeat s times."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The starting graph is then-cycle with nodes0,...,n-1.\nThe null graph is returned ifn< 1.",
                "shift_list : list": "A list of integer shifts modn,[s1,s2,..,sk]",
                "repeats : int": "Integer specifying the number of times that shifts inshift_listare successively applied to each current node in the n-cycle\nto generate an edge betweenn_currentandn_current+shiftmodn."
            },
            "Returns:": {
                "G : Graph": "A graph instance created from the specified LCF notation."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://en.wikipedia.org/wiki/LCF_notation",
            "Examples": "The utility graph\\(K_{3,3}\\)\nG=nx.LCF_graph(6,[3,-3],3)\nG.edges()\n# EdgeView([(0, 1), (0, 5), (0, 3), (1, 2), (1, 4), (2, 3), (2, 5), (3, 4), (4, 5)])\nThe Heawood graph:\nG=nx.LCF_graph(14,[5,-5],7)\nnx.is_isomorphic(G,nx.heawood_graph())\n# True"
        }
    },
    {
        "Section ID": "to_dict_of_dicts",
        "Description": [
            "Returns adjacency representation of graph as a dictionary of dictionaries."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "nodelist : list": "Use only nodes specified in nodelist",
                "edge_data : scalar, optional": "If provided, the value of the dictionary will be set toedge_datafor\nall edges. Usual values could be1orTrue. Ifedge_dataisNone(the default), the edgedata inGis used, resulting in a\ndict-of-dict-of-dicts. IfGis a MultiGraph, the result will be a\ndict-of-dict-of-dict-of-dicts. See Notes for an approach to customize\nhandling edge data.edge_datashouldnotbe a container."
            },
            "Returns:": {
                "dod : dict": "A nested dictionary representation ofG. Note that the level of\nnesting depends on the type ofGand the value ofedge_data(see Examples)."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For a more custom approach to handling edge data, try:",
            "Examples": "G=nx.path_graph(3)\nnx.to_dict_of_dicts(G)\n# {0: {1: {}}, 1: {0: {}, 2: {}}, 2: {1: {}}}\nEdge data is preserved by default (edge_data=None), resulting\nin dict-of-dict-of-dicts where the innermost dictionary contains the\nedge data:\nG=nx.Graph()\nG.add_edges_from(\n[\n(0,1,{\"weight\":1.0}),\n(1,2,{\"weight\":2.0}),\n(2,0,{\"weight\":1.0}),\n]\n)\nd=nx.to_dict_of_dicts(G)\nd\n# {0: {1: {'weight': 1.0}, 2: {'weight': 1.0}},\n#  1: {0: {'weight': 1.0}, 2: {'weight': 2.0}},\n#  2: {1: {'weight': 2.0}, 0: {'weight': 1.0}}}\nd[1][2][\"weight\"]\n# 2.0\nIfedge_datais notNone, edge data in the original graph (if any) is\nreplaced:\nd=nx.to_dict_of_dicts(G,edge_data=1)\nd\n# {0: {1: 1, 2: 1}, 1: {0: 1, 2: 1}, 2: {1: 1, 0: 1}}\nd[1][2]\n# 1\nThis also applies to MultiGraphs: edge data is preserved by default:\nG=nx.MultiGraph()\nG.add_edge(0,1,key=\"a\",weight=1.0)\n# 'a'\nG.add_edge(0,1,key=\"b\",weight=5.0)\n# 'b'\nd=nx.to_dict_of_dicts(G)\nd\n# {0: {1: {'a': {'weight': 1.0}, 'b': {'weight': 5.0}}},\n#  1: {0: {'a': {'weight': 1.0}, 'b': {'weight': 5.0}}}}\nd[0][1][\"b\"][\"weight\"]\n# 5.0\nBut multi edge data is lost ifedge_datais notNone:\nd=nx.to_dict_of_dicts(G,edge_data=10)\nd\n# {0: {1: 10}, 1: {0: 10}}"
        }
    },
    {
        "Section ID": "create_py_random_state",
        "Description": [
            "Returns a random.Random instance depending on input."
        ],
        "Field List": {
            "Parameters:": {
                "random_state : int or random number generator or None (default=None)": "If int, return arandom.Randominstance set with seed=int.Ifrandom.Randominstance, return it.If None or thenp.randompackage, return the global random number\ngenerator used bynp.random.If annp.random.Generatorinstance, or thenp.randompackage, or\nthe global numpy random number generator, then return it.\nwrapped in aPythonRandomViaNumpyBitsclass.If aPythonRandomViaNumpyBitsinstance, return it.If aPythonRandomInterfaceinstance, return it.If anp.random.RandomStateinstance and not the global numpy default,\nreturn it wrapped inPythonRandomInterfacefor backward bit-stream\nmatching with legacy code."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": ""
        }
    },
    {
        "Section ID": "shortest_path_length",
        "Description": [
            "Compute shortest path lengths in the graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node, optional": "Starting node for path.\nIf not specified, compute shortest path lengths using all nodes as\nsource nodes.",
                "target : node, optional": "Ending node for path.\nIf not specified, compute shortest path lengths using all nodes as\ntarget nodes.",
                "weight : None, string or function, optional (default = None)": "If None, every edge has weight/distance/cost 1.\nIf a string, use this edge attribute as the edge weight.\nAny edge attribute not present defaults to 1.\nIf this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly\nthree positional arguments: the two endpoints of an edge and\nthe dictionary of edge attributes for that edge.\nThe function must return a number.",
                "method : string, optional (default = \u2018dijkstra\u2019)": "The algorithm to use to compute the path length.\nSupported options: \u2018dijkstra\u2019, \u2018bellman-ford\u2019.\nOther inputs produce a ValueError.\nIfweightis None, unweighted graph methods are used, and this\nsuggestion is ignored."
            },
            "Returns:": {
                "length: int or iterator": "If the source and target are both specified, return the length of\nthe shortest path from the source to the target.If only the source is specified, return a dict keyed by target\nto the shortest path length from the source to that target.If only the target is specified, return a dict keyed by source\nto the shortest path length from that source to the target.If neither the source nor target are specified, return an iterator\nover (source, dictionary) where dictionary is keyed by target to\nshortest path length from source to that target."
            },
            "Raises:": {
                "NodeNotFound": "Ifsourceis not inG.",
                "NetworkXNoPath": "If no path exists between source and target.",
                "ValueError": "Ifmethodis not among the supported options."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The length of the path is always 1 less than the number of nodes involved\nin the path since the length measures the number of edges followed. For digraphs this returns the shortest directed path length. To find path\nlengths in the reverse direction use G.reverse(copy=False) first to flip\nthe edge orientation.",
            "Examples": "G=nx.path_graph(5)\nnx.shortest_path_length(G,source=0,target=4)\n# 4\np=nx.shortest_path_length(G,source=0)# target not specified\np[4]\n# 4\np=nx.shortest_path_length(G,target=4)# source not specified\np[0]\n# 4\np=dict(nx.shortest_path_length(G))# source,target not specified\np[0][4]\n# 4"
        }
    },
    {
        "Section ID": "mixing_dict",
        "Description": [
            "Returns a dictionary representation of mixing matrix."
        ],
        "Field List": {
            "Parameters:": {
                "xy : list or container of two-tuples": "Pairs of (x,y) items.",
                "attribute : string": "Node attribute key",
                "normalized : bool (default=False)": "Return counts if False or probabilities if True."
            },
            "Returns:": {
                "d: dictionary": "Counts or Joint probability of occurrence of values in xy."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "out_degree_centrality",
        "Description": [
            "Compute the out-degree centrality for nodes.",
            "The out-degree centrality for a node v is the fraction of nodes its\noutgoing edges are connected to."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph"
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of nodes with out-degree centrality as values."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The degree centrality values are normalized by dividing by the maximum\npossible degree in a simple graph n-1 where n is the number of nodes in G. For multigraphs or graphs with self loops the maximum degree might\nbe higher than n-1 and values of degree centrality greater than 1\nare possible.",
            "Examples": "G=nx.DiGraph([(0,1),(0,2),(0,3),(1,2),(1,3)])\nnx.out_degree_centrality(G)\n# {0: 1.0, 1: 0.6666666666666666, 2: 0.0, 3: 0.0}"
        }
    },
    {
        "Section ID": "read_edgelist",
        "Description": [
            "Read a graph from a list of edges."
        ],
        "Field List": {
            "Parameters:": {
                "path : file or string": "File or filename to read. If a file is provided, it must be\nopened in \u2018rb\u2019 mode.\nFilenames ending in .gz or .bz2 will be uncompressed.",
                "comments : string, optional": "The character used to indicate the start of a comment. To specify that\nno character should be treated as a comment, usecomments=None.",
                "delimiter : string, optional": "The string used to separate values.  The default is whitespace.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated.",
                "nodetype : int, float, str, Python type, optional": "Convert node data from strings to specified type",
                "data : bool or list of (label,type) tuples": "Tuples specifying dictionary key names and types for edge data",
                "edgetype : int, float, str, Python type, optional OBSOLETE": "Convert edge data from strings to specified type and use as \u2018weight\u2019",
                "encoding: string, optional": "Specify which encoding to use when reading file."
            },
            "Returns:": {
                "G : graph": "A networkx Graph or other type specified with create_using"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Since nodes must be hashable, the function nodetype must return hashable\ntypes (e.g. int, float, str, frozenset - or tuples of those, etc.)",
            "Examples": "nx.write_edgelist(nx.path_graph(4),\"test.edgelist\")\nG=nx.read_edgelist(\"test.edgelist\")\nfh=open(\"test.edgelist\",\"rb\")\nG=nx.read_edgelist(fh)\nfh.close()\nG=nx.read_edgelist(\"test.edgelist\",nodetype=int)\nG=nx.read_edgelist(\"test.edgelist\",create_using=nx.DiGraph)\nEdgelist with data in a list:\ntextline=\"1 2 3\"\nfh=open(\"test.edgelist\",\"w\")\nd=fh.write(textline)\nfh.close()\nG=nx.read_edgelist(\"test.edgelist\",nodetype=int,data=((\"weight\",float),))\nlist(G)\n# [1, 2]\nlist(G.edges(data=True))\n# [(1, 2, {'weight': 3.0})]\nSee parse_edgelist() for more examples of formatting."
        }
    },
    {
        "Section ID": "tutte_polynomial",
        "Description": [
            "Returns the Tutte polynomial of G",
            "This function computes the Tutte polynomial via an iterative version of\nthe deletion-contraction algorithm.",
            "The Tutte polynomial T_G(x,y) is a fundamental graph polynomial invariant in\ntwo variables. It encodes a wide array of information related to the\nedge-connectivity of a graph; \u201cMany problems about graphs can be reduced to\nproblems of finding and evaluating the Tutte polynomial at certain values\u201d [1] .\nIn fact, every deletion-contraction-expressible feature of a graph is a\nspecialization of the Tutte polynomial [2] (see Notes for examples).",
            "There are several equivalent definitions; here are three:",
            "Def 1 (rank-nullity expansion): For G an undirected graph, n(G) the\nnumber of vertices of G , E the edge set of G , V the vertex set of G , and c(A) the number of connected components of the graph with vertex\nset V and edge set A  [3] :",
            "Def 2 (spanning tree expansion): Let G be an undirected graph, T a spanning\ntree of G , and E the edge set of G . Let E have an arbitrary strict\nlinear order L . Let B_e be the unique minimal nonempty edge cut of \\(E \\setminus T \\cup {e}\\) . An edge e is internally active with respect to T and L if e is the least edge in B_e according to the linear order L . The internal activity of T (denoted i(T) ) is the number of edges\nin \\(E \\setminus T\\) that are internally active with respect to T and L .\nLet P_e be the unique path in \\(T \\cup {e}\\) whose source and target vertex\nare the same. An edge e is externally active with respect to T and L if e is the least edge in P_e according to the linear order L . The\nexternal activity of T (denoted e(T) ) is the number of edges in \\(E \\setminus T\\) that are externally active with respect to T and L .\nThen [4]  [5] :",
            "Def 3 (deletion-contraction recurrence): For G an undirected graph, G-e the graph obtained from G by deleting edge e , G/e the graph obtained\nfrom G by contracting edge e , k(G) the number of cut-edges of G ,\nand l(G) the number of self-loops of G :"
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": ""
            },
            "Returns:": {
                "instance of : sympy.core.add.Add": "A Sympy expression representing the Tutte polynomial forG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Some specializations of the Tutte polynomial:",
            "References": "[1]M. Brandt,\n\u201cThe Tutte Polynomial.\u201d\nTalking About Combinatorial Objects Seminar, 2015https://math.berkeley.edu/~brandtm/talks/tutte.pdf  [2]A. Bj\u00f6rklund, T. Husfeldt, P. Kaski, M. Koivisto,\n\u201cComputing the Tutte polynomial in vertex-exponential time\u201d\n49th Annual IEEE Symposium on Foundations of Computer Science, 2008https://ieeexplore.ieee.org/abstract/document/4691000  [3]Y. Shi, M. Dehmer, X. Li, I. Gutman,\n\u201cGraph Polynomials,\u201d p. 14  [4]Y. Shi, M. Dehmer, X. Li, I. Gutman,\n\u201cGraph Polynomials,\u201d p. 46  [5]A. Ne\u0161etril, J. Goodall,\n\u201cGraph invariants, homomorphisms, and the Tutte polynomial\u201dhttps://iuuk.mff.cuni.cz/~andrew/Tutte.pdf  [6]D. B. West,\n\u201cIntroduction to Graph Theory,\u201d p. 84  [7]G. Coutinho,\n\u201cA brief introduction to the Tutte polynomial\u201d\nStructural Analysis of Complex Networks, 2011https://homepages.dcc.ufmg.br/~gabriel/seminars/coutinho_tuttepolynomial_seminar.pdf  [8]J. A. Ellis-Monaghan, C. Merino,\n\u201cGraph polynomials and their applications I: The Tutte polynomial\u201d\nStructural Analysis of Complex Networks, 2011https://arxiv.org/pdf/0803.3079.pdf",
            "Examples": "C=nx.cycle_graph(5)\nnx.tutte_polynomial(C)\n# x**4 + x**3 + x**2 + x + y\nD=nx.diamond_graph()\nnx.tutte_polynomial(D)\n# x**3 + 2*x**2 + 2*x*y + x + y**2 + y"
        }
    },
    {
        "Section ID": "is_path",
        "Description": [
            "Returns whether or not the specified path exists.",
            "For it to return True, every node on the path must exist and\neach consecutive pair must be connected via one or more edges."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.",
                "path : list": "A list of nodes which defines the path to traverse"
            },
            "Returns:": {
                "bool": "True ifpathis a valid path inG"
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "random_regular_graph",
        "Description": [
            "Returns a random \\(d\\) -regular graph on \\(n\\) nodes.",
            "A regular graph is a graph where each node has the same number of neighbors.",
            "The resulting graph has no self-loops or parallel edges."
        ],
        "Field List": {
            "Parameters:": {
                "d : int": "The degree of each node.",
                "n : integer": "The number of nodes. The value of\\(n \\times d\\)must be even.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Raises:": {
                "NetworkXError": "If\\(n \\times d\\)is odd or\\(d\\)is greater than or equal to\\(n\\)."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The nodes are numbered from \\(0\\) to \\(n - 1\\) . Kim and Vu\u2019s paper [2] shows that this algorithm samples in an\nasymptotically uniform way from the space of random graphs when \\(d = O(n^{1 / 3 - \\epsilon})\\) .",
            "References": "[1]A. Steger and N. Wormald,\nGenerating random regular graphs quickly,\nProbability and Computing 8 (1999), 377-396, 1999.https://doi.org/10.1017/S0963548399003867  [2]Jeong Han Kim and Van H. Vu,\nGenerating random regular graphs,\nProceedings of the thirty-fifth ACM symposium on Theory of computing,\nSan Diego, CA, USA, pp 213\u2013222, 2003.http://portal.acm.org/citation.cfm?id=780542.780576"
        }
    },
    {
        "Section ID": "radius",
        "Description": [
            "Returns the radius of the graph G.",
            "The radius is the minimum eccentricity."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A graph",
                "e : eccentricity dictionary, optional": "A precomputed dictionary of eccentricities.",
                "weight : string, function, or None": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number.If this is None, every edge has weight/distance/cost 1.Weights stored as floating point values can lead to small round-off\nerrors in distances. Use integer weights to avoid this.Weights should be positive, since they are distances."
            },
            "Returns:": {
                "r : integer": "Radius of graph"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph([(1,2),(1,3),(1,4),(3,4),(3,5),(4,5)])\nnx.radius(G)\n# 2"
        }
    },
    {
        "Section ID": "normalized_cut_size",
        "Description": [
            "Returns the normalized size of the cut between two sets of nodes.",
            "The normalized cut size is the cut size times the sum of the\nreciprocal sizes of the volumes of the two sets. [1]"
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "S : collection": "A collection of nodes inG.",
                "T : collection": "A collection of nodes inG.",
                "weight : object": "Edge attribute key to use as weight. If not specified, edges\nhave weight one."
            },
            "Returns:": {
                "number": "The normalized cut size between the two setsSandT."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "In a multigraph, the cut size is the total weight of edges including\nmultiplicity.",
            "References": "[1]David Gleich.Hierarchical Directed Spectral Graph Partitioning.\n<https://www.cs.purdue.edu/homes/dgleich/publications/Gleich%202005%20-%20hierarchical%20directed%20spectral.pdf>"
        }
    },
    {
        "Section ID": "generic_graph_view",
        "Description": [
            "Returns a read-only view of G .",
            "The graph G and its attributes are not copied but viewed through the new graph object\nof the same class as G (or of the class specified in create_using )."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A directed/undirected graph/multigraph.",
                "create_using : NetworkX graph constructor, optional (default=None)": "Graph type to create. If graph instance, then cleared before populated.\nIfNone, then the appropriate Graph type is inferred fromG."
            },
            "Returns:": {
                "newG : graph": "A view of the input graphGand its attributes as viewed through\nthecreate_usingclass."
            },
            "Raises:": {
                "NetworkXError": "IfGis a multigraph (or multidigraph) butcreate_usingis not, or vice versa."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The returned graph view is read-only (cannot modify the graph).\nYet the view reflects any changes in G . The intent is to mimic dict views.",
            "Examples": "G=nx.Graph()\nG.add_edge(1,2,weight=0.3)\nG.add_edge(2,3,weight=0.5)\nG.edges(data=True)\n# EdgeDataView([(1, 2, {'weight': 0.3}), (2, 3, {'weight': 0.5})])\nThe view exposes the attributes from the original graph.\nviewG=nx.graphviews.generic_graph_view(G)\nviewG.edges(data=True)\n# EdgeDataView([(1, 2, {'weight': 0.3}), (2, 3, {'weight': 0.5})])\nChanges toGare reflected inviewG.\nG.remove_edge(2,3)\nG.edges(data=True)\n# EdgeDataView([(1, 2, {'weight': 0.3})])\nviewG.edges(data=True)\n# EdgeDataView([(1, 2, {'weight': 0.3})])\nWe can change the graph type with thecreate_usingparameter.\ntype(G)\n# <class 'networkx.classes.graph.Graph'>\nviewDG=nx.graphviews.generic_graph_view(G,create_using=nx.DiGraph)\ntype(viewDG)\n# <class 'networkx.classes.digraph.DiGraph'>"
        }
    },
    {
        "Section ID": "UnionAdjacency",
        "Description": [
            "A read-only union of dict Adjacencies as a Map of Maps of Maps.",
            "The two input dict-of-dict-of-dicts represent the union of G.succ and G.pred . Return values are UnionAtlas\nThe inner level of dict is read-write. But the\nmiddle and outer levels are read-only.",
            "succ : a dict-of-dict-of-dict {node: nbrdict}\npred : a dict-of-dict-of-dict {node: nbrdict}\nThe keys for the two dicts should be the same"
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "create_empty_copy",
        "Description": [
            "Returns a copy of the graph G with all of the edges removed."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "with_data : bool (default=True)": "Propagate Graph and Nodes data to the new graph."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "dense_gnm_random_graph",
        "Description": [
            "Returns a \\(G_{n,m}\\) random graph.",
            "In the \\(G_{n,m}\\) model, a graph is chosen uniformly at random from the set\nof all graphs with \\(n\\) nodes and \\(m\\) edges.",
            "This algorithm should be faster than gnm_random_graph() for dense\ngraphs."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes.",
                "m : int": "The number of edges.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Algorithm by Keith M. Briggs Mar 31, 2006.\nInspired by Knuth\u2019s Algorithm S (Selection sampling technique),\nin section 3.4.2 of [1] .",
            "References": "[1]Donald E. Knuth, The Art of Computer Programming,\nVolume 2/Seminumerical algorithms, Third Edition, Addison-Wesley, 1997."
        }
    },
    {
        "Section ID": "could_be_isomorphic",
        "Description": [
            "Returns False if graphs are definitely not isomorphic.\nTrue does NOT guarantee isomorphism."
        ],
        "Field List": {
            "Parameters:": {
                "G1, G2 : graphs": "The two graphs G1 and G2 must be the same type."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Checks for matching degree, triangle, and number of cliques sequences.\nThe triangle sequence contains the number of triangles each node is part of.\nThe clique sequence contains for each node the number of maximal cliques\ninvolving that node."
        }
    },
    {
        "Section ID": "average_shortest_path_length",
        "Description": [
            "Returns the average shortest path length.",
            "The average shortest path length is",
            "where V is the set of nodes in G , d(s,t) is the shortest path from s to t ,\nand n is the number of nodes in G ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "weight : None, string or function, optional (default = None)": "If None, every edge has weight/distance/cost 1.\nIf a string, use this edge attribute as the edge weight.\nAny edge attribute not present defaults to 1.\nIf this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly\nthree positional arguments: the two endpoints of an edge and\nthe dictionary of edge attributes for that edge.\nThe function must return a number.",
                "method : string, optional (default = \u2018unweighted\u2019 or \u2018dijkstra\u2019)": "The algorithm to use to compute the path lengths.\nSupported options are \u2018unweighted\u2019, \u2018dijkstra\u2019, \u2018bellman-ford\u2019,\n\u2018floyd-warshall\u2019 and \u2018floyd-warshall-numpy\u2019.\nOther method values produce a ValueError.\nThe default method is \u2018unweighted\u2019 ifweightis None,\notherwise the default method is \u2018dijkstra\u2019."
            },
            "Raises:": {
                "NetworkXPointlessConcept": "IfGis the null graph (that is, the graph on zero nodes).",
                "NetworkXError": "IfGis not connected (or not strongly connected, in the case\nof a directed graph).",
                "ValueError": "Ifmethodis not among the supported options."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.path_graph(5)\nnx.average_shortest_path_length(G)\n# 2.0\nFor disconnected graphs, you can compute the average shortest path\nlength for each component\nG=nx.Graph([(1,2),(3,4)])\nforCin(G.subgraph(c).copy()forcinnx.connected_components(G)):\nprint(nx.average_shortest_path_length(C))\n# 1.0\n# 1.0"
        }
    },
    {
        "Section ID": "number_of_spanning_trees",
        "Description": [
            "Returns the number of spanning trees in G .",
            "A spanning tree for an undirected graph is a tree that connects\nall nodes in the graph. For a directed graph, the analog of a\nspanning tree is called a (spanning) arborescence. The arborescence\nincludes a unique directed path from the root node to each other node.\nThe graph must be weakly connected, and the root must be a node\nthat includes all nodes as successors [3] . Note that to avoid\ndiscussing sink-roots and reverse-arborescences, we have reversed\nthe edge orientation from [3] and use the in-degree laplacian.",
            "This function (when weight is None ) returns the number of\nspanning trees for an undirected graph and the number of\narborescences from a single root node for a directed graph.\nWhen weight is the name of an edge attribute which holds the\nweight value of each edge, the function returns the sum over\nall trees of the multiplicative weight of each tree. That is,\nthe weight of the tree is the product of its edge weights.",
            "Kirchoff\u2019s Tree Matrix Theorem states that any cofactor of the\nLaplacian matrix of a graph is the number of spanning trees in the\ngraph. (Here we use cofactors for a diagonal entry so that the\ncofactor becomes the determinant of the matrix with one row\nand its matching column removed.) For a weighted Laplacian matrix,\nthe cofactor is the sum across all spanning trees of the\nmultiplicative weight of each tree. That is, the weight of each\ntree is the product of its edge weights. The theorem is also\nknown as Kirchhoff\u2019s theorem [1] and the Matrix-Tree theorem [2] .",
            "For directed graphs, a similar theorem (Tutte\u2019s Theorem) holds with\nthe cofactor chosen to be the one with row and column removed that\ncorrespond to the root. The cofactor is the number of arborescences\nwith the specified node as root. And the weighted version gives the\nsum of the arborescence weights with root root . The arborescence\nweight is the product of its edge weights."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "root : node": "A node in the directed graphGthat has all nodes as descendants.\n(This is ignored for undirected graphs.)",
                "weight : string or None, optional (default=None)": "The name of the edge attribute holding the edge weight.\nIfNone, then each edge is assumed to have a weight of 1."
            },
            "Returns:": {
                "Number": "Undirected graphs:The number of spanning trees of the graphG.\nOr the sum of all spanning tree weights of the graphGwhere the weight of a tree is the product of its edge weights.Directed graphs:The number of arborescences ofGrooted at noderoot.\nOr the sum of all arborescence weights of the graphGwith\nspecified root where the weight of an arborescence is the product\nof its edge weights.",
                "Undirected graphs:": "The number of spanning trees of the graphG.\nOr the sum of all spanning tree weights of the graphGwhere the weight of a tree is the product of its edge weights.",
                "Directed graphs:": "The number of arborescences ofGrooted at noderoot.\nOr the sum of all arborescence weights of the graphGwith\nspecified root where the weight of an arborescence is the product\nof its edge weights."
            },
            "Raises:": {
                "NetworkXPointlessConcept": "IfGdoes not contain any nodes.",
                "NetworkXError": "If the graphGis directed and the root node\nis not specified or is not in G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Self-loops are excluded. Multi-edges are contracted in one edge\nequal to the sum of the weights.",
            "References": "[1]Wikipedia\n\u201cKirchhoff\u2019s theorem.\u201dhttps://en.wikipedia.org/wiki/Kirchhoff%27s_theorem  [2]Kirchhoff, G. R.\n\u00dcber die Aufl\u00f6sung der Gleichungen, auf welche man\nbei der Untersuchung der linearen Vertheilung\nGalvanischer Str\u00f6me gef\u00fchrt wird\nAnnalen der Physik und Chemie, vol. 72, pp. 497-508, 1847.  [3](1,2)Margoliash, J.\n\u201cMatrix-Tree Theorem for Directed Graphs\u201dhttps://www.math.uchicago.edu/~may/VIGRE/VIGRE2010/REUPapers/Margoliash.pdf",
            "Examples": "G=nx.complete_graph(5)\nround(nx.number_of_spanning_trees(G))\n# 125\nG=nx.Graph()\nG.add_edge(1,2,weight=2)\nG.add_edge(1,3,weight=1)\nG.add_edge(2,3,weight=1)\nround(nx.number_of_spanning_trees(G,weight=\"weight\"))\n# 5"
        }
    },
    {
        "Section ID": "random_geometric_graph",
        "Description": [
            "Returns a random geometric graph in the unit cube of dimensions dim .",
            "The random geometric graph model places n nodes uniformly at\nrandom in the unit cube. Two nodes are joined by an edge if the\ndistance between the nodes is at most radius .",
            "Edges are determined using a KDTree when SciPy is available.\nThis reduces the time complexity from \\(O(n^2)\\) to \\(O(n)\\) ."
        ],
        "Field List": {
            "Parameters:": {
                "n : int or iterable": "Number of nodes or iterable of nodes",
                "radius: float": "Distance threshold value",
                "dim : int, optional": "Dimension of graph",
                "pos : dict, optional": "A dictionary keyed by node with node positions as values.",
                "p : float, optional": "Which Minkowski distance metric to use.phas to meet the condition1<=p<=infinity.If this argument is not specified, the\\(L^2\\)metric\n(the Euclidean distance metric), p = 2 is used.\nThis should not be confused with thepof an Erd\u0151s-R\u00e9nyi random\ngraph, which represents probability.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "pos_name : string, default=\u201dpos\u201d": "The name of the node attribute which represents the position\nin 2D coordinates of the node in the returned graph."
            },
            "Returns:": {
                "Graph": "A random geometric graph, undirected and without self-loops.\nEach node has a node attribute'pos'that stores the\nposition of that node in Euclidean space as provided by theposkeyword argument or, ifposwas not provided, as\ngenerated by this function."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This uses a k -d tree to build the graph. The pos keyword argument can be used to specify node positions so you\ncan create an arbitrary distribution and domain for positions. For example, to use a 2D Gaussian distribution of node positions with mean\n(0, 0) and standard deviation 2:",
            "References": "[1]Penrose, Mathew,Random Geometric Graphs,\nOxford Studies in Probability, 5, 2003.",
            "Examples": "Create a random geometric graph on twenty nodes where nodes are joined by\nan edge if their distance is at most 0.1:\nG=nx.random_geometric_graph(20,0.1)"
        }
    },
    {
        "Section ID": "wiener_index",
        "Description": [
            "Returns the Wiener index of the given graph.",
            "The Wiener index of a graph is the sum of the shortest-path\n(weighted) distances between each pair of reachable nodes.\nFor pairs of nodes in undirected graphs, only one orientation\nof the pair is counted."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "weight : string or None, optional (default: None)": "If None, every edge has weight 1.\nIf a string, use this edge attribute as the edge weight.\nAny edge attribute not present defaults to 1.\nThe edge weights are used to computing shortest-path distances."
            },
            "Returns:": {
                "number": "The Wiener index of the graphG."
            },
            "Raises:": {
                "NetworkXError": "If the graphGis not connected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "If a pair of nodes is not reachable, the distance is assumed to be\ninfinity. This means that for graphs that are not\nstrongly-connected, this function returns inf . The Wiener index is not usually defined for directed graphs, however\nthis function uses the natural generalization of the Wiener index to\ndirected graphs.",
            "References": "[1]Wikipedia: Wiener Index",
            "Examples": "The Wiener index of the (unweighted) complete graph onnnodes\nequals the number of pairs of thennodes, since each pair of\nnodes is at distance one:\nn=10\nG=nx.complete_graph(n)\nnx.wiener_index(G)==n*(n-1)/2\n# True\nGraphs that are not strongly-connected have infinite Wiener index:\nG=nx.empty_graph(2)\nnx.wiener_index(G)\n# inf"
        }
    },
    {
        "Section ID": "symmetric_difference",
        "Description": [
            "Returns new graph with edges that exist in either G or H but not both.",
            "The node sets of H and G must be the same."
        ],
        "Field List": {
            "Parameters:": {
                "G,H : graph": "A NetworkX graph.  G and H must have the same node sets."
            },
            "Returns:": {
                "D : A new graph with the same type as G.": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Attributes from the graph, nodes, and edges are not copied to the new\ngraph.",
            "Examples": "G=nx.Graph([(0,1),(0,2),(1,2),(1,3)])\nH=nx.Graph([(0,1),(1,2),(0,3)])\nR=nx.symmetric_difference(G,H)\nR.nodes\n# NodeView((0, 1, 2, 3))\nR.edges\n# EdgeView([(0, 2), (0, 3), (1, 3)])"
        }
    },
    {
        "Section ID": "MappedQueue",
        "Description": [
            "The MappedQueue class implements a min-heap with removal and update-priority.",
            "The min heap uses heapq as well as custom written _siftup and _siftdown\nmethods to allow the heap positions to be tracked by an additional dict\nkeyed by element to position. The smallest element can be popped in O(1) time,\nnew elements can be pushed in O(log n) time, and any element can be removed\nor updated in O(log n) time. The queue cannot contain duplicate elements\nand an attempt to push an element already in the queue will have no effect.",
            "MappedQueue complements the heapq package from the python standard\nlibrary. While MappedQueue is designed for maximum compatibility with\nheapq, it adds element removal, lookup, and priority update."
        ],
        "Field List": {
            "Parameters:": {
                "data : dict or iterable": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2001).\nIntroduction to algorithms second edition.  [2]Knuth, D. E. (1997). The art of computer programming (Vol. 3).\nPearson Education.",
            "Examples": "AMappedQueuecan be created empty, or optionally, given a dictionary\nof initial elements and priorities.  The methodspush,pop,remove, andupdateoperate on the queue.\ncolors_nm={\"red\":665,\"blue\":470,\"green\":550}\nq=MappedQueue(colors_nm)\nq.remove(\"red\")\nq.update(\"green\",\"violet\",400)\nq.push(\"indigo\",425)\n# True\n[q.pop().elementforiinrange(len(q.heap))]\n# ['violet', 'indigo', 'blue']\nAMappedQueuecan also be initialized with a list or other iterable. The priority is assumed\nto be the sort order of the items in the list.\nq=MappedQueue([916,50,4609,493,237])\nq.remove(493)\nq.update(237,1117)\n[q.pop()foriinrange(len(q.heap))]\n# [50, 916, 1117, 4609]\nAn exception is raised if the elements are not comparable.\nq=MappedQueue([100,\"a\"])Traceback (most recent call last):...TypeError'<' not supported between instances of 'int' and 'str'\nTo avoid the exception, use a dictionary to assign priorities to the elements.\nq=MappedQueue({100:0,\"a\":1})"
        }
    },
    {
        "Section ID": "spring_layout",
        "Description": [
            "Position nodes using Fruchterman-Reingold force-directed algorithm.",
            "The algorithm simulates a force-directed representation of the network\ntreating edges as springs holding nodes close, while treating nodes\nas repelling objects, sometimes called an anti-gravity force.\nSimulation continues until the positions are close to an equilibrium.",
            "There are some hard-coded values: minimal distance between\nnodes (0.01) and \u201ctemperature\u201d of 0.1 to ensure nodes don\u2019t fly away.\nDuring the simulation, k helps determine the distance between nodes,\nthough scale and center determine the size and place after\nrescaling occurs at the end of the simulation.",
            "Fixing some nodes doesn\u2019t allow them to move in the simulation.\nIt also turns off the rescaling feature at the simulation\u2019s end.\nIn addition, setting scale to None turns off rescaling."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph or list of nodes": "A position will be assigned to every node in G.",
                "k : float (default=None)": "Optimal distance between nodes.  If None the distance is set to\n1/sqrt(n) where n is the number of nodes.  Increase this value\nto move nodes farther apart.",
                "pos : dict or None  optional (default=None)": "Initial positions for nodes as a dictionary with node as keys\nand values as a coordinate list or tuple.  If None, then use\nrandom initial positions.",
                "fixed : list or None  optional (default=None)": "Nodes to keep fixed at initial position.\nNodes not inG.nodesare ignored.\nValueError raised iffixedspecified andposnot.",
                "iterations : int  optional (default=50)": "Maximum number of iterations taken",
                "threshold: float optional (default = 1e-4)": "Threshold for relative error in node position changes.\nThe iteration stops if the error is below this threshold.",
                "weight : string or None   optional (default=\u2019weight\u2019)": "The edge attribute that holds the numerical value used for\nthe edge weight.  Larger means a stronger attractive force.\nIf None, then all edge weights are 1.",
                "scale : number or None (default: 1)": "Scale factor for positions. Not used unlessfixedisNone.\nIf scale is None, no rescaling is performed.",
                "center : array-like or None": "Coordinate pair around which to center the layout.\nNot used unlessfixedisNone.",
                "dim : int": "Dimension of layout.",
                "seed : int, RandomState instance or None  optional (default=None)": "Set the random state for deterministic node layouts.\nIf int,seedis the seed used by the random number generator,\nif numpy.random.RandomState instance,seedis the random\nnumber generator,\nif None, the random number generator is the RandomState instance used\nby numpy.random."
            },
            "Returns:": {
                "pos : dict": "A dictionary of positions keyed by node"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.path_graph(4)\npos=nx.spring_layout(G)\n# The same using longer but equivalent function name\n>>> pos = nx.fruchterman_reingold_layout(G)"
        }
    },
    {
        "Section ID": "number_of_nonisomorphic_trees",
        "Description": [
            "Returns the number of nonisomorphic trees"
        ],
        "Field List": {
            "Parameters:": {
                "order : int": "order of the desired tree(s)"
            },
            "Returns:": {
                "length : Number of nonisomorphic graphs for the given order": ""
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "degree_histogram",
        "Description": [
            "Returns a list of the frequency of each degree value."
        ],
        "Field List": {
            "Parameters:": {
                "G : Networkx graph": "A graph"
            },
            "Returns:": {
                "hist : list": "A list of frequencies of degrees.\nThe degree values are the index in the list."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Note: the bins are width one, hence len(list) can be large\n(Order(number_of_edges))"
        }
    },
    {
        "Section ID": "local_efficiency",
        "Description": [
            "Returns the average local efficiency of the graph.",
            "The efficiency of a pair of nodes in a graph is the multiplicative\ninverse of the shortest path distance between the nodes. The local\nefficiency of a node in the graph is the average global efficiency of the\nsubgraph induced by the neighbors of the node. The average local\nefficiency is the average of the local efficiencies of each node [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : networkx.Graph": "An undirected graph for which to compute the average local efficiency."
            },
            "Returns:": {
                "float": "The average local efficiency of the graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weights are ignored when computing the shortest path distances.",
            "References": "[1]Latora, Vito, and Massimo Marchiori.\n\u201cEfficient behavior of small-world networks.\u201dPhysical Review Letters87.19 (2001): 198701.\n<https://doi.org/10.1103/PhysRevLett.87.198701>",
            "Examples": "G=nx.Graph([(0,1),(0,2),(0,3),(1,2),(1,3)])\nnx.local_efficiency(G)\n# 0.9166666666666667"
        }
    },
    {
        "Section ID": "capacity_scaling",
        "Description": [
            "Find a minimum cost flow satisfying all demands in digraph G.",
            "This is a capacity scaling successive shortest augmenting path algorithm.",
            "G is a digraph with edge costs and capacities and in which nodes\nhave demand, i.e., they want to send or receive some amount of\nflow. A negative demand means that the node wants to send flow, a\npositive demand means that the node want to receive flow. A flow on\nthe digraph G satisfies all demand if the net flow into each node\nis equal to the demand of that node."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "DiGraph or MultiDiGraph on which a minimum cost flow satisfying all\ndemands is to be found.",
                "demand : string": "Nodes of the graph G are expected to have an attribute demand\nthat indicates how much flow a node wants to send (negative\ndemand) or receive (positive demand). Note that the sum of the\ndemands should be 0 otherwise the problem in not feasible. If\nthis attribute is not present, a node is considered to have 0\ndemand. Default value: \u2018demand\u2019.",
                "capacity : string": "Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: \u2018capacity\u2019.",
                "weight : string": "Edges of the graph G are expected to have an attribute weight\nthat indicates the cost incurred by sending one unit of flow on\nthat edge. If not present, the weight is considered to be 0.\nDefault value: \u2018weight\u2019.",
                "heap : class": "Type of heap to be used in the algorithm. It should be a subclass ofMinHeapor implement a compatible interface.If a stock heap implementation is to be used,BinaryHeapis\nrecommended overPairingHeapfor Python implementations without\noptimized attribute accesses (e.g., CPython) despite a slower\nasymptotic running time. For Python implementations with optimized\nattribute accesses (e.g., PyPy),PairingHeapprovides better\nperformance. Default value:BinaryHeap."
            },
            "Returns:": {
                "flowCost : integer": "Cost of a minimum cost flow satisfying all demands.",
                "flowDict : dictionary": "If G is a digraph, a dict-of-dicts keyed by nodes such that\nflowDict[u][v] is the flow on edge (u, v).\nIf G is a MultiDiGraph, a dict-of-dicts-of-dicts keyed by nodes\nso that flowDict[u][v][key] is the flow on edge (u, v, key)."
            },
            "Raises:": {
                "NetworkXError": "This exception is raised if the input graph is not directed,\nnot connected.",
                "NetworkXUnfeasible": "This exception is raised in the following situations:The sum of the demands is not zero. Then, there is no\nflow satisfying all demands.There is no flow satisfying all demand.",
                "NetworkXUnbounded": "This exception is raised if the digraph G has a cycle of\nnegative cost and infinite capacity. Then, the cost of a flow\nsatisfying all demands is unbounded below."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm does not work if edge weights are floating-point numbers.",
            "Examples": "A simple example of a min cost flow problem.\nG=nx.DiGraph()\nG.add_node(\"a\",demand=-5)\nG.add_node(\"d\",demand=5)\nG.add_edge(\"a\",\"b\",weight=3,capacity=4)\nG.add_edge(\"a\",\"c\",weight=6,capacity=10)\nG.add_edge(\"b\",\"d\",weight=1,capacity=9)\nG.add_edge(\"c\",\"d\",weight=2,capacity=5)\nflowCost,flowDict=nx.capacity_scaling(G)\nflowCost\n# 24\nflowDict\n# {'a': {'b': 4, 'c': 1}, 'd': {}, 'b': {'d': 4}, 'c': {'d': 1}}\nIt is possible to change the name of the attributes used for the\nalgorithm.\nG=nx.DiGraph()\nG.add_node(\"p\",spam=-4)\nG.add_node(\"q\",spam=2)\nG.add_node(\"a\",spam=-2)\nG.add_node(\"d\",spam=-1)\nG.add_node(\"t\",spam=2)\nG.add_node(\"w\",spam=3)\nG.add_edge(\"p\",\"q\",cost=7,vacancies=5)\nG.add_edge(\"p\",\"a\",cost=1,vacancies=4)\nG.add_edge(\"q\",\"d\",cost=2,vacancies=3)\nG.add_edge(\"t\",\"q\",cost=1,vacancies=2)\nG.add_edge(\"a\",\"t\",cost=2,vacancies=4)\nG.add_edge(\"d\",\"w\",cost=3,vacancies=4)\nG.add_edge(\"t\",\"w\",cost=4,vacancies=1)\nflowCost,flowDict=nx.capacity_scaling(\nG,demand=\"spam\",capacity=\"vacancies\",weight=\"cost\"\n)\nflowCost\n# 37\nflowDict\n# {'p': {'q': 2, 'a': 2}, 'q': {'d': 1}, 'a': {'t': 4}, 'd': {'w': 2}, 't': {'q': 1, 'w': 1}, 'w': {}}"
        }
    },
    {
        "Section ID": "vf2pp_is_isomorphic",
        "Description": [
            "Examines whether G1 and G2 are isomorphic."
        ],
        "Field List": {
            "Parameters:": {
                "G1, G2 : NetworkX Graph or MultiGraph instances.": "The two graphs to check for isomorphism.",
                "node_label : str, optional": "The name of the node attribute to be used when comparing nodes.\nThe default isNone, meaning node attributes are not considered\nin the comparison. Any node that doesn\u2019t have thenode_labelattribute usesdefault_labelinstead.",
                "default_label : scalar": "Default value to use when a node doesn\u2019t have an attribute\nnamednode_label. Default isNone."
            },
            "Returns:": {
                "bool": "True if the two graphs are isomorphic, False otherwise."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "draw_spectral",
        "Description": [
            "Draw the graph G with a spectral 2D layout.",
            "This is a convenience function equivalent to:",
            "For more information about how node positions are determined, see spectral_layout ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph",
                "kwargs : optional keywords": "Seedraw_networkxfor a description of optional keywords."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The layout is computed each time this function is called.\nFor repeated drawing it is much more efficient to call spectral_layout directly and reuse the result:",
            "Examples": "G=nx.path_graph(5)\nnx.draw_spectral(G)"
        }
    },
    {
        "Section ID": "parse_graphml",
        "Description": [
            "Read graph in GraphML format from string."
        ],
        "Field List": {
            "Parameters:": {
                "graphml_string : string": "String containing graphml information\n(e.g., contents of a graphml file).",
                "node_type: Python type (default: str)": "Convert node ids to this type",
                "edge_key_type: Python type (default: int)": "Convert graphml edge ids to this type. Multigraphs use id as edge key.\nNon-multigraphs add to edge attribute dict with name \u201cid\u201d.",
                "force_multigraph : bool (default: False)": "If True, return a multigraph with edge keys. If False (the default)\nreturn a multigraph when multiedges are in the graph."
            },
            "Returns:": {
                "graph: NetworkX graph": "If no parallel edges are found a Graph or DiGraph is returned.\nOtherwise a MultiGraph or MultiDiGraph is returned."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Default node and edge attributes are not propagated to each node and edge.\nThey can be obtained from G.graph and applied to node and edge attributes\nif desired using something like this:",
            "Examples": "G=nx.path_graph(4)\nlinefeed=chr(10)# linefeed =\ns=linefeed.join(nx.generate_graphml(G))\nH=nx.parse_graphml(s)"
        }
    },
    {
        "Section ID": "bellman_ford_path_length",
        "Description": [
            "Returns the shortest path length from source to target\nin a weighted graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node label": "starting node for path",
                "target : node label": "ending node for path",
                "weight : string or function (default=\u201dweight\u201d)": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number."
            },
            "Returns:": {
                "length : number": "Shortest path length."
            },
            "Raises:": {
                "NodeNotFound": "Ifsourceis not inG.",
                "NetworkXNoPath": "If no path exists between source and target."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.",
            "Examples": "G=nx.path_graph(5)\nnx.bellman_ford_path_length(G,0,4)\n# 4"
        }
    },
    {
        "Section ID": "build_auxiliary_edge_connectivity",
        "Description": [
            "Auxiliary digraph for computing flow based edge connectivity",
            "If the input graph is undirected, we replace each edge ( u ,`v`) with\ntwo reciprocal arcs ( u , v ) and ( v , u ) and then we set the attribute\n\u2018capacity\u2019 for each arc to 1. If the input graph is directed we simply\nadd the \u2018capacity\u2019 attribute. Part of algorithm 1 in [1] .",
            "References"
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Abdol-Hossein Esfahanian. Connectivity Algorithms. (this is a\nchapter, look for the reference of the book).http://www.cse.msu.edu/~cse835/Papers/Graph_connectivity_revised.pdf"
        }
    },
    {
        "Section ID": "show_multidiedges",
        "Description": [
            "Returns a filter function that shows specific multi-directed edges."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "to_scipy_sparse_array",
        "Description": [
            "Returns the graph adjacency matrix as a SciPy sparse array."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "The NetworkX graph used to construct the sparse matrix.",
                "nodelist : list, optional": "The rows and columns are ordered according to the nodes innodelist.\nIfnodelistis None, then the ordering is produced by G.nodes().",
                "dtype : NumPy data-type, optional": "A valid NumPy dtype used to initialize the array. If None, then the\nNumPy default is used.",
                "weight : string or None   optional (default=\u2019weight\u2019)": "The edge attribute that holds the numerical value used for\nthe edge weight.  If None then all edge weights are 1.",
                "format : str in {\u2018bsr\u2019, \u2018csr\u2019, \u2018csc\u2019, \u2018coo\u2019, \u2018lil\u2019, \u2018dia\u2019, \u2018dok\u2019}": "The type of the matrix to be returned (default \u2018csr\u2019).  For\nsome algorithms different implementations of sparse matrices\ncan perform better.  See[1]for details."
            },
            "Returns:": {
                "A : SciPy sparse array": "Graph adjacency matrix."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For directed graphs, matrix entry i,j corresponds to an edge from i to j. The matrix entries are populated using the edge attribute held in\nparameter weight. When an edge does not have that attribute, the\nvalue of the entry is 1. For multiple edges the matrix values are the sums of the edge weights. When nodelist does not contain every node in G , the adjacency matrix\nis built from the subgraph of G that is induced by the nodes in nodelist . The convention used for self-loop edges in graphs is to assign the\ndiagonal matrix entry value to the weight attribute of the edge\n(or the number 1 if the edge has no weight attribute).  If the\nalternate convention of doubling the edge weight is desired the\nresulting SciPy sparse array can be modified as follows:",
            "References": "[1]Scipy Dev. References, \u201cSparse Matrices\u201d,https://docs.scipy.org/doc/scipy/reference/sparse.html",
            "Examples": "G=nx.MultiDiGraph()\nG.add_edge(0,1,weight=2)\n# 0\nG.add_edge(1,0)\n# 0\nG.add_edge(2,2,weight=3)\n# 0\nG.add_edge(2,2)\n# 1\nS=nx.to_scipy_sparse_array(G,nodelist=[0,1,2])\nprint(S.toarray())\n# [[0 2 0]\n#  [1 0 0]\n#  [0 0 4]]"
        }
    },
    {
        "Section ID": "krackhardt_kite_graph",
        "Description": [
            "Returns the Krackhardt Kite Social Network.",
            "A 10 actor social network introduced by David Krackhardt\nto illustrate different centrality measures [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : networkx Graph": "Krackhardt Kite graph with 10 nodes and 18 edges"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The traditional labeling is:\nAndre=1, Beverley=2, Carol=3, Diane=4,\nEd=5, Fernando=6, Garth=7, Heather=8, Ike=9, Jane=10.",
            "References": "[1]Krackhardt, David. \u201cAssessing the Political Landscape: Structure,\nCognition, and Power in Organizations\u201d. Administrative Science Quarterly.\n35 (2): 342\u2013369. doi:10.2307/2393394. JSTOR 2393394. June 1990."
        }
    },
    {
        "Section ID": "bidirectional_shortest_path",
        "Description": [
            "Returns a list of nodes in a shortest path between source and target."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node label": "starting node for path",
                "target : node label": "ending node for path"
            },
            "Returns:": {
                "path: list": "List of nodes in a path from source to target."
            },
            "Raises:": {
                "NetworkXNoPath": "If no path exists between source and target."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm is used by shortest_path(G, source, target).",
            "Examples": "G=nx.Graph()\nnx.add_path(G,[0,1,2,3,0,4,5,6,7,4])\nnx.bidirectional_shortest_path(G,2,6)\n# [2, 1, 0, 4, 5, 6]"
        }
    },
    {
        "Section ID": "geometric_soft_configuration_graph",
        "Description": [
            "Returns a random graph from the geometric soft configuration model.",
            "The \\(\\mathbb{S}^1\\) model [1] is the geometric soft configuration model\nwhich is able to explain many fundamental features of real networks such as\nsmall-world property, heteregenous degree distributions, high level of\nclustering, and self-similarity.",
            "In the geometric soft configuration model, a node \\(i\\) is assigned two hidden\nvariables: a hidden degree \\(\\kappa_i\\) , quantifying its popularity, influence,\nor importance, and an angular position \\(\\theta_i\\) in a circle abstracting the\nsimilarity space, where angular distances between nodes are a proxy for their\nsimilarity. Focusing on the angular position, this model is often called\nthe \\(\\mathbb{S}^1\\) model (a one-dimensional sphere). The circle\u2019s radius is\nadjusted to \\(R = N/2\\pi\\) , where \\(N\\) is the number of nodes, so that the density\nis set to 1 without loss of generality.",
            "The connection probability between any pair of nodes increases with\nthe product of their hidden degrees (i.e., their combined popularities),\nand decreases with the angular distance between the two nodes.\nSpecifically, nodes \\(i\\) and \\(j\\) are connected with the probability",
            "\\(p_{ij} = \\frac{1}{1 + \\frac{d_{ij}^\\beta}{\\left(\\mu \\kappa_i \\kappa_j\\right)^{\\max(1, \\beta)}}}\\)",
            "where \\(d_{ij} = R\\Delta\\theta_{ij}\\) is the arc length of the circle between\nnodes \\(i\\) and \\(j\\) separated by an angular distance \\(\\Delta\\theta_{ij}\\) .\nParameters \\(\\mu\\) and \\(\\beta\\) (also called inverse temperature) control the\naverage degree and the clustering coefficient, respectively.",
            "It can be shown [2] that the model undergoes a structural phase transition\nat \\(\\beta=1\\) so that for \\(\\beta<1\\) networks are unclustered in the thermodynamic\nlimit (when \\(N\\to \\infty\\) ) whereas for \\(\\beta>1\\) the ensemble generates\nnetworks with finite clustering coefficient.",
            "The \\(\\mathbb{S}^1\\) model can be expressed as a purely geometric model \\(\\mathbb{H}^2\\) in the hyperbolic plane [3] by mapping the hidden degree of\neach node into a radial coordinate as",
            "\\(r_i = \\hat{R} - \\frac{2 \\max(1, \\beta)}{\\beta \\zeta} \\ln \\left(\\frac{\\kappa_i}{\\kappa_0}\\right)\\)",
            "where \\(\\hat{R}\\) is the radius of the hyperbolic disk and \\(\\zeta\\) is the curvature,",
            "\\(\\hat{R} = \\frac{2}{\\zeta} \\ln \\left(\\frac{N}{\\pi}\\right)\n- \\frac{2\\max(1, \\beta)}{\\beta \\zeta} \\ln (\\mu \\kappa_0^2)\\)",
            "The connection probability then reads",
            "\\(p_{ij} = \\frac{1}{1 + \\exp\\left({\\frac{\\beta\\zeta}{2} (x_{ij} - \\hat{R})}\\right)}\\)",
            "where",
            "\\(x_{ij} = r_i + r_j + \\frac{2}{\\zeta} \\ln \\frac{\\Delta\\theta_{ij}}{2}\\)",
            "is a good approximation of the hyperbolic distance between two nodes separated\nby an angular distance \\(\\Delta\\theta_{ij}\\) with radial coordinates \\(r_i\\) and \\(r_j\\) .\nFor \\(\\beta > 1\\) , the curvature \\(\\zeta = 1\\) , for \\(\\beta < 1\\) , \\(\\zeta = \\beta^{-1}\\) ."
        ],
        "Field List": {
            "Parameters:": {
                "Either `n`, `gamma`, `mean_degree` are provided or `kappas`. The values of": "",
                "`n`, `gamma`, `mean_degree` (if provided) are used to construct a random": "",
                "kappa-dict keyed by node with values sampled from a power-law distribution.": "",
                "beta : positive number": "Inverse temperature, controlling the clustering coefficient.",
                "n : int (default: None)": "Size of the network (number of nodes).\nIf not provided,kappasmust be provided and holds the nodes.",
                "gamma : float (default: None)": "Exponent of the power-law distribution for hidden degreeskappas.\nIf not provided,kappasmust be provided directly.",
                "mean_degree : float (default: None)": "The mean degree in the network.\nIf not provided,kappasmust be provided directly.",
                "kappas : dict (default: None)": "A dict keyed by node to its hidden degree value.\nIf not provided, random values are computed based on a power-law\ndistribution usingn,gammaandmean_degree.",
                "seed : int, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "Graph": "A random geometric soft configuration graph (undirected with no self-loops).\nEach node has three node-attributes:kappathat represents the hidden degree.thetathe position in the similarity space (\\(\\mathbb{S}^1\\)) which is\nalso the angular position in the hyperbolic plane.radiusthe radial position in the hyperbolic plane\n(based on the hidden degree)."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Serrano, M. \u00c1., Krioukov, D., & Bogu\u00f1\u00e1, M. (2008). Self-similarity\nof complex networks and hidden metric spaces. Physical review letters, 100(7), 078701.  [2]van der Kolk, J., Serrano, M. \u00c1., & Bogu\u00f1\u00e1, M. (2022). An anomalous\ntopological phase transition in spatial random graphs. Communications Physics, 5(1), 245.  [3]Krioukov, D., Papadopoulos, F., Kitsak, M., Vahdat, A., & Bogun\u00e1, M. (2010).\nHyperbolic geometry of complex networks. Physical Review E, 82(3), 036106.",
            "Examples": "Generate a network with specified parameters:\nG=nx.geometric_soft_configuration_graph(beta=1.5,n=100,gamma=2.7,mean_degree=5)\nCreate a geometric soft configuration graph with 100 nodes. The\\(\\beta\\)parameter\nis set to 1.5 and the exponent of the powerlaw distribution of the hidden\ndegrees is 2.7 with mean value of 5.\nGenerate a network with predefined hidden degrees:\nkappas={i:10foriinrange(100)}\nG=nx.geometric_soft_configuration_graph(beta=2.5,kappas=kappas)\nCreate a geometric soft configuration graph with 100 nodes. The\\(\\beta\\)parameter\nis set to 2.5 and all nodes with hidden degree\\(\\kappa=10\\)."
        }
    },
    {
        "Section ID": "min_weighted_dominating_set",
        "Description": [
            "Returns a dominating set that approximates the minimum weight node\ndominating set."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected graph.",
                "weight : string": "The node attribute storing the weight of an node. If provided,\nthe node attribute with this key must be a number for each\nnode. If not provided, each node is assumed to have weight one."
            },
            "Returns:": {
                "min_weight_dominating_set : set": "A set of nodes, the sum of whose weights is no more than(logw(V))w(V^*), wherew(V)denotes the sum of the weights of\neach node in the graph andw(V^*)denotes the sum of the\nweights of each node in the minimum weight dominating set."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is directed."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm computes an approximate minimum weighted dominating\nset for the graph G . The returned solution has weight (logw(V))w(V^*) , where w(V) denotes the sum of the weights of each\nnode in the graph and w(V^*) denotes the sum of the weights of\neach node in the minimum weight dominating set for the graph. This implementation of the algorithm runs in \\(O(m)\\) time, where \\(m\\) is the number of edges in the graph.",
            "References": "[1]Vazirani, Vijay V.Approximation Algorithms.\nSpringer Science & Business Media, 2001.",
            "Examples": "G=nx.Graph([(0,1),(0,4),(1,4),(1,2),(2,3),(3,4),(2,5)])\nnx.approximation.min_weighted_dominating_set(G)\n# {1, 2, 4}"
        }
    },
    {
        "Section ID": "circular_layout",
        "Description": [
            "Position nodes on a circle."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph or list of nodes": "A position will be assigned to every node in G.",
                "scale : number (default: 1)": "Scale factor for positions.",
                "center : array-like or None": "Coordinate pair around which to center the layout.",
                "dim : int": "Dimension of layout.\nIf dim>2, the remaining dimensions are set to zero\nin the returned positions.\nIf dim<2, a ValueError is raised."
            },
            "Returns:": {
                "pos : dict": "A dictionary of positions keyed by node"
            },
            "Raises:": {
                "ValueError": "If dim < 2"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm currently only works in two dimensions and does not\ntry to minimize edge crossings.",
            "Examples": "G=nx.path_graph(4)\npos=nx.circular_layout(G)"
        }
    },
    {
        "Section ID": "EdgeComponentAuxGraph",
        "Description": [
            "A simple algorithm to find all k-edge-connected components in a graph.",
            "Constructing the auxiliary graph (which may take some time) allows for the\nk-edge-ccs to be found in linear time for arbitrary k.",
            "Notes",
            "This implementation is based on [1] . The idea is to construct an auxiliary\ngraph from which the k-edge-ccs can be extracted in linear time. The\nauxiliary graph is constructed in \\(O(|V|\\cdot F)\\) operations, where F is the\ncomplexity of max flow. Querying the components takes an additional \\(O(|V|)\\) operations. This algorithm can be slow for large graphs, but it handles an\narbitrary k and works for both directed and undirected inputs.",
            "The undirected case for k=1 is exactly connected components.\nThe undirected case for k=2 is exactly bridge connected components.\nThe directed case for k=1 is exactly strongly connected components.",
            "References",
            "Examples",
            "The auxiliary graph is primarily used for k-edge-ccs but it\ncan also speed up the queries of k-edge-subgraphs by refining the\nsearch space."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This implementation is based on [1] . The idea is to construct an auxiliary\ngraph from which the k-edge-ccs can be extracted in linear time. The\nauxiliary graph is constructed in \\(O(|V|\\cdot F)\\) operations, where F is the\ncomplexity of max flow. Querying the components takes an additional \\(O(|V|)\\) operations. This algorithm can be slow for large graphs, but it handles an\narbitrary k and works for both directed and undirected inputs. The undirected case for k=1 is exactly connected components.\nThe undirected case for k=2 is exactly bridge connected components.\nThe directed case for k=1 is exactly strongly connected components.",
            "References": "[1]Wang, Tianhao, et al. (2015) A simple algorithm for finding all\nk-edge-connected components.http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0136264",
            "Examples": "importitertoolsasit\nfromnetworkx.utilsimportpairwise\nfromnetworkx.algorithms.connectivityimportEdgeComponentAuxGraph\n# Build an interesting graph with multiple levels of k-edge-ccs\npaths=[\n(1,2,3,4,1,3,4,2),# a 3-edge-cc (a 4 clique)\n(5,6,7,5),# a 2-edge-cc (a 3 clique)\n(1,5),# combine first two ccs into a 1-edge-cc\n(0,),# add an additional disconnected 1-edge-cc\n]\nG=nx.Graph()\nG.add_nodes_from(it.chain(*paths))\nG.add_edges_from(it.chain(*[pairwise(path)forpathinpaths]))\n# Constructing the AuxGraph takes about O(n ** 4)\naux_graph=EdgeComponentAuxGraph.construct(G)\n# Once constructed, querying takes O(n)\nsorted(map(sorted,aux_graph.k_edge_components(k=1)))\n# [[0], [1, 2, 3, 4, 5, 6, 7]]\nsorted(map(sorted,aux_graph.k_edge_components(k=2)))\n# [[0], [1, 2, 3, 4], [5, 6, 7]]\nsorted(map(sorted,aux_graph.k_edge_components(k=3)))\n# [[0], [1, 2, 3, 4], [5], [6], [7]]\nsorted(map(sorted,aux_graph.k_edge_components(k=4)))\n# [[0], [1], [2], [3], [4], [5], [6], [7]]\nThe auxiliary graph is primarily used for k-edge-ccs but it\ncan also speed up the queries of k-edge-subgraphs by refining the\nsearch space.\nimportitertoolsasit\nfromnetworkx.utilsimportpairwise\nfromnetworkx.algorithms.connectivityimportEdgeComponentAuxGraph\npaths=[\n(1,2,4,3,1,4),\n]\nG=nx.Graph()\nG.add_nodes_from(it.chain(*paths))\nG.add_edges_from(it.chain(*[pairwise(path)forpathinpaths]))\naux_graph=EdgeComponentAuxGraph.construct(G)\nsorted(map(sorted,aux_graph.k_edge_subgraphs(k=3)))\n# [[1], [2], [3], [4]]\nsorted(map(sorted,aux_graph.k_edge_components(k=3)))\n# [[1, 4], [2], [3]]"
        }
    },
    {
        "Section ID": "dfs_tree",
        "Description": [
            "Returns oriented tree constructed from a depth-first-search from source."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node, optional": "Specify starting node for depth-first search.",
                "depth_limit : int, optional (default=len(G))": "Specify the maximum search depth.",
                "sort_neighbors : function (default=None)": "A function that takes an iterator over nodes as the input, and\nreturns an iterable of the same nodes with a custom ordering.\nFor example,sortedwill sort the nodes in increasing order."
            },
            "Returns:": {
                "T : NetworkX DiGraph": "An oriented tree"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.path_graph(5)\nT=nx.dfs_tree(G,source=0,depth_limit=2)\nlist(T.edges())\n# [(0, 1), (1, 2)]\nT=nx.dfs_tree(G,source=0)\nlist(T.edges())\n# [(0, 1), (1, 2), (2, 3), (3, 4)]"
        }
    },
    {
        "Section ID": "attr_matrix",
        "Description": [
            "Returns the attribute matrix using attributes from G as a numpy array.",
            "If only G is passed in, then the adjacency matrix is constructed.",
            "Let A be a discrete set of values for the node attribute node_attr . Then\nthe elements of A represent the rows and columns of the constructed matrix.\nNow, iterate through every edge e=(u,v) in G and consider the value\nof the edge attribute edge_attr .  If ua and va are the values of the\nnode attribute node_attr for u and v, respectively, then the value of\nthe edge attribute is added to the matrix element at (ua, va)."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "The NetworkX graph used to construct the attribute matrix.",
                "edge_attr : str, optional": "Each element of the matrix represents a running total of the\nspecified edge attribute for edges whose node attributes correspond\nto the rows/cols of the matrix. The attribute must be present for\nall edges in the graph. If no attribute is specified, then we\njust count the number of edges whose node attributes correspond\nto the matrix element.",
                "node_attr : str, optional": "Each row and column in the matrix represents a particular value\nof the node attribute.  The attribute must be present for all nodes\nin the graph. Note, the values of this attribute should be reliably\nhashable. So, float values are not recommended. If no attribute is\nspecified, then the rows and columns will be the nodes of the graph.",
                "normalized : bool, optional": "If True, then each row is normalized by the summation of its values.",
                "rc_order : list, optional": "A list of the node attribute values. This list specifies the ordering\nof rows and columns of the array. If no ordering is provided, then\nthe ordering will be random (and also, a return value)."
            },
            "Returns:": {
                "M : 2D NumPy ndarray": "The attribute matrix.",
                "ordering : list": "Ifrc_orderwas specified, then only the attribute matrix is returned.\nHowever, ifrc_orderwas None, then the ordering used to construct\nthe matrix is returned as well."
            },
            "Other Parameters:": {
                "dtype : NumPy data-type, optional": "A valid NumPy dtype used to initialize the array. Keep in mind certain\ndtypes can yield unexpected results if the array is to be normalized.\nThe parameter is passed to numpy.zeros(). If unspecified, the NumPy\ndefault is used.",
                "order : {\u2018C\u2019, \u2018F\u2019}, optional": "Whether to store multidimensional data in C- or Fortran-contiguous\n(row- or column-wise) order in memory. This parameter is passed to\nnumpy.zeros(). If unspecified, the NumPy default is used."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "Construct an adjacency matrix:\nG=nx.Graph()\nG.add_edge(0,1,thickness=1,weight=3)\nG.add_edge(0,2,thickness=2)\nG.add_edge(1,2,thickness=3)\nnx.attr_matrix(G,rc_order=[0,1,2])\n# array([[0., 1., 1.],\n#        [1., 0., 1.],\n#        [1., 1., 0.]])\nAlternatively, we can obtain the matrix describing edge thickness.\nnx.attr_matrix(G,edge_attr=\"thickness\",rc_order=[0,1,2])\n# array([[0., 1., 2.],\n#        [1., 0., 3.],\n#        [2., 3., 0.]])\nWe can also color the nodes and ask for the probability distribution over\nall edges (u,v) describing:"
        }
    },
    {
        "Section ID": "is_regular_expander",
        "Description": [
            "Determines whether the graph G is a regular expander. [1]",
            "An expander graph is a sparse graph with strong connectivity properties.",
            "More precisely, this helper checks whether the graph is a\nregular \\((n, d, \\lambda)\\) -expander with \\(\\lambda\\) close to\nthe Alon-Boppana bound and given by \\(\\lambda = 2 \\sqrt{d - 1} + \\epsilon\\) . [2]",
            "In the case where \\(\\epsilon = 0\\) then if the graph successfully passes the test\nit is a Ramanujan graph. [3]",
            "A Ramanujan graph has spectral gap almost as large as possible, which makes them\nexcellent expanders."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "epsilon : int, float, default=0": ""
            },
            "Returns:": {
                "bool": "Whether the given graph is a regular\\((n, d, \\lambda)\\)-expander\nwhere\\(\\lambda = 2 \\sqrt{d - 1} + \\epsilon\\)."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Expander graph,https://en.wikipedia.org/wiki/Expander_graph  [2]Alon-Boppana bound,https://en.wikipedia.org/wiki/Alon%E2%80%93Boppana_bound  [3]Ramanujan graphs,https://en.wikipedia.org/wiki/Ramanujan_graph",
            "Examples": "G=nx.random_regular_expander_graph(20,4)\nnx.is_regular_expander(G)\n# True"
        }
    },
    {
        "Section ID": "barycenter",
        "Description": [
            "Calculate barycenter of a connected graph, optionally with edge weights.",
            "The barycenter a connected graph \\(G\\) is the subgraph induced by the set of its nodes \\(v\\) minimizing the objective function",
            "where \\(d_G\\) is the (possibly weighted) pathlength .\nThe barycenter is also called the median . See [West01] , p. 78."
        ],
        "Field List": {
            "Parameters:": {
                "G : networkx.Graph": "The connected graph\\(G\\).",
                "weight : str, optional": "Passed through toshortest_path_length().",
                "attr : str, optional": "If given, write the value of the objective function to each node\u2019sattrattribute. Otherwise do not store the value.",
                "sp : dict of dicts, optional": "All pairs shortest path lengths as a dictionary of dictionaries"
            },
            "Returns:": {
                "list": "Nodes ofGthat induce the barycenter ofG."
            },
            "Raises:": {
                "NetworkXNoPath": "IfGis disconnected.Gmay appear disconnected tobarycenter()ifspis given but is missing shortest path\nlengths for any pairs.",
                "ValueError": "Ifspandweightare both given."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph([(1,2),(1,3),(1,4),(3,4),(3,5),(4,5)])\nnx.barycenter(G)\n# [1, 3, 4]"
        }
    },
    {
        "Section ID": "k_factor",
        "Description": [
            "Compute a k-factor of G",
            "A k-factor of a graph is a spanning k-regular subgraph.\nA spanning k-regular subgraph of G is a subgraph that contains\neach vertex of G and a subset of the edges of G such that each\nvertex has degree k."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected graph",
                "matching_weight: string, optional (default=\u2019weight\u2019)": "Edge data key corresponding to the edge weight.\nUsed for finding the max-weighted perfect matching.\nIf key not found, uses 1 as weight."
            },
            "Returns:": {
                "G2 : NetworkX graph": "A k-factor of G"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]\u201cAn algorithm for computing simple k-factors.\u201d,\nMeijer, Henk, Yurai N\u00fa\u00f1ez-Rodr\u00edguez, and David Rappaport,\nInformation processing letters, 2009.",
            "Examples": "G=nx.Graph([(1,2),(2,3),(3,4),(4,1)])\nG2=nx.k_factor(G,k=1)\nG2.edges()\n# EdgeView([(1, 2), (3, 4)])"
        }
    },
    {
        "Section ID": "spiral_layout",
        "Description": [
            "Position nodes in a spiral layout."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph or list of nodes": "A position will be assigned to every node in G.",
                "scale : number (default: 1)": "Scale factor for positions.",
                "center : array-like or None": "Coordinate pair around which to center the layout.",
                "dim : int, default=2": "Dimension of layout, currently only dim=2 is supported.\nOther dimension values result in a ValueError.",
                "resolution : float, default=0.35": "The compactness of the spiral layout returned.\nLower values result in more compressed spiral layouts.",
                "equidistant : bool, default=False": "If True, nodes will be positioned equidistant from each other\nby decreasing angle further from center.\nIf False, nodes will be positioned at equal angles\nfrom each other by increasing separation further from center."
            },
            "Returns:": {
                "pos : dict": "A dictionary of positions keyed by node"
            },
            "Raises:": {
                "ValueError": "If dim != 2"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm currently only works in two dimensions.",
            "Examples": "G=nx.path_graph(4)\npos=nx.spiral_layout(G)\nnx.draw(G,pos=pos)"
        }
    },
    {
        "Section ID": "one_exchange",
        "Description": [
            "Compute a partitioning of the graphs nodes and the corresponding cut value.",
            "Use a greedy one exchange strategy to find a locally maximal cut\nand its value, it works by finding the best node (one that gives\nthe highest gain to the cut value) to add to the current cut\nand repeats this process until no improvement can be made."
        ],
        "Field List": {
            "Parameters:": {
                "G : networkx Graph": "Graph to find a maximum cut for.",
                "initial_cut : set": "Cut to use as a starting point. If not supplied the algorithm\nstarts with an empty cut.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "weight : object": "Edge attribute key to use as weight. If not specified, edges\nhave weight one."
            },
            "Returns:": {
                "cut_value : scalar": "Value of the maximum cut.",
                "partition : pair of node sets": "A partitioning of the nodes that defines a maximum cut."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the graph is directed or is a multigraph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.complete_graph(5)\ncurr_cut_size,partition=nx.approximation.one_exchange(G,seed=1)\ncurr_cut_size\n# 6\npartition\n# ({0, 2}, {1, 3, 4})"
        }
    },
    {
        "Section ID": "draw_spring",
        "Description": [
            "Draw the graph G with a spring layout.",
            "This is a convenience function equivalent to:"
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph",
                "kwargs : optional keywords": "Seedraw_networkxfor a description of optional keywords."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "spring_layout is also the default layout for draw , so this function is equivalent to draw . The layout is computed each time this function is called.\nFor repeated drawing it is much more efficient to call spring_layout directly and reuse the result:",
            "Examples": "G=nx.path_graph(20)\nnx.draw_spring(G)"
        }
    },
    {
        "Section ID": "node_connectivity",
        "Description": [
            "Returns an approximation for node connectivity for a graph or digraph G.",
            "Node connectivity is equal to the minimum number of nodes that\nmust be removed to disconnect G or render it trivial. By Menger\u2019s theorem,\nthis is equal to the number of node independent paths (paths that\nshare no nodes other than source and target).",
            "If source and target nodes are provided, this function returns the\nlocal node connectivity: the minimum number of nodes that must be\nremoved to break all paths from source to target in G.",
            "This algorithm is based on a fast approximation that gives an strict lower\nbound on the actual number of node independent paths between two nodes [1] .\nIt works for both directed and undirected graphs."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected graph",
                "s : node": "Source node. Optional. Default value: None.",
                "t : node": "Target node. Optional. Default value: None."
            },
            "Returns:": {
                "K : integer": "Node connectivity of G, or local node connectivity if source\nand target are provided."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm [1] finds node independents paths between two nodes by\ncomputing their shortest path using BFS, marking the nodes of the path\nfound as \u2018used\u2019 and then searching other shortest paths excluding the\nnodes marked as used until no more paths exist. It is not exact because\na shortest path could use nodes that, if the path were longer, may belong\nto two different node independent paths. Thus it only guarantees an\nstrict lower bound on node connectivity.",
            "References": "[1](1,2)White, Douglas R., and Mark Newman. 2001 A Fast Algorithm for\nNode-Independent Paths. Santa Fe Institute Working Paper #01-07-035http://eclectic.ss.uci.edu/~drwhite/working.pdf",
            "Examples": "# Platonic octahedral graph is 4-node-connected\nfromnetworkx.algorithmsimportapproximationasapprox\nG=nx.octahedral_graph()\napprox.node_connectivity(G)\n# 4"
        }
    },
    {
        "Section ID": "local_node_connectivity",
        "Description": [
            "Computes local node connectivity for nodes s and t.",
            "Local node connectivity for two non adjacent nodes s and t is the\nminimum number of nodes that must be removed (along with their incident\nedges) to disconnect them.",
            "This is a flow based implementation of node connectivity. We compute the\nmaximum flow on an auxiliary digraph build from the original input\ngraph (see below for details)."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected graph",
                "s : node": "Source node",
                "t : node": "Target node",
                "flow_func : function": "A function for computing the maximum flow among a pair of nodes.\nThe function has to accept at least three parameters: a Digraph,\na source node, and a target node. And return a residual network\nthat follows NetworkX conventions (seemaximum_flow()for\ndetails). If flow_func is None, the default maximum flow function\n(edmonds_karp()) is used. See below for details. The choice\nof the default function may change from version to version and\nshould not be relied on. Default value: None.",
                "auxiliary : NetworkX DiGraph": "Auxiliary digraph to compute flow based node connectivity. It has\nto have a graph attribute called mapping with a dictionary mapping\nnode names in G and in the auxiliary digraph. If provided\nit will be reused instead of recreated. Default value: None.",
                "residual : NetworkX DiGraph": "Residual network to compute maximum flow. If provided it will be\nreused instead of recreated. Default value: None.",
                "cutoff : integer, float, or None (default: None)": "If specified, the maximum flow algorithm will terminate when the\nflow value reaches or exceeds the cutoff. This only works for flows\nthat support the cutoff parameter (most do) and is ignored otherwise."
            },
            "Returns:": {
                "K : integer": "local node connectivity for nodes s and t"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This is a flow based implementation of node connectivity. We compute the\nmaximum flow using, by default, the edmonds_karp() algorithm (see: maximum_flow() ) on an auxiliary digraph build from the original\ninput graph: For an undirected graph G having n nodes and m edges we derive a\ndirected graph H with 2n nodes and 2m+n arcs by replacing each\noriginal node v with two nodes v_A , v_B linked by an (internal)\narc in H. Then for each edge ( u , v ) in G we add two arcs\n( u_B , v_A ) and ( v_B , u_A ) in H. Finally we set the attribute\ncapacity = 1 for each arc in H [1] . For a directed graph G having n nodes and m arcs we derive a\ndirected graph H with 2n nodes and m+n arcs by replacing each\noriginal node v with two nodes v_A , v_B linked by an (internal)\narc ( v_A , v_B ) in H. Then for each arc ( u , v ) in G we add one arc\n( u_B , v_A ) in H. Finally we set the attribute capacity = 1 for\neach arc in H. This is equal to the local node connectivity because the value of\na maximum s-t-flow is equal to the capacity of a minimum s-t-cut.",
            "References": "[1]Kammer, Frank and Hanjo Taubig. Graph Connectivity. in Brandes and\nErlebach, \u2018Network Analysis: Methodological Foundations\u2019, Lecture\nNotes in Computer Science, Volume 3418, Springer-Verlag, 2005.http://www.informatik.uni-augsburg.de/thi/personen/kammer/Graph_Connectivity.pdf",
            "Examples": "This function is not imported in the base NetworkX namespace, so you\nhave to explicitly import it from the connectivity package:\nfromnetworkx.algorithms.connectivityimportlocal_node_connectivity\nWe use in this example the platonic icosahedral graph, which has node\nconnectivity 5.\nG=nx.icosahedral_graph()\nlocal_node_connectivity(G,0,6)\n# 5\nIf you need to compute local connectivity on several pairs of\nnodes in the same graph, it is recommended that you reuse the\ndata structures that NetworkX uses in the computation: the\nauxiliary digraph for node connectivity, and the residual\nnetwork for the underlying maximum flow computation.\nExample of how to compute local node connectivity among\nall pairs of nodes of the platonic icosahedral graph reusing\nthe data structures.\nimportitertools\n# You also have to explicitly import the function for\n# building the auxiliary digraph from the connectivity package\nfromnetworkx.algorithms.connectivityimportbuild_auxiliary_node_connectivity\nH=build_auxiliary_node_connectivity(G)\n# And the function for building the residual network from the\n# flow package\nfromnetworkx.algorithms.flowimportbuild_residual_network\n# Note that the auxiliary digraph has an edge attribute named capacity\nR=build_residual_network(H,\"capacity\")\nresult=dict.fromkeys(G,dict())\n# Reuse the auxiliary digraph and the residual network by passing them\n# as parameters\nforu,vinitertools.combinations(G,2):\nk=local_node_connectivity(G,u,v,auxiliary=H,residual=R)\nresult[u][v]=k\nall(result[u][v]==5foru,vinitertools.combinations(G,2))\n# True\nYou can also use alternative flow algorithms for computing node\nconnectivity. For instance, in dense networks the algorithmshortest_augmenting_path()will usually perform better than\nthe defaultedmonds_karp()which is faster for sparse\nnetworks with highly skewed degree distributions. Alternative flow\nfunctions have to be explicitly imported from the flow package.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\nlocal_node_connectivity(G,0,6,flow_func=shortest_augmenting_path)\n# 5"
        }
    },
    {
        "Section ID": "davis_southern_women_graph",
        "Description": [
            "Returns Davis Southern women social network.",
            "This is a bipartite graph.",
            "References"
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]A. Davis, Gardner, B. B., Gardner, M. R., 1941. Deep South.\nUniversity of Chicago Press, Chicago, IL."
        }
    },
    {
        "Section ID": "bfs_layout",
        "Description": [
            "Position nodes according to breadth-first search algorithm."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A position will be assigned to every node in G.",
                "start : node inG": "Starting node for bfs",
                "center : array-like or None": "Coordinate pair around which to center the layout."
            },
            "Returns:": {
                "pos : dict": "A dictionary of positions keyed by node."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm currently only works in two dimensions and does not\ntry to minimize edge crossings.",
            "Examples": "G=nx.path_graph(4)\npos=nx.bfs_layout(G,0)"
        }
    },
    {
        "Section ID": "chromatic_polynomial",
        "Description": [
            "Returns the chromatic polynomial of G",
            "This function computes the chromatic polynomial via an iterative version of\nthe deletion-contraction algorithm.",
            "The chromatic polynomial X_G(x) is a fundamental graph polynomial\ninvariant in one variable. Evaluating X_G(k) for an natural number k enumerates the proper k-colorings of G .",
            "There are several equivalent definitions; here are three:",
            "Def 1 (explicit formula):\nFor G an undirected graph, c(G) the number of connected components of G , E the edge set of G , and G(S) the spanning subgraph of G with\nedge set S  [1] :",
            "Def 2 (interpolating polynomial):\nFor G an undirected graph, n(G) the number of vertices of G , k_0=0 ,\nand k_i the number of distinct ways to color the vertices of G with i unique colors (for i a natural number at most n(G) ), X_G(x) is the\nunique Lagrange interpolating polynomial of degree n(G) through the points (0,k_0),(1,k_1),dots,(n(G),k_{n(G)})  [2] .",
            "Def 3 (chromatic recurrence):\nFor G an undirected graph, G-e the graph obtained from G by deleting\nedge e , G/e the graph obtained from G by contracting edge e , n(G) the number of vertices of G , and e(G) the number of edges of G  [3] :",
            "This formulation is also known as the Fundamental Reduction Theorem [4] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": ""
            },
            "Returns:": {
                "instance of : sympy.core.add.Add": "A Sympy expression representing the chromatic polynomial forG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Interpretation of the coefficients is discussed in [5] . Several special\ncases are listed in [2] . The chromatic polynomial is a specialization of the Tutte polynomial; in\nparticular, X_G(x)=T_G(x,0)  [6] . The chromatic polynomial may take negative arguments, though evaluations\nmay not have chromatic interpretations. For instance, X_G(-1) enumerates\nthe acyclic orientations of G  [7] .",
            "References": "[1]D. B. West,\n\u201cIntroduction to Graph Theory,\u201d p. 222  [2](1,2)E. W. Weisstein\n\u201cChromatic Polynomial\u201d\nMathWorld\u2013A Wolfram Web Resourcehttps://mathworld.wolfram.com/ChromaticPolynomial.html  [3]D. B. West,\n\u201cIntroduction to Graph Theory,\u201d p. 221  [4]J. Zhang, J. Goodall,\n\u201cAn Introduction to Chromatic Polynomials\u201dhttps://math.mit.edu/~apost/courses/18.204_2018/Julie_Zhang_paper.pdf  [5]R. C. Read,\n\u201cAn Introduction to Chromatic Polynomials\u201d\nJournal of Combinatorial Theory, 1968https://math.berkeley.edu/~mrklug/ReadChromatic.pdf  [6]W. T. Tutte,\n\u201cGraph-polynomials\u201d\nAdvances in Applied Mathematics, 2004https://www.sciencedirect.com/science/article/pii/S0196885803000411  [7]R. P. Stanley,\n\u201cAcyclic orientations of graphs\u201d\nDiscrete Mathematics, 2006https://math.mit.edu/~rstan/pubs/pubfiles/18.pdf",
            "Examples": "C=nx.cycle_graph(5)\nnx.chromatic_polynomial(C)\n# x**5 - 5*x**4 + 10*x**3 - 10*x**2 + 4*x\nG=nx.complete_graph(4)\nnx.chromatic_polynomial(G)\n# x**4 - 6*x**3 + 11*x**2 - 6*x"
        }
    },
    {
        "Section ID": "parse_gml",
        "Description": [
            "Parse GML graph from a string or iterable."
        ],
        "Field List": {
            "Parameters:": {
                "lines : string or iterable of strings": "Data in GML format.",
                "label : string, optional": "If not None, the parsed nodes will be renamed according to node\nattributes indicated bylabel. Default value: \u2018label\u2019.",
                "destringizer : callable, optional": "Adestringizerthat recovers values stored as strings in GML. If it\ncannot convert a string to a value, aValueErroris raised. Default\nvalue : None."
            },
            "Returns:": {
                "G : NetworkX graph": "The parsed graph."
            },
            "Raises:": {
                "NetworkXError": "If the input cannot be parsed."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This stores nested GML attributes as dictionaries in the NetworkX graph,\nnode, and edge attribute structures. GML files are stored using a 7-bit ASCII encoding with any extended\nASCII characters (iso8859-1) appearing as HTML character entities.\nWithout specifying a stringizer / destringizer , the code is capable of\nwriting int / float / str / dict / list data as required by the GML\nspecification.  For writing other data types, and for reading data other\nthan str you need to explicitly supply a stringizer / destringizer . For additional documentation on the GML file format, please see the GML url . See the module docstring networkx.readwrite.gml for more details."
        }
    },
    {
        "Section ID": "directed_combinatorial_laplacian_matrix",
        "Description": [
            "Return the directed combinatorial Laplacian matrix of G.",
            "The graph directed combinatorial Laplacian is the matrix",
            "where P is the transition matrix of the graph and Phi a matrix\nwith the Perron vector of P in the diagonal and zeros elsewhere [1] .",
            "Depending on the value of walk_type, P can be the transition matrix\ninduced by a random walk, a lazy random walk, or a random walk with\nteleportation (PageRank)."
        ],
        "Field List": {
            "Parameters:": {
                "G : DiGraph": "A NetworkX graph",
                "nodelist : list, optional": "The rows and columns are ordered according to the nodes in nodelist.\nIf nodelist is None, then the ordering is produced by G.nodes().",
                "weight : string or None, optional (default=\u2019weight\u2019)": "The edge data key used to compute each value in the matrix.\nIf None, then each edge has weight 1.",
                "walk_type : string or None, optional (default=None)": "One of\"random\",\"lazy\", or\"pagerank\". Ifwalk_type=None(the default), then a value is selected according to the properties ofG:\n-walk_type=\"random\"ifGis strongly connected and aperiodic\n-walk_type=\"lazy\"ifGis strongly connected but not aperiodic\n-walk_type=\"pagerank\"for all other cases.",
                "alpha : real": "(1 - alpha) is the teleportation probability used with pagerank"
            },
            "Returns:": {
                "L : NumPy matrix": "Combinatorial Laplacian of G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Only implemented for DiGraphs The result is always a symmetric matrix. This calculation uses the out-degree of the graph G . To use the\nin-degree for calculations instead, use G.reverse(copy=False) and\ntake the transpose.",
            "References": "[1]Fan Chung (2005).\nLaplacians and the Cheeger inequality for directed graphs.\nAnnals of Combinatorics, 9(1), 2005"
        }
    },
    {
        "Section ID": "parse_edgelist",
        "Description": [
            "Parse lines of an edge list representation of a bipartite graph."
        ],
        "Field List": {
            "Parameters:": {
                "lines : list or iterator of strings": "Input data in edgelist format",
                "comments : string, optional": "Marker for comment lines",
                "delimiter : string, optional": "Separator for node labels",
                "create_using: NetworkX graph container, optional": "Use given NetworkX graph for holding nodes or edges.",
                "nodetype : Python type, optional": "Convert nodes to this type.",
                "data : bool or list of (label,type) tuples": "If False generate no edge data or if True use a dictionary\nrepresentation of edge data or a list tuples specifying dictionary\nkey names and types for edge data."
            },
            "Returns:": {
                "G: NetworkX Graph": "The bipartite graph corresponding to lines"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "Edgelist with no data:\nfromnetworkx.algorithmsimportbipartite\nlines=[\"1 2\",\"2 3\",\"3 4\"]\nG=bipartite.parse_edgelist(lines,nodetype=int)\nsorted(G.nodes())\n# [1, 2, 3, 4]\nsorted(G.nodes(data=True))\n# [(1, {'bipartite': 0}), (2, {'bipartite': 0}), (3, {'bipartite': 0}), (4, {'bipartite': 1})]\nsorted(G.edges())\n# [(1, 2), (2, 3), (3, 4)]\nEdgelist with data in Python dictionary representation:\nlines=[\"1 2 {'weight':3}\",\"2 3 {'weight':27}\",\"3 4 {'weight':3.0}\"]\nG=bipartite.parse_edgelist(lines,nodetype=int)\nsorted(G.nodes())\n# [1, 2, 3, 4]\nsorted(G.edges(data=True))\n# [(1, 2, {'weight': 3}), (2, 3, {'weight': 27}), (3, 4, {'weight': 3.0})]\nEdgelist with data in a list:\nlines=[\"1 2 3\",\"2 3 27\",\"3 4 3.0\"]\nG=bipartite.parse_edgelist(lines,nodetype=int,data=((\"weight\",float),))\nsorted(G.nodes())\n# [1, 2, 3, 4]\nsorted(G.edges(data=True))\n# [(1, 2, {'weight': 3.0}), (2, 3, {'weight': 27.0}), (3, 4, {'weight': 3.0})]"
        }
    },
    {
        "Section ID": "resistance_distance",
        "Description": [
            "Returns the resistance distance between pairs of nodes in graph G.",
            "The resistance distance between two nodes of a graph is akin to treating\nthe graph as a grid of resistors with a resistance equal to the provided\nweight [1] , [2] .",
            "If weight is not provided, then a weight of 1 is used for all edges.",
            "If two nodes are the same, the resistance distance is zero."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A graph",
                "nodeA : node or None, optional (default=None)": "A node within graph G.\nIf None, compute resistance distance using all nodes as source nodes.",
                "nodeB : node or None, optional (default=None)": "A node within graph G.\nIf None, compute resistance distance using all nodes as target nodes.",
                "weight : string or None, optional (default=None)": "The edge data key used to compute the resistance distance.\nIf None, then each edge has weight 1.",
                "invert_weight : boolean (default=True)": "Proper calculation of resistance distance requires building the\nLaplacian matrix with the reciprocal of the weight. Not required\nif the weight is already inverted. Weight cannot be zero."
            },
            "Returns:": {
                "rd : dict or float": "IfnodeAandnodeBare given, resistance distance betweennodeAandnodeB. IfnodeAornodeBis unspecified (the default), a\ndictionary of nodes with resistance distances as the value."
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis a directed graph.",
                "NetworkXError": "IfGis not connected, or contains no nodes,\nornodeAis not inGornodeBis not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The implementation is based on Theorem A in [2] . Self-loops are ignored.\nMulti-edges are contracted in one edge with weight equal to the harmonic sum of the weights.",
            "References": "[1]Wikipedia\n\u201cResistance distance.\u201dhttps://en.wikipedia.org/wiki/Resistance_distance  [2](1,2)D. J. Klein and M. Randic.\nResistance distance.\nJ. of Math. Chem. 12:81-95, 1993.",
            "Examples": "G=nx.Graph([(1,2),(1,3),(1,4),(3,4),(3,5),(4,5)])\nround(nx.resistance_distance(G,1,3),10)\n# 0.625"
        }
    },
    {
        "Section ID": "inverse_line_graph",
        "Description": [
            "Returns the inverse line graph of graph G.",
            "If H is a graph, and G is the line graph of H, such that G = L(H).\nThen H is the inverse line graph of G.",
            "Not all graphs are line graphs and these do not have an inverse line graph.\nIn these cases this function raises a NetworkXError."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX Graph"
            },
            "Returns:": {
                "H : graph": "The inverse line graph of G."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is directed or a multigraph",
                "NetworkXError": "If G is not a line graph"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This is an implementation of the Roussopoulos algorithm[R90abc5507a69-1]_. If G consists of multiple components, then the algorithm doesn\u2019t work.\nYou should invert every component separately:",
            "References": "[1]Roussopoulos, N.D. , \u201cA max {m, n} algorithm for determining the graph H from\nits line graph G\u201d, Information Processing Letters 2, (1973), 108\u2013112, ISSN 0020-0190,DOI link"
        }
    },
    {
        "Section ID": "dodecahedral_graph",
        "Description": [
            "Returns the Platonic Dodecahedral graph.",
            "The dodecahedral graph has 20 nodes and 30 edges. The skeleton of the\ndodecahedron forms a graph. It is one of 5 Platonic graphs [1] .\nIt can be described in LCF notation as: [10,7,4,-4,-7,10,-4,7,-7,4]^2  [2] ."
        ],
        "Field List": {
            "Parameters:": {
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : networkx Graph": "Dodecahedral Graph with 20 nodes and 30 edges"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://en.wikipedia.org/wiki/Regular_dodecahedron#Dodecahedral_graph  [2]https://mathworld.wolfram.com/DodecahedralGraph.html"
        }
    },
    {
        "Section ID": "to_sparse6_bytes",
        "Description": [
            "Convert an undirected graph to bytes in sparse6 format."
        ],
        "Field List": {
            "Parameters:": {
                "G : Graph (undirected)": "",
                "nodes: list or iterable": "Nodes are labeled 0\u2026n-1 in the order provided.  If None the ordering\ngiven byG.nodes()is used.",
                "header: bool": "If True add \u2018>>sparse6<<\u2019 bytes to head of data."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the graph is directed.",
                "ValueError": "If the graph has at least2**36nodes; the sparse6 format\nis only defined for graphs of order less than2**36."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The returned bytes end with a newline character. The format does not support edge or node labels.",
            "References": "[1]Graph6 specification\n<https://users.cecs.anu.edu.au/~bdm/data/formats.html>",
            "Examples": "nx.to_sparse6_bytes(nx.path_graph(2))\n# b'>>sparse6<<:An\\n'"
        }
    },
    {
        "Section ID": "faster_could_be_isomorphic",
        "Description": [
            "Returns False if graphs are definitely not isomorphic.",
            "True does NOT guarantee isomorphism."
        ],
        "Field List": {
            "Parameters:": {
                "G1, G2 : graphs": "The two graphs G1 and G2 must be the same type."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Checks for matching degree sequences."
        }
    },
    {
        "Section ID": "to_vertex_cover",
        "Description": [
            "Returns the minimum vertex cover corresponding to the given maximum\nmatching of the bipartite graph G ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected bipartite graph",
                "matching : dictionary": "A dictionary whose keys are vertices inGand whose values are the\ndistinct neighbors comprising the maximum matching forG, as returned\nby, for example,maximum_matching(). The dictionarymustrepresent the maximum matching.",
                "top_nodes : container": "Container with all nodes in one bipartite node set. If not supplied\nit will be computed. But if more than one solution exists an exception\nwill be raised."
            },
            "Returns:": {
                "vertex_cover : set": "The minimum vertex cover inG."
            },
            "Raises:": {
                "AmbiguousSolution": "Raised if the input bipartite graph is disconnected and no container\nwith all nodes in one bipartite set is provided. When determining\nthe nodes in each bipartite set more than one valid solution is\npossible if the input graph is disconnected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This function is implemented using the procedure guaranteed by Konig\u2019s\ntheorem ,\nwhich proves an equivalence between a maximum matching and a minimum vertex\ncover in bipartite graphs. Since a minimum vertex cover is the complement of a maximum independent set\nfor any graph, one can compute the maximum independent set of a bipartite\ngraph this way:"
        }
    },
    {
        "Section ID": "prominent_group",
        "Description": [
            "Find the prominent group of size \\(k\\) in graph \\(G\\) . The prominence of the\ngroup is evaluated by the group betweenness centrality.",
            "Group betweenness centrality of a group of nodes \\(C\\) is the sum of the\nfraction of all-pairs shortest paths that pass through any vertex in \\(C\\)",
            "where \\(V\\) is the set of nodes, \\(\\sigma(s, t)\\) is the number of\nshortest \\((s, t)\\) -paths, and \\(\\sigma(s, t|C)\\) is the number of\nthose paths passing through some node in group \\(C\\) . Note that \\((s, t)\\) are not members of the group ( \\(V-C\\) is the set of nodes\nin \\(V\\) that are not in \\(C\\) )."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.",
                "k : int": "The number of nodes in the group.",
                "normalized : bool, optional (default=True)": "If True, group betweenness is normalized by1/((|V|-|C|)(|V|-|C|-1))where|V|is the number of nodes in G and|C|is the number of\nnodes in C.",
                "weight : None or string, optional (default=None)": "If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight.\nThe weight of an edge is treated as the length or distance between the two sides.",
                "endpoints : bool, optional (default=False)": "If True include the endpoints in the shortest path counts.",
                "C : list or set, optional (default=None)": "list of nodes which won\u2019t be candidates of the prominent group.",
                "greedy : bool, optional (default=False)": "Using a naive greedy algorithm in order to find non-optimal prominent\ngroup. For scale free networks the results are negligibly below the optimal\nresults."
            },
            "Returns:": {
                "max_GBC : float": "The group betweenness centrality of the prominent group.",
                "max_group : list": "The list of nodes in the prominent group."
            },
            "Raises:": {
                "NodeNotFound": "If node(s) in C are not present in G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Group betweenness centrality is described in [1] and its importance discussed in [3] .\nThe algorithm is described in [2] and is based on techniques mentioned in [4] . The number of nodes in the group must be a maximum of n-2 where n is the total number of nodes in the graph. For weighted graphs the edge weights must be greater than zero.\nZero edge weights can produce an infinite number of equal length\npaths between pairs of nodes. The total number of paths between source and target is counted\ndifferently for directed and undirected graphs. Directed paths\nbetween \u201cu\u201d and \u201cv\u201d are counted as two possible paths (one each\ndirection) while undirected paths between \u201cu\u201d and \u201cv\u201d are counted\nas one path. Said another way, the sum in the expression above is\nover all s!=t for directed graphs and for s<t for undirected graphs.",
            "References": "[1]M G Everett and S P Borgatti:\nThe Centrality of Groups and Classes.\nJournal of Mathematical Sociology. 23(3): 181-201. 1999.http://www.analytictech.com/borgatti/group_centrality.htm  [2]Rami Puzis, Yuval Elovici, and Shlomi Dolev:\n\u201cFinding the Most Prominent Group in Complex Networks\u201d\nAI communications 20(4): 287-296, 2007.https://www.researchgate.net/profile/Rami_Puzis2/publication/220308855  [3]Sourav Medya et. al.:\nGroup Centrality Maximization via Network Design.\nSIAM International Conference on Data Mining, SDM 2018, 126\u2013134.https://sites.cs.ucsb.edu/~arlei/pubs/sdm18.pdf  [4]Rami Puzis, Yuval Elovici, and Shlomi Dolev.\n\u201cFast algorithm for successive computation of group betweenness centrality.\u201dhttps://journals.aps.org/pre/pdf/10.1103/PhysRevE.76.056709"
        }
    },
    {
        "Section ID": "edge_load_centrality",
        "Description": [
            "Compute edge load.",
            "WARNING: This concept of edge load has not been analysed\nor discussed outside of NetworkX that we know of.\nIt is based loosely on load_centrality in the sense that\nit counts the number of shortest paths which cross each edge.\nThis function is for demonstration and testing purposes."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph",
                "cutoff : bool, optional (default=False)": "If specified, only consider paths of length <= cutoff."
            },
            "Returns:": {
                "A dict keyed by edge 2-tuple to the number of shortest paths": "",
                "which use that edge. Where more than one path is shortest": "",
                "the count is divided equally among paths.": ""
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "intersection_array",
        "Description": [
            "Returns the intersection array of a distance-regular graph.",
            "Given a distance-regular graph G with integers b_i, c_i,i = 0,\u2026.,d\nsuch that for any 2 vertices x,y in G at a distance i=d(x,y), there\nare exactly c_i neighbors of y at a distance of i-1 from x and b_i\nneighbors of y at a distance of i+1 from x.",
            "A distance regular graph\u2019s intersection array is given by,\n[b_0,b_1,\u2026..b_{d-1};c_1,c_2,\u2026..c_d]"
        ],
        "Field List": {
            "Parameters:": {
                "G: Networkx graph (undirected)": ""
            },
            "Returns:": {
                "b,c: tuple of lists": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Weisstein, Eric W. \u201cIntersection Array.\u201d\nFrom MathWorld\u2013A Wolfram Web Resource.http://mathworld.wolfram.com/IntersectionArray.html",
            "Examples": "G=nx.icosahedral_graph()\nnx.intersection_array(G)\n# ([5, 2, 1], [1, 2, 5])"
        }
    },
    {
        "Section ID": "random_layout",
        "Description": [
            "Position nodes uniformly at random in the unit square.",
            "For every node, a position is generated by choosing each of dim\ncoordinates uniformly at random on the interval [0.0, 1.0).",
            "NumPy ( http://scipy.org ) is required for this function."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph or list of nodes": "A position will be assigned to every node in G.",
                "center : array-like or None": "Coordinate pair around which to center the layout.",
                "dim : int": "Dimension of layout.",
                "seed : int, RandomState instance or None  optional (default=None)": "Set the random state for deterministic node layouts.\nIf int,seedis the seed used by the random number generator,\nif numpy.random.RandomState instance,seedis the random\nnumber generator,\nif None, the random number generator is the RandomState instance used\nby numpy.random."
            },
            "Returns:": {
                "pos : dict": "A dictionary of positions keyed by node"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.lollipop_graph(4,3)\npos=nx.random_layout(G)"
        }
    },
    {
        "Section ID": "line_graph",
        "Description": [
            "Returns the line graph of the graph or digraph G .",
            "The line graph of a graph G has a node for each edge in G and an\nedge joining those nodes if the two edges in G share a common node. For\ndirected graphs, nodes are adjacent exactly when the edges they represent\nform a directed path of length two.",
            "The nodes of the line graph are 2-tuples of nodes in the original graph (or\n3-tuples for multigraphs, with the key of the edge as the third element).",
            "For information about self-loops and more discussion, see the Notes section below."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX Graph, DiGraph, MultiGraph, or MultiDigraph.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "L : graph": "The line graph of G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Graph, node, and edge data are not propagated to the new graph. For\nundirected graphs, the nodes in G must be sortable, otherwise the\nconstructed line graph may not be correct. Self-loops in undirected graphs For an undirected graph G without multiple edges, each edge can be\nwritten as a set {u,v} .  Its line graph L has the edges of G as\nits nodes. If x and y are two nodes in L , then {x,y} is an edge\nin L if and only if the intersection of x and y is nonempty. Thus,\nthe set of all edges is determined by the set of all pairwise intersections\nof edges in G . Trivially, every edge in G would have a nonzero intersection with itself,\nand so every node in L should have a self-loop. This is not so\ninteresting, and the original context of line graphs was with simple\ngraphs, which had no self-loops or multiple edges. The line graph was also\nmeant to be a simple graph and thus, self-loops in L are not part of the\nstandard definition of a line graph. In a pairwise intersection matrix,\nthis is analogous to excluding the diagonal entries from the line graph\ndefinition. Self-loops and multiple edges in G add nodes to L in a natural way, and\ndo not require any fundamental changes to the definition. It might be\nargued that the self-loops we excluded before should now be included.\nHowever, the self-loops are still \u201ctrivial\u201d in some sense and thus, are\nusually excluded. Self-loops in directed graphs For a directed graph G without multiple edges, each edge can be written\nas a tuple (u,v) . Its line graph L has the edges of G as its\nnodes. If x and y are two nodes in L , then (x,y) is an edge in L if and only if the tail of x matches the head of y , for example, if x=(a,b) and y=(b,c) for some vertices a , b , and c in G . Due to the directed nature of the edges, it is no longer the case that\nevery edge in G should have a self-loop in L . Now, the only time\nself-loops arise is if a node in G itself has a self-loop.  So such\nself-loops are no longer \u201ctrivial\u201d but instead, represent essential\nfeatures of the topology of G . For this reason, the historical\ndevelopment of line digraphs is such that self-loops are included. When the\ngraph G has multiple edges, once again only superficial changes are\nrequired to the definition.",
            "References": "Harary, Frank, and Norman, Robert Z., \u201cSome properties of line digraphs\u201d,\nRend. Circ. Mat. Palermo, II. Ser. 9 (1960), 161\u2013168.  Hemminger, R. L.; Beineke, L. W. (1978), \u201cLine graphs and line digraphs\u201d,\nin Beineke, L. W.; Wilson, R. J., Selected Topics in Graph Theory,\nAcademic Press Inc., pp. 271\u2013305.",
            "Examples": "G=nx.star_graph(3)\nL=nx.line_graph(G)\nprint(sorted(map(sorted,L.edges())))# makes a 3-clique, K3\n# [[(0, 1), (0, 2)], [(0, 1), (0, 3)], [(0, 2), (0, 3)]]\nEdge attributes fromGare not copied over as node attributes inL, but\nattributes can be copied manually:\nG=nx.path_graph(4)\nG.add_edges_from((u,v,{\"tot\":u+v})foru,vinG.edges)\nG.edges(data=True)\n# EdgeDataView([(0, 1, {'tot': 1}), (1, 2, {'tot': 3}), (2, 3, {'tot': 5})])\nH=nx.line_graph(G)\nH.add_nodes_from((node,G.edges[node])fornodeinH)\nH.nodes(data=True)\n# NodeDataView({(0, 1): {'tot': 1}, (2, 3): {'tot': 5}, (1, 2): {'tot': 3}})"
        }
    },
    {
        "Section ID": "number_weakly_connected_components",
        "Description": [
            "Returns the number of weakly connected components in G."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A directed graph."
            },
            "Returns:": {
                "n : integer": "Number of weakly connected components"
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For directed graphs only.",
            "Examples": "G=nx.DiGraph([(0,1),(2,1),(3,4)])\nnx.number_weakly_connected_components(G)\n# 2"
        }
    },
    {
        "Section ID": "non_randomness",
        "Description": [
            "Compute the non-randomness of graph G.",
            "The first returned value nr is the sum of non-randomness values of all\nedges within the graph (where the non-randomness of an edge tends to be\nsmall when the two nodes linked by that edge are from two different\ncommunities).",
            "The second computed value nr_rd is a relative measure that indicates\nto what extent graph G is different from random graphs in terms\nof probability. When it is close to 0, the graph tends to be more\nlikely generated by an Erdos Renyi model."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Graph must be symmetric, connected, and without self-loops.",
                "k : int": "The number of communities in G.\nIf k is not set, the function will use a default community\ndetection algorithm to set it.",
                "weight : string or None, optional (default=None)": "The name of an edge attribute that holds the numerical value used\nas a weight. If None, then each edge has weight 1, i.e., the graph is\nbinary."
            },
            "Returns:": {
                "non-randomness : (float, float) tuple": "Non-randomness, Relative non-randomness w.r.t.\nErdos Renyi random graphs."
            },
            "Raises:": {
                "NetworkXException": "if the input graph is not connected.",
                "NetworkXError": "if the input graph contains self-loops."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This computes Eq. (4.4) and (4.5) in Ref. [1] . If a weight field is passed, this algorithm will use the eigenvalues\nof the weighted adjacency matrix to compute Eq. (4.4) and (4.5).",
            "References": "[1]Xiaowei Ying and Xintao Wu,\nOn Randomness Measures for Social Networks,\nSIAM International Conference on Data Mining. 2009",
            "Examples": "G=nx.karate_club_graph()\nnr,nr_rd=nx.non_randomness(G,2)\nnr,nr_rd=nx.non_randomness(G,2,\"weight\")"
        }
    },
    {
        "Section ID": "draw_networkx_edges",
        "Description": [
            "Draw the edges of the graph G.",
            "This draws only the edges of the graph G."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph",
                "pos : dictionary": "A dictionary with nodes as keys and positions as values.\nPositions should be sequences of length 2.",
                "edgelist : collection of edge tuples (default=G.edges())": "Draw only specified edges",
                "width : float or array of floats (default=1.0)": "Line width of edges",
                "edge_color : color or array of colors (default=\u2019k\u2019)": "Edge color. Can be a single color or a sequence of colors with the same\nlength as edgelist. Color can be string or rgb (or rgba) tuple of\nfloats from 0-1. If numeric values are specified they will be\nmapped to colors using the edge_cmap and edge_vmin,edge_vmax parameters.",
                "style : string or array of strings (default=\u2019solid\u2019)": "Edge line style e.g.: \u2018-\u2019, \u2018\u2013\u2019, \u2018-.\u2019, \u2018:\u2019\nor words like \u2018solid\u2019 or \u2018dashed\u2019.\nCan be a single style or a sequence of styles with the same\nlength as the edge list.\nIf less styles than edges are given the styles will cycle.\nIf more styles than edges are given the styles will be used sequentially\nand not be exhausted.\nAlso,(offset,onoffseq)tuples can be used as style instead of a strings.\n(Seematplotlib.patches.FancyArrowPatch:linestyle)",
                "alpha : float or array of floats (default=None)": "The edge transparency.  This can be a single alpha value,\nin which case it will be applied to all specified edges. Otherwise,\nif it is an array, the elements of alpha will be applied to the colors\nin order (cycling through alpha multiple times if necessary).",
                "edge_cmap : Matplotlib colormap, optional": "Colormap for mapping intensities of edges",
                "edge_vmin,edge_vmax : floats, optional": "Minimum and maximum for edge colormap scaling",
                "ax : Matplotlib Axes object, optional": "Draw the graph in the specified Matplotlib axes.",
                "arrows : bool or None, optional (default=None)": "IfNone, directed graphs draw arrowheads withFancyArrowPatch, while undirected graphs draw edges\nviaLineCollectionfor speed.\nIfTrue, draw arrowheads with FancyArrowPatches (bendable and stylish).\nIfFalse, draw edges using LineCollection (linear and fast).Note: Arrowheads will be the same color as edges.",
                "arrowstyle : str (default=\u2019-|>\u2019 for directed graphs)": "For directed graphs andarrows==Truedefaults to \u2018-|>\u2019,\nFor undirected graphs default to \u2018-\u2018.Seematplotlib.patches.ArrowStylefor more options.",
                "arrowsize : int (default=10)": "For directed graphs, choose the size of the arrow head\u2019s length and\nwidth. Seematplotlib.patches.FancyArrowPatchfor attributemutation_scalefor more info.",
                "connectionstyle : string or iterable of strings (default=\u201darc3\u201d)": "Pass the connectionstyle parameter to create curved arc of rounding\nradius rad. For example, connectionstyle=\u2019arc3,rad=0.2\u2019.\nSeematplotlib.patches.ConnectionStyleandmatplotlib.patches.FancyArrowPatchfor more info.\nIf Iterable, index indicates i\u2019th edge key of MultiGraph",
                "node_size : scalar or array (default=300)": "Size of nodes. Though the nodes are not drawn with this function, the\nnode size is used in determining edge positioning.",
                "nodelist : list, optional (default=G.nodes())": "This provides the node order for thenode_sizearray (if it is an array).",
                "node_shape : string (default=\u2019o\u2019)": "The marker used for nodes, used in determining edge positioning.\nSpecification is as amatplotlib.markersmarker, e.g. one of \u2018so^>v<dph8\u2019.",
                "label : None or string": "Label for legend",
                "min_source_margin : int (default=0)": "The minimum margin (gap) at the beginning of the edge at the source.",
                "min_target_margin : int (default=0)": "The minimum margin (gap) at the end of the edge at the target.",
                "hide_ticks : bool, optional": "Hide ticks of axes. WhenTrue(the default), ticks and ticklabels\nare removed from the axes. To set ticks and tick labels to the pyplot default,\nusehide_ticks=False."
            },
            "Returns:": {
                "matplotlib.collections.LineCollection or a list of matplotlib.patches.FancyArrowPatch": "Ifarrows=True, a list of FancyArrowPatches is returned.\nIfarrows=False, a LineCollection is returned.\nIfarrows=None(the default), then a LineCollection is returned ifGis undirected, otherwise returns a list of FancyArrowPatches."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For directed graphs, arrows are drawn at the head end.  Arrows can be\nturned off with keyword arrows=False or by passing an arrowstyle without\nan arrow on the end. Be sure to include node_size as a keyword argument; arrows are\ndrawn considering the size of nodes. Self-loops are always drawn with FancyArrowPatch regardless of the value of arrows or whether G is directed.\nWhen arrows=False or arrows=None and G is undirected, the\nFancyArrowPatches corresponding to the self-loops are not explicitly\nreturned. They should instead be accessed via the Axes.patches attribute (see examples).",
            "Examples": "G=nx.dodecahedral_graph()\nedges=nx.draw_networkx_edges(G,pos=nx.spring_layout(G))\nG=nx.DiGraph()\nG.add_edges_from([(1,2),(1,3),(2,3)])\narcs=nx.draw_networkx_edges(G,pos=nx.spring_layout(G))\nalphas=[0.3,0.4,0.5]\nfori,arcinenumerate(arcs):# change alpha values of arcs\narc.set_alpha(alphas[i])\nThe FancyArrowPatches corresponding to self-loops are not always\nreturned, but can always be accessed via thepatchesattribute of thematplotlib.Axesobject.\nimportmatplotlib.pyplotasplt\nfig,ax=plt.subplots()\nG=nx.Graph([(0,1),(0,0)])# Self-loop at node 0\nedge_collection=nx.draw_networkx_edges(G,pos=nx.circular_layout(G),ax=ax)\nself_loop_fap=ax.patches[0]\nAlso see the NetworkX drawing examples athttps://networkx.org/documentation/latest/auto_examples/index.html"
        }
    },
    {
        "Section ID": "all_pairs_shortest_path",
        "Description": [
            "Compute shortest paths between all nodes."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "cutoff : integer, optional": "Depth at which to stop the search. Only paths of length at mostcutoffare returned."
            },
            "Returns:": {
                "paths : iterator": "Dictionary, keyed by source and target, of shortest paths."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "There may be multiple shortest paths with the same length between\ntwo nodes. For each pair, this function returns only one of those paths.",
            "Examples": "G=nx.path_graph(5)\npath=dict(nx.all_pairs_shortest_path(G))\nprint(path[0][4])\n# [0, 1, 2, 3, 4]"
        }
    },
    {
        "Section ID": "strongly_connected_components_recursive",
        "Description": [
            "Generate nodes in strongly connected components of graph.",
            "Recursive version of algorithm."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "A directed graph."
            },
            "Returns:": {
                "comp : generator of sets": "A generator of sets of nodes, one for each strongly connected\ncomponent of G."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Uses Tarjan\u2019s algorithm[Re7cb971df765-1]_ with Nuutila\u2019s modifications[Re7cb971df765-2]_.",
            "References": "[1]Depth-first search and linear graph algorithms, R. Tarjan\nSIAM Journal of Computing 1(2):146-160, (1972).  [2]On finding the strongly connected components in a directed graph.\nE. Nuutila and E. Soisalon-Soinen\nInformation Processing Letters 49(1): 9-14, (1994)..",
            "Examples": "Generate a sorted list of strongly connected components, largest first.\nG=nx.cycle_graph(4,create_using=nx.DiGraph())\nnx.add_cycle(G,[10,11,12])\n[\nlen(c)\nforcinsorted(\nnx.strongly_connected_components_recursive(G),key=len,reverse=True\n)\n]\n# [4, 3]\nIf you only want the largest component, it\u2019s more efficient to\nuse max instead of sort.\nlargest=max(nx.strongly_connected_components_recursive(G),key=len)\nTo create the induced subgraph of the components use:\n>>> S = [G.subgraph(c).copy() for c in nx.weakly_connected_components(G)]"
        }
    },
    {
        "Section ID": "dag_longest_path_length",
        "Description": [
            "Returns the longest path length in a DAG"
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX DiGraph": "A directed acyclic graph (DAG)",
                "weight : string, optional": "Edge data key to use for weight",
                "default_weight : int, optional": "The weight of edges that do not have a weight attribute"
            },
            "Returns:": {
                "int": "Longest path length"
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis not directed"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "DG=nx.DiGraph([(0,1,{\"cost\":1}),(1,2,{\"cost\":1}),(0,2,{\"cost\":42})])\nlist(nx.all_simple_paths(DG,0,2))\n# [[0, 1, 2], [0, 2]]\nnx.dag_longest_path_length(DG)\n# 2\nnx.dag_longest_path_length(DG,weight=\"cost\")\n# 42"
        }
    },
    {
        "Section ID": "is_partition",
        "Description": [
            "Returns True if communities is a partition of the nodes of G .",
            "A partition of a universe set is a family of pairwise disjoint sets\nwhose union is the entire universe set."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph.": "",
                "communities : list or iterable of sets of nodes": "If not a list, the iterable is converted internally to a list.\nIf it is an iterator it is exhausted."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "complete_to_chordal_graph",
        "Description": [
            "Return a copy of G completed to a chordal graph",
            "Adds edges to a copy of G to create a chordal graph. A graph G=(V,E) is\ncalled chordal if for each cycle with length bigger than 3, there exist\ntwo non-adjacent nodes connected by an edge (called a chord)."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected graph"
            },
            "Returns:": {
                "H : NetworkX graph": "The chordal enhancement of G",
                "alpha : Dictionary": "The elimination ordering of nodes of G"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "There are different approaches to calculate the chordal\nenhancement of a graph. The algorithm used here is called\nMCS-M and gives at least minimal (local) triangulation of graph. Note\nthat this triangulation is not necessarily a global minimum. https://en.wikipedia.org/wiki/Chordal_graph",
            "References": "[1]Berry, Anne & Blair, Jean & Heggernes, Pinar & Peyton, Barry. (2004)\nMaximum Cardinality Search for Computing Minimal Triangulations of\nGraphs.  Algorithmica. 39. 287-298. 10.1007/s00453-004-1084-3.",
            "Examples": "fromnetworkx.algorithms.chordalimportcomplete_to_chordal_graph\nG=nx.wheel_graph(10)\nH,alpha=complete_to_chordal_graph(G)"
        }
    },
    {
        "Section ID": "double_edge_swap",
        "Description": [
            "Swap two edges in the graph while keeping the node degrees fixed.",
            "A double-edge swap removes two randomly chosen edges u-v and x-y\nand creates the new edges u-x and v-y:",
            "If either the edge u-x or v-y already exist no swap is performed\nand another attempt is made to find a suitable edge pair."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "An undirected graph",
                "nswap : integer (optional, default=1)": "Number of double-edge swaps to perform",
                "max_tries : integer (optional)": "Maximum number of attempts to swap edges",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "G : graph": "The graph after double edge swaps."
            },
            "Raises:": {
                "NetworkXError": "IfGis directed, or\nIfnswap>max_tries, or\nIf there are fewer than 4 nodes or 2 edges inG.",
                "NetworkXAlgorithmError": "If the number of swap attempts exceedsmax_triesbeforenswapswaps are made"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Does not enforce any connectivity constraints. The graph G is modified in place."
        }
    },
    {
        "Section ID": "gnc_graph",
        "Description": [
            "Returns the growing network with copying (GNC) digraph with n nodes.",
            "The GNC graph is built by adding nodes one at a time with a link to one\npreviously added node (chosen uniformly at random) and to all of that\nnode\u2019s successors."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes for the generated graph.",
                "create_using : NetworkX graph constructor, optional (default DiGraph)": "Graph type to create. If graph instance, then cleared before populated.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]P. L. Krapivsky and S. Redner,\nNetwork Growth by Copying,\nPhys. Rev. E, 71, 036118, 2005k.},"
        }
    },
    {
        "Section ID": "min_weighted_vertex_cover",
        "Description": [
            "Returns an approximate minimum weighted vertex cover.",
            "The set of nodes returned by this function is guaranteed to be a\nvertex cover, and the total weight of the set is guaranteed to be at\nmost twice the total weight of the minimum weight vertex cover. In\nother words,",
            "where \\(S\\) is the vertex cover returned by this function, \\(S^*\\) is the vertex cover of minimum weight out of all vertex\ncovers of the graph, and \\(w\\) is the function that computes the\nsum of the weights of each node in that given set."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "weight : string, optional (default = None)": "If None, every node has weight 1. If a string, use this node\nattribute as the node weight. A node without this attribute is\nassumed to have weight 1."
            },
            "Returns:": {
                "min_weighted_cover : set": "Returns a set of nodes whose weight sum is no more than twice\nthe weight sum of the minimum weight vertex cover."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For a directed graph, a vertex cover has the same definition: a set\nof nodes such that each edge in the graph is incident to at least\none node in the set. Whether the node is the head or tail of the\ndirected edge is ignored. This is the local-ratio algorithm for computing an approximate\nvertex cover. The algorithm greedily reduces the costs over edges,\niteratively building a cover. The worst-case runtime of this\nimplementation is \\(O(m \\log n)\\) , where \\(n\\) is the number\nof nodes and \\(m\\) the number of edges in the graph.",
            "References": "[1]Bar-Yehuda, R., and Even, S. (1985). \u201cA local-ratio theorem for\napproximating the weighted vertex cover problem.\u201dAnnals of Discrete Mathematics, 25, 27\u201346\n<http://www.cs.technion.ac.il/~reuven/PDF/vc_lr.pdf>"
        }
    },
    {
        "Section ID": "edge_disjoint_paths",
        "Description": [
            "Returns the edges disjoint paths between source and target.",
            "Edge disjoint paths are paths that do not share any edge. The\nnumber of edge disjoint paths between source and target is equal\nto their edge connectivity."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "s : node": "Source node for the flow.",
                "t : node": "Sink node for the flow.",
                "flow_func : function": "A function for computing the maximum flow among a pair of nodes.\nThe function has to accept at least three parameters: a Digraph,\na source node, and a target node. And return a residual network\nthat follows NetworkX conventions (seemaximum_flow()for\ndetails). If flow_func is None, the default maximum flow function\n(edmonds_karp()) is used. The choice of the default function\nmay change from version to version and should not be relied on.\nDefault value: None.",
                "cutoff : integer or None (default: None)": "Maximum number of paths to yield. If specified, the maximum flow\nalgorithm will terminate when the flow value reaches or exceeds the\ncutoff. This only works for flows that support the cutoff parameter\n(most do) and is ignored otherwise.",
                "auxiliary : NetworkX DiGraph": "Auxiliary digraph to compute flow based edge connectivity. It has\nto have a graph attribute called mapping with a dictionary mapping\nnode names in G and in the auxiliary digraph. If provided\nit will be reused instead of recreated. Default value: None.",
                "residual : NetworkX DiGraph": "Residual network to compute maximum flow. If provided it will be\nreused instead of recreated. Default value: None."
            },
            "Returns:": {
                "paths : generator": "A generator of edge independent paths."
            },
            "Raises:": {
                "NetworkXNoPath": "If there is no path between source and target.",
                "NetworkXError": "If source or target are not in the graph G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This is a flow based implementation of edge disjoint paths. We compute\nthe maximum flow between source and target on an auxiliary directed\nnetwork. The saturated edges in the residual network after running the\nmaximum flow algorithm correspond to edge disjoint paths between source\nand target in the original network. This function handles both directed\nand undirected graphs, and can use all flow algorithms from NetworkX flow\npackage.",
            "Examples": "We use in this example the platonic icosahedral graph, which has node\nedge connectivity 5, thus there are 5 edge disjoint paths between any\npair of nodes.\nG=nx.icosahedral_graph()\nlen(list(nx.edge_disjoint_paths(G,0,6)))\n# 5\nIf you need to compute edge disjoint paths on several pairs of\nnodes in the same graph, it is recommended that you reuse the\ndata structures that NetworkX uses in the computation: the\nauxiliary digraph for edge connectivity, and the residual\nnetwork for the underlying maximum flow computation.\nExample of how to compute edge disjoint paths among all pairs of\nnodes of the platonic icosahedral graph reusing the data\nstructures.\nimportitertools\n# You also have to explicitly import the function for\n# building the auxiliary digraph from the connectivity package\nfromnetworkx.algorithms.connectivityimportbuild_auxiliary_edge_connectivity\nH=build_auxiliary_edge_connectivity(G)\n# And the function for building the residual network from the\n# flow package\nfromnetworkx.algorithms.flowimportbuild_residual_network\n# Note that the auxiliary digraph has an edge attribute named capacity\nR=build_residual_network(H,\"capacity\")\nresult={n:{}forninG}\n# Reuse the auxiliary digraph and the residual network by passing them\n# as arguments\nforu,vinitertools.combinations(G,2):\nk=len(list(nx.edge_disjoint_paths(G,u,v,auxiliary=H,residual=R)))\nresult[u][v]=k\nall(result[u][v]==5foru,vinitertools.combinations(G,2))\n# True\nYou can also use alternative flow algorithms for computing edge disjoint\npaths. For instance, in dense networks the algorithmshortest_augmenting_path()will usually perform better than\nthe defaultedmonds_karp()which is faster for sparse\nnetworks with highly skewed degree distributions. Alternative flow\nfunctions have to be explicitly imported from the flow package.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\nlen(list(nx.edge_disjoint_paths(G,0,6,flow_func=shortest_augmenting_path)))\n# 5"
        }
    },
    {
        "Section ID": "write_weighted_edgelist",
        "Description": [
            "Write graph G as a list of edges with numeric weights."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "path : file or string": "File or filename to write. If a file is provided, it must be\nopened in \u2018wb\u2019 mode.\nFilenames ending in .gz or .bz2 will be compressed.",
                "comments : string, optional": "The character used to indicate the start of a comment",
                "delimiter : string, optional": "The string used to separate values.  The default is whitespace.",
                "encoding: string, optional": "Specify which encoding to use when writing file."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph()\nG.add_edge(1,2,weight=7)\nnx.write_weighted_edgelist(G,\"test.weighted.edgelist\")"
        }
    },
    {
        "Section ID": "shell_layout",
        "Description": [
            "Position nodes in concentric circles."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph or list of nodes": "A position will be assigned to every node in G.",
                "nlist : list of lists": "List of node lists for each shell.",
                "rotate : angle in radians (default=pi/len(nlist))": "Angle by which to rotate the starting position of each shell\nrelative to the starting position of the previous shell.\nTo recreate behavior before v2.5 use rotate=0.",
                "scale : number (default: 1)": "Scale factor for positions.",
                "center : array-like or None": "Coordinate pair around which to center the layout.",
                "dim : int": "Dimension of layout, currently only dim=2 is supported.\nOther dimension values result in a ValueError."
            },
            "Returns:": {
                "pos : dict": "A dictionary of positions keyed by node"
            },
            "Raises:": {
                "ValueError": "If dim != 2"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm currently only works in two dimensions and does not\ntry to minimize edge crossings.",
            "Examples": "G=nx.path_graph(4)\nshells=[[0],[1,2,3]]\npos=nx.shell_layout(G,shells)"
        }
    },
    {
        "Section ID": "dinitz",
        "Description": [
            "Find a maximum single-commodity flow using Dinitz\u2019 algorithm.",
            "This function returns the residual network resulting after computing\nthe maximum flow. See below for details about the conventions\nNetworkX uses for defining residual networks.",
            "This algorithm has a running time of \\(O(n^2 m)\\) for \\(n\\) nodes and \\(m\\) edges [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Edges of the graph are expected to have an attribute called\n\u2018capacity\u2019. If this attribute is not present, the edge is\nconsidered to have infinite capacity.",
                "s : node": "Source node for the flow.",
                "t : node": "Sink node for the flow.",
                "capacity : string": "Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: \u2018capacity\u2019.",
                "residual : NetworkX graph": "Residual network on which the algorithm is to be executed. If None, a\nnew residual network is created. Default value: None.",
                "value_only : bool": "If True compute only the value of the maximum flow. This parameter\nwill be ignored by this algorithm because it is not applicable.",
                "cutoff : integer, float": "If specified, the algorithm will terminate when the flow value reaches\nor exceeds the cutoff. In this case, it may be unable to immediately\ndetermine a minimum cut. Default value: None."
            },
            "Returns:": {
                "R : NetworkX DiGraph": "Residual network after computing the maximum flow."
            },
            "Raises:": {
                "NetworkXError": "The algorithm does not support MultiGraph and MultiDiGraph. If\nthe input graph is an instance of one of these two classes, a\nNetworkXError is raised.",
                "NetworkXUnbounded": "If the graph has a path of infinite capacity, the value of a\nfeasible flow on the graph is unbounded above and the function\nraises a NetworkXUnbounded."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The residual network R from an input graph G has the\nsame nodes as G . R is a DiGraph that contains a pair\nof edges (u,v) and (v,u) iff (u,v) is not a\nself-loop, and at least one of (u,v) and (v,u) exists\nin G . For each edge (u,v) in R , R[u][v]['capacity'] is equal to the capacity of (u,v) in G if it exists\nin G or zero otherwise. If the capacity is infinite, R[u][v]['capacity'] will have a high arbitrary finite value\nthat does not affect the solution of the problem. This value is stored in R.graph['inf'] . For each edge (u,v) in R , R[u][v]['flow'] represents the flow function of (u,v) and\nsatisfies R[u][v]['flow']==-R[v][u]['flow'] . The flow value, defined as the total flow into t , the sink, is\nstored in R.graph['flow_value'] . If cutoff is not\nspecified, reachability to t using only edges (u,v) such\nthat R[u][v]['flow']<R[u][v]['capacity'] induces a minimum s - t cut.",
            "References": "[1]Dinitz\u2019 Algorithm: The Original Version and Even\u2019s Version.\n2006. Yefim Dinitz. In Theoretical Computer Science. Lecture\nNotes in Computer Science. Volume 3895. pp 218-240.https://doi.org/10.1007/11685654_10",
            "Examples": "fromnetworkx.algorithms.flowimportdinitz\nThe functions that implement flow algorithms and output a residual\nnetwork, such as this one, are not imported to the base NetworkX\nnamespace, so you have to explicitly import them from the flow package.\nG=nx.DiGraph()\nG.add_edge(\"x\",\"a\",capacity=3.0)\nG.add_edge(\"x\",\"b\",capacity=1.0)\nG.add_edge(\"a\",\"c\",capacity=3.0)\nG.add_edge(\"b\",\"c\",capacity=5.0)\nG.add_edge(\"b\",\"d\",capacity=4.0)\nG.add_edge(\"d\",\"e\",capacity=2.0)\nG.add_edge(\"c\",\"y\",capacity=2.0)\nG.add_edge(\"e\",\"y\",capacity=3.0)\nR=dinitz(G,\"x\",\"y\")\nflow_value=nx.maximum_flow_value(G,\"x\",\"y\")\nflow_value\n# 3.0\nflow_value==R.graph[\"flow_value\"]\n# True"
        }
    },
    {
        "Section ID": "is_minimal_d_separator",
        "Description": [
            "Determine if z is a minimal d-separator for x and y .",
            "A d-separator, z , in a DAG is a set of nodes that blocks\nall paths from nodes in set x to nodes in set y .\nA minimal d-separator is a d-separator z such that removing\nany subset of nodes makes it no longer a d-separator.",
            "Note: This function checks whether z is a d-separator AND is\nminimal. One can use the function is_d_separator to only check if z is a d-separator. See examples below."
        ],
        "Field List": {
            "Parameters:": {
                "G : nx.DiGraph": "A NetworkX DAG.",
                "x : node | set": "A node or set of nodes in the graph.",
                "y : node | set": "A node or set of nodes in the graph.",
                "z : node | set": "The node or set of nodes to check if it is a minimal d-separating set.\nThe functionis_d_separator()is called inside this function\nto verify thatzis in fact a d-separator.",
                "included : set | node | None": "A node or set of nodes which must be included in the found separating set,\ndefault isNone, which means the empty set.",
                "restricted : set | node | None": "Restricted node or set of nodes to consider. Only these nodes can be in\nthe found separating set, default isNonemeaning all nodes inG."
            },
            "Returns:": {
                "bool": "Whether or not the setzis a minimal d-separator subject torestrictednodes andincludednode constraints."
            },
            "Raises:": {
                "NetworkXError": "Raises aNetworkXErrorif the input graph is not a DAG.",
                "NodeNotFound": "If any of the input nodes are not found in the graph,\naNodeNotFoundexception is raised."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This function works on verifying that a set is minimal and\nd-separating between two nodes. Uses criterion (a), (b), (c) on\npage 4 of [1] . a) closure( x ) and y are disjoint. b) z contains\nall nodes from included and is contained in the restricted nodes and in the union of ancestors of x , y , and included .\nc) the nodes in z not in included are contained in both\nclosure(x) and closure(y). The closure of a set is the set of nodes\nconnected to the set by a directed path in G. The complexity is \\(O(m)\\) , where \\(m\\) stands for the\nnumber of edges in the subgraph of G consisting of only the\nancestors of x and y . For full details, see [1] .",
            "References": "[1](1,2)van der Zander, Benito, and Maciej Li\u015bkiewicz. \u201cFinding\nminimal d-separators in linear time and applications.\u201d In\nUncertainty in Artificial Intelligence, pp. 637-647. PMLR, 2020.",
            "Examples": "G=nx.path_graph([0,1,2,3],create_using=nx.DiGraph)\nG.add_node(4)\nnx.is_minimal_d_separator(G,0,2,{1})\n# True\n# since {1} is the minimal d-separator, {1, 3, 4} is not minimal\nnx.is_minimal_d_separator(G,0,2,{1,3,4})\n# False\n# alternatively, if we only want to check that {1, 3, 4} is a d-separator\nnx.is_d_separator(G,0,2,{1,3,4})\n# True"
        }
    },
    {
        "Section ID": "quotient_graph",
        "Description": [
            "Returns the quotient graph of G under the specified equivalence\nrelation on nodes."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "The graph for which to return the quotient graph with the\nspecified node relation.",
                "partition : function, or dict or list of lists, tuples or sets": "If a function, this function must represent an equivalence\nrelation on the nodes ofG. It must take two argumentsuandvand return True exactly whenuandvare in the\nsame equivalence class. The equivalence classes form the nodes\nin the returned graph.If a dict of lists/tuples/sets, the keys can be any meaningful\nblock labels, but the values must be the block lists/tuples/sets\n(one list/tuple/set per block), and the blocks must form a valid\npartition of the nodes of the graph. That is, each node must be\nin exactly one block of the partition.If a list of sets, the list must form a valid partition of\nthe nodes of the graph. That is, each node must be in exactly\none block of the partition.",
                "edge_relation : Boolean function with two arguments": "This function must represent an edge relation on theblocksof\nthepartitionofG. It must take two arguments,BandC,\neach one a set of nodes, and return True exactly when there should be\nan edge joining blockBto blockCin the returned graph.Ifedge_relationis not specified, it is assumed to be the\nfollowing relation. BlockBis related to blockCif and\nonly if some node inBis adjacent to some node inC,\naccording to the edge set ofG.",
                "node_data : function": "This function takes one argument,B, a set of nodes inG,\nand must return a dictionary representing the node data\nattributes to set on the node representingBin the quotient graph.\nIf None, the following node attributes will be set:\u2018graph\u2019, the subgraph of the graphGthat this block\nrepresents,\u2018nnodes\u2019, the number of nodes in this block,\u2018nedges\u2019, the number of edges within this block,\u2018density\u2019, the density of the subgraph ofGthat this\nblock represents.",
                "edge_data : function": "This function takes two arguments,BandC, each one a set\nof nodes, and must return a dictionary representing the edge\ndata attributes to set on the edge joiningBandC, should\nthere be an edge joiningBandCin the quotient graph (if\nno such edge occurs in the quotient graph as determined byedge_relation, then the output of this function is ignored).If the quotient graph would be a multigraph, this function is\nnot applied, since the edge data from each edge in the graphGappears in the edges of the quotient graph.",
                "weight : string or None, optional (default=\u201dweight\u201d)": "The name of an edge attribute that holds the numerical value\nused as a weight. If None then each edge has weight 1.",
                "relabel : bool": "If True, relabel the nodes of the quotient graph to be\nnonnegative integers. Otherwise, the nodes are identified withfrozensetinstances representing the blocks given inpartition.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "NetworkX graph": "The quotient graph ofGunder the equivalence relation\nspecified bypartition. If the partition were given as a\nlist ofsetinstances andrelabelis False,\neach node will be afrozensetcorresponding to the sameset."
            },
            "Raises:": {
                "NetworkXException": "If the given partition is not a valid partition of the nodes ofG."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Patrick Doreian, Vladimir Batagelj, and Anuska Ferligoj.Generalized Blockmodeling.\nCambridge University Press, 2004.",
            "Examples": "The quotient graph of the complete bipartite graph under the \u201csame\nneighbors\u201d equivalence relation isK_2. Under this relation, two nodes\nare equivalent if they are not adjacent but have the same neighbor set.\nG=nx.complete_bipartite_graph(2,3)\nsame_neighbors=lambdau,v:(unotinG[v]andvnotinG[u]andG[u]==G[v])\nQ=nx.quotient_graph(G,same_neighbors)\nK2=nx.complete_graph(2)\nnx.is_isomorphic(Q,K2)\n# True\nThe quotient graph of a directed graph under the \u201csame strongly connected\ncomponent\u201d equivalence relation is the condensation of the graph (seecondensation()). This example comes from the Wikipedia article`Strongly connected component`_.\nG=nx.DiGraph()\nedges=[\n\"ab\",\n\"be\",\n\"bf\",\n\"bc\",\n\"cg\",\n\"cd\",\n\"dc\",\n\"dh\",\n\"ea\",\n\"ef\",\n\"fg\",\n\"gf\",\n\"hd\",\n\"hf\",\n]\nG.add_edges_from(tuple(x)forxinedges)\ncomponents=list(nx.strongly_connected_components(G))\nsorted(sorted(component)forcomponentincomponents)\n# [['a', 'b', 'e'], ['c', 'd', 'h'], ['f', 'g']]\n\nC=nx.condensation(G,components)\ncomponent_of=C.graph[\"mapping\"]\nsame_component=lambdau,v:component_of[u]==component_of[v]\nQ=nx.quotient_graph(G,same_component)\nnx.is_isomorphic(C,Q)\n# True\nNode identification can be represented as the quotient of a graph under the\nequivalence relation that places the two nodes in one block and each other\nnode in its own singleton block.\nK24=nx.complete_bipartite_graph(2,4)\nK34=nx.complete_bipartite_graph(3,4)\nC=nx.contracted_nodes(K34,1,2)\nnodes={1,2}\nis_contracted=lambdau,v:uinnodesandvinnodes\nQ=nx.quotient_graph(K34,is_contracted)\nnx.is_isomorphic(Q,C)\n# True\nnx.is_isomorphic(Q,K24)\n# True\nThe blockmodeling technique described in[1]can be implemented as a\nquotient graph.\nG=nx.path_graph(6)\npartition=[{0,1},{2,3},{4,5}]\nM=nx.quotient_graph(G,partition,relabel=True)\nlist(M.edges())\n# [(0, 1), (1, 2)]\nHere is the sample example but using partition as a dict of block sets.\nG=nx.path_graph(6)\npartition={0:{0,1},2:{2,3},4:{4,5}}\nM=nx.quotient_graph(G,partition,relabel=True)\nlist(M.edges())\n# [(0, 1), (1, 2)]\nPartitions can be represented in various ways:"
        }
    },
    {
        "Section ID": "edge_betweenness_centrality",
        "Description": [
            "Compute betweenness centrality for edges.",
            "Betweenness centrality of an edge \\(e\\) is the sum of the\nfraction of all-pairs shortest paths that pass through \\(e\\)",
            "where \\(V\\) is the set of nodes, \\(\\sigma(s, t)\\) is the number of\nshortest \\((s, t)\\) -paths, and \\(\\sigma(s, t|e)\\) is the number of\nthose paths passing through edge \\(e\\)  [2] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.",
                "k : int, optional (default=None)": "If k is not None use k node samples to estimate betweenness.\nThe value of k <= n where n is the number of nodes in the graph.\nHigher values give better approximation.",
                "normalized : bool, optional": "If True the betweenness values are normalized by\\(2/(n(n-1))\\)for graphs, and\\(1/(n(n-1))\\)for directed graphs where\\(n\\)is the number of nodes in G.",
                "weight : None or string, optional (default=None)": "If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight.\nWeights are used to calculate weighted shortest paths, so they are\ninterpreted as distances.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.\nNote that this is only used if k is not None."
            },
            "Returns:": {
                "edges : dictionary": "Dictionary of edges with betweenness centrality as the value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The algorithm is from Ulrik Brandes [1] . For weighted graphs the edge weights must be greater than zero.\nZero edge weights can produce an infinite number of equal length\npaths between pairs of nodes.",
            "References": "[1]A Faster Algorithm for Betweenness Centrality. Ulrik Brandes,\nJournal of Mathematical Sociology 25(2):163-177, 2001.https://doi.org/10.1080/0022250X.2001.9990249  [2]Ulrik Brandes: On Variants of Shortest-Path Betweenness\nCentrality and their Generic Computation.\nSocial Networks 30(2):136-145, 2008.https://doi.org/10.1016/j.socnet.2007.11.001"
        }
    },
    {
        "Section ID": "fast_label_propagation_communities",
        "Description": [
            "Returns communities in G as detected by fast label propagation.",
            "The fast label propagation algorithm is described in [1] . The algorithm is\nprobabilistic and the found communities may vary in different executions.",
            "The algorithm operates as follows. First, the community label of each node is\nset to a unique label. The algorithm then repeatedly updates the labels of\nthe nodes to the most frequent label in their neighborhood. In case of ties,\na random label is chosen from the most frequent labels.",
            "The algorithm maintains a queue of nodes that still need to be processed.\nInitially, all nodes are added to the queue in a random order. Then the nodes\nare removed from the queue one by one and processed. If a node updates its label,\nall its neighbors that have a different label are added to the queue (if not\nalready in the queue). The algorithm stops when the queue is empty."
        ],
        "Field List": {
            "Parameters:": {
                "G : Graph, DiGraph, MultiGraph, or MultiDiGraph": "Any NetworkX graph.",
                "weight : string, or None (default)": "The edge attribute representing a non-negative weight of an edge. If None,\neach edge is assumed to have weight one. The weight of an edge is used in\ndetermining the frequency with which a label appears among the neighbors of\na node (edge with weightwis equivalent towunweighted edges).",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state. SeeRandomness."
            },
            "Returns:": {
                "communities : iterable": "Iterable of communities given as sets of nodes."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge directions are ignored for directed graphs.\nEdge weights must be non-negative numbers.",
            "References": "[1]Vincent A. Traag & Lovro \u0160ubelj. \u201cLarge network community detection by\nfast label propagation.\u201d Scientific Reports 13 (2023): 2701.https://doi.org/10.1038/s41598-023-29610-z"
        }
    },
    {
        "Section ID": "is_semiconnected",
        "Description": [
            "Returns True if the graph is semiconnected, False otherwise.",
            "A graph is semiconnected if and only if for any pair of nodes, either one\nis reachable from the other, or they are mutually reachable.",
            "This function uses a theorem that states that a DAG is semiconnected\nif for any topological sort, for node \\(v_n\\) in that sort, there is an\nedge \\((v_i, v_{i+1})\\) . That allows us to check if a non-DAG G is\nsemiconnected by condensing the graph: i.e. constructing a new graph H with nodes being the strongly connected components of G , and edges\n(scc_1, scc_2) if there is a edge \\((v_1, v_2)\\) in G for some \\(v_1 \\in scc_1\\) and \\(v_2 \\in scc_2\\) . That results in a DAG, so we compute\nthe topological sort of H and check if for every \\(n\\) there is an edge \\((scc_n, scc_{n+1})\\) ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A directed graph."
            },
            "Returns:": {
                "semiconnected : bool": "True if the graph is semiconnected, False otherwise."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the input graph is undirected.",
                "NetworkXPointlessConcept": "If the graph is empty."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.path_graph(4,create_using=nx.DiGraph())\nprint(nx.is_semiconnected(G))\n# True\nG=nx.DiGraph([(1,2),(3,2)])\nprint(nx.is_semiconnected(G))\n# False"
        }
    },
    {
        "Section ID": "dominating_set",
        "Description": [
            "Finds a dominating set for the graph G.",
            "A dominating set for a graph with node set V is a subset D of V such that every node not in D is adjacent to at least one\nmember of D  [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "start_with : node (default=None)": "Node to use as a starting point for the algorithm."
            },
            "Returns:": {
                "D : set": "A dominating set for G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This function is an implementation of algorithm 7 in [2] which\nfinds some dominating set, not necessarily the smallest one.",
            "References": "[1]https://en.wikipedia.org/wiki/Dominating_set  [2]Abdol-Hossein Esfahanian. Connectivity Algorithms.http://www.cse.msu.edu/~cse835/Papers/Graph_connectivity_revised.pdf"
        }
    },
    {
        "Section ID": "caveman_graph",
        "Description": [
            "Returns a caveman graph of l cliques of size k ."
        ],
        "Field List": {
            "Parameters:": {
                "l : int": "Number of cliques",
                "k : int": "Size of cliques"
            },
            "Returns:": {
                "G : NetworkX Graph": "caveman graph"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This returns an undirected graph, it can be converted to a directed\ngraph using nx.to_directed() , or a multigraph using nx.MultiGraph(nx.caveman_graph(l,k)) . Only the undirected version is\ndescribed in [1] and it is unclear which of the directed\ngeneralizations is most useful.",
            "References": "[1]Watts, D. J. \u2018Networks, Dynamics, and the Small-World Phenomenon.\u2019\nAmer. J. Soc. 105, 493-527, 1999.",
            "Examples": "G=nx.caveman_graph(3,3)"
        }
    },
    {
        "Section ID": "random_unlabeled_rooted_tree",
        "Description": [
            "Returns a number of unlabeled rooted trees uniformly at random",
            "Returns one or more (depending on number_of_trees )\nunlabeled rooted trees with n nodes drawn uniformly\nat random."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes",
                "number_of_trees : int or None (default)": "If not None, this number of trees is generated and returned.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "networkx.Graph : or list of : networkx.Graph": "A singlenetworkx.Graph(or a list thereof, ifnumber_of_treesis specified) with nodes in the set {0, \u2026,n- 1}.\nThe \u201croot\u201d graph attribute identifies the root of the tree."
            },
            "Raises:": {
                "NetworkXPointlessConcept": "Ifnis zero (because the null graph is not a tree)."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The trees are generated using the \u201cRANRUT\u201d algorithm from [1] .\nThe algorithm needs to compute some counting functions\nthat are relatively expensive: in case several trees are needed,\nit is advisable to use the number_of_trees optional argument\nto reuse the counting functions.",
            "References": "[1]Nijenhuis, Albert, and Wilf, Herbert S.\n\u201cCombinatorial algorithms: for computers and calculators.\u201d\nAcademic Press, 1978.https://doi.org/10.1016/C2013-0-11243-3"
        }
    },
    {
        "Section ID": "gnr_graph",
        "Description": [
            "Returns the growing network with redirection (GNR) digraph with n nodes and redirection probability p .",
            "The GNR graph is built by adding nodes one at a time with a link to one\npreviously added node.  The previous target node is chosen uniformly at\nrandom.  With probability p the link is instead \u201credirected\u201d to the\nsuccessor node of the target.",
            "The graph is always a (directed) tree."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes for the generated graph.",
                "p : float": "The redirection probability.",
                "create_using : NetworkX graph constructor, optional (default DiGraph)": "Graph type to create. If graph instance, then cleared before populated.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]P. L. Krapivsky and S. Redner,\nOrganization of Growing Random Networks,\nPhys. Rev. E, 63, 066123, 2001.",
            "Examples": "To create the undirected GNR graph, use theto_directed()method:\nD=nx.gnr_graph(10,0.5)# the GNR graph\nG=D.to_undirected()# the undirected version"
        }
    },
    {
        "Section ID": "random_graph",
        "Description": [
            "Returns a bipartite random graph.",
            "This is a bipartite version of the binomial (Erd\u0151s-R\u00e9nyi) graph.\nThe graph is composed of two partitions. Set A has nodes 0 to\n(n - 1) and set B has nodes n to (n + m - 1)."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes in the first bipartite set.",
                "m : int": "The number of nodes in the second bipartite set.",
                "p : float": "Probability for edge creation.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "directed : bool, optional (default=False)": "If True return a directed graph"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The bipartite random graph algorithm chooses each of the n*m (undirected)\nor 2*nm (directed) possible edges with probability p. This algorithm is \\(O(n+m)\\) where \\(m\\) is the expected number of edges. The nodes are assigned the attribute \u2018bipartite\u2019 with the value 0 or 1\nto indicate which bipartite set the node belongs to. This function is not imported in the main namespace.\nTo use it use nx.bipartite.random_graph",
            "References": "[1]Vladimir Batagelj and Ulrik Brandes,\n\u201cEfficient generation of large random networks\u201d,\nPhys. Rev. E, 71, 036113, 2005."
        }
    },
    {
        "Section ID": "multipartite_layout",
        "Description": [
            "Position nodes in layers of straight lines."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph or list of nodes": "A position will be assigned to every node in G.",
                "subset_key : string or dict (default=\u2019subset\u2019)": "If a string, the key of node data in G that holds the node subset.\nIf a dict, keyed by layer number to the nodes in that layer/subset.",
                "align : string (default=\u2019vertical\u2019)": "The alignment of nodes. Vertical or horizontal.",
                "scale : number (default: 1)": "Scale factor for positions.",
                "center : array-like or None": "Coordinate pair around which to center the layout."
            },
            "Returns:": {
                "pos : dict": "A dictionary of positions keyed by node."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm currently only works in two dimensions and does not\ntry to minimize edge crossings. Network does not need to be a complete multipartite graph. As long as nodes\nhave subset_key data, they will be placed in the corresponding layers.",
            "Examples": "G=nx.complete_multipartite_graph(28,16,10)\npos=nx.multipartite_layout(G)\nor use a dict to provide the layers of the layout\nG=nx.Graph([(0,1),(1,2),(1,3),(3,4)])\nlayers={\"a\":[0],\"b\":[1],\"c\":[2,3],\"d\":[4]}\npos=nx.multipartite_layout(G,subset_key=layers)"
        }
    },
    {
        "Section ID": "rescale_layout_dict",
        "Description": [
            "Return a dictionary of scaled positions keyed by node"
        ],
        "Field List": {
            "Parameters:": {
                "pos : A dictionary of positions keyed by node": "",
                "scale : number (default: 1)": "The size of the resulting extent in all directions."
            },
            "Returns:": {
                "pos : A dictionary of positions keyed by node": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "importnumpyasnp\npos={0:np.array((0,0)),1:np.array((1,1)),2:np.array((0.5,0.5))}\nnx.rescale_layout_dict(pos)\n# {0: array([-1., -1.]), 1: array([1., 1.]), 2: array([0., 0.])}\npos={0:np.array((0,0)),1:np.array((-1,1)),2:np.array((-0.5,0.5))}\nnx.rescale_layout_dict(pos,scale=2)\n# {0: array([ 2., -2.]), 1: array([-2.,  2.]), 2: array([0., 0.])}"
        }
    },
    {
        "Section ID": "is_empty",
        "Description": [
            "Returns True if G has no edges."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph."
            },
            "Returns:": {
                "bool": "True ifGhas no edges, and False otherwise."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "An empty graph can have nodes but not edges. The empty graph with zero\nnodes is known as the null graph. This is an \\(O(n)\\) operation where n\nis the number of nodes in the graph."
        }
    },
    {
        "Section ID": "communicability",
        "Description": [
            "Returns communicability between all pairs of nodes in G.",
            "The communicability between pairs of nodes in G is the sum of\nwalks of different lengths starting at node u and ending at node v."
        ],
        "Field List": {
            "Parameters:": {
                "G: graph": ""
            },
            "Returns:": {
                "comm: dictionary of dictionaries": "Dictionary of dictionaries keyed by nodes with communicability\nas the value."
            },
            "Raises:": {
                "NetworkXError": "If the graph is not undirected and simple."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm uses a spectral decomposition of the adjacency matrix.\nLet G=(V,E) be a simple undirected graph.  Using the connection between\nthe powers  of the adjacency matrix and the number of walks in the graph,\nthe communicability  between nodes u and v based on the graph spectrum\nis [1]",
            "References": "[1]Ernesto Estrada, Naomichi Hatano,\n\u201cCommunicability in complex networks\u201d,\nPhys. Rev. E 77, 036111 (2008).https://arxiv.org/abs/0707.0756",
            "Examples": "G=nx.Graph([(0,1),(1,2),(1,5),(5,4),(2,4),(2,3),(4,3),(3,6)])\nc=nx.communicability(G)"
        }
    },
    {
        "Section ID": "generate_network_text",
        "Description": [
            "Generate lines in the \u201cnetwork text\u201d format",
            "This works via a depth-first traversal of the graph and writing a line for\neach unique node encountered. Non-tree edges are written to the right of\neach node, and connection to a non-tree edge is indicated with an ellipsis.\nThis representation works best when the input graph is a forest, but any\ngraph can be represented.",
            "This notation is original to networkx, although it is simple enough that it\nmay be known in existing literature. See #5602 for details. The procedure\nis summarized as follows:",
            "1. Given a set of source nodes (which can be specified, or automatically\ndiscovered via finding the (strongly) connected components and choosing one\nnode with minimum degree from each), we traverse the graph in depth first\norder.",
            "4. The children of each node (wrt the directed DFS tree) are drawn\nunderneath and to the right of it. In the case that a child node has already\nbeen drawn the connection is replaced with an ellipsis (\u201d\u2026\u201d) to indicate\nthat there is one or more connections represented elsewhere.",
            "5. If a maximum depth is specified, an edge to nodes past this maximum\ndepth will be represented by an ellipsis.",
            "6. If a a node has a truthy \u201ccollapse\u201d value, then we do not traverse past\nthat node."
        ],
        "Field List": {
            "Parameters:": {
                "graph : nx.DiGraph | nx.Graph": "Graph to represent",
                "with_labels : bool | str": "If True will use the \u201clabel\u201d attribute of a node to display if it\nexists otherwise it will use the node value itself. If given as a\nstring, then that attribute name will be used instead of \u201clabel\u201d.\nDefaults to True.",
                "sources : List": "Specifies which nodes to start traversal from. Note: nodes that are not\nreachable from one of these sources may not be shown. If unspecified,\nthe minimal set of nodes needed to reach all others will be used.",
                "max_depth : int | None": "The maximum depth to traverse before stopping. Defaults to None.",
                "ascii_only : Boolean": "If True only ASCII characters are used to construct the visualization",
                "vertical_chains : Boolean": "If True, chains of nodes will be drawn vertically when possible."
            },
            "Yields:": {
                "str : a line of generated text": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "graph=nx.path_graph(10)\ngraph.add_node(\"A\")\ngraph.add_node(\"B\")\ngraph.add_node(\"C\")\ngraph.add_node(\"D\")\ngraph.add_edge(9,\"A\")\ngraph.add_edge(9,\"B\")\ngraph.add_edge(9,\"C\")\ngraph.add_edge(\"C\",\"D\")\ngraph.add_edge(\"C\",\"E\")\ngraph.add_edge(\"C\",\"F\")\nnx.write_network_text(graph)\n# \u2559\u2500\u2500 0\n#     \u2514\u2500\u2500 1\n#         \u2514\u2500\u2500 2\n#             \u2514\u2500\u2500 3\n#                 \u2514\u2500\u2500 4\n#                     \u2514\u2500\u2500 5\n#                         \u2514\u2500\u2500 6\n#                             \u2514\u2500\u2500 7\n#                                 \u2514\u2500\u2500 8\n#                                     \u2514\u2500\u2500 9\n#                                         \u251c\u2500\u2500 A\n#                                         \u251c\u2500\u2500 B\n#                                         \u2514\u2500\u2500 C\n#                                             \u251c\u2500\u2500 D\n#                                             \u251c\u2500\u2500 E\n#                                             \u2514\u2500\u2500 F\nnx.write_network_text(graph,vertical_chains=True)\n# \u2559\u2500\u2500 0\n#     \u2502\n#     1\n#     \u2502\n#     2\n#     \u2502\n#     3\n#     \u2502\n#     4\n#     \u2502\n#     5\n#     \u2502\n#     6\n#     \u2502\n#     7\n#     \u2502\n#     8\n#     \u2502\n#     9\n#     \u251c\u2500\u2500 A\n#     \u251c\u2500\u2500 B\n#     \u2514\u2500\u2500 C\n#         \u251c\u2500\u2500 D\n#         \u251c\u2500\u2500 E\n#         \u2514\u2500\u2500 F"
        }
    },
    {
        "Section ID": "dfs_successors",
        "Description": [
            "Returns dictionary of successors in depth-first-search from source."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node, optional": "Specify starting node for depth-first search.\nNote that you will get successors for all nodes in the\ncomponent containingsource. This input only specifies\nwhere the DFS starts.",
                "depth_limit : int, optional (default=len(G))": "Specify the maximum search depth.",
                "sort_neighbors : function (default=None)": "A function that takes an iterator over nodes as the input, and\nreturns an iterable of the same nodes with a custom ordering.\nFor example,sortedwill sort the nodes in increasing order."
            },
            "Returns:": {
                "succ: dict": "A dictionary with nodes as keys and list of successor nodes as values."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "If a source is not specified then a source is chosen arbitrarily and\nrepeatedly until all components in the graph are searched. The implementation of this function is adapted from David Eppstein\u2019s\ndepth-first search function in PADS , with modifications\nto allow depth limits based on the Wikipedia article\n\u201c Depth-limited search \u201d.",
            "Examples": "G=nx.path_graph(5)\nnx.dfs_successors(G,source=0)\n# {0: [1], 1: [2], 2: [3], 3: [4]}\nnx.dfs_successors(G,source=0,depth_limit=2)\n# {0: [1], 1: [2]}"
        }
    },
    {
        "Section ID": "random_kernel_graph",
        "Description": [
            "Returns an random graph based on the specified kernel.",
            "The algorithm chooses each of the \\([n(n-1)]/2\\) possible edges with\nprobability specified by a kernel \\(\\kappa(x,y)\\)  [1] .  The kernel \\(\\kappa(x,y)\\) must be a symmetric (in \\(x,y\\) ), non-negative,\nbounded function."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes",
                "kernel_integral : function": "Function that returns the definite integral of the kernel\\(\\kappa(x,y)\\),\\(F(y,a,b) := \\int_a^b \\kappa(x,y)dx\\)",
                "kernel_root: function (optional)": "Function that returns the root\\(b\\)of the equation\\(F(y,a,b) = r\\).\nIf None, the root is found usingscipy.optimize.brentq()(this requires SciPy).",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The kernel is specified through its definite integral which must be\nprovided as one of the arguments. If the integral and root of the\nkernel integral can be found in \\(O(1)\\) time then this algorithm runs in\ntime \\(O(n+m)\\) where m is the expected number of edges [2] . The nodes are set to integers from \\(0\\) to \\(n-1\\) .",
            "References": "[1]Bollob\u00e1s, B\u00e9la,  Janson, S. and Riordan, O.\n\u201cThe phase transition in inhomogeneous random graphs\u201d,Random Structures Algorithms, 31, 3\u2013122, 2007.  [2]Hagberg A, Lemons N (2015),\n\u201cFast Generation of Sparse Random Kernel Graphs\u201d.\nPLoS ONE 10(9): e0135177, 2015. doi:10.1371/journal.pone.0135177",
            "Examples": "Generate an Erd\u0151s\u2013R\u00e9nyi random graph\\(G(n,c/n)\\), with kernel\\(\\kappa(x,y)=c\\)where\\(c\\)is the mean expected degree.\ndefintegral(u,w,z):\nreturnc*(z-w)\ndefroot(u,w,r):\nreturnr/c+w\nc=1\ngraph=nx.random_kernel_graph(1000,integral,root)"
        }
    },
    {
        "Section ID": "traveling_salesman_problem",
        "Description": [
            "Find the shortest path in G connecting specified nodes",
            "This function allows approximate solution to the traveling salesman\nproblem on networks that are not complete graphs and/or where the\nsalesman does not need to visit all nodes.",
            "This function proceeds in two steps. First, it creates a complete\ngraph using the all-pairs shortest_paths between nodes in nodes .\nEdge weights in the new graph are the lengths of the paths\nbetween each pair of nodes in the original graph.\nSecond, an algorithm (default: christofides for undirected and asadpour_atsp for directed) is used to approximate the minimal Hamiltonian\ncycle on this new graph. The available algorithms are:",
            "Once the Hamiltonian Cycle is found, this function post-processes to\naccommodate the structure of the original graph. If cycle is False ,\nthe biggest weight edge is removed to make a Hamiltonian path.\nThen each edge on the new complete graph used for that analysis is\nreplaced by the shortest_path between those nodes on the original graph.\nIf the input graph G includes edges with weights that do not adhere to\nthe triangle inequality, such as when G is not a complete graph (i.e\nlength of non-existent edges is infinity), then the returned path may\ncontain some repeating nodes (other than the starting node)."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A possibly weighted graph",
                "nodes : collection of nodes (default=G.nodes)": "collection (list, set, etc.) of nodes to visit",
                "weight : string, optional (default=\u201dweight\u201d)": "Edge data key corresponding to the edge weight.\nIf any edge does not have this attribute the weight is set to 1.",
                "cycle : bool (default: True)": "Indicates whether a cycle should be returned, or a path.\nNote: the cycle is the approximate minimal cycle.\nThe path simply removes the biggest edge in that cycle.",
                "method : function (default: None)": "A function that returns a cycle on all nodes and approximates\nthe solution to the traveling salesman problem on a complete\ngraph. The returned cycle is then used to find a corresponding\nsolution onG.methodshould be callable; take inputsG, andweight; and return a list of nodes along the cycle.Provided options includechristofides(),greedy_tsp(),simulated_annealing_tsp()andthreshold_accepting_tsp().IfmethodisNone: usechristofides()for undirectedGandasadpour_atsp()for directedG.",
                "**kwargs : dict": "Other keyword arguments to be passed to themethodfunction passed in."
            },
            "Returns:": {
                "list": "List of nodes inGalong a path with an approximation of the minimal\npath throughnodes."
            },
            "Raises:": {
                "NetworkXError": "IfGis a directed graph it has to be strongly connected or the\ncomplete version cannot be generated."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "tsp=nx.approximation.traveling_salesman_problem\nG=nx.cycle_graph(9)\nG[4][5][\"weight\"]=5# all other weights are 1\ntsp(G,nodes=[3,6])\n# [3, 2, 1, 0, 8, 7, 6, 7, 8, 0, 1, 2, 3]\npath=tsp(G,cycle=False)\npathin([4,3,2,1,0,8,7,6,5],[5,6,7,8,0,1,2,3,4])\n# True\nWhile no longer required, you can still build (curry) your own function\nto provide parameter values to the methods.\nSA_tsp=nx.approximation.simulated_annealing_tsp\nmethod=lambdaG,weight:SA_tsp(G,\"greedy\",weight=weight,temp=500)\npath=tsp(G,cycle=False,method=method)\npathin([4,3,2,1,0,8,7,6,5],[5,6,7,8,0,1,2,3,4])\n# True\nOtherwise, pass other keyword arguments directly into the tsp function.\npath=tsp(\nG,\ncycle=False,\nmethod=nx.approximation.simulated_annealing_tsp,\ninit_cycle=\"greedy\",\ntemp=500,\n)\npathin([4,3,2,1,0,8,7,6,5],[5,6,7,8,0,1,2,3,4])\n# True"
        }
    },
    {
        "Section ID": "k_shell",
        "Description": [
            "Returns the k-shell of G.",
            "The k-shell is the subgraph induced by nodes with core number k.\nThat is, nodes in the k-core that are not in the (k+1)-core."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A graph or directed graph.",
                "k : int, optional": "The order of the shell. If not specified return the outer shell.",
                "core_number : dictionary, optional": "Precomputed core numbers for the graph G."
            },
            "Returns:": {
                "G : NetworkX graph": "The k-shell subgraph"
            },
            "Raises:": {
                "NetworkXNotImplemented": "The k-shell is not implemented for multigraphs or graphs with self loops."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This is similar to k_corona but in that case only neighbors in the\nk-core are considered. For directed graphs the node degree is defined to be the\nin-degree + out-degree. Graph, node, and edge attributes are copied to the subgraph.",
            "References": "[1]A model of Internet topology using k-shell decomposition\nShai Carmi, Shlomo Havlin, Scott Kirkpatrick, Yuval Shavitt,\nand Eran Shir, PNAS  July 3, 2007   vol. 104  no. 27  11150-11154http://www.pnas.org/content/104/27/11150.full",
            "Examples": "degrees=[0,1,2,2,2,2,3]\nH=nx.havel_hakimi_graph(degrees)\nH.degree\n# DegreeView({0: 1, 1: 2, 2: 2, 3: 2, 4: 2, 5: 3, 6: 0})\nnx.k_shell(H,k=1).nodes\n# NodeView((0, 4))"
        }
    },
    {
        "Section ID": "number_strongly_connected_components",
        "Description": [
            "Returns number of strongly connected components in graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A directed graph."
            },
            "Returns:": {
                "n : integer": "Number of strongly connected components"
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For directed graphs only.",
            "Examples": "G=nx.DiGraph(\n[(0,1),(1,2),(2,0),(2,3),(4,5),(3,4),(5,6),(6,3),(6,7)]\n)\nnx.number_strongly_connected_components(G)\n# 3"
        }
    },
    {
        "Section ID": "directed_laplacian_matrix",
        "Description": [
            "Returns the directed Laplacian matrix of G.",
            "The graph directed Laplacian is the matrix",
            "where I is the identity matrix, P is the transition matrix of the\ngraph, and Phi a matrix with the Perron vector of P in the diagonal and\nzeros elsewhere [1] .",
            "Depending on the value of walk_type, P can be the transition matrix\ninduced by a random walk, a lazy random walk, or a random walk with\nteleportation (PageRank)."
        ],
        "Field List": {
            "Parameters:": {
                "G : DiGraph": "A NetworkX graph",
                "nodelist : list, optional": "The rows and columns are ordered according to the nodes in nodelist.\nIf nodelist is None, then the ordering is produced by G.nodes().",
                "weight : string or None, optional (default=\u2019weight\u2019)": "The edge data key used to compute each value in the matrix.\nIf None, then each edge has weight 1.",
                "walk_type : string or None, optional (default=None)": "One of\"random\",\"lazy\", or\"pagerank\". Ifwalk_type=None(the default), then a value is selected according to the properties ofG:\n-walk_type=\"random\"ifGis strongly connected and aperiodic\n-walk_type=\"lazy\"ifGis strongly connected but not aperiodic\n-walk_type=\"pagerank\"for all other cases.",
                "alpha : real": "(1 - alpha) is the teleportation probability used with pagerank"
            },
            "Returns:": {
                "L : NumPy matrix": "Normalized Laplacian of G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Only implemented for DiGraphs The result is always a symmetric matrix. This calculation uses the out-degree of the graph G . To use the\nin-degree for calculations instead, use G.reverse(copy=False) and\ntake the transpose.",
            "References": "[1]Fan Chung (2005).\nLaplacians and the Cheeger inequality for directed graphs.\nAnnals of Combinatorics, 9(1), 2005"
        }
    },
    {
        "Section ID": "shortest_simple_paths",
        "Description": [],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node": "Starting node for path",
                "target : node": "Ending node for path",
                "weight : string or function": "If it is a string, it is the name of the edge attribute to be\nused as a weight.If it is a function, the weight of an edge is the value returned\nby the function. The function must accept exactly three positional\narguments: the two endpoints of an edge and the dictionary of edge\nattributes for that edge. The function must return a number.If None all edges are considered to have unit weight. Default\nvalue None."
            },
            "Returns:": {
                "path_generator: generator": "A generator that produces lists of simple paths, in order from\nshortest to longest."
            },
            "Raises:": {
                "NetworkXNoPath": "If no path exists between source and target.",
                "NetworkXError": "If source or target nodes are not in the input graph.",
                "NetworkXNotImplemented": "If the input graph is a Multi[Di]Graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This procedure is based on algorithm by Jin Y. Yen [1] .  Finding\nthe first \\(K\\) paths requires \\(O(KN^3)\\) operations.",
            "References": "[1]Jin Y. Yen, \u201cFinding the K Shortest Loopless Paths in a\nNetwork\u201d, Management Science, Vol. 17, No. 11, Theory Series\n(Jul., 1971), pp. 712-716.",
            "Examples": "G=nx.cycle_graph(7)\npaths=list(nx.shortest_simple_paths(G,0,3))\nprint(paths)\n# [[0, 1, 2, 3], [0, 6, 5, 4, 3]]\nYou can use this function to efficiently compute the k shortest/best\npaths between two nodes.\nfromitertoolsimportislice\ndefk_shortest_paths(G,source,target,k,weight=None):\nreturnlist(\nislice(nx.shortest_simple_paths(G,source,target,weight=weight),k)\n)\nforpathink_shortest_paths(G,0,3,2):\nprint(path)\n# [0, 1, 2, 3]\n# [0, 6, 5, 4, 3]"
        }
    },
    {
        "Section ID": "christofides",
        "Description": [
            "Approximate a solution of the traveling salesman problem",
            "Compute a 3/2-approximation of the traveling salesman problem\nin a complete undirected graph using Christofides [1] algorithm."
        ],
        "Field List": {
            "Parameters:": {
                "G : Graph": "Gshould be a complete weighted undirected graph.\nThe distance between all pairs of nodes should be included.",
                "weight : string, optional (default=\u201dweight\u201d)": "Edge data key corresponding to the edge weight.\nIf any edge does not have this attribute the weight is set to 1.",
                "tree : NetworkX graph or None (default: None)": "A minimum spanning tree of G. Or, if None, the minimum spanning\ntree is computed usingnetworkx.minimum_spanning_tree()"
            },
            "Returns:": {
                "list": "List of nodes inGalong a cycle with a 3/2-approximation of\nthe minimal Hamiltonian cycle."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Christofides, Nicos. \u201cWorst-case analysis of a new heuristic for\nthe travelling salesman problem.\u201d No. RR-388. Carnegie-Mellon Univ\nPittsburgh Pa Management Sciences Research Group, 1976."
        }
    },
    {
        "Section ID": "icosahedral_graph",
        "Description": [
            "Returns the Platonic Icosahedral graph.",
            "The icosahedral graph has 12 nodes and 30 edges. It is a Platonic graph\nwhose nodes have the connectivity of the icosahedron. It is undirected,\nregular and Hamiltonian [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : networkx Graph": "Icosahedral graph with 12 nodes and 30 edges."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://mathworld.wolfram.com/IcosahedralGraph.html"
        }
    },
    {
        "Section ID": "is_locally_k_edge_connected",
        "Description": [
            "Tests to see if an edge in a graph is locally k-edge-connected.",
            "Is it impossible to disconnect s and t by removing fewer than k edges?\nIf so, then s and t are locally k-edge-connected in G."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "An undirected graph.",
                "s : node": "Source node",
                "t : node": "Target node",
                "k : integer": "local edge connectivity for nodes s and t"
            },
            "Returns:": {
                "boolean": "True if s and t are locally k-edge-connected in G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "fromnetworkx.algorithms.connectivityimportis_locally_k_edge_connected\nG=nx.barbell_graph(10,0)\nis_locally_k_edge_connected(G,5,15,k=1)\n# True\nis_locally_k_edge_connected(G,5,15,k=2)\n# False\nis_locally_k_edge_connected(G,1,5,k=2)\n# True"
        }
    },
    {
        "Section ID": "preflow_push",
        "Description": [
            "Find a maximum single-commodity flow using the highest-label\npreflow-push algorithm.",
            "This function returns the residual network resulting after computing\nthe maximum flow. See below for details about the conventions\nNetworkX uses for defining residual networks.",
            "This algorithm has a running time of \\(O(n^2 \\sqrt{m})\\) for \\(n\\) nodes and \\(m\\) edges."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Edges of the graph are expected to have an attribute called\n\u2018capacity\u2019. If this attribute is not present, the edge is\nconsidered to have infinite capacity.",
                "s : node": "Source node for the flow.",
                "t : node": "Sink node for the flow.",
                "capacity : string": "Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: \u2018capacity\u2019.",
                "residual : NetworkX graph": "Residual network on which the algorithm is to be executed. If None, a\nnew residual network is created. Default value: None.",
                "global_relabel_freq : integer, float": "Relative frequency of applying the global relabeling heuristic to speed\nup the algorithm. If it is None, the heuristic is disabled. Default\nvalue: 1.",
                "value_only : bool": "If False, compute a maximum flow; otherwise, compute a maximum preflow\nwhich is enough for computing the maximum flow value. Default value:\nFalse."
            },
            "Returns:": {
                "R : NetworkX DiGraph": "Residual network after computing the maximum flow."
            },
            "Raises:": {
                "NetworkXError": "The algorithm does not support MultiGraph and MultiDiGraph. If\nthe input graph is an instance of one of these two classes, a\nNetworkXError is raised.",
                "NetworkXUnbounded": "If the graph has a path of infinite capacity, the value of a\nfeasible flow on the graph is unbounded above and the function\nraises a NetworkXUnbounded."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The residual network R from an input graph G has the\nsame nodes as G . R is a DiGraph that contains a pair\nof edges (u,v) and (v,u) iff (u,v) is not a\nself-loop, and at least one of (u,v) and (v,u) exists\nin G . For each node u in R , R.nodes[u]['excess'] represents the difference between flow into u and flow out of u . For each edge (u,v) in R , R[u][v]['capacity'] is equal to the capacity of (u,v) in G if it exists\nin G or zero otherwise. If the capacity is infinite, R[u][v]['capacity'] will have a high arbitrary finite value\nthat does not affect the solution of the problem. This value is stored in R.graph['inf'] . For each edge (u,v) in R , R[u][v]['flow'] represents the flow function of (u,v) and\nsatisfies R[u][v]['flow']==-R[v][u]['flow'] . The flow value, defined as the total flow into t , the sink, is\nstored in R.graph['flow_value'] . Reachability to t using\nonly edges (u,v) such that R[u][v]['flow']<R[u][v]['capacity'] induces a minimum s - t cut.",
            "Examples": "fromnetworkx.algorithms.flowimportpreflow_push\nThe functions that implement flow algorithms and output a residual\nnetwork, such as this one, are not imported to the base NetworkX\nnamespace, so you have to explicitly import them from the flow package.\nG=nx.DiGraph()\nG.add_edge(\"x\",\"a\",capacity=3.0)\nG.add_edge(\"x\",\"b\",capacity=1.0)\nG.add_edge(\"a\",\"c\",capacity=3.0)\nG.add_edge(\"b\",\"c\",capacity=5.0)\nG.add_edge(\"b\",\"d\",capacity=4.0)\nG.add_edge(\"d\",\"e\",capacity=2.0)\nG.add_edge(\"c\",\"y\",capacity=2.0)\nG.add_edge(\"e\",\"y\",capacity=3.0)\nR=preflow_push(G,\"x\",\"y\")\nflow_value=nx.maximum_flow_value(G,\"x\",\"y\")\nflow_value==R.graph[\"flow_value\"]\n# True\n# preflow_push also stores the maximum flow value\n# in the excess attribute of the sink node t\nflow_value==R.nodes[\"y\"][\"excess\"]\n# True\n# For some problems, you might only want to compute a\n# maximum preflow.\nR=preflow_push(G,\"x\",\"y\",value_only=True)\nflow_value==R.graph[\"flow_value\"]\n# True\nflow_value==R.nodes[\"y\"][\"excess\"]\n# True"
        }
    },
    {
        "Section ID": "gnmk_random_graph",
        "Description": [
            "Returns a random bipartite graph G_{n,m,k}.",
            "Produces a bipartite graph chosen randomly out of the set of all graphs\nwith n top nodes, m bottom nodes, and k edges.\nThe graph is composed of two sets of nodes.\nSet A has nodes 0 to (n - 1) and set B has nodes n to (n + m - 1)."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes in the first bipartite set.",
                "m : int": "The number of nodes in the second bipartite set.",
                "k : int": "The number of edges",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "directed : bool, optional (default=False)": "If True return a directed graph"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "If k > m * n then a complete bipartite graph is returned. This graph is a bipartite version of the G_{nm} random graph model. The nodes are assigned the attribute \u2018bipartite\u2019 with the value 0 or 1\nto indicate which bipartite set the node belongs to. This function is not imported in the main namespace.\nTo use it use nx.bipartite.gnmk_random_graph",
            "Examples": "from nx.algorithms import bipartite\nG = bipartite.gnmk_random_graph(10,20,50)"
        }
    },
    {
        "Section ID": "square_clustering",
        "Description": [
            "Compute the squares clustering coefficient for nodes.",
            "For each node return the fraction of possible squares that exist at\nthe node [1]",
            "where \\(q_v(u,w)\\) are the number of common neighbors of \\(u\\) and \\(w\\) other than \\(v\\) (ie squares), and \\(a_v(u,w) = (k_u -\n(1+q_v(u,w)+\\theta_{uv})) + (k_w - (1+q_v(u,w)+\\theta_{uw}))\\) , where \\(\\theta_{uw} = 1\\) if \\(u\\) and \\(w\\) are connected and 0\notherwise. [2]"
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "",
                "nodes : container of nodes, optional (default=all nodes in G)": "Compute clustering for nodes in this container."
            },
            "Returns:": {
                "c4 : dictionary": "A dictionary keyed by node with the square clustering coefficient value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "While \\(C_3(v)\\) (triangle clustering) gives the probability that\ntwo neighbors of node v are connected with each other, \\(C_4(v)\\) is\nthe probability that two neighbors of node v share a common\nneighbor different from v. This algorithm can be applied to both\nbipartite and unipartite networks.",
            "References": "[1]Pedro G. Lind, Marta C. Gonz\u00e1lez, and Hans J. Herrmann. 2005\nCycles and clustering in bipartite networks.\nPhysical Review E (72) 056127.  [2]Zhang, Peng et al. Clustering Coefficient and Community Structure of\nBipartite Networks. Physica A: Statistical Mechanics and its Applications 387.27 (2008): 6869\u20136875.https://arxiv.org/abs/0710.0117v1",
            "Examples": "G=nx.complete_graph(5)\nprint(nx.square_clustering(G,0))\n# 1.0\nprint(nx.square_clustering(G))\n# {0: 1.0, 1: 1.0, 2: 1.0, 3: 1.0, 4: 1.0}"
        }
    },
    {
        "Section ID": "generate_graphml",
        "Description": [
            "Generate GraphML lines for G"
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph",
                "encoding : string (optional)": "Encoding for text data.",
                "prettyprint : bool (optional)": "If True use line breaks and indenting in output XML.",
                "named_key_ids : bool (optional)": "If True use attr.name as value for key elements\u2019 id attribute.",
                "edge_id_from_attribute : dict key (optional)": "If provided, the graphml edge id is set by looking up the corresponding\nedge data attribute keyed by this parameter. IfNoneor the key does not exist in edge data,\nthe edge id is set by the edge key ifGis a MultiGraph, else the edge id is left unset."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This implementation does not support mixed graphs (directed and unidirected\nedges together) hyperedges, nested graphs, or ports.",
            "Examples": "G=nx.path_graph(4)\nlinefeed=chr(10)# linefeed =\ns=linefeed.join(nx.generate_graphml(G))\nforlineinnx.generate_graphml(G):\nprint(line)"
        }
    },
    {
        "Section ID": "is_multigraphical",
        "Description": [
            "Returns True if some multigraph can realize the sequence."
        ],
        "Field List": {
            "Parameters:": {
                "sequence : list": "A list of integers"
            },
            "Returns:": {
                "valid : bool": "True if deg_sequence is a multigraphic degree sequence and False if not."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The worst-case run time is \\(O(n)\\) where \\(n\\) is the length of the sequence.",
            "References": "[1]S. L. Hakimi. \u201cOn the realizability of a set of integers as\ndegrees of the vertices of a linear graph\u201d, J. SIAM, 10, pp. 496-506\n(1962).",
            "Examples": "G=nx.MultiGraph([(1,2),(1,3),(2,3),(3,4),(4,2),(5,1),(5,4)])\nsequence=(dfor_,dinG.degree())\nnx.is_multigraphical(sequence)\n# True\nTo test a non-multigraphical sequence:\n>>> sequence_list = [d for _, d in G.degree()]\n>>> sequence_list[-1] += 1\n>>> nx.is_multigraphical(sequence_list)\nFalse"
        }
    },
    {
        "Section ID": "local_node_connectivity",
        "Description": [
            "Compute node connectivity between source and target.",
            "Pairwise or local node connectivity between two distinct and nonadjacent\nnodes is the minimum number of nodes that must be removed (minimum\nseparating cutset) to disconnect them. By Menger\u2019s theorem, this is equal\nto the number of node independent paths (paths that share no nodes other\nthan source and target). Which is what we compute in this function.",
            "This algorithm is a fast approximation that gives an strict lower\nbound on the actual number of node independent paths between two nodes [1] .\nIt works for both directed and undirected graphs."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node": "Starting node for node connectivity",
                "target : node": "Ending node for node connectivity",
                "cutoff : integer": "Maximum node connectivity to consider. If None, the minimum degree\nof source or target is used as a cutoff. Default value None."
            },
            "Returns:": {
                "k: integer": "pairwise node connectivity"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm [1] finds node independents paths between two nodes by\ncomputing their shortest path using BFS, marking the nodes of the path\nfound as \u2018used\u2019 and then searching other shortest paths excluding the\nnodes marked as used until no more paths exist. It is not exact because\na shortest path could use nodes that, if the path were longer, may belong\nto two different node independent paths. Thus it only guarantees an\nstrict lower bound on node connectivity. Note that the authors propose a further refinement, losing accuracy and\ngaining speed, which is not implemented yet.",
            "References": "[1](1,2)White, Douglas R., and Mark Newman. 2001 A Fast Algorithm for\nNode-Independent Paths. Santa Fe Institute Working Paper #01-07-035http://eclectic.ss.uci.edu/~drwhite/working.pdf",
            "Examples": "# Platonic octahedral graph has node connectivity 4\n# for each non adjacent node pair\nfromnetworkx.algorithmsimportapproximationasapprox\nG=nx.octahedral_graph()\napprox.local_node_connectivity(G,0,5)\n# 4"
        }
    },
    {
        "Section ID": "directed_configuration_model",
        "Description": [
            "Returns a directed_random graph with the given degree sequences.",
            "The configuration model generates a random directed pseudograph\n(graph with parallel edges and self loops) by randomly assigning\nedges to match the given degree sequences."
        ],
        "Field List": {
            "Parameters:": {
                "in_degree_sequence : list of nonnegative integers": "Each list entry corresponds to the in-degree of a node.",
                "out_degree_sequence : list of nonnegative integers": "Each list entry corresponds to the out-degree of a node.",
                "create_using : NetworkX graph constructor, optional (default MultiDiGraph)": "Graph type to create. If graph instance, then cleared before populated.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "G : MultiDiGraph": "A graph with the specified degree sequences.\nNodes are labeled starting at 0 with an index\ncorresponding to the position in deg_sequence."
            },
            "Raises:": {
                "NetworkXError": "If the degree sequences do not have the same sum."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Algorithm as described by Newman [1] . A non-graphical degree sequence (not realizable by some simple\ngraph) is allowed since this function returns graphs with self\nloops and parallel edges.  An exception is raised if the degree\nsequences does not have the same sum. This configuration model construction process can lead to\nduplicate edges and loops.  You can remove the self-loops and\nparallel edges (see below) which will likely result in a graph\nthat doesn\u2019t have the exact degree sequence specified.  This\n\u201cfinite-size effect\u201d decreases as the size of the graph increases.",
            "References": "[1]Newman, M. E. J. and Strogatz, S. H. and Watts, D. J.\nRandom graphs with arbitrary degree distributions and their applications\nPhys. Rev. E, 64, 026118 (2001)",
            "Examples": "One can modify the in- and out-degree sequences from an existing\ndirected graph in order to create a new directed graph. For example,\nhere we modify the directed path graph:\nD=nx.DiGraph([(0,1),(1,2),(2,3)])\ndin=list(dforn,dinD.in_degree())\ndout=list(dforn,dinD.out_degree())\ndin.append(1)\ndout[0]=2\n# We now expect an edge from node 0 to a new node, node 3.\nD=nx.directed_configuration_model(din,dout)\nThe returned graph is a directed multigraph, which may have parallel\nedges. To remove any parallel edges from the returned graph:\nD=nx.DiGraph(D)\nSimilarly, to remove self-loops:\nD.remove_edges_from(nx.selfloop_edges(D))"
        }
    },
    {
        "Section ID": "randomized_partitioning",
        "Description": [
            "Compute a random partitioning of the graph nodes and its cut value.",
            "A partitioning is calculated by observing each node\nand deciding to add it to the partition with probability p ,\nreturning a random cut and its corresponding value (the\nsum of weights of edges connecting different partitions)."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "p : scalar": "Probability for each node to be part of the first partition.\nShould be in [0,1]",
                "weight : object": "Edge attribute key to use as weight. If not specified, edges\nhave weight one."
            },
            "Returns:": {
                "cut_size : scalar": "Value of the minimum cut.",
                "partition : pair of node sets": "A partitioning of the nodes that defines a minimum cut."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the graph is directed or is a multigraph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.complete_graph(5)\ncut_size,partition=nx.approximation.randomized_partitioning(G,seed=1)\ncut_size\n# 6\npartition\n# ({0, 3, 4}, {1, 2})"
        }
    },
    {
        "Section ID": "to_pandas_adjacency",
        "Description": [
            "Returns the graph adjacency matrix as a Pandas DataFrame."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "The NetworkX graph used to construct the Pandas DataFrame.",
                "nodelist : list, optional": "The rows and columns are ordered according to the nodes innodelist.\nIfnodelistis None, then the ordering is produced by G.nodes().",
                "multigraph_weight : {sum, min, max}, optional": "An operator that determines how weights in multigraphs are handled.\nThe default is to sum the weights of the multiple edges.",
                "weight : string or None, optional": "The edge attribute that holds the numerical value used for\nthe edge weight.  If an edge does not have that attribute, then the\nvalue 1 is used instead.",
                "nonedge : float, optional": "The matrix values corresponding to nonedges are typically set to zero.\nHowever, this could be undesirable if there are matrix values\ncorresponding to actual edges that also have the value zero. If so,\none might prefer nonedges to have some other value, such as nan."
            },
            "Returns:": {
                "df : Pandas DataFrame": "Graph adjacency matrix"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For directed graphs, entry i,j corresponds to an edge from i to j. The DataFrame entries are assigned to the weight edge attribute. When\nan edge does not have a weight attribute, the value of the entry is set to\nthe number 1.  For multiple (parallel) edges, the values of the entries\nare determined by the \u2018multigraph_weight\u2019 parameter.  The default is to\nsum the weight attributes for each of the parallel edges. When nodelist does not contain every node in G , the matrix is built\nfrom the subgraph of G that is induced by the nodes in nodelist . The convention used for self-loop edges in graphs is to assign the\ndiagonal matrix entry value to the weight attribute of the edge\n(or the number 1 if the edge has no weight attribute).  If the\nalternate convention of doubling the edge weight is desired the\nresulting Pandas DataFrame can be modified as follows:",
            "Examples": "G=nx.MultiDiGraph()\nG.add_edge(0,1,weight=2)\n# 0\nG.add_edge(1,0)\n# 0\nG.add_edge(2,2,weight=3)\n# 0\nG.add_edge(2,2)\n# 1\nnx.to_pandas_adjacency(G,nodelist=[0,1,2],dtype=int)\n#    0  1  2\n# 0  0  2  0\n# 1  1  0  0\n# 2  0  0  4"
        }
    },
    {
        "Section ID": "has_eulerian_path",
        "Description": [
            "Return True iff G has an Eulerian path.",
            "An Eulerian path is a path in a graph which uses each edge of a graph\nexactly once. If source is specified, then this function checks\nwhether an Eulerian path that starts at node source exists."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "The graph to find an euler path in.",
                "source : node, optional": "Starting node for path."
            },
            "Returns:": {
                "Bool : True if G has an Eulerian path.": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "If you prefer to allow graphs with isolated vertices to have Eulerian path,\nyou can first remove such vertices and then callhas_eulerian_pathas below example shows.\nG=nx.Graph([(0,1),(1,2),(0,2)])\nG.add_node(3)\nnx.has_eulerian_path(G)\n# False\nG.remove_nodes_from(list(nx.isolates(G)))\nnx.has_eulerian_path(G)\n# True"
        }
    },
    {
        "Section ID": "is_branching",
        "Description": [
            "Returns True if G is a branching.",
            "A branching is a directed forest with maximum in-degree equal to 1."
        ],
        "Field List": {
            "Parameters:": {
                "G : directed graph": "The directed graph to test."
            },
            "Returns:": {
                "b : bool": "A boolean that is True ifGis a branching."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "In another convention, a branching is also known as a forest .",
            "Examples": "G=nx.DiGraph([(0,1),(1,2),(2,3),(3,4)])\nnx.is_branching(G)\n# True\nG.remove_edge(2,3)\nG.add_edge(3,1)# maximum in-degree is 2\nnx.is_branching(G)\n# False"
        }
    },
    {
        "Section ID": "gomory_hu_tree",
        "Description": [
            "Returns the Gomory-Hu tree of an undirected graph G.",
            "A Gomory-Hu tree of an undirected graph with capacities is a\nweighted tree that represents the minimum s-t cuts for all s-t\npairs in the graph.",
            "It only requires n-1 minimum cut computations instead of the\nobvious n(n-1)/2 . The tree represents all s-t cuts as the\nminimum cut value among any pair of nodes is the minimum edge\nweight in the shortest path between the two nodes in the\nGomory-Hu tree.",
            "The Gomory-Hu tree also has the property that removing the\nedge with the minimum weight in the shortest path between\nany two nodes leaves two connected components that form\na partition of the nodes in G that defines the minimum s-t\ncut.",
            "See Examples section below for details."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected graph",
                "capacity : string": "Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: \u2018capacity\u2019.",
                "flow_func : function": "Function to perform the underlying flow computations. Default valueedmonds_karp(). This function performs better in sparse graphs\nwith right tailed degree distributions.shortest_augmenting_path()will perform better in denser\ngraphs."
            },
            "Returns:": {
                "Tree : NetworkX graph": "A NetworkX graph representing the Gomory-Hu tree of the input graph."
            },
            "Raises:": {
                "NetworkXNotImplemented": "Raised if the input graph is directed.",
                "NetworkXError": "Raised if the input graph is an empty Graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This implementation is based on Gusfield approach [1] to compute\nGomory-Hu trees, which does not require node contractions and has\nthe same computational complexity than the original method.",
            "References": "[1]Gusfield D: Very simple methods for all pairs network flow analysis.\nSIAM J Comput 19(1):143-155, 1990.",
            "Examples": "G=nx.karate_club_graph()\nnx.set_edge_attributes(G,1,\"capacity\")\nT=nx.gomory_hu_tree(G)\n# The value of the minimum cut between any pair\n# of nodes in G is the minimum edge weight in the\n# shortest path between the two nodes in the\n# Gomory-Hu tree.\ndefminimum_edge_weight_in_shortest_path(T,u,v):\npath=nx.shortest_path(T,u,v,weight=\"weight\")\nreturnmin((T[u][v][\"weight\"],(u,v))for(u,v)inzip(path,path[1:]))\nu,v=0,33\ncut_value,edge=minimum_edge_weight_in_shortest_path(T,u,v)\ncut_value\n# 10\nnx.minimum_cut_value(G,u,v)\n# 10\n# The Gomory-Hu tree also has the property that removing the\n# edge with the minimum weight in the shortest path between\n# any two nodes leaves two connected components that form\n# a partition of the nodes in G that defines the minimum s-t\n# cut.\ncut_value,edge=minimum_edge_weight_in_shortest_path(T,u,v)\nT.remove_edge(*edge)\nU,V=list(nx.connected_components(T))\n# Thus U and V form a partition that defines a minimum cut\n# between u and v in G. You can compute the edge cut set,\n# that is, the set of edges that if removed from G will\n# disconnect u from v in G, with this information:\ncutset=set()\nforx,nbrsin((n,G[n])forninU):\ncutset.update((x,y)foryinnbrsifyinV)\n# Because we have set the capacities of all edges to 1\n# the cutset contains ten edges\nlen(cutset)\n# 10\n# You can use any maximum flow algorithm for the underlying\n# flow computations using the argument flow_func\nfromnetworkx.algorithmsimportflow\nT=nx.gomory_hu_tree(G,flow_func=flow.boykov_kolmogorov)\ncut_value,edge=minimum_edge_weight_in_shortest_path(T,u,v)\ncut_value\n# 10\nnx.minimum_cut_value(G,u,v,flow_func=flow.boykov_kolmogorov)\n# 10"
        }
    },
    {
        "Section ID": "from_biadjacency_matrix",
        "Description": [
            "Creates a new bipartite graph from a biadjacency matrix given as a\nSciPy sparse array."
        ],
        "Field List": {
            "Parameters:": {
                "A: scipy sparse array": "A biadjacency matrix representation of a graph",
                "create_using: NetworkX graph": "Use specified graph for result.  The default is Graph()",
                "edge_attribute: string": "Name of edge attribute to store matrix numeric value. The data will\nhave the same type as the matrix entry (int, float, (real,imag))."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The nodes are labeled with the attribute bipartite set to an integer\n0 or 1 representing membership in part 0 or part 1 of the bipartite graph. If create_using is an instance of networkx.MultiGraph or networkx.MultiDiGraph and the entries of A are of\ntype int , then this function returns a multigraph (of the same\ntype as create_using ) with parallel edges. In this case, edge_attribute will be ignored.",
            "References": "[1] https://en.wikipedia.org/wiki/Adjacency_matrix#Adjacency_matrix_of_a_bipartite_graph"
        }
    },
    {
        "Section ID": "cartesian_product",
        "Description": [
            "Returns the Cartesian product of G and H.",
            "The Cartesian product \\(P\\) of the graphs \\(G\\) and \\(H\\) has a node set that\nis the Cartesian product of the node sets, \\(V(P)=V(G) \\times V(H)\\) . \\(P\\) has an edge \\(((u,v),(x,y))\\) if and only if either \\(u\\) is equal to \\(x\\) and both \\(v\\) and \\(y\\) are adjacent in \\(H\\) or if \\(v\\) is equal to \\(y\\) and\nboth \\(u\\) and \\(x\\) are adjacent in \\(G\\) ."
        ],
        "Field List": {
            "Parameters:": {
                "G, H: graphs": "Networkx graphs."
            },
            "Returns:": {
                "P: NetworkX graph": "The Cartesian product of G and H. P will be a multi-graph if either G\nor H is a multi-graph. Will be a directed if G and H are directed,\nand undirected if G and H are undirected."
            },
            "Raises:": {
                "NetworkXError": "If G and H are not both directed or both undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Node attributes in P are two-tuple of the G and H node attributes.\nMissing attributes are assigned None.",
            "Examples": "G=nx.Graph()\nH=nx.Graph()\nG.add_node(0,a1=True)\nH.add_node(\"a\",a2=\"Spam\")\nP=nx.cartesian_product(G,H)\nlist(P)\n# [(0, 'a')]\nEdge attributes and edge keys (for multigraphs) are also copied to the\nnew product graph"
        }
    },
    {
        "Section ID": "transitivity",
        "Description": [
            "Compute graph transitivity, the fraction of all possible triangles\npresent in G.",
            "Possible triangles are identified by the number of \u201ctriads\u201d\n(two edges with a shared vertex).",
            "The transitivity is"
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": ""
            },
            "Returns:": {
                "out : float": "Transitivity"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Self loops are ignored.",
            "Examples": "G=nx.complete_graph(5)\nprint(nx.transitivity(G))\n# 1.0"
        }
    },
    {
        "Section ID": "number_connected_components",
        "Description": [
            "Returns the number of connected components."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "An undirected graph."
            },
            "Returns:": {
                "n : integer": "Number of connected components"
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is directed."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For undirected graphs only.",
            "Examples": "G=nx.Graph([(0,1),(1,2),(5,6),(3,4)])\nnx.number_connected_components(G)\n# 3"
        }
    },
    {
        "Section ID": "random_reference",
        "Description": [
            "Compute a random graph by swapping edges of a given graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "An undirected graph with 4 or more nodes.",
                "niter : integer (optional, default=1)": "An edge is rewired approximatelynitertimes.",
                "connectivity : boolean (optional, default=True)": "When True, ensure connectivity for the randomized graph.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "G : graph": "The randomized graph."
            },
            "Raises:": {
                "NetworkXError": "If there are fewer than 4 nodes or 2 edges inG"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The implementation is adapted from the algorithm by Maslov and Sneppen\n(2002) [1] .",
            "References": "[1]Maslov, Sergei, and Kim Sneppen.\n\u201cSpecificity and stability in topology of protein networks.\u201d\nScience 296.5569 (2002): 910-913."
        }
    },
    {
        "Section ID": "laplacian_centrality",
        "Description": [
            "Compute the Laplacian centrality for nodes in the graph G .",
            "The Laplacian Centrality of a node i is measured by the drop in the\nLaplacian Energy after deleting node i from the graph. The Laplacian Energy\nis the sum of the squared eigenvalues of a graph\u2019s Laplacian matrix.",
            "Where \\(E_L (G)\\) is the Laplacian energy of graph G ,\nE_L (G_i) is the Laplacian energy of graph G after deleting node i and \\(\\lambda_i\\) are the eigenvalues of G \u2019s Laplacian matrix.\nThis formula shows the normalized value. Without normalization,\nthe numerator on the right side is returned."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph",
                "normalized : bool (default = True)": "If True the centrality score is scaled so the sum over all nodes is 1.\nIf False the centrality score for each node is the drop in Laplacian\nenergy when that node is removed.",
                "nodelist : list, optional (default = None)": "The rows and columns are ordered according to the nodes in nodelist.\nIf nodelist is None, then the ordering is produced by G.nodes().",
                "weight: string or None, optional (default=`weight`)": "Optional parameterweightto compute the Laplacian matrix.\nThe edge data key used to compute each value in the matrix.\nIf None, then each edge has weight 1.",
                "walk_type : string or None, optional (default=None)": "Optional parameterwalk_typeused when callingdirected_laplacian_matrix.\nOne of\"random\",\"lazy\", or\"pagerank\". Ifwalk_type=None(the default), then a value is selected according to the properties ofG:\n-walk_type=\"random\"ifGis strongly connected and aperiodic\n-walk_type=\"lazy\"ifGis strongly connected but not aperiodic\n-walk_type=\"pagerank\"for all other cases.",
                "alpha : real (default = 0.95)": "Optional parameteralphaused when callingdirected_laplacian_matrix.\n(1 - alpha) is the teleportation probability used with pagerank."
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of nodes with Laplacian centrality as the value."
            },
            "Raises:": {
                "NetworkXPointlessConcept": "If the graphGis the null graph.",
                "ZeroDivisionError": "If the graphGhas no edges (is empty) and normalization is requested."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The algorithm is implemented based on [1] with an extension to directed graphs\nusing the directed_laplacian_matrix function.",
            "References": "[1]Qi, X., Fuller, E., Wu, Q., Wu, Y., and Zhang, C.-Q. (2012).\nLaplacian centrality: A new centrality measure for weighted networks.\nInformation Sciences, 194:240-253.https://math.wvu.edu/~cqzhang/Publication-files/my-paper/INS-2012-Laplacian-W.pdf",
            "Examples": "G=nx.Graph()\nedges=[(0,1,4),(0,2,2),(2,1,1),(1,3,2),(1,4,2),(4,5,1)]\nG.add_weighted_edges_from(edges)\nsorted((v,f\"{c:0.2f}\")forv,cinlaplacian_centrality(G).items())\n# [(0, '0.70'), (1, '0.90'), (2, '0.28'), (3, '0.22'), (4, '0.26'), (5, '0.04')]"
        }
    },
    {
        "Section ID": "degree_pearson_correlation_coefficient",
        "Description": [
            "Compute degree assortativity of graph.",
            "Assortativity measures the similarity of connections\nin the graph with respect to the node degree.",
            "This is the same as degree_assortativity_coefficient but uses the\npotentially faster scipy.stats.pearsonr function."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "x: string (\u2018in\u2019,\u2019out\u2019)": "The degree type for source node (directed graphs only).",
                "y: string (\u2018in\u2019,\u2019out\u2019)": "The degree type for target node (directed graphs only).",
                "weight: string or None, optional (default=None)": "The edge attribute that holds the numerical value used\nas a weight.  If None, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node.",
                "nodes: list or iterable (optional)": "Compute pearson correlation of degrees only for specified nodes.\nThe default is all nodes."
            },
            "Returns:": {
                "r : float": "Assortativity of graph by degree."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This calls scipy.stats.pearsonr.",
            "References": "[1]M. E. J. Newman, Mixing patterns in networks\nPhysical Review E, 67 026126, 2003  [2]Foster, J.G., Foster, D.V., Grassberger, P. & Paczuski, M.\nEdge direction and the structure of networks, PNAS 107, 10815-20 (2010).",
            "Examples": "G=nx.path_graph(4)\nr=nx.degree_pearson_correlation_coefficient(G)\nprint(f\"{r:3.1f}\")\n# -0.5"
        }
    },
    {
        "Section ID": "boykov_kolmogorov",
        "Description": [
            "Find a maximum single-commodity flow using Boykov-Kolmogorov algorithm.",
            "This function returns the residual network resulting after computing\nthe maximum flow. See below for details about the conventions\nNetworkX uses for defining residual networks.",
            "This algorithm has worse case complexity \\(O(n^2 m |C|)\\) for \\(n\\) nodes, \\(m\\) edges, and \\(|C|\\) the cost of the minimum cut [1] . This implementation\nuses the marking heuristic defined in [2] which improves its running\ntime in many practical problems."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Edges of the graph are expected to have an attribute called\n\u2018capacity\u2019. If this attribute is not present, the edge is\nconsidered to have infinite capacity.",
                "s : node": "Source node for the flow.",
                "t : node": "Sink node for the flow.",
                "capacity : string": "Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: \u2018capacity\u2019.",
                "residual : NetworkX graph": "Residual network on which the algorithm is to be executed. If None, a\nnew residual network is created. Default value: None.",
                "value_only : bool": "If True compute only the value of the maximum flow. This parameter\nwill be ignored by this algorithm because it is not applicable.",
                "cutoff : integer, float": "If specified, the algorithm will terminate when the flow value reaches\nor exceeds the cutoff. In this case, it may be unable to immediately\ndetermine a minimum cut. Default value: None."
            },
            "Returns:": {
                "R : NetworkX DiGraph": "Residual network after computing the maximum flow."
            },
            "Raises:": {
                "NetworkXError": "The algorithm does not support MultiGraph and MultiDiGraph. If\nthe input graph is an instance of one of these two classes, a\nNetworkXError is raised.",
                "NetworkXUnbounded": "If the graph has a path of infinite capacity, the value of a\nfeasible flow on the graph is unbounded above and the function\nraises a NetworkXUnbounded."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The residual network R from an input graph G has the\nsame nodes as G . R is a DiGraph that contains a pair\nof edges (u,v) and (v,u) iff (u,v) is not a\nself-loop, and at least one of (u,v) and (v,u) exists\nin G . For each edge (u,v) in R , R[u][v]['capacity'] is equal to the capacity of (u,v) in G if it exists\nin G or zero otherwise. If the capacity is infinite, R[u][v]['capacity'] will have a high arbitrary finite value\nthat does not affect the solution of the problem. This value is stored in R.graph['inf'] . For each edge (u,v) in R , R[u][v]['flow'] represents the flow function of (u,v) and\nsatisfies R[u][v]['flow']==-R[v][u]['flow'] . The flow value, defined as the total flow into t , the sink, is\nstored in R.graph['flow_value'] . If cutoff is not\nspecified, reachability to t using only edges (u,v) such\nthat R[u][v]['flow']<R[u][v]['capacity'] induces a minimum s - t cut.",
            "References": "[1]Boykov, Y., & Kolmogorov, V. (2004). An experimental comparison\nof min-cut/max-flow algorithms for energy minimization in vision.\nPattern Analysis and Machine Intelligence, IEEE Transactions on,\n26(9), 1124-1137.https://doi.org/10.1109/TPAMI.2004.60  [2]Vladimir Kolmogorov. Graph-based Algorithms for Multi-camera\nReconstruction Problem. PhD thesis, Cornell University, CS Department,\n2003. pp. 109-114.https://web.archive.org/web/20170809091249/https://pub.ist.ac.at/~vnk/papers/thesis.pdf",
            "Examples": "fromnetworkx.algorithms.flowimportboykov_kolmogorov\nThe functions that implement flow algorithms and output a residual\nnetwork, such as this one, are not imported to the base NetworkX\nnamespace, so you have to explicitly import them from the flow package.\nG=nx.DiGraph()\nG.add_edge(\"x\",\"a\",capacity=3.0)\nG.add_edge(\"x\",\"b\",capacity=1.0)\nG.add_edge(\"a\",\"c\",capacity=3.0)\nG.add_edge(\"b\",\"c\",capacity=5.0)\nG.add_edge(\"b\",\"d\",capacity=4.0)\nG.add_edge(\"d\",\"e\",capacity=2.0)\nG.add_edge(\"c\",\"y\",capacity=2.0)\nG.add_edge(\"e\",\"y\",capacity=3.0)\nR=boykov_kolmogorov(G,\"x\",\"y\")\nflow_value=nx.maximum_flow_value(G,\"x\",\"y\")\nflow_value\n# 3.0\nflow_value==R.graph[\"flow_value\"]\n# True\nA nice feature of the Boykov-Kolmogorov algorithm is that a partition\nof the nodes that defines a minimum cut can be easily computed based\non the search trees used during the algorithm. These trees are stored\nin the graph attributetreesof the residual network.\nsource_tree,target_tree=R.graph[\"trees\"]\npartition=(set(source_tree),set(G)-set(source_tree))\nOr equivalently:\npartition=(set(G)-set(target_tree),set(target_tree))"
        }
    },
    {
        "Section ID": "bfs_beam_edges",
        "Description": [
            "Iterates over edges in a beam search.",
            "The beam search is a generalized breadth-first search in which only\nthe \u201cbest\u201d w neighbors of the current node are enqueued, where w is the beam width and \u201cbest\u201d is an application-specific\nheuristic. In general, a beam search with a small beam width might\nnot visit each node in the graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node": "Starting node for the breadth-first search; this function\niterates over only those edges in the component reachable from\nthis node.",
                "value : function": "A function that takes a node of the graph as input and returns a\nreal number indicating how \u201cgood\u201d it is. A higher value means it\nis more likely to be visited sooner during the search. When\nvisiting a new node, only thewidthneighbors with the highestvalueare enqueued (in decreasing order ofvalue).",
                "width : int (default = None)": "The beam width for the search. This is the number of neighbors\n(ordered byvalue) to enqueue when visiting each new node."
            },
            "Yields:": {
                "edge": "Edges in the beam search starting fromsource, given as a pair\nof nodes."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "To give nodes with, for example, a higher centrality precedence\nduring the search, set thevaluefunction to return the centrality\nvalue of the node:\nG=nx.karate_club_graph()\ncentrality=nx.eigenvector_centrality(G)\nlist(nx.bfs_beam_edges(G,source=0,value=centrality.get,width=3))\n# [(0, 2), (0, 1), (0, 8), (2, 32), (1, 13), (8, 33)]"
        }
    },
    {
        "Section ID": "from_pandas_edgelist",
        "Description": [
            "Returns a graph from Pandas DataFrame containing an edge list.",
            "The Pandas DataFrame should contain at least two columns of node names and\nzero or more columns of edge attributes. Each row will be processed as one\nedge instance.",
            "Note: This function iterates over DataFrame.values, which is not\nguaranteed to retain the data type across columns in the row. This is only\na problem if your row is entirely numeric and a mix of ints and floats. In\nthat case, all values will be returned as floats. See the\nDataFrame.iterrows documentation for an example."
        ],
        "Field List": {
            "Parameters:": {
                "df : Pandas DataFrame": "An edge list representation of a graph",
                "source : str or int": "A valid column name (string or integer) for the source nodes (for the\ndirected case).",
                "target : str or int": "A valid column name (string or integer) for the target nodes (for the\ndirected case).",
                "edge_attr : str or int, iterable, True, or None": "A valid column name (str or int) or iterable of column names that are\nused to retrieve items and add them to the graph as edge attributes.\nIfTrue, all of the remaining columns will be added.\nIfNone, no edge attributes are added to the graph.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated.",
                "edge_key : str or None, optional (default=None)": "A valid column name for the edge keys (for a MultiGraph). The values in\nthis column are used for the edge keys when adding edges if create_using\nis a multigraph.",
                "If you have node attributes stored in a separate dataframe `df_nodes`,": "",
                "you can load those attributes to the graph `G` using the following code:": "",
                "```": "",
                "df_nodes = pd.DataFrame({\u201cnode_id\u201d: [1, 2, 3], \u201cattribute1\u201d: [\u201cA\u201d, \u201cB\u201d, \u201cC\u201d]})": "",
                "G.add_nodes_from((n, dict(d)) for n, d in df_nodes.iterrows())": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "Simple integer weights on edges:\nimportpandasaspd\npd.options.display.max_columns=20\nimportnumpyasnp\nrng=np.random.RandomState(seed=5)\nints=rng.randint(1,11,size=(3,2))\na=[\"A\",\"B\",\"C\"]\nb=[\"D\",\"A\",\"E\"]\ndf=pd.DataFrame(ints,columns=[\"weight\",\"cost\"])\ndf[0]=a\ndf[\"b\"]=b\ndf[[\"weight\",\"cost\",0,\"b\"]]\n#    weight  cost  0  b\n# 0       4     7  A  D\n# 1       7     1  B  A\n# 2      10     9  C  E\nG=nx.from_pandas_edgelist(df,0,\"b\",[\"weight\",\"cost\"])\nG[\"E\"][\"C\"][\"weight\"]\n# 10\nG[\"E\"][\"C\"][\"cost\"]\n# 9\nedges=pd.DataFrame(\n{\n\"source\":[0,1,2],\n\"target\":[2,2,3],\n\"weight\":[3,4,5],\n\"color\":[\"red\",\"blue\",\"blue\"],\n}\n)\nG=nx.from_pandas_edgelist(edges,edge_attr=True)\nG[0][2][\"color\"]\n# 'red'\nBuild multigraph with custom keys:\nedges=pd.DataFrame(\n{\n\"source\":[0,1,2,0],\n\"target\":[2,2,3,2],\n\"my_edge_key\":[\"A\",\"B\",\"C\",\"D\"],\n\"weight\":[3,4,5,6],\n\"color\":[\"red\",\"blue\",\"blue\",\"blue\"],\n}\n)\nG=nx.from_pandas_edgelist(\nedges,\nedge_key=\"my_edge_key\",\nedge_attr=[\"weight\",\"color\"],\ncreate_using=nx.MultiGraph(),\n)\nG[0][2]\n# AtlasView({'A': {'weight': 3, 'color': 'red'}, 'D': {'weight': 6, 'color': 'blue'}})"
        }
    },
    {
        "Section ID": "union",
        "Description": [
            "Combine graphs G and H. The names of nodes must be unique.",
            "A name collision between the graphs will raise an exception.",
            "A renaming facility is provided to avoid name collisions."
        ],
        "Field List": {
            "Parameters:": {
                "G, H : graph": "A NetworkX graph",
                "rename : iterable , optional": "Node names of G and H can be changed by specifying the tuple\nrename=(\u2018G-\u2018,\u2019H-\u2019) (for example).  Node \u201cu\u201d in G is then renamed\n\u201cG-u\u201d and \u201cv\u201d in H is renamed \u201cH-v\u201d."
            },
            "Returns:": {
                "U : A union graph with the same type as G.": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "To combine graphs that have common nodes, consider compose(G, H)\nor the method, Graph.update(). disjoint_union() is similar to union() except that it avoids name clashes\nby relabeling the nodes with sequential integers. Edge and node attributes are propagated from G and H to the union graph.\nGraph attributes are also propagated, but if they are present in both G and H,\nthen the value from H is used.",
            "Examples": "G=nx.Graph([(0,1),(0,2),(1,2)])\nH=nx.Graph([(0,1),(0,3),(1,3),(1,2)])\nU=nx.union(G,H,rename=(\"G\",\"H\"))\nU.nodes\n# NodeView(('G0', 'G1', 'G2', 'H0', 'H1', 'H3', 'H2'))\nU.edges\n# EdgeView([('G0', 'G1'), ('G0', 'G2'), ('G1', 'G2'), ('H0', 'H1'), ('H0', 'H3'), ('H1', 'H3'), ('H1', 'H2')])"
        }
    },
    {
        "Section ID": "write_graphml",
        "Description": [
            "Write G in GraphML XML format to path",
            "This function uses the LXML framework and should be faster than\nthe version using the xml library."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph",
                "path : file or string": "File or filename to write.\nFilenames ending in .gz or .bz2 will be compressed.",
                "encoding : string (optional)": "Encoding for text data.",
                "prettyprint : bool (optional)": "If True use line breaks and indenting in output XML.",
                "infer_numeric_types : boolean": "Determine if numeric types should be generalized.\nFor example, if edges have both int and float \u2018weight\u2019 attributes,\nwe infer in GraphML that both are floats.",
                "named_key_ids : bool (optional)": "If True use attr.name as value for key elements\u2019 id attribute.",
                "edge_id_from_attribute : dict key (optional)": "If provided, the graphml edge id is set by looking up the corresponding\nedge data attribute keyed by this parameter. IfNoneor the key does not exist in edge data,\nthe edge id is set by the edge key ifGis a MultiGraph, else the edge id is left unset."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This implementation does not support mixed graphs (directed\nand unidirected edges together) hyperedges, nested graphs, or ports.",
            "Examples": "G=nx.path_graph(4)\nnx.write_graphml_lxml(G,\"fourpath.graphml\")"
        }
    },
    {
        "Section ID": "minimum_st_node_cut",
        "Description": [
            "Returns a set of nodes of minimum cardinality that disconnect source\nfrom target in G.",
            "This function returns the set of nodes of minimum cardinality that,\nif removed, would destroy all paths among source and target in G."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "s : node": "Source node.",
                "t : node": "Target node.",
                "flow_func : function": "A function for computing the maximum flow among a pair of nodes.\nThe function has to accept at least three parameters: a Digraph,\na source node, and a target node. And return a residual network\nthat follows NetworkX conventions (seemaximum_flow()for\ndetails). If flow_func is None, the default maximum flow function\n(edmonds_karp()) is used. See below for details. The choice\nof the default function may change from version to version and\nshould not be relied on. Default value: None.",
                "auxiliary : NetworkX DiGraph": "Auxiliary digraph to compute flow based node connectivity. It has\nto have a graph attribute called mapping with a dictionary mapping\nnode names in G and in the auxiliary digraph. If provided\nit will be reused instead of recreated. Default value: None.",
                "residual : NetworkX DiGraph": "Residual network to compute maximum flow. If provided it will be\nreused instead of recreated. Default value: None."
            },
            "Returns:": {
                "cutset : set": "Set of nodes that, if removed, would destroy all paths between\nsource and target in G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This is a flow based implementation of minimum node cut. The algorithm\nis based in solving a number of maximum flow computations to determine\nthe capacity of the minimum cut on an auxiliary directed network that\ncorresponds to the minimum node cut of G. It handles both directed\nand undirected graphs. This implementation is based on algorithm 11\nin [1] .",
            "References": "[1]Abdol-Hossein Esfahanian. Connectivity Algorithms.http://www.cse.msu.edu/~cse835/Papers/Graph_connectivity_revised.pdf",
            "Examples": "This function is not imported in the base NetworkX namespace, so you\nhave to explicitly import it from the connectivity package:\nfromnetworkx.algorithms.connectivityimportminimum_st_node_cut\nWe use in this example the platonic icosahedral graph, which has node\nconnectivity 5.\nG=nx.icosahedral_graph()\nlen(minimum_st_node_cut(G,0,6))\n# 5\nIf you need to compute local st cuts between several pairs of\nnodes in the same graph, it is recommended that you reuse the\ndata structures that NetworkX uses in the computation: the\nauxiliary digraph for node connectivity and node cuts, and the\nresidual network for the underlying maximum flow computation.\nExample of how to compute local st node cuts reusing the data\nstructures:\n# You also have to explicitly import the function for\n# building the auxiliary digraph from the connectivity package\nfromnetworkx.algorithms.connectivityimportbuild_auxiliary_node_connectivity\nH=build_auxiliary_node_connectivity(G)\n# And the function for building the residual network from the\n# flow package\nfromnetworkx.algorithms.flowimportbuild_residual_network\n# Note that the auxiliary digraph has an edge attribute named capacity\nR=build_residual_network(H,\"capacity\")\n# Reuse the auxiliary digraph and the residual network by passing them\n# as parameters\nlen(minimum_st_node_cut(G,0,6,auxiliary=H,residual=R))\n# 5\nYou can also use alternative flow algorithms for computing minimum st\nnode cuts. For instance, in dense networks the algorithmshortest_augmenting_path()will usually perform better than\nthe defaultedmonds_karp()which is faster for sparse\nnetworks with highly skewed degree distributions. Alternative flow\nfunctions have to be explicitly imported from the flow package.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\nlen(minimum_st_node_cut(G,0,6,flow_func=shortest_augmenting_path))\n# 5"
        }
    },
    {
        "Section ID": "maximum_flow",
        "Description": [
            "Find a maximum single-commodity flow."
        ],
        "Field List": {
            "Parameters:": {
                "flowG : NetworkX graph": "Edges of the graph are expected to have an attribute called\n\u2018capacity\u2019. If this attribute is not present, the edge is\nconsidered to have infinite capacity.",
                "_s : node": "Source node for the flow.",
                "_t : node": "Sink node for the flow.",
                "capacity : string": "Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: \u2018capacity\u2019.",
                "flow_func : function": "A function for computing the maximum flow among a pair of nodes\nin a capacitated graph. The function has to accept at least three\nparameters: a Graph or Digraph, a source node, and a target node.\nAnd return a residual network that follows NetworkX conventions\n(see Notes). If flow_func is None, the default maximum\nflow function (preflow_push()) is used. See below for\nalternative algorithms. The choice of the default function may change\nfrom version to version and should not be relied on. Default value:\nNone.",
                "kwargs : Any other keyword parameter is passed to the function that": "computes the maximum flow."
            },
            "Returns:": {
                "flow_value : integer, float": "Value of the maximum flow, i.e., net outflow from the source.",
                "flow_dict : dict": "A dictionary containing the value of the flow that went through\neach edge."
            },
            "Raises:": {
                "NetworkXError": "The algorithm does not support MultiGraph and MultiDiGraph. If\nthe input graph is an instance of one of these two classes, a\nNetworkXError is raised.",
                "NetworkXUnbounded": "If the graph has a path of infinite capacity, the value of a\nfeasible flow on the graph is unbounded above and the function\nraises a NetworkXUnbounded."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The function used in the flow_func parameter has to return a residual\nnetwork that follows NetworkX conventions: The residual network R from an input graph G has the\nsame nodes as G . R is a DiGraph that contains a pair\nof edges (u,v) and (v,u) iff (u,v) is not a\nself-loop, and at least one of (u,v) and (v,u) exists\nin G . For each edge (u,v) in R , R[u][v]['capacity'] is equal to the capacity of (u,v) in G if it exists\nin G or zero otherwise. If the capacity is infinite, R[u][v]['capacity'] will have a high arbitrary finite value\nthat does not affect the solution of the problem. This value is stored in R.graph['inf'] . For each edge (u,v) in R , R[u][v]['flow'] represents the flow function of (u,v) and\nsatisfies R[u][v]['flow']==-R[v][u]['flow'] . The flow value, defined as the total flow into t , the sink, is\nstored in R.graph['flow_value'] . Reachability to t using\nonly edges (u,v) such that R[u][v]['flow']<R[u][v]['capacity'] induces a minimum s - t cut. Specific algorithms may store extra data in R . The function should supports an optional boolean parameter value_only. When\nTrue, it can optionally terminate the algorithm as soon as the maximum flow\nvalue and the minimum cut can be determined.",
            "Examples": "G=nx.DiGraph()\nG.add_edge(\"x\",\"a\",capacity=3.0)\nG.add_edge(\"x\",\"b\",capacity=1.0)\nG.add_edge(\"a\",\"c\",capacity=3.0)\nG.add_edge(\"b\",\"c\",capacity=5.0)\nG.add_edge(\"b\",\"d\",capacity=4.0)\nG.add_edge(\"d\",\"e\",capacity=2.0)\nG.add_edge(\"c\",\"y\",capacity=2.0)\nG.add_edge(\"e\",\"y\",capacity=3.0)\nmaximum_flow returns both the value of the maximum flow and a\ndictionary with all flows.\nflow_value,flow_dict=nx.maximum_flow(G,\"x\",\"y\")\nflow_value\n# 3.0\nprint(flow_dict[\"x\"][\"b\"])\n# 1.0\nYou can also use alternative algorithms for computing the\nmaximum flow by using the flow_func parameter.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\nflow_value==nx.maximum_flow(G,\"x\",\"y\",flow_func=shortest_augmenting_path)[0]\n# True"
        }
    },
    {
        "Section ID": "to_prufer_sequence",
        "Description": [
            "Returns the Pr\u00fcfer sequence of the given tree.",
            "A Pr\u00fcfer sequence is a list of n - 2 numbers between 0 and n - 1, inclusive. The tree corresponding to a given Pr\u00fcfer\nsequence can be recovered by repeatedly joining a node in the\nsequence with a node with the smallest potential degree according to\nthe sequence."
        ],
        "Field List": {
            "Parameters:": {
                "T : NetworkX graph": "An undirected graph object representing a tree."
            },
            "Returns:": {
                "list": "The Pr\u00fcfer sequence of the given tree."
            },
            "Raises:": {
                "NetworkXPointlessConcept": "If the number of nodes inTis less than two.",
                "NotATree": "IfTis not a tree.",
                "KeyError": "If the set of nodes inTis not {0, \u2026,n- 1}."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "There is a bijection from labeled trees to Pr\u00fcfer sequences. This\nfunction is the inverse of the from_prufer_sequence() function. Sometimes Pr\u00fcfer sequences use nodes labeled from 1 to n instead\nof from 0 to n - 1. This function requires nodes to be labeled in\nthe latter form. You can use relabel_nodes() to\nrelabel the nodes of your tree to the appropriate format. This implementation is from [1] and has a running time of \\(O(n)\\) .",
            "References": "[1]Wang, Xiaodong, Lei Wang, and Yingjie Wu.\n\u201cAn optimal algorithm for Prufer codes.\u201dJournal of Software Engineering and Applications2.02 (2009): 111.\n<https://doi.org/10.4236/jsea.2009.22016>",
            "Examples": "There is a bijection between Pr\u00fcfer sequences and labeled trees, so\nthis function is the inverse of thefrom_prufer_sequence()function:\nedges=[(0,3),(1,3),(2,3),(3,4),(4,5)]\ntree=nx.Graph(edges)\nsequence=nx.to_prufer_sequence(tree)\nsequence\n# [3, 3, 3, 4]\ntree2=nx.from_prufer_sequence(sequence)\nlist(tree2.edges())==edges\n# True"
        }
    },
    {
        "Section ID": "graphviz_layout",
        "Description": [
            "Create node positions for G using Graphviz."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A graph created with NetworkX",
                "prog : string": "Name of Graphviz layout program",
                "root : string, optional": "Root node for twopi layout",
                "args : string, optional": "Extra arguments to Graphviz layout program"
            },
            "Returns:": {
                "Dictionary of x, y, positions keyed by node.": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This is a wrapper for pygraphviz_layout. Note that some graphviz layouts are not guaranteed to be deterministic,\nsee graphviz/graphviz#1767 for more info.",
            "Examples": "G=nx.petersen_graph()\npos=nx.nx_agraph.graphviz_layout(G)\npos=nx.nx_agraph.graphviz_layout(G,prog=\"dot\")"
        }
    },
    {
        "Section ID": "node_disjoint_paths",
        "Description": [
            "Computes node disjoint paths between source and target.",
            "Node disjoint paths are paths that only share their first and last\nnodes. The number of node independent paths between two nodes is\nequal to their local node connectivity."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "s : node": "Source node.",
                "t : node": "Target node.",
                "flow_func : function": "A function for computing the maximum flow among a pair of nodes.\nThe function has to accept at least three parameters: a Digraph,\na source node, and a target node. And return a residual network\nthat follows NetworkX conventions (seemaximum_flow()for\ndetails). If flow_func is None, the default maximum flow function\n(edmonds_karp()) is used. See below for details. The choice\nof the default function may change from version to version and\nshould not be relied on. Default value: None.",
                "cutoff : integer or None (default: None)": "Maximum number of paths to yield. If specified, the maximum flow\nalgorithm will terminate when the flow value reaches or exceeds the\ncutoff. This only works for flows that support the cutoff parameter\n(most do) and is ignored otherwise.",
                "auxiliary : NetworkX DiGraph": "Auxiliary digraph to compute flow based node connectivity. It has\nto have a graph attribute called mapping with a dictionary mapping\nnode names in G and in the auxiliary digraph. If provided\nit will be reused instead of recreated. Default value: None.",
                "residual : NetworkX DiGraph": "Residual network to compute maximum flow. If provided it will be\nreused instead of recreated. Default value: None."
            },
            "Returns:": {
                "paths : generator": "Generator of node disjoint paths."
            },
            "Raises:": {
                "NetworkXNoPath": "If there is no path between source and target.",
                "NetworkXError": "If source or target are not in the graph G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This is a flow based implementation of node disjoint paths. We compute\nthe maximum flow between source and target on an auxiliary directed\nnetwork. The saturated edges in the residual network after running the\nmaximum flow algorithm correspond to node disjoint paths between source\nand target in the original network. This function handles both directed\nand undirected graphs, and can use all flow algorithms from NetworkX flow\npackage.",
            "Examples": "We use in this example the platonic icosahedral graph, which has node\nconnectivity 5, thus there are 5 node disjoint paths between any pair\nof non neighbor nodes.\nG=nx.icosahedral_graph()\nlen(list(nx.node_disjoint_paths(G,0,6)))\n# 5\nIf you need to compute node disjoint paths between several pairs of\nnodes in the same graph, it is recommended that you reuse the\ndata structures that NetworkX uses in the computation: the\nauxiliary digraph for node connectivity and node cuts, and the\nresidual network for the underlying maximum flow computation.\nExample of how to compute node disjoint paths reusing the data\nstructures:\n# You also have to explicitly import the function for\n# building the auxiliary digraph from the connectivity package\nfromnetworkx.algorithms.connectivityimportbuild_auxiliary_node_connectivity\nH=build_auxiliary_node_connectivity(G)\n# And the function for building the residual network from the\n# flow package\nfromnetworkx.algorithms.flowimportbuild_residual_network\n# Note that the auxiliary digraph has an edge attribute named capacity\nR=build_residual_network(H,\"capacity\")\n# Reuse the auxiliary digraph and the residual network by passing them\n# as arguments\nlen(list(nx.node_disjoint_paths(G,0,6,auxiliary=H,residual=R)))\n# 5\nYou can also use alternative flow algorithms for computing node disjoint\npaths. For instance, in dense networks the algorithmshortest_augmenting_path()will usually perform better than\nthe defaultedmonds_karp()which is faster for sparse\nnetworks with highly skewed degree distributions. Alternative flow\nfunctions have to be explicitly imported from the flow package.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\nlen(list(nx.node_disjoint_paths(G,0,6,flow_func=shortest_augmenting_path)))\n# 5"
        }
    },
    {
        "Section ID": "connected_components",
        "Description": [
            "Generate connected components."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "An undirected graph"
            },
            "Returns:": {
                "comp : generator of sets": "A generator of sets of nodes, one for each component of G."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is directed."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For undirected graphs only.",
            "Examples": "Generate a sorted list of connected components, largest first.\nG=nx.path_graph(4)\nnx.add_path(G,[10,11,12])\n[len(c)forcinsorted(nx.connected_components(G),key=len,reverse=True)]\n# [4, 3]\nIf you only want the largest connected component, it\u2019s more\nefficient to use max instead of sort.\nlargest_cc=max(nx.connected_components(G),key=len)\nTo create the induced subgraph of each component use:\nS=[G.subgraph(c).copy()forcinnx.connected_components(G)]"
        }
    },
    {
        "Section ID": "kneser_graph",
        "Description": [
            "Returns the Kneser Graph with parameters n and k .",
            "The Kneser Graph has nodes that are k-tuples (subsets) of the integers\nbetween 0 and n-1 . Nodes are adjacent if their corresponding sets are disjoint."
        ],
        "Field List": {
            "Parameters:": {
                "n: int": "Number of integers from which to make node subsets.\nSubsets are drawn fromset(range(n)).",
                "k: int": "Size of the subsets."
            },
            "Returns:": {
                "G : NetworkX Graph": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.kneser_graph(5,2)\nG.number_of_nodes()\n# 10\nG.number_of_edges()\n# 15\nnx.is_isomorphic(G,nx.petersen_graph())\n# True"
        }
    },
    {
        "Section ID": "schultz_index",
        "Description": [
            "Returns the Schultz Index (of the first kind) of G",
            "The Schultz Index  [3] of a graph is the sum over all node pairs of\ndistances times the sum of degrees. Consider an undirected graph G .\nFor each node pair (u,v) compute dist(u,v)*(deg(u)+deg(v) where dist is the shortest path length between two nodes and deg is the degree of a node.",
            "The Schultz Index is the sum of these quantities over all (unordered)\npairs of nodes."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "The undirected graph of interest.",
                "weight : string or None, optional (default: None)": "If None, every edge has weight 1.\nIf a string, use this edge attribute as the edge weight.\nAny edge attribute not present defaults to 1.\nThe edge weights are used to computing shortest-path distances."
            },
            "Returns:": {
                "number": "The first kind of Schultz Index of the graphG."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]I. Gutman, Selected properties of the Schultz molecular topological index,\nJ. Chem. Inf. Comput. Sci. 34 (1994), 1087\u20131089.https://doi.org/10.1021/ci00021a009  [2]M.V. Diudeaa and I. Gutman, Wiener-Type Topological Indices,\nCroatica Chemica Acta, 71 (1998), 21-51.https://hrcak.srce.hr/132323  [3]H. P. Schultz, Topological organic chemistry. 1.\nGraph theory and topological indices of alkanes,i\nJ. Chem. Inf. Comput. Sci. 29 (1989), 239\u2013257.",
            "Examples": "The Schultz Index of the (unweighted) complete graph onnnodes\nequals the number of pairs of thennodes times2*(n-1),\nsince each pair of nodes is at distance one and the sum of degree\nof two nodes is2*(n-1).\nn=10\nG=nx.complete_graph(n)\nnx.schultz_index(G)==(n*(n-1)/2)*(2*(n-1))\n# True\nGraph that is disconnected\nnx.schultz_index(nx.empty_graph(2))\n# inf"
        }
    },
    {
        "Section ID": "dfs_labeled_edges",
        "Description": [
            "Iterate over edges in a depth-first-search (DFS) labeled by type."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node, optional": "Specify starting node for depth-first search and return edges in\nthe component reachable from source.",
                "depth_limit : int, optional (default=len(G))": "Specify the maximum search depth.",
                "sort_neighbors : function (default=None)": "A function that takes an iterator over nodes as the input, and\nreturns an iterable of the same nodes with a custom ordering.\nFor example,sortedwill sort the nodes in increasing order."
            },
            "Returns:": {
                "edges: generator": "A generator of triples of the form (u,v,d), where (u,v) is the edge being explored in the depth-first search anddis one of the strings \u2018forward\u2019, \u2018nontree\u2019, \u2018reverse\u2019, or \u2018reverse-depth_limit\u2019.\nA \u2018forward\u2019 edge is one in whichuhas been visited butvhas\nnot. A \u2018nontree\u2019 edge is one in which bothuandvhave been\nvisited but the edge is not in the DFS tree. A \u2018reverse\u2019 edge is\none in which bothuandvhave been visited and the edge is in\nthe DFS tree. When thedepth_limitis reached via a \u2018forward\u2019 edge,\na \u2018reverse\u2019 edge is immediately generated rather than the subtree\nbeing explored. To indicate this flavor of \u2018reverse\u2019 edge, the string\nyielded is \u2018reverse-depth_limit\u2019."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "If a source is not specified then a source is chosen arbitrarily and\nrepeatedly until all components in the graph are searched. The implementation of this function is adapted from David Eppstein\u2019s\ndepth-first search function in PADS , with modifications\nto allow depth limits based on the Wikipedia article\n\u201c Depth-limited search \u201d.",
            "Examples": "The labels reveal the complete transcript of the depth-first search\nalgorithm in more detail than, for example,dfs_edges():\nfrompprintimportpprint\n\nG=nx.DiGraph([(0,1),(1,2),(2,1)])\npprint(list(nx.dfs_labeled_edges(G,source=0)))\n# [(0, 0, 'forward'),\n#  (0, 1, 'forward'),\n#  (1, 2, 'forward'),\n#  (2, 1, 'nontree'),\n#  (1, 2, 'reverse'),\n#  (0, 1, 'reverse'),\n#  (0, 0, 'reverse')]"
        }
    },
    {
        "Section ID": "write_gexf",
        "Description": [
            "Write G in GEXF format to path.",
            "\u201cGEXF (Graph Exchange XML Format) is a language for describing\ncomplex networks structures, their associated data and dynamics\u201d [1] .",
            "Node attributes are checked according to the version of the GEXF\nschemas used for parameters which are not user defined,\ne.g. visualization \u2018viz\u2019 [2] . See example for usage."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "path : file or string": "File or file name to write.\nFile names ending in .gz or .bz2 will be compressed.",
                "encoding : string (optional, default: \u2018utf-8\u2019)": "Encoding for text data.",
                "prettyprint : bool (optional, default: True)": "If True use line breaks and indenting in output XML.",
                "version: string (optional, default: \u20181.2draft\u2019)": "The version of GEXF to be used for nodes attributes checking"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This implementation does not support mixed graphs (directed and undirected\nedges together). The node id attribute is set to be the string of the node label.\nIf you want to specify an id use set it as node data, e.g.\nnode[\u2018a\u2019][\u2018id\u2019]=1 to set the id of node \u2018a\u2019 to 1.",
            "References": "[1]GEXF File Format,http://gexf.net/  [2]GEXF schema,http://gexf.net/schema.html",
            "Examples": "G=nx.path_graph(4)\nnx.write_gexf(G,\"test.gexf\")\n# visualization data\n>>> G.nodes[0][\u201cviz\u201d] = {\u201csize\u201d: 54}\n>>> G.nodes[0][\u201cviz\u201d][\u201cposition\u201d] = {\u201cx\u201d: 0, \u201cy\u201d: 1}\n>>> G.nodes[0][\u201cviz\u201d][\u201ccolor\u201d] = {\u201cr\u201d: 0, \u201cg\u201d: 0, \u201cb\u201d: 256}"
        }
    },
    {
        "Section ID": "write_dot",
        "Description": [
            "Write NetworkX graph G to Graphviz dot format on path."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph",
                "path : filename": "Filename or file handle to write"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "To use a specific graph layout, call A.layout prior to write_dot .\nNote that some graphviz layouts are not guaranteed to be deterministic,\nsee graphviz/graphviz#1767 for more info."
        }
    },
    {
        "Section ID": "windmill_graph",
        "Description": [
            "Generate a windmill graph.\nA windmill graph is a graph of n cliques each of size k that are all\njoined at one node.\nIt can be thought of as taking a disjoint union of n cliques of size k ,\nselecting one point from each, and contracting all of the selected points.\nAlternatively, one could generate n cliques of size k-1 and one node\nthat is connected to all other nodes in the graph."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "Number of cliques",
                "k : int": "Size of cliques"
            },
            "Returns:": {
                "G : NetworkX Graph": "windmill graph with n cliques of size k"
            },
            "Raises:": {
                "NetworkXError": "If the number of cliques is less than two\nIf the size of the cliques are less than two"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The node labeled 0 will be the node connected to all other nodes.\nNote that windmill graphs are usually denoted Wd(k,n) , so the parameters\nare in the opposite order as the parameters of this method.",
            "Examples": "G=nx.windmill_graph(4,5)"
        }
    },
    {
        "Section ID": "antichains",
        "Description": [
            "Generates antichains from a directed acyclic graph (DAG).",
            "An antichain is a subset of a partially ordered set such that any\ntwo elements in the subset are incomparable."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX DiGraph": "A directed acyclic graph (DAG)",
                "topo_order: list or tuple, optional": "A topological order for G (if None, the function will compute one)"
            },
            "Yields:": {
                "antichain : list": "a list of nodes inGrepresenting an antichain"
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis not directed",
                "NetworkXUnfeasible": "IfGcontains a cycle"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This function was originally developed by Peter Jipsen and Franco Saliola\nfor the SAGE project. It\u2019s included in NetworkX with permission from the\nauthors. Original SAGE code at: sagemath/sage",
            "References": "[1]Free Lattices, by R. Freese, J. Jezek and J. B. Nation,\nAMS, Vol 42, 1995, p. 226.",
            "Examples": "DG=nx.DiGraph([(1,2),(1,3)])\nlist(nx.antichains(DG))\n# [[], [3], [2], [2, 3], [1]]"
        }
    },
    {
        "Section ID": "bfs_tree",
        "Description": [
            "Returns an oriented tree constructed from of a breadth-first-search\nstarting at source."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node": "Specify starting node for breadth-first search",
                "reverse : bool, optional": "If True traverse a directed graph in the reverse direction",
                "depth_limit : int, optional(default=len(G))": "Specify the maximum search depth",
                "sort_neighbors : function (default=None)": "A function that takes an iterator over nodes as the input, and\nreturns an iterable of the same nodes with a custom ordering.\nFor example,sortedwill sort the nodes in increasing order."
            },
            "Returns:": {
                "T: NetworkX DiGraph": "An oriented tree"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Based on http://www.ics.uci.edu/~eppstein/PADS/BFS.py by D. Eppstein, July 2004. The modifications\nto allow depth limits based on the Wikipedia article\n\u201c Depth-limited-search \u201d.",
            "Examples": "G=nx.path_graph(3)\nlist(nx.bfs_tree(G,1).edges())\n# [(1, 0), (1, 2)]\nH=nx.Graph()\nnx.add_path(H,[0,1,2,3,4,5,6])\nnx.add_path(H,[2,7,8,9,10])\nsorted(list(nx.bfs_tree(H,source=3,depth_limit=3).edges()))\n# [(1, 0), (2, 1), (2, 7), (3, 2), (3, 4), (4, 5), (5, 6), (7, 8)]"
        }
    },
    {
        "Section ID": "np_random_state",
        "Description": [
            "Decorator to generate a numpy RandomState or Generator instance.",
            "The decorator processes the argument indicated by random_state_argument using nx.utils.create_random_state() .\nThe argument value can be a seed (integer), or a numpy.random.RandomState or numpy.random.RandomState instance or ( None or numpy.random ).\nThe latter two options use the global random number generator for numpy.random .",
            "The returned instance is a numpy.random.RandomState or numpy.random.Generator ."
        ],
        "Field List": {
            "Parameters:": {
                "random_state_argument : string or int": "The name or index of the argument to be converted\nto anumpy.random.RandomStateinstance."
            },
            "Returns:": {
                "_random_state : function": "Function whose random_state keyword argument is a RandomState instance."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "Decorate functions like this:\n@np_random_state(\"seed\")defrandom_float(seed=None):returnseed.rand()@np_random_state(0)defrandom_float(rng=None):returnrng.rand()@np_random_state(1)defrandom_array(dims,random_state=1):returnrandom_state.rand(*dims)"
        }
    },
    {
        "Section ID": "is_weighted",
        "Description": [
            "Returns True if G has weighted edges."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.",
                "edge : tuple, optional": "A 2-tuple specifying the only edge inGthat will be tested. If\nNone, then every edge inGis tested.",
                "weight: string, optional": "The attribute name used to query for edge weights."
            },
            "Returns:": {
                "bool": "A boolean signifying ifG, or the specified edge, is weighted."
            },
            "Raises:": {
                "NetworkXError": "If the specified edge does not exist."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.path_graph(4)\nnx.is_weighted(G)\n# False\nnx.is_weighted(G,(2,3))\n# False\nG=nx.DiGraph()\nG.add_edge(1,2,weight=1)\nnx.is_weighted(G)\n# True"
        }
    },
    {
        "Section ID": "simulated_annealing_tsp",
        "Description": [
            "Returns an approximate solution to the traveling salesman problem.",
            "This function uses simulated annealing to approximate the minimal cost\ncycle through the nodes. Starting from a suboptimal solution, simulated\nannealing perturbs that solution, occasionally accepting changes that make\nthe solution worse to escape from a locally optimal solution. The chance\nof accepting such changes decreases over the iterations to encourage\nan optimal result.  In summary, the function returns a cycle starting\nat source for which the total cost is minimized. It also returns the cost.",
            "The chance of accepting a proposed change is related to a parameter called\nthe temperature (annealing has a physical analogue of steel hardening\nas it cools). As the temperature is reduced, the chance of moves that\nincrease cost goes down."
        ],
        "Field List": {
            "Parameters:": {
                "G : Graph": "Gshould be a complete weighted graph.\nThe distance between all pairs of nodes should be included.",
                "init_cycle : list of all nodes or \u201cgreedy\u201d": "The initial solution (a cycle through all nodes returning to the start).\nThis argument has no default to make you think about it.\nIf \u201cgreedy\u201d, usegreedy_tsp(G,weight).\nOther common starting cycles arelist(G)+[next(iter(G))]or the final\nresult ofsimulated_annealing_tspwhen doingthreshold_accepting_tsp.",
                "weight : string, optional (default=\u201dweight\u201d)": "Edge data key corresponding to the edge weight.\nIf any edge does not have this attribute the weight is set to 1.",
                "source : node, optional (default: first node in list(G))": "Starting node.  If None, defaults tonext(iter(G))",
                "temp : int, optional (default=100)": "The algorithm\u2019s temperature parameter. It represents the initial\nvalue of temperature",
                "move : \u201c1-1\u201d or \u201c1-0\u201d or function, optional (default=\u201d1-1\u201d)": "Indicator of what move to use when finding new trial solutions.\nStrings indicate two special built-in moves:\u201c1-1\u201d: 1-1 exchange which transposes the position\nof two elements of the current solution.\nThe function called isswap_two_nodes().\nFor example if we apply 1-1 exchange in the solutionA=[3,2,1,4,3]we can get the following by the transposition of 1 and 4 elements:A'=[3,2,4,1,3]\u201c1-0\u201d: 1-0 exchange which moves an node in the solution\nto a new position.\nThe function called ismove_one_node().\nFor example if we apply 1-0 exchange in the solutionA=[3,2,1,4,3]we can transfer the fourth element to the second position:A'=[3,4,2,1,3]You may provide your own functions to enact a move from\none solution to a neighbor solution. The function must take\nthe solution as input along with aseedinput to control\nrandom number generation (see theseedinput here).\nYour function should maintain the solution as a cycle with\nequal first and last node and all others appearing once.\nYour function should return the new solution.",
                "max_iterations : int, optional (default=10)": "Declared done when this number of consecutive iterations of\nthe outer loop occurs without any change in the best cost solution.",
                "N_inner : int, optional (default=100)": "The number of iterations of the inner loop.",
                "alpha : float between (0, 1), optional (default=0.01)": "Percentage of temperature decrease in each iteration\nof outer loop",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "cycle : list of nodes": "Returns the cycle (list of nodes) that a salesman\ncan follow to minimize total weight of the trip."
            },
            "Raises:": {
                "NetworkXError": "IfGis not complete the algorithm raises an exception."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Simulated Annealing is a metaheuristic local search algorithm.\nThe main characteristic of this algorithm is that it accepts\neven solutions which lead to the increase of the cost in order\nto escape from low quality local optimal solutions. This algorithm needs an initial solution. If not provided, it is\nconstructed by a simple greedy algorithm. At every iteration, the\nalgorithm selects thoughtfully a neighbor solution.\nConsider \\(c(x)\\) cost of current solution and \\(c(x')\\) cost of a\nneighbor solution.\nIf \\(c(x') - c(x) <= 0\\) then the neighbor solution becomes the current\nsolution for the next iteration. Otherwise, the algorithm accepts\nthe neighbor solution with probability \\(p = exp - ([c(x') - c(x)] / temp)\\) .\nOtherwise the current solution is retained. temp is a parameter of the algorithm and represents temperature. Time complexity:\nFor \\(N_i\\) iterations of the inner loop and \\(N_o\\) iterations of the\nouter loop, this algorithm has running time \\(O(N_i * N_o * |V|)\\) . For more information and how the algorithm is inspired see: http://en.wikipedia.org/wiki/Simulated_annealing",
            "Examples": "fromnetworkx.algorithmsimportapproximationasapprox\nG=nx.DiGraph()\nG.add_weighted_edges_from(\n{\n(\"A\",\"B\",3),\n(\"A\",\"C\",17),\n(\"A\",\"D\",14),\n(\"B\",\"A\",3),\n(\"B\",\"C\",12),\n(\"B\",\"D\",16),\n(\"C\",\"A\",13),\n(\"C\",\"B\",12),\n(\"C\",\"D\",4),\n(\"D\",\"A\",14),\n(\"D\",\"B\",15),\n(\"D\",\"C\",2),\n}\n)\ncycle=approx.simulated_annealing_tsp(G,\"greedy\",source=\"D\")\ncost=sum(G[n][nbr][\"weight\"]forn,nbrinnx.utils.pairwise(cycle))\ncycle\n# ['D', 'C', 'B', 'A', 'D']\ncost\n# 31\nincycle=[\"D\",\"B\",\"A\",\"C\",\"D\"]\ncycle=approx.simulated_annealing_tsp(G,incycle,source=\"D\")\ncost=sum(G[n][nbr][\"weight\"]forn,nbrinnx.utils.pairwise(cycle))\ncycle\n# ['D', 'C', 'B', 'A', 'D']\ncost\n# 31"
        }
    },
    {
        "Section ID": "communicability_exp",
        "Description": [
            "Returns communicability between all pairs of nodes in G.",
            "Communicability between pair of node (u,v) of node in G is the sum of\nwalks of different lengths starting at node u and ending at node v."
        ],
        "Field List": {
            "Parameters:": {
                "G: graph": ""
            },
            "Returns:": {
                "comm: dictionary of dictionaries": "Dictionary of dictionaries keyed by nodes with communicability\nas the value."
            },
            "Raises:": {
                "NetworkXError": "If the graph is not undirected and simple."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm uses matrix exponentiation of the adjacency matrix. Let G=(V,E) be a simple undirected graph.  Using the connection between\nthe powers  of the adjacency matrix and the number of walks in the graph,\nthe communicability between nodes u and v is [1] ,",
            "References": "[1]Ernesto Estrada, Naomichi Hatano,\n\u201cCommunicability in complex networks\u201d,\nPhys. Rev. E 77, 036111 (2008).https://arxiv.org/abs/0707.0756",
            "Examples": "G=nx.Graph([(0,1),(1,2),(1,5),(5,4),(2,4),(2,3),(4,3),(3,6)])\nc=nx.communicability_exp(G)"
        }
    },
    {
        "Section ID": "greedy_branching",
        "Description": [
            "Returns a branching obtained through a greedy algorithm.",
            "This algorithm is wrong, and cannot give a proper optimal branching.\nHowever, we include it for pedagogical reasons, as it can be helpful to\nsee what its outputs are.",
            "The output is a branching, and possibly, a spanning arborescence. However,\nit is not guaranteed to be optimal in either case."
        ],
        "Field List": {
            "Parameters:": {
                "G : DiGraph": "The directed graph to scan.",
                "attr : str": "The attribute to use as weights. If None, then each edge will be\ntreated equally with a weight of 1.",
                "default : float": "Whenattris not None, then if an edge does not have that attribute,defaultspecifies what value it should take.",
                "kind : str": "The type of optimum to search for: \u2018min\u2019 or \u2018max\u2019 greedy branching.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "B : directed graph": "The greedily obtained branching."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "from_edgelist",
        "Description": [
            "Returns a graph from a list of edges."
        ],
        "Field List": {
            "Parameters:": {
                "edgelist : list or iterator": "Edge tuples",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "edgelist=[(0,1)]# single edge (0,1)\nG=nx.from_edgelist(edgelist)\nor\nG=nx.Graph(edgelist)# use Graph constructor"
        }
    },
    {
        "Section ID": "Edmonds",
        "Description": [
            "Edmonds algorithm [1] for finding optimal branchings and spanning\narborescences.",
            "This algorithm can find both minimum and maximum spanning arborescences and\nbranchings.",
            "Notes",
            "While this algorithm can find a minimum branching, since it isn\u2019t required\nto be spanning, the minimum branching is always from the set of negative\nweight edges which is most likely the empty set for most graphs.",
            "References"
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {
            "Notes": "While this algorithm can find a minimum branching, since it isn\u2019t required\nto be spanning, the minimum branching is always from the set of negative\nweight edges which is most likely the empty set for most graphs.",
            "References": "[1]J. Edmonds, Optimum Branchings, Journal of Research of the National\nBureau of Standards, 1967, Vol. 71B, p.233-240,https://archive.org/details/jresv71Bn4p233"
        }
    },
    {
        "Section ID": "havel_hakimi_graph",
        "Description": [
            "Returns a bipartite graph from two given degree sequences using a\nHavel-Hakimi style construction.",
            "The graph is composed of two partitions. Set A has nodes 0 to\n(len(aseq) - 1) and set B has nodes len(aseq) to (len(bseq) - 1).\nNodes from the set A are connected to nodes in the set B by\nconnecting the highest degree nodes in set A to the highest degree\nnodes in set B until all stubs are connected."
        ],
        "Field List": {
            "Parameters:": {
                "aseq : list": "Degree sequence for node set A.",
                "bseq : list": "Degree sequence for node set B.",
                "create_using : NetworkX graph instance, optional": "Return graph of this type."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The sum of the two sequences must be equal: sum(aseq)=sum(bseq)\nIf no graph type is specified use MultiGraph with parallel edges.\nIf you want a graph with no parallel edges use create_using=Graph()\nbut then the resulting degree sequences might not be exact. The nodes are assigned the attribute \u2018bipartite\u2019 with the value 0 or 1\nto indicate which bipartite set the node belongs to. This function is not imported in the main namespace.\nTo use it use nx.bipartite.havel_hakimi_graph"
        }
    },
    {
        "Section ID": "zipf_rv",
        "Description": [
            "Returns a random value chosen from the Zipf distribution.",
            "The return value is an integer drawn from the probability distribution",
            "where \\(\\zeta(\\alpha, x_{\\min})\\) is the Hurwitz zeta function."
        ],
        "Field List": {
            "Parameters:": {
                "alpha : float": "Exponent value of the distribution",
                "xmin : int": "Minimum value",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "x : int": "Random value from Zipf distribution"
            },
            "Raises:": {
                "ValueError:": "If xmin < 1 or\nIf alpha <= 1"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The rejection algorithm generates random values for a the power-law\ndistribution in uniformly bounded expected time dependent on\nparameters.  See [1] for details on its operation.",
            "References": "[1]Luc Devroye, Non-Uniform Random Variate Generation,\nSpringer-Verlag, New York, 1986.",
            "Examples": "nx.utils.zipf_rv(alpha=2,xmin=3,seed=42)\n# 8"
        }
    },
    {
        "Section ID": "random_cograph",
        "Description": [
            "Returns a random cograph with \\(2 ^ n\\) nodes.",
            "A cograph is a graph containing no path on four vertices.\nCographs or \\(P_4\\) -free graphs can be obtained from a single vertex\nby disjoint union and complementation operations.",
            "This generator starts off from a single vertex and performs disjoint\nunion and full join operations on itself.\nThe decision on which operation will take place is random."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The order of the cograph.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "G : A random graph containing no path on four vertices.": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]D.G. Corneil, H. Lerchs, L.Stewart Burlingham,\n\u201cComplement reducible graphs\u201d,\nDiscrete Applied Mathematics, Volume 3, Issue 3, 1981, Pages 163-174,\nISSN 0166-218X."
        }
    },
    {
        "Section ID": "eulerian_path",
        "Description": [
            "Return an iterator over the edges of an Eulerian path in G ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "The graph in which to look for an eulerian path.",
                "source : node or None (default: None)": "The node at which to start the search. None means search over all\nstarting nodes.",
                "keys : Bool (default: False)": "Indicates whether to yield edge 3-tuples (u, v, edge_key).\nThe default yields edge 2-tuples"
            },
            "Yields:": {
                "Edge tuples along the eulerian path.": "",
                "Warning: If : source : provided is not the start node of an Euler path": "",
                "will raise error even if an Euler Path exists.": ""
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "arbitrary_element",
        "Description": [
            "Returns an arbitrary element of iterable without removing it.",
            "This is most useful for \u201cpeeking\u201d at an arbitrary element of a set,\nbut can be used for any list, dictionary, etc., as well."
        ],
        "Field List": {
            "Parameters:": {
                "iterable : abc.collections.Iterableinstance": "Any object that implements__iter__, e.g. set, dict, list, tuple,\netc."
            },
            "Returns:": {
                "The object that results from : next(iter(iterable))": ""
            },
            "Raises:": {
                "ValueError": "Ifiterableis an iterator (because the current implementation of\nthis function would consume an element from the iterator)."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This function does not return a random element. If iterable is\nordered, sequential calls will return the same value:",
            "Examples": "Arbitrary elements from common Iterable objects:\nnx.utils.arbitrary_element([1,2,3])# list\n# 1\nnx.utils.arbitrary_element((1,2,3))# tuple\n# 1\nnx.utils.arbitrary_element({1,2,3})# set\n# 1\nd={k:vfork,vinzip([1,2,3],[3,2,1])}\nnx.utils.arbitrary_element(d)# dict_keys\n# 1\nnx.utils.arbitrary_element(d.values())# dict values\n# 3\nstris also an Iterable:\nnx.utils.arbitrary_element(\"hello\")\n# 'h'\nValueErroris raised ifiterableis an iterator:\niterator=iter([1,2,3])# Iterator, *not* Iterable\nnx.utils.arbitrary_element(iterator)Traceback (most recent call last):    ...ValueErrorcannot return an arbitrary item from an iterator"
        }
    },
    {
        "Section ID": "alternating_havel_hakimi_graph",
        "Description": [
            "Returns a bipartite graph from two given degree sequences using\nan alternating Havel-Hakimi style construction.",
            "The graph is composed of two partitions. Set A has nodes 0 to\n(len(aseq) - 1) and set B has nodes len(aseq) to (len(bseq) - 1).\nNodes from the set A are connected to nodes in the set B by\nconnecting the highest degree nodes in set A to alternatively the\nhighest and the lowest degree nodes in set B until all stubs are\nconnected."
        ],
        "Field List": {
            "Parameters:": {
                "aseq : list": "Degree sequence for node set A.",
                "bseq : list": "Degree sequence for node set B.",
                "create_using : NetworkX graph instance, optional": "Return graph of this type."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The sum of the two sequences must be equal: sum(aseq)=sum(bseq)\nIf no graph type is specified use MultiGraph with parallel edges.\nIf you want a graph with no parallel edges use create_using=Graph()\nbut then the resulting degree sequences might not be exact. The nodes are assigned the attribute \u2018bipartite\u2019 with the value 0 or 1\nto indicate which bipartite set the node belongs to. This function is not imported in the main namespace.\nTo use it use nx.bipartite.alternating_havel_hakimi_graph"
        }
    },
    {
        "Section ID": "geographical_threshold_graph",
        "Description": [
            "Returns a geographical threshold graph.",
            "The geographical threshold graph model places \\(n\\) nodes uniformly at\nrandom in a rectangular domain.  Each node \\(u\\) is assigned a weight \\(w_u\\) . Two nodes \\(u\\) and \\(v\\) are joined by an edge if",
            "where r is the distance between u and v , p_dist is any function of r , and \\(\\theta\\) as the threshold parameter. p_dist is used to\ngive weight to the distance between nodes when deciding whether or not\nthey should be connected. The larger p_dist is, the more prone nodes\nseparated by r are to be connected, and vice versa."
        ],
        "Field List": {
            "Parameters:": {
                "n : int or iterable": "Number of nodes or iterable of nodes",
                "theta: float": "Threshold value",
                "dim : int, optional": "Dimension of graph",
                "pos : dict": "Node positions as a dictionary of tuples keyed by node.",
                "weight : dict": "Node weights as a dictionary of numbers keyed by node.",
                "metric : function": "A metric on vectors of numbers (represented as lists or\ntuples). This must be a function that accepts two lists (or\ntuples) as input and yields a number as output. The function\nmust also satisfy the four requirements of ametric.\nSpecifically, if\\(d\\)is the function and\\(x\\),\\(y\\),\nand\\(z\\)are vectors in the graph, then\\(d\\)must satisfy\\(d(x, y) \\ge 0\\),\\(d(x, y) = 0\\)if and only if\\(x = y\\),\\(d(x, y) = d(y, x)\\),\\(d(x, z) \\le d(x, y) + d(y, z)\\).If this argument is not specified, the Euclidean distance metric is\nused.",
                "p_dist : function, optional": "Any function used to give weight to the distance between nodes when\ndeciding whether or not they should be connected.p_distwas\noriginally conceived as a probability density function giving the\nprobability of connecting two nodes that are of metric distancerapart. The implementation here allows for more arbitrary definitions\nofp_distthat do not need to correspond to valid probability\ndensity functions. Thescipy.statspackage has many\nprobability density functions implemented and tools for custom\nprobability density definitions, and passing the.pdfmethod of\nscipy.stats distributions can be used here. Ifp_dist=None(the default), the exponential function\\(r^{-2}\\)is used.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "pos_name : string, default=\u201dpos\u201d": "The name of the node attribute which represents the position\nin 2D coordinates of the node in the returned graph.",
                "weight_name : string, default=\u201dweight\u201d": "The name of the node attribute which represents the weight\nof the node in the returned graph."
            },
            "Returns:": {
                "Graph": "A random geographic threshold graph, undirected and without\nself-loops.Each node has a node attributeposthat stores the\nposition of that node in Euclidean space as provided by theposkeyword argument or, ifposwas not provided, as\ngenerated by this function. Similarly, each node has a node\nattributeweightthat stores the weight of that node as\nprovided or as generated."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "If weights are not specified they are assigned to nodes by drawing randomly\nfrom the exponential distribution with rate parameter \\(\\lambda=1\\) .\nTo specify weights from a different distribution, use the weight keyword\nargument:",
            "References": "[1]Masuda, N., Miwa, H., Konno, N.:\nGeographical threshold graphs with small-world and scale-free\nproperties.\nPhysical Review E 71, 036108 (2005)  [2]Milan Bradonji\u0107, Aric Hagberg and Allon G. Percus,\nGiant component and connectivity in geographical threshold graphs,\nin Algorithms and Models for the Web-Graph (WAW 2007),\nAntony Bonato and Fan Chung (Eds), pp. 209\u2013216, 2007",
            "Examples": "Specify an alternate distance metric using themetrickeyword\nargument. For example, to use thetaxicab metricinstead of the\ndefaultEuclidean metric:\ndist=lambdax,y:sum(abs(a-b)fora,binzip(x,y))\nG=nx.geographical_threshold_graph(10,0.1,metric=dist)"
        }
    },
    {
        "Section ID": "minimum_edge_cut",
        "Description": [
            "Returns a set of edges of minimum cardinality that disconnects G.",
            "If source and target nodes are provided, this function returns the\nset of edges of minimum cardinality that, if removed, would break\nall paths among source and target in G. If not, it returns a set of\nedges of minimum cardinality that disconnects G."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "s : node": "Source node. Optional. Default value: None.",
                "t : node": "Target node. Optional. Default value: None.",
                "flow_func : function": "A function for computing the maximum flow among a pair of nodes.\nThe function has to accept at least three parameters: a Digraph,\na source node, and a target node. And return a residual network\nthat follows NetworkX conventions (seemaximum_flow()for\ndetails). If flow_func is None, the default maximum flow function\n(edmonds_karp()) is used. See below for details. The\nchoice of the default function may change from version\nto version and should not be relied on. Default value: None."
            },
            "Returns:": {
                "cutset : set": "Set of edges that, if removed, would disconnect G. If source\nand target nodes are provided, the set contains the edges that\nif removed, would destroy all paths between source and target."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This is a flow based implementation of minimum edge cut. For\nundirected graphs the algorithm works by finding a \u2018small\u2019 dominating\nset of nodes of G (see algorithm 7 in [1] ) and computing the maximum\nflow between an arbitrary node in the dominating set and the rest of\nnodes in it. This is an implementation of algorithm 6 in [1] . For\ndirected graphs, the algorithm does n calls to the max flow function.\nThe function raises an error if the directed graph is not weakly\nconnected and returns an empty set if it is weakly connected.\nIt is an implementation of algorithm 8 in [1] .",
            "References": "[1](1,2,3)Abdol-Hossein Esfahanian. Connectivity Algorithms.http://www.cse.msu.edu/~cse835/Papers/Graph_connectivity_revised.pdf",
            "Examples": "# Platonic icosahedral graph has edge connectivity 5\nG=nx.icosahedral_graph()\nlen(nx.minimum_edge_cut(G))\n# 5\nYou can use alternative flow algorithms for the underlying\nmaximum flow computation. In dense networks the algorithmshortest_augmenting_path()will usually perform better\nthan the defaultedmonds_karp(), which is faster for\nsparse networks with highly skewed degree distributions.\nAlternative flow functions have to be explicitly imported\nfrom the flow package.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\nlen(nx.minimum_edge_cut(G,flow_func=shortest_augmenting_path))\n# 5\nIf you specify a pair of nodes (source and target) as parameters,\nthis function returns the value of local edge connectivity.\nnx.edge_connectivity(G,3,7)\n# 5\nIf you need to perform several local computations among different\npairs of nodes on the same graph, it is recommended that you reuse\nthe data structures used in the maximum flow computations. Seelocal_edge_connectivity()for details."
        }
    },
    {
        "Section ID": "is_reachable",
        "Description": [
            "Decides whether there is a path from s to t in the\ntournament.",
            "This function is more theoretically efficient than the reachability\nchecks than the shortest path algorithms in networkx.algorithms.shortest_paths .",
            "The given graph must be a tournament, otherwise this function\u2019s\nbehavior is undefined."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A directed graph representing a tournament.",
                "s : node": "A node in the graph.",
                "t : node": "A node in the graph."
            },
            "Returns:": {
                "bool": "Whether there is a path fromstotinG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Although this function is more theoretically efficient than the\ngeneric shortest path functions, a speedup requires the use of\nparallelism. Though it may in the future, the current implementation\ndoes not use parallelism, thus you may not see much of a speedup. This algorithm comes from [1].",
            "References": "[1]Tantau, Till.\n\u201cA note on the complexity of the reachability problem for\ntournaments.\u201dElectronic Colloquium on Computational Complexity. 2001.\n<http://eccc.hpi-web.de/report/2001/092/>",
            "Examples": "G=nx.DiGraph([(1,0),(1,3),(1,2),(2,3),(2,0),(3,0)])\nnx.is_tournament(G)\n# True\nnx.tournament.is_reachable(G,1,3)\n# True\nnx.tournament.is_reachable(G,3,2)\n# False"
        }
    },
    {
        "Section ID": "paley_graph",
        "Description": [
            "Returns the Paley \\(\\frac{(p-1)}{2}\\) -regular graph on \\(p\\) nodes.",
            "The returned graph is a graph on \\(\\mathbb{Z}/p\\mathbb{Z}\\) with edges between \\(x\\) and \\(y\\) if and only if \\(x-y\\) is a nonzero square in \\(\\mathbb{Z}/p\\mathbb{Z}\\) .",
            "If \\(p \\equiv 1  \\pmod 4\\) , \\(-1\\) is a square in \\(\\mathbb{Z}/p\\mathbb{Z}\\) and therefore \\(x-y\\) is a square if and\nonly if \\(y-x\\) is also a square, i.e the edges in the Paley graph are symmetric.",
            "If \\(p \\equiv 3 \\pmod 4\\) , \\(-1\\) is not a square in \\(\\mathbb{Z}/p\\mathbb{Z}\\) and therefore either \\(x-y\\) or \\(y-x\\) is a square in \\(\\mathbb{Z}/p\\mathbb{Z}\\) but not both.",
            "Note that a more general definition of Paley graphs extends this construction\nto graphs over \\(q=p^n\\) vertices, by using the finite field \\(F_q\\) instead of \\(\\mathbb{Z}/p\\mathbb{Z}\\) .\nThis construction requires to compute squares in general finite fields and is\nnot what is implemented here (i.e paley_graph(25) does not return the true\nPaley graph associated with \\(5^2\\) )."
        ],
        "Field List": {
            "Parameters:": {
                "p : int, an odd prime number.": "",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : graph": "The constructed directed graph."
            },
            "Raises:": {
                "NetworkXError": "If the graph is a multigraph."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "Chapter 13 in B. Bollobas, Random Graphs. Second edition.\nCambridge Studies in Advanced Mathematics, 73.\nCambridge University Press, Cambridge (2001)."
        }
    },
    {
        "Section ID": "s_metric",
        "Description": [
            "Returns the s-metric [1] of graph.",
            "The s-metric is defined as the sum of the products deg(u)*deg(v) for every edge (u,v) in G ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "The graph used to compute the s-metric.",
                "normalized : bool (optional)": "Normalize the value.Deprecated since version 3.2:Thenormalizedkeyword argument is deprecated and will be removed\nin the future"
            },
            "Returns:": {
                "s : float": "The s-metric of the graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Lun Li, David Alderson, John C. Doyle, and Walter Willinger,\nTowards a Theory of Scale-Free Graphs:\nDefinition, Properties, and  Implications (Extended Version), 2005.https://arxiv.org/abs/cond-mat/0501169"
        }
    },
    {
        "Section ID": "dag_to_branching",
        "Description": [
            "Returns a branching representing all (overlapping) paths from\nroot nodes to leaf nodes in the given directed acyclic graph.",
            "As described in networkx.algorithms.tree.recognition , a branching is a directed forest in which each node has at most one\nparent. In other words, a branching is a disjoint union of arborescences . For this function, each node of in-degree zero in G becomes a root of one of the arborescences, and there will be\none leaf node for each distinct path from that root to a leaf node\nin G .",
            "Each node v in G with k parents becomes k distinct nodes in\nthe returned branching, one for each parent, and the sub-DAG rooted\nat v is duplicated for each copy. The algorithm then recurses on\nthe children of each copy of v ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A directed acyclic graph."
            },
            "Returns:": {
                "DiGraph": "The branching in which there is a bijection between root-to-leaf\npaths inG(in which multiple paths may share the same leaf)\nand root-to-leaf paths in the branching (in which there is a\nunique path from a root to a leaf).Each node has an attribute \u2018source\u2019 whose value is the original\nnode to which this node corresponds. No other graph, node, or\nedge attributes are copied into this new graph."
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis not directed, or ifGis a multigraph.",
                "HasACycle": "IfGis not acyclic."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This function is not idempotent in the sense that the node labels in\nthe returned branching may be uniquely generated each time the\nfunction is invoked. In fact, the node labels may not be integers;\nin order to relabel the nodes to be more readable, you can use the networkx.convert_node_labels_to_integers() function. The current implementation of this function uses networkx.prefix_tree() , so it is subject to the limitations of\nthat function.",
            "Examples": "To examine which nodes in the returned branching were produced by\nwhich original node in the directed acyclic graph, we can collect\nthe mapping from source node to new nodes into a dictionary. For\nexample, consider the directed diamond graph:\nfromcollectionsimportdefaultdict\nfromoperatorimportitemgetter\n\nG=nx.DiGraph(nx.utils.pairwise(\"abd\"))\nG.add_edges_from(nx.utils.pairwise(\"acd\"))\nB=nx.dag_to_branching(G)\n\nsources=defaultdict(set)\nforv,sourceinB.nodes(data=\"source\"):\nsources[source].add(v)\nlen(sources[\"a\"])\n# 1\nlen(sources[\"d\"])\n# 2\nTo copy node attributes from the original graph to the new graph,\nyou can use a dictionary like the one constructed in the above\nexample:\nforsource,nodesinsources.items():\nforvinnodes:\nB.nodes[v].update(G.nodes[source])"
        }
    },
    {
        "Section ID": "descendants",
        "Description": [
            "Returns all nodes reachable from source in G ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "",
                "source : node inG": ""
            },
            "Returns:": {
                "set()": "The descendants ofsourceinG"
            },
            "Raises:": {
                "NetworkXError": "If nodesourceis not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "DG=nx.path_graph(5,create_using=nx.DiGraph)\nsorted(nx.descendants(DG,2))\n# [3, 4]\nThesourcenode is not a descendant of itself, but can be included manually:\nsorted(nx.descendants(DG,2)|{2})\n# [2, 3, 4]"
        }
    },
    {
        "Section ID": "spectral_layout",
        "Description": [
            "Position nodes using the eigenvectors of the graph Laplacian.",
            "Using the unnormalized Laplacian, the layout shows possible clusters of\nnodes which are an approximation of the ratio cut. If dim is the number of\ndimensions then the positions are the entries of the dim eigenvectors\ncorresponding to the ascending eigenvalues starting from the second one."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph or list of nodes": "A position will be assigned to every node in G.",
                "weight : string or None   optional (default=\u2019weight\u2019)": "The edge attribute that holds the numerical value used for\nthe edge weight.  If None, then all edge weights are 1.",
                "scale : number (default: 1)": "Scale factor for positions.",
                "center : array-like or None": "Coordinate pair around which to center the layout.",
                "dim : int": "Dimension of layout."
            },
            "Returns:": {
                "pos : dict": "A dictionary of positions keyed by node"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Directed graphs will be considered as undirected graphs when\npositioning the nodes. For larger graphs (>500 nodes) this will use the SciPy sparse\neigenvalue solver (ARPACK).",
            "Examples": "G=nx.path_graph(4)\npos=nx.spectral_layout(G)"
        }
    },
    {
        "Section ID": "find_threshold_graph",
        "Description": [
            "Returns a threshold subgraph that is close to largest in G .",
            "The threshold graph will contain the largest degree node in G."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph instance": "An instance ofGraph, orMultiDiGraph",
                "create_using : NetworkX graph class orNone(default), optional": "Type of graph to use when constructing the threshold graph.\nIfNone, infer the appropriate graph type from the input."
            },
            "Returns:": {
                "graph": "A graph instance representing the threshold graph"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Threshold graphs:https://en.wikipedia.org/wiki/Threshold_graph",
            "Examples": "fromnetworkx.algorithms.thresholdimportfind_threshold_graph\nG=nx.barbell_graph(3,3)\nT=find_threshold_graph(G)\nT.nodes# may vary\n# NodeView((7, 8, 5, 6))"
        }
    },
    {
        "Section ID": "number_of_selfloops",
        "Description": [
            "Returns the number of selfloop edges.",
            "A selfloop edge has the same node at both ends."
        ],
        "Field List": {
            "Returns:": {
                "nloops : int": "The number of selfloops."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_edge(1,1)\nG.add_edge(1,2)\nnx.number_of_selfloops(G)\n# 1"
        }
    },
    {
        "Section ID": "triad_type",
        "Description": [
            "Returns the sociological triad type for a triad."
        ],
        "Field List": {
            "Parameters:": {
                "G : digraph": "A NetworkX DiGraph with 3 nodes"
            },
            "Returns:": {
                "triad_type : str": "A string identifying the triad type"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "There can be 6 unique edges in a triad (order-3 DiGraph) (so 2^^6=64 unique\ntriads given 3 nodes). These 64 triads each display exactly 1 of 16\ntopologies of triads (topologies can be permuted). These topologies are\nidentified by the following notation: {m}{a}{n}{type} (for example: 111D, 210, 102) Here:",
            "References": "[1]Snijders, T. (2012). \u201cTransitivity and triads.\u201d University of\nOxford.https://web.archive.org/web/20170830032057/http://www.stats.ox.ac.uk/~snijders/Trans_Triads_ha.pdf",
            "Examples": "G=nx.DiGraph([(1,2),(2,3),(3,1)])\nnx.triad_type(G)\n# '030C'\nG.add_edge(1,3)\nnx.triad_type(G)\n# '120C'"
        }
    },
    {
        "Section ID": "is_threshold_graph",
        "Description": [
            "Returns True if G is a threshold graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph instance": "An instance ofGraph,DiGraph,MultiGraphorMultiDiGraph"
            },
            "Returns:": {
                "bool": "TrueifGis a threshold graph,Falseotherwise."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Threshold graphs:https://en.wikipedia.org/wiki/Threshold_graph",
            "Examples": "fromnetworkx.algorithms.thresholdimportis_threshold_graph\nG=nx.path_graph(3)\nis_threshold_graph(G)\n# True\nG=nx.barbell_graph(3,3)\nis_threshold_graph(G)\n# False"
        }
    },
    {
        "Section ID": "cn_soundarajan_hopcroft",
        "Description": [],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX undirected graph.",
                "ebunch : iterable of node pairs, optional (default = None)": "The score will be computed for each pair of nodes given in the\niterable. The pairs must be given as 2-tuples (u, v) where u\nand v are nodes in the graph. If ebunch is None then all\nnonexistent edges in the graph will be used.\nDefault value: None.",
                "community : string, optional (default = \u2018community\u2019)": "Nodes attribute name containing the community information.\nG[u][community] identifies which community u belongs to. Each\nnode belongs to at most one community. Default value: \u2018community\u2019."
            },
            "Returns:": {
                "piter : iterator": "An iterator of 3-tuples in the form (u, v, p) where (u, v) is a\npair of nodes and p is their score."
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis aDiGraph, aMultigraphor aMultiDiGraph.",
                "NetworkXAlgorithmError": "If no community information is available for a node inebunchor inG(ifebunchisNone).",
                "NodeNotFound": "Ifebunchhas a node that is not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Sucheta Soundarajan and John Hopcroft.\nUsing community information to improve the precision of link\nprediction methods.\nIn Proceedings of the 21st international conference companion on\nWorld Wide Web (WWW \u201812 Companion). ACM, New York, NY, USA, 607-608.http://doi.acm.org/10.1145/2187980.2188150",
            "Examples": "G=nx.path_graph(3)\nG.nodes[0][\"community\"]=0\nG.nodes[1][\"community\"]=0\nG.nodes[2][\"community\"]=0\npreds=nx.cn_soundarajan_hopcroft(G,[(0,2)])\nforu,v,pinpreds:\nprint(f\"({u}, {v}) -> {p}\")\n# (0, 2) -> 2"
        }
    },
    {
        "Section ID": "minimum_node_cut",
        "Description": [
            "Returns a set of nodes of minimum cardinality that disconnects G.",
            "If source and target nodes are provided, this function returns the\nset of nodes of minimum cardinality that, if removed, would destroy\nall paths among source and target in G. If not, it returns a set\nof nodes of minimum cardinality that disconnects G."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "s : node": "Source node. Optional. Default value: None.",
                "t : node": "Target node. Optional. Default value: None.",
                "flow_func : function": "A function for computing the maximum flow among a pair of nodes.\nThe function has to accept at least three parameters: a Digraph,\na source node, and a target node. And return a residual network\nthat follows NetworkX conventions (seemaximum_flow()for\ndetails). If flow_func is None, the default maximum flow function\n(edmonds_karp()) is used. See below for details. The\nchoice of the default function may change from version\nto version and should not be relied on. Default value: None."
            },
            "Returns:": {
                "cutset : set": "Set of nodes that, if removed, would disconnect G. If source\nand target nodes are provided, the set contains the nodes that\nif removed, would destroy all paths between source and target."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This is a flow based implementation of minimum node cut. The algorithm\nis based in solving a number of maximum flow computations to determine\nthe capacity of the minimum cut on an auxiliary directed network that\ncorresponds to the minimum node cut of G. It handles both directed\nand undirected graphs. This implementation is based on algorithm 11\nin [1] .",
            "References": "[1]Abdol-Hossein Esfahanian. Connectivity Algorithms.http://www.cse.msu.edu/~cse835/Papers/Graph_connectivity_revised.pdf",
            "Examples": "# Platonic icosahedral graph has node connectivity 5\nG=nx.icosahedral_graph()\nnode_cut=nx.minimum_node_cut(G)\nlen(node_cut)\n# 5\nYou can use alternative flow algorithms for the underlying maximum\nflow computation. In dense networks the algorithmshortest_augmenting_path()will usually perform better\nthan the defaultedmonds_karp(), which is faster for\nsparse networks with highly skewed degree distributions. Alternative\nflow functions have to be explicitly imported from the flow package.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\nnode_cut==nx.minimum_node_cut(G,flow_func=shortest_augmenting_path)\n# True\nIf you specify a pair of nodes (source and target) as parameters,\nthis function returns a local st node cut.\nlen(nx.minimum_node_cut(G,3,7))\n# 5\nIf you need to perform several local st cuts among different\npairs of nodes on the same graph, it is recommended that you reuse\nthe data structures used in the maximum flow computations. Seeminimum_st_node_cut()for details."
        }
    },
    {
        "Section ID": "no_filter",
        "Description": [
            "Returns a filter function that always evaluates to True."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "tutte_graph",
        "Description": [
            "Returns the Tutte graph.",
            "The Tutte graph is a cubic polyhedral, non-Hamiltonian graph. It has\n46 nodes and 69 edges.\nIt is a counterexample to Tait\u2019s conjecture that every 3-regular polyhedron\nhas a Hamiltonian cycle.\nIt can be realized geometrically from a tetrahedron by multiply truncating\nthree of its vertices [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : networkx Graph": "Tutte graph"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://en.wikipedia.org/wiki/Tutte_graph"
        }
    },
    {
        "Section ID": "gutman_index",
        "Description": [
            "Returns the Gutman Index for the graph G .",
            "The Gutman Index measures the topology of networks, especially for molecule\nnetworks of atoms connected by bonds [1] . It is also called the Schultz Index\nof the second kind [2] .",
            "Consider an undirected graph G with node set V .\nThe Gutman Index of a graph is the sum over all (unordered) pairs of nodes\nof nodes (u,v) , with distance dist(u,v) and degrees deg(u) and deg(v) , of dist(u,v)*deg(u)*deg(v)"
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "weight : string or None, optional (default: None)": "If None, every edge has weight 1.\nIf a string, use this edge attribute as the edge weight.\nAny edge attribute not present defaults to 1.\nThe edge weights are used to computing shortest-path distances."
            },
            "Returns:": {
                "number": "The Gutman Index of the graphG."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]M.V. Diudeaa and I. Gutman, Wiener-Type Topological Indices,\nCroatica Chemica Acta, 71 (1998), 21-51.https://hrcak.srce.hr/132323  [2]I. Gutman, Selected properties of the Schultz molecular topological index,\nJ. Chem. Inf. Comput. Sci. 34 (1994), 1087\u20131089.https://doi.org/10.1021/ci00021a009",
            "Examples": "The Gutman Index of the (unweighted) complete graph onnnodes\nequals the number of pairs of thennodes times(n-1)*(n-1),\nsince each pair of nodes is at distance one and the product of degree of two\nvertices is(n-1)*(n-1).\nn=10\nG=nx.complete_graph(n)\nnx.gutman_index(G)==(n*(n-1)/2)*((n-1)*(n-1))\n# True\nGraphs that are disconnected\nG=nx.empty_graph(2)\nnx.gutman_index(G)\n# inf"
        }
    },
    {
        "Section ID": "eppstein_matching",
        "Description": [
            "Returns the maximum cardinality matching of the bipartite graph G ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected bipartite graph",
                "top_nodes : container": "Container with all nodes in one bipartite node set. If not supplied\nit will be computed. But if more than one solution exists an exception\nwill be raised."
            },
            "Returns:": {
                "matches : dictionary": "The matching is returned as a dictionary,matching, such thatmatching[v]==wif nodevis matched to nodew. Unmatched\nnodes do not occur as a key inmatching."
            },
            "Raises:": {
                "AmbiguousSolution": "Raised if the input bipartite graph is disconnected and no container\nwith all nodes in one bipartite set is provided. When determining\nthe nodes in each bipartite set more than one valid solution is\npossible if the input graph is disconnected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This function is implemented with David Eppstein\u2019s version of the algorithm\nHopcroft\u2013Karp algorithm (see hopcroft_karp_matching() ), which\noriginally appeared in the Python Algorithms and Data Structures library\n(PADS) . See bipartitedocumentation for further details on how bipartite graphs are handled in NetworkX."
        }
    },
    {
        "Section ID": "min_cost_flow_cost",
        "Description": [
            "Find the cost of a minimum cost flow satisfying all demands in digraph G.",
            "G is a digraph with edge costs and capacities and in which nodes\nhave demand, i.e., they want to send or receive some amount of\nflow. A negative demand means that the node wants to send flow, a\npositive demand means that the node want to receive flow. A flow on\nthe digraph G satisfies all demand if the net flow into each node\nis equal to the demand of that node."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "DiGraph on which a minimum cost flow satisfying all demands is\nto be found.",
                "demand : string": "Nodes of the graph G are expected to have an attribute demand\nthat indicates how much flow a node wants to send (negative\ndemand) or receive (positive demand). Note that the sum of the\ndemands should be 0 otherwise the problem in not feasible. If\nthis attribute is not present, a node is considered to have 0\ndemand. Default value: \u2018demand\u2019.",
                "capacity : string": "Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: \u2018capacity\u2019.",
                "weight : string": "Edges of the graph G are expected to have an attribute weight\nthat indicates the cost incurred by sending one unit of flow on\nthat edge. If not present, the weight is considered to be 0.\nDefault value: \u2018weight\u2019."
            },
            "Returns:": {
                "flowCost : integer, float": "Cost of a minimum cost flow satisfying all demands."
            },
            "Raises:": {
                "NetworkXError": "This exception is raised if the input graph is not directed or\nnot connected.",
                "NetworkXUnfeasible": "This exception is raised in the following situations:The sum of the demands is not zero. Then, there is no\nflow satisfying all demands.There is no flow satisfying all demand.",
                "NetworkXUnbounded": "This exception is raised if the digraph G has a cycle of\nnegative cost and infinite capacity. Then, the cost of a flow\nsatisfying all demands is unbounded below."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm is not guaranteed to work if edge weights or demands\nare floating point numbers (overflows and roundoff errors can\ncause problems). As a workaround you can use integer numbers by\nmultiplying the relevant edge attributes by a convenient\nconstant factor (eg 100).",
            "Examples": "A simple example of a min cost flow problem.\nG=nx.DiGraph()\nG.add_node(\"a\",demand=-5)\nG.add_node(\"d\",demand=5)\nG.add_edge(\"a\",\"b\",weight=3,capacity=4)\nG.add_edge(\"a\",\"c\",weight=6,capacity=10)\nG.add_edge(\"b\",\"d\",weight=1,capacity=9)\nG.add_edge(\"c\",\"d\",weight=2,capacity=5)\nflowCost=nx.min_cost_flow_cost(G)\nflowCost\n# 24"
        }
    },
    {
        "Section ID": "maximum_matching",
        "Description": [
            "Returns the maximum cardinality matching in the given bipartite graph.",
            "This function is simply an alias for hopcroft_karp_matching() ."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "to_networkx_graph",
        "Description": [
            "Make a NetworkX graph from a known data structure.",
            "The preferred way to call this is automatically\nfrom the class constructor",
            "instead of the equivalent"
        ],
        "Field List": {
            "Parameters:": {
                "data : object to be converted": "Current known types are:any NetworkX graph\ndict-of-dicts\ndict-of-lists\ncontainer (e.g. set, list, tuple) of edges\niterator (e.g. itertools.chain) that produces edges\ngenerator of edges\nPandas DataFrame (row per edge)\n2D numpy array\nscipy sparse array\npygraphviz agraph",
                "Current known types are:": "any NetworkX graph\ndict-of-dicts\ndict-of-lists\ncontainer (e.g. set, list, tuple) of edges\niterator (e.g. itertools.chain) that produces edges\ngenerator of edges\nPandas DataFrame (row per edge)\n2D numpy array\nscipy sparse array\npygraphviz agraph",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated.",
                "multigraph_input : bool (default False)": "If True and  data is a dict_of_dicts,\ntry to create a multigraph assuming dict_of_dict_of_lists.\nIf data and create_using are both multigraphs then create\na multigraph from a multigraph."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "heawood_graph",
        "Description": [
            "Returns the Heawood Graph, a (3,6) cage.",
            "The Heawood Graph is an undirected graph with 14 nodes and 21 edges,\nnamed after Percy John Heawood [1] .\nIt is cubic symmetric, nonplanar, Hamiltonian, and can be represented\nin LCF notation as [5,-5]^7  [2] .\nIt is the unique (3,6)-cage: the regular cubic graph of girth 6 with\nminimal number of vertices [3] ."
        ],
        "Field List": {
            "Parameters:": {
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : networkx Graph": "Heawood Graph with 14 nodes and 21 edges"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://en.wikipedia.org/wiki/Heawood_graph  [2]https://mathworld.wolfram.com/HeawoodGraph.html  [3]https://www.win.tue.nl/~aeb/graphs/Heawood.html"
        }
    },
    {
        "Section ID": "rooted_tree_isomorphism",
        "Description": [
            "Given two rooted trees t1 and t2 ,\nwith roots root1 and root2 respectively\nthis routine will determine if they are isomorphic.",
            "These trees may be either directed or undirected,\nbut if they are directed, all edges should flow from the root.",
            "It returns the isomorphism, a mapping of the nodes of t1 onto the nodes\nof t2 , such that two trees are then identical.",
            "Note that two trees may have more than one isomorphism, and this\nroutine just returns one valid mapping."
        ],
        "Field List": {
            "Parameters:": {
                "`t1` : NetworkX graph": "One of the trees being compared",
                "`root1` : a node oft1which is the root of the tree": "",
                "`t2` : undirected NetworkX graph": "The other tree being compared",
                "`root2` : a node oft2which is the root of the tree": "",
                "This is a subroutine used to implement `tree_isomorphism`, but will": "",
                "be somewhat faster if you already have rooted trees.": ""
            },
            "Returns:": {
                "isomorphism : list": "A list of pairs in which the left element is a node int1and the right element is a node int2.  The pairs are in\narbitrary order.  If the nodes in one tree is mapped to the names in\nthe other, then trees will be identical. Note that an isomorphism\nwill not necessarily be unique.Ift1andt2are not isomorphic, then it returns the empty list."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "kosaraju_strongly_connected_components",
        "Description": [
            "Generate nodes in strongly connected components of graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "A directed graph."
            },
            "Returns:": {
                "comp : generator of sets": "A generator of sets of nodes, one for each strongly connected\ncomponent of G."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Uses Kosaraju\u2019s algorithm.",
            "Examples": "Generate a sorted list of strongly connected components, largest first.\nG=nx.cycle_graph(4,create_using=nx.DiGraph())\nnx.add_cycle(G,[10,11,12])\n[\nlen(c)\nforcinsorted(\nnx.kosaraju_strongly_connected_components(G),key=len,reverse=True\n)\n]\n# [4, 3]\nIf you only want the largest component, it\u2019s more efficient to\nuse max instead of sort.\nlargest=max(nx.kosaraju_strongly_connected_components(G),key=len)"
        }
    },
    {
        "Section ID": "partition_quality",
        "Description": [
            "Returns the coverage and performance of a partition of G.",
            "The coverage of a partition is the ratio of the number of\nintra-community edges to the total number of edges in the graph.",
            "The performance of a partition is the number of\nintra-community edges plus inter-community non-edges divided by the total\nnumber of potential edges.",
            "This algorithm has complexity \\(O(C^2 + L)\\) where C is the number of communities and L is the number of links."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "partition : sequence": "Partition of the nodes ofG, represented as a sequence of\nsets of nodes (blocks). Each block of the partition represents a\ncommunity."
            },
            "Returns:": {
                "(float, float)": "The (coverage, performance) tuple of the partition, as defined above."
            },
            "Raises:": {
                "NetworkXError": "Ifpartitionis not a valid partition of the nodes ofG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "",
            "References": "[1]Santo Fortunato.\n\u201cCommunity Detection in Graphs\u201d.Physical Reports, Volume 486, Issue 3\u20135 pp. 75\u2013174\n<https://arxiv.org/abs/0906.0612>"
        }
    },
    {
        "Section ID": "from_dict_of_dicts",
        "Description": [
            "Returns a graph from a dictionary of dictionaries."
        ],
        "Field List": {
            "Parameters:": {
                "d : dictionary of dictionaries": "A dictionary of dictionaries adjacency representation.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated.",
                "multigraph_input : bool (default False)": "When True, the dictdis assumed\nto be a dict-of-dict-of-dict-of-dict structure keyed by\nnode to neighbor to edge keys to edge data for multi-edges.\nOtherwise this routine assumes dict-of-dict-of-dict keyed by\nnode to neighbor to edge data."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "dod={0:{1:{\"weight\":1}}}# single edge (0,1)\nG=nx.from_dict_of_dicts(dod)\nor\nG=nx.Graph(dod)# use Graph constructor"
        }
    },
    {
        "Section ID": "max_weight_matching",
        "Description": [
            "Compute a maximum-weighted matching of G.",
            "A matching is a subset of edges in which no node occurs more than once.\nThe weight of a matching is the sum of the weights of its edges.\nA maximal matching cannot add more edges and still be a matching.\nThe cardinality of a matching is the number of matched edges."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected graph",
                "maxcardinality: bool, optional (default=False)": "If maxcardinality is True, compute the maximum-cardinality matching\nwith maximum weight among all maximum-cardinality matchings.",
                "weight: string, optional (default=\u2019weight\u2019)": "Edge data key corresponding to the edge weight.\nIf key not found, uses 1 as weight."
            },
            "Returns:": {
                "matching : set": "A maximal matching of the graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "If G has edges with weight attributes the edge data are used as\nweight values else the weights are assumed to be 1. This function takes time O(number_of_nodes ** 3). If all edge weights are integers, the algorithm uses only integer\ncomputations.  If floating point weights are used, the algorithm\ncould return a slightly suboptimal matching due to numeric\nprecision errors. This method is based on the \u201cblossom\u201d method for finding augmenting\npaths and the \u201cprimal-dual\u201d method for finding a matching of maximum\nweight, both methods invented by Jack Edmonds [1] . Bipartite graphs can also be matched using the functions present in networkx.algorithms.bipartite.matching .",
            "References": "[1]\u201cEfficient Algorithms for Finding Maximum Matching in Graphs\u201d,\nZvi Galil, ACM Computing Surveys, 1986.",
            "Examples": "G=nx.Graph()\nedges=[(1,2,6),(1,3,2),(2,3,1),(2,4,7),(3,5,9),(4,5,3)]\nG.add_weighted_edges_from(edges)\nsorted(nx.max_weight_matching(G))\n# [(2, 4), (5, 3)]"
        }
    },
    {
        "Section ID": "treewidth_min_fill_in",
        "Description": [
            "Returns a treewidth decomposition using the Minimum Fill-in heuristic.",
            "The heuristic chooses a node from the graph, where the number of edges\nadded turning the neighborhood of the chosen node into clique is as\nsmall as possible."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": ""
            },
            "Returns:": {
                "Treewidth decomposition : (int, Graph) tuple": "2-tuple with treewidth and the corresponding decomposed tree."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "is_tournament",
        "Description": [
            "Returns True if and only if G is a tournament.",
            "A tournament is a directed graph, with neither self-loops nor\nmulti-edges, in which there is exactly one directed edge joining\neach pair of distinct nodes."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A directed graph representing a tournament."
            },
            "Returns:": {
                "bool": "Whether the given graph is a tournament graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Some definitions require a self-loop on each node, but that is not\nthe convention used here.",
            "Examples": "G=nx.DiGraph([(0,1),(1,2),(2,0)])\nnx.is_tournament(G)\n# True"
        }
    },
    {
        "Section ID": "attracting_components",
        "Description": [
            "Generates the attracting components in G .",
            "An attracting component in a directed graph G is a strongly connected\ncomponent with the property that a random walker on the graph will never\nleave the component, once it enters the component.",
            "The nodes in attracting components can also be thought of as recurrent\nnodes.  If a random walker enters the attractor containing the node, then\nthe node will be visited infinitely often.",
            "To obtain induced subgraphs on each component use: (G.subgraph(c).copy()forcinattracting_components(G))"
        ],
        "Field List": {
            "Parameters:": {
                "G : DiGraph, MultiDiGraph": "The graph to be analyzed."
            },
            "Returns:": {
                "attractors : generator of sets": "A generator of sets of nodes, one for each attracting component of G."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the input graph is undirected."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "connected_double_edge_swap",
        "Description": [
            "Attempts the specified number of double-edge swaps in the graph G .",
            "A double-edge swap removes two randomly chosen edges (u,v) and (x,y) and creates the new edges (u,x) and (v,y) :",
            "If either (u,x) or (v,y) already exist, then no swap is performed\nso the actual number of swapped edges is always at most  nswap ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "An undirected graph",
                "nswap : integer (optional, default=1)": "Number of double-edge swaps to perform",
                "_window_threshold : integer": "The window size below which connectedness of the graph will be checked\nafter each swap.The \u201cwindow\u201d in this function is a dynamically updated integer that\nrepresents the number of swap attempts to make before checking if the\ngraph remains connected. It is an optimization used to decrease the\nrunning time of the algorithm in exchange for increased complexity of\nimplementation.If the window size is below this threshold, then the algorithm checks\nafter each swap if the graph remains connected by checking if there is a\npath joining the two nodes whose edge was just removed. If the window\nsize is above this threshold, then the algorithm performs do all the\nswaps in the window and only then check if the graph is still connected.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "int": "The number of successful swaps"
            },
            "Raises:": {
                "NetworkXError": "If the input graph is not connected, or if the graph has fewer than four\nnodes."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The initial graph G must be connected, and the resulting graph is\nconnected. The graph G is modified in place.",
            "References": "[1]C. Gkantsidis and M. Mihail and E. Zegura,\nThe Markov chain simulation method for generating connected\npower law random graphs, 2003.http://citeseer.ist.psu.edu/gkantsidis03markov.html"
        }
    },
    {
        "Section ID": "all_node_cuts",
        "Description": [
            "Returns all minimum k cutsets of an undirected graph G.",
            "This implementation is based on Kanevsky\u2019s algorithm [1] for finding all\nminimum-size node cut-sets of an undirected graph G; ie the set (or sets)\nof nodes of cardinality equal to the node connectivity of G. Thus if\nremoved, would break G into two or more connected components."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected graph",
                "k : Integer": "Node connectivity of the input graph. If k is None, then it is\ncomputed. Default value: None.",
                "flow_func : function": "Function to perform the underlying flow computations. Default value isedmonds_karp(). This function performs\nbetter in sparse graphs with right tailed degree distributions.shortest_augmenting_path()will\nperform better in denser graphs."
            },
            "Returns:": {
                "cuts : a generator of node cutsets": "Each node cutset has cardinality equal to the node connectivity of\nthe input graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This implementation is based on the sequential algorithm for finding all\nminimum-size separating vertex sets in a graph [1] . The main idea is to\ncompute minimum cuts using local maximum flow computations among a set\nof nodes of highest degree and all other non-adjacent nodes in the Graph.\nOnce we find a minimum cut, we add an edge between the high degree\nnode and the target node of the local maximum flow computation to make\nsure that we will not find that minimum cut again.",
            "References": "[1](1,2)Kanevsky, A. (1993). Finding all minimum-size separating vertex\nsets in a graph. Networks 23(6), 533\u2013541.http://onlinelibrary.wiley.com/doi/10.1002/net.3230230604/abstract",
            "Examples": "# A two-dimensional grid graph has 4 cutsets of cardinality 2\nG=nx.grid_2d_graph(5,5)\ncutsets=list(nx.all_node_cuts(G))\nlen(cutsets)\n# 4\nall(2==len(cutset)forcutsetincutsets)\n# True\nnx.node_connectivity(G)\n# 2"
        }
    },
    {
        "Section ID": "karate_club_graph",
        "Description": [
            "Returns Zachary\u2019s Karate Club graph.",
            "Each node in the returned graph has a node attribute \u2018club\u2019 that\nindicates the name of the club to which the member represented by that node\nbelongs, either \u2018Mr. Hi\u2019 or \u2018Officer\u2019. Each edge has a weight based on the\nnumber of contexts in which that edge\u2019s incident node members interacted.",
            "References",
            "Examples",
            "To get the name of the club to which a node belongs:"
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Zachary, Wayne W.\n\u201cAn Information Flow Model for Conflict and Fission in Small Groups.\u201dJournal of Anthropological Research, 33, 452\u2013473, (1977).",
            "Examples": "To get the name of the club to which a node belongs:\nG=nx.karate_club_graph()\nG.nodes[5][\"club\"]\n# 'Mr. Hi'\nG.nodes[9][\"club\"]\n# 'Officer'"
        }
    },
    {
        "Section ID": "is_dominating_set",
        "Description": [
            "Checks if nbunch is a dominating set for G .",
            "A dominating set for a graph with node set V is a subset D of V such that every node not in D is adjacent to at least one\nmember of D  [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "nbunch : iterable": "An iterable of nodes in the graphG."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://en.wikipedia.org/wiki/Dominating_set"
        }
    },
    {
        "Section ID": "girth",
        "Description": [
            "Returns the girth of the graph.",
            "The girth of a graph is the length of its shortest cycle, or infinity if\nthe graph is acyclic. The algorithm follows the description given on the\nWikipedia page [1] , and runs in time O(mn) on a graph with m edges and n\nnodes."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": ""
            },
            "Returns:": {
                "int or math.inf": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Wikipedia: Girth",
            "Examples": "All examples below (except P_5) can easily be checked using Wikipedia,\nwhich has a page for each of these famous graphs.\nnx.girth(nx.chvatal_graph())\n# 4\nnx.girth(nx.tutte_graph())\n# 4\nnx.girth(nx.petersen_graph())\n# 5\nnx.girth(nx.heawood_graph())\n# 6\nnx.girth(nx.pappus_graph())\n# 6\nnx.girth(nx.path_graph(5))\n# inf"
        }
    },
    {
        "Section ID": "subgraph_view",
        "Description": [
            "View of G applying a filter on nodes and edges.",
            "subgraph_view provides a read-only view of the input graph that excludes\nnodes and edges based on the outcome of two filter functions filter_node and filter_edge .",
            "The filter_node function takes one argument \u2014 the node \u2014 and returns True if the node should be included in the subgraph, and False if it\nshould not be included.",
            "The filter_edge function takes two (or three arguments if G is a\nmulti-graph) \u2014 the nodes describing an edge, plus the edge-key if\nparallel edges are possible \u2014 and returns True if the edge should be\nincluded in the subgraph, and False if it should not be included.",
            "Both node and edge filter functions are called on graph elements as they\nare queried, meaning there is no up-front cost to creating the view."
        ],
        "Field List": {
            "Parameters:": {
                "G : networkx.Graph": "A directed/undirected graph/multigraph",
                "filter_node : callable, optional": "A function taking a node as input, which returnsTrueif the node\nshould appear in the view.",
                "filter_edge : callable, optional": "A function taking as input the two nodes describing an edge (plus the\nedge-key ifGis a multi-graph), which returnsTrueif the edge\nshould appear in the view."
            },
            "Returns:": {
                "graph : networkx.Graph": "A read-only graph view of the input graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.path_graph(6)\nFilter functions operate on the node, and returnTrueif the node should\nappear in the view:\ndeffilter_node(n1):\nreturnn1!=5\nview=nx.subgraph_view(G,filter_node=filter_node)\nview.nodes()\n# NodeView((0, 1, 2, 3, 4))\nWe can use a closure pattern to filter graph elements based on additional\ndata \u2014 for example, filtering on edge data attached to the graph:\nG[3][4][\"cross_me\"]=False\ndeffilter_edge(n1,n2):\nreturnG[n1][n2].get(\"cross_me\",True)\nview=nx.subgraph_view(G,filter_edge=filter_edge)\nview.edges()\n# EdgeView([(0, 1), (1, 2), (2, 3), (4, 5)])\nview=nx.subgraph_view(\nG,\nfilter_node=filter_node,\nfilter_edge=filter_edge,\n)\nview.nodes()\n# NodeView((0, 1, 2, 3, 4))\nview.edges()\n# EdgeView([(0, 1), (1, 2), (2, 3)])"
        }
    },
    {
        "Section ID": "is_kl_connected",
        "Description": [
            "Returns True if and only if G is locally (k,l) -connected.",
            "A graph is locally (k,l) -connected if for each edge (u,v) in the\ngraph there are at least l edge-disjoint paths of length at most k joining u to v ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "The graph to test for local(k,l)-connectedness.",
                "k : integer": "The maximum length of paths to consider. A higher number means a looser\nconnectivity requirement.",
                "l : integer": "The number of edge-disjoint paths. A higher number means a stricter\nconnectivity requirement.",
                "low_memory : bool": "If this is True, this function uses an algorithm that uses slightly\nmore time but less memory."
            },
            "Returns:": {
                "bool": "Whether the graph is locally(k,l)-connected subgraph."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Chung, Fan and Linyuan Lu. \u201cThe Small World Phenomenon in Hybrid\nPower Law Graphs.\u201dComplex Networks. Springer Berlin Heidelberg,\n2004. 89\u2013104."
        }
    },
    {
        "Section ID": "pagerank",
        "Description": [
            "Returns the PageRank of the nodes in the graph.",
            "PageRank computes a ranking of the nodes in the graph G based on\nthe structure of the incoming links. It was originally designed as\nan algorithm to rank web pages."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.  Undirected graphs will be converted to a directed\ngraph with two directed edges for each undirected edge.",
                "alpha : float, optional": "Damping parameter for PageRank, default=0.85.",
                "personalization: dict, optional": "The \u201cpersonalization vector\u201d consisting of a dictionary with a\nkey some subset of graph nodes and personalization value each of those.\nAt least one personalization value must be non-zero.\nIf not specified, a nodes personalization value will be zero.\nBy default, a uniform distribution is used.",
                "max_iter : integer, optional": "Maximum number of iterations in power method eigenvalue solver.",
                "tol : float, optional": "Error tolerance used to check convergence in power method solver.\nThe iteration will stop after a tolerance oflen(G)*tolis reached.",
                "nstart : dictionary, optional": "Starting value of PageRank iteration for each node.",
                "weight : key, optional": "Edge data key to use as weight.  If None weights are set to 1.",
                "dangling: dict, optional": "The outedges to be assigned to any \u201cdangling\u201d nodes, i.e., nodes without\nany outedges. The dict key is the node the outedge points to and the dict\nvalue is the weight of that outedge. By default, dangling nodes are given\noutedges according to the personalization vector (uniform if not\nspecified). This must be selected to result in an irreducible transition\nmatrix (see notes under google_matrix). It may be common to have the\ndangling dict to be the same as the personalization dict."
            },
            "Returns:": {
                "pagerank : dictionary": "Dictionary of nodes with PageRank as value"
            },
            "Raises:": {
                "PowerIterationFailedConvergence": "If the algorithm fails to converge to the specified tolerance\nwithin the specified number of iterations of the power iteration\nmethod."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The eigenvector calculation is done by the power iteration method\nand has no guarantee of convergence.  The iteration will stop after\nan error tolerance of len(G)*tol has been reached. If the\nnumber of iterations exceed max_iter , a networkx.exception.PowerIterationFailedConvergence exception\nis raised. The PageRank algorithm was designed for directed graphs but this\nalgorithm does not check if the input graph is directed and will\nexecute on undirected graphs by converting each edge in the\ndirected graph to two edges.",
            "References": "[1]A. Langville and C. Meyer,\n\u201cA survey of eigenvector methods of web information retrieval.\u201dhttp://citeseer.ist.psu.edu/713792.html  [2]Page, Lawrence; Brin, Sergey; Motwani, Rajeev and Winograd, Terry,\nThe PageRank citation ranking: Bringing order to the Web. 1999http://dbpubs.stanford.edu:8090/pub/showDoc.Fulltext?lang=en&doc=1999-66&format=pdf",
            "Examples": "G=nx.DiGraph(nx.path_graph(4))\npr=nx.pagerank(G,alpha=0.9)"
        }
    },
    {
        "Section ID": "node_clique_number",
        "Description": [
            "Returns the size of the largest maximal clique containing each given node.",
            "Returns a single or list depending on input nodes.\nAn optional list of cliques can be input if already computed."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "An undirected graph.",
                "cliques : list, optional (default=None)": "A list of cliques, each of which is itself a list of nodes.\nIf not specified, the list of all cliques will be computed\nusingfind_cliques()."
            },
            "Returns:": {
                "int or dict": "Ifnodesis a single node, returns the size of the\nlargest maximal clique inGcontaining that node.\nOtherwise return a dict keyed by node to the size\nof the largest maximal clique containing that node."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "barabasi_albert_graph",
        "Description": [
            "Returns a random graph using Barab\u00e1si\u2013Albert preferential attachment",
            "A graph of \\(n\\) nodes is grown by attaching new nodes each with \\(m\\) edges that are preferentially attached to existing nodes with high degree."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "Number of nodes",
                "m : int": "Number of edges to attach from a new node to existing nodes",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "initial_graph : Graph or None (default)": "Initial network for Barab\u00e1si\u2013Albert algorithm.\nIt should be a connected graph for most use cases.\nA copy ofinitial_graphis used.\nIf None, starts from a star graph on (m+1) nodes."
            },
            "Returns:": {
                "G : Graph": ""
            },
            "Raises:": {
                "NetworkXError": "Ifmdoes not satisfy1<=m<n, or\nthe initial graph number of nodes m0 does not satisfym<=m0<=n."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]A. L. Barab\u00e1si and R. Albert \u201cEmergence of scaling in\nrandom networks\u201d, Science 286, pp 509-512, 1999."
        }
    },
    {
        "Section ID": "all_pairs_node_connectivity",
        "Description": [
            "Compute node connectivity between all pairs of nodes of G."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected graph",
                "nbunch: container": "Container of nodes. If provided node connectivity will be computed\nonly over pairs of nodes in nbunch.",
                "flow_func : function": "A function for computing the maximum flow among a pair of nodes.\nThe function has to accept at least three parameters: a Digraph,\na source node, and a target node. And return a residual network\nthat follows NetworkX conventions (seemaximum_flow()for\ndetails). If flow_func is None, the default maximum flow function\n(edmonds_karp()) is used. See below for details. The\nchoice of the default function may change from version\nto version and should not be relied on. Default value: None."
            },
            "Returns:": {
                "all_pairs : dict": "A dictionary with node connectivity between all pairs of nodes\nin G, or in nbunch if provided."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "read_gml",
        "Description": [
            "Read graph in GML format from path ."
        ],
        "Field List": {
            "Parameters:": {
                "path : filename or filehandle": "The filename or filehandle to read from.",
                "label : string, optional": "If not None, the parsed nodes will be renamed according to node\nattributes indicated bylabel. Default value: \u2018label\u2019.",
                "destringizer : callable, optional": "Adestringizerthat recovers values stored as strings in GML. If it\ncannot convert a string to a value, aValueErroris raised. Default\nvalue : None."
            },
            "Returns:": {
                "G : NetworkX graph": "The parsed graph."
            },
            "Raises:": {
                "NetworkXError": "If the input cannot be parsed."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "GML files are stored using a 7-bit ASCII encoding with any extended\nASCII characters (iso8859-1) appearing as HTML character entities.\nWithout specifying a stringizer / destringizer , the code is capable of\nwriting int / float / str / dict / list data as required by the GML\nspecification.  For writing other data types, and for reading data other\nthan str you need to explicitly supply a stringizer / destringizer . For additional documentation on the GML file format, please see the GML url . See the module docstring networkx.readwrite.gml for more details.",
            "Examples": "G=nx.path_graph(4)\nnx.write_gml(G,\"test.gml\")\nGML values are interpreted as strings by default:\nH=nx.read_gml(\"test.gml\")\nH.nodes\n# NodeView(('0', '1', '2', '3'))\nWhen adestringizeris provided, GML values are converted to the provided type.\nFor example, integer nodes can be recovered as shown below:\nJ=nx.read_gml(\"test.gml\",destringizer=int)\nJ.nodes\n# NodeView((0, 1, 2, 3))"
        }
    },
    {
        "Section ID": "from_graph6_bytes",
        "Description": [
            "Read a simple undirected graph in graph6 format from bytes."
        ],
        "Field List": {
            "Parameters:": {
                "bytes_in : bytes": "Data in graph6 format, without a trailing newline."
            },
            "Returns:": {
                "G : Graph": ""
            },
            "Raises:": {
                "NetworkXError": "If bytes_in is unable to be parsed in graph6 format",
                "ValueError": "If any charactercin bytes_in does not satisfy63<=ord(c)<127."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Graph6 specification\n<http://users.cecs.anu.edu.au/~bdm/data/formats.html>",
            "Examples": "G=nx.from_graph6_bytes(b\"A_\")\nsorted(G.edges())\n# [(0, 1)]"
        }
    },
    {
        "Section ID": "lowest_common_ancestor",
        "Description": [
            "Compute the lowest common ancestor of the given pair of nodes."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX directed graph": "",
                "node1, node2 : nodes in the graph.": "",
                "default : object": "Returned if no common ancestor betweennode1andnode2"
            },
            "Returns:": {
                "The lowest common ancestor of node1 and node2,": "",
                "or default if they have no common ancestors.": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.DiGraph()\nnx.add_path(G,(0,1,2,3))\nnx.add_path(G,(0,4,3))\nnx.lowest_common_ancestor(G,2,4)\n# 0"
        }
    },
    {
        "Section ID": "triangles",
        "Description": [
            "Compute the number of triangles.",
            "Finds the number of triangles that include a node as one vertex."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph",
                "nodes : node, iterable of nodes, or None (default=None)": "If a singleton node, return the number of triangles for that node.\nIf an iterable, compute the number of triangles for each of those nodes.\nIfNone(the default) compute the number of triangles for all nodes inG."
            },
            "Returns:": {
                "out : dict or int": "Ifnodesis a container of nodes, returns number of triangles keyed by node (dict).\nIfnodesis a specific node, returns number of triangles for the node (int)."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Self loops are ignored.",
            "Examples": "G=nx.complete_graph(5)\nprint(nx.triangles(G,0))\n# 6\nprint(nx.triangles(G))\n# {0: 6, 1: 6, 2: 6, 3: 6, 4: 6}\nprint(list(nx.triangles(G,[0,1]).values()))\n# [6, 6]"
        }
    },
    {
        "Section ID": "directed_modularity_matrix",
        "Description": [
            "Returns the directed modularity matrix of G.",
            "The modularity matrix is the matrix B = A - <A>, where A is the adjacency\nmatrix and <A> is the expected adjacency matrix, assuming that the graph\nis described by the configuration model.",
            "More specifically, the element B_ij of B is defined as",
            "where \\(k_i^{in}\\) is the in degree of node i, and \\(k_j^{out}\\) is the out degree\nof node j, with m the number of edges in the graph. When weight is set\nto a name of an attribute edge, Aij, k_i, k_j and m are computed using\nits value."
        ],
        "Field List": {
            "Parameters:": {
                "G : DiGraph": "A NetworkX DiGraph",
                "nodelist : list, optional": "The rows and columns are ordered according to the nodes in nodelist.\nIf nodelist is None, then the ordering is produced by G.nodes().",
                "weight : string or None, optional (default=None)": "The edge attribute that holds the numerical value used for\nthe edge weight.  If None then all edge weights are 1."
            },
            "Returns:": {
                "B : Numpy array": "The modularity matrix of G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "NetworkX defines the element A_ij of the adjacency matrix as 1 if there\nis a link going from node i to node j. Leicht and Newman use the opposite\ndefinition. This explains the different expression for B_ij.",
            "References": "[1]E. A. Leicht, M. E. J. Newman,\n\u201cCommunity structure in directed networks\u201d,\nPhys. Rev Lett., vol. 100, no. 11, p. 118703, 2008.",
            "Examples": "G=nx.DiGraph()\nG.add_edges_from(\n(\n(1,2),\n(1,3),\n(3,1),\n(3,2),\n(3,5),\n(4,5),\n(4,6),\n(5,4),\n(5,6),\n(6,4),\n)\n)\nB=nx.directed_modularity_matrix(G)"
        }
    },
    {
        "Section ID": "multi_source_dijkstra",
        "Description": [
            "Find shortest weighted paths and lengths from a given set of\nsource nodes.",
            "Uses Dijkstra\u2019s algorithm to compute the shortest paths and lengths\nbetween one of the source nodes and the given target , or all other\nreachable nodes if not specified, for a weighted graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "sources : non-empty set of nodes": "Starting nodes for paths. If this is just a set containing a\nsingle node, then all paths computed by this function will start\nfrom that node. If there are two or more nodes in the set, the\ncomputed paths may begin from any one of the start nodes.",
                "target : node label, optional": "Ending node for path",
                "cutoff : integer or float, optional": "Length (sum of edge weights) at which the search is stopped.\nIf cutoff is provided, only return paths with summed weight <= cutoff.",
                "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge."
            },
            "Returns:": {
                "distance, path : pair of dictionaries, or numeric and list": "If target is None, returns a tuple of two dictionaries keyed by node.\nThe first dictionary stores distance from one of the source nodes.\nThe second stores the path from one of the sources to that node.\nIf target is not None, returns a tuple of (distance, path) where\ndistance is the distance from source to target and path is a list\nrepresenting the path from source to target."
            },
            "Raises:": {
                "ValueError": "Ifsourcesis empty.",
                "NodeNotFound": "If any ofsourcesis not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The weight function can be used to hide edges by returning None.\nSo weight=lambdau,v,d:1ifd['color']==\"red\"elseNone will find the shortest red path. Based on the Python cookbook recipe (119466) at https://code.activestate.com/recipes/119466/ This algorithm is not guaranteed to work if edge weights\nare negative or are floating point numbers\n(overflows and roundoff errors can cause problems).",
            "Examples": "G=nx.path_graph(5)\nlength,path=nx.multi_source_dijkstra(G,{0,4})\nfornodein[0,1,2,3,4]:\nprint(f\"{node}: {length[node]}\")\n# 0: 0\n# 1: 1\n# 2: 2\n# 3: 1\n# 4: 0\npath[1]\n# [0, 1]\npath[3]\n# [4, 3]\nlength,path=nx.multi_source_dijkstra(G,{0,4},1)\nlength\n# 1\npath\n# [0, 1]"
        }
    },
    {
        "Section ID": "full_join",
        "Description": [
            "Returns the full join of graphs G and H.",
            "Full join is the union of G and H in which all edges between\nG and H are added.\nThe node sets of G and H must be disjoint,\notherwise an exception is raised."
        ],
        "Field List": {
            "Parameters:": {
                "G, H : graph": "A NetworkX graph",
                "rename : tuple , default=(None, None)": "Node names of G and H can be changed by specifying the tuple\nrename=(\u2018G-\u2018,\u2019H-\u2019) (for example).  Node \u201cu\u201d in G is then renamed\n\u201cG-u\u201d and \u201cv\u201d in H is renamed \u201cH-v\u201d."
            },
            "Returns:": {
                "U : The full join graph with the same type as G.": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "It is recommended that G and H be either both directed or both undirected. If G is directed, then edges from G to H are added as well as from H to G. Note that full_join() does not produce parallel edges for MultiGraphs. The full join operation of graphs G and H is the same as getting\ntheir complement, performing a disjoint union, and finally getting\nthe complement of the resulting graph. Graph, edge, and node attributes are propagated from G and H\nto the union graph.  If a graph attribute is present in both\nG and H the value from H is used.",
            "Examples": "G=nx.Graph([(0,1),(0,2)])\nH=nx.Graph([(3,4)])\nR=nx.full_join(G,H,rename=(\"G\",\"H\"))\nR.nodes\n# NodeView(('G0', 'G1', 'G2', 'H3', 'H4'))\nR.edges\n# EdgeView([('G0', 'G1'), ('G0', 'G2'), ('G0', 'H3'), ('G0', 'H4'), ('G1', 'H3'), ('G1', 'H4'), ('G2', 'H3'), ('G2', 'H4'), ('H3', 'H4')])"
        }
    },
    {
        "Section ID": "simple_cycles",
        "Description": [
            "Find simple cycles (elementary circuits) of a graph.",
            "A simplecycle , or elementarycircuit , is a closed path where\nno node appears twice.  In a directed graph, two simple cycles are distinct\nif they are not cyclic permutations of each other.  In an undirected graph,\ntwo simple cycles are distinct if they are not cyclic permutations of each\nother nor of the other\u2019s reversal.",
            "Optionally, the cycles are bounded in length.  In the unbounded case, we use\na nonrecursive, iterator/generator version of Johnson\u2019s algorithm [1] .  In\nthe bounded case, we use a version of the algorithm of Gupta and\nSuzumura[R155c03fc9e2e-2]_. There may be better algorithms for some cases [3]  [4]  [5] .",
            "The algorithms of Johnson, and Gupta and Suzumura, are enhanced by some\nwell-known preprocessing techniques.  When G is directed, we restrict our\nattention to strongly connected components of G, generate all simple cycles\ncontaining a certain node, remove that node, and further decompose the\nremainder into strongly connected components.  When G is undirected, we\nrestrict our attention to biconnected components, generate all simple cycles\ncontaining a particular edge, remove that edge, and further decompose the\nremainder into biconnected components.",
            "Note that multigraphs are supported by this function \u2013 and in undirected\nmultigraphs, a pair of parallel edges is considered a cycle of length 2.\nLikewise, self-loops are considered to be cycles of length 1.  We define\ncycles as sequences of nodes; so the presence of loops and parallel edges\ndoes not change the number of simple cycles in a graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX DiGraph": "A directed graph",
                "length_bound : int or None, optional (default=None)": "If length_bound is an int, generate all simple cycles of G with length at\nmost length_bound.  Otherwise, generate all simple cycles of G."
            },
            "Yields:": {
                "list of nodes": "Each cycle is represented by a list of nodes along the cycle."
            },
            "Raises:": {
                "ValueError": "when length_bound < 0."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "When length_bound is None, the time complexity is \\(O((n+e)(c+1))\\) for \\(n\\) nodes, \\(e\\) edges and \\(c\\) simple circuits.  Otherwise, when length_bound > 1,\nthe time complexity is \\(O((c+n)(k-1)d^k)\\) where \\(d\\) is the average degree of\nthe nodes of G and \\(k\\) = length_bound.",
            "References": "[1]Finding all the elementary circuits of a directed graph.\nD. B. Johnson, SIAM Journal on Computing 4, no. 1, 77-84, 1975.https://doi.org/10.1137/0204007  [2]Finding All Bounded-Length Simple Cycles in a Directed Graph\nA. Gupta and T. Suzumurahttps://arxiv.org/abs/2105.10094  [3]Enumerating the cycles of a digraph: a new preprocessing strategy.\nG. Loizou and P. Thanish, Information Sciences, v. 27, 163-182, 1982.  [4]A search strategy for the elementary cycles of a directed graph.\nJ.L. Szwarcfiter and P.E. Lauer, BIT NUMERICAL MATHEMATICS,\nv. 16, no. 2, 192-204, 1976.  [5]Optimal Listing of Cycles and st-Paths in Undirected Graphs\nR. Ferreira and R. Grossi and A. Marino and N. Pisanti and R. Rizzi and\nG. Sacomotohttps://arxiv.org/abs/1205.2766",
            "Examples": "edges=[(0,0),(0,1),(0,2),(1,2),(2,0),(2,1),(2,2)]\nG=nx.DiGraph(edges)\nsorted(nx.simple_cycles(G))\n# [[0], [0, 1, 2], [0, 2], [1, 2], [2]]\nTo filter the cycles so that they don\u2019t include certain nodes or edges,\ncopy your graph and eliminate those nodes or edges before calling.\nFor example, to exclude self-loops from the above example:\nH=G.copy()\nH.remove_edges_from(nx.selfloop_edges(G))\nsorted(nx.simple_cycles(H))\n# [[0, 1, 2], [0, 2], [1, 2]]"
        }
    },
    {
        "Section ID": "compute_v_structures",
        "Description": [
            "Iterate through the graph to compute all v-structures.",
            "V-structures are triples in the directed graph where\ntwo parent nodes point to the same child and the two parent nodes\nare not adjacent."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx DiGraph."
            },
            "Returns:": {
                "vstructs : iterator of tuples": "The v structures within the graph. Each v structure is a 3-tuple with the\nparent, collider, and other parent."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Wikipedia: Collider in causal graphs",
            "Examples": "G=nx.DiGraph()\nG.add_edges_from([(1,2),(0,5),(3,1),(2,4),(3,1),(4,5),(1,5)])\nsorted(nx.compute_v_structures(G))\n# [(0, 5, 1), (0, 5, 4), (1, 5, 4)]"
        }
    },
    {
        "Section ID": "path_weight",
        "Description": [
            "Returns total cost associated with specified path and weight"
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.",
                "path: list": "A list of node labels which defines the path to traverse",
                "weight: string": "A string indicating which edge attribute to use for path cost"
            },
            "Returns:": {
                "cost: int or float": "An integer or a float representing the total cost with respect to the\nspecified weight of the specified path"
            },
            "Raises:": {
                "NetworkXNoPath": "If the specified edge does not exist."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "is_simple_path",
        "Description": [
            "Returns True if and only if nodes form a simple path in G .",
            "A simple path in a graph is a nonempty sequence of nodes in which\nno node appears more than once in the sequence, and each adjacent\npair of nodes in the sequence is adjacent in the graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.",
                "nodes : list": "A list of one or more nodes in the graphG."
            },
            "Returns:": {
                "bool": "Whether the given list of nodes represents a simple path inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "An empty list of nodes is not a path but a list of one node is a\npath. Here\u2019s an explanation why. This function operates on node paths . One could also consider edge paths . There is a bijection between node paths and edge\npaths. The length of a path is the number of edges in the path, so a list\nof nodes of length n corresponds to a path of length n - 1.\nThus the smallest edge path would be a list of zero edges, the empty\npath. This corresponds to a list of one node. To convert between a node path and an edge path, you can use code\nlike the following:",
            "Examples": "G=nx.cycle_graph(4)\nnx.is_simple_path(G,[2,3,0])\n# True\nnx.is_simple_path(G,[0,2])\n# False"
        }
    },
    {
        "Section ID": "is_strongly_connected",
        "Description": [
            "Test directed graph for strong connectivity.",
            "A directed graph is strongly connected if and only if every vertex in\nthe graph is reachable from every other vertex."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "A directed graph."
            },
            "Returns:": {
                "connected : bool": "True if the graph is strongly connected, False otherwise."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For directed graphs only.",
            "Examples": "G=nx.DiGraph([(0,1),(1,2),(2,3),(3,0),(2,4),(4,2)])\nnx.is_strongly_connected(G)\n# True\nG.remove_edge(2,3)\nnx.is_strongly_connected(G)\n# False"
        }
    },
    {
        "Section ID": "multi_source_dijkstra_path",
        "Description": [
            "Find shortest weighted paths in G from a given set of source\nnodes.",
            "Compute shortest path between any of the source nodes and all other\nreachable nodes for a weighted graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "sources : non-empty set of nodes": "Starting nodes for paths. If this is just a set containing a\nsingle node, then all paths computed by this function will start\nfrom that node. If there are two or more nodes in the set, the\ncomputed paths may begin from any one of the start nodes.",
                "cutoff : integer or float, optional": "Length (sum of edge weights) at which the search is stopped.\nIf cutoff is provided, only return paths with summed weight <= cutoff.",
                "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge."
            },
            "Returns:": {
                "paths : dictionary": "Dictionary of shortest paths keyed by target."
            },
            "Raises:": {
                "ValueError": "Ifsourcesis empty.",
                "NodeNotFound": "If any ofsourcesis not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The weight function can be used to hide edges by returning None.\nSo weight=lambdau,v,d:1ifd['color']==\"red\"elseNone will find the shortest red path.",
            "Examples": "G=nx.path_graph(5)\npath=nx.multi_source_dijkstra_path(G,{0,4})\npath[1]\n# [0, 1]\npath[3]\n# [4, 3]"
        }
    },
    {
        "Section ID": "enumerate_all_cliques",
        "Description": [
            "Returns all cliques in an undirected graph.",
            "This function returns an iterator over cliques, each of which is a\nlist of nodes. The iteration is ordered by cardinality of the\ncliques: first all cliques of size one, then all cliques of size\ntwo, etc."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "An undirected graph."
            },
            "Returns:": {
                "iterator": "An iterator over cliques, each of which is a list of nodes inG. The cliques are ordered according to size."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "To obtain a list of all cliques, use list(enumerate_all_cliques(G)) . However, be aware that in the\nworst-case, the length of this list can be exponential in the number\nof nodes in the graph (for example, when the graph is the complete\ngraph). This function avoids storing all cliques in memory by only\nkeeping current candidate node lists in memory during its search. The implementation is adapted from the algorithm by Zhang, et\nal. (2005) [1] to output all cliques discovered. This algorithm ignores self-loops and parallel edges, since cliques\nare not conventionally defined with such edges.",
            "References": "[1]Yun Zhang, Abu-Khzam, F.N., Baldwin, N.E., Chesler, E.J.,\nLangston, M.A., Samatova, N.F.,\n\u201cGenome-Scale Computational Approaches to Memory-Intensive\nApplications in Systems Biology\u201d.Supercomputing, 2005. Proceedings of the ACM/IEEE SC 2005\nConference, pp. 12, 12\u201318 Nov. 2005.\n<https://doi.org/10.1109/SC.2005.29>."
        }
    },
    {
        "Section ID": "weighted_choice",
        "Description": [
            "Returns a single element from a weighted sample.",
            "The input is a dictionary of items with weights as values."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "contracted_edge",
        "Description": [
            "Returns the graph that results from contracting the specified edge.",
            "Edge contraction identifies the two endpoints of the edge as a single node\nincident to any edge that was incident to the original two nodes. A graph\nthat results from edge contraction is called a minor of the original\ngraph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "The graph whose edge will be contracted.",
                "edge : tuple": "Must be a pair of nodes inG.",
                "self_loops : Boolean": "If this is True, any edges (includingedge) joining the\nendpoints ofedgeinGbecome self-loops on the new node in the\nreturned graph.",
                "copy : Boolean (default True)": "If this is True, a the contraction will be performed on a copy ofG,\notherwise the contraction will happen in place."
            },
            "Returns:": {
                "Networkx graph": "A new graph object of the same type asG(leavingGunmodified)\nwith endpoints ofedgeidentified in a single node. The right node\nofedgewill be merged into the left one, so only the left one will\nappear in the returned graph."
            },
            "Raises:": {
                "ValueError": "Ifedgeis not an edge inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "Attempting to contract two nonadjacent nodes yields an error:\nG=nx.cycle_graph(4)\nnx.contracted_edge(G,(1,3))Traceback (most recent call last):  ...ValueErrorEdge (1, 3) does not exist in graph G; cannot contract it\nContracting two adjacent nodes in the cycle graph onnnodes yields the\ncycle graph onn - 1nodes:\nC5=nx.cycle_graph(5)\nC4=nx.cycle_graph(4)\nM=nx.contracted_edge(C5,(0,1),self_loops=False)\nnx.is_isomorphic(M,C4)\n# True"
        }
    },
    {
        "Section ID": "hopcroft_karp_matching",
        "Description": [
            "Returns the maximum cardinality matching of the bipartite graph G .",
            "A matching is a set of edges that do not share any nodes. A maximum\ncardinality matching is a matching with the most edges possible. It\nis not always unique. Finding a matching in a bipartite graph can be\ntreated as a networkx flow problem.",
            "The functions hopcroft_karp_matching and maximum_matching are aliases of the same function."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected bipartite graph",
                "top_nodes : container of nodes": "Container with all nodes in one bipartite node set. If not supplied\nit will be computed. But if more than one solution exists an exception\nwill be raised."
            },
            "Returns:": {
                "matches : dictionary": "The matching is returned as a dictionary,matches, such thatmatches[v]==wif nodevis matched to nodew. Unmatched\nnodes do not occur as a key inmatches."
            },
            "Raises:": {
                "AmbiguousSolution": "Raised if the input bipartite graph is disconnected and no container\nwith all nodes in one bipartite set is provided. When determining\nthe nodes in each bipartite set more than one valid solution is\npossible if the input graph is disconnected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This function is implemented with the Hopcroft\u2013Karp matching algorithm for\nbipartite graphs. See bipartitedocumentation for further details on how bipartite graphs are handled in NetworkX.",
            "References": "[1]John E. Hopcroft and Richard M. Karp. \u201cAn n^{5 / 2} Algorithm for\nMaximum Matchings in Bipartite Graphs\u201d In:SIAM Journal of Computing2.4 (1973), pp. 225\u2013231. <https://doi.org/10.1137/0202019>."
        }
    },
    {
        "Section ID": "lukes_partitioning",
        "Description": [
            "Optimal partitioning of a weighted tree using the Lukes algorithm.",
            "This algorithm partitions a connected, acyclic graph featuring integer\nnode weights and float edge weights. The resulting clusters are such\nthat the total weight of the nodes in each cluster does not exceed\nmax_size and that the weight of the edges that are cut by the partition\nis minimum. The algorithm is based on [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "max_size : int": "Maximum weight a partition can have in terms of sum of\nnode_weight for all nodes in the partition",
                "edge_weight : key": "Edge data key to use as weight. If None, the weights are all\nset to one.",
                "node_weight : key": "Node data key to use as weight. If None, the weights are all\nset to one. The data must be int."
            },
            "Returns:": {
                "partition : list": "A list of sets of nodes representing the clusters of the\npartition."
            },
            "Raises:": {
                "NotATree": "If G is not a tree.",
                "TypeError": "If any of the values of node_weight is not int."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Lukes, J. A. (1974).\n\u201cEfficient Algorithm for the Partitioning of Trees.\u201d\nIBM Journal of Research and Development, 18(3), 217\u2013224."
        }
    },
    {
        "Section ID": "ring_of_cliques",
        "Description": [
            "Defines a \u201cring of cliques\u201d graph.",
            "A ring of cliques graph is consisting of cliques, connected through single\nlinks. Each clique is a complete graph."
        ],
        "Field List": {
            "Parameters:": {
                "num_cliques : int": "Number of cliques",
                "clique_size : int": "Size of cliques"
            },
            "Returns:": {
                "G : NetworkX Graph": "ring of cliques graph"
            },
            "Raises:": {
                "NetworkXError": "If the number of cliques is lower than 2 or\nif the size of cliques is smaller than 2."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The connected_caveman_graph graph removes a link from each clique to\nconnect it with the next clique. Instead, the ring_of_cliques graph\nsimply adds the link without removing any link from the cliques.",
            "Examples": "G=nx.ring_of_cliques(8,4)"
        }
    },
    {
        "Section ID": "all_shortest_paths",
        "Description": [
            "Compute all shortest simple paths in the graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node": "Starting node for path.",
                "target : node": "Ending node for path.",
                "weight : None, string or function, optional (default = None)": "If None, every edge has weight/distance/cost 1.\nIf a string, use this edge attribute as the edge weight.\nAny edge attribute not present defaults to 1.\nIf this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly\nthree positional arguments: the two endpoints of an edge and\nthe dictionary of edge attributes for that edge.\nThe function must return a number.",
                "method : string, optional (default = \u2018dijkstra\u2019)": "The algorithm to use to compute the path lengths.\nSupported options: \u2018dijkstra\u2019, \u2018bellman-ford\u2019.\nOther inputs produce a ValueError.\nIfweightis None, unweighted graph methods are used, and this\nsuggestion is ignored."
            },
            "Returns:": {
                "paths : generator of lists": "A generator of all paths between source and target."
            },
            "Raises:": {
                "ValueError": "Ifmethodis not among the supported options.",
                "NetworkXNoPath": "Iftargetcannot be reached fromsource."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "There may be many shortest paths between the source and target.  If G\ncontains zero-weight cycles, this function will not produce all shortest\npaths because doing so would produce infinitely many paths of unbounded\nlength \u2013 instead, we only produce the shortest simple paths.",
            "Examples": "G=nx.Graph()\nnx.add_path(G,[0,1,2])\nnx.add_path(G,[0,10,2])\nprint([pforpinnx.all_shortest_paths(G,source=0,target=2)])\n# [[0, 1, 2], [0, 10, 2]]"
        }
    },
    {
        "Section ID": "from_pydot",
        "Description": [
            "Returns a NetworkX graph from a Pydot graph."
        ],
        "Field List": {
            "Parameters:": {
                "P : Pydot graph": "A graph created with Pydot"
            },
            "Returns:": {
                "G : NetworkX multigraph": "A MultiGraph or MultiDiGraph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "K5=nx.complete_graph(5)\nA=nx.nx_pydot.to_pydot(K5)\nG=nx.nx_pydot.from_pydot(A)# return MultiGraph\n# make a Graph instead of MultiGraph\n>>> G = nx.Graph(nx.nx_pydot.from_pydot(A))"
        }
    },
    {
        "Section ID": "nodes_or_number",
        "Description": [
            "Decorator to allow number of nodes or container of nodes.",
            "With this decorator, the specified argument can be either a number or a container\nof nodes. If it is a number, the nodes used are range(n) .\nThis allows nx.complete_graph(50) in place of nx.complete_graph(list(range(50))) .\nAnd it also allows nx.complete_graph(any_list_of_nodes) ."
        ],
        "Field List": {
            "Parameters:": {
                "which_args : string or int or sequence of strings or ints": "If string, the name of the argument to be treated.\nIf int, the index of the argument to be treated.\nIf more than one node argument is allowed, can be a list of locations."
            },
            "Returns:": {
                "_nodes_or_numbers : function": "Function which replaces int args with ranges."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "Decorate functions like this:\n@nodes_or_number(\"nodes\")defempty_graph(nodes):# nodes is converted to a list of nodes@nodes_or_number(0)defempty_graph(nodes):# nodes is converted to a list of nodes@nodes_or_number([\"m1\",\"m2\"])defgrid_2d_graph(m1,m2,periodic=False):# m1 and m2 are each converted to a list of nodes@nodes_or_number([0,1])defgrid_2d_graph(m1,m2,periodic=False):# m1 and m2 are each converted to a list of nodes@nodes_or_number(1)deffull_rary_tree(r,n)# presumably r is a number. It is not handled by this decorator.# n is converted to a list of nodes"
        }
    },
    {
        "Section ID": "all_simple_edge_paths",
        "Description": [
            "Generate lists of edges for all simple paths in G from source to target.",
            "A simple path is a path with no repeated nodes."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node": "Starting node for path",
                "target : nodes": "Single node or iterable of nodes at which to end path",
                "cutoff : integer, optional": "Depth to stop the search. Only paths of length <= cutoff are returned."
            },
            "Returns:": {
                "path_generator: generator": "A generator that produces lists of simple paths.  If there are no paths\nbetween the source and target within the given cutoff the generator\nproduces no output.\nFor multigraphs, the list of edges have elements of the form(u,v,k).\nWherekcorresponds to the edge key."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm uses a modified depth-first search to generate the\npaths [1] .  A single path can be found in \\(O(V+E)\\) time but the\nnumber of simple paths in a graph can be very large, e.g. \\(O(n!)\\) in\nthe complete graph of order \\(n\\) .",
            "References": "[1]R. Sedgewick, \u201cAlgorithms in C, Part 5: Graph Algorithms\u201d,\nAddison Wesley Professional, 3rd ed., 2001.",
            "Examples": "Print the simple path edges of a Graph:\ng=nx.Graph([(1,2),(2,4),(1,3),(3,4)])\nforpathinsorted(nx.all_simple_edge_paths(g,1,4)):\nprint(path)\n# [(1, 2), (2, 4)]\n# [(1, 3), (3, 4)]\nPrint the simple path edges of a MultiGraph. Returned edges come with\ntheir associated keys:\nmg=nx.MultiGraph()\nmg.add_edge(1,2,key=\"k0\")\n# 'k0'\nmg.add_edge(1,2,key=\"k1\")\n# 'k1'\nmg.add_edge(2,3,key=\"k0\")\n# 'k0'\nforpathinsorted(nx.all_simple_edge_paths(mg,1,3)):\nprint(path)\n# [(1, 2, 'k0'), (2, 3, 'k0')]\n# [(1, 2, 'k1'), (2, 3, 'k0')]\nWhensourceis one of the targets, the empty path starting and ending atsourcewithout traversing any edge is considered a valid simple edge path\nand is included in the results:\nG=nx.Graph()\nG.add_node(0)\npaths=list(nx.all_simple_edge_paths(G,0,0))\nforpathinpaths:\nprint(path)\n# []\nlen(paths)\n# 1"
        }
    },
    {
        "Section ID": "convert_node_labels_to_integers",
        "Description": [
            "Returns a copy of the graph G with the nodes relabeled using\nconsecutive integers."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "first_label : int, optional (default=0)": "An integer specifying the starting offset in numbering nodes.\nThe new integer labels are numbered first_label, \u2026, n-1+first_label.",
                "ordering : string": "\u201cdefault\u201d : inherit node ordering from G.nodes()\n\u201csorted\u201d  : inherit node ordering from sorted(G.nodes())\n\u201cincreasing degree\u201d : nodes are sorted by increasing degree\n\u201cdecreasing degree\u201d : nodes are sorted by decreasing degree",
                "label_attribute : string, optional (default=None)": "Name of node attribute to store old label.  If None no attribute\nis created."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Node and edge attribute data are copied to the new (relabeled) graph. There is no guarantee that the relabeling of nodes to integers will\ngive the same two integers for two (even identical graphs).\nUse the ordering argument to try to preserve the order."
        }
    },
    {
        "Section ID": "cut_size",
        "Description": [
            "Returns the size of the cut between two sets of nodes.",
            "A cut is a partition of the nodes of a graph into two sets. The cut size is the sum of the weights of the edges \u201cbetween\u201d the two\nsets of nodes."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "S : collection": "A collection of nodes inG.",
                "T : collection": "A collection of nodes inG. If not specified, this is taken to\nbe the set complement ofS.",
                "weight : object": "Edge attribute key to use as weight. If not specified, edges\nhave weight one."
            },
            "Returns:": {
                "number": "Total weight of all edges from nodes in setSto nodes in\nsetT(and, in the case of directed graphs, all edges from\nnodes inTto nodes inS)."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "In a multigraph, the cut size is the total weight of edges including\nmultiplicity.",
            "Examples": "In the graph with two cliques joined by a single edges, the natural\nbipartition of the graph into two blocks, one for each clique,\nyields a cut of weight one:\nG=nx.barbell_graph(3,0)\nS={0,1,2}\nT={3,4,5}\nnx.cut_size(G,S,T)\n# 1\nEach parallel edge in a multigraph is counted when determining the\ncut size:\nG=nx.MultiGraph([\"ab\",\"ab\"])\nS={\"a\"}\nT={\"b\"}\nnx.cut_size(G,S,T)\n# 2"
        }
    },
    {
        "Section ID": "node_degree_xy",
        "Description": [
            "Generate node degree-degree pairs for edges in G."
        ],
        "Field List": {
            "Parameters:": {
                "G: NetworkX graph": "",
                "x: string (\u2018in\u2019,\u2019out\u2019)": "The degree type for source node (directed graphs only).",
                "y: string (\u2018in\u2019,\u2019out\u2019)": "The degree type for target node (directed graphs only).",
                "weight: string or None, optional (default=None)": "The edge attribute that holds the numerical value used\nas a weight.  If None, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node.",
                "nodes: list or iterable (optional)": "Use only edges that are adjacency to specified nodes.\nThe default is all nodes."
            },
            "Returns:": {
                "(x, y): 2-tuple": "Generates 2-tuple of (degree, degree) values."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For undirected graphs each edge is produced twice, once for each edge\nrepresentation (u, v) and (v, u), with the exception of self-loop edges\nwhich only appear once.",
            "Examples": "G=nx.DiGraph()\nG.add_edge(1,2)\nlist(nx.node_degree_xy(G,x=\"out\",y=\"in\"))\n# [(1, 1)]\nlist(nx.node_degree_xy(G,x=\"in\",y=\"out\"))\n# [(0, 0)]"
        }
    },
    {
        "Section ID": "not_implemented_for",
        "Description": [
            "Decorator to mark algorithms as not implemented"
        ],
        "Field List": {
            "Parameters:": {
                "graph_types : container of strings": "Entries must be one of \u201cdirected\u201d, \u201cundirected\u201d, \u201cmultigraph\u201d, or \u201cgraph\u201d."
            },
            "Returns:": {
                "_require : function": "The decorated function."
            },
            "Raises:": {
                "NetworkXNotImplemented": "",
                "If any of the packages cannot be imported": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Multiple types are joined logically with \u201cand\u201d.\nFor \u201cor\u201d use multiple @not_implemented_for() lines.",
            "Examples": "Decorate functions like this:\n@not_implemented_for(\"directed\")defsp_function(G):pass# rule out MultiDiGraph@not_implemented_for(\"directed\",\"multigraph\")defsp_np_function(G):pass# rule out all except DiGraph@not_implemented_for(\"undirected\")@not_implemented_for(\"multigraph\")defsp_np_function(G):pass"
        }
    },
    {
        "Section ID": "single_target_shortest_path_length",
        "Description": [
            "Compute the shortest path lengths to target from all reachable nodes."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "target : node": "Target node for path",
                "cutoff : integer, optional": "Depth to stop the search. Only paths of length <= cutoff are returned."
            },
            "Returns:": {
                "lengths : iterator": "(source, shortest path length) iterator"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.path_graph(5,create_using=nx.DiGraph())\nlength=dict(nx.single_target_shortest_path_length(G,4))\nlength[0]\n# 4\nfornodeinrange(5):\nprint(f\"{node}: {length[node]}\")\n# 0: 4\n# 1: 3\n# 2: 2\n# 3: 1\n# 4: 0"
        }
    },
    {
        "Section ID": "degree_mixing_dict",
        "Description": [
            "Returns dictionary representation of mixing matrix for degree."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "NetworkX graph object.",
                "x: string (\u2018in\u2019,\u2019out\u2019)": "The degree type for source node (directed graphs only).",
                "y: string (\u2018in\u2019,\u2019out\u2019)": "The degree type for target node (directed graphs only).",
                "weight: string or None, optional (default=None)": "The edge attribute that holds the numerical value used\nas a weight.  If None, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node.",
                "normalized : bool (default=False)": "Return counts if False or probabilities if True."
            },
            "Returns:": {
                "d: dictionary": "Counts or joint probability of occurrence of degree pairs."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "join_trees",
        "Description": [
            "Returns a new rooted tree made by joining rooted_trees",
            "Constructs a new tree by joining each tree in rooted_trees .\nA new root node is added and connected to each of the roots\nof the input trees. While copying the nodes from the trees,\nrelabeling to integers occurs. If the label_attribute is provided,\nthe old node labels will be stored in the new tree under this attribute."
        ],
        "Field List": {
            "Parameters:": {
                "rooted_trees : list": "A list of pairs in which each left element is a NetworkX graph\nobject representing a tree and each right element is the root\nnode of that tree. The nodes of these trees will be relabeled to\nintegers.",
                "label_attribute : str": "If provided, the old node labels will be stored in the new tree\nunder this node attribute. If not provided, the original labels\nof the nodes in the input trees are not stored.",
                "first_label : int, optional (default=0)": "Specifies the label for the new root node. If provided, the root node of the joined tree\nwill have this label. If not provided, the root node will default to a label of 0."
            },
            "Returns:": {
                "NetworkX graph": "The rooted tree resulting from joining the providedrooted_trees. The new tree has a root node\nlabeled as specified byfirst_label(defaulting to 0 if not provided). Subtrees from the inputrooted_treesare attached to this new root node. Each non-root node, if thelabel_attributeis provided, has an attribute that indicates the original label of the node in the input tree."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Trees are stored in NetworkX as NetworkX Graphs. There is no specific\nenforcement of the fact that these are trees. Testing for each tree\ncan be done using networkx.is_tree() . Graph, edge, and node attributes are propagated from the given\nrooted trees to the created tree. If there are any overlapping graph\nattributes, those from later trees will overwrite those from earlier\ntrees in the tuple of positional arguments.",
            "Examples": "Join two full balanced binary trees of heighthto get a full\nbalanced binary tree of depthh+ 1:\nh=4\nleft=nx.balanced_tree(2,h)\nright=nx.balanced_tree(2,h)\njoined_tree=nx.join([(left,0),(right,0)])\nnx.is_isomorphic(joined_tree,nx.balanced_tree(2,h+1))\n# True"
        }
    },
    {
        "Section ID": "closeness_centrality",
        "Description": [
            "Compute the closeness centrality for nodes in a bipartite network.",
            "The closeness of a node is the distance to all other nodes in the\ngraph or in the case that the graph is not connected to all other nodes\nin the connected component containing that node."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A bipartite network",
                "nodes : list or container": "Container with all nodes in one bipartite node set.",
                "normalized : bool, optional": "If True (default) normalize by connected component size."
            },
            "Returns:": {
                "closeness : dictionary": "Dictionary keyed by node with bipartite closeness centrality\nas the value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The nodes input parameter must contain all nodes in one bipartite node set,\nbut the dictionary returned contains all nodes from both node sets.\nSee bipartitedocumentation for further details on how bipartite graphs are handled in NetworkX. Closeness centrality is normalized by the minimum distance possible.\nIn the bipartite case the minimum distance for a node in one bipartite\nnode set is 1 from all nodes in the other node set and 2 from all\nother nodes in its own set [1] . Thus the closeness centrality\nfor node v in the two bipartite sets U with n nodes and V with m nodes is",
            "References": "[1]Borgatti, S.P. and Halgin, D. In press. \u201cAnalyzing Affiliation\nNetworks\u201d. In Carrington, P. and Scott, J. (eds) The Sage Handbook\nof Social Network Analysis. Sage Publications.https://dx.doi.org/10.4135/9781446294413.n28",
            "Examples": "G=nx.wheel_graph(5)\ntop_nodes={0,1,2}\nnx.bipartite.closeness_centrality(G,nodes=top_nodes)\n# {0: 1.5, 1: 1.2, 2: 1.2, 3: 1.0, 4: 1.0}"
        }
    },
    {
        "Section ID": "weisfeiler_lehman_subgraph_hashes",
        "Description": [
            "Return a dictionary of subgraph hashes by node.",
            "Dictionary keys are nodes in G , and values are a list of hashes.\nEach hash corresponds to a subgraph rooted at a given node u in G .\nLists of subgraph hashes are sorted in increasing order of depth from\ntheir root node, with the hash at index i corresponding to a subgraph\nof nodes at most i edges distance from u. Thus, each list will contain iterations elements - a hash for a subgraph at each depth. If include_initial_labels is set to True , each list will additionally\nhave contain a hash of the initial node label (or equivalently a\nsubgraph of depth 0) prepended, totalling iterations+1 elements.",
            "The function iteratively aggregates and hashes neighborhoods of each node.\nThis is achieved for each step by replacing for each node its label from\nthe previous iteration with its hashed 1-hop neighborhood aggregate.\nThe new node label is then appended to a list of node labels for each\nnode.",
            "To aggregate neighborhoods for a node \\(u\\) at each step, all labels of\nnodes adjacent to \\(u\\) are concatenated. If the edge_attr parameter is set,\nlabels for each neighboring node are prefixed with the value of this attribute\nalong the connecting edge from this neighbor to node \\(u\\) . The resulting string\nis then hashed to compress this information into a fixed digest size.",
            "Thus, at the \\(i\\) -th iteration, nodes within \\(i\\) hops influence any given\nhashed node label. We can therefore say that at depth \\(i\\) for node \\(u\\) we have a hash for a subgraph induced by the \\(i\\) -hop neighborhood of \\(u\\) .",
            "The output can be used to to create general Weisfeiler-Lehman graph kernels,\nor generate features for graphs or nodes - for example to generate \u2018words\u2019 in\na graph as seen in the \u2018graph2vec\u2019 algorithm.\nSee [1] & [2] respectively for details.",
            "Hashes are identical for isomorphic subgraphs and there exist strong\nguarantees that non-isomorphic graphs will get different hashes.\nSee [1] for details.",
            "If no node or edge attributes are provided, the degree of each node\nis used as its initial label.\nOtherwise, node and/or edge labels are used to compute the hash."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "The graph to be hashed.\nCan have node and/or edge attributes. Can also have no attributes.",
                "edge_attr : string, optional (default=None)": "The key in edge attribute dictionary to be used for hashing.\nIf None, edge labels are ignored.",
                "node_attr : string, optional (default=None)": "The key in node attribute dictionary to be used for hashing.\nIf None, and no edge_attr given, use the degrees of the nodes as labels.\nIf None, and edge_attr is given, each node starts with an identical label.",
                "iterations : int, optional (default=3)": "Number of neighbor aggregations to perform.\nShould be larger for larger graphs.",
                "digest_size : int, optional (default=16)": "Size (in bits) of blake2b hash digest to use for hashing node labels.\nThe default size is 16 bits.",
                "include_initial_labels : bool, optional (default=False)": "If True, include the hashed initial node label as the first subgraph\nhash for each node."
            },
            "Returns:": {
                "node_subgraph_hashes : dict": "A dictionary with each key given by a node in G, and each value given\nby the subgraph hashes in order of depth from the key node."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "To hash the full graph when subgraph hashes are not needed, use weisfeiler_lehman_graph_hash for efficiency. Similarity between hashes does not imply similarity between graphs.",
            "References": "[1](1,2)Shervashidze, Nino, Pascal Schweitzer, Erik Jan Van Leeuwen,\nKurt Mehlhorn, and Karsten M. Borgwardt. Weisfeiler Lehman\nGraph Kernels. Journal of Machine Learning Research. 2011.http://www.jmlr.org/papers/volume12/shervashidze11a/shervashidze11a.pdf  [2]Annamalai Narayanan, Mahinthan Chandramohan, Rajasekar Venkatesan,\nLihui Chen, Yang Liu and Shantanu Jaiswa. graph2vec: Learning\nDistributed Representations of Graphs. arXiv. 2017https://arxiv.org/pdf/1707.05005.pdf",
            "Examples": "Finding similar nodes in different graphs:\nG1=nx.Graph()\nG1.add_edges_from([(1,2),(2,3),(2,4),(3,5),(4,6),(5,7),(6,7)])\nG2=nx.Graph()\nG2.add_edges_from([(1,3),(2,3),(1,6),(1,5),(4,6)])\ng1_hashes=nx.weisfeiler_lehman_subgraph_hashes(G1,iterations=3,digest_size=8)\ng2_hashes=nx.weisfeiler_lehman_subgraph_hashes(G2,iterations=3,digest_size=8)\nEven though G1 and G2 are not isomorphic (they have different numbers of edges),\nthe hash sequence of depth 3 for node 1 in G1 and node 5 in G2 are similar:\ng1_hashes[1]\n# ['a93b64973cfc8897', 'db1b43ae35a1878f', '57872a7d2059c1c0']\ng2_hashes[5]\n# ['a93b64973cfc8897', 'db1b43ae35a1878f', '1716d2a4012fa4bc']\nThe first 2 WL subgraph hashes match. From this we can conclude that it\u2019s very\nlikely the neighborhood of 2 hops around these nodes are isomorphic.\nHowever the 3-hop neighborhoods ofG1andG2are not isomorphic since the\n3rd hashes in the lists above are not equal.\nThese nodes may be candidates to be classified together since their local topology\nis similar."
        }
    },
    {
        "Section ID": "dedensify",
        "Description": [
            "Compresses neighborhoods around high-degree nodes",
            "Reduces the number of edges to high-degree nodes by adding compressor nodes\nthat summarize multiple edges of the same type to high-degree nodes (nodes\nwith a degree greater than a given threshold).  Dedensification also has\nthe added benefit of reducing the number of edges around high-degree nodes.\nThe implementation currently supports graphs with a single edge type."
        ],
        "Field List": {
            "Parameters:": {
                "G: graph": "A networkx graph",
                "threshold: int": "Minimum degree threshold of a node to be considered a high degree node.\nThe threshold must be greater than or equal to 2.",
                "prefix: str or None, optional (default: None)": "An optional prefix for denoting compressor nodes",
                "copy: bool, optional (default: True)": "Indicates if dedensification should be done inplace"
            },
            "Returns:": {
                "dedensified networkx graph : (graph, set)": "2-tuple of the dedensified graph and set of compressor nodes"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "According to the algorithm in [1] , removes edges in a graph by\ncompressing/decompressing the neighborhoods around high degree nodes by\nadding compressor nodes that summarize multiple edges of the same type\nto high-degree nodes.  Dedensification will only add a compressor node when\ndoing so will reduce the total number of edges in the given graph. This\nimplementation currently supports graphs with a single edge type.",
            "References": "[1]Maccioni, A., & Abadi, D. J. (2016, August).\nScalable pattern matching over compressed graphs via dedensification.\nIn Proceedings of the 22nd ACM SIGKDD International Conference on\nKnowledge Discovery and Data Mining (pp. 1755-1764).http://www.cs.umd.edu/~abadi/papers/graph-dedense.pdf",
            "Examples": "Dedensification will only add compressor nodes when doing so would result\nin fewer edges:\noriginal_graph=nx.DiGraph()\noriginal_graph.add_nodes_from(\n[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"A\",\"B\",\"C\"]\n)\noriginal_graph.add_edges_from(\n[\n(\"1\",\"C\"),(\"1\",\"B\"),\n(\"2\",\"C\"),(\"2\",\"B\"),(\"2\",\"A\"),\n(\"3\",\"B\"),(\"3\",\"A\"),(\"3\",\"6\"),\n(\"4\",\"C\"),(\"4\",\"B\"),(\"4\",\"A\"),\n(\"5\",\"B\"),(\"5\",\"A\"),\n(\"6\",\"5\"),\n(\"A\",\"6\")\n]\n)\nc_graph,c_nodes=nx.dedensify(original_graph,threshold=2)\noriginal_graph.number_of_edges()\n# 15\nc_graph.number_of_edges()\n# 14\nA dedensified, directed graph can be \u201cdensified\u201d to reconstruct the\noriginal graph:\noriginal_graph=nx.DiGraph()\noriginal_graph.add_nodes_from(\n[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"A\",\"B\",\"C\"]\n)\noriginal_graph.add_edges_from(\n[\n(\"1\",\"C\"),(\"1\",\"B\"),\n(\"2\",\"C\"),(\"2\",\"B\"),(\"2\",\"A\"),\n(\"3\",\"B\"),(\"3\",\"A\"),(\"3\",\"6\"),\n(\"4\",\"C\"),(\"4\",\"B\"),(\"4\",\"A\"),\n(\"5\",\"B\"),(\"5\",\"A\"),\n(\"6\",\"5\"),\n(\"A\",\"6\")\n]\n)\nc_graph,c_nodes=nx.dedensify(original_graph,threshold=2)\n# re-densifies the compressed graph into the original graph\nforc_nodeinc_nodes:\nall_neighbors=set(nx.all_neighbors(c_graph,c_node))\nout_neighbors=set(c_graph.neighbors(c_node))\nforout_neighborinout_neighbors:\nc_graph.remove_edge(c_node,out_neighbor)\nin_neighbors=all_neighbors-out_neighbors\nforin_neighborinin_neighbors:\nc_graph.remove_edge(in_neighbor,c_node)\nforout_neighborinout_neighbors:\nc_graph.add_edge(in_neighbor,out_neighbor)\nc_graph.remove_node(c_node)\n\nnx.is_isomorphic(original_graph,c_graph)\n# True"
        }
    },
    {
        "Section ID": "non_neighbors",
        "Description": [
            "Returns the non-neighbors of the node in the graph."
        ],
        "Field List": {
            "Parameters:": {
                "graph : NetworkX graph": "Graph to find neighbors.",
                "node : node": "The node whose neighbors will be returned."
            },
            "Returns:": {
                "non_neighbors : set": "Set of nodes in the graph that are not neighbors of the node."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "balanced_tree",
        "Description": [
            "Returns the perfectly balanced r -ary tree of height h .",
            "( Sourcecode , png )"
        ],
        "Field List": {
            "Parameters:": {
                "r : int": "Branching factor of the tree; each node will haverchildren.",
                "h : int": "Height of the tree.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : NetworkX graph": "A balancedr-ary tree of heighth."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This is the rooted tree where all leaves are at distance h from\nthe root. The root has degree r and all other internal nodes\nhave degree r+1 . Node labels are integers, starting from zero. A balanced tree is also known as a complete r-ary tree ."
        }
    },
    {
        "Section ID": "dispersion",
        "Description": [
            "Calculate dispersion between u and v in G .",
            "A link between two actors ( u and v ) has a high dispersion when their\nmutual ties ( s and t ) are not well connected with each other."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.",
                "u : node, optional": "The source for the dispersion score (e.g. ego node of the network).",
                "v : node, optional": "The target of the dispersion score if specified.",
                "normalized : bool": "If True (default) normalize by the embeddedness of the nodes (u and v).",
                "alpha, b, c : float": "Parameters for the normalization procedure. Whennormalizedis True,\nthe dispersion value is normalized by:result=((dispersion+b)**alpha)/(embeddedness+c)as long as the denominator is nonzero."
            },
            "Returns:": {
                "nodes : dictionary": "If u (v) is specified, returns a dictionary of nodes with dispersion\nscore for all \u201ctarget\u201d (\u201csource\u201d) nodes. If neither u nor v is\nspecified, returns a dictionary of dictionaries for all nodes \u2018u\u2019 in the\ngraph with a dispersion score for each node \u2018v\u2019."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This implementation follows Lars Backstrom and Jon Kleinberg [1] . Typical\nusage would be to run dispersion on the ego network \\(G_u\\) if \\(u\\) were\nspecified.  Running dispersion() with neither \\(u\\) nor \\(v\\) specified\ncan take some time to complete.",
            "References": "[1]Romantic Partnerships and the Dispersion of Social Ties:\nA Network Analysis of Relationship Status on Facebook.\nLars Backstrom, Jon Kleinberg.https://arxiv.org/pdf/1310.6753v1.pdf"
        }
    },
    {
        "Section ID": "normalized_laplacian_spectrum",
        "Description": [
            "Return eigenvalues of the normalized Laplacian of G"
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "weight : string or None, optional (default=\u2019weight\u2019)": "The edge data key used to compute each value in the matrix.\nIf None, then each edge has weight 1."
            },
            "Returns:": {
                "evals : NumPy array": "Eigenvalues"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For MultiGraph/MultiDiGraph, the edges weights are summed.\nSee to_numpy_array for other options."
        }
    },
    {
        "Section ID": "single_source_bellman_ford",
        "Description": [
            "Compute shortest paths and lengths in a weighted graph G.",
            "Uses Bellman-Ford algorithm for shortest paths."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node label": "Starting node for path",
                "target : node label, optional": "Ending node for path",
                "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number."
            },
            "Returns:": {
                "distance, path : pair of dictionaries, or numeric and list": "If target is None, returns a tuple of two dictionaries keyed by node.\nThe first dictionary stores distance from one of the source nodes.\nThe second stores the path from one of the sources to that node.\nIf target is not None, returns a tuple of (distance, path) where\ndistance is the distance from source to target and path is a list\nrepresenting the path from source to target."
            },
            "Raises:": {
                "NodeNotFound": "Ifsourceis not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.",
            "Examples": "G=nx.path_graph(5)\nlength,path=nx.single_source_bellman_ford(G,0)\nlength[4]\n# 4\nfornodein[0,1,2,3,4]:\nprint(f\"{node}: {length[node]}\")\n# 0: 0\n# 1: 1\n# 2: 2\n# 3: 3\n# 4: 4\npath[4]\n# [0, 1, 2, 3, 4]\nlength,path=nx.single_source_bellman_ford(G,0,1)\nlength\n# 1\npath\n# [0, 1]"
        }
    },
    {
        "Section ID": "overall_reciprocity",
        "Description": [
            "Compute the reciprocity for the whole graph.",
            "See the doc of reciprocity for the definition."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph"
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "random_powerlaw_tree",
        "Description": [
            "Returns a tree with a power law degree distribution."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes.",
                "gamma : float": "Exponent of the power law.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "tries : int": "Number of attempts to adjust the sequence to make it a tree."
            },
            "Raises:": {
                "NetworkXError": "If no valid sequence is found within the maximum number of\nattempts."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "A trial power law degree sequence is chosen and then elements are\nswapped with new elements from a powerlaw distribution until the\nsequence makes a tree (by checking, for example, that the number of\nedges is one smaller than the number of nodes)."
        }
    },
    {
        "Section ID": "bridge_components",
        "Description": [
            "Finds all bridge-connected components G."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX undirected graph": ""
            },
            "Returns:": {
                "bridge_components : a generator of 2-edge-connected components": ""
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the input graph is directed or a multigraph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Bridge-connected components are also known as 2-edge-connected components.",
            "Examples": "# The barbell graph with parameter zero has a single bridge\nG=nx.barbell_graph(5,0)\nfromnetworkx.algorithms.connectivity.edge_kcomponentsimportbridge_components\nsorted(map(sorted,bridge_components(G)))\n# [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]"
        }
    },
    {
        "Section ID": "path_graph",
        "Description": [
            "Returns the Path graph P_n of linearly connected nodes.",
            "( Sourcecode , png )"
        ],
        "Field List": {
            "Parameters:": {
                "n : int or iterable": "If an integer, nodes are 0 to n - 1.\nIf an iterable of nodes, in the order they appear in the path.\nWarning: n is not checked for duplicates and if present the\nresulting graph may not be as desired. Make sure you have no duplicates.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "complete_multipartite_graph",
        "Description": [
            "Returns the complete multipartite graph with the specified subset sizes.",
            "( Sourcecode , png )"
        ],
        "Field List": {
            "Parameters:": {
                "subset_sizes : tuple of integers or tuple of node iterables": "The arguments can either all be integer number of nodes or they\ncan all be iterables of nodes. If integers, they represent the\nnumber of nodes in each subset of the multipartite graph.\nIf iterables, each is used to create the nodes for that subset.\nThe length of subset_sizes is the number of subsets."
            },
            "Returns:": {
                "G : NetworkX Graph": "Returns the complete multipartite graph with the specified subsets.For each node, the node attribute \u2018subset\u2019 is an integer\nindicating which subset contains the node."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This function generalizes several other graph builder functions.",
            "Examples": "Creating a complete tripartite graph, with subsets of one, two, and three\nnodes, respectively.\nG=nx.complete_multipartite_graph(1,2,3)\n[G.nodes[u][\"subset\"]foruinG]\n# [0, 1, 1, 2, 2, 2]\nlist(G.edges(0))\n# [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5)]\nlist(G.edges(2))\n# [(2, 0), (2, 3), (2, 4), (2, 5)]\nlist(G.edges(4))\n# [(4, 0), (4, 1), (4, 2)]\nG=nx.complete_multipartite_graph(\"a\",\"bc\",\"def\")\n[G.nodes[u][\"subset\"]foruinsorted(G)]\n# [0, 1, 1, 2, 2, 2]"
        }
    },
    {
        "Section ID": "configuration_model",
        "Description": [
            "Returns a random bipartite graph from two given degree sequences."
        ],
        "Field List": {
            "Parameters:": {
                "aseq : list": "Degree sequence for node set A.",
                "bseq : list": "Degree sequence for node set B.",
                "create_using : NetworkX graph instance, optional": "Return graph of this type.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "The graph is composed of two partitions. Set A has nodes 0 to": "",
                "(len(aseq) - 1) and set B has nodes len(aseq) to (len(bseq) - 1).": "",
                "Nodes from set A are connected to nodes in set B by choosing": "",
                "randomly from the possible free stubs, one in A and one in B.": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The sum of the two sequences must be equal: sum(aseq)=sum(bseq)\nIf no graph type is specified use MultiGraph with parallel edges.\nIf you want a graph with no parallel edges use create_using=Graph()\nbut then the resulting degree sequences might not be exact. The nodes are assigned the attribute \u2018bipartite\u2019 with the value 0 or 1\nto indicate which bipartite set the node belongs to. This function is not imported in the main namespace.\nTo use it use nx.bipartite.configuration_model"
        }
    },
    {
        "Section ID": "compose",
        "Description": [
            "Compose graph G with H by combining nodes and edges into a single graph.",
            "The node sets and edges sets do not need to be disjoint.",
            "Composing preserves the attributes of nodes and edges.\nAttribute values from H take precedent over attribute values from G."
        ],
        "Field List": {
            "Parameters:": {
                "G, H : graph": "A NetworkX graph"
            },
            "Returns:": {
                "C: A new graph with the same type as G": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "It is recommended that G and H be either both directed or both undirected. For MultiGraphs, the edges are identified by incident nodes AND edge-key.\nThis can cause surprises (i.e., edge (1,2) may or may not be the same\nin two graphs) if you use MultiGraph without keeping track of edge keys. If combining the attributes of common nodes is not desired, consider union(),\nwhich raises an exception for name collisions.",
            "Examples": "G=nx.Graph([(0,1),(0,2)])\nH=nx.Graph([(0,1),(1,2)])\nR=nx.compose(G,H)\nR.nodes\n# NodeView((0, 1, 2))\nR.edges\n# EdgeView([(0, 1), (0, 2), (1, 2)])\nBy default, the attributes fromHtake precedent over attributes fromG.\nIf you prefer another way of combining attributes, you can update them after the compose operation:\nG=nx.Graph([(0,1,{\"weight\":2.0}),(3,0,{\"weight\":100.0})])\nH=nx.Graph([(0,1,{\"weight\":10.0}),(1,2,{\"weight\":-1.0})])\nnx.set_node_attributes(G,{0:\"dark\",1:\"light\",3:\"black\"},name=\"color\")\nnx.set_node_attributes(H,{0:\"green\",1:\"orange\",2:\"yellow\"},name=\"color\")\nGcomposeH=nx.compose(G,H)\nNormally, color attribute values of nodes of GcomposeH come from H. We can workaround this as follows:\nnode_data={\nn:G.nodes[n][\"color\"]+\" \"+H.nodes[n][\"color\"]forninG.nodes&H.nodes\n}\nnx.set_node_attributes(GcomposeH,node_data,\"color\")\nprint(GcomposeH.nodes[0][\"color\"])\n# dark green\nprint(GcomposeH.nodes[3][\"color\"])\n# black\nSimilarly, we can update edge attributes after the compose operation in a way we prefer:\nedge_data={\ne:G.edges[e][\"weight\"]*H.edges[e][\"weight\"]foreinG.edges&H.edges\n}\nnx.set_edge_attributes(GcomposeH,edge_data,\"weight\")\nprint(GcomposeH.edges[(0,1)][\"weight\"])\n# 20.0\nprint(GcomposeH.edges[(3,0)][\"weight\"])\n# 100.0"
        }
    },
    {
        "Section ID": "combinatorial_embedding_to_pos",
        "Description": [
            "Assigns every node a (x, y) position based on the given embedding",
            "The algorithm iteratively inserts nodes of the input graph in a certain\norder and rearranges previously inserted nodes so that the planar drawing\nstays valid. This is done efficiently by only maintaining relative\npositions during the node placements and calculating the absolute positions\nat the end. For more information see [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "embedding : nx.PlanarEmbedding": "This defines the order of the edges",
                "fully_triangulate : bool": "If set to True the algorithm adds edges to a copy of the input\nembedding and makes it chordal."
            },
            "Returns:": {
                "pos : dict": "Maps each node to a tuple that defines the (x, y) position"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]M. Chrobak and T.H. Payne:\nA Linear-time Algorithm for Drawing a Planar Graph on a Grid 1989http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.51.6677"
        }
    },
    {
        "Section ID": "navigable_small_world_graph",
        "Description": [
            "Returns a navigable small-world graph.",
            "A navigable small-world graph is a directed grid with additional long-range\nconnections that are chosen randomly."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The length of one side of the lattice; the number of nodes in\nthe graph is therefore\\(n^2\\).",
                "p : int": "The diameter of short range connections. Each node is joined with every\nother node within this lattice distance.",
                "q : int": "The number of long-range connections for each node.",
                "r : float": "Exponent for decaying probability of connections.  The probability of\nconnecting to a node at lattice distance\\(d\\)is\\(1/d^r\\).",
                "dim : int": "Dimension of grid",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]J. Kleinberg. The small-world phenomenon: An algorithmic\nperspective. Proc. 32nd ACM Symposium on Theory of Computing, 2000."
        }
    },
    {
        "Section ID": "relaxed_caveman_graph",
        "Description": [
            "Returns a relaxed caveman graph.",
            "A relaxed caveman graph starts with l cliques of size k .  Edges are\nthen randomly rewired with probability p to link different cliques."
        ],
        "Field List": {
            "Parameters:": {
                "l : int": "Number of groups",
                "k : int": "Size of cliques",
                "p : float": "Probability of rewiring each edge.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "G : NetworkX Graph": "Relaxed Caveman Graph"
            },
            "Raises:": {
                "NetworkXError": "If p is not in [0,1]"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Santo Fortunato, Community Detection in Graphs,\nPhysics Reports Volume 486, Issues 3-5, February 2010, Pages 75-174.https://arxiv.org/abs/0906.0612",
            "Examples": "G=nx.relaxed_caveman_graph(2,3,0.1,seed=42)"
        }
    },
    {
        "Section ID": "house_graph",
        "Description": [
            "Returns the House graph (square with triangle on top)",
            "The house graph is a simple undirected graph with\n5 nodes and 6 edges [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : networkx Graph": "House graph in the form of a square with a triangle on top"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://mathworld.wolfram.com/HouseGraph.html"
        }
    },
    {
        "Section ID": "modular_product",
        "Description": [
            "Returns the Modular product of G and H.",
            "The modular product of G and H is the graph \\(M = G \\nabla H\\) ,\nconsisting of the node set \\(V(M) = V(G) \\times V(H)\\) that is the Cartesian\nproduct of the node sets of G and H . Further, M contains an edge ((u, v), (x, y)):",
            "More formally:"
        ],
        "Field List": {
            "Parameters:": {
                "G, H: NetworkX graphs": "The graphs to take the modular product of."
            },
            "Returns:": {
                "M: NetworkX graph": "The Modular product ofGandH."
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis not a simple graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The modular product is defined in [1] and was first\nintroduced as the weak modular product . The modular product reduces the problem of counting isomorphic subgraphs\nin G and H to the problem of counting cliques in M. The subgraphs of G and H that are induced by the nodes of a clique in M are\nisomorphic [2]  [3] .",
            "References": "[1]R. Hammack, W. Imrich, and S. Klav\u017ear,\n\u201cHandbook of Product Graphs\u201d, CRC Press, 2011.  [2]H. G. Barrow and R. M. Burstall,\n\u201cSubgraph isomorphism, matching relational structures and maximal\ncliques\u201d, Information Processing Letters, vol. 4, issue 4, pp. 83-84,\n1976,https://doi.org/10.1016/0020-0190(76)90049-1.  [3]V. G. Vizing, \u201cReduction of the problem of isomorphism and isomorphic\nentrance to the task of finding the nondensity of a graph.\u201d Proc. Third\nAll-Union Conference on Problems of Theoretical Cybernetics. 1974.",
            "Examples": "G=nx.cycle_graph(4)\nH=nx.path_graph(2)\nM=nx.modular_product(G,H)\nlist(M)\n# [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1), (3, 0), (3, 1)]\nprint(M)\n# Graph with 8 nodes and 8 edges"
        }
    },
    {
        "Section ID": "dominance_frontiers",
        "Description": [
            "Returns the dominance frontiers of all nodes of a directed graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : a DiGraph or MultiDiGraph": "The graph where dominance is to be computed.",
                "start : node": "The start node of dominance computation."
            },
            "Returns:": {
                "df : dict keyed by nodes": "A dict containing the dominance frontiers of each node reachable fromstartas lists."
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis undirected.",
                "NetworkXError": "Ifstartis not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]K. D. Cooper, T. J. Harvey, and K. Kennedy.\nA simple, fast dominance algorithm.\nSoftware Practice & Experience, 4:110, 2001.",
            "Examples": "G=nx.DiGraph([(1,2),(1,3),(2,5),(3,4),(4,5)])\nsorted((u,sorted(df))foru,dfinnx.dominance_frontiers(G,1).items())\n# [(1, []), (2, [5]), (3, [5]), (4, [5]), (5, [])]"
        }
    },
    {
        "Section ID": "harmonic_function",
        "Description": [
            "Node classification by Harmonic function",
            "Function for computing Harmonic function algorithm by Zhu et al."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "",
                "max_iter : int": "maximum number of iterations allowed",
                "label_name : string": "name of target labels to predict"
            },
            "Returns:": {
                "predicted : list": "List of lengthlen(G)with the predicted labels for each node."
            },
            "Raises:": {
                "NetworkXError": "If no nodes inGhave attributelabel_name."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "Zhu, X., Ghahramani, Z., & Lafferty, J. (2003, August).\nSemi-supervised learning using gaussian fields and harmonic functions.\nIn ICML (Vol. 3, pp. 912-919).",
            "Examples": "fromnetworkx.algorithmsimportnode_classification\nG=nx.path_graph(4)\nG.nodes[0][\"label\"]=\"A\"\nG.nodes[3][\"label\"]=\"B\"\nG.nodes(data=True)\n# NodeDataView({0: {'label': 'A'}, 1: {}, 2: {}, 3: {'label': 'B'}})\nG.edges()\n# EdgeView([(0, 1), (1, 2), (2, 3)])\npredicted=node_classification.harmonic_function(G)\npredicted\n# ['A', 'A', 'B', 'B']"
        }
    },
    {
        "Section ID": "min_edge_dominating_set",
        "Description": [
            "Returns minimum cardinality edge dominating set."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected graph"
            },
            "Returns:": {
                "min_edge_dominating_set : set": "Returns a set of dominating edges whose size is no more than 2 * OPT."
            },
            "Raises:": {
                "ValueError": "If the input graphGis empty."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The algorithm computes an approximate solution to the edge dominating set\nproblem. The result is no more than 2 * OPT in terms of size of the set.\nRuntime of the algorithm is \\(O(|E|)\\) .",
            "Examples": "G=nx.petersen_graph()\nnx.approximation.min_edge_dominating_set(G)\n# {(0, 1), (4, 9), (6, 8), (5, 7), (2, 3)}"
        }
    },
    {
        "Section ID": "triads_by_type",
        "Description": [
            "Returns a list of all triads for each triad type in a directed graph.\nThere are exactly 16 different types of triads possible. Suppose 1, 2, 3 are three\nnodes, they will be classified as a particular triad type if their connections\nare as follows:",
            "Refer to the example gallery for visual examples of the triad types."
        ],
        "Field List": {
            "Parameters:": {
                "G : digraph": "A NetworkX DiGraph"
            },
            "Returns:": {
                "tri_by_type : dict": "Dictionary with triad types as keys and lists of triads as values."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Snijders, T. (2012). \u201cTransitivity and triads.\u201d University of\nOxford.https://web.archive.org/web/20170830032057/http://www.stats.ox.ac.uk/~snijders/Trans_Triads_ha.pdf",
            "Examples": "G=nx.DiGraph([(1,2),(1,3),(2,3),(3,1),(5,6),(5,4),(6,7)])\ndict=nx.triads_by_type(G)\ndict[\"120C\"][0].edges()\n# OutEdgeView([(1, 2), (1, 3), (2, 3), (3, 1)])\ndict[\"012\"][0].edges()\n# OutEdgeView([(1, 2)])"
        }
    },
    {
        "Section ID": "normalized_laplacian_matrix",
        "Description": [
            "Returns the normalized Laplacian matrix of G.",
            "The normalized graph Laplacian is the matrix",
            "where L is the graph Laplacian and D is the diagonal matrix of\nnode degrees [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "nodelist : list, optional": "The rows and columns are ordered according to the nodes in nodelist.\nIf nodelist is None, then the ordering is produced by G.nodes().",
                "weight : string or None, optional (default=\u2019weight\u2019)": "The edge data key used to compute each value in the matrix.\nIf None, then each edge has weight 1."
            },
            "Returns:": {
                "N : SciPy sparse array": "The normalized Laplacian matrix of G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For MultiGraph, the edges weights are summed.\nSee to_numpy_array() for other options. If the Graph contains selfloops, D is defined as diag(sum(A,1)) , where A is\nthe adjacency matrix [2] . This calculation uses the out-degree of the graph G . To use the\nin-degree for calculations instead, use G.reverse(copy=False) and\ntake the transpose. For an unnormalized output, use laplacian_matrix .",
            "References": "[1]Fan Chung-Graham, Spectral Graph Theory,\nCBMS Regional Conference Series in Mathematics, Number 92, 1997.  [2]Steve Butler, Interlacing For Weighted Graphs Using The Normalized\nLaplacian, Electronic Journal of Linear Algebra, Volume 16, pp. 90-98,\nMarch 2007.  [3]Langville, Amy N., and Carl D. Meyer. Google\u2019s PageRank and Beyond:\nThe Science of Search Engine Rankings. Princeton University Press, 2006.",
            "Examples": "importnumpyasnp\nedges=[\n(1,2),\n(2,1),\n(2,4),\n(4,3),\n(3,4),\n]\nDiG=nx.DiGraph(edges)\nprint(nx.normalized_laplacian_matrix(DiG).toarray())\n# [[ 1.         -0.70710678  0.          0.        ]\n#  [-0.70710678  1.         -0.70710678  0.        ]\n#  [ 0.          0.          1.         -1.        ]\n#  [ 0.          0.         -1.          1.        ]]\nNotice that node 4 is represented by the third column and row. This is because\nby default the row/column order is the order ofG.nodes(i.e. the node added\norder \u2013 in the edgelist, 4 first appears in (2, 4), before node 3 in edge (4, 3).)\nTo control the node order of the matrix, use thenodelistargument.\nprint(nx.normalized_laplacian_matrix(DiG,nodelist=[1,2,3,4]).toarray())\n# [[ 1.         -0.70710678  0.          0.        ]\n#  [-0.70710678  1.          0.         -0.70710678]\n#  [ 0.          0.          1.         -1.        ]\n#  [ 0.          0.         -1.          1.        ]]\nG=nx.Graph(edges)\nprint(nx.normalized_laplacian_matrix(G).toarray())\n# [[ 1.         -0.70710678  0.          0.        ]\n#  [-0.70710678  1.         -0.5         0.        ]\n#  [ 0.         -0.5         1.         -0.70710678]\n#  [ 0.          0.         -0.70710678  1.        ]]"
        }
    },
    {
        "Section ID": "is_negatively_weighted",
        "Description": [
            "Returns True if G has negatively weighted edges."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.",
                "edge : tuple, optional": "A 2-tuple specifying the only edge inGthat will be tested. If\nNone, then every edge inGis tested.",
                "weight: string, optional": "The attribute name used to query for edge weights."
            },
            "Returns:": {
                "bool": "A boolean signifying ifG, or the specified edge, is negatively\nweighted."
            },
            "Raises:": {
                "NetworkXError": "If the specified edge does not exist."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph()\nG.add_edges_from([(1,3),(2,4),(2,6)])\nG.add_edge(1,2,weight=4)\nnx.is_negatively_weighted(G,(1,2))\n# False\nG[2][4][\"weight\"]=-2\nnx.is_negatively_weighted(G)\n# True\nG=nx.DiGraph()\nedges=[(\"0\",\"3\",3),(\"0\",\"1\",-5),(\"1\",\"0\",-2)]\nG.add_weighted_edges_from(edges)\nnx.is_negatively_weighted(G)\n# True"
        }
    },
    {
        "Section ID": "shortest_path",
        "Description": [
            "Compute shortest paths in the graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node, optional": "Starting node for path. If not specified, compute shortest\npaths for each possible starting node.",
                "target : node, optional": "Ending node for path. If not specified, compute shortest\npaths to all possible nodes.",
                "weight : None, string or function, optional (default = None)": "If None, every edge has weight/distance/cost 1.\nIf a string, use this edge attribute as the edge weight.\nAny edge attribute not present defaults to 1.\nIf this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly\nthree positional arguments: the two endpoints of an edge and\nthe dictionary of edge attributes for that edge.\nThe function must return a number.",
                "method : string, optional (default = \u2018dijkstra\u2019)": "The algorithm to use to compute the path.\nSupported options: \u2018dijkstra\u2019, \u2018bellman-ford\u2019.\nOther inputs produce a ValueError.\nIfweightis None, unweighted graph methods are used, and this\nsuggestion is ignored."
            },
            "Returns:": {
                "path: list or dictionary": "All returned paths include both the source and target in the path.If the source and target are both specified, return a single list\nof nodes in a shortest path from the source to the target.If only the source is specified, return a dictionary keyed by\ntargets with a list of nodes in a shortest path from the source\nto one of the targets.If only the target is specified, return a dictionary keyed by\nsources with a list of nodes in a shortest path from one of the\nsources to the target.If neither the source nor target are specified return a dictionary\nof dictionaries with path[source][target]=[list of nodes in path]."
            },
            "Raises:": {
                "NodeNotFound": "Ifsourceis not inG.",
                "ValueError": "Ifmethodis not among the supported options."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "There may be more than one shortest path between a source and target.\nThis returns only one of them.",
            "Examples": "G=nx.path_graph(5)\nprint(nx.shortest_path(G,source=0,target=4))\n# [0, 1, 2, 3, 4]\np=nx.shortest_path(G,source=0)# target not specified\np[3]# shortest path from source=0 to target=3\n# [0, 1, 2, 3]\np=nx.shortest_path(G,target=4)# source not specified\np[1]# shortest path from source=1 to target=4\n# [1, 2, 3, 4]\np=dict(nx.shortest_path(G))# source, target not specified\np[2][4]# shortest path from source=2 to target=4\n# [2, 3, 4]"
        }
    },
    {
        "Section ID": "barbell_graph",
        "Description": [
            "Returns the Barbell Graph: two complete graphs connected by a path.",
            "( Sourcecode , png )"
        ],
        "Field List": {
            "Parameters:": {
                "m1 : int": "Size of the left and right barbells, must be greater than 2.",
                "m2 : int": "Length of the path connecting the barbells.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated.\nOnly undirected Graphs are supported."
            },
            "Returns:": {
                "G : NetworkX graph": "A barbell graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Two identical complete graphs \\(K_{m1}\\) form the left and right bells,\nand are connected by a path \\(P_{m2}\\) ."
        }
    },
    {
        "Section ID": "discrete_sequence",
        "Description": [
            "Return sample sequence of length n from a given discrete distribution\nor discrete cumulative distribution.",
            "One of the following must be specified.",
            "distribution = histogram of values, will be normalized",
            "cdistribution = normalized discrete cumulative distribution"
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "is_weakly_connected",
        "Description": [
            "Test directed graph for weak connectivity.",
            "A directed graph is weakly connected if and only if the graph\nis connected when the direction of the edge between nodes is ignored.",
            "Note that if a graph is strongly connected (i.e. the graph is connected\neven when we account for directionality), it is by definition weakly\nconnected as well."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "A directed graph."
            },
            "Returns:": {
                "connected : bool": "True if the graph is weakly connected, False otherwise."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For directed graphs only.",
            "Examples": "G=nx.DiGraph([(0,1),(2,1)])\nG.add_node(3)\nnx.is_weakly_connected(G)# node 3 is not connected to the graph\n# False\nG.add_edge(2,3)\nnx.is_weakly_connected(G)\n# True"
        }
    },
    {
        "Section ID": "resource_allocation_index",
        "Description": [
            "Compute the resource allocation index of all node pairs in ebunch.",
            "Resource allocation index of u and v is defined as",
            "where \\(\\Gamma(u)\\) denotes the set of neighbors of \\(u\\) ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX undirected graph.",
                "ebunch : iterable of node pairs, optional (default = None)": "Resource allocation index will be computed for each pair of\nnodes given in the iterable. The pairs must be given as\n2-tuples (u, v) where u and v are nodes in the graph. If ebunch\nis None then all nonexistent edges in the graph will be used.\nDefault value: None."
            },
            "Returns:": {
                "piter : iterator": "An iterator of 3-tuples in the form (u, v, p) where (u, v) is a\npair of nodes and p is their resource allocation index."
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis aDiGraph, aMultigraphor aMultiDiGraph.",
                "NodeNotFound": "Ifebunchhas a node that is not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]T. Zhou, L. Lu, Y.-C. Zhang.\nPredicting missing links via local information.\nEur. Phys. J. B 71 (2009) 623.https://arxiv.org/pdf/0901.0553.pdf",
            "Examples": "G=nx.complete_graph(5)\npreds=nx.resource_allocation_index(G,[(0,1),(2,3)])\nforu,v,pinpreds:\nprint(f\"({u}, {v}) -> {p:.8f}\")\n# (0, 1) -> 0.75000000\n# (2, 3) -> 0.75000000"
        }
    },
    {
        "Section ID": "global_reaching_centrality",
        "Description": [
            "Returns the global reaching centrality of a directed graph.",
            "The global reaching centrality of a weighted directed graph is the\naverage over all nodes of the difference between the local reaching\ncentrality of the node and the greatest local reaching centrality of\nany node in the graph [1] . For more information on the local\nreaching centrality, see local_reaching_centrality() .\nInformally, the local reaching centrality is the proportion of the\ngraph that is reachable from the neighbors of the node."
        ],
        "Field List": {
            "Parameters:": {
                "G : DiGraph": "A networkx DiGraph.",
                "weight : None or string, optional (default=None)": "Attribute to use for edge weights. IfNone, each edge weight\nis assumed to be one. A higher weight implies a stronger\nconnection between nodes and ashorterpath length.",
                "normalized : bool, optional (default=True)": "Whether to normalize the edge weights by the total sum of edge\nweights."
            },
            "Returns:": {
                "h : float": "The global reaching centrality of the graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Mones, Enys, Lilla Vicsek, and Tam\u00e1s Vicsek.\n\u201cHierarchy Measure for Complex Networks.\u201dPLoS ONE7.3 (2012): e33799.https://doi.org/10.1371/journal.pone.0033799",
            "Examples": "G=nx.DiGraph()\nG.add_edge(1,2)\nG.add_edge(1,3)\nnx.global_reaching_centrality(G)\n# 1.0\nG.add_edge(3,2)\nnx.global_reaching_centrality(G)\n# 0.75"
        }
    },
    {
        "Section ID": "difference",
        "Description": [
            "Returns a new graph that contains the edges that exist in G but not in H.",
            "The node sets of H and G must be the same."
        ],
        "Field List": {
            "Parameters:": {
                "G,H : graph": "A NetworkX graph. G and H must have the same node sets."
            },
            "Returns:": {
                "D : A new graph with the same type as G.": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Attributes from the graph, nodes, and edges are not copied to the new\ngraph.  If you want a new graph of the difference of G and H with\nthe attributes (including edge data) from G use remove_nodes_from()\nas follows:",
            "Examples": "G=nx.Graph([(0,1),(0,2),(1,2),(1,3)])\nH=nx.Graph([(0,1),(1,2),(0,3)])\nR=nx.difference(G,H)\nR.nodes\n# NodeView((0, 1, 2, 3))\nR.edges\n# EdgeView([(0, 2), (1, 3)])"
        }
    },
    {
        "Section ID": "boundary_expansion",
        "Description": [
            "Returns the boundary expansion of the set S .",
            "The boundary expansion is the quotient of the size\nof the node boundary and the cardinality of S . [1]"
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "S : collection": "A collection of nodes inG."
            },
            "Returns:": {
                "number": "The boundary expansion of the setS."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Vadhan, Salil P.\n\u201cPseudorandomness.\u201dFoundations and Trends in Theoretical Computer Science7.1\u20133 (2011): 1\u2013336.\n<https://doi.org/10.1561/0400000010>"
        }
    },
    {
        "Section ID": "greedy_tsp",
        "Description": [
            "Return a low cost cycle starting at source and its cost.",
            "This approximates a solution to the traveling salesman problem.\nIt finds a cycle of all the nodes that a salesman can visit in order\nto visit many nodes while minimizing total distance.\nIt uses a simple greedy algorithm.\nIn essence, this function returns a large cycle given a source point\nfor which the total cost of the cycle is minimized."
        ],
        "Field List": {
            "Parameters:": {
                "G : Graph": "The Graph should be a complete weighted undirected graph.\nThe distance between all pairs of nodes should be included.",
                "weight : string, optional (default=\u201dweight\u201d)": "Edge data key corresponding to the edge weight.\nIf any edge does not have this attribute the weight is set to 1.",
                "source : node, optional (default: first node in list(G))": "Starting node.  If None, defaults tonext(iter(G))"
            },
            "Returns:": {
                "cycle : list of nodes": "Returns the cycle (list of nodes) that a salesman\ncan follow to minimize total weight of the trip."
            },
            "Raises:": {
                "NetworkXError": "IfGis not complete, the algorithm raises an exception."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This implementation of a greedy algorithm is based on the following:",
            "Examples": "fromnetworkx.algorithmsimportapproximationasapprox\nG=nx.DiGraph()\nG.add_weighted_edges_from(\n{\n(\"A\",\"B\",3),\n(\"A\",\"C\",17),\n(\"A\",\"D\",14),\n(\"B\",\"A\",3),\n(\"B\",\"C\",12),\n(\"B\",\"D\",16),\n(\"C\",\"A\",13),\n(\"C\",\"B\",12),\n(\"C\",\"D\",4),\n(\"D\",\"A\",14),\n(\"D\",\"B\",15),\n(\"D\",\"C\",2),\n}\n)\ncycle=approx.greedy_tsp(G,source=\"D\")\ncost=sum(G[n][nbr][\"weight\"]forn,nbrinnx.utils.pairwise(cycle))\ncycle\n# ['D', 'C', 'B', 'A', 'D']\ncost\n# 31"
        }
    },
    {
        "Section ID": "add_path",
        "Description": [
            "Add a path to the Graph G_to_add_to."
        ],
        "Field List": {
            "Parameters:": {
                "G_to_add_to : graph": "A NetworkX graph",
                "nodes_for_path : iterable container": "A container of nodes.  A path will be constructed from\nthe nodes (in order) and added to the graph.",
                "attr : keyword arguments, optional (default= no attributes)": "Attributes to add to every edge in path."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph()\nnx.add_path(G,[0,1,2,3])\nnx.add_path(G,[10,11,12],weight=7)"
        }
    },
    {
        "Section ID": "draw_kamada_kawai",
        "Description": [
            "Draw the graph G with a Kamada-Kawai force-directed layout.",
            "This is a convenience function equivalent to:"
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph",
                "kwargs : optional keywords": "Seedraw_networkxfor a description of optional keywords."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The layout is computed each time this function is called.\nFor repeated drawing it is much more efficient to call kamada_kawai_layout directly and reuse the\nresult:",
            "Examples": "G=nx.path_graph(5)\nnx.draw_kamada_kawai(G)"
        }
    },
    {
        "Section ID": "dag_longest_path",
        "Description": [
            "Returns the longest path in a directed acyclic graph (DAG).",
            "If G has edges with weight attribute the edge data are used as\nweight values."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX DiGraph": "A directed acyclic graph (DAG)",
                "weight : str, optional": "Edge data key to use for weight",
                "default_weight : int, optional": "The weight of edges that do not have a weight attribute",
                "topo_order: list or tuple, optional": "A topological order forG(if None, the function will compute one)"
            },
            "Returns:": {
                "list": "Longest path"
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis not directed"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "DG=nx.DiGraph([(0,1,{\"cost\":1}),(1,2,{\"cost\":1}),(0,2,{\"cost\":42})])\nlist(nx.all_simple_paths(DG,0,2))\n# [[0, 1, 2], [0, 2]]\nnx.dag_longest_path(DG)\n# [0, 1, 2]\nnx.dag_longest_path(DG,weight=\"cost\")\n# [0, 2]\nIn the case where multiple valid topological orderings exist,topo_ordercan be used to specify a specific ordering:\nDG=nx.DiGraph([(0,1),(0,2)])\nsorted(nx.all_topological_sorts(DG))# Valid topological orderings\n# [[0, 1, 2], [0, 2, 1]]\nnx.dag_longest_path(DG,topo_order=[0,1,2])\n# [0, 1]\nnx.dag_longest_path(DG,topo_order=[0,2,1])\n# [0, 2]"
        }
    },
    {
        "Section ID": "graphviz_layout",
        "Description": [
            "Create node positions using Pydot and Graphviz.",
            "Returns a dictionary of positions keyed by node."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "The graph for which the layout is computed.",
                "prog : string (default: \u2018neato\u2019)": "The name of the GraphViz program to use for layout.\nOptions depend on GraphViz version but may include:\n\u2018dot\u2019, \u2018twopi\u2019, \u2018fdp\u2019, \u2018sfdp\u2019, \u2018circo\u2019",
                "root : Node from G or None (default: None)": "The node of G from which to start some layout algorithms."
            },
            "Returns:": {
                "Dictionary of (x, y) positions keyed by node.": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This is a wrapper for pydot_layout.",
            "Examples": "G=nx.complete_graph(4)\npos=nx.nx_pydot.graphviz_layout(G)\npos=nx.nx_pydot.graphviz_layout(G,prog=\"dot\")"
        }
    },
    {
        "Section ID": "truncated_tetrahedron_graph",
        "Description": [
            "Returns the skeleton of the truncated Platonic tetrahedron.",
            "The truncated tetrahedron is an Archimedean solid with 4 regular hexagonal faces,\n4 equilateral triangle faces, 12 nodes and 18 edges. It can be constructed by truncating\nall 4 vertices of a regular tetrahedron at one third of the original edge length [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : networkx Graph": "Skeleton of the truncated tetrahedron"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://en.wikipedia.org/wiki/Truncated_tetrahedron"
        }
    },
    {
        "Section ID": "union_all",
        "Description": [
            "Returns the union of all graphs.",
            "The graphs must be disjoint, otherwise an exception is raised."
        ],
        "Field List": {
            "Parameters:": {
                "graphs : iterable": "Iterable of NetworkX graphs",
                "rename : iterable , optional": "Node names of graphs can be changed by specifying the tuple\nrename=(\u2018G-\u2018,\u2019H-\u2019) (for example).  Node \u201cu\u201d in G is then renamed\n\u201cG-u\u201d and \u201cv\u201d in H is renamed \u201cH-v\u201d. Infinite generators (like itertools.count)\nare also supported."
            },
            "Returns:": {
                "U : a graph with the same type as the first graph in list": ""
            },
            "Raises:": {
                "ValueError": "Ifgraphsis an empty list.",
                "NetworkXError": "In case of mixed type graphs, like MultiGraph and Graph, or directed and undirected graphs."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For operating on mixed type graphs, they should be converted to the same type.\n>>> G = nx.Graph()\n>>> H = nx.DiGraph()\n>>> GH = union_all([nx.DiGraph(G), H]) To force a disjoint union with node relabeling, use\ndisjoint_union_all(G,H) or convert_node_labels_to integers(). Graph, edge, and node attributes are propagated to the union graph.\nIf a graph attribute is present in multiple graphs, then the value\nfrom the last graph in the list with that attribute is used.",
            "Examples": "G1=nx.Graph([(1,2),(2,3)])\nG2=nx.Graph([(4,5),(5,6)])\nresult_graph=nx.union_all([G1,G2])\nresult_graph.nodes()\n# NodeView((1, 2, 3, 4, 5, 6))\nresult_graph.edges()\n# EdgeView([(1, 2), (2, 3), (4, 5), (5, 6)])"
        }
    },
    {
        "Section ID": "maximum_flow_value",
        "Description": [
            "Find the value of maximum single-commodity flow."
        ],
        "Field List": {
            "Parameters:": {
                "flowG : NetworkX graph": "Edges of the graph are expected to have an attribute called\n\u2018capacity\u2019. If this attribute is not present, the edge is\nconsidered to have infinite capacity.",
                "_s : node": "Source node for the flow.",
                "_t : node": "Sink node for the flow.",
                "capacity : string": "Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: \u2018capacity\u2019.",
                "flow_func : function": "A function for computing the maximum flow among a pair of nodes\nin a capacitated graph. The function has to accept at least three\nparameters: a Graph or Digraph, a source node, and a target node.\nAnd return a residual network that follows NetworkX conventions\n(see Notes). If flow_func is None, the default maximum\nflow function (preflow_push()) is used. See below for\nalternative algorithms. The choice of the default function may change\nfrom version to version and should not be relied on. Default value:\nNone.",
                "kwargs : Any other keyword parameter is passed to the function that": "computes the maximum flow."
            },
            "Returns:": {
                "flow_value : integer, float": "Value of the maximum flow, i.e., net outflow from the source."
            },
            "Raises:": {
                "NetworkXError": "The algorithm does not support MultiGraph and MultiDiGraph. If\nthe input graph is an instance of one of these two classes, a\nNetworkXError is raised.",
                "NetworkXUnbounded": "If the graph has a path of infinite capacity, the value of a\nfeasible flow on the graph is unbounded above and the function\nraises a NetworkXUnbounded."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The function used in the flow_func parameter has to return a residual\nnetwork that follows NetworkX conventions: The residual network R from an input graph G has the\nsame nodes as G . R is a DiGraph that contains a pair\nof edges (u,v) and (v,u) iff (u,v) is not a\nself-loop, and at least one of (u,v) and (v,u) exists\nin G . For each edge (u,v) in R , R[u][v]['capacity'] is equal to the capacity of (u,v) in G if it exists\nin G or zero otherwise. If the capacity is infinite, R[u][v]['capacity'] will have a high arbitrary finite value\nthat does not affect the solution of the problem. This value is stored in R.graph['inf'] . For each edge (u,v) in R , R[u][v]['flow'] represents the flow function of (u,v) and\nsatisfies R[u][v]['flow']==-R[v][u]['flow'] . The flow value, defined as the total flow into t , the sink, is\nstored in R.graph['flow_value'] . Reachability to t using\nonly edges (u,v) such that R[u][v]['flow']<R[u][v]['capacity'] induces a minimum s - t cut. Specific algorithms may store extra data in R . The function should supports an optional boolean parameter value_only. When\nTrue, it can optionally terminate the algorithm as soon as the maximum flow\nvalue and the minimum cut can be determined.",
            "Examples": "G=nx.DiGraph()\nG.add_edge(\"x\",\"a\",capacity=3.0)\nG.add_edge(\"x\",\"b\",capacity=1.0)\nG.add_edge(\"a\",\"c\",capacity=3.0)\nG.add_edge(\"b\",\"c\",capacity=5.0)\nG.add_edge(\"b\",\"d\",capacity=4.0)\nG.add_edge(\"d\",\"e\",capacity=2.0)\nG.add_edge(\"c\",\"y\",capacity=2.0)\nG.add_edge(\"e\",\"y\",capacity=3.0)\nmaximum_flow_value computes only the value of the\nmaximum flow:\nflow_value=nx.maximum_flow_value(G,\"x\",\"y\")\nflow_value\n# 3.0\nYou can also use alternative algorithms for computing the\nmaximum flow by using the flow_func parameter.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\nflow_value==nx.maximum_flow_value(G,\"x\",\"y\",flow_func=shortest_augmenting_path)\n# True"
        }
    },
    {
        "Section ID": "closeness_centrality",
        "Description": [
            "Compute closeness centrality for nodes.",
            "Closeness centrality [1] of a node u is the reciprocal of the\naverage shortest path distance to u over all n-1 reachable nodes.",
            "where d(v,u) is the shortest-path distance between v and u ,\nand n-1 is the number of nodes reachable from u . Notice that the\ncloseness distance function computes the incoming distance to u for directed graphs. To use outward distance, act on G.reverse() .",
            "Notice that higher values of closeness indicate higher centrality.",
            "Wasserman and Faust propose an improved formula for graphs with\nmore than one connected component. The result is \u201ca ratio of the\nfraction of actors in the group who are reachable, to the average\ndistance\u201d from the reachable actors [2] . You might think this\nscale factor is inverted but it is not. As is, nodes from small\ncomponents receive a smaller closeness value. Letting N denote\nthe number of nodes in the graph,"
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "u : node, optional": "Return only the value for node u",
                "distance : edge attribute key, optional (default=None)": "Use the specified edge attribute as the edge distance in shortest\npath calculations.  IfNone(the default) all edges have a distance of 1.\nAbsent edge attributes are assigned a distance of 1. Note that no check\nis performed to ensure that edges have the provided attribute.",
                "wf_improved : bool, optional (default=True)": "If True, scale by the fraction of nodes reachable. This gives the\nWasserman and Faust improved formula. For single component graphs\nit is the same as the original formula."
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of nodes with closeness centrality as the value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The closeness centrality is normalized to (n-1)/(|G|-1) where n is the number of nodes in the connected part of graph\ncontaining the node.  If the graph is not completely connected,\nthis algorithm computes the closeness centrality for each\nconnected part separately scaled by that parts size. If the \u2018distance\u2019 keyword is set to an edge attribute key then the\nshortest-path length will be computed using Dijkstra\u2019s algorithm with\nthat edge attribute as the edge weight. The closeness centrality uses inward distance to a node, not outward.\nIf you want to use outword distances apply the function to G.reverse() In NetworkX 2.2 and earlier a bug caused Dijkstra\u2019s algorithm to use the\noutward distance rather than the inward distance. If you use a \u2018distance\u2019\nkeyword and a DiGraph, your results will change between v2.2 and v2.3.",
            "References": "[1]Linton C. Freeman: Centrality in networks: I.\nConceptual clarification. Social Networks 1:215-239, 1979.https://doi.org/10.1016/0378-8733(78)90021-7  [2]pg. 201 of Wasserman, S. and Faust, K.,\nSocial Network Analysis: Methods and Applications, 1994,\nCambridge University Press.",
            "Examples": "G=nx.Graph([(0,1),(0,2),(0,3),(1,2),(1,3)])\nnx.closeness_centrality(G)\n# {0: 1.0, 1: 1.0, 2: 0.75, 3: 0.75}"
        }
    },
    {
        "Section ID": "naive_greedy_modularity_communities",
        "Description": [
            "Find communities in G using greedy modularity maximization.",
            "This implementation is O(n^4), much slower than alternatives, but it is\nprovided as an easy-to-understand reference implementation.",
            "Greedy modularity maximization begins with each node in its own community\nand joins the pair of communities that most increases modularity until no\nsuch pair exists.",
            "This function maximizes the generalized modularity, where resolution is the resolution parameter, often expressed as \\(\\gamma\\) .\nSee modularity() ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Graph must be simple and undirected.",
                "resolution : float (default=1)": "If resolution is less than 1, modularity favors larger communities.\nGreater than 1 favors smaller communities.",
                "weight : string or None, optional (default=None)": "The name of an edge attribute that holds the numerical value used\nas a weight.  If None, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node."
            },
            "Returns:": {
                "list": "A list of sets of nodes, one for each community.\nSorted by length with largest communities first."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.karate_club_graph()\nc=nx.community.naive_greedy_modularity_communities(G)\nsorted(c[0])\n# [8, 14, 15, 18, 20, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33]"
        }
    },
    {
        "Section ID": "corona_product",
        "Description": [
            "Returns the Corona product of G and H.",
            "The corona product of \\(G\\) and \\(H\\) is the graph \\(C = G \\circ H\\) obtained by\ntaking one copy of \\(G\\) , called the center graph, \\(|V(G)|\\) copies of \\(H\\) ,\ncalled the outer graph, and making the \\(i\\) -th vertex of \\(G\\) adjacent to\nevery vertex of the \\(i\\) -th copy of \\(H\\) , where \\(1 \u2264 i \u2264 |V(G)|\\) ."
        ],
        "Field List": {
            "Parameters:": {
                "G, H: NetworkX graphs": "The graphs to take the carona product of.Gis the center graph andHis the outer graph"
            },
            "Returns:": {
                "C: NetworkX graph": "The Corona product of G and H."
            },
            "Raises:": {
                "NetworkXError": "If G and H are not both directed or both undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1] M. Tavakoli, F. Rahbarnia, and A. R. Ashrafi, \u201cStudying the corona product of graphs under some graph invariants,\u201d\nTransactions on Combinatorics, vol. 3, no. 3, pp. 43\u201349, Sep. 2014,\ndoi: 10.22108/toc.2014.5542.  [2] A. Faraji, \u201cCorona Product in Graph Theory,\u201d Ali Faraji, May 11, 2021. https://blog.alifaraji.ir/math/graph-theory/corona-product.html(accessed Dec. 07, 2021).",
            "Examples": "G=nx.cycle_graph(4)\nH=nx.path_graph(2)\nC=nx.corona_product(G,H)\nlist(C)\n# [0, 1, 2, 3, (0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1), (3, 0), (3, 1)]\nprint(C)\n# Graph with 12 nodes and 16 edges"
        }
    },
    {
        "Section ID": "planted_partition_graph",
        "Description": [
            "Returns the planted l-partition graph.",
            "This model partitions a graph with n=l*k vertices in\nl groups with k vertices each. Vertices of the same\ngroup are linked with a probability p_in, and vertices\nof different groups are linked with probability p_out."
        ],
        "Field List": {
            "Parameters:": {
                "l : int": "Number of groups",
                "k : int": "Number of vertices in each group",
                "p_in : float": "probability of connecting vertices within a group",
                "p_out : float": "probability of connected vertices between groups",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "directed : bool,optional (default=False)": "If True return a directed graph"
            },
            "Returns:": {
                "G : NetworkX Graph or DiGraph": "planted l-partition graph"
            },
            "Raises:": {
                "NetworkXError": "Ifp_in,p_outare not in[0,1]"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]A. Condon, R.M. Karp, Algorithms for graph partitioning\non the planted partition model,\nRandom Struct. Algor. 18 (2001) 116-140.  [2]Santo Fortunato \u2018Community Detection in Graphs\u2019 Physical Reports\nVolume 486, Issue 3-5 p. 75-174.https://arxiv.org/abs/0906.0612",
            "Examples": "G=nx.planted_partition_graph(4,3,0.5,0.1,seed=42)"
        }
    },
    {
        "Section ID": "percolation_centrality",
        "Description": [
            "Compute the percolation centrality for nodes.",
            "Percolation centrality of a node \\(v\\) , at a given time, is defined\nas the proportion of \u2018percolated paths\u2019 that go through that node.",
            "This measure quantifies relative impact of nodes based on their\ntopological connectivity, as well as their percolation states.",
            "Percolation states of nodes are used to depict network percolation\nscenarios (such as during infection transmission in a social network\nof individuals, spreading of computer viruses on computer networks, or\ntransmission of disease over a network of towns) over time. In this\nmeasure usually the percolation state is expressed as a decimal\nbetween 0.0 and 1.0.",
            "When all nodes are in the same percolated state this measure is\nequivalent to betweenness centrality."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.",
                "attribute : None or string, optional (default=\u2019percolation\u2019)": "Name of the node attribute to use for percolation state, used\nifstatesis None. If a node does not set the attribute the\nstate of that node will be set to the default value of 1.\nIf all nodes do not have the attribute all nodes will be set to\n1 and the centrality measure will be equivalent to betweenness centrality.",
                "states : None or dict, optional (default=None)": "Specify percolation states for the nodes, nodes as keys states\nas values.",
                "weight : None or string, optional (default=None)": "If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight.\nThe weight of an edge is treated as the length or distance between the two sides."
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of nodes with percolation centrality as the value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The algorithm is from Mahendra Piraveenan, Mikhail Prokopenko, and\nLiaquat Hossain [1] Pair dependencies are calculated and accumulated using [2] For weighted graphs the edge weights must be greater than zero.\nZero edge weights can produce an infinite number of equal length\npaths between pairs of nodes.",
            "References": "[1]Mahendra Piraveenan, Mikhail Prokopenko, Liaquat Hossain\nPercolation Centrality: Quantifying Graph-Theoretic Impact of Nodes\nduring Percolation in Networkshttp://journals.plos.org/plosone/article?id=10.1371/journal.pone.0053095  [2]Ulrik Brandes:\nA Faster Algorithm for Betweenness Centrality.\nJournal of Mathematical Sociology 25(2):163-177, 2001.https://doi.org/10.1080/0022250X.2001.9990249"
        }
    },
    {
        "Section ID": "cost_of_flow",
        "Description": [
            "Compute the cost of the flow given by flowDict on graph G.",
            "Note that this function does not check for the validity of the\nflow flowDict. This function will fail if the graph G and the\nflow don\u2019t have the same edge set."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "DiGraph on which a minimum cost flow satisfying all demands is\nto be found.",
                "weight : string": "Edges of the graph G are expected to have an attribute weight\nthat indicates the cost incurred by sending one unit of flow on\nthat edge. If not present, the weight is considered to be 0.\nDefault value: \u2018weight\u2019.",
                "flowDict : dictionary": "Dictionary of dictionaries keyed by nodes such that\nflowDict[u][v] is the flow edge (u, v)."
            },
            "Returns:": {
                "cost : Integer, float": "The total cost of the flow. This is given by the sum over all\nedges of the product of the edge\u2019s flow and the edge\u2019s weight."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm is not guaranteed to work if edge weights or demands\nare floating point numbers (overflows and roundoff errors can\ncause problems). As a workaround you can use integer numbers by\nmultiplying the relevant edge attributes by a convenient\nconstant factor (eg 100).",
            "Examples": "G=nx.DiGraph()\nG.add_node(\"a\",demand=-5)\nG.add_node(\"d\",demand=5)\nG.add_edge(\"a\",\"b\",weight=3,capacity=4)\nG.add_edge(\"a\",\"c\",weight=6,capacity=10)\nG.add_edge(\"b\",\"d\",weight=1,capacity=9)\nG.add_edge(\"c\",\"d\",weight=2,capacity=5)\nflowDict=nx.min_cost_flow(G)\nflowDict\n# {'a': {'b': 4, 'c': 1}, 'd': {}, 'b': {'d': 4}, 'c': {'d': 1}}\nnx.cost_of_flow(G,flowDict)\n# 24"
        }
    },
    {
        "Section ID": "bfs_edges",
        "Description": [
            "Iterate over edges in a breadth-first-search starting at source."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node": "Specify starting node for breadth-first search; this function\niterates over only those edges in the component reachable from\nthis node.",
                "reverse : bool, optional": "If True traverse a directed graph in the reverse direction",
                "depth_limit : int, optional(default=len(G))": "Specify the maximum search depth",
                "sort_neighbors : function (default=None)": "A function that takes an iterator over nodes as the input, and\nreturns an iterable of the same nodes with a custom ordering.\nFor example,sortedwill sort the nodes in increasing order."
            },
            "Yields:": {
                "edge: 2-tuple of nodes": "Yields edges resulting from the breadth-first search."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The naming of this function is very similar to edge_bfs() . The difference\nis that edge_bfs yields edges even if they extend back to an already\nexplored node while this generator yields the edges of the tree that results\nfrom a breadth-first-search (BFS) so no edges are reported if they extend\nto already explored nodes. That means edge_bfs reports all edges while bfs_edges only reports those traversed by a node-based BFS. Yet another\ndescription is that bfs_edges reports the edges traversed during BFS\nwhile edge_bfs reports all edges in the order they are explored. Based on the breadth-first search implementation in PADS [1] by D. Eppstein, July 2004; with modifications to allow depth limits\nas described in [2] .",
            "References": "[1]http://www.ics.uci.edu/~eppstein/PADS/BFS.py.  [2]https://en.wikipedia.org/wiki/Depth-limited_search",
            "Examples": "To get the edges in a breadth-first search:\nG=nx.path_graph(3)\nlist(nx.bfs_edges(G,0))\n# [(0, 1), (1, 2)]\nlist(nx.bfs_edges(G,source=0,depth_limit=1))\n# [(0, 1)]\nTo get the nodes in a breadth-first search order:\nG=nx.path_graph(3)\nroot=2\nedges=nx.bfs_edges(G,root)\nnodes=[root]+[vforu,vinedges]\nnodes\n# [2, 1, 0]"
        }
    },
    {
        "Section ID": "katz_centrality_numpy",
        "Description": [
            "Compute the Katz centrality for the graph G.",
            "Katz centrality computes the centrality for a node based on the centrality\nof its neighbors. It is a generalization of the eigenvector centrality. The\nKatz centrality for node \\(i\\) is",
            "where \\(A\\) is the adjacency matrix of graph G with eigenvalues \\(\\lambda\\) .",
            "The parameter \\(\\beta\\) controls the initial centrality and",
            "Katz centrality computes the relative influence of a node within a\nnetwork by measuring the number of the immediate neighbors (first\ndegree nodes) and also all other nodes in the network that connect\nto the node under consideration through these immediate neighbors.",
            "Extra weight can be provided to immediate neighbors through the\nparameter \\(\\beta\\) .  Connections made with distant neighbors\nare, however, penalized by an attenuation factor \\(\\alpha\\) which\nshould be strictly less than the inverse largest eigenvalue of the\nadjacency matrix in order for the Katz centrality to be computed\ncorrectly. More information is provided in [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "alpha : float": "Attenuation factor",
                "beta : scalar or dictionary, optional (default=1.0)": "Weight attributed to the immediate neighborhood. If not a scalar the\ndictionary must have an value for every node.",
                "normalized : bool": "If True normalize the resulting values.",
                "weight : None or string, optional": "If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight.\nIn this measure the weight is interpreted as the connection strength."
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of nodes with Katz centrality as the value."
            },
            "Raises:": {
                "NetworkXError": "If the parameterbetais not a scalar but lacks a value for at least\none node"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Katz centrality was introduced by [2] . This algorithm uses a direct linear solver to solve the above equation.\nThe parameter alpha should be strictly less than the inverse of largest\neigenvalue of the adjacency matrix for there to be a solution.\nYou can use max(nx.adjacency_spectrum(G)) to get \\(\\lambda_{\\max}\\) the largest\neigenvalue of the adjacency matrix. For strongly connected graphs, as \\(\\alpha \\to 1/\\lambda_{\\max}\\) , and \\(\\beta > 0\\) ,\nKatz centrality approaches the results for eigenvector centrality. For directed graphs this finds \u201cleft\u201d eigenvectors which corresponds\nto the in-edges in the graph. For out-edges Katz centrality,\nfirst reverse the graph with G.reverse() .",
            "References": "[1]Mark E. J. Newman:\nNetworks: An Introduction.\nOxford University Press, USA, 2010, p. 173.  [2]Leo Katz:\nA New Status Index Derived from Sociometric Index.\nPsychometrika 18(1):39\u201343, 1953https://link.springer.com/content/pdf/10.1007/BF02289026.pdf",
            "Examples": "importmath\nG=nx.path_graph(4)\nphi=(1+math.sqrt(5))/2.0# largest eigenvalue of adj matrix\ncentrality=nx.katz_centrality_numpy(G,1/phi)\nforn,cinsorted(centrality.items()):\nprint(f\"{n} {c:.2f}\")\n# 0 0.37\n# 1 0.60\n# 2 0.60\n# 3 0.37"
        }
    },
    {
        "Section ID": "complete_graph",
        "Description": [
            "Return the complete graph K_n with n nodes.",
            "A complete graph on n nodes means that all pairs\nof distinct nodes have an edge connecting them.",
            "( Sourcecode , png )"
        ],
        "Field List": {
            "Parameters:": {
                "n : int or iterable container of nodes": "If n is an integer, nodes are from range(n).\nIf n is a container of nodes, those nodes appear in the graph.\nWarning: n is not checked for duplicates and if present the\nresulting graph may not be as desired. Make sure you have no duplicates.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.complete_graph(9)\nlen(G)\n# 9\nG.size()\n# 36\nG=nx.complete_graph(range(11,14))\nlist(G.nodes())\n# [11, 12, 13]\nG=nx.complete_graph(4,nx.DiGraph())\nG.is_directed()\n# True"
        }
    },
    {
        "Section ID": "local_reaching_centrality",
        "Description": [
            "Returns the local reaching centrality of a node in a directed\ngraph.",
            "The local reaching centrality of a node in a directed graph is the\nproportion of other nodes reachable from that node [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : DiGraph": "A NetworkX DiGraph.",
                "v : node": "A node in the directed graphG.",
                "paths : dictionary (default=None)": "If this is notNoneit must be a dictionary representation\nof single-source shortest paths, as computed by, for example,networkx.shortest_path()with source nodev. Use this\nkeyword argument if you intend to invoke this function many\ntimes but don\u2019t want the paths to be recomputed each time.",
                "weight : None or string, optional (default=None)": "Attribute to use for edge weights.  IfNone, each edge weight\nis assumed to be one. A higher weight implies a stronger\nconnection between nodes and ashorterpath length.",
                "normalized : bool, optional (default=True)": "Whether to normalize the edge weights by the total sum of edge\nweights."
            },
            "Returns:": {
                "h : float": "The local reaching centrality of the nodevin the graphG."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Mones, Enys, Lilla Vicsek, and Tam\u00e1s Vicsek.\n\u201cHierarchy Measure for Complex Networks.\u201dPLoS ONE7.3 (2012): e33799.https://doi.org/10.1371/journal.pone.0033799",
            "Examples": "G=nx.DiGraph()\nG.add_edges_from([(1,2),(1,3)])\nnx.local_reaching_centrality(G,3)\n# 0.0\nG.add_edge(3,2)\nnx.local_reaching_centrality(G,3)\n# 0.5"
        }
    },
    {
        "Section ID": "sedgewick_maze_graph",
        "Description": [
            "Return a small maze with a cycle.",
            "This is the maze used in Sedgewick, 3rd Edition, Part 5, Graph\nAlgorithms, Chapter 18, e.g. Figure 18.2 and following [1] .\nNodes are numbered 0,..,7"
        ],
        "Field List": {
            "Parameters:": {
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : networkx Graph": "Small maze with a cycle"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Figure 18.2, Chapter 18, Graph Algorithms (3rd Ed), Sedgewick"
        }
    },
    {
        "Section ID": "random_clustered_graph",
        "Description": [
            "Generate a random graph with the given joint independent edge degree and\ntriangle degree sequence.",
            "This uses a configuration model-like approach to generate a random graph\n(with parallel edges and self-loops) by randomly assigning edges to match\nthe given joint degree sequence.",
            "The joint degree sequence is a list of pairs of integers of the form \\([(d_{1,i}, d_{1,t}), \\dotsc, (d_{n,i}, d_{n,t})]\\) . According to this list,\nvertex \\(u\\) is a member of \\(d_{u,t}\\) triangles and has \\(d_{u, i}\\) other\nedges. The number \\(d_{u,t}\\) is the triangle degree of \\(u\\) and the number \\(d_{u,i}\\) is the independent edge degree ."
        ],
        "Field List": {
            "Parameters:": {
                "joint_degree_sequence : list of integer pairs": "Each list entry corresponds to the independent edge degree and\ntriangle degree of a node.",
                "create_using : NetworkX graph constructor, optional (default MultiGraph)": "Graph type to create. If graph instance, then cleared before populated.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "G : MultiGraph": "A graph with the specified degree sequence. Nodes are labeled\nstarting at 0 with an index corresponding to the position in\ndeg_sequence."
            },
            "Raises:": {
                "NetworkXError": "If the independent edge degree sequence sum is not even\nor the triangle degree sequence sum is not divisible by 3."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "As described by Miller [1] (see also Newman [2] for an equivalent\ndescription). A non-graphical degree sequence (not realizable by some simple\ngraph) is allowed since this function returns graphs with self\nloops and parallel edges.  An exception is raised if the\nindependent degree sequence does not have an even sum or the\ntriangle degree sequence sum is not divisible by 3. This configuration model-like construction process can lead to\nduplicate edges and loops.  You can remove the self-loops and\nparallel edges (see below) which will likely result in a graph\nthat doesn\u2019t have the exact degree sequence specified.  This\n\u201cfinite-size effect\u201d decreases as the size of the graph increases.",
            "References": "[1]Joel C. Miller. \u201cPercolation and epidemics in random clustered\nnetworks\u201d. In: Physical review. E, Statistical, nonlinear, and soft\nmatter physics 80 (2 Part 1 August 2009).  [2]M. E. J. Newman. \u201cRandom Graphs with Clustering\u201d.\nIn: Physical Review Letters 103 (5 July 2009)",
            "Examples": "deg=[(1,0),(1,0),(1,0),(2,0),(1,0),(2,1),(0,1),(0,1)]\nG=nx.random_clustered_graph(deg)\nTo remove parallel edges:\nG=nx.Graph(G)\nTo remove self loops:\nG.remove_edges_from(nx.selfloop_edges(G))"
        }
    },
    {
        "Section ID": "k_components",
        "Description": [
            "Returns the approximate k-component structure of a graph G.",
            "A k -component is a maximal subgraph of a graph G that has, at least,\nnode connectivity k : we need to remove at least k nodes to break it\ninto more components. k -components have an inherent hierarchical\nstructure because they are nested in terms of connectivity: a connected\ngraph can contain several 2-components, each of which can contain\none or more 3-components, and so forth.",
            "This implementation is based on the fast heuristics to approximate\nthe k -component structure of a graph [1] . Which, in turn, it is based on\na fast approximation algorithm for finding good lower bounds of the number\nof node independent paths between two nodes [2] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected graph",
                "min_density : Float": "Density relaxation threshold. Default value 0.95"
            },
            "Returns:": {
                "k_components : dict": "Dictionary with connectivity levelkas key and a list of\nsets of nodes that form a k-component of levelkas values."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is directed."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The logic of the approximation algorithm for computing the k -component\nstructure [1] is based on repeatedly applying simple and fast algorithms\nfor k -cores and biconnected components in order to narrow down the\nnumber of pairs of nodes over which we have to compute White and Newman\u2019s\napproximation algorithm for finding node independent paths [2] . More\nformally, this algorithm is based on Whitney\u2019s theorem, which states\nan inclusion relation among node connectivity, edge connectivity, and\nminimum degree for any graph G. This theorem implies that every k -component is nested inside a k -edge-component, which in turn,\nis contained in a k -core. Thus, this algorithm computes node independent\npaths among pairs of nodes in each biconnected part of each k -core,\nand repeats this procedure for each k from 3 to the maximal core number\nof a node in the input graph. Because, in practice, many nodes of the core of level k inside a\nbicomponent actually are part of a component of level k, the auxiliary\ngraph needed for the algorithm is likely to be very dense. Thus, we use\na complement graph data structure (see AntiGraph ) to save memory.\nAntiGraph only stores information of the edges that are not present\nin the actual auxiliary graph. When applying algorithms to this\ncomplement graph data structure, it behaves as if it were the dense\nversion.",
            "References": "[1](1,2)Torrents, J. and F. Ferraro (2015) Structural Cohesion:\nVisualization and Heuristics for Fast Computation.https://arxiv.org/pdf/1503.04476v1  [2](1,2)White, Douglas R., and Mark Newman (2001) A Fast Algorithm for\nNode-Independent Paths. Santa Fe Institute Working Paper #01-07-035https://www.santafe.edu/research/results/working-papers/fast-approximation-algorithms-for-finding-node-ind  [3]Moody, J. and D. White (2003). Social cohesion and embeddedness:\nA hierarchical conception of social groups.\nAmerican Sociological Review 68(1), 103\u201328.https://doi.org/10.2307/3088904",
            "Examples": "# Petersen graph has 10 nodes and it is triconnected, thus all\n# nodes are in a single component on all three connectivity levels\nfromnetworkx.algorithmsimportapproximationasapxa\nG=nx.petersen_graph()\nk_components=apxa.k_components(G)"
        }
    },
    {
        "Section ID": "label_propagation_communities",
        "Description": [
            "Generates community sets determined by label propagation",
            "Finds communities in G using a semi-synchronous label propagation\nmethod [1] . This method combines the advantages of both the synchronous\nand asynchronous models. Not implemented for directed graphs."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "An undirected NetworkX graph."
            },
            "Returns:": {
                "communities : iterable": "A dict_values object that contains a set of nodes for each community."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the graph is directed"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Cordasco, G., & Gargano, L. (2010, December). Community detection\nvia semi-synchronous label propagation algorithms. In Business\nApplications of Social Network Analysis (BASNA), 2010 IEEE International\nWorkshop on (pp. 1-8). IEEE."
        }
    },
    {
        "Section ID": "dijkstra_path",
        "Description": [
            "Returns the shortest weighted path from source to target in G.",
            "Uses Dijkstra\u2019s Method to compute the shortest weighted path\nbetween two nodes in a graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node": "Starting node",
                "target : node": "Ending node",
                "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge."
            },
            "Returns:": {
                "path : list": "List of nodes in a shortest path."
            },
            "Raises:": {
                "NodeNotFound": "Ifsourceis not inG.",
                "NetworkXNoPath": "If no path exists between source and target."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The weight function can be used to hide edges by returning None.\nSo weight=lambdau,v,d:1ifd['color']==\"red\"elseNone will find the shortest red path. The weight function can be used to include node weights.",
            "Examples": "G=nx.path_graph(5)\nprint(nx.dijkstra_path(G,0,4))\n# [0, 1, 2, 3, 4]\nFind edges of shortest path in Multigraph\nG=nx.MultiDiGraph()\nG.add_weighted_edges_from([(1,2,0.75),(1,2,0.5),(2,3,0.5),(1,3,1.5)])\nnodes=nx.dijkstra_path(G,1,3)\nedges=nx.utils.pairwise(nodes)\nlist(\n(u,v,min(G[u][v],key=lambdak:G[u][v][k].get(\"weight\",1)))\nforu,vinedges\n)\n# [(1, 2, 1), (2, 3, 0)]"
        }
    },
    {
        "Section ID": "biconnected_component_edges",
        "Description": [
            "Returns a generator of lists of edges, one list for each biconnected\ncomponent of the input graph.",
            "Biconnected components are maximal subgraphs such that the removal of a\nnode (and all edges incident on that node) will not disconnect the\nsubgraph.  Note that nodes may be part of more than one biconnected\ncomponent.  Those nodes are articulation points, or cut vertices.\nHowever, each edge belongs to one, and only one, biconnected component.",
            "Notice that by convention a dyad is considered a biconnected component."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "An undirected graph."
            },
            "Returns:": {
                "edges : generator of lists": "Generator of lists of edges, one list for each bicomponent."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the input graph is not undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The algorithm to find articulation points and biconnected\ncomponents is implemented using a non-recursive depth-first-search\n(DFS) that keeps track of the highest level that back edges reach\nin the DFS tree.  A node n is an articulation point if, and only\nif, there exists a subtree rooted at n such that there is no\nback edge from any successor of n that links to a predecessor of n in the DFS tree.  By keeping track of all the edges traversed\nby the DFS we can obtain the biconnected components because all\nedges of a bicomponent will be traversed consecutively between\narticulation points.",
            "References": "[1]Hopcroft, J.; Tarjan, R. (1973).\n\u201cEfficient algorithms for graph manipulation\u201d.\nCommunications of the ACM 16: 372\u2013378. doi:10.1145/362248.362272",
            "Examples": "G=nx.barbell_graph(4,2)\nprint(nx.is_biconnected(G))\n# False\nbicomponents_edges=list(nx.biconnected_component_edges(G))\nlen(bicomponents_edges)\n# 5\nG.add_edge(2,8)\nprint(nx.is_biconnected(G))\n# True\nbicomponents_edges=list(nx.biconnected_component_edges(G))\nlen(bicomponents_edges)\n# 1"
        }
    },
    {
        "Section ID": "asyn_fluidc",
        "Description": [
            "Returns communities in G as detected by Fluid Communities algorithm.",
            "The asynchronous fluid communities algorithm is described in [1] . The algorithm is based on the simple idea of fluids interacting\nin an environment, expanding and pushing each other. Its initialization is\nrandom, so found communities may vary on different executions.",
            "The algorithm proceeds as follows. First each of the initial k communities\nis initialized in a random vertex in the graph. Then the algorithm iterates\nover all vertices in a random order, updating the community of each vertex\nbased on its own community and the communities of its neighbors. This\nprocess is performed several times until convergence.\nAt all times, each community has a total density of 1, which is equally\ndistributed among the vertices it contains. If a vertex changes of\ncommunity, vertex densities of affected communities are adjusted\nimmediately. When a complete iteration over all vertices is done, such that\nno vertex changes the community it belongs to, the algorithm has converged\nand returns.",
            "This is the original version of the algorithm described in [1] .\nUnfortunately, it does not support weighted graphs yet."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Graph must be simple and undirected.",
                "k : integer": "The number of communities to be found.",
                "max_iter : integer": "The number of maximum iterations allowed. By default 100.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "communities : iterable": "Iterable of communities given as sets of nodes."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "k variable is not an optional argument.",
            "References": "[1](1,2)Par\u00e9s F., Garcia-Gasulla D. et al. \u201cFluid Communities: A\nCompetitive and Highly Scalable Community Detection Algorithm\u201d.\n[https://arxiv.org/pdf/1703.09307.pdf]."
        }
    },
    {
        "Section ID": "is_valid_degree_sequence_erdos_gallai",
        "Description": [
            "Returns True if deg_sequence can be realized by a simple graph.",
            "The validation is done using the Erd\u0151s-Gallai theorem [EG1960] ."
        ],
        "Field List": {
            "Parameters:": {
                "deg_sequence : list": "A list of integers"
            },
            "Returns:": {
                "valid : bool": "True if deg_sequence is graphical and False if not."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This implementation uses an equivalent form of the Erd\u0151s-Gallai criterion.\nWorst-case run time is \\(O(n)\\) where \\(n\\) is the length of the sequence. Specifically, a sequence d is graphical if and only if the\nsum of the sequence is even and for all strong indices k in the sequence,",
            "References": "[1]A. Tripathi and S. Vijay. \u201cA note on a theorem of Erd\u0151s & Gallai\u201d,\nDiscrete Mathematics, 265, pp. 417-420 (2003).  [2](1,2)I.E. Zverovich and V.E. Zverovich. \u201cContributions to the theory\nof graphic sequences\u201d, Discrete Mathematics, 105, pp. 292-303 (1992).  [EG1960]Erd\u0151s and Gallai, Mat. Lapok 11 264, 1960.",
            "Examples": "G=nx.Graph([(1,2),(1,3),(2,3),(3,4),(4,2),(5,1),(5,4)])\nsequence=(dfor_,dinG.degree())\nnx.is_valid_degree_sequence_erdos_gallai(sequence)\n# True\nTo test a non-valid sequence:\n>>> sequence_list = [d for _, d in G.degree()]\n>>> sequence_list[-1] += 1\n>>> nx.is_valid_degree_sequence_erdos_gallai(sequence_list)\nFalse"
        }
    },
    {
        "Section ID": "maximal_independent_set",
        "Description": [
            "Returns a random maximal independent set guaranteed to contain\na given set of nodes.",
            "An independent set is a set of nodes such that the subgraph\nof G induced by these nodes contains no edges. A maximal\nindependent set is an independent set such that it is not possible\nto add a new node and still get an independent set."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "nodes : list or iterable": "Nodes that must be part of the independent set. This set of nodes\nmust be independent.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "indep_nodes : list": "List of nodes that are part of a maximal independent set."
            },
            "Raises:": {
                "NetworkXUnfeasible": "If the nodes in the provided list are not part of the graph or\ndo not form an independent set, an exception is raised.",
                "NetworkXNotImplemented": "IfGis directed."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm does not solve the maximum independent set problem.",
            "Examples": "G=nx.path_graph(5)\nnx.maximal_independent_set(G)\n# [4, 0, 2]\nnx.maximal_independent_set(G,[1])\n# [1, 3]"
        }
    },
    {
        "Section ID": "group_out_degree_centrality",
        "Description": [
            "Compute the group out-degree centrality for a group of nodes.",
            "Group out-degree centrality of a group of nodes \\(S\\) is the fraction\nof non-group members connected to group members by outgoing edges."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.",
                "S : list or set": "S is a group of nodes which belong to G, for which group in-degree\ncentrality is to be calculated."
            },
            "Returns:": {
                "centrality : float": "Group out-degree centrality of the group S."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is undirected.",
                "NodeNotFound": "If node(s) in S are not in G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The number of nodes in the group must be a maximum of n - 1 where n is the total number of nodes in the graph. G.neighbors(i) gives nodes with an outward edge from i, in a DiGraph,\nso for group out-degree centrality, the graph itself is used."
        }
    },
    {
        "Section ID": "adjacency_spectrum",
        "Description": [
            "Returns eigenvalues of the adjacency matrix of G."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "weight : string or None, optional (default=\u2019weight\u2019)": "The edge data key used to compute each value in the matrix.\nIf None, then each edge has weight 1."
            },
            "Returns:": {
                "evals : NumPy array": "Eigenvalues"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For MultiGraph/MultiDiGraph, the edges weights are summed.\nSee to_numpy_array for other options."
        }
    },
    {
        "Section ID": "local_and_global_consistency",
        "Description": [
            "Node classification by Local and Global Consistency",
            "Function for computing Local and global consistency algorithm by Zhou et al."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "",
                "alpha : float": "Clamping factor",
                "max_iter : int": "Maximum number of iterations allowed",
                "label_name : string": "Name of target labels to predict"
            },
            "Returns:": {
                "predicted : list": "List of lengthlen(G)with the predicted labels for each node."
            },
            "Raises:": {
                "NetworkXError": "If no nodes inGhave attributelabel_name."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "Zhou, D., Bousquet, O., Lal, T. N., Weston, J., & Sch\u00f6lkopf, B. (2004).\nLearning with local and global consistency.\nAdvances in neural information processing systems, 16(16), 321-328.",
            "Examples": "fromnetworkx.algorithmsimportnode_classification\nG=nx.path_graph(4)\nG.nodes[0][\"label\"]=\"A\"\nG.nodes[3][\"label\"]=\"B\"\nG.nodes(data=True)\n# NodeDataView({0: {'label': 'A'}, 1: {}, 2: {}, 3: {'label': 'B'}})\nG.edges()\n# EdgeView([(0, 1), (1, 2), (2, 3)])\npredicted=node_classification.local_and_global_consistency(G)\npredicted\n# ['A', 'A', 'B', 'B']"
        }
    },
    {
        "Section ID": "read_dot",
        "Description": [
            "Returns a NetworkX graph from a dot file on path."
        ],
        "Field List": {
            "Parameters:": {
                "path : file or string": "File name or file handle to read."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "moebius_kantor_graph",
        "Description": [
            "Returns the Moebius-Kantor graph.",
            "The M\u00f6bius-Kantor graph is the cubic symmetric graph on 16 nodes.\nIts LCF notation is [5,-5]^8, and it is isomorphic to the generalized\nPetersen graph [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : networkx Graph": "Moebius-Kantor graph"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://en.wikipedia.org/wiki/M%C3%B6bius%E2%80%93Kantor_graph"
        }
    },
    {
        "Section ID": "is_arborescence",
        "Description": [
            "Returns True if G is an arborescence.",
            "An arborescence is a directed tree with maximum in-degree equal to 1."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "The graph to test."
            },
            "Returns:": {
                "b : bool": "A boolean that is True ifGis an arborescence."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "In another convention, an arborescence is known as a tree .",
            "Examples": "G=nx.DiGraph([(0,1),(0,2),(2,3),(3,4)])\nnx.is_arborescence(G)\n# True\nG.remove_edge(0,1)\nG.add_edge(1,2)# maximum in-degree is 2\nnx.is_arborescence(G)\n# False"
        }
    },
    {
        "Section ID": "ramsey_R2",
        "Description": [
            "Compute the largest clique and largest independent set in G .",
            "This can be used to estimate bounds for the 2-color\nRamsey number R(2;s,t) for G .",
            "This is a recursive implementation which could run into trouble\nfor large recursions. Note that self-loop edges are ignored."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected graph"
            },
            "Returns:": {
                "max_pair : (set, set) tuple": "Maximum clique, Maximum independent set."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the graph is directed or is a multigraph."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "is_distance_regular",
        "Description": [
            "Returns True if the graph is distance regular, False otherwise.",
            "A connected graph G is distance-regular if for any nodes x,y\nand any integers i,j=0,1,\u2026,d (where d is the graph\ndiameter), the number of vertices at distance i from x and\ndistance j from y depends only on i,j and the graph distance\nbetween x and y, independently of the choice of x and y."
        ],
        "Field List": {
            "Parameters:": {
                "G: Networkx graph (undirected)": ""
            },
            "Returns:": {
                "bool": "True if the graph is Distance Regular, False otherwise"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For undirected and simple graphs only",
            "References": "[1]Brouwer, A. E.; Cohen, A. M.; and Neumaier, A.\nDistance-Regular Graphs. New York: Springer-Verlag, 1989.  [2]Weisstein, Eric W. \u201cDistance-Regular Graph.\u201dhttp://mathworld.wolfram.com/Distance-RegularGraph.html",
            "Examples": "G=nx.hypercube_graph(6)\nnx.is_distance_regular(G)\n# True"
        }
    },
    {
        "Section ID": "write_latex",
        "Description": [
            "Write the latex code to draw the graph(s) onto path .",
            "This convenience function creates the latex drawing code as a string\nand writes that to a file ready to be compiled when as_document is True\nor ready to be import ed or include ed into your main LaTeX document.",
            "The path argument can be a string filename or a file handle to write to."
        ],
        "Field List": {
            "Parameters:": {
                "Gbunch : NetworkX graph or iterable of NetworkX graphs": "If Gbunch is a graph, it is drawn in a figure environment.\nIf Gbunch is an iterable of graphs, each is drawn in a subfigure\nenvironment within a single figure environment.",
                "path : filename": "Filename or file handle to write to",
                "options : dict": "By default, TikZ is used with options: (others are ignored):pos : string or dict or list\n    The name of the node attribute on `G` that holds the position of each node.\n    Positions can be sequences of length 2 with numbers for (x,y) coordinates.\n    They can also be strings to denote positions in TikZ style, such as (x, y)\n    or (angle:radius).\n    If a dict, it should be keyed by node to a position.\n    If an empty dict, a circular layout is computed by TikZ.\n    If you are drawing many graphs in subfigures, use a list of position dicts.\ntikz_options : string\n    The tikzpicture options description defining the options for the picture.\n    Often large scale options like `[scale=2]`.\ndefault_node_options : string\n    The draw options for a path of nodes. Individual node options override these.\nnode_options : string or dict\n    The name of the node attribute on `G` that holds the options for each node.\n    Or a dict keyed by node to a string holding the options for that node.\nnode_label : string or dict\n    The name of the node attribute on `G` that holds the node label (text)\n    displayed for each node. If the attribute is \"\" or not present, the node\n    itself is drawn as a string. LaTeX processing such as ``\"$A_1$\"`` is allowed.\n    Or a dict keyed by node to a string holding the label for that node.\ndefault_edge_options : string\n    The options for the scope drawing all edges. The default is \"[-]\" for\n    undirected graphs and \"[->]\" for directed graphs.\nedge_options : string or dict\n    The name of the edge attribute on `G` that holds the options for each edge.\n    If the edge is a self-loop and ``\"loop\" not in edge_options`` the option\n    \"loop,\" is added to the options for the self-loop edge. Hence you can\n    use \"[loop above]\" explicitly, but the default is \"[loop]\".\n    Or a dict keyed by edge to a string holding the options for that edge.\nedge_label : string or dict\n    The name of the edge attribute on `G` that holds the edge label (text)\n    displayed for each edge. If the attribute is \"\" or not present, no edge\n    label is drawn.\n    Or a dict keyed by edge to a string holding the label for that edge.\nedge_label_options : string or dict\n    The name of the edge attribute on `G` that holds the label options for\n    each edge. For example, \"[sloped,above,blue]\". The default is no options.\n    Or a dict keyed by edge to a string holding the label options for that edge.\ncaption : string\n    The caption string for the figure environment\nlatex_label : string\n    The latex label used for the figure for easy referral from the main text\nsub_captions : list of strings\n    The sub_caption string for each subfigure in the figure\nsub_latex_labels : list of strings\n    The latex label for each subfigure in the figure\nn_rows : int\n    The number of rows of subfigures to arrange for multiple graphs\nas_document : bool\n    Whether to wrap the latex code in a document environment for compiling\ndocument_wrapper : formatted text string with variable ``content``.\n    This text is called to evaluate the content embedded in a document\n    environment with a preamble setting up the TikZ syntax.\nfigure_wrapper : formatted text string\n    This text is evaluated with variables ``content``, ``caption`` and ``label``.\n    It wraps the content and if a caption is provided, adds the latex code for\n    that caption, and if a label is provided, adds the latex code for a label.\nsubfigure_wrapper : formatted text string\n    This text evaluate variables ``size``, ``content``, ``caption`` and ``label``.\n    It wraps the content and if a caption is provided, adds the latex code for\n    that caption, and if a label is provided, adds the latex code for a label.\n    The size is the vertical size of each row of subfigures as a fraction."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "chain_decomposition",
        "Description": [
            "Returns the chain decomposition of a graph.",
            "The chain decomposition of a graph with respect a depth-first\nsearch tree is a set of cycles or paths derived from the set of\nfundamental cycles of the tree in the following manner. Consider\neach fundamental cycle with respect to the given tree, represented\nas a list of edges beginning with the nontree edge oriented away\nfrom the root of the tree. For each fundamental cycle, if it\noverlaps with any previous fundamental cycle, just take the initial\nnon-overlapping segment, which is a path instead of a cycle. Each\ncycle or path is called a chain . For more information, see [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : undirected graph": "",
                "root : node (optional)": "A node in the graphG. If specified, only the chain\ndecomposition for the connected component containing this node\nwill be returned. This node indicates the root of the depth-first\nsearch tree."
            },
            "Yields:": {
                "chain : list": "A list of edges representing a chain. There is no guarantee on\nthe orientation of the edges in each chain (for example, if a\nchain includes the edge joining nodes 1 and 2, the chain may\ninclude either (1, 2) or (2, 1))."
            },
            "Raises:": {
                "NodeNotFound": "Ifrootis not in the graphG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The worst-case running time of this implementation is linear in the\nnumber of nodes and number of edges [1] .",
            "References": "[1](1,2)Jens M. Schmidt (2013). \u201cA simple test on 2-vertex-\nand 2-edge-connectivity.\u201dInformation Processing Letters,\n113, 241\u2013244. Elsevier. <https://doi.org/10.1016/j.ipl.2013.01.016>",
            "Examples": "G=nx.Graph([(0,1),(1,4),(3,4),(3,5),(4,5)])\nlist(nx.chain_decomposition(G))\n# [[(4, 5), (5, 3), (3, 4)]]"
        }
    },
    {
        "Section ID": "strategy_connected_sequential",
        "Description": [
            "Returns an iterable over nodes in G in the order given by a\nbreadth-first or depth-first traversal.",
            "traversal must be one of the strings 'dfs' or 'bfs' ,\nrepresenting depth-first traversal or breadth-first traversal,\nrespectively.",
            "The generated sequence has the property that for each node except\nthe first, at least one neighbor appeared earlier in the sequence.",
            "G is a NetworkX graph. colors is ignored."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "draw",
        "Description": [
            "Draw the graph G with Matplotlib.",
            "Draw the graph as a simple representation with no node\nlabels or edge labels and using the full Matplotlib figure area\nand no axis labels by default.  See draw_networkx() for more\nfull-featured drawing that allows title, axis labels etc."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph",
                "pos : dictionary, optional": "A dictionary with nodes as keys and positions as values.\nIf not specified a spring layout positioning will be computed.\nSeenetworkx.drawing.layoutfor functions that\ncompute node positions.",
                "ax : Matplotlib Axes object, optional": "Draw the graph in specified Matplotlib axes.",
                "kwds : optional keywords": "See networkx.draw_networkx() for a description of optional keywords."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This function has the same name as pylab.draw and pyplot.draw\nso beware when using fromnetworkximport* since you might overwrite the pylab.draw function. With pyplot use",
            "Examples": "G=nx.dodecahedral_graph()\nnx.draw(G)\nnx.draw(G,pos=nx.spring_layout(G))# use spring layout"
        }
    },
    {
        "Section ID": "intersection",
        "Description": [
            "Returns a new graph that contains only the nodes and the edges that exist in\nboth G and H."
        ],
        "Field List": {
            "Parameters:": {
                "G,H : graph": "A NetworkX graph. G and H can have different node sets but must be both graphs or both multigraphs."
            },
            "Returns:": {
                "GH : A new graph with the same type as G.": ""
            },
            "Raises:": {
                "NetworkXError": "If one is a MultiGraph and the other one is a graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Attributes from the graph, nodes, and edges are not copied to the new\ngraph.  If you want a new graph of the intersection of G and H\nwith the attributes (including edge data) from G use remove_nodes_from()\nas follows",
            "Examples": "G=nx.Graph([(0,1),(0,2),(1,2)])\nH=nx.Graph([(0,3),(1,2),(2,3)])\nR=nx.intersection(G,H)\nR.nodes\n# NodeView((0, 1, 2))\nR.edges\n# EdgeView([(1, 2)])"
        }
    },
    {
        "Section ID": "k_edge_augmentation",
        "Description": [
            "Finds set of edges to k-edge-connect G.",
            "Adding edges from the augmentation to G make it impossible to disconnect G\nunless k or more edges are removed. This function uses the most efficient\nfunction available (depending on the value of k and if the problem is\nweighted or unweighted) to search for a minimum weight subset of available\nedges that k-edge-connects G. In general, finding a k-edge-augmentation is\nNP-hard, so solutions are not guaranteed to be minimal. Furthermore, a\nk-edge-augmentation may not exist."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "An undirected graph.",
                "k : integer": "Desired edge connectivity",
                "avail : dict or a set of 2 or 3 tuples": "The available edges that can be used in the augmentation.If unspecified, then all edges in the complement of G are available.\nOtherwise, each item is an available edge (with an optional weight).In the unweighted case, each item is an edge(u,v).In the weighted case, each item is a 3-tuple(u,v,d)or a dict\nwith items(u,v):d.  The third item,d, can be a dictionary\nor a real number.  Ifdis a dictionaryd[weight]correspondings to the weight.",
                "weight : string": "key to use to find weights ifavailis a set of 3-tuples where the\nthird item in each tuple is a dictionary.",
                "partial : boolean": "If partial is True and no feasible k-edge-augmentation exists, then all\na partial k-edge-augmentation is generated. Adding the edges in a\npartial augmentation to G, minimizes the number of k-edge-connected\ncomponents and maximizes the edge connectivity between those\ncomponents. For details, seepartial_k_edge_augmentation()."
            },
            "Yields:": {
                "edge : tuple": "Edges that, once added to G, would cause G to become k-edge-connected.\nIf partial is False, an error is raised if this is not possible.\nOtherwise, generated edges form a partial augmentation, which\nk-edge-connects any part of G where it is possible, and maximally\nconnects the remaining parts."
            },
            "Raises:": {
                "NetworkXUnfeasible": "If partial is False and no k-edge-augmentation exists.",
                "NetworkXNotImplemented": "If the input graph is directed or a multigraph.",
                "ValueError:": "If k is less than 1"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "When k=1 this returns an optimal solution. When k=2 and avail is None, this returns an optimal solution.\nOtherwise when k=2, this returns a 2-approximation of the optimal solution.",
            "Examples": "# Unweighted cases\nG=nx.path_graph((1,2,3,4))\nG.add_node(5)\nsorted(nx.k_edge_augmentation(G,k=1))\n# [(1, 5)]\nsorted(nx.k_edge_augmentation(G,k=2))\n# [(1, 5), (5, 4)]\nsorted(nx.k_edge_augmentation(G,k=3))\n# [(1, 4), (1, 5), (2, 5), (3, 5), (4, 5)]\ncomplement=list(nx.k_edge_augmentation(G,k=5,partial=True))\nG.add_edges_from(complement)\nnx.edge_connectivity(G)\n# 4\n# Weighted cases\nG=nx.path_graph((1,2,3,4))\nG.add_node(5)\n# avail can be a tuple with a dict\navail=[(1,5,{\"weight\":11}),(2,5,{\"weight\":10})]\nsorted(nx.k_edge_augmentation(G,k=1,avail=avail,weight=\"weight\"))\n# [(2, 5)]\n# or avail can be a 3-tuple with a real number\navail=[(1,5,11),(2,5,10),(4,3,1),(4,5,51)]\nsorted(nx.k_edge_augmentation(G,k=2,avail=avail))\n# [(1, 5), (2, 5), (4, 5)]\n# or avail can be a dict\navail={(1,5):11,(2,5):10,(4,3):1,(4,5):51}\nsorted(nx.k_edge_augmentation(G,k=2,avail=avail))\n# [(1, 5), (2, 5), (4, 5)]\n# If augmentation is infeasible, then a partial solution can be found\navail={(1,5):11}\nsorted(nx.k_edge_augmentation(G,k=2,avail=avail,partial=True))\n# [(1, 5)]"
        }
    },
    {
        "Section ID": "petersen_graph",
        "Description": [
            "Returns the Petersen graph.",
            "The Peterson graph is a cubic, undirected graph with 10 nodes and 15 edges [1] .\nJulius Petersen constructed the graph as the smallest counterexample\nagainst the claim that a connected bridgeless cubic graph\nhas an edge colouring with three colours [2] ."
        ],
        "Field List": {
            "Parameters:": {
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : networkx Graph": "Petersen graph"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://en.wikipedia.org/wiki/Petersen_graph  [2]https://www.win.tue.nl/~aeb/drg/graphs/Petersen.html"
        }
    },
    {
        "Section ID": "score_sequence",
        "Description": [
            "Returns the score sequence for the given tournament graph.",
            "The score sequence is the sorted list of the out-degrees of the\nnodes of the graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A directed graph representing a tournament."
            },
            "Returns:": {
                "list": "A sorted list of the out-degrees of the nodes ofG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.DiGraph([(1,0),(1,3),(0,2),(0,3),(2,1),(3,2)])\nnx.is_tournament(G)\n# True\nnx.tournament.score_sequence(G)\n# [1, 1, 2, 2]"
        }
    },
    {
        "Section ID": "clique_removal",
        "Description": [
            "Repeatedly remove cliques from the graph.",
            "Results in a \\(O(|V|/(\\log |V|)^2)\\) approximation of maximum clique\nand independent set. Returns the largest independent set found, along\nwith found maximal cliques."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected graph"
            },
            "Returns:": {
                "max_ind_cliques : (set, list) tuple": "2-tuple of Maximal Independent Set and list of maximal cliques (sets)."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the graph is directed or is a multigraph."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Boppana, R., & Halld\u00f3rsson, M. M. (1992).\nApproximating maximum independent sets by excluding subgraphs.\nBIT Numerical Mathematics, 32(2), 180\u2013196. Springer.",
            "Examples": "G=nx.path_graph(10)\nnx.approximation.clique_removal(G)\n# ({0, 2, 4, 6, 9}, [{0, 1}, {2, 3}, {4, 5}, {6, 7}, {8, 9}])"
        }
    },
    {
        "Section ID": "all_pairs_dijkstra",
        "Description": [
            "Find shortest weighted paths and lengths between all nodes."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "cutoff : integer or float, optional": "Length (sum of edge weights) at which the search is stopped.\nIf cutoff is provided, only return paths with summed weight <= cutoff.",
                "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edge[u][v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge."
            },
            "Yields:": {
                "(node, (distance, path)) : (node obj, (dict, dict))": "Each source node has two associated dicts. The first holds distance\nkeyed by target and the second holds paths keyed by target.\n(See single_source_dijkstra for the source/target node terminology.)\nIf desired you can applydict()to this function to create a dict\nkeyed by source node to the two dicts."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The yielded dicts only have keys for reachable nodes.",
            "Examples": "G=nx.path_graph(5)\nlen_path=dict(nx.all_pairs_dijkstra(G))\nlen_path[3][0][1]\n# 2\nfornodein[0,1,2,3,4]:\nprint(f\"3 - {node}: {len_path[3][0][node]}\")\n# 3 - 0: 3\n# 3 - 1: 2\n# 3 - 2: 1\n# 3 - 3: 0\n# 3 - 4: 1\nlen_path[3][1][1]\n# [3, 2, 1]\nforn,(dist,path)innx.all_pairs_dijkstra(G):\nprint(path[1])\n# [0, 1]\n# [1]\n# [2, 1]\n# [3, 2, 1]\n# [4, 3, 2, 1]"
        }
    },
    {
        "Section ID": "random_labeled_rooted_tree",
        "Description": [
            "Returns a labeled rooted tree with n nodes.",
            "The returned tree is chosen uniformly at random from all labeled rooted trees."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "networkx.Graph": "Anetworkx.Graphwith integer nodes 0 <= node <=n- 1.\nThe root of the tree is selected uniformly from the nodes.\nThe \u201croot\u201d graph attribute identifies the root of the tree."
            },
            "Raises:": {
                "NetworkXPointlessConcept": "Ifnis zero (because the null graph is not a tree)."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This function returns the result of random_labeled_tree() with a randomly selected root."
        }
    },
    {
        "Section ID": "maximum_spanning_tree",
        "Description": [
            "Returns a maximum spanning tree or forest on an undirected graph G ."
        ],
        "Field List": {
            "Parameters:": {
                "G : undirected graph": "An undirected graph. IfGis connected, then the algorithm finds a\nspanning tree. Otherwise, a spanning forest is found.",
                "weight : str": "Data key to use for edge weights.",
                "algorithm : string": "The algorithm to use when finding a maximum spanning tree. Valid\nchoices are \u2018kruskal\u2019, \u2018prim\u2019, or \u2018boruvka\u2019. The default is\n\u2018kruskal\u2019.",
                "ignore_nan : bool (default: False)": "If a NaN is found as an edge weight normally an exception is raised.\nIfignore_nanisTruethen that edge is ignored instead."
            },
            "Returns:": {
                "G : NetworkX Graph": "A maximum spanning tree or forest."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For Bor\u016fvka\u2019s algorithm, each edge must have a weight attribute, and\neach edge weight must be distinct. For the other algorithms, if the graph edges do not have a weight\nattribute a default weight of 1 will be used. There may be more than one tree with the same minimum or maximum weight.\nSee networkx.tree.recognition for more detailed definitions. Isolated nodes with self-loops are in the tree as edgeless isolated nodes.",
            "Examples": "G=nx.cycle_graph(4)\nG.add_edge(0,3,weight=2)\nT=nx.maximum_spanning_tree(G)\nsorted(T.edges(data=True))\n# [(0, 1, {}), (0, 3, {'weight': 2}), (1, 2, {})]"
        }
    },
    {
        "Section ID": "edge_dfs",
        "Description": [
            "A directed, depth-first-search of edges in G , beginning at source .",
            "Yield the edges of G in a depth-first-search order continuing until\nall edges are generated."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A directed/undirected graph/multigraph.",
                "source : node, list of nodes": "The node from which the traversal begins. If None, then a source\nis chosen arbitrarily and repeatedly until all edges from each node in\nthe graph are searched.",
                "orientation : None | \u2018original\u2019 | \u2018reverse\u2019 | \u2018ignore\u2019 (default: None)": "For directed graphs and directed multigraphs, edge traversals need not\nrespect the original orientation of the edges.\nWhen set to \u2018reverse\u2019 every edge is traversed in the reverse direction.\nWhen set to \u2018ignore\u2019, every edge is treated as undirected.\nWhen set to \u2018original\u2019, every edge is treated as directed.\nIn all three cases, the yielded edge tuples add a last entry to\nindicate the direction in which that edge was traversed.\nIf orientation is None, the yielded edge has no direction indicated.\nThe direction is respected, but not reported."
            },
            "Yields:": {
                "edge : directed edge": "A directed edge indicating the path taken by the depth-first traversal.\nFor graphs,edgeis of the form(u,v)whereuandvare the tail and head of the edge as determined by the traversal.\nFor multigraphs,edgeis of the form(u,v,key), wherekeyis\nthe key of the edge. When the graph is directed, thenuandvare always in the order of the actual directed edge.\nIf orientation is not None then the edge tuple is extended to include\nthe direction of traversal (\u2018forward\u2019 or \u2018reverse\u2019) on that edge."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The goal of this function is to visit edges. It differs from the more\nfamiliar depth-first traversal of nodes, as provided by dfs_edges() , in\nthat it does not stop once every node has been visited. In a directed graph\nwith edges [(0, 1), (1, 2), (2, 1)], the edge (2, 1) would not be visited\nif not for the functionality provided by this function.",
            "Examples": "nodes=[0,1,2,3]\nedges=[(0,1),(1,0),(1,0),(2,1),(3,1)]\nlist(nx.edge_dfs(nx.Graph(edges),nodes))\n# [(0, 1), (1, 2), (1, 3)]\nlist(nx.edge_dfs(nx.DiGraph(edges),nodes))\n# [(0, 1), (1, 0), (2, 1), (3, 1)]\nlist(nx.edge_dfs(nx.MultiGraph(edges),nodes))\n# [(0, 1, 0), (1, 0, 1), (0, 1, 2), (1, 2, 0), (1, 3, 0)]\nlist(nx.edge_dfs(nx.MultiDiGraph(edges),nodes))\n# [(0, 1, 0), (1, 0, 0), (1, 0, 1), (2, 1, 0), (3, 1, 0)]\nlist(nx.edge_dfs(nx.DiGraph(edges),nodes,orientation=\"ignore\"))\n# [(0, 1, 'forward'), (1, 0, 'forward'), (2, 1, 'reverse'), (3, 1, 'reverse')]\nlist(nx.edge_dfs(nx.MultiDiGraph(edges),nodes,orientation=\"ignore\"))\n# [(0, 1, 0, 'forward'), (1, 0, 0, 'forward'), (1, 0, 1, 'reverse'), (2, 1, 0, 'reverse'), (3, 1, 0, 'reverse')]"
        }
    },
    {
        "Section ID": "prefix_tree",
        "Description": [
            "Creates a directed prefix tree from a list of paths.",
            "Usually the paths are described as strings or lists of integers.",
            "A \u201cprefix tree\u201d represents the prefix structure of the strings.\nEach node represents a prefix of some string. The root represents\nthe empty prefix with children for the single letter prefixes which\nin turn have children for each double letter prefix starting with\nthe single letter corresponding to the parent node, and so on.",
            "More generally the prefixes do not need to be strings. A prefix refers\nto the start of a sequence. The root has children for each one element\nprefix and they have children for each two element prefix that starts\nwith the one element sequence of the parent, and so on.",
            "Note that this implementation uses integer nodes with an attribute.\nEach node has an attribute \u201csource\u201d whose value is the original element\nof the path to which this node corresponds. For example, suppose paths consists of one path: \u201ccan\u201d. Then the nodes [1,2,3] which represent\nthis path have \u201csource\u201d values \u201cc\u201d, \u201ca\u201d and \u201cn\u201d.",
            "All the descendants of a node have a common prefix in the sequence/path\nassociated with that node. From the returned tree, the prefix for each\nnode can be constructed by traversing the tree up to the root and\naccumulating the \u201csource\u201d values along the way.",
            "The root node is always 0 and has \u201csource\u201d attribute None .\nThe root is the only node with in-degree zero.\nThe nil node is always -1 and has \u201csource\u201d attribute \"NIL\" .\nThe nil node is the only node with out-degree zero."
        ],
        "Field List": {
            "Parameters:": {
                "paths: iterable of paths": "An iterable of paths which are themselves sequences.\nMatching prefixes among these sequences are identified with\nnodes of the prefix tree. One leaf of the tree is associated\nwith each path. (Identical paths are associated with the same\nleaf of the tree.)"
            },
            "Returns:": {
                "tree: DiGraph": "A directed graph representing an arborescence consisting of the\nprefix tree generated bypaths. Nodes are directed \u201cdownward\u201d,\nfrom parent to child. A special \u201csynthetic\u201d root node is added\nto be the parent of the first node in each path. A special\n\u201csynthetic\u201d leaf node, the \u201cnil\u201d node-1, is added to be the child\nof all nodes representing the last element in a path. (The\naddition of this nil node technically makes this not an\narborescence but a directed acyclic graph; removing the nil node\nmakes it an arborescence.)"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The prefix tree is also known as a trie .",
            "Examples": "Create a prefix tree from a list of strings with common prefixes:\npaths=[\"ab\",\"abs\",\"ad\"]\nT=nx.prefix_tree(paths)\nlist(T.edges)\n# [(0, 1), (1, 2), (1, 4), (2, -1), (2, 3), (3, -1), (4, -1)]\nThe leaf nodes can be obtained as predecessors of the nil node:\nroot,NIL=0,-1\nlist(T.predecessors(NIL))\n# [2, 3, 4]\nTo recover the original paths that generated the prefix tree,\ntraverse up the tree from the node-1to the node0:\nrecovered=[]\nforvinT.predecessors(NIL):\nprefix=\"\"\nwhilev!=root:\nprefix=str(T.nodes[v][\"source\"])+prefix\nv=next(T.predecessors(v))# only one predecessor\nrecovered.append(prefix)\nsorted(recovered)\n# ['ab', 'abs', 'ad']"
        }
    },
    {
        "Section ID": "non_edges",
        "Description": [
            "Returns the nonexistent edges in the graph."
        ],
        "Field List": {
            "Parameters:": {
                "graph : NetworkX graph.": "Graph to find nonexistent edges."
            },
            "Returns:": {
                "non_edges : iterator": "Iterator of edges that are not in the graph."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "hoffman_singleton_graph",
        "Description": [
            "Returns the Hoffman-Singleton Graph.",
            "The Hoffman\u2013Singleton graph is a symmetrical undirected graph\nwith 50 nodes and 175 edges.\nAll indices lie in Z%5 : that is, the integers mod 5 [1] .\nIt is the only regular graph of vertex degree 7, diameter 2, and girth 5.\nIt is the unique (7,5)-cage graph and Moore graph, and contains many\ncopies of the Petersen graph [2] ."
        ],
        "Field List": {
            "Returns:": {
                "G : networkx Graph": "Hoffman\u2013Singleton Graph with 50 nodes and 175 edges"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Constructed from pentagon and pentagram as follows: Take five pentagons \\(P_h\\) and five pentagrams \\(Q_i\\) . Join vertex \\(j\\) of \\(P_h\\) to vertex \\(h\u00b7i+j\\) of \\(Q_i\\)  [3] .",
            "References": "[1]https://blogs.ams.org/visualinsight/2016/02/01/hoffman-singleton-graph/  [2]https://mathworld.wolfram.com/Hoffman-SingletonGraph.html  [3]https://en.wikipedia.org/wiki/Hoffman%E2%80%93Singleton_graph"
        }
    },
    {
        "Section ID": "k_truss",
        "Description": [
            "Returns the k-truss of G .",
            "The k-truss is the maximal induced subgraph of G which contains at least\nthree vertices where every edge is incident to at least k-2 triangles."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "An undirected graph",
                "k : int": "The order of the truss"
            },
            "Returns:": {
                "H : NetworkX graph": "The k-truss subgraph"
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis a multigraph or directed graph or if it contains self loops."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "A k-clique is a (k-2)-truss and a k-truss is a (k+1)-core. Graph, node, and edge attributes are copied to the subgraph. K-trusses were originally defined in [2] which states that the k-truss\nis the maximal induced subgraph where each edge belongs to at least k-2 triangles. A more recent paper, [1], uses a slightly different\ndefinition requiring that each edge belong to at least k triangles.\nThis implementation uses the original definition of k-2 triangles.",
            "References": "[1]Bounds and Algorithms for k-truss. Paul Burkhardt, Vance Faber,\nDavid G. Harris, 2018.https://arxiv.org/abs/1806.05523v2  [2]Trusses: Cohesive Subgraphs for Social Network Analysis. Jonathan\nCohen, 2005.",
            "Examples": "degrees=[0,1,2,2,2,2,3]\nH=nx.havel_hakimi_graph(degrees)\nH.degree\n# DegreeView({0: 1, 1: 2, 2: 2, 3: 2, 4: 2, 5: 3, 6: 0})\nnx.k_truss(H,k=2).nodes\n# NodeView((0, 1, 2, 3, 4, 5))"
        }
    },
    {
        "Section ID": "is_k_regular",
        "Description": [
            "Determines whether the graph G is a k-regular graph.",
            "A k-regular graph is a graph where each vertex has degree k."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": ""
            },
            "Returns:": {
                "bool": "Whether the given graph is k-regular."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph([(1,2),(2,3),(3,4),(4,1)])\nnx.is_k_regular(G,k=3)\n# False"
        }
    },
    {
        "Section ID": "node_connected_component",
        "Description": [
            "Returns the set of nodes in the component of graph containing node n."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "An undirected graph.",
                "n : node label": "A node in G"
            },
            "Returns:": {
                "comp : set": "A set of nodes in the component of G containing node n."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is directed."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For undirected graphs only.",
            "Examples": "G=nx.Graph([(0,1),(1,2),(5,6),(3,4)])\nnx.node_connected_component(G,0)# nodes of component that contains node 0\n# {0, 1, 2}"
        }
    },
    {
        "Section ID": "floyd_warshall_predecessor_and_distance",
        "Description": [
            "Find all-pairs shortest path lengths using Floyd\u2019s algorithm."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "weight: string, optional (default= \u2018weight\u2019)": "Edge data key corresponding to the edge weight."
            },
            "Returns:": {
                "predecessor,distance : dictionaries": "Dictionaries, keyed by source and target, of predecessors and distances\nin the shortest path."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Floyd\u2019s algorithm is appropriate for finding shortest paths\nin dense graphs or graphs with negative weights when Dijkstra\u2019s algorithm\nfails.  This algorithm can still fail if there are negative cycles.\nIt has running time \\(O(n^3)\\) with running space of \\(O(n^2)\\) .",
            "Examples": "G=nx.DiGraph()\nG.add_weighted_edges_from(\n[\n(\"s\",\"u\",10),\n(\"s\",\"x\",5),\n(\"u\",\"v\",1),\n(\"u\",\"x\",2),\n(\"v\",\"y\",1),\n(\"x\",\"u\",3),\n(\"x\",\"v\",5),\n(\"x\",\"y\",2),\n(\"y\",\"s\",7),\n(\"y\",\"v\",6),\n]\n)\npredecessors,_=nx.floyd_warshall_predecessor_and_distance(G)\nprint(nx.reconstruct_path(\"s\",\"v\",predecessors))\n# ['s', 'x', 'u', 'v']"
        }
    },
    {
        "Section ID": "read_sparse6",
        "Description": [
            "Read an undirected graph in sparse6 format from path."
        ],
        "Field List": {
            "Parameters:": {
                "path : file or string": "File or filename to write."
            },
            "Returns:": {
                "G : Graph/Multigraph or list of Graphs/MultiGraphs": "If the file contains multiple lines then a list of graphs is returned"
            },
            "Raises:": {
                "NetworkXError": "If the string is unable to be parsed in sparse6 format"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Sparse6 specification\n<https://users.cecs.anu.edu.au/~bdm/data/formats.html>",
            "Examples": "You can read a sparse6 file by giving the path to the file:\nimporttempfile\nwithtempfile.NamedTemporaryFile(delete=False)asf:\n_=f.write(b\">>sparse6<<:An\\n\")\n_=f.seek(0)\nG=nx.read_sparse6(f.name)\nlist(G.edges())\n# [(0, 1)]\nYou can also read a sparse6 file by giving an open file-like object:\nimporttempfile\nwithtempfile.NamedTemporaryFile()asf:\n_=f.write(b\">>sparse6<<:An\\n\")\n_=f.seek(0)\nG=nx.read_sparse6(f)\nlist(G.edges())\n# [(0, 1)]"
        }
    },
    {
        "Section ID": "all_pairs_dijkstra_path_length",
        "Description": [
            "Compute shortest path lengths between all nodes in a weighted graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "cutoff : integer or float, optional": "Length (sum of edge weights) at which the search is stopped.\nIf cutoff is provided, only return paths with summed weight <= cutoff.",
                "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge."
            },
            "Returns:": {
                "distance : iterator": "(source, dictionary) iterator with dictionary keyed by target and\nshortest path length as the key value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The dictionary returned only has keys for reachable node pairs.",
            "Examples": "G=nx.path_graph(5)\nlength=dict(nx.all_pairs_dijkstra_path_length(G))\nfornodein[0,1,2,3,4]:\nprint(f\"1 - {node}: {length[1][node]}\")\n# 1 - 0: 1\n# 1 - 1: 0\n# 1 - 2: 1\n# 1 - 3: 2\n# 1 - 4: 3\nlength[3][2]\n# 1\nlength[2][2]\n# 0"
        }
    },
    {
        "Section ID": "MultiAdjacencyView",
        "Description": [
            "An MultiAdjacencyView is a Read-only Map of Maps of Maps of Maps.",
            "It is a View into a dict-of-dict-of-dict-of-dict data structure.\nThe inner level of dict is read-write. But the\nouter levels are read-only."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "is_matching",
        "Description": [
            "Return True if matching is a valid matching of G",
            "A matching in a graph is a set of edges in which no two distinct\nedges share a common endpoint. Each node is incident to at most one\nedge in the matching. The edges are said to be independent."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "matching : dict or set": "A dictionary or set representing a matching. If a dictionary, it\nmust havematching[u]==vandmatching[v]==ufor each\nedge(u,v)in the matching. If a set, it must have elements\nof the form(u,v), where(u,v)is an edge in the\nmatching."
            },
            "Returns:": {
                "bool": "Whether the given set or dictionary represents a valid matching\nin the graph."
            },
            "Raises:": {
                "NetworkXError": "If the proposed matching has an edge to a node not in G.\nOr if the matching is not a collection of 2-tuple edges."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph([(1,2),(1,3),(2,3),(2,4),(3,5),(4,5)])\nnx.is_maximal_matching(G,{1:3,2:4})# using dict to represent matching\n# True\nnx.is_matching(G,{(1,3),(2,4)})# using set to represent matching\n# True"
        }
    },
    {
        "Section ID": "degree_assortativity_coefficient",
        "Description": [
            "Compute degree assortativity of graph.",
            "Assortativity measures the similarity of connections\nin the graph with respect to the node degree."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "x: string (\u2018in\u2019,\u2019out\u2019)": "The degree type for source node (directed graphs only).",
                "y: string (\u2018in\u2019,\u2019out\u2019)": "The degree type for target node (directed graphs only).",
                "weight: string or None, optional (default=None)": "The edge attribute that holds the numerical value used\nas a weight.  If None, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node.",
                "nodes: list or iterable (optional)": "Compute degree assortativity only for nodes in container.\nThe default is all nodes."
            },
            "Returns:": {
                "r : float": "Assortativity of graph by degree."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This computes Eq. (21) in Ref. [1] , where e is the joint\nprobability distribution (mixing matrix) of the degrees.  If G is\ndirected than the matrix e is the joint probability of the\nuser-specified degree type for the source and target.",
            "References": "[1]M. E. J. Newman, Mixing patterns in networks,\nPhysical Review E, 67 026126, 2003  [2]Foster, J.G., Foster, D.V., Grassberger, P. & Paczuski, M.\nEdge direction and the structure of networks, PNAS 107, 10815-20 (2010).",
            "Examples": "G=nx.path_graph(4)\nr=nx.degree_assortativity_coefficient(G)\nprint(f\"{r:3.1f}\")\n# -0.5"
        }
    },
    {
        "Section ID": "jaccard_coefficient",
        "Description": [
            "Compute the Jaccard coefficient of all node pairs in ebunch.",
            "Jaccard coefficient of nodes u and v is defined as",
            "where \\(\\Gamma(u)\\) denotes the set of neighbors of \\(u\\) ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX undirected graph.",
                "ebunch : iterable of node pairs, optional (default = None)": "Jaccard coefficient will be computed for each pair of nodes\ngiven in the iterable. The pairs must be given as 2-tuples\n(u, v) where u and v are nodes in the graph. If ebunch is None\nthen all nonexistent edges in the graph will be used.\nDefault value: None."
            },
            "Returns:": {
                "piter : iterator": "An iterator of 3-tuples in the form (u, v, p) where (u, v) is a\npair of nodes and p is their Jaccard coefficient."
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis aDiGraph, aMultigraphor aMultiDiGraph.",
                "NodeNotFound": "Ifebunchhas a node that is not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]D. Liben-Nowell, J. Kleinberg.\nThe Link Prediction Problem for Social Networks (2004).http://www.cs.cornell.edu/home/kleinber/link-pred.pdf",
            "Examples": "G=nx.complete_graph(5)\npreds=nx.jaccard_coefficient(G,[(0,1),(2,3)])\nforu,v,pinpreds:\nprint(f\"({u}, {v}) -> {p:.8f}\")\n# (0, 1) -> 0.60000000\n# (2, 3) -> 0.60000000"
        }
    },
    {
        "Section ID": "random_internet_as_graph",
        "Description": [
            "Generates a random undirected graph resembling the Internet AS network"
        ],
        "Field List": {
            "Parameters:": {
                "n: integer in [1000, 10000]": "Number of graph nodes",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "G: Networkx Graph object": "A randomly generated undirected graph"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm returns an undirected graph resembling the Internet\nAutonomous System (AS) network, it uses the approach by Elmokashfi et al. [1] and it grants the properties described in the related paper [1] . Each node models an autonomous system, with an attribute \u2018type\u2019 specifying\nits kind; tier-1 (T), mid-level (M), customer (C) or content-provider (CP).\nEach edge models an ADV communication link (hence, bidirectional) with\nattributes:",
            "References": "[1](1,2)A. Elmokashfi, A. Kvalbein and C. Dovrolis, \u201cOn the Scalability of\nBGP: The Role of Topology Growth,\u201d in IEEE Journal on Selected Areas\nin Communications, vol. 28, no. 8, pp. 1250-1261, October 2010."
        }
    },
    {
        "Section ID": "eulerize",
        "Description": [
            "Transforms a graph into an Eulerian graph.",
            "If G is Eulerian the result is G as a MultiGraph, otherwise the result is a smallest\n(in terms of the number of edges) multigraph whose underlying simple graph is G ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "An undirected graph"
            },
            "Returns:": {
                "G : NetworkX multigraph": ""
            },
            "Raises:": {
                "NetworkXError": "If the graph is not connected."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]J. Edmonds, E. L. Johnson.\nMatching, Euler tours and the Chinese postman.\nMathematical programming, Volume 5, Issue 1 (1973), 111-114.  [2]https://en.wikipedia.org/wiki/Eulerian_path  [3]http://web.math.princeton.edu/math_alive/5/Notes1.pdf",
            "Examples": "G=nx.complete_graph(10)\nH=nx.eulerize(G)\nnx.is_eulerian(H)\n# True"
        }
    },
    {
        "Section ID": "min_maximal_matching",
        "Description": [
            "Returns the minimum maximal matching of G. That is, out of all maximal\nmatchings of the graph G, the smallest is returned."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected graph"
            },
            "Returns:": {
                "min_maximal_matching : set": "Returns a set of edges such that no two edges share a common endpoint\nand every edge not in the set shares some common endpoint in the set.\nCardinality will be 2*OPT in the worst case."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The algorithm computes an approximate solution for the minimum maximal\ncardinality matching problem. The solution is no more than 2 * OPT in size.\nRuntime is \\(O(|E|)\\) .",
            "References": "[1]Vazirani, Vijay Approximation Algorithms (2001)"
        }
    },
    {
        "Section ID": "to_agraph",
        "Description": [
            "Returns a pygraphviz graph from a NetworkX graph N."
        ],
        "Field List": {
            "Parameters:": {
                "N : NetworkX graph": "A graph created with NetworkX"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "If N has an dict N.graph_attr an attempt will be made first\nto copy properties attached to the graph (see from_agraph)\nand then updated with the calling arguments if any.",
            "Examples": "K5=nx.complete_graph(5)\nA=nx.nx_agraph.to_agraph(K5)"
        }
    },
    {
        "Section ID": "generate_gexf",
        "Description": [
            "Generate lines of GEXF format representation of G.",
            "\u201cGEXF (Graph Exchange XML Format) is a language for describing\ncomplex networks structures, their associated data and dynamics\u201d [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "",
                "A NetworkX graph": "",
                "encoding : string (optional, default: \u2018utf-8\u2019)": "",
                "Encoding for text data.": "",
                "prettyprint : bool (optional, default: True)": "",
                "If True use line breaks and indenting in output XML.": "",
                "version : string (default: 1.2draft)": "",
                "Version of GEFX File Format (see http://gexf.net/schema.html)": "",
                "Supported values: \u201c1.1draft\u201d, \u201c1.2draft\u201d": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This implementation does not support mixed graphs (directed and undirected\nedges together). The node id attribute is set to be the string of the node label.\nIf you want to specify an id use set it as node data, e.g.\nnode[\u2018a\u2019][\u2018id\u2019]=1 to set the id of node \u2018a\u2019 to 1.",
            "References": "[1]GEXF File Format,https://gephi.org/gexf/format/",
            "Examples": "G=nx.path_graph(4)\nlinefeed=chr(10)# linefeed=\ns=linefeed.join(nx.generate_gexf(G))\nforlineinnx.generate_gexf(G):\nprint(line)"
        }
    },
    {
        "Section ID": "asadpour_atsp",
        "Description": [
            "Returns an approximate solution to the traveling salesman problem.",
            "This approximate solution is one of the best known approximations for the\nasymmetric traveling salesman problem developed by Asadpour et al, [1] . The algorithm first solves the Held-Karp relaxation to find a lower\nbound for the weight of the cycle. Next, it constructs an exponential\ndistribution of undirected spanning trees where the probability of an\nedge being in the tree corresponds to the weight of that edge using a\nmaximum entropy rounding scheme. Next we sample that distribution \\(2 \\lceil \\ln n \\rceil\\) times and save the minimum sampled tree once the\ndirection of the arcs is added back to the edges. Finally, we augment\nthen short circuit that graph to find the approximate tour for the\nsalesman."
        ],
        "Field List": {
            "Parameters:": {
                "G : nx.DiGraph": "The graph should be a complete weighted directed graph. The\ndistance between all paris of nodes should be included and the triangle\ninequality should hold. That is, the direct edge between any two nodes\nshould be the path of least cost.",
                "weight : string, optional (default=\u201dweight\u201d)": "Edge data key corresponding to the edge weight.\nIf any edge does not have this attribute the weight is set to 1.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "source : node label (default=`None`)": "If given, return the cycle starting and ending at the given node."
            },
            "Returns:": {
                "cycle : list of nodes": "Returns the cycle (list of nodes) that a salesman can follow to minimize\nthe total weight of the trip."
            },
            "Raises:": {
                "NetworkXError": "Ifsourceis notNoneand is not a node inG, the algorithm raises\nan exception.",
                "NetworkXNotImplemented": "IfGis an undirected graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]A. Asadpour, M. X. Goemans, A. Madry, S. O. Gharan, and A. Saberi,\nAn o(log n/log log n)-approximation algorithm for the asymmetric\ntraveling salesman problem, Operations research, 65 (2017),\npp. 1043\u20131061",
            "Examples": "importnetworkxasnx\nimportnetworkx.algorithms.approximationasapprox\nG=nx.complete_graph(3,create_using=nx.DiGraph)\nnx.set_edge_attributes(\nG,{(0,1):2,(1,2):2,(2,0):2,(0,2):1,(2,1):1,(1,0):1},\"weight\"\n)\ntour=approx.asadpour_atsp(G,source=0)\ntour\n# [0, 2, 1, 0]"
        }
    },
    {
        "Section ID": "planar_layout",
        "Description": [
            "Position nodes without edge intersections."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph or list of nodes": "A position will be assigned to every node in G. If G is of type\nnx.PlanarEmbedding, the positions are selected accordingly.",
                "scale : number (default: 1)": "Scale factor for positions.",
                "center : array-like or None": "Coordinate pair around which to center the layout.",
                "dim : int": "Dimension of layout."
            },
            "Returns:": {
                "pos : dict": "A dictionary of positions keyed by node"
            },
            "Raises:": {
                "NetworkXException": "If G is not planar"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.path_graph(4)\npos=nx.planar_layout(G)"
        }
    },
    {
        "Section ID": "show_edges",
        "Description": [
            "Returns a filter function that shows specific undirected edges."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "literal_destringizer",
        "Description": [
            "Convert a Python literal to the value it represents."
        ],
        "Field List": {
            "Parameters:": {
                "rep : string": "A Python literal."
            },
            "Returns:": {
                "value : object": "The value of the Python literal."
            },
            "Raises:": {
                "ValueError": "Ifrepis not a Python literal."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "to_pandas_edgelist",
        "Description": [
            "Returns the graph edge list as a Pandas DataFrame."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "The NetworkX graph used to construct the Pandas DataFrame.",
                "source : str or int, optional": "A valid column name (string or integer) for the source nodes (for the\ndirected case).",
                "target : str or int, optional": "A valid column name (string or integer) for the target nodes (for the\ndirected case).",
                "nodelist : list, optional": "Use only nodes specified in nodelist",
                "dtype : dtype, default None": "Use to create the DataFrame. Data type to force.\nOnly a single dtype is allowed. If None, infer.",
                "edge_key : str or int or None, optional (default=None)": "A valid column name (string or integer) for the edge keys (for the\nmultigraph case). If None, edge keys are not stored in the DataFrame."
            },
            "Returns:": {
                "df : Pandas DataFrame": "Graph edge list"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph(\n[\n(\"A\",\"B\",{\"cost\":1,\"weight\":7}),\n(\"C\",\"E\",{\"cost\":9,\"weight\":10}),\n]\n)\ndf=nx.to_pandas_edgelist(G,nodelist=[\"A\",\"C\"])\ndf[[\"source\",\"target\",\"cost\",\"weight\"]]\n#   source target  cost  weight\n# 0      A      B     1       7\n# 1      C      E     9      10\nG=nx.MultiGraph([(\"A\",\"B\",{\"cost\":1}),(\"A\",\"B\",{\"cost\":9})])\ndf=nx.to_pandas_edgelist(G,nodelist=[\"A\",\"C\"],edge_key=\"ekey\")\ndf[[\"source\",\"target\",\"cost\",\"ekey\"]]\n#   source target  cost  ekey\n# 0      A      B     1     0\n# 1      A      B     9     1"
        }
    },
    {
        "Section ID": "ra_index_soundarajan_hopcroft",
        "Description": [
            "Compute the resource allocation index of all node pairs in\nebunch using community information.",
            "For two nodes \\(u\\) and \\(v\\) , this function computes the resource\nallocation index considering only common neighbors belonging to the\nsame community as \\(u\\) and \\(v\\) . Mathematically,",
            "where \\(f(w)\\) equals 1 if \\(w\\) belongs to the same community as \\(u\\) and \\(v\\) or 0 otherwise and \\(\\Gamma(u)\\) denotes the set of\nneighbors of \\(u\\) ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX undirected graph.",
                "ebunch : iterable of node pairs, optional (default = None)": "The score will be computed for each pair of nodes given in the\niterable. The pairs must be given as 2-tuples (u, v) where u\nand v are nodes in the graph. If ebunch is None then all\nnonexistent edges in the graph will be used.\nDefault value: None.",
                "community : string, optional (default = \u2018community\u2019)": "Nodes attribute name containing the community information.\nG[u][community] identifies which community u belongs to. Each\nnode belongs to at most one community. Default value: \u2018community\u2019."
            },
            "Returns:": {
                "piter : iterator": "An iterator of 3-tuples in the form (u, v, p) where (u, v) is a\npair of nodes and p is their score."
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis aDiGraph, aMultigraphor aMultiDiGraph.",
                "NetworkXAlgorithmError": "If no community information is available for a node inebunchor inG(ifebunchisNone).",
                "NodeNotFound": "Ifebunchhas a node that is not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Sucheta Soundarajan and John Hopcroft.\nUsing community information to improve the precision of link\nprediction methods.\nIn Proceedings of the 21st international conference companion on\nWorld Wide Web (WWW \u201812 Companion). ACM, New York, NY, USA, 607-608.http://doi.acm.org/10.1145/2187980.2188150",
            "Examples": "G=nx.Graph()\nG.add_edges_from([(0,1),(0,2),(1,3),(2,3)])\nG.nodes[0][\"community\"]=0\nG.nodes[1][\"community\"]=0\nG.nodes[2][\"community\"]=1\nG.nodes[3][\"community\"]=0\npreds=nx.ra_index_soundarajan_hopcroft(G,[(0,3)])\nforu,v,pinpreds:\nprint(f\"({u}, {v}) -> {p:.8f}\")\n# (0, 3) -> 0.50000000"
        }
    },
    {
        "Section ID": "cd_index",
        "Description": [
            "Compute the CD index for node within the graph G .",
            "Calculates the CD index for the given node of the graph,\nconsidering only its predecessors who have the time attribute\nsmaller than or equal to the time attribute of the node plus time_delta ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A directed networkx graph whose nodes havetimeattributes and optionallyweightattributes (if a weight is not given, it is considered 1).",
                "node : node": "The node for which the CD index is calculated.",
                "time_delta : numeric or timedelta": "Amount of time after thetimeattribute of thenode. The value oftime_deltamust support comparison with thetimenode attribute. For\nexample, if thetimeattribute of the nodes aredatetime.datetimeobjects, thentime_deltashould be adatetime.timedeltaobject.",
                "time : string (Optional, default is \u201ctime\u201d)": "The name of the node attribute that will be used for the calculations.",
                "weight : string (Optional, default is None)": "The name of the node attribute used as weight."
            },
            "Returns:": {
                "float": "The CD index calculated for the nodenodewithin the graphG."
            },
            "Raises:": {
                "NetworkXError": "If not all nodes have atimeattribute ortime_deltaandtimeattribute types are not compatible ornequals 0.",
                "NetworkXNotImplemented": "IfGis a non-directed graph or a multigraph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This method implements the algorithm for calculating the CD index,\nas described in the paper by Funk and Owen-Smith [1] . The CD index\nis used in order to check how consolidating or destabilizing a patent\nis, hence the nodes of the graph represent patents and the edges show\nthe citations between these patents. The mathematical model is given\nbelow:",
            "References": "[1]Funk, Russell J., and Jason Owen-Smith.\n\u201cA dynamic network measure of technological change.\u201d\nManagement science 63, no. 3 (2017): 791-817.http://russellfunk.org/cdindex/static/papers/funk_ms_2017.pdf",
            "Examples": "fromdatetimeimportdatetime,timedelta\nG=nx.DiGraph()\nnodes={\n1:{\"time\":datetime(2015,1,1)},\n2:{\"time\":datetime(2012,1,1),\"weight\":4},\n3:{\"time\":datetime(2010,1,1)},\n4:{\"time\":datetime(2008,1,1)},\n5:{\"time\":datetime(2014,1,1)},\n}\nG.add_nodes_from([(n,nodes[n])forninnodes])\nedges=[(1,3),(1,4),(2,3),(3,4),(3,5)]\nG.add_edges_from(edges)\ndelta=timedelta(days=5*365)\nnx.cd_index(G,3,time_delta=delta,time=\"time\")\n# 0.5\nnx.cd_index(G,3,time_delta=delta,time=\"time\",weight=\"weight\")\n# 0.12\nIntegers can also be used for the time values:\n>>> node_times = {1: 2015, 2: 2012, 3: 2010, 4: 2008, 5: 2014}\n>>> nx.set_node_attributes(G, node_times, \u201cnew_time\u201d)\n>>> nx.cd_index(G, 3, time_delta=4, time=\u201dnew_time\u201d)\n0.5\n>>> nx.cd_index(G, 3, time_delta=4, time=\u201dnew_time\u201d, weight=\u201dweight\u201d)\n0.12"
        }
    },
    {
        "Section ID": "hnm_harary_graph",
        "Description": [
            "Returns the Harary graph with given numbers of nodes and edges.",
            "The Harary graph \\(H_{n,m}\\) is the graph that maximizes node connectivity\nwith \\(n\\) nodes and \\(m\\) edges.",
            "This maximum node connectivity is known to be floor( \\(2m/n\\) ). [1]"
        ],
        "Field List": {
            "Parameters:": {
                "n: integer": "The number of nodes the generated graph is to contain",
                "m: integer": "The number of edges the generated graph is to contain",
                "create_using : NetworkX graph constructor, optional Graph type": "to create (default=nx.Graph). If graph instance, then cleared\nbefore populated."
            },
            "Returns:": {
                "NetworkX graph": "The Harary graph\\(H_{n,m}\\)."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm runs in \\(O(m)\\) time.\nIt is implemented by following the Reference [2] .",
            "References": "[1]F. T. Boesch, A. Satyanarayana, and C. L. Suffel,\n\u201cA Survey of Some Network Reliability Analysis and Synthesis Results,\u201d\nNetworks, pp. 99-107, 2009.  [2]Harary, F. \u201cThe Maximum Connectivity of a Graph.\u201d\nProc. Nat. Acad. Sci. USA 48, 1142-1146, 1962."
        }
    },
    {
        "Section ID": "draw_shell",
        "Description": [
            "Draw networkx graph G with shell layout.",
            "This is a convenience function equivalent to:"
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph",
                "nlist : list of list of nodes, optional": "A list containing lists of nodes representing the shells.\nDefault isNone, meaning all nodes are in a single shell.\nSeeshell_layoutfor details.",
                "kwargs : optional keywords": "Seedraw_networkxfor a description of optional keywords."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The layout is computed each time this function is called.\nFor repeated drawing it is much more efficient to call shell_layout directly and reuse the result:",
            "Examples": "G=nx.path_graph(4)\nshells=[[0],[1,2,3]]\nnx.draw_shell(G,nlist=shells)"
        }
    },
    {
        "Section ID": "hypercube_graph",
        "Description": [
            "Returns the n -dimensional hypercube graph.",
            "The nodes are the integers between 0 and 2**n-1 , inclusive.",
            "For more information on the hypercube graph, see the Wikipedia\narticle Hypercube graph ."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The dimension of the hypercube.\nThe number of nodes in the graph will be2**n."
            },
            "Returns:": {
                "NetworkX graph": "The hypercube graph of dimensionn."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "dorogovtsev_goltsev_mendes_graph",
        "Description": [
            "Returns the hierarchically constructed Dorogovtsev-Goltsev-Mendes graph.",
            "The Dorogovtsev-Goltsev-Mendes [1] procedure produces a scale-free graph\ndeterministically with the following properties for a given n :\n- Total number of nodes = 3*(3**n+1)/2 - Total number of edges = 3**(n+1)",
            "( Sourcecode , png )"
        ],
        "Field List": {
            "Parameters:": {
                "n : integer": "The generation number.",
                "create_using : NetworkX Graph, optional": "Graph type to be returned. Directed graphs and multi graphs are not\nsupported."
            },
            "Returns:": {
                "G : NetworkX Graph": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]S. N. Dorogovtsev, A. V. Goltsev and J. F. F. Mendes,\n\u201cPseudofractal scale-free web\u201d, Physical Review E 65, 066122, 2002.https://arxiv.org/pdf/cond-mat/0112143.pdf",
            "Examples": "G=nx.dorogovtsev_goltsev_mendes_graph(3)\nG.number_of_nodes()\n# 15\nG.number_of_edges()\n# 27\nnx.is_planar(G)\n# True"
        }
    },
    {
        "Section ID": "stochastic_block_model",
        "Description": [
            "Returns a stochastic block model graph.",
            "This model partitions the nodes in blocks of arbitrary sizes, and places\nedges between pairs of nodes independently, with a probability that depends\non the blocks."
        ],
        "Field List": {
            "Parameters:": {
                "sizes : list of ints": "Sizes of blocks",
                "p : list of list of floats": "Element (r,s) gives the density of edges going from the nodes\nof group r to nodes of group s.\np must match the number of groups (len(sizes) == len(p)),\nand it must be symmetric if the graph is undirected.",
                "nodelist : list, optional": "The block tags are assigned according to the node identifiers\nin nodelist. If nodelist is None, then the ordering is the\nrange [0,sum(sizes)-1].",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "directed : boolean optional, default=False": "Whether to create a directed graph or not.",
                "selfloops : boolean optional, default=False": "Whether to include self-loops or not.",
                "sparse: boolean optional, default=True": "Use the sparse heuristic to speed up the generator."
            },
            "Returns:": {
                "g : NetworkX Graph or DiGraph": "Stochastic block model graph of size sum(sizes)"
            },
            "Raises:": {
                "NetworkXError": "If probabilities are not in [0,1].\nIf the probability matrix is not square (directed case).\nIf the probability matrix is not symmetric (undirected case).\nIf the sizes list does not match nodelist or the probability matrix.\nIf nodelist contains duplicate."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Holland, P. W., Laskey, K. B., & Leinhardt, S.,\n\u201cStochastic blockmodels: First steps\u201d,\nSocial networks, 5(2), 109-137, 1983.",
            "Examples": "sizes=[75,75,300]\nprobs=[[0.25,0.05,0.02],[0.05,0.35,0.07],[0.02,0.07,0.40]]\ng=nx.stochastic_block_model(sizes,probs,seed=0)\nlen(g)\n# 450\nH=nx.quotient_graph(g,g.graph[\"partition\"],relabel=True)\nforvinH.nodes(data=True):\nprint(round(v[1][\"density\"],3))\n# 0.245\n# 0.348\n# 0.405\nforvinH.edges(data=True):\nprint(round(1.0*v[2][\"weight\"]/(sizes[v[0]]*sizes[v[1]]),3))\n# 0.051\n# 0.022\n# 0.07"
        }
    },
    {
        "Section ID": "strategy_connected_sequential_dfs",
        "Description": [
            "Returns an iterable over nodes in G in the order given by a\ndepth-first traversal.",
            "The generated sequence has the property that for each node except\nthe first, at least one neighbor appeared earlier in the sequence.",
            "G is a NetworkX graph. colors is ignored."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "literal_stringizer",
        "Description": [
            "Convert a value to a Python literal in GML representation."
        ],
        "Field List": {
            "Parameters:": {
                "value : object": "Thevalueto be converted to GML representation."
            },
            "Returns:": {
                "rep : string": "A double-quoted Python literal representing value. Unprintable\ncharacters are replaced by XML character references."
            },
            "Raises:": {
                "ValueError": "Ifvaluecannot be converted to GML."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The original value can be recovered using the networkx.readwrite.gml.literal_destringizer() function."
        }
    },
    {
        "Section ID": "single_source_bellman_ford_path",
        "Description": [
            "Compute shortest path between source and all other reachable\nnodes for a weighted graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node": "Starting node for path.",
                "weight : string or function (default=\u201dweight\u201d)": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number."
            },
            "Returns:": {
                "paths : dictionary": "Dictionary of shortest path lengths keyed by target."
            },
            "Raises:": {
                "NodeNotFound": "Ifsourceis not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.",
            "Examples": "G=nx.path_graph(5)\npath=nx.single_source_bellman_ford_path(G,0)\npath[4]\n# [0, 1, 2, 3, 4]"
        }
    },
    {
        "Section ID": "diamond_graph",
        "Description": [
            "Returns the Diamond graph",
            "The Diamond Graph is  planar undirected graph with 4 nodes and 5 edges.\nIt is also sometimes known as the double triangle graph or kite graph [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : networkx Graph": "Diamond Graph with 4 nodes and 5 edges"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://mathworld.wolfram.com/DiamondGraph.html"
        }
    },
    {
        "Section ID": "generate_gml",
        "Description": [
            "Generate a single entry of the graph G in GML format."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "The graph to be converted to GML.",
                "stringizer : callable, optional": "Astringizerwhich converts non-int/non-float/non-dict values into\nstrings. If it cannot convert a value into a string, it should raise aValueErrorto indicate that. Default value: None."
            },
            "Returns:": {
                "lines: generator of strings": "Lines of GML data. Newlines are not appended."
            },
            "Raises:": {
                "NetworkXError": "Ifstringizercannot convert a value into a string, or the value to\nconvert is not a string whilestringizeris None."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Graph attributes named \u2018directed\u2019, \u2018multigraph\u2019, \u2018node\u2019 or\n\u2018edge\u2019, node attributes named \u2018id\u2019 or \u2018label\u2019, edge attributes\nnamed \u2018source\u2019 or \u2018target\u2019 (or \u2018key\u2019 if G is a multigraph)\nare ignored because these attribute names are used to encode the graph\nstructure. GML files are stored using a 7-bit ASCII encoding with any extended\nASCII characters (iso8859-1) appearing as HTML character entities.\nWithout specifying a stringizer / destringizer , the code is capable of\nwriting int / float / str / dict / list data as required by the GML\nspecification.  For writing other data types, and for reading data other\nthan str you need to explicitly supply a stringizer / destringizer . For additional documentation on the GML file format, please see the GML url . See the module docstring networkx.readwrite.gml for more details.",
            "Examples": "G=nx.Graph()\nG.add_node(\"1\")\nprint(\"\\n\".join(nx.generate_gml(G)))\n# graph [\n#   node [\n#     id 0\n#     label \"1\"\n#   ]\n# ]\nG=nx.MultiGraph([(\"a\",\"b\"),(\"a\",\"b\")])\nprint(\"\\n\".join(nx.generate_gml(G)))\n# graph [\n#   multigraph 1\n#   node [\n#     id 0\n#     label \"a\"\n#   ]\n#   node [\n#     id 1\n#     label \"b\"\n#   ]\n#   edge [\n#     source 0\n#     target 1\n#     key 0\n#   ]\n#   edge [\n#     source 0\n#     target 1\n#     key 1\n#   ]\n# ]"
        }
    },
    {
        "Section ID": "is_valid_joint_degree",
        "Description": [
            "Checks whether the given joint degree dictionary is realizable.",
            "A joint degree dictionary is a dictionary of dictionaries, in\nwhich entry joint_degrees[k][l] is an integer representing the\nnumber of edges joining nodes of degree k with nodes of degree l . Such a dictionary is realizable as a simple graph if and only\nif the following conditions are satisfied."
        ],
        "Field List": {
            "Parameters:": {
                "joint_degrees : dictionary of dictionary of integers": "A joint degree dictionary in which entryjoint_degrees[k][l]is the number of edges joining nodes of degreekwith nodes of\ndegreel."
            },
            "Returns:": {
                "bool": "Whether the given joint degree dictionary is realizable as a\nsimple graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]M. Gjoka, M. Kurant, A. Markopoulou, \u201c2.5K Graphs: from Sampling\nto Generation\u201d, IEEE Infocom, 2013.  [2]I. Stanton, A. Pinar, \u201cConstructing and sampling graphs with a\nprescribed joint degree distribution\u201d, Journal of Experimental\nAlgorithmics, 2012."
        }
    },
    {
        "Section ID": "fiedler_vector",
        "Description": [
            "Returns the Fiedler vector of a connected undirected graph.",
            "The Fiedler vector of a connected undirected graph is the eigenvector\ncorresponding to the second smallest eigenvalue of the Laplacian matrix\nof the graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "An undirected graph.",
                "weight : object, optional (default: None)": "The data key used to determine the weight of each edge. If None, then\neach edge has unit weight.",
                "normalized : bool, optional (default: False)": "Whether the normalized Laplacian matrix is used.",
                "tol : float, optional (default: 1e-8)": "Tolerance of relative residual in eigenvalue computation.",
                "method : string, optional (default: \u2018tracemin_pcg\u2019)": "Method of eigenvalue computation. It must be one of the tracemin\noptions shown below (TraceMIN), \u2018lanczos\u2019 (Lanczos iteration)\nor \u2018lobpcg\u2019 (LOBPCG).The TraceMIN algorithm uses a linear system solver. The following\nvalues allow specifying the solver to be used.ValueSolver\u2018tracemin_pcg\u2019Preconditioned conjugate gradient method\u2018tracemin_lu\u2019LU factorization",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "fiedler_vector : NumPy array of floats.": "Fiedler vector."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is directed.",
                "NetworkXError": "If G has less than two nodes or is not connected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weights are interpreted by their absolute values. For MultiGraph\u2019s,\nweights of parallel edges are summed. Zero-weighted edges are ignored.",
            "Examples": "Given a connected graph the signs of the values in the Fiedler vector can be\nused to partition the graph into two components.\nG=nx.barbell_graph(5,0)\nnx.fiedler_vector(G,normalized=True,seed=1)\n# array([-0.32864129, -0.32864129, -0.32864129, -0.32864129, -0.26072899,\n#         0.26072899,  0.32864129,  0.32864129,  0.32864129,  0.32864129])\nThe connected components are the two 5-node cliques of the barbell graph."
        }
    },
    {
        "Section ID": "global_parameters",
        "Description": [
            "Returns global parameters for a given intersection array.",
            "Given a distance-regular graph G with integers b_i, c_i,i = 0,\u2026.,d\nsuch that for any 2 vertices x,y in G at a distance i=d(x,y), there\nare exactly c_i neighbors of y at a distance of i-1 from x and b_i\nneighbors of y at a distance of i+1 from x.",
            "Thus, a distance regular graph has the global parameters,\n[[c_0,a_0,b_0],[c_1,a_1,b_1],\u2026\u2026,[c_d,a_d,b_d]] for the\nintersection array  [b_0,b_1,\u2026..b_{d-1};c_1,c_2,\u2026..c_d]\nwhere a_i+b_i+c_i=k , k= degree of every vertex."
        ],
        "Field List": {
            "Parameters:": {
                "b : list": "",
                "c : list": ""
            },
            "Returns:": {
                "iterable": "An iterable over three tuples."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Weisstein, Eric W. \u201cGlobal Parameters.\u201d\nFrom MathWorld\u2013A Wolfram Web Resource.http://mathworld.wolfram.com/GlobalParameters.html",
            "Examples": "G=nx.dodecahedral_graph()\nb,c=nx.intersection_array(G)\nlist(nx.global_parameters(b,c))\n# [(0, 0, 3), (1, 0, 2), (1, 1, 1), (1, 1, 1), (2, 0, 1), (3, 0, 0)]"
        }
    },
    {
        "Section ID": "from_agraph",
        "Description": [
            "Returns a NetworkX Graph or DiGraph from a PyGraphviz graph."
        ],
        "Field List": {
            "Parameters:": {
                "A : PyGraphviz AGraph": "A graph created with PyGraphviz",
                "create_using : NetworkX graph constructor, optional (default=None)": "Graph type to create. If graph instance, then cleared before populated.\nIfNone, then the appropriate Graph type is inferred fromA."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The Graph G will have a dictionary G.graph_attr containing\nthe default graphviz attributes for graphs, nodes and edges. Default node attributes will be in the dictionary G.node_attr\nwhich is keyed by node. Edge attributes will be returned as edge data in G.  With\nedge_attr=False the edge data will be the Graphviz edge weight\nattribute or the value 1 if no edge weight attribute is found.",
            "Examples": "K5=nx.complete_graph(5)\nA=nx.nx_agraph.to_agraph(K5)\nG=nx.nx_agraph.from_agraph(A)"
        }
    },
    {
        "Section ID": "all_pairs_shortest_path_length",
        "Description": [
            "Computes the shortest path lengths between all nodes in G ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "cutoff : integer, optional": "Depth at which to stop the search. Only paths of length at mostcutoffare returned."
            },
            "Returns:": {
                "lengths : iterator": "(source, dictionary) iterator with dictionary keyed by target and\nshortest path length as the key value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The iterator returned only has reachable node pairs.",
            "Examples": "G=nx.path_graph(5)\nlength=dict(nx.all_pairs_shortest_path_length(G))\nfornodein[0,1,2,3,4]:\nprint(f\"1 - {node}: {length[1][node]}\")\n# 1 - 0: 1\n# 1 - 1: 0\n# 1 - 2: 1\n# 1 - 3: 2\n# 1 - 4: 3\nlength[3][2]\n# 1\nlength[2][2]\n# 0"
        }
    },
    {
        "Section ID": "topological_sort",
        "Description": [
            "Returns a generator of nodes in topologically sorted order.",
            "A topological sort is a nonunique permutation of the nodes of a\ndirected graph such that an edge from u to v implies that u\nappears before v in the topological sort order. This ordering is\nvalid only if the graph has no directed cycles."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX digraph": "A directed acyclic graph (DAG)"
            },
            "Yields:": {
                "nodes": "Yields the nodes in topological sorted order."
            },
            "Raises:": {
                "NetworkXError": "Topological sort is defined for directed graphs only. If the graphGis undirected, aNetworkXErroris raised.",
                "NetworkXUnfeasible": "IfGis not a directed acyclic graph (DAG) no topological sort exists\nand aNetworkXUnfeasibleexception is raised.  This can also be\nraised ifGis changed while the returned iterator is being processed",
                "RuntimeError": "IfGis changed while the returned iterator is being processed."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm is based on a description and proof in\n\u201cIntroduction to Algorithms: A Creative Approach\u201d [1] .",
            "References": "[1]Manber, U. (1989).Introduction to Algorithms - A Creative Approach.Addison-Wesley.",
            "Examples": "To get the reverse order of the topological sort:\nDG=nx.DiGraph([(1,2),(2,3)])\nlist(reversed(list(nx.topological_sort(DG))))\n# [3, 2, 1]\nIf your DiGraph naturally has the edges representing tasks/inputs\nand nodes representing people/processes that initiate tasks, then\ntopological_sort is not quite what you need. You will have to change\nthe tasks to nodes with dependence reflected by edges. The result is\na kind of topological sort of the edges. This can be done\nwithnetworkx.line_graph()as follows:\nlist(nx.topological_sort(nx.line_graph(DG)))\n# [(1, 2), (2, 3)]"
        }
    },
    {
        "Section ID": "hkn_harary_graph",
        "Description": [
            "Returns the Harary graph with given node connectivity and node number.",
            "The Harary graph \\(H_{k,n}\\) is the graph that minimizes the number of\nedges needed with given node connectivity \\(k\\) and node number \\(n\\) .",
            "This smallest number of edges is known to be ceil( \\(kn/2\\) ) [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "k: integer": "The node connectivity of the generated graph",
                "n: integer": "The number of nodes the generated graph is to contain",
                "create_using : NetworkX graph constructor, optional Graph type": "to create (default=nx.Graph). If graph instance, then cleared\nbefore populated."
            },
            "Returns:": {
                "NetworkX graph": "The Harary graph\\(H_{k,n}\\)."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm runs in \\(O(kn)\\) time.\nIt is implemented by following the Reference [2] .",
            "References": "[1]Weisstein, Eric W. \u201cHarary Graph.\u201d From MathWorld\u2013A Wolfram Web\nResource.http://mathworld.wolfram.com/HararyGraph.html.  [2]Harary, F. \u201cThe Maximum Connectivity of a Graph.\u201d\nProc. Nat. Acad. Sci. USA 48, 1142-1146, 1962."
        }
    },
    {
        "Section ID": "s_metric",
        "Description": [
            "Returns the s-metric [1] of graph.",
            "The s-metric is defined as the sum of the products deg(u)*deg(v) for every edge (u,v) in G ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "The graph used to compute the s-metric.",
                "normalized : bool (optional)": "Normalize the value.Deprecated since version 3.2:Thenormalizedkeyword argument is deprecated and will be removed\nin the future"
            },
            "Returns:": {
                "s : float": "The s-metric of the graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Lun Li, David Alderson, John C. Doyle, and Walter Willinger,\nTowards a Theory of Scale-Free Graphs:\nDefinition, Properties, and  Implications (Extended Version), 2005.https://arxiv.org/abs/cond-mat/0501169"
        }
    },
    {
        "Section ID": "vf2pp_isomorphism",
        "Description": [
            "Return an isomorphic mapping between G1 and G2 if it exists."
        ],
        "Field List": {
            "Parameters:": {
                "G1, G2 : NetworkX Graph or MultiGraph instances.": "The two graphs to check for isomorphism.",
                "node_label : str, optional": "The name of the node attribute to be used when comparing nodes.\nThe default isNone, meaning node attributes are not considered\nin the comparison. Any node that doesn\u2019t have thenode_labelattribute usesdefault_labelinstead.",
                "default_label : scalar": "Default value to use when a node doesn\u2019t have an attribute\nnamednode_label. Default isNone."
            },
            "Returns:": {
                "dict or None": "Node mapping if the two graphs are isomorphic. None otherwise."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "katz_centrality",
        "Description": [
            "Compute the Katz centrality for the nodes of the graph G.",
            "Katz centrality computes the centrality for a node based on the centrality\nof its neighbors. It is a generalization of the eigenvector centrality. The\nKatz centrality for node \\(i\\) is",
            "where \\(A\\) is the adjacency matrix of graph G with eigenvalues \\(\\lambda\\) .",
            "The parameter \\(\\beta\\) controls the initial centrality and",
            "Katz centrality computes the relative influence of a node within a\nnetwork by measuring the number of the immediate neighbors (first\ndegree nodes) and also all other nodes in the network that connect\nto the node under consideration through these immediate neighbors.",
            "Extra weight can be provided to immediate neighbors through the\nparameter \\(\\beta\\) .  Connections made with distant neighbors\nare, however, penalized by an attenuation factor \\(\\alpha\\) which\nshould be strictly less than the inverse largest eigenvalue of the\nadjacency matrix in order for the Katz centrality to be computed\ncorrectly. More information is provided in [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.",
                "alpha : float, optional (default=0.1)": "Attenuation factor",
                "beta : scalar or dictionary, optional (default=1.0)": "Weight attributed to the immediate neighborhood. If not a scalar, the\ndictionary must have a value for every node.",
                "max_iter : integer, optional (default=1000)": "Maximum number of iterations in power method.",
                "tol : float, optional (default=1.0e-6)": "Error tolerance used to check convergence in power method iteration.",
                "nstart : dictionary, optional": "Starting value of Katz iteration for each node.",
                "normalized : bool, optional (default=True)": "If True normalize the resulting values.",
                "weight : None or string, optional (default=None)": "If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight.\nIn this measure the weight is interpreted as the connection strength."
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of nodes with Katz centrality as the value."
            },
            "Raises:": {
                "NetworkXError": "If the parameterbetais not a scalar but lacks a value for at least\none node",
                "PowerIterationFailedConvergence": "If the algorithm fails to converge to the specified tolerance\nwithin the specified number of iterations of the power iteration\nmethod."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Katz centrality was introduced by [2] . This algorithm it uses the power method to find the eigenvector\ncorresponding to the largest eigenvalue of the adjacency matrix of G .\nThe parameter alpha should be strictly less than the inverse of largest\neigenvalue of the adjacency matrix for the algorithm to converge.\nYou can use max(nx.adjacency_spectrum(G)) to get \\(\\lambda_{\\max}\\) the largest\neigenvalue of the adjacency matrix.\nThe iteration will stop after max_iter iterations or an error tolerance of number_of_nodes(G)*tol has been reached. For strongly connected graphs, as \\(\\alpha \\to 1/\\lambda_{\\max}\\) , and \\(\\beta > 0\\) ,\nKatz centrality approaches the results for eigenvector centrality. For directed graphs this finds \u201cleft\u201d eigenvectors which corresponds\nto the in-edges in the graph. For out-edges Katz centrality,\nfirst reverse the graph with G.reverse() .",
            "References": "[1]Mark E. J. Newman:\nNetworks: An Introduction.\nOxford University Press, USA, 2010, p. 720.  [2]Leo Katz:\nA New Status Index Derived from Sociometric Index.\nPsychometrika 18(1):39\u201343, 1953https://link.springer.com/content/pdf/10.1007/BF02289026.pdf",
            "Examples": "importmath\nG=nx.path_graph(4)\nphi=(1+math.sqrt(5))/2.0# largest eigenvalue of adj matrix\ncentrality=nx.katz_centrality(G,1/phi-0.01)\nforn,cinsorted(centrality.items()):\nprint(f\"{n} {c:.2f}\")\n# 0 0.37\n# 1 0.60\n# 2 0.60\n# 3 0.37"
        }
    },
    {
        "Section ID": "network_simplex",
        "Description": [
            "Find a minimum cost flow satisfying all demands in digraph G.",
            "This is a primal network simplex algorithm that uses the leaving\narc rule to prevent cycling.",
            "G is a digraph with edge costs and capacities and in which nodes\nhave demand, i.e., they want to send or receive some amount of\nflow. A negative demand means that the node wants to send flow, a\npositive demand means that the node want to receive flow. A flow on\nthe digraph G satisfies all demand if the net flow into each node\nis equal to the demand of that node."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "DiGraph on which a minimum cost flow satisfying all demands is\nto be found.",
                "demand : string": "Nodes of the graph G are expected to have an attribute demand\nthat indicates how much flow a node wants to send (negative\ndemand) or receive (positive demand). Note that the sum of the\ndemands should be 0 otherwise the problem in not feasible. If\nthis attribute is not present, a node is considered to have 0\ndemand. Default value: \u2018demand\u2019.",
                "capacity : string": "Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: \u2018capacity\u2019.",
                "weight : string": "Edges of the graph G are expected to have an attribute weight\nthat indicates the cost incurred by sending one unit of flow on\nthat edge. If not present, the weight is considered to be 0.\nDefault value: \u2018weight\u2019."
            },
            "Returns:": {
                "flowCost : integer, float": "Cost of a minimum cost flow satisfying all demands.",
                "flowDict : dictionary": "Dictionary of dictionaries keyed by nodes such that\nflowDict[u][v] is the flow edge (u, v)."
            },
            "Raises:": {
                "NetworkXError": "This exception is raised if the input graph is not directed or\nnot connected.",
                "NetworkXUnfeasible": "This exception is raised in the following situations:The sum of the demands is not zero. Then, there is no\nflow satisfying all demands.There is no flow satisfying all demand.",
                "NetworkXUnbounded": "This exception is raised if the digraph G has a cycle of\nnegative cost and infinite capacity. Then, the cost of a flow\nsatisfying all demands is unbounded below."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm is not guaranteed to work if edge weights or demands\nare floating point numbers (overflows and roundoff errors can\ncause problems). As a workaround you can use integer numbers by\nmultiplying the relevant edge attributes by a convenient\nconstant factor (eg 100).",
            "References": "[1]Z. Kiraly, P. Kovacs.\nEfficient implementation of minimum-cost flow algorithms.\nActa Universitatis Sapientiae, Informatica 4(1):67\u2013118. 2012.  [2]R. Barr, F. Glover, D. Klingman.\nEnhancement of spanning tree labeling procedures for network\noptimization.\nINFOR 17(1):16\u201334. 1979.",
            "Examples": "A simple example of a min cost flow problem.\nG=nx.DiGraph()\nG.add_node(\"a\",demand=-5)\nG.add_node(\"d\",demand=5)\nG.add_edge(\"a\",\"b\",weight=3,capacity=4)\nG.add_edge(\"a\",\"c\",weight=6,capacity=10)\nG.add_edge(\"b\",\"d\",weight=1,capacity=9)\nG.add_edge(\"c\",\"d\",weight=2,capacity=5)\nflowCost,flowDict=nx.network_simplex(G)\nflowCost\n# 24\nflowDict\n# {'a': {'b': 4, 'c': 1}, 'd': {}, 'b': {'d': 4}, 'c': {'d': 1}}\nThe mincost flow algorithm can also be used to solve shortest path\nproblems. To find the shortest path between two nodes u and v,\ngive all edges an infinite capacity, give node u a demand of -1 and\nnode v a demand a 1. Then run the network simplex. The value of a\nmin cost flow will be the distance between u and v and edges\ncarrying positive flow will indicate the path.\nG=nx.DiGraph()\nG.add_weighted_edges_from(\n[\n(\"s\",\"u\",10),\n(\"s\",\"x\",5),\n(\"u\",\"v\",1),\n(\"u\",\"x\",2),\n(\"v\",\"y\",1),\n(\"x\",\"u\",3),\n(\"x\",\"v\",5),\n(\"x\",\"y\",2),\n(\"y\",\"s\",7),\n(\"y\",\"v\",6),\n]\n)\nG.add_node(\"s\",demand=-1)\nG.add_node(\"v\",demand=1)\nflowCost,flowDict=nx.network_simplex(G)\nflowCost==nx.shortest_path_length(G,\"s\",\"v\",weight=\"weight\")\n# True\nsorted([(u,v)foruinflowDictforvinflowDict[u]ifflowDict[u][v]>0])\n# [('s', 'x'), ('u', 'v'), ('x', 'u')]\nnx.shortest_path(G,\"s\",\"v\",weight=\"weight\")\n# ['s', 'x', 'u', 'v']\nIt is possible to change the name of the attributes used for the\nalgorithm.\nG=nx.DiGraph()\nG.add_node(\"p\",spam=-4)\nG.add_node(\"q\",spam=2)\nG.add_node(\"a\",spam=-2)\nG.add_node(\"d\",spam=-1)\nG.add_node(\"t\",spam=2)\nG.add_node(\"w\",spam=3)\nG.add_edge(\"p\",\"q\",cost=7,vacancies=5)\nG.add_edge(\"p\",\"a\",cost=1,vacancies=4)\nG.add_edge(\"q\",\"d\",cost=2,vacancies=3)\nG.add_edge(\"t\",\"q\",cost=1,vacancies=2)\nG.add_edge(\"a\",\"t\",cost=2,vacancies=4)\nG.add_edge(\"d\",\"w\",cost=3,vacancies=4)\nG.add_edge(\"t\",\"w\",cost=4,vacancies=1)\nflowCost,flowDict=nx.network_simplex(\nG,demand=\"spam\",capacity=\"vacancies\",weight=\"cost\"\n)\nflowCost\n# 37\nflowDict\n# {'p': {'q': 2, 'a': 2}, 'q': {'d': 1}, 'a': {'t': 4}, 'd': {'w': 2}, 't': {'q': 1, 'w': 1}, 'w': {}}"
        }
    },
    {
        "Section ID": "to_dict_of_lists",
        "Description": [
            "Returns adjacency representation of graph as a dictionary of lists."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "nodelist : list": "Use only nodes specified in nodelist"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Completely ignores edge data for MultiGraph and MultiDiGraph."
        }
    },
    {
        "Section ID": "write_graph6",
        "Description": [
            "Write a simple undirected graph to a path in graph6 format."
        ],
        "Field List": {
            "Parameters:": {
                "G : Graph (undirected)": "",
                "path : str": "The path naming the file to which to write the graph.",
                "nodes: list or iterable": "Nodes are labeled 0\u2026n-1 in the order provided.  If None the ordering\ngiven byG.nodes()is used.",
                "header: bool": "If True add \u2018>>graph6<<\u2019 string to head of data"
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the graph is directed or is a multigraph.",
                "ValueError": "If the graph has at least2**36nodes; the graph6 format\nis only defined for graphs of order less than2**36."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The function writes a newline character after writing the encoding\nof the graph. The format does not support edge or node labels, parallel edges or\nself loops.  If self loops are present they are silently ignored.",
            "References": "[1]Graph6 specification\n<http://users.cecs.anu.edu.au/~bdm/data/formats.html>",
            "Examples": "You can write a graph6 file by giving the path to a file:\nimporttempfile\nwithtempfile.NamedTemporaryFile(delete=False)asf:\nnx.write_graph6(nx.path_graph(2),f.name)\n_=f.seek(0)\nprint(f.read())\n# b'>>graph6<<A_\\n'"
        }
    },
    {
        "Section ID": "random_spanning_tree",
        "Description": [
            "Sample a random spanning tree using the edges weights of G .",
            "This function supports two different methods for determining the\nprobability of the graph. If multiplicative=True , the probability\nis based on the product of edge weights, and if multiplicative=False it is based on the sum of the edge weight. However, since it is\neasier to determine the total weight of all spanning trees for the\nmultiplicative version, that is significantly faster and should be used if\npossible. Additionally, setting weight to None will cause a spanning tree\nto be selected with uniform probability.",
            "The function uses algorithm A8 in [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : nx.Graph": "An undirected version of the original graph.",
                "weight : string": "The edge key for the edge attribute holding edge weight.",
                "multiplicative : bool, default=True": "IfTrue, the probability of each tree is the product of its edge weight\nover the sum of the product of all the spanning trees in the graph. IfFalse, the probability is the sum of its edge weight over the sum of\nthe sum of weights for all spanning trees in the graph.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "nx.Graph": "A spanning tree using the distribution defined by the weight of the tree."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]V. Kulkarni, Generating random combinatorial objects, Journal of\nAlgorithms, 11 (1990), pp. 185\u2013207"
        }
    },
    {
        "Section ID": "has_bridges",
        "Description": [
            "Decide whether a graph has any bridges.",
            "A bridge in a graph is an edge whose removal causes the number of\nconnected components of the graph to increase."
        ],
        "Field List": {
            "Parameters:": {
                "G : undirected graph": "",
                "root : node (optional)": "A node in the graphG. If specified, only the bridges in the\nconnected component containing this node will be considered."
            },
            "Returns:": {
                "bool": "Whether the graph (or the connected component containingroot)\nhas any bridges."
            },
            "Raises:": {
                "NodeNotFound": "Ifrootis not in the graphG.",
                "NetworkXNotImplemented": "IfGis a directed graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This implementation uses the networkx.bridges() function, so\nit shares its worst-case time complexity, \\(O(m + n)\\) , ignoring\npolylogarithmic factors, where \\(n\\) is the number of nodes in the\ngraph and \\(m\\) is the number of edges.",
            "Examples": "The barbell graph with parameter zero has a single bridge:\nG=nx.barbell_graph(10,0)\nnx.has_bridges(G)\n# True\nOn the other hand, the cycle graph has no bridges:\nG=nx.cycle_graph(5)\nnx.has_bridges(G)\n# False"
        }
    },
    {
        "Section ID": "rooted_product",
        "Description": [
            "Return the rooted product of graphs G and H rooted at root in H.",
            "A new graph is constructed representing the rooted product of\nthe inputted graphs, G and H, with a root in H.\nA rooted product duplicates H for each nodes in G with the root\nof H corresponding to the node in G. Nodes are renamed as the direct\nproduct of G and H. The result is a subgraph of the cartesian product."
        ],
        "Field List": {
            "Parameters:": {
                "G,H : graph": "A NetworkX graph",
                "root : node": "A node in H"
            },
            "Returns:": {
                "R : The rooted product of G and H with a specified root in H": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The nodes of R are the Cartesian Product of the nodes of G and H.\nThe nodes of G and H are not relabeled."
        }
    },
    {
        "Section ID": "grid_2d_graph",
        "Description": [
            "Returns the two-dimensional grid graph.",
            "The grid graph has each node connected to its four nearest neighbors."
        ],
        "Field List": {
            "Parameters:": {
                "m, n : int or iterable container of nodes": "If an integer, nodes are fromrange(n).\nIf a container, elements become the coordinate of the nodes.",
                "periodic : bool or iterable": "Ifperiodicis True, both dimensions are periodic. If False, none\nare periodic.  Ifperiodicis iterable, it should yield 2 bool\nvalues indicating whether the 1st and 2nd axes, respectively, are\nperiodic.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "NetworkX graph": "The (possibly periodic) grid graph of the specified dimensions."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "is_triad",
        "Description": [
            "Returns True if the graph G is a triad, else False."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX Graph"
            },
            "Returns:": {
                "istriad : boolean": "Whether G is a valid triad"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.DiGraph([(1,2),(2,3),(3,1)])\nnx.is_triad(G)\n# True\nG.add_edge(0,1)\nnx.is_triad(G)\n# False"
        }
    },
    {
        "Section ID": "graph_edit_distance",
        "Description": [
            "Returns GED (graph edit distance) between graphs G1 and G2.",
            "Graph edit distance is a graph similarity measure analogous to\nLevenshtein distance for strings.  It is defined as minimum cost\nof edit path (sequence of node and edge edit operations)\ntransforming graph G1 to graph isomorphic to G2."
        ],
        "Field List": {
            "Parameters:": {
                "G1, G2: graphs": "The two graphs G1 and G2 must be of the same type.",
                "node_match : callable": "A function that returns True if node n1 in G1 and n2 in G2\nshould be considered equal during matching.The function will be called likenode_match(G1.nodes[n1], G2.nodes[n2]).That is, the function will receive the node attribute\ndictionaries for n1 and n2 as inputs.Ignored if node_subst_cost is specified.  If neither\nnode_match nor node_subst_cost are specified then node\nattributes are not considered.",
                "edge_match : callable": "A function that returns True if the edge attribute dictionaries\nfor the pair of nodes (u1, v1) in G1 and (u2, v2) in G2 should\nbe considered equal during matching.The function will be called likeedge_match(G1[u1][v1], G2[u2][v2]).That is, the function will receive the edge attribute\ndictionaries of the edges under consideration.Ignored if edge_subst_cost is specified.  If neither\nedge_match nor edge_subst_cost are specified then edge\nattributes are not considered.",
                "node_subst_cost, node_del_cost, node_ins_cost : callable": "Functions that return the costs of node substitution, node\ndeletion, and node insertion, respectively.The functions will be called likenode_subst_cost(G1.nodes[n1], G2.nodes[n2]),\nnode_del_cost(G1.nodes[n1]),\nnode_ins_cost(G2.nodes[n2]).That is, the functions will receive the node attribute\ndictionaries as inputs.  The functions are expected to return\npositive numeric values.Function node_subst_cost overrides node_match if specified.\nIf neither node_match nor node_subst_cost are specified then\ndefault node substitution cost of 0 is used (node attributes\nare not considered during matching).If node_del_cost is not specified then default node deletion\ncost of 1 is used.  If node_ins_cost is not specified then\ndefault node insertion cost of 1 is used.",
                "edge_subst_cost, edge_del_cost, edge_ins_cost : callable": "Functions that return the costs of edge substitution, edge\ndeletion, and edge insertion, respectively.The functions will be called likeedge_subst_cost(G1[u1][v1], G2[u2][v2]),\nedge_del_cost(G1[u1][v1]),\nedge_ins_cost(G2[u2][v2]).That is, the functions will receive the edge attribute\ndictionaries as inputs.  The functions are expected to return\npositive numeric values.Function edge_subst_cost overrides edge_match if specified.\nIf neither edge_match nor edge_subst_cost are specified then\ndefault edge substitution cost of 0 is used (edge attributes\nare not considered during matching).If edge_del_cost is not specified then default edge deletion\ncost of 1 is used.  If edge_ins_cost is not specified then\ndefault edge insertion cost of 1 is used.",
                "roots : 2-tuple": "Tuple where first element is a node in G1 and the second\nis a node in G2.\nThese nodes are forced to be matched in the comparison to\nallow comparison between rooted graphs.",
                "upper_bound : numeric": "Maximum edit distance to consider.  Return None if no edit\ndistance under or equal to upper_bound exists.",
                "timeout : numeric": "Maximum number of seconds to execute.\nAfter timeout is met, the current best GED is returned."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Zeina Abu-Aisheh, Romain Raveaux, Jean-Yves Ramel, Patrick\nMartineau. An Exact Graph Edit Distance Algorithm for Solving\nPattern Recognition Problems. 4th International Conference on\nPattern Recognition Applications and Methods 2015, Jan 2015,\nLisbon, Portugal. 2015,\n<10.5220/0005209202710278>. <hal-01168816>https://hal.archives-ouvertes.fr/hal-01168816",
            "Examples": "G1=nx.cycle_graph(6)\nG2=nx.wheel_graph(7)\nnx.graph_edit_distance(G1,G2)\n# 7.0\nG1=nx.star_graph(5)\nG2=nx.star_graph(5)\nnx.graph_edit_distance(G1,G2,roots=(0,0))\n# 0.0\nnx.graph_edit_distance(G1,G2,roots=(1,0))\n# 8.0"
        }
    },
    {
        "Section ID": "condensation",
        "Description": [
            "Returns the condensation of G.",
            "The condensation of G is the graph with each of the strongly connected\ncomponents contracted into a single node."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX DiGraph": "A directed graph.",
                "scc:  list or generator (optional, default=None)": "Strongly connected components. If provided, the elements insccmust partition the nodes inG. If not provided, it will be\ncalculated as scc=nx.strongly_connected_components(G)."
            },
            "Returns:": {
                "C : NetworkX DiGraph": "The condensation graph C of G.  The node labels are integers\ncorresponding to the index of the component in the list of\nstrongly connected components of G.  C has a graph attribute named\n\u2018mapping\u2019 with a dictionary mapping the original nodes to the\nnodes in C to which they belong.  Each node in C also has a node\nattribute \u2018members\u2019 with the set of original nodes in G that\nform the SCC that the node in C represents."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "After contracting all strongly connected components to a single node,\nthe resulting graph is a directed acyclic graph.",
            "Examples": "Contracting two sets of strongly connected nodes into two distinct SCC\nusing the barbell graph.\nG=nx.barbell_graph(4,0)\nG.remove_edge(3,4)\nG=nx.DiGraph(G)\nH=nx.condensation(G)\nH.nodes.data()\n# NodeDataView({0: {'members': {0, 1, 2, 3}}, 1: {'members': {4, 5, 6, 7}}})\nH.graph[\"mapping\"]\n# {0: 0, 1: 0, 2: 0, 3: 0, 4: 1, 5: 1, 6: 1, 7: 1}\nContracting a complete graph into one single SCC.\nG=nx.complete_graph(7,create_using=nx.DiGraph)\nH=nx.condensation(G)\nH.nodes\n# NodeView((0,))\nH.nodes.data()\n# NodeDataView({0: {'members': {0, 1, 2, 3, 4, 5, 6}}})"
        }
    },
    {
        "Section ID": "minimum_spanning_arborescence",
        "Description": [
            "Returns a minimum spanning arborescence from G."
        ],
        "Field List": {
            "Parameters:": {
                "G : (multi)digraph-like": "The graph to be searched.",
                "attr : str": "The edge attribute used to in determining optimality.",
                "default : float": "The value of the edge attribute used if an edge does not have\nthe attributeattr.",
                "preserve_attrs : bool": "If True, preserve the other attributes of the original graph (that are not\npassed toattr)",
                "partition : str": "The key for the edge attribute containing the partition\ndata on the graph. Edges can be included, excluded or open using theEdgePartitionenum."
            },
            "Returns:": {
                "B : (multi)digraph-like": "A minimum spanning arborescence."
            },
            "Raises:": {
                "NetworkXException": "If the graph does not contain a minimum spanning arborescence."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "group_in_degree_centrality",
        "Description": [
            "Compute the group in-degree centrality for a group of nodes.",
            "Group in-degree centrality of a group of nodes \\(S\\) is the fraction\nof non-group members connected to group members by incoming edges."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.",
                "S : list or set": "S is a group of nodes which belong to G, for which group in-degree\ncentrality is to be calculated."
            },
            "Returns:": {
                "centrality : float": "Group in-degree centrality of the group S."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is undirected.",
                "NodeNotFound": "If node(s) in S are not in G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The number of nodes in the group must be a maximum of n - 1 where n is the total number of nodes in the graph. G.neighbors(i) gives nodes with an outward edge from i, in a DiGraph,\nso for group in-degree centrality, the reverse graph is used."
        }
    },
    {
        "Section ID": "edges",
        "Description": [
            "Returns an edge view of edges incident to nodes in nbunch.",
            "Return all edges if nbunch is unspecified or nbunch=None.",
            "For digraphs, edges=out_edges",
            "This function wraps the G.edges property."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "lexicographic_product",
        "Description": [
            "Returns the lexicographic product of G and H.",
            "The lexicographical product \\(P\\) of the graphs \\(G\\) and \\(H\\) has a node set\nthat is the Cartesian product of the node sets, \\(V(P)=V(G) \\times V(H)\\) . \\(P\\) has an edge \\(((u,v), (x,y))\\) if and only if \\((u,v)\\) is an edge in \\(G\\) or \\(u==v\\) and \\((x,y)\\) is an edge in \\(H\\) ."
        ],
        "Field List": {
            "Parameters:": {
                "G, H: graphs": "Networkx graphs."
            },
            "Returns:": {
                "P: NetworkX graph": "The Cartesian product of G and H. P will be a multi-graph if either G\nor H is a multi-graph. Will be a directed if G and H are directed,\nand undirected if G and H are undirected."
            },
            "Raises:": {
                "NetworkXError": "If G and H are not both directed or both undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Node attributes in P are two-tuple of the G and H node attributes.\nMissing attributes are assigned None.",
            "Examples": "G=nx.Graph()\nH=nx.Graph()\nG.add_node(0,a1=True)\nH.add_node(\"a\",a2=\"Spam\")\nP=nx.lexicographic_product(G,H)\nlist(P)\n# [(0, 'a')]\nEdge attributes and edge keys (for multigraphs) are also copied to the\nnew product graph"
        }
    },
    {
        "Section ID": "show_multiedges",
        "Description": [
            "Returns a filter function that shows specific multi-undirected edges."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "read_leda",
        "Description": [
            "Read graph in LEDA format from path."
        ],
        "Field List": {
            "Parameters:": {
                "path : file or string": "File or filename to read.  Filenames ending in .gz or .bz2  will be\nuncompressed."
            },
            "Returns:": {
                "G : NetworkX graph": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]http://www.algorithmic-solutions.info/leda_guide/graphs/leda_native_graph_fileformat.html",
            "Examples": "G=nx.read_leda(\u2018file.leda\u2019)"
        }
    },
    {
        "Section ID": "negative_edge_cycle",
        "Description": [
            "Returns True if there exists a negative edge cycle anywhere in G."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number.",
                "heuristic : bool": "Determines whether to use a heuristic to early detect negative\ncycles at a negligible cost. In case of graphs with a negative cycle,\nthe performance of detection increases by at least an order of magnitude."
            },
            "Returns:": {
                "negative_cycle : bool": "True if a negative edge cycle exists, otherwise False."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. This algorithm uses bellman_ford_predecessor_and_distance() but finds\nnegative cycles on any component by first adding a new node connected to\nevery node, and starting bellman_ford_predecessor_and_distance on that\nnode.  It then removes that extra node.",
            "Examples": "G=nx.cycle_graph(5,create_using=nx.DiGraph())\nprint(nx.negative_edge_cycle(G))\n# False\nG[1][2][\"weight\"]=-7\nprint(nx.negative_edge_cycle(G))\n# True"
        }
    },
    {
        "Section ID": "bethe_hessian_spectrum",
        "Description": [
            "Returns eigenvalues of the Bethe Hessian matrix of G."
        ],
        "Field List": {
            "Parameters:": {
                "G : Graph": "A NetworkX Graph or DiGraph",
                "r : float": "Regularizer parameter"
            },
            "Returns:": {
                "evals : NumPy array": "Eigenvalues"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]A. Saade, F. Krzakala and L. Zdeborov\u00e1\n\u201cSpectral clustering of graphs with the bethe hessian\u201d,\nAdvances in Neural Information Processing Systems. 2014."
        }
    },
    {
        "Section ID": "find_cliques",
        "Description": [
            "Returns all maximal cliques in an undirected graph.",
            "For each node n , a maximal clique for n is a largest complete\nsubgraph containing n . The largest maximal clique is sometimes\ncalled the maximum clique .",
            "This function returns an iterator over cliques, each of which is a\nlist of nodes. It is an iterative implementation, so should not\nsuffer from recursion depth issues.",
            "This function accepts a list of nodes and only the maximal cliques\ncontaining all of these nodes are returned. It can considerably speed up\nthe running time if some specific cliques are desired."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "An undirected graph.",
                "nodes : list, optional (default=None)": "If provided, only yieldmaximal cliquescontaining all nodes innodes.\nIfnodesisn\u2019t a clique itself, a ValueError is raised."
            },
            "Returns:": {
                "iterator": "An iterator over maximal cliques, each of which is a list of\nnodes inG. Ifnodesis provided, only the maximal cliques\ncontaining all the nodes innodesare returned. The order of\ncliques is arbitrary."
            },
            "Raises:": {
                "ValueError": "Ifnodesis not a clique."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "To obtain a list of all maximal cliques, use list(find_cliques(G)) . However, be aware that in the worst-case,\nthe length of this list can be exponential in the number of nodes in\nthe graph. This function avoids storing all cliques in memory by\nonly keeping current candidate node lists in memory during its search. This implementation is based on the algorithm published by Bron and\nKerbosch (1973) [1] , as adapted by Tomita, Tanaka and Takahashi\n(2006) [2] and discussed in Cazals and Karande (2008) [3] . It\nessentially unrolls the recursion used in the references to avoid\nissues of recursion stack depth (for a recursive implementation, see find_cliques_recursive() ). This algorithm ignores self-loops and parallel edges, since cliques\nare not conventionally defined with such edges.",
            "References": "[1]Bron, C. and Kerbosch, J.\n\u201cAlgorithm 457: finding all cliques of an undirected graph\u201d.Communications of the ACM16, 9 (Sep. 1973), 575\u2013577.\n<http://portal.acm.org/citation.cfm?doid=362342.362367>  [2]Etsuji Tomita, Akira Tanaka, Haruhisa Takahashi,\n\u201cThe worst-case time complexity for generating all maximal\ncliques and computational experiments\u201d,Theoretical Computer Science, Volume 363, Issue 1,\nComputing and Combinatorics,\n10th Annual International Conference on\nComputing and Combinatorics (COCOON 2004), 25 October 2006, Pages 28\u201342\n<https://doi.org/10.1016/j.tcs.2006.06.015>  [3]F. Cazals, C. Karande,\n\u201cA note on the problem of reporting maximal cliques\u201d,Theoretical Computer Science,\nVolume 407, Issues 1\u20133, 6 November 2008, Pages 564\u2013568,\n<https://doi.org/10.1016/j.tcs.2008.05.010>",
            "Examples": "frompprintimportpprint# For nice dict formatting\nG=nx.karate_club_graph()\nsum(1forcinnx.find_cliques(G))# The number of maximal cliques in G\n# 36\nmax(nx.find_cliques(G),key=len)# The largest maximal clique in G\n# [0, 1, 2, 3, 13]\nThe size of the largest maximal clique is known as theclique numberof\nthe graph, which can be found directly with:\nmax(len(c)forcinnx.find_cliques(G))\n# 5\nOne can also compute the number of maximal cliques inGthat contain a given\nnode. The following produces a dictionary keyed by node whose\nvalues are the number of maximal cliques inGthat contain the node:\npprint({n:sum(1forcinnx.find_cliques(G)ifninc)forninG})\n# {0: 13,\n#  1: 6,\n#  2: 7,\n#  3: 3,\n#  4: 2,\n#  5: 3,\n#  6: 3,\n#  7: 1,\n#  8: 3,\n#  9: 2,\n#  10: 2,\n#  11: 1,\n#  12: 1,\n#  13: 2,\n#  14: 1,\n#  15: 1,\n#  16: 1,\n#  17: 1,\n#  18: 1,\n#  19: 2,\n#  20: 1,\n#  21: 1,\n#  22: 1,\n#  23: 3,\n#  24: 2,\n#  25: 2,\n#  26: 1,\n#  27: 3,\n#  28: 2,\n#  29: 2,\n#  30: 2,\n#  31: 4,\n#  32: 9,\n#  33: 14}\nOr, similarly, the maximal cliques inGthat contain a given node.\nFor example, the 4 maximal cliques that contain node 31:\n[cforcinnx.find_cliques(G)if31inc]\n# [[0, 31], [33, 32, 31], [33, 28, 31], [24, 25, 31]]"
        }
    },
    {
        "Section ID": "hide_multiedges",
        "Description": [
            "Returns a filter function that hides specific multi-undirected edges."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "kemeny_constant",
        "Description": [
            "Returns the Kemeny constant of the given graph.",
            "The Kemeny constant (or Kemeny\u2019s constant) of a graph G can be computed by regarding the graph as a Markov chain.\nThe Kemeny constant is then the expected number of time steps\nto transition from a starting state i to a random destination state\nsampled from the Markov chain\u2019s stationary distribution.\nThe Kemeny constant is independent of the chosen initial state [1] .",
            "The Kemeny constant measures the time needed for spreading\nacross a graph. Low values indicate a closely connected graph\nwhereas high values indicate a spread-out graph.",
            "If weight is not provided, then a weight of 1 is used for all edges.",
            "Since G represents a Markov chain, the weights must be positive."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "weight : string or None, optional (default=None)": "The edge data key used to compute the Kemeny constant.\nIf None, then each edge has weight 1."
            },
            "Returns:": {
                "float": "The Kemeny constant of the graphG."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the graphGis directed.",
                "NetworkXError": "If the graphGis not connected, or contains no nodes,\nor has edges with negative weights."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The implementation is based on equation (3.3) in [2] .\nSelf-loops are allowed and indicate a Markov chain where\nthe state can remain the same. Multi-edges are contracted\nin one edge with weight equal to the sum of the weights.",
            "References": "[1]Wikipedia\n\u201cKemeny\u2019s constant.\u201dhttps://en.wikipedia.org/wiki/Kemeny%27s_constant  [2]Lov\u00e1sz L.\nRandom walks on graphs: A survey.\nPaul Erd\u00f6s is Eighty, vol. 2, Bolyai Society,\nMathematical Studies, Keszthely, Hungary (1993), pp. 1-46",
            "Examples": "G=nx.complete_graph(5)\nround(nx.kemeny_constant(G),10)\n# 3.2"
        }
    },
    {
        "Section ID": "selfloop_edges",
        "Description": [
            "Returns an iterator over selfloop edges.",
            "A selfloop edge has the same node at both ends."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.",
                "data : string or bool, optional (default=False)": "Return selfloop edges as two tuples (u, v) (data=False)\nor three-tuples (u, v, datadict) (data=True)\nor three-tuples (u, v, datavalue) (data=\u2019attrname\u2019)",
                "keys : bool, optional (default=False)": "If True, return edge keys with each edge.",
                "default : value, optional (default=None)": "Value used for edges that don\u2019t have the requested attribute.\nOnly relevant if data is not True or False."
            },
            "Returns:": {
                "edgeiter : iterator over edge tuples": "An iterator over all selfloop edges."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.MultiGraph()# or Graph, DiGraph, MultiDiGraph, etc\nekey=G.add_edge(1,1)\nekey=G.add_edge(1,2)\nlist(nx.selfloop_edges(G))\n# [(1, 1)]\nlist(nx.selfloop_edges(G,data=True))\n# [(1, 1, {})]\nlist(nx.selfloop_edges(G,keys=True))\n# [(1, 1, 0)]\nlist(nx.selfloop_edges(G,keys=True,data=True))\n# [(1, 1, 0, {})]"
        }
    },
    {
        "Section ID": "recursive_simple_cycles",
        "Description": [
            "Find simple cycles (elementary circuits) of a directed graph.",
            "A simplecycle , or elementarycircuit , is a closed path where\nno node appears twice. Two elementary circuits are distinct if they\nare not cyclic permutations of each other.",
            "This version uses a recursive algorithm to build a list of cycles.\nYou should probably use the iterator version called simple_cycles().\nWarning: This recursive version uses lots of RAM!\nIt appears in NetworkX for pedagogical value."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX DiGraph": "A directed graph"
            },
            "Returns:": {
                "A list of cycles, where each cycle is represented by a list of nodes": "",
                "along the cycle.": "",
                "Example:": "",
                "[[0], [2], [0, 1, 2], [0, 2], [1, 2]]": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The implementation follows pp. 79-80 in [1] . The time complexity is \\(O((n+e)(c+1))\\) for \\(n\\) nodes, \\(e\\) edges and \\(c\\) elementary circuits.",
            "References": "[1]Finding all the elementary circuits of a directed graph.\nD. B. Johnson, SIAM Journal on Computing 4, no. 1, 77-84, 1975.https://doi.org/10.1137/0204007"
        }
    },
    {
        "Section ID": "chvatal_graph",
        "Description": [
            "Returns the Chv\u00e1tal Graph",
            "The Chv\u00e1tal Graph is an undirected graph with 12 nodes and 24 edges [1] .\nIt has 370 distinct (directed) Hamiltonian cycles, giving a unique generalized\nLCF notation of order 4, two of order 6 , and 43 of order 1 [2] ."
        ],
        "Field List": {
            "Parameters:": {
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : networkx Graph": "The Chv\u00e1tal graph with 12 nodes and 24 edges"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://en.wikipedia.org/wiki/Chv%C3%A1tal_graph  [2]https://mathworld.wolfram.com/ChvatalGraph.html"
        }
    },
    {
        "Section ID": "to_undirected",
        "Description": [
            "Returns an undirected view of the graph graph .",
            "Identical to graph.to_undirected(as_view=True)\nNote that graph.to_undirected defaults to as_view=False while this function always provides a view."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "tree_broadcast_time",
        "Description": [
            "Return the Broadcast Time of the tree G .",
            "The minimum broadcast time of a node is defined as the minimum amount\nof time required to complete broadcasting starting from the\noriginator. The broadcast time of a graph is the maximum over\nall nodes of the minimum broadcast time from that node [1] .\nThis function returns the minimum broadcast time of node .\nIf node is None the broadcast time for the graph is returned."
        ],
        "Field List": {
            "Parameters:": {
                "G : undirected graph": "The graph should be an undirected tree",
                "node: int, optional": "index of starting node. IfNone, the algorithm returns the broadcast\ntime of the tree."
            },
            "Returns:": {
                "BT : int": "Broadcast Time of a node in a tree"
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the graph is directed or is a multigraph."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Harutyunyan, H. A. and Li, Z.\n\u201cA Simple Construction of Broadcast Graphs.\u201d\nIn Computing and Combinatorics. COCOON 2019\n(Ed. D. Z. Du and C. Tian.) Springer, pp. 240-253, 2019."
        }
    },
    {
        "Section ID": "node_expansion",
        "Description": [
            "Returns the node expansion of the set S .",
            "The node expansion is the quotient of the size of the node\nboundary of S and the cardinality of S . [1]"
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "S : collection": "A collection of nodes inG."
            },
            "Returns:": {
                "number": "The node expansion of the setS."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Vadhan, Salil P.\n\u201cPseudorandomness.\u201dFoundations and Trends\nin Theoretical Computer Science7.1\u20133 (2011): 1\u2013336.\n<https://doi.org/10.1561/0400000010>"
        }
    },
    {
        "Section ID": "optimize_graph_edit_distance",
        "Description": [
            "Returns consecutive approximations of GED (graph edit distance)\nbetween graphs G1 and G2.",
            "Graph edit distance is a graph similarity measure analogous to\nLevenshtein distance for strings.  It is defined as minimum cost\nof edit path (sequence of node and edge edit operations)\ntransforming graph G1 to graph isomorphic to G2."
        ],
        "Field List": {
            "Parameters:": {
                "G1, G2: graphs": "The two graphs G1 and G2 must be of the same type.",
                "node_match : callable": "A function that returns True if node n1 in G1 and n2 in G2\nshould be considered equal during matching.The function will be called likenode_match(G1.nodes[n1], G2.nodes[n2]).That is, the function will receive the node attribute\ndictionaries for n1 and n2 as inputs.Ignored if node_subst_cost is specified.  If neither\nnode_match nor node_subst_cost are specified then node\nattributes are not considered.",
                "edge_match : callable": "A function that returns True if the edge attribute dictionaries\nfor the pair of nodes (u1, v1) in G1 and (u2, v2) in G2 should\nbe considered equal during matching.The function will be called likeedge_match(G1[u1][v1], G2[u2][v2]).That is, the function will receive the edge attribute\ndictionaries of the edges under consideration.Ignored if edge_subst_cost is specified.  If neither\nedge_match nor edge_subst_cost are specified then edge\nattributes are not considered.",
                "node_subst_cost, node_del_cost, node_ins_cost : callable": "Functions that return the costs of node substitution, node\ndeletion, and node insertion, respectively.The functions will be called likenode_subst_cost(G1.nodes[n1], G2.nodes[n2]),\nnode_del_cost(G1.nodes[n1]),\nnode_ins_cost(G2.nodes[n2]).That is, the functions will receive the node attribute\ndictionaries as inputs.  The functions are expected to return\npositive numeric values.Function node_subst_cost overrides node_match if specified.\nIf neither node_match nor node_subst_cost are specified then\ndefault node substitution cost of 0 is used (node attributes\nare not considered during matching).If node_del_cost is not specified then default node deletion\ncost of 1 is used.  If node_ins_cost is not specified then\ndefault node insertion cost of 1 is used.",
                "edge_subst_cost, edge_del_cost, edge_ins_cost : callable": "Functions that return the costs of edge substitution, edge\ndeletion, and edge insertion, respectively.The functions will be called likeedge_subst_cost(G1[u1][v1], G2[u2][v2]),\nedge_del_cost(G1[u1][v1]),\nedge_ins_cost(G2[u2][v2]).That is, the functions will receive the edge attribute\ndictionaries as inputs.  The functions are expected to return\npositive numeric values.Function edge_subst_cost overrides edge_match if specified.\nIf neither edge_match nor edge_subst_cost are specified then\ndefault edge substitution cost of 0 is used (edge attributes\nare not considered during matching).If edge_del_cost is not specified then default edge deletion\ncost of 1 is used.  If edge_ins_cost is not specified then\ndefault edge insertion cost of 1 is used.",
                "upper_bound : numeric": "Maximum edit distance to consider."
            },
            "Returns:": {
                "Generator of consecutive approximations of graph edit distance.": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Zeina Abu-Aisheh, Romain Raveaux, Jean-Yves Ramel, Patrick\nMartineau. An Exact Graph Edit Distance Algorithm for Solving\nPattern Recognition Problems. 4th International Conference on\nPattern Recognition Applications and Methods 2015, Jan 2015,\nLisbon, Portugal. 2015,\n<10.5220/0005209202710278>. <hal-01168816>https://hal.archives-ouvertes.fr/hal-01168816",
            "Examples": "G1=nx.cycle_graph(6)\nG2=nx.wheel_graph(7)\nforvinnx.optimize_graph_edit_distance(G1,G2):\nminv=v\nminv\n# 7.0"
        }
    },
    {
        "Section ID": "trophic_levels",
        "Description": [
            "Compute the trophic levels of nodes.",
            "The trophic level of a node \\(i\\) is",
            "where \\(k^{in}_i\\) is the in-degree of i",
            "and nodes with \\(k^{in}_i = 0\\) have \\(s_i = 1\\) by convention.",
            "These are calculated using the method outlined in Levine [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : DiGraph": "A directed networkx graph"
            },
            "Returns:": {
                "nodes : dict": "Dictionary of nodes with trophic level as the value."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Stephen Levine (1980) J. theor. Biol. 83, 195-207"
        }
    },
    {
        "Section ID": "to_edgelist",
        "Description": [
            "Returns a list of edges in the graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "nodelist : list": "Use only nodes specified in nodelist"
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "fast_gnp_random_graph",
        "Description": [
            "Returns a \\(G_{n,p}\\) random graph, also known as an Erd\u0151s-R\u00e9nyi graph or\na binomial graph."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes.",
                "p : float": "Probability for edge creation.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "directed : bool, optional (default=False)": "If True, this function returns a directed graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The \\(G_{n,p}\\) graph algorithm chooses each of the \\([n (n - 1)] / 2\\) (undirected) or \\(n (n - 1)\\) (directed) possible edges with probability \\(p\\) . This algorithm [1] runs in \\(O(n + m)\\) time, where m is the expected number of\nedges, which equals \\(p n (n - 1) / 2\\) . This should be faster than gnp_random_graph() when \\(p\\) is small and the expected number of edges\nis small (that is, the graph is sparse).",
            "References": "[1]Vladimir Batagelj and Ulrik Brandes,\n\u201cEfficient generation of large random networks\u201d,\nPhys. Rev. E, 71, 036113, 2005."
        }
    },
    {
        "Section ID": "gaussian_random_partition_graph",
        "Description": [
            "Generate a Gaussian random partition graph.",
            "A Gaussian random partition graph is created by creating k partitions\neach with a size drawn from a normal distribution with mean s and variance\ns/v. Nodes are connected within clusters with probability p_in and\nbetween clusters with probability p_out[1]"
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "Number of nodes in the graph",
                "s : float": "Mean cluster size",
                "v : float": "Shape parameter. The variance of cluster size distribution is s/v.",
                "p_in : float": "Probability of intra cluster connection.",
                "p_out : float": "Probability of inter cluster connection.",
                "directed : boolean, optional default=False": "Whether to create a directed graph or not",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "G : NetworkX Graph or DiGraph": "gaussian random partition graph"
            },
            "Raises:": {
                "NetworkXError": "If s is > n\nIf p_in or p_out is not in [0,1]"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Note the number of partitions is dependent on s,v and n, and that the\nlast partition may be considerably smaller, as it is sized to simply\nfill out the nodes [1]",
            "References": "[1]Ulrik Brandes, Marco Gaertler, Dorothea Wagner,\nExperiments on Graph Clustering Algorithms,\nIn the proceedings of the 11th Europ. Symp. Algorithms, 2003.",
            "Examples": "G=nx.gaussian_random_partition_graph(100,10,10,0.25,0.1)\nlen(G)\n# 100"
        }
    },
    {
        "Section ID": "weighted_projected_graph",
        "Description": [
            "Returns a weighted projection of B onto one of its node sets.",
            "The weighted projected graph is the projection of the bipartite\nnetwork B onto the specified nodes with weights representing the\nnumber of shared neighbors or the ratio between actual shared\nneighbors and possible shared neighbors if ratioisTrue  [1] .\nThe nodes retain their attributes and are connected in the resulting\ngraph if they have an edge to a common node in the original graph."
        ],
        "Field List": {
            "Parameters:": {
                "B : NetworkX graph": "The input graph should be bipartite.",
                "nodes : list or iterable": "Distinct nodes to project onto (the \u201cbottom\u201d nodes).",
                "ratio: Bool (default=False)": "If True, edge weight is the ratio between actual shared neighbors\nand maximum possible shared neighbors (i.e., the size of the other\nnode set). If False, edges weight is the number of shared neighbors."
            },
            "Returns:": {
                "Graph : NetworkX graph": "A graph that is the projection onto the given nodes."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "No attempt is made to verify that the input graph B is bipartite, or that\nthe input nodes are distinct. However, if the length of the input nodes is\ngreater than or equal to the nodes in the graph B, an exception is raised.\nIf the nodes are not distinct but don\u2019t raise this error, the output weights\nwill be incorrect.\nThe graph and node properties are (shallow) copied to the projected graph. See bipartitedocumentation for further details on how bipartite graphs are handled in NetworkX.",
            "References": "[1]Borgatti, S.P. and Halgin, D. In press. \u201cAnalyzing Affiliation\nNetworks\u201d. In Carrington, P. and Scott, J. (eds) The Sage Handbook\nof Social Network Analysis. Sage Publications.",
            "Examples": "fromnetworkx.algorithmsimportbipartite\nB=nx.path_graph(4)\nG=bipartite.weighted_projected_graph(B,[1,3])\nlist(G)\n# [1, 3]\nlist(G.edges(data=True))\n# [(1, 3, {'weight': 1})]\nG=bipartite.weighted_projected_graph(B,[1,3],ratio=True)\nlist(G.edges(data=True))\n# [(1, 3, {'weight': 0.5})]"
        }
    },
    {
        "Section ID": "is_valid_degree_sequence_havel_hakimi",
        "Description": [
            "Returns True if deg_sequence can be realized by a simple graph.",
            "The validation proceeds using the Havel-Hakimi theorem [havel1955] , [hakimi1962] , [CL1996] .\nWorst-case run time is \\(O(s)\\) where \\(s\\) is the sum of the sequence."
        ],
        "Field List": {
            "Parameters:": {
                "deg_sequence : list": "A list of integers where each element specifies the degree of a node\nin a graph."
            },
            "Returns:": {
                "valid : bool": "True if deg_sequence is graphical and False if not."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The ZZ condition says that for the sequence d if",
            "References": "[1]I.E. Zverovich and V.E. Zverovich. \u201cContributions to the theory\nof graphic sequences\u201d, Discrete Mathematics, 105, pp. 292-303 (1992).  [havel1955]Havel, V. \u201cA Remark on the Existence of Finite Graphs\u201d\nCasopis Pest. Mat. 80, 477-480, 1955.  [hakimi1962]Hakimi, S. \u201cOn the Realizability of a Set of Integers as\nDegrees of the Vertices of a Graph.\u201d SIAM J. Appl. Math. 10, 496-506, 1962.  [CL1996]G. Chartrand and L. Lesniak, \u201cGraphs and Digraphs\u201d,\nChapman and Hall/CRC, 1996.",
            "Examples": "G=nx.Graph([(1,2),(1,3),(2,3),(3,4),(4,2),(5,1),(5,4)])\nsequence=(dfor_,dinG.degree())\nnx.is_valid_degree_sequence_havel_hakimi(sequence)\n# True\nTo test a non-valid sequence:\n>>> sequence_list = [d for _, d in G.degree()]\n>>> sequence_list[-1] += 1\n>>> nx.is_valid_degree_sequence_havel_hakimi(sequence_list)\nFalse"
        }
    },
    {
        "Section ID": "floyd_warshall_numpy",
        "Description": [
            "Find all-pairs shortest path lengths using Floyd\u2019s algorithm.",
            "This algorithm for finding shortest paths takes advantage of\nmatrix representations of a graph and works well for dense\ngraphs where all-pairs shortest path lengths are desired.\nThe results are returned as a NumPy array, distance[i, j],\nwhere i and j are the indexes of two nodes in nodelist.\nThe entry distance[i, j] is the distance along a shortest\npath from i to j. If no path exists the distance is Inf."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "nodelist : list, optional (default=G.nodes)": "The rows and columns are ordered by the nodes in nodelist.\nIf nodelist is None then the ordering is produced by G.nodes.\nNodelist should include all nodes in G.",
                "weight: string, optional (default=\u2019weight\u2019)": "Edge data key corresponding to the edge weight."
            },
            "Returns:": {
                "distance : 2D numpy.ndarray": "A numpy array of shortest path distances between nodes.\nIf there is no path between two nodes the value is Inf."
            },
            "Raises:": {
                "NetworkXError": "If nodelist is not a list of the nodes in G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Floyd\u2019s algorithm is appropriate for finding shortest paths in\ndense graphs or graphs with negative weights when Dijkstra\u2019s\nalgorithm fails. This algorithm can still fail if there are negative\ncycles. It has running time \\(O(n^3)\\) with running space of \\(O(n^2)\\) .",
            "Examples": "G=nx.DiGraph()\nG.add_weighted_edges_from([(0,1,5),(1,2,2),(2,3,-3),(1,3,10),(3,2,8)])\nnx.floyd_warshall_numpy(G)\n# array([[ 0.,  5.,  7.,  4.],\n#        [inf,  0.,  2., -1.],\n#        [inf, inf,  0., -3.],\n#        [inf, inf,  8.,  0.]])"
        }
    },
    {
        "Section ID": "parse_multiline_adjlist",
        "Description": [
            "Parse lines of a multiline adjacency list representation of a graph."
        ],
        "Field List": {
            "Parameters:": {
                "lines : list or iterator of strings": "Input data in multiline adjlist format",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated.",
                "nodetype : Python type, optional": "Convert nodes to this type.",
                "edgetype : Python type, optional": "Convert edges to this type.",
                "comments : string, optional": "Marker for comment lines",
                "delimiter : string, optional": "Separator for node labels.  The default is whitespace."
            },
            "Returns:": {
                "G: NetworkX graph": "The graph corresponding to the lines in multiline adjacency list format."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "lines=[\n\"1 2\",\n\"2 {'weight':3, 'name': 'Frodo'}\",\n\"3 {}\",\n\"2 1\",\n\"5 {'weight':6, 'name': 'Saruman'}\",\n]\nG=nx.parse_multiline_adjlist(iter(lines),nodetype=int)\nlist(G)\n# [1, 2, 3, 5]"
        }
    },
    {
        "Section ID": "is_biconnected",
        "Description": [
            "Returns True if the graph is biconnected, False otherwise.",
            "A graph is biconnected if, and only if, it cannot be disconnected by\nremoving only one node (and all edges incident on that node).  If\nremoving a node increases the number of disconnected components\nin the graph, that node is called an articulation point, or cut\nvertex.  A biconnected graph has no articulation points."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "An undirected graph."
            },
            "Returns:": {
                "biconnected : bool": "True if the graph is biconnected, False otherwise."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the input graph is not undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The algorithm to find articulation points and biconnected\ncomponents is implemented using a non-recursive depth-first-search\n(DFS) that keeps track of the highest level that back edges reach\nin the DFS tree.  A node n is an articulation point if, and only\nif, there exists a subtree rooted at n such that there is no\nback edge from any successor of n that links to a predecessor of n in the DFS tree.  By keeping track of all the edges traversed\nby the DFS we can obtain the biconnected components because all\nedges of a bicomponent will be traversed consecutively between\narticulation points.",
            "References": "[1]Hopcroft, J.; Tarjan, R. (1973).\n\u201cEfficient algorithms for graph manipulation\u201d.\nCommunications of the ACM 16: 372\u2013378. doi:10.1145/362248.362272",
            "Examples": "G=nx.path_graph(4)\nprint(nx.is_biconnected(G))\n# False\nG.add_edge(0,3)\nprint(nx.is_biconnected(G))\n# True"
        }
    },
    {
        "Section ID": "k_edge_subgraphs",
        "Description": [
            "Generates nodes in each maximal k-edge-connected subgraph in G."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "k : Integer": "Desired edge connectivity"
            },
            "Returns:": {
                "k_edge_subgraphs : a generator of k-edge-subgraphs": "Each k-edge-subgraph is a maximal set of nodes that defines a subgraph\nof G that is k-edge-connected."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the input graph is a multigraph.",
                "ValueError:": "If k is less than 1"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Attempts to use the most efficient implementation available based on k.\nIf k=1, or k=2 and the graph is undirected, then this simply calls k_edge_components .  Otherwise the algorithm from _[1] is used.",
            "References": "[1]Zhou, Liu, et al. (2012) Finding maximal k-edge-connected subgraphs\nfrom a large graph.  ACM International Conference on Extending Database\nTechnology 2012 480-\u2013491.https://openproceedings.org/2012/conf/edbt/ZhouLYLCL12.pdf",
            "Examples": "importitertoolsasit\nfromnetworkx.utilsimportpairwise\npaths=[\n(1,2,4,3,1,4),\n(5,6,7,8,5,7,8,6),\n]\nG=nx.Graph()\nG.add_nodes_from(it.chain(*paths))\nG.add_edges_from(it.chain(*[pairwise(path)forpathinpaths]))\n# note this does not return {1, 4} unlike k_edge_components\nsorted(map(sorted,nx.k_edge_subgraphs(G,k=3)))\n# [[1], [2], [3], [4], [5, 6, 7, 8]]"
        }
    },
    {
        "Section ID": "nodes_equal",
        "Description": [
            "Check if nodes are equal.",
            "Equality here means equal as Python objects.\nNode data must match if included.\nThe order of nodes is not relevant."
        ],
        "Field List": {
            "Parameters:": {
                "nodes1, nodes2 : iterables of nodes, or (node, datadict) tuples": ""
            },
            "Returns:": {
                "bool": "True if nodes are equal, False otherwise."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "add_star",
        "Description": [
            "Add a star to Graph G_to_add_to.",
            "The first node in nodes_for_star is the middle of the star.\nIt is connected to all other nodes."
        ],
        "Field List": {
            "Parameters:": {
                "G_to_add_to : graph": "A NetworkX graph",
                "nodes_for_star : iterable container": "A container of nodes.",
                "attr : keyword arguments, optional (default= no attributes)": "Attributes to add to every edge in star."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph()\nnx.add_star(G,[0,1,2,3])\nnx.add_star(G,[10,11,12],weight=2)"
        }
    },
    {
        "Section ID": "octahedral_graph",
        "Description": [
            "Returns the Platonic Octahedral graph.",
            "The octahedral graph is the 6-node 12-edge Platonic graph having the\nconnectivity of the octahedron [1] . If 6 couples go to a party,\nand each person shakes hands with every person except his or her partner,\nthen this graph describes the set of handshakes that take place;\nfor this reason it is also called the cocktail party graph [2] ."
        ],
        "Field List": {
            "Parameters:": {
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : networkx Graph": "Octahedral graph"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://mathworld.wolfram.com/OctahedralGraph.html  [2]https://en.wikipedia.org/wiki/Tur%C3%A1n_graph#Special_cases"
        }
    },
    {
        "Section ID": "full_rary_tree",
        "Description": [
            "Creates a full r-ary tree of n nodes.",
            "Sometimes called a k-ary, n-ary, or m-ary tree.\n\u201c\u2026 all non-leaf nodes have exactly r children and all levels\nare full except for some rightmost position of the bottom level\n(if a leaf at the bottom level is missing, then so are all of the\nleaves to its right.\u201d [1]",
            "( Sourcecode , png )"
        ],
        "Field List": {
            "Parameters:": {
                "r : int": "branching factor of the tree",
                "n : int": "Number of nodes in the tree",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : networkx Graph": "An r-ary tree with n nodes"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]An introduction to data structures and algorithms,\nJames Andrew Storer,  Birkhauser Boston 2001, (page 225)."
        }
    },
    {
        "Section ID": "draw_networkx_edge_labels",
        "Description": [
            "Draw edge labels."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph",
                "pos : dictionary": "A dictionary with nodes as keys and positions as values.\nPositions should be sequences of length 2.",
                "edge_labels : dictionary (default=None)": "Edge labels in a dictionary of labels keyed by edge two-tuple.\nOnly labels for the keys in the dictionary are drawn.",
                "label_pos : float (default=0.5)": "Position of edge label along edge (0=head, 0.5=center, 1=tail)",
                "font_size : int (default=10)": "Font size for text labels",
                "font_color : color (default=\u2019k\u2019 black)": "Font color string. Color can be string or rgb (or rgba) tuple of\nfloats from 0-1.",
                "font_weight : string (default=\u2019normal\u2019)": "Font weight",
                "font_family : string (default=\u2019sans-serif\u2019)": "Font family",
                "alpha : float or None (default=None)": "The text transparency",
                "bbox : Matplotlib bbox, optional": "Specify text box properties (e.g. shape, color etc.) for edge labels.\nDefault is {boxstyle=\u2019round\u2019, ec=(1.0, 1.0, 1.0), fc=(1.0, 1.0, 1.0)}.",
                "horizontalalignment : string (default=\u2019center\u2019)": "Horizontal alignment {\u2018center\u2019, \u2018right\u2019, \u2018left\u2019}",
                "verticalalignment : string (default=\u2019center\u2019)": "Vertical alignment {\u2018center\u2019, \u2018top\u2019, \u2018bottom\u2019, \u2018baseline\u2019, \u2018center_baseline\u2019}",
                "ax : Matplotlib Axes object, optional": "Draw the graph in the specified Matplotlib axes.",
                "rotate : bool (default=True)": "Rotate edge labels to lie parallel to edges",
                "clip_on : bool (default=True)": "Turn on clipping of edge labels at axis boundaries",
                "node_size : scalar or array (default=300)": "Size of nodes.  If an array it must be the same length as nodelist.",
                "nodelist : list, optional (default=G.nodes())": "This provides the node order for thenode_sizearray (if it is an array).",
                "connectionstyle : string or iterable of strings (default=\u201darc3\u201d)": "Pass the connectionstyle parameter to create curved arc of rounding\nradius rad. For example, connectionstyle=\u2019arc3,rad=0.2\u2019.\nSeematplotlib.patches.ConnectionStyleandmatplotlib.patches.FancyArrowPatchfor more info.\nIf Iterable, index indicates i\u2019th edge key of MultiGraph",
                "hide_ticks : bool, optional": "Hide ticks of axes. WhenTrue(the default), ticks and ticklabels\nare removed from the axes. To set ticks and tick labels to the pyplot default,\nusehide_ticks=False."
            },
            "Returns:": {
                "dict": "dictof labels keyed by edge"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.dodecahedral_graph()\nedge_labels=nx.draw_networkx_edge_labels(G,pos=nx.spring_layout(G))\nAlso see the NetworkX drawing examples athttps://networkx.org/documentation/latest/auto_examples/index.html"
        }
    },
    {
        "Section ID": "stochastic_graph",
        "Description": [
            "Returns a right-stochastic representation of directed graph G .",
            "A right-stochastic graph is a weighted digraph in which for each\nnode, the sum of the weights of all the out-edges of that node is\n1. If the graph is already weighted (for example, via a \u2018weight\u2019\nedge attribute), the reweighting takes that into account."
        ],
        "Field List": {
            "Parameters:": {
                "G : directed graph": "ADiGraphorMultiDiGraph.",
                "copy : boolean, optional": "If this is True, then this function returns a new graph with\nthe stochastic reweighting. Otherwise, the original graph is\nmodified in-place (and also returned, for convenience).",
                "weight : edge attribute key (optional, default=\u2019weight\u2019)": "Edge attribute key used for reading the existing weight and\nsetting the new weight.  If no attribute with this key is found\nfor an edge, then the edge weight is assumed to be 1. If an edge\nhas a weight, it must be a positive number."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "grid_graph",
        "Description": [
            "Returns the n -dimensional grid graph.",
            "The dimension n is the length of the list dim and the size in\neach dimension is the value of the corresponding list element."
        ],
        "Field List": {
            "Parameters:": {
                "dim : list or tuple of numbers or iterables of nodes": "\u2018dim\u2019 is a tuple or list with, for each dimension, either a number\nthat is the size of that dimension or an iterable of nodes for\nthat dimension. The dimension of the grid_graph is the length\nofdim.",
                "periodic : bool or iterable": "Ifperiodicis True, all dimensions are periodic. If False all\ndimensions are not periodic. Ifperiodicis iterable, it should\nyielddimbool values each of which indicates whether the\ncorresponding axis is periodic."
            },
            "Returns:": {
                "NetworkX graph": "The (possibly periodic) grid graph of the specified dimensions."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "To produce a 2 by 3 by 4 grid graph, a graph on 24 nodes:\nfromnetworkximportgrid_graph\nG=grid_graph(dim=(2,3,4))\nlen(G)\n# 24\nG=grid_graph(dim=(range(7,9),range(3,6)))\nlen(G)\n# 6"
        }
    },
    {
        "Section ID": "dijkstra_path_length",
        "Description": [
            "Returns the shortest weighted path length in G from source to target.",
            "Uses Dijkstra\u2019s Method to compute the shortest weighted path length\nbetween two nodes in a graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node label": "starting node for path",
                "target : node label": "ending node for path",
                "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge."
            },
            "Returns:": {
                "length : number": "Shortest path length."
            },
            "Raises:": {
                "NodeNotFound": "Ifsourceis not inG.",
                "NetworkXNoPath": "If no path exists between source and target."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The weight function can be used to hide edges by returning None.\nSo weight=lambdau,v,d:1ifd['color']==\"red\"elseNone will find the shortest red path. The function single_source_dijkstra() computes both\npath and length-of-path if you need both, use that.",
            "Examples": "G=nx.path_graph(5)\nnx.dijkstra_path_length(G,0,4)\n# 4"
        }
    },
    {
        "Section ID": "relabel_gexf_graph",
        "Description": [
            "Relabel graph using \u201clabel\u201d node keyword for node label."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph read from GEXF data"
            },
            "Returns:": {
                "H : graph": "A NetworkX graph with relabeled nodes"
            },
            "Raises:": {
                "NetworkXError": "If node labels are missing or not unique while relabel=True."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This function relabels the nodes in a NetworkX graph with the\n\u201clabel\u201d attribute.  It also handles relabeling the specific GEXF\nnode attributes \u201cparents\u201d, and \u201cpid\u201d."
        }
    },
    {
        "Section ID": "voterank",
        "Description": [
            "Select a list of influential nodes in a graph using VoteRank algorithm",
            "VoteRank [1] computes a ranking of the nodes in a graph G based on a\nvoting scheme. With VoteRank, all nodes vote for each of its in-neighbors\nand the node with the highest votes is elected iteratively. The voting\nability of out-neighbors of elected nodes is decreased in subsequent turns."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.",
                "number_of_nodes : integer, optional": "Number of ranked nodes to extract (default all nodes)."
            },
            "Returns:": {
                "voterank : list": "Ordered list of computed seeds.\nOnly nodes with positive number of votes are returned."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Each edge is treated independently in case of multigraphs.",
            "References": "[1]Zhang, J.-X. et al. (2016).\nIdentifying a set of influential spreaders in complex networks.\nSci. Rep. 6, 27823; doi: 10.1038/srep27823.",
            "Examples": "G=nx.Graph([(0,1),(0,2),(0,3),(1,4)])\nnx.voterank(G)\n# [0, 1]\nThe algorithm can be used both for undirected and directed graphs.\nHowever, the directed version is different in two ways:\n(i) nodes only vote for their in-neighbors and\n(ii) only the voting ability of elected node and its out-neighbors are updated:\nG=nx.DiGraph([(0,1),(2,1),(2,3),(3,4)])\nnx.voterank(G)\n# [2, 3]"
        }
    },
    {
        "Section ID": "multi_source_dijkstra_path_length",
        "Description": [
            "Find shortest weighted path lengths in G from a given set of\nsource nodes.",
            "Compute the shortest path length between any of the source nodes and\nall other reachable nodes for a weighted graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "sources : non-empty set of nodes": "Starting nodes for paths. If this is just a set containing a\nsingle node, then all paths computed by this function will start\nfrom that node. If there are two or more nodes in the set, the\ncomputed paths may begin from any one of the start nodes.",
                "cutoff : integer or float, optional": "Length (sum of edge weights) at which the search is stopped.\nIf cutoff is provided, only return paths with summed weight <= cutoff.",
                "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge."
            },
            "Returns:": {
                "length : dict": "Dict keyed by node to shortest path length to nearest source."
            },
            "Raises:": {
                "ValueError": "Ifsourcesis empty.",
                "NodeNotFound": "If any ofsourcesis not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The weight function can be used to hide edges by returning None.\nSo weight=lambdau,v,d:1ifd['color']==\"red\"elseNone will find the shortest red path.",
            "Examples": "G=nx.path_graph(5)\nlength=nx.multi_source_dijkstra_path_length(G,{0,4})\nfornodein[0,1,2,3,4]:\nprint(f\"{node}: {length[node]}\")\n# 0: 0\n# 1: 1\n# 2: 2\n# 3: 1\n# 4: 0"
        }
    },
    {
        "Section ID": "is_tree",
        "Description": [
            "Returns True if G is a tree.",
            "A tree is a connected graph with no undirected cycles.",
            "For directed graphs, G is a tree if the underlying graph is a tree. The\nunderlying graph is obtained by treating each directed edge as a single\nundirected edge in a multigraph."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "The graph to test."
            },
            "Returns:": {
                "b : bool": "A boolean that is True ifGis a tree."
            },
            "Raises:": {
                "NetworkXPointlessConcept": "IfGis empty."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "In another convention, a directed tree is known as a polytree and then tree corresponds to an arborescence .",
            "Examples": "G=nx.Graph()\nG.add_edges_from([(1,2),(1,3),(2,4),(2,5)])\nnx.is_tree(G)# n-1 edges\n# True\nG.add_edge(3,4)\nnx.is_tree(G)# n edges\n# False"
        }
    },
    {
        "Section ID": "UnionAtlas",
        "Description": [
            "A read-only union of two atlases (dict-of-dict).",
            "The two dict-of-dicts represent the inner dict of\nan Adjacency: G.succ[node] and G.pred[node] .\nThe inner level of dict of both hold attribute key:value\npairs and is read-write. But the outer level is read-only."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "chordal_graph_cliques",
        "Description": [
            "Returns all maximal cliques of a chordal graph.",
            "The algorithm breaks the graph in connected components and performs a\nmaximum cardinality search in each component to get the cliques."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph"
            },
            "Yields:": {
                "frozenset of nodes": "Maximal cliques, each of which is a frozenset of\nnodes inG. The order of cliques is arbitrary."
            },
            "Raises:": {
                "NetworkXError": "The algorithm does not support DiGraph, MultiGraph and MultiDiGraph.\nThe algorithm can only be applied to chordal graphs. If the input\ngraph is found to be non-chordal, aNetworkXErroris raised."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "e=[\n(1,2),\n(1,3),\n(2,3),\n(2,4),\n(3,4),\n(3,5),\n(3,6),\n(4,5),\n(4,6),\n(5,6),\n(7,8),\n]\nG=nx.Graph(e)\nG.add_node(9)\ncliques=[cforcinchordal_graph_cliques(G)]\ncliques[0]\n# frozenset({1, 2, 3})"
        }
    },
    {
        "Section ID": "write_edgelist",
        "Description": [
            "Write a bipartite graph as a list of edges."
        ],
        "Field List": {
            "Parameters:": {
                "G : Graph": "A NetworkX bipartite graph",
                "path : file or string": "File or filename to write. If a file is provided, it must be\nopened in \u2018wb\u2019 mode. Filenames ending in .gz or .bz2 will be compressed.",
                "comments : string, optional": "The character used to indicate the start of a comment",
                "delimiter : string, optional": "The string used to separate values.  The default is whitespace.",
                "data : bool or list, optional": "If False write no edge data.\nIf True write a string representation of the edge data dictionary..\nIf a list (or other iterable) is provided, write the  keys specified\nin the list.",
                "encoding: string, optional": "Specify which encoding to use when writing file."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.path_graph(4)\nG.add_nodes_from([0,2],bipartite=0)\nG.add_nodes_from([1,3],bipartite=1)\nnx.write_edgelist(G,\"test.edgelist\")\nfh=open(\"test.edgelist\",\"wb\")\nnx.write_edgelist(G,fh)\nnx.write_edgelist(G,\"test.edgelist.gz\")\nnx.write_edgelist(G,\"test.edgelist.gz\",data=False)\nG=nx.Graph()\nG.add_edge(1,2,weight=7,color=\"red\")\nnx.write_edgelist(G,\"test.edgelist\",data=False)\nnx.write_edgelist(G,\"test.edgelist\",data=[\"color\"])\nnx.write_edgelist(G,\"test.edgelist\",data=[\"color\",\"weight\"])"
        }
    },
    {
        "Section ID": "generic_weighted_projected_graph",
        "Description": [
            "Weighted projection of B with a user-specified weight function.",
            "The bipartite network B is projected on to the specified nodes\nwith weights computed by a user-specified function.  This function\nmust accept as a parameter the neighborhood sets of two nodes and\nreturn an integer or a float.",
            "The nodes retain their attributes and are connected in the resulting graph\nif they have an edge to a common node in the original graph."
        ],
        "Field List": {
            "Parameters:": {
                "B : NetworkX graph": "The input graph should be bipartite.",
                "nodes : list or iterable": "Nodes to project onto (the \u201cbottom\u201d nodes).",
                "weight_function : function": "This function must accept as parameters the same input graph\nthat this function, and two nodes; and return an integer or a float.\nThe default function computes the number of shared neighbors."
            },
            "Returns:": {
                "Graph : NetworkX graph": "A graph that is the projection onto the given nodes."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "No attempt is made to verify that the input graph B is bipartite.\nThe graph and node properties are (shallow) copied to the projected graph. See bipartitedocumentation for further details on how bipartite graphs are handled in NetworkX.",
            "Examples": "fromnetworkx.algorithmsimportbipartite\n# Define some custom weight functions\ndefjaccard(G,u,v):\nunbrs=set(G[u])\nvnbrs=set(G[v])\nreturnfloat(len(unbrs&vnbrs))/len(unbrs|vnbrs)\ndefmy_weight(G,u,v,weight=\"weight\"):\nw=0\nfornbrinset(G[u])&set(G[v]):\nw+=G[u][nbr].get(weight,1)+G[v][nbr].get(weight,1)\nreturnw\n# A complete bipartite graph with 4 nodes and 4 edges\nB=nx.complete_bipartite_graph(2,2)\n# Add some arbitrary weight to the edges\nfori,(u,v)inenumerate(B.edges()):\nB.edges[u,v][\"weight\"]=i+1\nforedgeinB.edges(data=True):\nprint(edge)\n# (0, 2, {'weight': 1})\n# (0, 3, {'weight': 2})\n# (1, 2, {'weight': 3})\n# (1, 3, {'weight': 4})\n# By default, the weight is the number of shared neighbors\nG=bipartite.generic_weighted_projected_graph(B,[0,1])\nprint(list(G.edges(data=True)))\n# [(0, 1, {'weight': 2})]\n# To specify a custom weight function use the weight_function parameter\nG=bipartite.generic_weighted_projected_graph(B,[0,1],weight_function=jaccard)\nprint(list(G.edges(data=True)))\n# [(0, 1, {'weight': 1.0})]\nG=bipartite.generic_weighted_projected_graph(B,[0,1],weight_function=my_weight)\nprint(list(G.edges(data=True)))\n# [(0, 1, {'weight': 10})]"
        }
    },
    {
        "Section ID": "nonisomorphic_trees",
        "Description": [
            "Generates lists of nonisomorphic trees"
        ],
        "Field List": {
            "Parameters:": {
                "order : int": "order of the desired tree(s)",
                "create : one of {\u201cgraph\u201d, \u201cmatrix\u201d} (default=\u201dgraph\u201d)": "If\"graph\"is selected a list ofGraphinstances will be returned,\nif matrix is selected a list of adjacency matrices will be returned.Deprecated since version 3.3:Thecreateargument is deprecated and will be removed in NetworkX\nversion 3.5. In the future,nonisomorphic_treeswill yield graph\ninstances by default. To generate adjacency matrices, callnx.to_numpy_arrayon the output, e.g.:[nx.to_numpy_array(G)forGinnx.nonisomorphic_trees(N)]"
            },
            "Yields:": {
                "list": "A list of nonisomorphic trees, in one of two formats depending on the\nvalue of thecreateparameter:\n-create=\"graph\": yields a list ofnetworkx.Graphinstances\n-create=\"matrix\": yields a list of list-of-lists representing adjacency matrices"
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "center",
        "Description": [
            "Returns the center of the graph G.",
            "The center is the set of nodes with eccentricity equal to radius."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A graph",
                "e : eccentricity dictionary, optional": "A precomputed dictionary of eccentricities.",
                "weight : string, function, or None": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number.If this is None, every edge has weight/distance/cost 1.Weights stored as floating point values can lead to small round-off\nerrors in distances. Use integer weights to avoid this.Weights should be positive, since they are distances."
            },
            "Returns:": {
                "c : list": "List of nodes in center"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph([(1,2),(1,3),(1,4),(3,4),(3,5),(4,5)])\nlist(nx.center(G))\n# [1, 3, 4]"
        }
    },
    {
        "Section ID": "is_perfect_matching",
        "Description": [
            "Return True if matching is a perfect matching for G",
            "A perfect matching in a graph is a matching in which exactly one edge\nis incident upon each vertex."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "matching : dict or set": "A dictionary or set representing a matching. If a dictionary, it\nmust havematching[u]==vandmatching[v]==ufor each\nedge(u,v)in the matching. If a set, it must have elements\nof the form(u,v), where(u,v)is an edge in the\nmatching."
            },
            "Returns:": {
                "bool": "Whether the given set or dictionary represents a valid perfect\nmatching in the graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph([(1,2),(1,3),(2,3),(2,4),(3,5),(4,5),(4,6)])\nmy_match={1:2,3:5,4:6}\nnx.is_perfect_matching(G,my_match)\n# True"
        }
    },
    {
        "Section ID": "all_pairs_dijkstra_path",
        "Description": [
            "Compute shortest paths between all nodes in a weighted graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "cutoff : integer or float, optional": "Length (sum of edge weights) at which the search is stopped.\nIf cutoff is provided, only return paths with summed weight <= cutoff.",
                "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge."
            },
            "Returns:": {
                "paths : iterator": "(source, dictionary) iterator with dictionary keyed by target and\nshortest path as the key value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.",
            "Examples": "G=nx.path_graph(5)\npath=dict(nx.all_pairs_dijkstra_path(G))\npath[0][4]\n# [0, 1, 2, 3, 4]"
        }
    },
    {
        "Section ID": "tensor_product",
        "Description": [
            "Returns the tensor product of G and H.",
            "The tensor product \\(P\\) of the graphs \\(G\\) and \\(H\\) has a node set that\nis the Cartesian product of the node sets, \\(V(P)=V(G) \\times V(H)\\) . \\(P\\) has an edge \\(((u,v), (x,y))\\) if and only if \\((u,x)\\) is an edge in \\(G\\) and \\((v,y)\\) is an edge in \\(H\\) .",
            "Tensor product is sometimes also referred to as the categorical product,\ndirect product, cardinal product or conjunction."
        ],
        "Field List": {
            "Parameters:": {
                "G, H: graphs": "Networkx graphs."
            },
            "Returns:": {
                "P: NetworkX graph": "The tensor product of G and H. P will be a multi-graph if either G\nor H is a multi-graph, will be a directed if G and H are directed,\nand undirected if G and H are undirected."
            },
            "Raises:": {
                "NetworkXError": "If G and H are not both directed or both undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Node attributes in P are two-tuple of the G and H node attributes.\nMissing attributes are assigned None.",
            "Examples": "G=nx.Graph()\nH=nx.Graph()\nG.add_node(0,a1=True)\nH.add_node(\"a\",a2=\"Spam\")\nP=nx.tensor_product(G,H)\nlist(P)\n# [(0, 'a')]\nEdge attributes and edge keys (for multigraphs) are also copied to the\nnew product graph"
        }
    },
    {
        "Section ID": "random_tournament",
        "Description": [
            "Returns a random tournament graph on n nodes."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes in the returned graph.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "G : DiGraph": "A tournament onnnodes, with exactly one directed edge joining\neach pair of distinct nodes."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm adds, for each pair of distinct nodes, an edge with\nuniformly random orientation. In other words, binom{n}{2} flips\nof an unbiased coin decide the orientations of the edges in the\ngraph."
        }
    },
    {
        "Section ID": "directed_joint_degree_graph",
        "Description": [
            "Generates a random simple directed graph with the joint degree."
        ],
        "Field List": {
            "Parameters:": {
                "degree_seq : list of tuples (of size 3)": "degree sequence contains tuples of nodes with node id, in degree and\nout degree.",
                "nkk : dictionary of dictionary of integers": "directed joint degree dictionary, for nodes of out degree k (first\nlevel of dict) and nodes of in degree l (second level of dict)\ndescribes the number of edges.",
                "seed : hashable object, optional": "Seed for random number generator."
            },
            "Returns:": {
                "G : Graph": "A directed graph with the specified inputs."
            },
            "Raises:": {
                "NetworkXError": "If degree_seq and nkk are not realizable as a simple directed graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Similarly to the undirected version:\nIn each iteration of the \u201cwhile loop\u201d the algorithm picks two disconnected\nnodes v and w, of degree k and l correspondingly,  for which nkk[k][l] has\nnot reached its target yet i.e. (for given k,l): n_edges_add < nkk[k][l].\nIt then adds edge (v,w) and always increases the number of edges in graph G\nby one. The intelligence of the algorithm lies in the fact that  it is always\npossible to add an edge between disconnected nodes v and w, for which\nnkk[degree(v)][degree(w)] has not reached its target, even if one or both\nnodes do not have free stubs. If either node v or w does not have a free\nstub, we perform a \u201cneighbor switch\u201d, an edge rewiring move that releases a\nfree stub while keeping nkk the same. The difference for the directed version lies in the fact that neighbor\nswitches might not be able to rewire, but in these cases unsaturated nodes\ncan be reassigned to use instead, see [1] for detailed description and\nproofs. The algorithm continues for E (number of edges in the graph) iterations of\nthe \u201cwhile loop\u201d, at which point all entries of the given nkk[k][l] have\nreached their target values and the construction is complete.",
            "References": "[1] B. Tillman, A. Markopoulou, C. T. Butts & M. Gjoka, \u201cConstruction of Directed 2K Graphs\u201d. In Proc. of KDD 2017.",
            "Examples": "in_degrees=[0,1,1,2]\nout_degrees=[1,1,1,1]\nnkk={1:{1:2,2:2}}\nG=nx.directed_joint_degree_graph(in_degrees,out_degrees,nkk)"
        }
    },
    {
        "Section ID": "florentine_families_graph",
        "Description": [
            "Returns Florentine families graph.",
            "References"
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Ronald L. Breiger and Philippa E. Pattison\nCumulated social roles: The duality of persons and their algebras,1\nSocial Networks, Volume 8, Issue 3, September 1986, Pages 215-256"
        }
    },
    {
        "Section ID": "generic_bfs_edges",
        "Description": [
            "Iterate over edges in a breadth-first search.",
            "The breadth-first search begins at source and enqueues the\nneighbors of newly visited nodes specified by the neighbors function."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node": "Starting node for the breadth-first search; this function\niterates over only those edges in the component reachable from\nthis node.",
                "neighbors : function": "A function that takes a newly visited node of the graph as input\nand returns aniterator(not just a list) of nodes that are\nneighbors of that node with custom ordering. If not specified, this is\njust theG.neighborsmethod, but in general it can be any function\nthat returns an iterator over some or all of the neighbors of a\ngiven node, in any order.",
                "depth_limit : int, optional(default=len(G))": "Specify the maximum search depth.",
                "sort_neighbors : Callable (default=None)": "Deprecated since version 3.2:The sort_neighbors parameter is deprecated and will be removed in\nversion 3.4. A custom (e.g. sorted) ordering of neighbors can be\nspecified with theneighborsparameter.A function that takes an iterator over nodes as the input, and\nreturns an iterable of the same nodes with a custom ordering.\nFor example,sortedwill sort the nodes in increasing order."
            },
            "Yields:": {
                "edge": "Edges in the breadth-first search starting fromsource."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This implementation is from PADS , which was in the public domain\nwhen it was first accessed in July, 2004.  The modifications\nto allow depth limits are based on the Wikipedia article\n\u201c Depth-limited-search \u201d.",
            "Examples": "G=nx.path_graph(7)\nlist(nx.generic_bfs_edges(G,source=0))\n# [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]\nlist(nx.generic_bfs_edges(G,source=2))\n# [(2, 1), (2, 3), (1, 0), (3, 4), (4, 5), (5, 6)]\nlist(nx.generic_bfs_edges(G,source=2,depth_limit=2))\n# [(2, 1), (2, 3), (1, 0), (3, 4)]\nTheneighborsparam can be used to specify the visitation order of each\nnode\u2019s neighbors generically. In the following example, we modify the default\nneighbor to returnoddnodes first:\ndefodd_first(n):\nreturnsorted(G.neighbors(n),key=lambdax:x%2,reverse=True)\nG=nx.star_graph(5)\nlist(nx.generic_bfs_edges(G,source=0))# Default neighbor ordering\n# [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5)]\nlist(nx.generic_bfs_edges(G,source=0,neighbors=odd_first))\n# [(0, 1), (0, 3), (0, 5), (0, 2), (0, 4)]"
        }
    },
    {
        "Section ID": "read_pajek",
        "Description": [
            "Read graph in Pajek format from path."
        ],
        "Field List": {
            "Parameters:": {
                "path : file or string": "File or filename to write.\nFilenames ending in .gz or .bz2 will be uncompressed."
            },
            "Returns:": {
                "G : NetworkX MultiGraph or MultiDiGraph.": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "See http://vlado.fmf.uni-lj.si/pub/networks/pajek/doc/draweps.htm for format information.",
            "Examples": "G=nx.path_graph(4)\nnx.write_pajek(G,\"test.net\")\nG=nx.read_pajek(\"test.net\")\nTo create a Graph instead of a MultiGraph use\nG1=nx.Graph(G)"
        }
    },
    {
        "Section ID": "attribute_assortativity_coefficient",
        "Description": [
            "Compute assortativity for node attributes.",
            "Assortativity measures the similarity of connections\nin the graph with respect to the given attribute."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "attribute : string": "Node attribute key",
                "nodes: list or iterable (optional)": "Compute attribute assortativity for nodes in container.\nThe default is all nodes."
            },
            "Returns:": {
                "r: float": "Assortativity of graph for given attribute"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This computes Eq. (2) in Ref. [1] , (trace(M)-sum(M^2))/(1-sum(M^2)),\nwhere M is the joint probability distribution (mixing matrix)\nof the specified attribute.",
            "References": "[1]M. E. J. Newman, Mixing patterns in networks,\nPhysical Review E, 67 026126, 2003",
            "Examples": "G=nx.Graph()\nG.add_nodes_from([0,1],color=\"red\")\nG.add_nodes_from([2,3],color=\"blue\")\nG.add_edges_from([(0,1),(2,3)])\nprint(nx.attribute_assortativity_coefficient(G,\"color\"))\n# 1.0"
        }
    },
    {
        "Section ID": "density",
        "Description": [
            "Returns density of bipartite graph B."
        ],
        "Field List": {
            "Parameters:": {
                "B : NetworkX graph": "",
                "nodes: list or container": "Nodes in one node set of the bipartite graph."
            },
            "Returns:": {
                "d : float": "The bipartite density"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The container of nodes passed as argument must contain all nodes\nin one of the two bipartite node sets to avoid ambiguity in the\ncase of disconnected graphs.\nSee bipartitedocumentation for further details on how bipartite graphs are handled in NetworkX.",
            "Examples": "fromnetworkx.algorithmsimportbipartite\nG=nx.complete_bipartite_graph(3,2)\nX=set([0,1,2])\nbipartite.density(G,X)\n# 1.0\nY=set([3,4])\nbipartite.density(G,Y)\n# 1.0"
        }
    },
    {
        "Section ID": "get_edge_attributes",
        "Description": [
            "Get edge attributes from graph"
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "",
                "name : string": "Attribute name",
                "default: object (default=None)": "Default value of the edge attribute if there is no value set for that\nedge in graph. IfNonethen edges without this attribute are not\nincluded in the returned dict."
            },
            "Returns:": {
                "Dictionary of attributes keyed by edge. For (di)graphs, the keys are": "",
                "2-tuples of the form: (u, v). For multi(di)graphs, the keys are 3-tuples of": "",
                "the form: (u, v, key).": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph()\nnx.add_path(G,[1,2,3],color=\"red\")\ncolor=nx.get_edge_attributes(G,\"color\")\ncolor[(1,2)]\n# 'red'\nG.add_edge(3,4)\ncolor=nx.get_edge_attributes(G,\"color\",default=\"yellow\")\ncolor[(3,4)]\n# 'yellow'"
        }
    },
    {
        "Section ID": "scale_free_graph",
        "Description": [
            "Returns a scale-free directed graph."
        ],
        "Field List": {
            "Parameters:": {
                "n : integer": "Number of nodes in graph",
                "alpha : float": "Probability for adding a new node connected to an existing node\nchosen randomly according to the in-degree distribution.",
                "beta : float": "Probability for adding an edge between two existing nodes.\nOne existing node is chosen randomly according the in-degree\ndistribution and the other chosen randomly according to the out-degree\ndistribution.",
                "gamma : float": "Probability for adding a new node connected to an existing node\nchosen randomly according to the out-degree distribution.",
                "delta_in : float": "Bias for choosing nodes from in-degree distribution.",
                "delta_out : float": "Bias for choosing nodes from out-degree distribution.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "initial_graph : MultiDiGraph instance, optional": "Build the scale-free graph starting from this initial MultiDiGraph,\nif provided."
            },
            "Returns:": {
                "MultiDiGraph": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The sum of alpha , beta , and gamma must be 1.",
            "References": "[1]B. Bollob\u00e1s, C. Borgs, J. Chayes, and O. Riordan,\nDirected scale-free graphs,\nProceedings of the fourteenth annual ACM-SIAM Symposium on\nDiscrete Algorithms, 132\u2013139, 2003.",
            "Examples": "Create a scale-free graph on one hundred nodes:\nG=nx.scale_free_graph(100)"
        }
    },
    {
        "Section ID": "rich_club_coefficient",
        "Description": [
            "Returns the rich-club coefficient of the graph G .",
            "For each degree k , the rich-club coefficient is the ratio of the\nnumber of actual to the number of potential edges for nodes with\ndegree greater than k :",
            "where N_k is the number of nodes with degree larger than k , and E_k is the number of edges among those nodes."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected graph with neither parallel edges nor self-loops.",
                "normalized : bool (optional)": "Normalize using randomized network as in[1]",
                "Q : float (optional, default=100)": "Ifnormalizedis True, performQ*mdouble-edge\nswaps, wheremis the number of edges inG, to use as a\nnull-model for normalization.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "rc : dictionary": "A dictionary, keyed by degree, with rich-club coefficient values."
            },
            "Raises:": {
                "NetworkXError": "IfGhas fewer than four nodes andnormalized=True.\nA randomly sampled graph for normalization cannot be generated in this case."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The rich club definition and algorithm are found in [1] .  This\nalgorithm ignores any edge weights and is not defined for directed\ngraphs or graphs with parallel edges or self loops. Normalization is done by computing the rich club coefficient for a randomly\nsampled graph with the same degree distribution as G by\nrepeatedly swapping the endpoints of existing edges. For graphs with fewer than 4\nnodes, it is not possible to generate a random graph with a prescribed\ndegree distribution, as the degree distribution fully determines the graph\n(hence making the coefficients trivially normalized to 1).\nThis function raises an exception in this case. Estimates for appropriate values of Q are found in [2] .",
            "References": "[1](1,2)Julian J. McAuley, Luciano da Fontoura Costa,\nand Tib\u00e9rio S. Caetano,\n\u201cThe rich-club phenomenon across complex network hierarchies\u201d,\nApplied Physics Letters Vol 91 Issue 8, August 2007.https://arxiv.org/abs/physics/0701290  [2]R. Milo, N. Kashtan, S. Itzkovitz, M. E. J. Newman, U. Alon,\n\u201cUniform generation of random graphs with arbitrary degree\nsequences\u201d, 2006.https://arxiv.org/abs/cond-mat/0312028",
            "Examples": "G=nx.Graph([(0,1),(0,2),(1,2),(1,3),(1,4),(4,5)])\nrc=nx.rich_club_coefficient(G,normalized=False,seed=42)\nrc[0]\n# 0.4"
        }
    },
    {
        "Section ID": "clustering",
        "Description": [
            "Compute the clustering coefficient for nodes.",
            "For unweighted graphs, the clustering of a node \\(u\\) is the fraction of possible triangles through that node that exist,",
            "where \\(T(u)\\) is the number of triangles through node \\(u\\) and \\(deg(u)\\) is the degree of \\(u\\) .",
            "For weighted graphs, there are several ways to define clustering [1] .\nthe one used here is defined\nas the geometric average of the subgraph edge weights [2] ,",
            "The edge weights \\(\\hat{w}_{uv}\\) are normalized by the maximum weight\nin the network \\(\\hat{w}_{uv} = w_{uv}/\\max(w)\\) .",
            "The value of \\(c_u\\) is assigned to 0 if \\(deg(u) < 2\\) .",
            "Additionally, this weighted definition has been generalized to support negative edge weights [3] .",
            "For directed graphs, the clustering is similarly defined as the fraction\nof all possible directed triangles or geometric average of the subgraph\nedge weights for unweighted and weighted directed graph respectively [4] .",
            "where \\(T(u)\\) is the number of directed triangles through node \\(u\\) , \\(deg^{tot}(u)\\) is the sum of in degree and out degree of \\(u\\) and \\(deg^{\\leftrightarrow}(u)\\) is the reciprocal degree of \\(u\\) ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "",
                "nodes : node, iterable of nodes, or None (default=None)": "If a singleton node, return the number of triangles for that node.\nIf an iterable, compute the number of triangles for each of those nodes.\nIfNone(the default) compute the number of triangles for all nodes inG.",
                "weight : string or None, optional (default=None)": "The edge attribute that holds the numerical value used as a weight.\nIf None, then each edge has weight 1."
            },
            "Returns:": {
                "out : float, or dictionary": "Clustering coefficient at specified nodes"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Self loops are ignored.",
            "References": "[1]Generalizations of the clustering coefficient to weighted\ncomplex networks by J. Saram\u00e4ki, M. Kivel\u00e4, J.-P. Onnela,\nK. Kaski, and J. Kert\u00e9sz, Physical Review E, 75 027105 (2007).http://jponnela.com/web_documents/a9.pdf  [2]Intensity and coherence of motifs in weighted complex\nnetworks by J. P. Onnela, J. Saram\u00e4ki, J. Kert\u00e9sz, and K. Kaski,\nPhysical Review E, 71(6), 065103 (2005).  [3]Generalization of Clustering Coefficients to Signed Correlation Networks\nby G. Costantini and M. Perugini, PloS one, 9(2), e88669 (2014).  [4]Clustering in complex directed networks by G. Fagiolo,\nPhysical Review E, 76(2), 026107 (2007).",
            "Examples": "G=nx.complete_graph(5)\nprint(nx.clustering(G,0))\n# 1.0\nprint(nx.clustering(G))\n# {0: 1.0, 1: 1.0, 2: 1.0, 3: 1.0, 4: 1.0}"
        }
    },
    {
        "Section ID": "show_diedges",
        "Description": [
            "Returns a filter function that shows specific directed edges."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "read_graph6",
        "Description": [
            "Read simple undirected graphs in graph6 format from path."
        ],
        "Field List": {
            "Parameters:": {
                "path : file or string": "File or filename to write."
            },
            "Returns:": {
                "G : Graph or list of Graphs": "If the file contains multiple lines then a list of graphs is returned"
            },
            "Raises:": {
                "NetworkXError": "If the string is unable to be parsed in graph6 format"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Graph6 specification\n<http://users.cecs.anu.edu.au/~bdm/data/formats.html>",
            "Examples": "You can read a graph6 file by giving the path to the file:\nimporttempfile\nwithtempfile.NamedTemporaryFile(delete=False)asf:\n_=f.write(b\">>graph6<<A_\\n\")\n_=f.seek(0)\nG=nx.read_graph6(f.name)\nlist(G.edges())\n# [(0, 1)]\nYou can also read a graph6 file by giving an open file-like object:\nimporttempfile\nwithtempfile.NamedTemporaryFile()asf:\n_=f.write(b\">>graph6<<A_\\n\")\n_=f.seek(0)\nG=nx.read_graph6(f)\nlist(G.edges())\n# [(0, 1)]"
        }
    },
    {
        "Section ID": "lattice_reference",
        "Description": [
            "Latticize the given graph by swapping edges."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "An undirected graph.",
                "niter : integer (optional, default=1)": "An edge is rewired approximately niter times.",
                "D : numpy.array (optional, default=None)": "Distance to the diagonal matrix.",
                "connectivity : boolean (optional, default=True)": "Ensure connectivity for the latticized graph when set to True.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "G : graph": "The latticized graph."
            },
            "Raises:": {
                "NetworkXError": "If there are fewer than 4 nodes or 2 edges inG"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The implementation is adapted from the algorithm by Sporns et al. [1] .\nwhich is inspired from the original work by Maslov and Sneppen(2002) [2] .",
            "References": "[1]Sporns, Olaf, and Jonathan D. Zwi.\n\u201cThe small world of the cerebral cortex.\u201d\nNeuroinformatics 2.2 (2004): 145-162.  [2]Maslov, Sergei, and Kim Sneppen.\n\u201cSpecificity and stability in topology of protein networks.\u201d\nScience 296.5569 (2002): 910-913."
        }
    },
    {
        "Section ID": "random_labeled_tree",
        "Description": [
            "Returns a labeled tree on n nodes chosen uniformly at random.",
            "Generating uniformly distributed random Pr\u00fcfer sequences and\nconverting them into the corresponding trees is a straightforward\nmethod of generating uniformly distributed random labeled trees.\nThis function implements this method."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes, greater than zero.",
                "seed : random_state": "Indicator of random number generation state.\nSeeRandomness"
            },
            "Returns:": {
                "networkx.Graph": "Anetworkx.Graphwith nodes in the set {0, \u2026,n- 1}."
            },
            "Raises:": {
                "NetworkXPointlessConcept": "Ifnis zero (because the null graph is not a tree)."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "trivial_graph",
        "Description": [
            "Return the Trivial graph with one node (with label 0) and no edges.",
            "( Sourcecode , png )"
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "general_random_intersection_graph",
        "Description": [
            "Returns a random intersection graph with independent probabilities\nfor connections between node and attribute sets."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes in the first bipartite set (nodes)",
                "m : int": "The number of nodes in the second bipartite set (attributes)",
                "p : list of floats of length m": "Probabilities for connecting nodes to each attribute",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Nikoletseas, S. E., Raptopoulos, C., and Spirakis, P. G.\nThe existence and efficient construction of large independent sets\nin general random intersection graphs. In ICALP (2004), J. D\u00b4\u0131az,\nJ. Karhum\u00a8aki, A. Lepist\u00a8o, and D. Sannella, Eds., vol. 3142\nof Lecture Notes in Computer Science, Springer, pp. 1029\u20131040."
        }
    },
    {
        "Section ID": "wheel_graph",
        "Description": [
            "Return the wheel graph",
            "The wheel graph consists of a hub node connected to a cycle of (n-1) nodes.",
            "( Sourcecode , png )"
        ],
        "Field List": {
            "Parameters:": {
                "n : int or iterable": "If an integer, node labels are 0 to n with center 0.\nIf an iterable of nodes, the center is the first.\nWarning: n is not checked for duplicates and if present the\nresulting graph may not be as desired. Make sure you have no duplicates.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated.",
                "Node labels are the integers 0 to n - 1.": ""
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "is_directed_acyclic_graph",
        "Description": [
            "Returns True if the graph G is a directed acyclic graph (DAG) or\nFalse if not."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": ""
            },
            "Returns:": {
                "bool": "True ifGis a DAG, False otherwise"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "Undirected graph:\nG=nx.Graph([(1,2),(2,3)])\nnx.is_directed_acyclic_graph(G)\n# False\nDirected graph with cycle:\nG=nx.DiGraph([(1,2),(2,3),(3,1)])\nnx.is_directed_acyclic_graph(G)\n# False\nDirected acyclic graph:\nG=nx.DiGraph([(1,2),(2,3)])\nnx.is_directed_acyclic_graph(G)\n# True"
        }
    },
    {
        "Section ID": "AdjacencyView",
        "Description": [
            "An AdjacencyView is a Read-only Map of Maps of Maps.",
            "It is a View into a dict-of-dict-of-dict data structure.\nThe inner level of dict is read-write. But the\nouter levels are read-only."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "graph_atlas",
        "Description": [
            "Returns graph number i from the Graph Atlas.",
            "For more information, see graph_atlas_g() ."
        ],
        "Field List": {
            "Parameters:": {
                "i : int": "The index of the graph from the atlas to get. The graph at index\n0 is assumed to be the null graph."
            },
            "Returns:": {
                "list": "A list ofGraphobjects, the one at indexicorresponding to the graphiin the Graph Atlas."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The time required by this function increases linearly with the\nargument i , since it reads a large file sequentially in order to\ngenerate the graph [1] .",
            "References": "[1]Ronald C. Read and Robin J. Wilson,An Atlas of Graphs.\nOxford University Press, 1998."
        }
    },
    {
        "Section ID": "max_clique",
        "Description": [
            "Find the Maximum Clique",
            "Finds the \\(O(|V|/(log|V|)^2)\\) apx of maximum clique/independent set\nin the worst case."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected graph"
            },
            "Returns:": {
                "clique : set": "The apx-maximum clique of the graph"
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the graph is directed or is a multigraph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "A clique in an undirected graph G = (V, E) is a subset of the vertex set CsubseteqV such that for every two vertices in C there exists an edge\nconnecting the two. This is equivalent to saying that the subgraph\ninduced by C is complete (in some cases, the term clique may also refer\nto the subgraph). A maximum clique is a clique of the largest possible size in a given graph.\nThe clique number omega(G) of a graph G is the number of\nvertices in a maximum clique in G. The intersection number of\nG is the smallest number of cliques that together cover all edges of G. https://en.wikipedia.org/wiki/Maximum_clique",
            "References": "[1]Boppana, R., & Halld\u00f3rsson, M. M. (1992).\nApproximating maximum independent sets by excluding subgraphs.\nBIT Numerical Mathematics, 32(2), 180\u2013196. Springer.\ndoi:10.1007/BF01994876",
            "Examples": "G=nx.path_graph(10)\nnx.approximation.max_clique(G)\n# {8, 9}"
        }
    },
    {
        "Section ID": "strategy_connected_sequential_bfs",
        "Description": [
            "Returns an iterable over nodes in G in the order given by a\nbreadth-first traversal.",
            "The generated sequence has the property that for each node except\nthe first, at least one neighbor appeared earlier in the sequence.",
            "G is a NetworkX graph. colors is ignored."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "bidirectional_dijkstra",
        "Description": [
            "Dijkstra\u2019s algorithm for shortest paths using bidirectional search."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node": "Starting node.",
                "target : node": "Ending node.",
                "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge."
            },
            "Returns:": {
                "length, path : number and list": "length is the distance from source to target.\npath is a list of nodes on a path from source to target."
            },
            "Raises:": {
                "NodeNotFound": "If eithersourceortargetis not inG.",
                "NetworkXNoPath": "If no path exists between source and target."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The weight function can be used to hide edges by returning None.\nSo weight=lambdau,v,d:1ifd['color']==\"red\"elseNone will find the shortest red path. In practice  bidirectional Dijkstra is much more than twice as fast as\nordinary Dijkstra. Ordinary Dijkstra expands nodes in a sphere-like manner from the\nsource. The radius of this sphere will eventually be the length\nof the shortest path. Bidirectional Dijkstra will expand nodes\nfrom both the source and the target, making two spheres of half\nthis radius. Volume of the first sphere is pi*r*r while the\nothers are 2*pi*r/2*r/2 , making up half the volume. This algorithm is not guaranteed to work if edge weights\nare negative or are floating point numbers\n(overflows and roundoff errors can cause problems).",
            "Examples": "G=nx.path_graph(5)\nlength,path=nx.bidirectional_dijkstra(G,0,4)\nprint(length)\n# 4\nprint(path)\n# [0, 1, 2, 3, 4]"
        }
    },
    {
        "Section ID": "effective_size",
        "Description": [
            "Returns the effective size of all nodes in the graph G .",
            "The effective size of a node\u2019s ego network is based on the concept\nof redundancy. A person\u2019s ego network has redundancy to the extent\nthat her contacts are connected to each other as well. The\nnonredundant part of a person\u2019s relationships is the effective\nsize of her ego network [1] .  Formally, the effective size of a\nnode \\(u\\) , denoted \\(e(u)\\) , is defined by",
            "where \\(N(u)\\) is the set of neighbors of \\(u\\) and \\(p_{uw}\\) is the\nnormalized mutual weight of the (directed or undirected) edges\njoining \\(u\\) and \\(v\\) , for each vertex \\(u\\) and \\(v\\)  [1] . And \\(m_{vw}\\) is the mutual weight of \\(v\\) and \\(w\\) divided by \\(v\\) highest mutual\nweight with any of its neighbors. The mutual weight of \\(u\\) and \\(v\\) is the sum of the weights of edges joining them (edge weights are\nassumed to be one if the graph is unweighted).",
            "For the case of unweighted and undirected graphs, Borgatti proposed\na simplified formula to compute effective size [2]",
            "where t is the number of ties in the ego network (not including\nties to ego) and n is the number of nodes (excluding ego)."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "The graph containingv. Directed graphs are treated like\nundirected graphs when computing neighbors ofv.",
                "nodes : container, optional": "Container of nodes in the graphGto compute the effective size.\nIf None, the effective size of every node is computed.",
                "weight : None or string, optional": "If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight."
            },
            "Returns:": {
                "dict": "Dictionary with nodes as keys and the effective size of the node as values."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Burt also defined the related concept of efficiency of a node\u2019s ego\nnetwork, which is its effective size divided by the degree of that\nnode [1] . So you can easily compute efficiency:",
            "References": "[1](1,2,3)Burt, Ronald S.Structural Holes: The Social Structure of Competition.Cambridge: Harvard University Press, 1995.  [2]Borgatti, S.\n\u201cStructural Holes: Unpacking Burt\u2019s Redundancy Measures\u201d\nCONNECTIONS 20(1):35-38.http://www.analytictech.com/connections/v20(1)/holes.htm"
        }
    },
    {
        "Section ID": "read_gexf",
        "Description": [
            "Read graph in GEXF format from path.",
            "\u201cGEXF (Graph Exchange XML Format) is a language for describing\ncomplex networks structures, their associated data and dynamics\u201d [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "path : file or string": "File or file name to read.\nFile names ending in .gz or .bz2 will be decompressed.",
                "node_type: Python type (default: None)": "Convert node ids to this type if not None.",
                "relabel : bool (default: False)": "If True relabel the nodes to use the GEXF node \u201clabel\u201d attribute\ninstead of the node \u201cid\u201d attribute as the NetworkX node label.",
                "version : string (default: 1.2draft)": "",
                "Version of GEFX File Format (see http://gexf.net/schema.html)": "Supported values: \u201c1.1draft\u201d, \u201c1.2draft\u201d"
            },
            "Returns:": {
                "graph: NetworkX graph": "If no parallel edges are found a Graph or DiGraph is returned.\nOtherwise a MultiGraph or MultiDiGraph is returned."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This implementation does not support mixed graphs (directed and undirected\nedges together).",
            "References": "[1]GEXF File Format,http://gexf.net/"
        }
    },
    {
        "Section ID": "isolates",
        "Description": [
            "Iterator over isolates in the graph.",
            "An isolate is a node with no neighbors (that is, with degree\nzero). For directed graphs, this means no in-neighbors and no\nout-neighbors."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": ""
            },
            "Returns:": {
                "iterator": "An iterator over the isolates ofG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "To get a list of all isolates of a graph, use thelistconstructor:\nG=nx.Graph()\nG.add_edge(1,2)\nG.add_node(3)\nlist(nx.isolates(G))\n# [3]\nTo remove all isolates in the graph, first create a list of the\nisolates, then useGraph.remove_nodes_from():\nG.remove_nodes_from(list(nx.isolates(G)))\nlist(G)\n# [1, 2]\nFor digraphs, isolates have zero in-degree and zero out_degre:\nG=nx.DiGraph([(0,1),(1,2)])\nG.add_node(3)\nlist(nx.isolates(G))\n# [3]"
        }
    },
    {
        "Section ID": "degree",
        "Description": [
            "Returns a degree view of single node or of nbunch of nodes.\nIf nbunch is omitted, then return degrees of all nodes.",
            "This function wraps the G.degree property."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "build_residual_network",
        "Description": [
            "Build a residual network and initialize a zero flow.",
            "The residual network R from an input graph G has the\nsame nodes as G . R is a DiGraph that contains a pair\nof edges (u,v) and (v,u) iff (u,v) is not a\nself-loop, and at least one of (u,v) and (v,u) exists\nin G .",
            "For each edge (u,v) in R , R[u][v]['capacity'] is equal to the capacity of (u,v) in G if it exists\nin G or zero otherwise. If the capacity is infinite, R[u][v]['capacity'] will have a high arbitrary finite value\nthat does not affect the solution of the problem. This value is stored in R.graph['inf'] . For each edge (u,v) in R , R[u][v]['flow'] represents the flow function of (u,v) and\nsatisfies R[u][v]['flow']==-R[v][u]['flow'] .",
            "The flow value, defined as the total flow into t , the sink, is\nstored in R.graph['flow_value'] . If cutoff is not\nspecified, reachability to t using only edges (u,v) such\nthat R[u][v]['flow']<R[u][v]['capacity'] induces a minimum s - t cut."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "spanner",
        "Description": [
            "Returns a spanner of the given graph with the given stretch.",
            "A spanner of a graph G = (V, E) with stretch t is a subgraph\nH = (V, E_S) such that E_S is a subset of E and the distance between\nany pair of nodes in H is at most t times the distance between the\nnodes in G."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "An undirected simple graph.",
                "stretch : float": "The stretch of the spanner.",
                "weight : object": "The edge attribute to use as distance.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "NetworkX graph": "A spanner of the given graph with the given stretch."
            },
            "Raises:": {
                "ValueError": "If a stretch less than 1 is given."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This function implements the spanner algorithm by Baswana and Sen,\nsee [1]. This algorithm is a randomized las vegas algorithm: The expected\nrunning time is O(km) where k = (stretch + 1) // 2 and m is the\nnumber of edges in G. The returned graph is always a spanner of the\ngiven graph with the specified stretch. For weighted graphs the\nnumber of edges in the spanner is O(k * n^(1 + 1 / k)) where k is\ndefined as above and n is the number of nodes in G. For unweighted\ngraphs the number of edges is O(n^(1 + 1 / k) + kn).",
            "References": "[1] S. Baswana, S. Sen. A Simple and Linear Time Randomized\nAlgorithm for Computing Sparse Spanners in Weighted Graphs.\nRandom Struct. Algorithms 30(4): 532-563 (2007)."
        }
    },
    {
        "Section ID": "open_file",
        "Description": [
            "Decorator to ensure clean opening and closing of files."
        ],
        "Field List": {
            "Parameters:": {
                "path_arg : string or int": "Name or index of the argument that is a path.",
                "mode : str": "String for opening mode."
            },
            "Returns:": {
                "_open_file : function": "Function which cleanly executes the io."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Note that this decorator solves the problem when a path argument is\nspecified as a string, but it does not handle the situation when the\nfunction wants to accept a default of None (and then handle it). Here is an example of how to handle this case:",
            "Examples": "Decorate functions like this:\n@open_file(0,\"r\")defread_function(pathname):pass@open_file(1,\"w\")defwrite_function(G,pathname):pass@open_file(1,\"w\")defwrite_function(G,pathname=\"graph.dot\"):pass@open_file(\"pathname\",\"w\")defwrite_function(G,pathname=\"graph.dot\"):pass@open_file(\"path\",\"w+\")defanother_function(arg,**kwargs):path=kwargs[\"path\"]pass"
        }
    },
    {
        "Section ID": "draw_circular",
        "Description": [
            "Draw the graph G with a circular layout.",
            "This is a convenience function equivalent to:"
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph",
                "kwargs : optional keywords": "Seedraw_networkxfor a description of optional keywords."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The layout is computed each time this function is called. For\nrepeated drawing it is much more efficient to call circular_layout directly and reuse the result:",
            "Examples": "G=nx.path_graph(5)\nnx.draw_circular(G)"
        }
    },
    {
        "Section ID": "betweenness_centrality_subset",
        "Description": [
            "Compute betweenness centrality for a subset of nodes.",
            "where \\(S\\) is the set of sources, \\(T\\) is the set of targets, \\(\\sigma(s, t)\\) is the number of shortest \\((s, t)\\) -paths,\nand \\(\\sigma(s, t|v)\\) is the number of those paths\npassing through some  node \\(v\\) other than \\(s, t\\) .\nIf \\(s = t\\) , \\(\\sigma(s, t) = 1\\) ,\nand if \\(v \\in {s, t}\\) , \\(\\sigma(s, t|v) = 0\\)  [2] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.",
                "sources: list of nodes": "Nodes to use as sources for shortest paths in betweenness",
                "targets: list of nodes": "Nodes to use as targets for shortest paths in betweenness",
                "normalized : bool, optional": "If True the betweenness values are normalized by\\(2/((n-1)(n-2))\\)for graphs, and\\(1/((n-1)(n-2))\\)for directed graphs where\\(n\\)is the number of nodes in G.",
                "weight : None or string, optional (default=None)": "If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight.\nWeights are used to calculate weighted shortest paths, so they are\ninterpreted as distances."
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of nodes with betweenness centrality as the value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The basic algorithm is from [1] . For weighted graphs the edge weights must be greater than zero.\nZero edge weights can produce an infinite number of equal length\npaths between pairs of nodes. The normalization might seem a little strange but it is\ndesigned to make betweenness_centrality(G) be the same as\nbetweenness_centrality_subset(G,sources=G.nodes(),targets=G.nodes()). The total number of paths between source and target is counted\ndifferently for directed and undirected graphs. Directed paths\nare easy to count. Undirected paths are tricky: should a path\nfrom \u201cu\u201d to \u201cv\u201d count as 1 undirected path or as 2 directed paths? For betweenness_centrality we report the number of undirected\npaths when G is undirected. For betweenness_centrality_subset the reporting is different.\nIf the source and target subsets are the same, then we want\nto count undirected paths. But if the source and target subsets\ndiffer \u2013 for example, if sources is {0} and targets is {1},\nthen we are only counting the paths in one direction. They are\nundirected paths but we are counting them in a directed way.\nTo count them as undirected paths, each should count as half a path.",
            "References": "[1]Ulrik Brandes, A Faster Algorithm for Betweenness Centrality.\nJournal of Mathematical Sociology 25(2):163-177, 2001.https://doi.org/10.1080/0022250X.2001.9990249  [2]Ulrik Brandes: On Variants of Shortest-Path Betweenness\nCentrality and their Generic Computation.\nSocial Networks 30(2):136-145, 2008.https://doi.org/10.1016/j.socnet.2007.11.001"
        }
    },
    {
        "Section ID": "gnp_random_graph",
        "Description": [
            "Returns a \\(G_{n,p}\\) random graph, also known as an Erd\u0151s-R\u00e9nyi graph\nor a binomial graph.",
            "The \\(G_{n,p}\\) model chooses each of the possible edges with probability \\(p\\) ."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes.",
                "p : float": "Probability for edge creation.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "directed : bool, optional (default=False)": "If True, this function returns a directed graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm [2] runs in \\(O(n^2)\\) time.  For sparse graphs (that is, for\nsmall values of \\(p\\) ), fast_gnp_random_graph() is a faster algorithm. binomial_graph() and erdos_renyi_graph() are\naliases for gnp_random_graph() .",
            "References": "[1]Erd\u0151s and A. R\u00e9nyi, On Random Graphs, Publ. Math. 6, 290 (1959).  [2]Gilbert, Random Graphs, Ann. Math. Stat., 30, 1141 (1959)."
        }
    },
    {
        "Section ID": "empty_graph",
        "Description": [
            "Returns the empty graph with n nodes and zero edges.",
            "( Sourcecode , png )"
        ],
        "Field List": {
            "Parameters:": {
                "n : int or iterable container of nodes (default = 0)": "If n is an integer, nodes are fromrange(n).\nIf n is a container of nodes, those nodes appear in the graph.",
                "create_using : Graph Instance, Constructor or None": "Indicator of type of graph to return.\nIf a Graph-type instance, then clear and use it.\nIf None, use thedefaultconstructor.\nIf a constructor, call it to create an empty graph.",
                "default : Graph constructor (optional, default = nx.Graph)": "The constructor to use if create_using is None.\nIf None, then nx.Graph is used.\nThis is used when passing an unknowncreate_usingvalue\nthrough your home-grown function toempty_graphand\nyou want a default constructor other than nx.Graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The variable create_using should be a Graph Constructor or a\n\u201cgraph\u201d-like object. Constructors, e.g. nx.Graph or nx.MultiGraph will be used to create the returned graph. \u201cgraph\u201d-like objects\nwill be cleared (nodes and edges will be removed) and refitted as\nan empty \u201cgraph\u201d with nodes specified in n. This capability\nis useful for specifying the class-nature of the resulting empty\n\u201cgraph\u201d (i.e. Graph, DiGraph, MyWeirdGraphClass, etc.). The variable create_using has three main uses:\nFirstly, the variable create_using can be used to create an\nempty digraph, multigraph, etc.  For example,",
            "Examples": "G=nx.empty_graph(10)\nG.number_of_nodes()\n# 10\nG.number_of_edges()\n# 0\nG=nx.empty_graph(\"ABC\")\nG.number_of_nodes()\n# 3\nsorted(G)\n# ['A', 'B', 'C']"
        }
    },
    {
        "Section ID": "equivalence_classes",
        "Description": [
            "Returns equivalence classes of relation when applied to iterable .",
            "The equivalence classes, or blocks, consist of objects from iterable which are all equivalent. They are defined to be equivalent if the relation function returns True when passed any two objects from that\nclass, and False otherwise. To define an equivalence relation the\nfunction must be reflexive, symmetric and transitive."
        ],
        "Field List": {
            "Parameters:": {
                "iterable : list, tuple, or set": "An iterable of elements/nodes.",
                "relation : function": "A Boolean-valued function that implements an equivalence relation\n(reflexive, symmetric, transitive binary relation) on the elements\nofiterable- it must take two elements and returnTrueif\nthey are related, orFalseif not."
            },
            "Returns:": {
                "set of frozensets": "A set of frozensets representing the partition induced by the equivalence\nrelation functionrelationon the elements ofiterable. Each\nmember set in the return set represents an equivalence class, or\nblock, of the partition.Duplicate elements will be ignored so it makes the most sense foriterableto be aset."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This function does not check that relation represents an equivalence\nrelation. You can check that your equivalence classes provide a partition\nusing is_partition .",
            "Examples": "LetXbe the set of integers from0to9, and consider an equivalence\nrelationRonXof congruence modulo3: this means that two integersxandyinXare equivalent underRif they leave the same\nremainder when divided by3, i.e.(x-y)mod3=0.\nThe equivalence classes of this relation are{0,3,6,9},{1,4,7},{2,5,8}:0,3,6,9are all divisible by3and leave zero\nremainder;1,4,7leave remainder1; while2,5and8leave\nremainder2. We can see this by callingequivalence_classeswithXand a function implementation ofR.\nX=set(range(10))\ndefmod3(x,y):\nreturn(x-y)%3==0\nequivalence_classes(X,mod3)\n# {frozenset({1, 4, 7}), frozenset({8, 2, 5}), frozenset({0, 9, 3, 6})}"
        }
    },
    {
        "Section ID": "set_edge_attributes",
        "Description": [
            "Sets edge attributes from a given value or dictionary of values."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "",
                "values : scalar value, dict-like": "What the edge attribute should be set to.  Ifvaluesis\nnot a dictionary, then it is treated as a single attribute value\nthat is then applied to every edge inG.  This means that if\nyou provide a mutable object, like a list, updates to that object\nwill be reflected in the edge attribute for each edge.  The attribute\nname will bename.Ifvaluesis a dict or a dict of dict, it should be keyed\nby edge tuple to either an attribute value or a dict of attribute\nkey/value pairs used to update the edge\u2019s attributes.\nFor multigraphs, the edge tuples must be of the form(u,v,key),\nwhereuandvare nodes andkeyis the edge key.\nFor non-multigraphs, the keys must be tuples of the form(u,v).",
                "name : string (optional, default=None)": "Name of the edge attribute to set if values is a scalar."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "After computing some property of the edges of a graph, you may want\nto assign a edge attribute to store the value of that property for\neach edge:\nG=nx.path_graph(3)\nbb=nx.edge_betweenness_centrality(G,normalized=False)\nnx.set_edge_attributes(G,bb,\"betweenness\")\nG.edges[1,2][\"betweenness\"]\n# 2.0\nIf you provide a list as the second argument, updates to the list\nwill be reflected in the edge attribute for each edge:\nlabels=[]\nnx.set_edge_attributes(G,labels,\"labels\")\nlabels.append(\"foo\")\nG.edges[0,1][\"labels\"]\n# ['foo']\nG.edges[1,2][\"labels\"]\n# ['foo']\nIf you provide a dictionary of dictionaries as the second argument,\nthe entire dictionary will be used to update edge attributes:\nG=nx.path_graph(3)\nattrs={(0,1):{\"attr1\":20,\"attr2\":\"nothing\"},(1,2):{\"attr2\":3}}\nnx.set_edge_attributes(G,attrs)\nG[0][1][\"attr1\"]\n# 20\nG[0][1][\"attr2\"]\n# 'nothing'\nG[1][2][\"attr2\"]\n# 3\nThe attributes of one Graph can be used to set those of another.\nH=nx.path_graph(3)\nnx.set_edge_attributes(H,G.edges)\nNote that if the dict contains edges that are not inG, they are\nsilently ignored:\nG=nx.Graph([(0,1)])\nnx.set_edge_attributes(G,{(1,2):{\"weight\":2.0}})\n(1,2)inG.edges()\n# False\nFor multigraphs, thevaluesdict is expected to be keyed by 3-tuples\nincluding the edge key:\nMG=nx.MultiGraph()\nedges=[(0,1),(0,1)]\nMG.add_edges_from(edges)# Returns list of edge keys\n# [0, 1]\nattributes={(0,1,0):{\"cost\":21},(0,1,1):{\"cost\":7}}\nnx.set_edge_attributes(MG,attributes)\nMG[0][1][0][\"cost\"]\n# 21\nMG[0][1][1][\"cost\"]\n# 7\nIf MultiGraph attributes are desired for a Graph, you must convert the 3-tuple\nmultiedge to a 2-tuple edge and the last multiedge\u2019s attribute value will\noverwrite the previous values. Continuing from the previous case we get:\nH=nx.path_graph([0,1,2])\nnx.set_edge_attributes(H,{(u,v):edforu,v,edinMG.edges.data()})\nnx.get_edge_attributes(H,\"cost\")\n# {(0, 1): 7}"
        }
    },
    {
        "Section ID": "all_pairs_lowest_common_ancestor",
        "Description": [
            "Return the lowest common ancestor of all pairs or the provided pairs"
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX directed graph": "",
                "pairs : iterable of pairs of nodes, optional (default: all pairs)": "The pairs of nodes of interest.\nIf None, will find the LCA of all pairs of nodes."
            },
            "Yields:": {
                "((node1, node2), lca) : 2-tuple": "Where lca is least common ancestor of node1 and node2.\nNote that for the default case, the order of the node pair is not considered,\ne.g. you will not get both(a,b)and(b,a)"
            },
            "Raises:": {
                "NetworkXPointlessConcept": "IfGis null.",
                "NetworkXError": "IfGis not a DAG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Only defined on non-null directed acyclic graphs.",
            "Examples": "The default behavior is to yield the lowest common ancestor for all\npossible combinations of nodes inG, including self-pairings:\nG=nx.DiGraph([(0,1),(0,3),(1,2)])\ndict(nx.all_pairs_lowest_common_ancestor(G))\n# {(0, 0): 0, (0, 1): 0, (0, 3): 0, (0, 2): 0, (1, 1): 1, (1, 3): 0, (1, 2): 1, (3, 3): 3, (3, 2): 0, (2, 2): 2}\nThe pairs argument can be used to limit the output to only the\nspecified node pairings:\ndict(nx.all_pairs_lowest_common_ancestor(G,pairs=[(1,2),(2,3)]))\n# {(1, 2): 1, (2, 3): 0}"
        }
    },
    {
        "Section ID": "attribute_mixing_matrix",
        "Description": [
            "Returns mixing matrix for attribute."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "NetworkX graph object.",
                "attribute : string": "Node attribute key.",
                "nodes: list or iterable (optional)": "Use only nodes in container to build the matrix. The default is\nall nodes.",
                "mapping : dictionary, optional": "Mapping from node attribute to integer index in matrix.\nIf not specified, an arbitrary ordering will be used.",
                "normalized : bool (default=True)": "Return counts if False or probabilities if True."
            },
            "Returns:": {
                "m: numpy array": "Counts or joint probability of occurrence of attribute pairs."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "If each node has a unique attribute value, the unnormalized mixing matrix\nwill be equal to the adjacency matrix. To get a denser mixing matrix,\nthe rounding can be performed to form groups of nodes with equal values.\nFor example, the exact height of persons in cm (180.79155222, 163.9080892,\n163.30095355, 167.99016217, 168.21590163, \u2026) can be rounded to (180, 163,\n163, 168, 168, \u2026). Definitions of attribute mixing matrix vary on whether the matrix\nshould include rows for attribute values that don\u2019t arise. Here we\ndo not include such empty-rows. But you can force them to appear\nby inputting a mapping that includes those values.",
            "Examples": "G=nx.path_graph(3)\ngender={0:\"male\",1:\"female\",2:\"female\"}\nnx.set_node_attributes(G,gender,\"gender\")\nmapping={\"male\":0,\"female\":1}\nmix_mat=nx.attribute_mixing_matrix(G,\"gender\",mapping=mapping)\nmix_mat\n# array([[0.  , 0.25],\n#        [0.25, 0.5 ]])"
        }
    },
    {
        "Section ID": "join",
        "Description": [
            "A deprecated name for join_trees",
            "Returns a new rooted tree with a root node joined with the roots\nof each of the given rooted trees."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "branching_weight",
        "Description": [
            "Returns the total weight of a branching.",
            "You must access this function through the networkx.algorithms.tree module."
        ],
        "Field List": {
            "Parameters:": {
                "G : DiGraph": "The directed graph.",
                "attr : str": "The attribute to use as weights. If None, then each edge will be\ntreated equally with a weight of 1.",
                "default : float": "Whenattris not None, then if an edge does not have that attribute,defaultspecifies what value it should take."
            },
            "Returns:": {
                "weight: int or float": "The total weight of the branching."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.DiGraph()\nG.add_weighted_edges_from([(0,1,2),(1,2,4),(2,3,3),(3,4,2)])\nnx.tree.branching_weight(G)\n# 11"
        }
    },
    {
        "Section ID": "k_crust",
        "Description": [
            "Returns the k-crust of G.",
            "The k-crust is the graph G with the edges of the k-core removed\nand isolated nodes found after the removal of edges are also removed."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A graph or directed graph.",
                "k : int, optional": "The order of the shell. If not specified return the main crust.",
                "core_number : dictionary, optional": "Precomputed core numbers for the graph G."
            },
            "Returns:": {
                "G : NetworkX graph": "The k-crust subgraph"
            },
            "Raises:": {
                "NetworkXNotImplemented": "The k-crust is not implemented for multigraphs or graphs with self loops."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This definition of k-crust is different than the definition in [1] .\nThe k-crust in [1] is equivalent to the k+1 crust of this algorithm. For directed graphs the node degree is defined to be the\nin-degree + out-degree. Graph, node, and edge attributes are copied to the subgraph.",
            "References": "[1](1,2)A model of Internet topology using k-shell decomposition\nShai Carmi, Shlomo Havlin, Scott Kirkpatrick, Yuval Shavitt,\nand Eran Shir, PNAS  July 3, 2007   vol. 104  no. 27  11150-11154http://www.pnas.org/content/104/27/11150.full",
            "Examples": "degrees=[0,1,2,2,2,2,3]\nH=nx.havel_hakimi_graph(degrees)\nH.degree\n# DegreeView({0: 1, 1: 2, 2: 2, 3: 2, 4: 2, 5: 3, 6: 0})\nnx.k_crust(H,k=1).nodes\n# NodeView((0, 4, 6))"
        }
    },
    {
        "Section ID": "Edmonds",
        "Description": [
            "Edmonds algorithm [1] for finding optimal branchings and spanning\narborescences.",
            "This algorithm can find both minimum and maximum spanning arborescences and\nbranchings.",
            "Notes",
            "While this algorithm can find a minimum branching, since it isn\u2019t required\nto be spanning, the minimum branching is always from the set of negative\nweight edges which is most likely the empty set for most graphs.",
            "References"
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {
            "Notes": "While this algorithm can find a minimum branching, since it isn\u2019t required\nto be spanning, the minimum branching is always from the set of negative\nweight edges which is most likely the empty set for most graphs.",
            "References": "[1]J. Edmonds, Optimum Branchings, Journal of Research of the National\nBureau of Standards, 1967, Vol. 71B, p.233-240,https://archive.org/details/jresv71Bn4p233"
        }
    },
    {
        "Section ID": "tree_data",
        "Description": [
            "Returns data in tree format that is suitable for JSON serialization\nand use in JavaScript documents."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "G must be an oriented tree",
                "root : node": "The root of the tree",
                "ident : string": "Attribute name for storing NetworkX-internal graph data.identmust\nhave a different value thanchildren. The default is \u2018id\u2019.",
                "children : string": "Attribute name for storing NetworkX-internal graph data.childrenmust have a different value thanident. The default is \u2018children\u2019."
            },
            "Returns:": {
                "data : dict": "A dictionary with node-link formatted data."
            },
            "Raises:": {
                "NetworkXError": "Ifchildrenandidentattributes are identical."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Node attributes are stored in this format but keys\nfor attributes must be strings if you want to serialize with JSON. Graph and edge attributes are not stored.",
            "Examples": "fromnetworkx.readwriteimportjson_graph\nG=nx.DiGraph([(1,2)])\ndata=json_graph.tree_data(G,root=1)\nTo serialize with json\nimportjson\ns=json.dumps(data)"
        }
    },
    {
        "Section ID": "all_topological_sorts",
        "Description": [
            "Returns a generator of _all_ topological sorts of the directed graph G.",
            "A topological sort is a nonunique permutation of the nodes such that an\nedge from u to v implies that u appears before v in the topological sort\norder."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX DiGraph": "A directed graph"
            },
            "Yields:": {
                "topological_sort_order : list": "a list of nodes inG, representing one of the topological sort orders"
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis not directed",
                "NetworkXUnfeasible": "IfGis not acyclic"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Implements an iterative version of the algorithm given in [1].",
            "References": "[1]Knuth, Donald E., Szwarcfiter, Jayme L. (1974).\n\u201cA Structured Program to Generate All Topological Sorting Arrangements\u201d\nInformation Processing Letters, Volume 2, Issue 6, 1974, Pages 153-157,\nISSN 0020-0190,https://doi.org/10.1016/0020-0190(74)90001-5.\nElsevier (North-Holland), Amsterdam",
            "Examples": "To enumerate all topological sorts of directed graph:\nDG=nx.DiGraph([(1,2),(2,3),(2,4)])\nlist(nx.all_topological_sorts(DG))\n# [[1, 2, 4, 3], [1, 2, 3, 4]]"
        }
    },
    {
        "Section ID": "communicability_betweenness_centrality",
        "Description": [
            "Returns subgraph communicability for all pairs of nodes in G.",
            "Communicability betweenness measure makes use of the number of walks\nconnecting every pair of nodes as the basis of a betweenness centrality\nmeasure."
        ],
        "Field List": {
            "Parameters:": {
                "G: graph": ""
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of nodes with communicability betweenness as the value."
            },
            "Raises:": {
                "NetworkXError": "If the graph is not undirected and simple."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Let G=(V,E) be a simple undirected graph with n nodes and m edges,\nand A denote the adjacency matrix of G . Let G(r)=(V,E(r)) be the graph resulting from\nremoving all edges connected to node r but not the node itself. The adjacency matrix for G(r) is A+E(r) ,  where E(r) has nonzeros\nonly in row and column r . The subraph betweenness of a node r is [1]",
            "References": "[1]Ernesto Estrada, Desmond J. Higham, Naomichi Hatano,\n\u201cCommunicability Betweenness in Complex Networks\u201d\nPhysica A 388 (2009) 764-774.https://arxiv.org/abs/0905.4102",
            "Examples": "G=nx.Graph([(0,1),(1,2),(1,5),(5,4),(2,4),(2,3),(4,3),(3,6)])\ncbc=nx.communicability_betweenness_centrality(G)\nprint([f\"{node} {cbc[node]:0.2f}\"fornodeinsorted(cbc)])\n# ['0 0.03', '1 0.45', '2 0.51', '3 0.45', '4 0.40', '5 0.19', '6 0.03']"
        }
    },
    {
        "Section ID": "current_flow_closeness_centrality",
        "Description": [
            "Compute current-flow closeness centrality for nodes.",
            "Current-flow closeness centrality is variant of closeness\ncentrality based on effective resistance between nodes in\na network. This metric is also known as information centrality."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.",
                "weight : None or string, optional (default=None)": "If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight.\nThe weight reflects the capacity or the strength of the\nedge.",
                "dtype: data type (default=float)": "Default data type for internal matrices.\nSet to np.float32 for lower memory consumption.",
                "solver: string (default=\u2019lu\u2019)": "Type of linear solver to use for computing the flow matrix.\nOptions are \u201cfull\u201d (uses most memory), \u201clu\u201d (recommended), and\n\u201ccg\u201d (uses least memory)."
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of nodes with current flow closeness centrality as the value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The algorithm is from Brandes [1] . See also [2] for the original definition of information centrality.",
            "References": "[1]Ulrik Brandes and Daniel Fleischer,\nCentrality Measures Based on Current Flow.\nProc. 22nd Symp. Theoretical Aspects of Computer Science (STACS \u201805).\nLNCS 3404, pp. 533-544. Springer-Verlag, 2005.https://doi.org/10.1007/978-3-540-31856-9_44  [2]Karen Stephenson and Marvin Zelen:\nRethinking centrality: Methods and examples.\nSocial Networks 11(1):1-37, 1989.https://doi.org/10.1016/0378-8733(89)90016-6"
        }
    },
    {
        "Section ID": "binomial_graph",
        "Description": [
            "Returns a \\(G_{n,p}\\) random graph, also known as an Erd\u0151s-R\u00e9nyi graph\nor a binomial graph.",
            "The \\(G_{n,p}\\) model chooses each of the possible edges with probability \\(p\\) ."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes.",
                "p : float": "Probability for edge creation.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "directed : bool, optional (default=False)": "If True, this function returns a directed graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm [2] runs in \\(O(n^2)\\) time.  For sparse graphs (that is, for\nsmall values of \\(p\\) ), fast_gnp_random_graph() is a faster algorithm. binomial_graph() and erdos_renyi_graph() are\naliases for gnp_random_graph() .",
            "References": "[1]Erd\u0151s and A. R\u00e9nyi, On Random Graphs, Publ. Math. 6, 290 (1959).  [2]Gilbert, Random Graphs, Ann. Math. Stat., 30, 1141 (1959)."
        }
    },
    {
        "Section ID": "subgraph",
        "Description": [
            "Returns the subgraph induced on nodes in nbunch."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "nbunch : list, iterable": "A container of nodes that will be iterated through once (thus\nit should be an iterator or be iterable).  Each element of the\ncontainer should be a valid node type: any hashable type except\nNone.  If nbunch is None, return all edges data in the graph.\nNodes in nbunch that are not in the graph will be (quietly)\nignored."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "subgraph(G) calls G.subgraph()"
        }
    },
    {
        "Section ID": "is_d_separator",
        "Description": [
            "Return whether node sets x and y are d-separated by z ."
        ],
        "Field List": {
            "Parameters:": {
                "G : nx.DiGraph": "A NetworkX DAG.",
                "x : node or set of nodes": "First node or set of nodes inG.",
                "y : node or set of nodes": "Second node or set of nodes inG.",
                "z : node or set of nodes": "Potential separator (set of conditioning nodes inG). Can be empty set."
            },
            "Returns:": {
                "b : bool": "A boolean that is true ifxis d-separated fromygivenzinG."
            },
            "Raises:": {
                "NetworkXError": "Thed-separationtest is commonly used on disjoint sets of\nnodes in acyclic directed graphs.  Accordingly, the algorithm\nraises aNetworkXErrorif the node sets are not\ndisjoint or if the input graph is not a DAG.",
                "NodeNotFound": "If any of the input nodes are not found in the graph,\naNodeNotFoundexception is raised"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "A d-separating set in a DAG is a set of nodes that\nblocks all paths between the two sets. Nodes in z block a path if they are part of the path and are not a collider,\nor a descendant of a collider. Also colliders that are not in z block a path. A collider structure along a path\nis ...->c<-... where c is the collider node. https://en.wikipedia.org/wiki/Bayesian_network#d-separation"
        }
    },
    {
        "Section ID": "k_components",
        "Description": [
            "Returns the k-component structure of a graph G.",
            "A k -component is a maximal subgraph of a graph G that has, at least,\nnode connectivity k : we need to remove at least k nodes to break it\ninto more components. k -components have an inherent hierarchical\nstructure because they are nested in terms of connectivity: a connected\ngraph can contain several 2-components, each of which can contain\none or more 3-components, and so forth."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "flow_func : function": "Function to perform the underlying flow computations. Default valueedmonds_karp(). This function performs better in sparse graphs with\nright tailed degree distributions.shortest_augmenting_path()will\nperform better in denser graphs."
            },
            "Returns:": {
                "k_components : dict": "Dictionary with all connectivity levelskin the input Graph as keys\nand a list of sets of nodes that form a k-component of levelkas\nvalues."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the input graph is directed."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Moody and White [1] (appendix A) provide an algorithm for identifying\nk-components in a graph, which is based on Kanevsky\u2019s algorithm [2] for finding all minimum-size node cut-sets of a graph (implemented in all_node_cuts() function):",
            "References": "[1]Moody, J. and D. White (2003). Social cohesion and embeddedness:\nA hierarchical conception of social groups.\nAmerican Sociological Review 68(1), 103\u201328.http://www2.asanet.org/journals/ASRFeb03MoodyWhite.pdf  [2]Kanevsky, A. (1993). Finding all minimum-size separating vertex\nsets in a graph. Networks 23(6), 533\u2013541.http://onlinelibrary.wiley.com/doi/10.1002/net.3230230604/abstract  [3]Torrents, J. and F. Ferraro (2015). Structural Cohesion:\nVisualization and Heuristics for Fast Computation.https://arxiv.org/pdf/1503.04476v1",
            "Examples": "# Petersen graph has 10 nodes and it is triconnected, thus all\n# nodes are in a single component on all three connectivity levels\nG=nx.petersen_graph()\nk_components=nx.k_components(G)"
        }
    },
    {
        "Section ID": "number_attracting_components",
        "Description": [
            "Returns the number of attracting components in G ."
        ],
        "Field List": {
            "Parameters:": {
                "G : DiGraph, MultiDiGraph": "The graph to be analyzed."
            },
            "Returns:": {
                "n : int": "The number of attracting components in G."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the input graph is undirected."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "duplication_divergence_graph",
        "Description": [
            "Returns an undirected graph using the duplication-divergence model.",
            "A graph of n nodes is created by duplicating the initial nodes\nand retaining edges incident to the original nodes with a retention\nprobability p ."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The desired number of nodes in the graph.",
                "p : float": "The probability for retaining the edge of the replicated node.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "G : Graph": ""
            },
            "Raises:": {
                "NetworkXError": "Ifpis not a valid probability.\nIfnis less than 2."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm appears in [1]. This implementation disallows the possibility of generating\ndisconnected graphs.",
            "References": "[1]I. Ispolatov, P. L. Krapivsky, A. Yuryev,\n\u201cDuplication-divergence model of protein interaction network\u201d,\nPhys. Rev. E, 71, 061911, 2005."
        }
    },
    {
        "Section ID": "betweenness_centrality",
        "Description": [
            "Compute the shortest-path betweenness centrality for nodes.",
            "Betweenness centrality of a node \\(v\\) is the sum of the\nfraction of all-pairs shortest paths that pass through \\(v\\)",
            "where \\(V\\) is the set of nodes, \\(\\sigma(s, t)\\) is the number of\nshortest \\((s, t)\\) -paths,  and \\(\\sigma(s, t|v)\\) is the number of\nthose paths  passing through some  node \\(v\\) other than \\(s, t\\) .\nIf \\(s = t\\) , \\(\\sigma(s, t) = 1\\) , and if \\(v \\in {s, t}\\) , \\(\\sigma(s, t|v) = 0\\)  [2] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.",
                "k : int, optional (default=None)": "If k is not None use k node samples to estimate betweenness.\nThe value of k <= n where n is the number of nodes in the graph.\nHigher values give better approximation.",
                "normalized : bool, optional": "If True the betweenness values are normalized by2/((n-1)(n-2))for graphs, and1/((n-1)(n-2))for directed graphs wherenis the number of nodes in G.",
                "weight : None or string, optional (default=None)": "If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight.\nWeights are used to calculate weighted shortest paths, so they are\ninterpreted as distances.",
                "endpoints : bool, optional": "If True include the endpoints in the shortest path counts.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.\nNote that this is only used if k is not None."
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of nodes with betweenness centrality as the value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The algorithm is from Ulrik Brandes [1] .\nSee [4] for the original first published version and [2] for details on\nalgorithms for variations and related metrics. For approximate betweenness calculations set k=#samples to use\nk nodes (\u201cpivots\u201d) to estimate the betweenness values. For an estimate\nof the number of pivots needed see [3] . For weighted graphs the edge weights must be greater than zero.\nZero edge weights can produce an infinite number of equal length\npaths between pairs of nodes. The total number of paths between source and target is counted\ndifferently for directed and undirected graphs. Directed paths\nare easy to count. Undirected paths are tricky: should a path\nfrom \u201cu\u201d to \u201cv\u201d count as 1 undirected path or as 2 directed paths? For betweenness_centrality we report the number of undirected\npaths when G is undirected. For betweenness_centrality_subset the reporting is different.\nIf the source and target subsets are the same, then we want\nto count undirected paths. But if the source and target subsets\ndiffer \u2013 for example, if sources is {0} and targets is {1},\nthen we are only counting the paths in one direction. They are\nundirected paths but we are counting them in a directed way.\nTo count them as undirected paths, each should count as half a path. This algorithm is not guaranteed to be correct if edge weights\nare floating point numbers. As a workaround you can use integer\nnumbers by multiplying the relevant edge attributes by a convenient\nconstant factor (eg 100) and converting to integers.",
            "References": "[1]Ulrik Brandes:\nA Faster Algorithm for Betweenness Centrality.\nJournal of Mathematical Sociology 25(2):163-177, 2001.https://doi.org/10.1080/0022250X.2001.9990249  [2](1,2)Ulrik Brandes:\nOn Variants of Shortest-Path Betweenness\nCentrality and their Generic Computation.\nSocial Networks 30(2):136-145, 2008.https://doi.org/10.1016/j.socnet.2007.11.001  [3]Ulrik Brandes and Christian Pich:\nCentrality Estimation in Large Networks.\nInternational Journal of Bifurcation and Chaos 17(7):2303-2318, 2007.https://dx.doi.org/10.1142/S0218127407018403  [4]Linton C. Freeman:\nA set of measures of centrality based on betweenness.\nSociometry 40: 35\u201341, 1977https://doi.org/10.2307/3033543"
        }
    },
    {
        "Section ID": "generate_random_paths",
        "Description": [
            "Randomly generate sample_size paths of length path_length ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A NetworkX graph",
                "sample_size : integer": "The number of paths to generate. This isRin[1].",
                "path_length : integer (default = 5)": "The maximum size of the path to randomly generate.\nThis isTin[1]. According to the paper,T>=5is\nrecommended.",
                "index_map : dictionary, optional": "If provided, this will be populated with the inverted\nindex of nodes mapped to the set of generated random path\nindices withinpaths.",
                "weight : string or None, optional (default=\u201dweight\u201d)": "The name of an edge attribute that holds the numerical value\nused as a weight. If None then each edge has weight 1.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "paths : generator of lists": "Generator ofsample_sizepaths each with lengthpath_length."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1](1,2)Zhang, J., Tang, J., Ma, C., Tong, H., Jing, Y., & Li, J.\nPanther: Fast top-k similarity search on large networks.\nIn Proceedings of the ACM SIGKDD International Conference\non Knowledge Discovery and Data Mining (Vol. 2015-August, pp. 1445\u20131454).\nAssociation for Computing Machinery.https://doi.org/10.1145/2783258.2783267.",
            "Examples": "Note that the return value is the list of paths:\nG=nx.star_graph(3)\nrandom_path=nx.generate_random_paths(G,2)\nBy passing a dictionary intoindex_map, it will build an\ninverted index mapping of nodes to the paths in which that node is present:\nG=nx.star_graph(3)\nindex_map={}\nrandom_path=nx.generate_random_paths(G,3,index_map=index_map)\npaths_containing_node_0=[\nrandom_path[path_idx]forpath_idxinindex_map.get(0,[])\n]"
        }
    },
    {
        "Section ID": "lexicographical_topological_sort",
        "Description": [
            "Generate the nodes in the unique lexicographical topological sort order.",
            "Generates a unique ordering of nodes by first sorting topologically (for which there are often\nmultiple valid orderings) and then additionally by sorting lexicographically.",
            "A topological sort arranges the nodes of a directed graph so that the\nupstream node of each directed edge precedes the downstream node.\nIt is always possible to find a solution for directed graphs that have no cycles.\nThere may be more than one valid solution.",
            "Lexicographical sorting is just sorting alphabetically. It is used here to break ties in the\ntopological sort and to determine a single, unique ordering.  This can be useful in comparing\nsort results.",
            "The lexicographical order can be customized by providing a function to the key= parameter.\nThe definition of the key function is the same as used in python\u2019s built-in sort() .\nThe function takes a single argument and returns a key to use for sorting purposes.",
            "Lexicographical sorting can fail if the node names are un-sortable. See the example below.\nThe solution is to provide a function to the key= argument that returns sortable keys."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX digraph": "A directed acyclic graph (DAG)",
                "key : function, optional": "A function of one argument that converts a node name to a comparison key.\nIt defines and resolves ambiguities in the sort order.  Defaults to the identity function."
            },
            "Yields:": {
                "nodes": "Yields the nodes of G in lexicographical topological sort order."
            },
            "Raises:": {
                "NetworkXError": "Topological sort is defined for directed graphs only. If the graphGis undirected, aNetworkXErroris raised.",
                "NetworkXUnfeasible": "IfGis not a directed acyclic graph (DAG) no topological sort exists\nand aNetworkXUnfeasibleexception is raised.  This can also be\nraised ifGis changed while the returned iterator is being processed",
                "RuntimeError": "IfGis changed while the returned iterator is being processed.",
                "TypeError": "Results from un-sortable node names.\nConsider usingkey=parameter to resolve ambiguities in the sort order."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm is based on a description and proof in\n\u201cIntroduction to Algorithms: A Creative Approach\u201d [1] .",
            "References": "[1]Manber, U. (1989).Introduction to Algorithms - A Creative Approach.Addison-Wesley.",
            "Examples": "DG=nx.DiGraph([(2,1),(2,5),(1,3),(1,4),(5,4)])\nlist(nx.lexicographical_topological_sort(DG))\n# [2, 1, 3, 5, 4]\nlist(nx.lexicographical_topological_sort(DG,key=lambdax:-x))\n# [2, 5, 1, 4, 3]\nThe sort will fail for any graph with integer and string nodes. Comparison of integer to strings\nis not defined in python.  Is 3 greater or less than \u2018red\u2019?\nDG=nx.DiGraph([(1,\"red\"),(3,\"red\"),(1,\"green\"),(2,\"blue\")])\nlist(nx.lexicographical_topological_sort(DG))Traceback (most recent call last):...TypeError'<' not supported between instances of 'str' and 'int'...\nIncomparable nodes can be resolved using akeyfunction. This example function\nallows comparison of integers and strings by returning a tuple where the first\nelement is True forstr, False otherwise. The second element is the node name.\nThis groups the strings and integers separately so they can be compared only among themselves.\nkey=lambdanode:(isinstance(node,str),node)\nlist(nx.lexicographical_topological_sort(DG,key=key))\n# [1, 2, 3, 'blue', 'green', 'red']"
        }
    },
    {
        "Section ID": "graphs_equal",
        "Description": [
            "Check if graphs are equal.",
            "Equality here means equal as Python objects (not isomorphism).\nNode, edge and graph data must match."
        ],
        "Field List": {
            "Parameters:": {
                "graph1, graph2 : graph": ""
            },
            "Returns:": {
                "bool": "True if graphs are equal, False otherwise."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "binomial_tree",
        "Description": [
            "Returns the Binomial Tree of order n.",
            "The binomial tree of order 0 consists of a single node. A binomial tree of order k\nis defined recursively by linking two binomial trees of order k-1: the root of one is\nthe leftmost child of the root of the other.",
            "( Sourcecode , png )"
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "Order of the binomial tree.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : NetworkX graph": "A binomial tree of\\(2^n\\)nodes and\\(2^n - 1\\)edges."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "modularity_matrix",
        "Description": [
            "Returns the modularity matrix of G.",
            "The modularity matrix is the matrix B = A - <A>, where A is the adjacency\nmatrix and <A> is the average adjacency matrix, assuming that the graph\nis described by the configuration model.",
            "More specifically, the element B_ij of B is defined as",
            "where k_i is the degree of node i, and where m is the number of edges\nin the graph. When weight is set to a name of an attribute edge, Aij, k_i,\nk_j and m are computed using its value."
        ],
        "Field List": {
            "Parameters:": {
                "G : Graph": "A NetworkX graph",
                "nodelist : list, optional": "The rows and columns are ordered according to the nodes in nodelist.\nIf nodelist is None, then the ordering is produced by G.nodes().",
                "weight : string or None, optional (default=None)": "The edge attribute that holds the numerical value used for\nthe edge weight.  If None then all edge weights are 1."
            },
            "Returns:": {
                "B : Numpy array": "The modularity matrix of G."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]M. E. J. Newman, \u201cModularity and community structure in networks\u201d,\nProc. Natl. Acad. Sci. USA, vol. 103, pp. 8577-8582, 2006.",
            "Examples": "k=[3,2,2,1,0]\nG=nx.havel_hakimi_graph(k)\nB=nx.modularity_matrix(G)"
        }
    },
    {
        "Section ID": "tree_graph",
        "Description": [
            "Returns graph from tree data format."
        ],
        "Field List": {
            "Parameters:": {
                "data : dict": "Tree formatted graph data",
                "ident : string": "Attribute name for storing NetworkX-internal graph data.identmust\nhave a different value thanchildren. The default is \u2018id\u2019.",
                "children : string": "Attribute name for storing NetworkX-internal graph data.childrenmust have a different value thanident. The default is \u2018children\u2019."
            },
            "Returns:": {
                "G : NetworkX DiGraph": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "fromnetworkx.readwriteimportjson_graph\nG=nx.DiGraph([(1,2)])\ndata=json_graph.tree_data(G,root=1)\nH=json_graph.tree_graph(data)"
        }
    },
    {
        "Section ID": "reverse_view",
        "Description": [
            "View of G with edge directions reversed",
            "reverse_view returns a read-only view of the input graph where\nedge directions are reversed.",
            "Identical to digraph.reverse(copy=False)"
        ],
        "Field List": {
            "Parameters:": {
                "G : networkx.DiGraph": ""
            },
            "Returns:": {
                "graph : networkx.DiGraph": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.DiGraph()\nG.add_edge(1,2)\nG.add_edge(2,3)\nG.edges()\n# OutEdgeView([(1, 2), (2, 3)])\nview=nx.reverse_view(G)\nview.edges()\n# OutEdgeView([(2, 1), (3, 2)])"
        }
    },
    {
        "Section ID": "preferential_attachment_graph",
        "Description": [
            "Create a bipartite graph with a preferential attachment model from\na given single degree sequence.",
            "The graph is composed of two partitions. Set A has nodes 0 to\n(len(aseq) - 1) and set B has nodes starting with node len(aseq).\nThe number of nodes in set B is random."
        ],
        "Field List": {
            "Parameters:": {
                "aseq : list": "Degree sequence for node set A.",
                "p : float": "Probability that a new bottom node is added.",
                "create_using : NetworkX graph instance, optional": "Return graph of this type.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The nodes are assigned the attribute \u2018bipartite\u2019 with the value 0 or 1\nto indicate which bipartite set the node belongs to. This function is not imported in the main namespace.\nTo use it use nx.bipartite.preferential_attachment_graph",
            "References": "[1]Guillaume, J.L. and Latapy, M.,\nBipartite graphs as models of complex networks.\nPhysica A: Statistical Mechanics and its Applications,\n2006, 371(2), pp.795-813.  [2]Jean-Loup Guillaume and Matthieu Latapy,\nBipartite structure of all complex networks,\nInf. Process. Lett. 90, 2004, pg. 215-221https://doi.org/10.1016/j.ipl.2004.03.007"
        }
    },
    {
        "Section ID": "generate_multiline_adjlist",
        "Description": [
            "Generate a single line of the graph G in multiline adjacency list format."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "delimiter : string, optional": "Separator for node labels"
            },
            "Returns:": {
                "lines : string": "Lines of data in multiline adjlist format."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.lollipop_graph(4,3)\nforlineinnx.generate_multiline_adjlist(G):\nprint(line)\n# 0 3\n# 1 {}\n# 2 {}\n# 3 {}\n# 1 2\n# 2 {}\n# 3 {}\n# 2 1\n# 3 {}\n# 3 1\n# 4 {}\n# 4 1\n# 5 {}\n# 5 1\n# 6 {}\n# 6 0"
        }
    },
    {
        "Section ID": "find_minimal_d_separator",
        "Description": [
            "Returns a minimal d-separating set between x and y if possible",
            "A d-separating set in a DAG is a set of nodes that blocks all\npaths between the two sets of nodes, x and y . This function\nconstructs a d-separating set that is \u201cminimal\u201d, meaning no nodes can\nbe removed without it losing the d-separating property for x and y .\nIf no d-separating sets exist for x and y , this returns None .",
            "In a DAG there may be more than one minimal d-separator between two\nsets of nodes. Minimal d-separators are not always unique. This function\nreturns one minimal d-separator, or None if no d-separator exists.",
            "Uses the algorithm presented in [1] . The complexity of the algorithm\nis \\(O(m)\\) , where \\(m\\) stands for the number of edges in\nthe subgraph of G consisting of only the ancestors of x and y .\nFor full details, see [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx DAG.",
                "x : set | node": "A node or set of nodes in the graph.",
                "y : set | node": "A node or set of nodes in the graph.",
                "included : set | node | None": "A node or set of nodes which must be included in the found separating set,\ndefault is None, which means the empty set.",
                "restricted : set | node | None": "Restricted node or set of nodes to consider. Only these nodes can be in\nthe found separating set, default is None meaning all nodes inG."
            },
            "Returns:": {
                "z : set | None": "The minimal d-separating set, if at least one d-separating set exists,\notherwise None."
            },
            "Raises:": {
                "NetworkXError": "Raises aNetworkXErrorif the input graph is not a DAG\nor if node setsx,y, andincludedare not disjoint.",
                "NodeNotFound": "If any of the input nodes are not found in the graph,\naNodeNotFoundexception is raised."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1](1,2)van der Zander, Benito, and Maciej Li\u015bkiewicz. \u201cFinding\nminimal d-separators in linear time and applications.\u201d In\nUncertainty in Artificial Intelligence, pp. 637-647. PMLR, 2020."
        }
    },
    {
        "Section ID": "powerlaw_cluster_graph",
        "Description": [
            "Holme and Kim algorithm for growing graphs with powerlaw\ndegree distribution and approximate average clustering."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "the number of nodes",
                "m : int": "the number of random edges to add for each new node",
                "p : float,": "Probability of adding a triangle after adding a random edge",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Raises:": {
                "NetworkXError": "Ifmdoes not satisfy1<=m<=norpdoes not\nsatisfy0<=p<=1."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The average clustering has a hard time getting above a certain\ncutoff that depends on m .  This cutoff is often quite low.  The\ntransitivity (fraction of triangles to possible triangles) seems to\ndecrease with network size. It is essentially the Barab\u00e1si\u2013Albert (BA) growth model with an\nextra step that each random edge is followed by a chance of\nmaking an edge to one of its neighbors too (and thus a triangle). This algorithm improves on BA in the sense that it enables a\nhigher average clustering to be attained if desired. It seems possible to have a disconnected graph with this algorithm\nsince the initial m nodes may not be all linked to a new node\non the first iteration like the BA model.",
            "References": "[1]P. Holme and B. J. Kim,\n\u201cGrowing scale-free networks with tunable clustering\u201d,\nPhys. Rev. E, 65, 026107, 2002."
        }
    },
    {
        "Section ID": "is_edge_cover",
        "Description": [
            "Decides whether a set of edges is a valid edge cover of the graph.",
            "Given a set of edges, whether it is an edge covering can\nbe decided if we just check whether all nodes of the graph\nhas an edge from the set, incident on it."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "An undirected bipartite graph.",
                "cover : set": "Set of edges to be checked."
            },
            "Returns:": {
                "bool": "Whether the set of edges is a valid edge cover of the graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "An edge cover of a graph is a set of edges such that every node of\nthe graph is incident to at least one edge of the set.",
            "Examples": "G=nx.Graph([(0,1),(0,2),(0,3),(1,2),(1,3)])\ncover={(2,1),(3,0)}\nnx.is_edge_cover(G,cover)\n# True"
        }
    },
    {
        "Section ID": "maximum_spanning_edges",
        "Description": [
            "Generate edges in a maximum spanning forest of an undirected\nweighted graph.",
            "A maximum spanning tree is a subgraph of the graph (a tree)\nwith the maximum possible sum of edge weights.  A spanning forest is a\nunion of the spanning trees for each connected component of the graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : undirected Graph": "An undirected graph. IfGis connected, then the algorithm finds a\nspanning tree. Otherwise, a spanning forest is found.",
                "algorithm : string": "The algorithm to use when finding a maximum spanning tree. Valid\nchoices are \u2018kruskal\u2019, \u2018prim\u2019, or \u2018boruvka\u2019. The default is \u2018kruskal\u2019.",
                "weight : string": "Edge data key to use for weight (default \u2018weight\u2019).",
                "keys : bool": "Whether to yield edge key in multigraphs in addition to the edge.\nIfGis not a multigraph, this is ignored.",
                "data : bool, optional": "If True yield the edge data along with the edge.",
                "ignore_nan : bool (default: False)": "If a NaN is found as an edge weight normally an exception is raised.\nIfignore_nanisTruethen that edge is ignored instead."
            },
            "Returns:": {
                "edges : iterator": "An iterator over edges in a maximum spanning tree ofG.\nEdges connecting nodesuandvare represented as tuples:(u,v,k,d)or(u,v,k)or(u,v,d)or(u,v)IfGis a multigraph,keysindicates whether the edge keykwill\nbe reported in the third position in the edge tuple.dataindicates\nwhether the edge datadictdwill appear at the end of the edge tuple.IfGis not a multigraph, the tuples are(u,v,d)ifdatais True\nor(u,v)ifdatais False."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For Bor\u016fvka\u2019s algorithm, each edge must have a weight attribute, and\neach edge weight must be distinct. For the other algorithms, if the graph edges do not have a weight\nattribute a default weight of 1 will be used. Modified code from David Eppstein, April 2006 http://www.ics.uci.edu/~eppstein/PADS/",
            "Examples": "fromnetworkx.algorithmsimporttree\nFind maximum spanning edges by Kruskal\u2019s algorithm\nG=nx.cycle_graph(4)\nG.add_edge(0,3,weight=2)\nmst=tree.maximum_spanning_edges(G,algorithm=\"kruskal\",data=False)\nedgelist=list(mst)\nsorted(sorted(e)foreinedgelist)\n# [[0, 1], [0, 3], [1, 2]]\nFind maximum spanning edges by Prim\u2019s algorithm\nG=nx.cycle_graph(4)\nG.add_edge(0,3,weight=2)# assign weight 2 to edge 0-3\nmst=tree.maximum_spanning_edges(G,algorithm=\"prim\",data=False)\nedgelist=list(mst)\nsorted(sorted(e)foreinedgelist)\n# [[0, 1], [0, 3], [2, 3]]"
        }
    },
    {
        "Section ID": "find_cliques_recursive",
        "Description": [
            "Returns all maximal cliques in a graph.",
            "For each node v , a maximal clique for v is a largest complete\nsubgraph containing v . The largest maximal clique is sometimes\ncalled the maximum clique .",
            "This function returns an iterator over cliques, each of which is a\nlist of nodes. It is a recursive implementation, so may suffer from\nrecursion depth issues, but is included for pedagogical reasons.\nFor a non-recursive implementation, see find_cliques() .",
            "This function accepts a list of nodes and only the maximal cliques\ncontaining all of these nodes are returned. It can considerably speed up\nthe running time if some specific cliques are desired."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "nodes : list, optional (default=None)": "If provided, only yieldmaximal cliquescontaining all nodes innodes.\nIfnodesisn\u2019t a clique itself, a ValueError is raised."
            },
            "Returns:": {
                "iterator": "An iterator over maximal cliques, each of which is a list of\nnodes inG. Ifnodesis provided, only the maximal cliques\ncontaining all the nodes innodesare yielded. The order of\ncliques is arbitrary."
            },
            "Raises:": {
                "ValueError": "Ifnodesis not a clique."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "To obtain a list of all maximal cliques, use list(find_cliques_recursive(G)) . However, be aware that in the\nworst-case, the length of this list can be exponential in the number\nof nodes in the graph. This function avoids storing all cliques in memory\nby only keeping current candidate node lists in memory during its search. This implementation is based on the algorithm published by Bron and\nKerbosch (1973) [1] , as adapted by Tomita, Tanaka and Takahashi\n(2006) [2] and discussed in Cazals and Karande (2008) [3] . For a\nnon-recursive implementation, see find_cliques() . This algorithm ignores self-loops and parallel edges, since cliques\nare not conventionally defined with such edges.",
            "References": "[1]Bron, C. and Kerbosch, J.\n\u201cAlgorithm 457: finding all cliques of an undirected graph\u201d.Communications of the ACM16, 9 (Sep. 1973), 575\u2013577.\n<http://portal.acm.org/citation.cfm?doid=362342.362367>  [2]Etsuji Tomita, Akira Tanaka, Haruhisa Takahashi,\n\u201cThe worst-case time complexity for generating all maximal\ncliques and computational experiments\u201d,Theoretical Computer Science, Volume 363, Issue 1,\nComputing and Combinatorics,\n10th Annual International Conference on\nComputing and Combinatorics (COCOON 2004), 25 October 2006, Pages 28\u201342\n<https://doi.org/10.1016/j.tcs.2006.06.015>  [3]F. Cazals, C. Karande,\n\u201cA note on the problem of reporting maximal cliques\u201d,Theoretical Computer Science,\nVolume 407, Issues 1\u20133, 6 November 2008, Pages 564\u2013568,\n<https://doi.org/10.1016/j.tcs.2008.05.010>"
        }
    },
    {
        "Section ID": "generate_edgelist",
        "Description": [
            "Generate a single line of the graph G in edge list format."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "delimiter : string, optional": "Separator for node labels",
                "data : bool or list of keys": "If False generate no edge data.  If True use a dictionary\nrepresentation of edge data.  If a list of keys use a list of data\nvalues corresponding to the keys."
            },
            "Returns:": {
                "lines : string": "Lines of data in adjlist format."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.lollipop_graph(4,3)\nG[1][2][\"weight\"]=3\nG[3][4][\"capacity\"]=12\nforlineinnx.generate_edgelist(G,data=False):\nprint(line)\n# 0 1\n# 0 2\n# 0 3\n# 1 2\n# 1 3\n# 2 3\n# 3 4\n# 4 5\n# 5 6\nforlineinnx.generate_edgelist(G):\nprint(line)\n# 0 1 {}\n# 0 2 {}\n# 0 3 {}\n# 1 2 {'weight': 3}\n# 1 3 {}\n# 2 3 {}\n# 3 4 {'capacity': 12}\n# 4 5 {}\n# 5 6 {}\nforlineinnx.generate_edgelist(G,data=[\"weight\"]):\nprint(line)\n# 0 1\n# 0 2\n# 0 3\n# 1 2 3\n# 1 3\n# 2 3\n# 3 4\n# 4 5\n# 5 6"
        }
    },
    {
        "Section ID": "get_node_attributes",
        "Description": [
            "Get node attributes from graph"
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "",
                "name : string": "Attribute name",
                "default: object (default=None)": "Default value of the node attribute if there is no value set for that\nnode in graph. IfNonethen nodes without this attribute are not\nincluded in the returned dict."
            },
            "Returns:": {
                "Dictionary of attributes keyed by node.": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph()\nG.add_nodes_from([1,2,3],color=\"red\")\ncolor=nx.get_node_attributes(G,\"color\")\ncolor[1]\n# 'red'\nG.add_node(4)\ncolor=nx.get_node_attributes(G,\"color\",default=\"yellow\")\ncolor[4]\n# 'yellow'"
        }
    },
    {
        "Section ID": "chordal_graph_treewidth",
        "Description": [
            "Returns the treewidth of the chordal graph G."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph"
            },
            "Returns:": {
                "treewidth : int": "The size of the largest clique in the graph minus one."
            },
            "Raises:": {
                "NetworkXError": "The algorithm does not support DiGraph, MultiGraph and MultiDiGraph.\nThe algorithm can only be applied to chordal graphs. If the input\ngraph is found to be non-chordal, aNetworkXErroris raised."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://en.wikipedia.org/wiki/Tree_decomposition#Treewidth",
            "Examples": "e=[\n(1,2),\n(1,3),\n(2,3),\n(2,4),\n(3,4),\n(3,5),\n(3,6),\n(4,5),\n(4,6),\n(5,6),\n(7,8),\n]\nG=nx.Graph(e)\nG.add_node(9)\nnx.chordal_graph_treewidth(G)\n# 3"
        }
    },
    {
        "Section ID": "vf2pp_all_isomorphisms",
        "Description": [
            "Yields all the possible mappings between G1 and G2."
        ],
        "Field List": {
            "Parameters:": {
                "G1, G2 : NetworkX Graph or MultiGraph instances.": "The two graphs to check for isomorphism.",
                "node_label : str, optional": "The name of the node attribute to be used when comparing nodes.\nThe default isNone, meaning node attributes are not considered\nin the comparison. Any node that doesn\u2019t have thenode_labelattribute usesdefault_labelinstead.",
                "default_label : scalar": "Default value to use when a node doesn\u2019t have an attribute\nnamednode_label. Default isNone."
            },
            "Yields:": {
                "dict": "Isomorphic mapping between the nodes inG1andG2."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "desargues_graph",
        "Description": [
            "Returns the Desargues Graph",
            "The Desargues Graph is a non-planar, distance-transitive cubic graph\nwith 20 nodes and 30 edges [1] .\nIt is a symmetric graph. It can be represented in LCF notation\nas [5,-5,9,-9]^5 [2] ."
        ],
        "Field List": {
            "Parameters:": {
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : networkx Graph": "Desargues Graph with 20 nodes and 30 edges"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://en.wikipedia.org/wiki/Desargues_graph  [2]https://mathworld.wolfram.com/DesarguesGraph.html"
        }
    },
    {
        "Section ID": "common_neighbors",
        "Description": [
            "Returns the common neighbors of two nodes in a graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX undirected graph.",
                "u, v : nodes": "Nodes in the graph."
            },
            "Returns:": {
                "cnbors : set": "Set of common neighbors of u and v in the graph."
            },
            "Raises:": {
                "NetworkXError": "If u or v is not a node in the graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.complete_graph(5)\nsorted(nx.common_neighbors(G,0,1))\n# [2, 3, 4]"
        }
    },
    {
        "Section ID": "kernighan_lin_bisection",
        "Description": [
            "Partition a graph into two blocks using the Kernighan\u2013Lin\nalgorithm.",
            "This algorithm partitions a network into two sets by iteratively\nswapping pairs of nodes to reduce the edge cut between the two sets.  The\npairs are chosen according to a modified form of Kernighan-Lin [1] , which\nmoves node individually, alternating between sides to keep the bisection\nbalanced."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Graph must be undirected.",
                "partition : tuple": "Pair of iterables containing an initial partition. If not\nspecified, a random balanced partition is used.",
                "max_iter : int": "Maximum number of times to attempt swaps to find an\nimprovement before giving up.",
                "weight : key": "Edge data key to use as weight. If None, the weights are all\nset to one.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.\nOnly used if partition is None"
            },
            "Returns:": {
                "partition : tuple": "A pair of sets of nodes representing the bipartition."
            },
            "Raises:": {
                "NetworkXError": "If partition is not a valid partition of the nodes of the graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Kernighan, B. W.; Lin, Shen (1970).\n\u201cAn efficient heuristic procedure for partitioning graphs.\u201dBell Systems Technical Journal49: 291\u2013307.\nOxford University Press 2011."
        }
    },
    {
        "Section ID": "star_graph",
        "Description": [
            "Return the star graph",
            "The star graph consists of one center node connected to n outer nodes.",
            "( Sourcecode , png )"
        ],
        "Field List": {
            "Parameters:": {
                "n : int or iterable": "If an integer, node labels are 0 to n with center 0.\nIf an iterable of nodes, the center is the first.\nWarning: n is not checked for duplicates and if present the\nresulting graph may not be as desired. Make sure you have no duplicates.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The graph has n+1 nodes for integer n.\nSo star_graph(3) is the same as star_graph(range(4))."
        }
    },
    {
        "Section ID": "thresholded_random_geometric_graph",
        "Description": [
            "Returns a thresholded random geometric graph in the unit cube.",
            "The thresholded random geometric graph [1] model places n nodes\nuniformly at random in the unit cube of dimensions dim . Each node u is assigned a weight \\(w_u\\) . Two nodes u and v are\njoined by an edge if they are within the maximum connection distance, radius computed by the p -Minkowski distance and the summation of\nweights \\(w_u\\) + \\(w_v\\) is greater than or equal\nto the threshold parameter theta .",
            "Edges within radius of each other are determined using a KDTree when\nSciPy is available. This reduces the time complexity from \\(O(n^2)\\) to \\(O(n)\\) ."
        ],
        "Field List": {
            "Parameters:": {
                "n : int or iterable": "Number of nodes or iterable of nodes",
                "radius: float": "Distance threshold value",
                "theta: float": "Threshold value",
                "dim : int, optional": "Dimension of graph",
                "pos : dict, optional": "A dictionary keyed by node with node positions as values.",
                "weight : dict, optional": "Node weights as a dictionary of numbers keyed by node.",
                "p : float, optional (default 2)": "Which Minkowski distance metric to use.phas to meet the condition1<=p<=infinity.If this argument is not specified, the\\(L^2\\)metric\n(the Euclidean distance metric), p = 2 is used.This should not be confused with thepof an Erd\u0151s-R\u00e9nyi random\ngraph, which represents probability.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "pos_name : string, default=\u201dpos\u201d": "The name of the node attribute which represents the position\nin 2D coordinates of the node in the returned graph.",
                "weight_name : string, default=\u201dweight\u201d": "The name of the node attribute which represents the weight\nof the node in the returned graph."
            },
            "Returns:": {
                "Graph": "A thresholded random geographic graph, undirected and without\nself-loops.Each node has a node attribute'pos'that stores the\nposition of that node in Euclidean space as provided by theposkeyword argument or, ifposwas not provided, as\ngenerated by this function. Similarly, each node has a nodethre\nattribute'weight'that stores the weight of that node as\nprovided or as generated."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This uses a k -d tree to build the graph. The pos keyword argument can be used to specify node positions so you\ncan create an arbitrary distribution and domain for positions. For example, to use a 2D Gaussian distribution of node positions with mean\n(0, 0) and standard deviation 2 If weights are not specified they are assigned to nodes by drawing randomly\nfrom the exponential distribution with rate parameter \\(\\lambda=1\\) .\nTo specify weights from a different distribution, use the weight keyword\nargument:",
            "References": "[1]http://cole-maclean.github.io/blog/files/thesis.pdf",
            "Examples": "Default Graph:\nG = nx.thresholded_random_geometric_graph(50, 0.2, 0.1)\nCustom Graph:\nCreate a thresholded random geometric graph on 50 uniformly distributed\nnodes where nodes are joined by an edge if their sum weights drawn from\na exponential distribution with rate = 5 are >= theta = 0.1 and their\nEuclidean distance is at most 0.2."
        }
    },
    {
        "Section ID": "threshold_accepting_tsp",
        "Description": [
            "Returns an approximate solution to the traveling salesman problem.",
            "This function uses threshold accepting methods to approximate the minimal cost\ncycle through the nodes. Starting from a suboptimal solution, threshold\naccepting methods perturb that solution, accepting any changes that make\nthe solution no worse than increasing by a threshold amount. Improvements\nin cost are accepted, but so are changes leading to small increases in cost.\nThis allows the solution to leave suboptimal local minima in solution space.\nThe threshold is decreased slowly as iterations proceed helping to ensure\nan optimum. In summary, the function returns a cycle starting at source for which the total cost is minimized."
        ],
        "Field List": {
            "Parameters:": {
                "G : Graph": "Gshould be a complete weighted graph.\nThe distance between all pairs of nodes should be included.",
                "init_cycle : list or \u201cgreedy\u201d": "The initial solution (a cycle through all nodes returning to the start).\nThis argument has no default to make you think about it.\nIf \u201cgreedy\u201d, usegreedy_tsp(G,weight).\nOther common starting cycles arelist(G)+[next(iter(G))]or the final\nresult ofsimulated_annealing_tspwhen doingthreshold_accepting_tsp.",
                "weight : string, optional (default=\u201dweight\u201d)": "Edge data key corresponding to the edge weight.\nIf any edge does not have this attribute the weight is set to 1.",
                "source : node, optional (default: first node in list(G))": "Starting node.  If None, defaults tonext(iter(G))",
                "threshold : int, optional (default=1)": "The algorithm\u2019s threshold parameter. It represents the initial\nthreshold\u2019s value",
                "move : \u201c1-1\u201d or \u201c1-0\u201d or function, optional (default=\u201d1-1\u201d)": "Indicator of what move to use when finding new trial solutions.\nStrings indicate two special built-in moves:\u201c1-1\u201d: 1-1 exchange which transposes the position\nof two elements of the current solution.\nThe function called isswap_two_nodes().\nFor example if we apply 1-1 exchange in the solutionA=[3,2,1,4,3]we can get the following by the transposition of 1 and 4 elements:A'=[3,2,4,1,3]\u201c1-0\u201d: 1-0 exchange which moves an node in the solution\nto a new position.\nThe function called ismove_one_node().\nFor example if we apply 1-0 exchange in the solutionA=[3,2,1,4,3]we can transfer the fourth element to the second position:A'=[3,4,2,1,3]You may provide your own functions to enact a move from\none solution to a neighbor solution. The function must take\nthe solution as input along with aseedinput to control\nrandom number generation (see theseedinput here).\nYour function should maintain the solution as a cycle with\nequal first and last node and all others appearing once.\nYour function should return the new solution.",
                "max_iterations : int, optional (default=10)": "Declared done when this number of consecutive iterations of\nthe outer loop occurs without any change in the best cost solution.",
                "N_inner : int, optional (default=100)": "The number of iterations of the inner loop.",
                "alpha : float between (0, 1), optional (default=0.1)": "Percentage of threshold decrease when there is at\nleast one acceptance of a neighbor solution.\nIf no inner loop moves are accepted the threshold remains unchanged.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "cycle : list of nodes": "Returns the cycle (list of nodes) that a salesman\ncan follow to minimize total weight of the trip."
            },
            "Raises:": {
                "NetworkXError": "IfGis not complete the algorithm raises an exception."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Threshold Accepting is a metaheuristic local search algorithm.\nThe main characteristic of this algorithm is that it accepts\neven solutions which lead to the increase of the cost in order\nto escape from low quality local optimal solutions. This algorithm needs an initial solution. This solution can be\nconstructed by a simple greedy algorithm. At every iteration, it\nselects thoughtfully a neighbor solution.\nConsider \\(c(x)\\) cost of current solution and \\(c(x')\\) cost of\nneighbor solution.\nIf \\(c(x') - c(x) <= threshold\\) then the neighbor solution becomes the current\nsolution for the next iteration, where the threshold is named threshold. In comparison to the Simulated Annealing algorithm, the Threshold\nAccepting algorithm does not accept very low quality solutions\n(due to the presence of the threshold value). In the case of\nSimulated Annealing, even a very low quality solution can\nbe accepted with probability \\(p\\) . Time complexity:\nIt has a running time \\(O(m * n * |V|)\\) where \\(m\\) and \\(n\\) are the number\nof times the outer and inner loop run respectively. For more information and how algorithm is inspired see: https://doi.org/10.1016/0021-9991(90)90201-B",
            "Examples": "fromnetworkx.algorithmsimportapproximationasapprox\nG=nx.DiGraph()\nG.add_weighted_edges_from(\n{\n(\"A\",\"B\",3),\n(\"A\",\"C\",17),\n(\"A\",\"D\",14),\n(\"B\",\"A\",3),\n(\"B\",\"C\",12),\n(\"B\",\"D\",16),\n(\"C\",\"A\",13),\n(\"C\",\"B\",12),\n(\"C\",\"D\",4),\n(\"D\",\"A\",14),\n(\"D\",\"B\",15),\n(\"D\",\"C\",2),\n}\n)\ncycle=approx.threshold_accepting_tsp(G,\"greedy\",source=\"D\")\ncost=sum(G[n][nbr][\"weight\"]forn,nbrinnx.utils.pairwise(cycle))\ncycle\n# ['D', 'C', 'B', 'A', 'D']\ncost\n# 31\nincycle=[\"D\",\"B\",\"A\",\"C\",\"D\"]\ncycle=approx.threshold_accepting_tsp(G,incycle,source=\"D\")\ncost=sum(G[n][nbr][\"weight\"]forn,nbrinnx.utils.pairwise(cycle))\ncycle\n# ['D', 'C', 'B', 'A', 'D']\ncost\n# 31"
        }
    },
    {
        "Section ID": "random_unlabeled_rooted_forest",
        "Description": [
            "Returns a forest or list of forests selected at random.",
            "Returns one or more (depending on number_of_forests )\nunlabeled rooted forests with n nodes, and with no more than q nodes per tree, drawn uniformly at random.\nThe \u201croots\u201d graph attribute identifies the roots of the forest."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes",
                "q : int or None (default)": "The maximum number of nodes per tree.",
                "number_of_forests : int or None (default)": "If not None, this number of forests is generated and returned.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "networkx.Graph : or list of : networkx.Graph": "A singlenetworkx.Graph(or a list thereof, ifnumber_of_forestsis specified) with nodes in the set {0, \u2026,n- 1}.\nThe \u201croots\u201d graph attribute is a set containing the roots\nof the trees in the forest."
            },
            "Raises:": {
                "ValueError": "Ifnis non-zero butqis zero."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This function implements the algorithm \u201cForest\u201d of [1] .\nThe algorithm needs to compute some counting functions\nthat are relatively expensive: in case several trees are needed,\nit is advisable to use the number_of_forests optional argument\nto reuse the counting functions.",
            "References": "[1]Wilf, Herbert S. \u201cThe uniform selection of free trees.\u201d\nJournal of Algorithms 2.2 (1981): 204-207.https://doi.org/10.1016/0196-6774(81)90021-3"
        }
    },
    {
        "Section ID": "turan_graph",
        "Description": [
            "Return the Turan Graph",
            "The Turan Graph is a complete multipartite graph on \\(n\\) nodes\nwith \\(r\\) disjoint subsets. That is, edges connect each node to\nevery node not in its subset.",
            "Given \\(n\\) and \\(r\\) , we create a complete multipartite graph with \\(r-(n \\mod r)\\) partitions of size \\(n/r\\) , rounded down, and \\(n \\mod r\\) partitions of size \\(n/r+1\\) , rounded down.",
            "( Sourcecode , png )"
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes.",
                "r : int": "The number of partitions.\nMust be less than or equal to n."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Must satisfy \\(1 <= r <= n\\) .\nThe graph has \\((r-1)(n^2)/(2r)\\) edges, rounded down."
        }
    },
    {
        "Section ID": "cytoscape_data",
        "Description": [
            "Returns data in Cytoscape JSON format (cyjs)."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "The graph to convert to cytoscape format",
                "name : string": "A string which is mapped to the \u2018name\u2019 node element in cyjs format.\nMust not have the same value asident.",
                "ident : string": "A string which is mapped to the \u2018id\u2019 node element in cyjs format.\nMust not have the same value asname."
            },
            "Returns:": {
                "data: dict": "A dictionary with cyjs formatted data."
            },
            "Raises:": {
                "NetworkXError": "If the values fornameandidentare identical."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Cytoscape user\u2019s manual:http://manual.cytoscape.org/en/stable/index.html",
            "Examples": "G=nx.path_graph(2)\nnx.cytoscape_data(G)\n# {'data': [],\n#  'directed': False,\n#  'multigraph': False,\n#  'elements': {'nodes': [{'data': {'id': '0', 'value': 0, 'name': '0'}},\n#    {'data': {'id': '1', 'value': 1, 'name': '1'}}],\n#   'edges': [{'data': {'source': 0, 'target': 1}}]}}"
        }
    },
    {
        "Section ID": "extended_barabasi_albert_graph",
        "Description": [
            "Returns an extended Barab\u00e1si\u2013Albert model graph.",
            "An extended Barab\u00e1si\u2013Albert model graph is a random graph constructed\nusing preferential attachment. The extended model allows new edges,\nrewired edges or new nodes. Based on the probabilities \\(p\\) and \\(q\\) with \\(p + q < 1\\) , the growing behavior of the graph is determined as:",
            "1) With \\(p\\) probability, \\(m\\) new edges are added to the graph,\nstarting from randomly chosen existing nodes and attached preferentially at the other end.",
            "2) With \\(q\\) probability, \\(m\\) existing edges are rewired\nby randomly choosing an edge and rewiring one end to a preferentially chosen node.",
            "3) With \\((1 - p - q)\\) probability, \\(m\\) new nodes are added to the graph\nwith edges attached preferentially.",
            "When \\(p = q = 0\\) , the model behaves just like the Barab\u00e1si\u2013Alber model."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "Number of nodes",
                "m : int": "Number of edges with which a new node attaches to existing nodes",
                "p : float": "Probability value for adding an edge between existing nodes. p + q < 1",
                "q : float": "Probability value of rewiring of existing edges. p + q < 1",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "G : Graph": ""
            },
            "Raises:": {
                "NetworkXError": "Ifmdoes not satisfy1<=m<nor1>=p+q"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Albert, R., & Barab\u00e1si, A. L. (2000)\nTopology of evolving networks: local events and universality\nPhysical review letters, 85(24), 5234."
        }
    },
    {
        "Section ID": "write_edgelist",
        "Description": [
            "Write graph as a list of edges."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "path : file or string": "File or filename to write. If a file is provided, it must be\nopened in \u2018wb\u2019 mode. Filenames ending in .gz or .bz2 will be compressed.",
                "comments : string, optional": "The character used to indicate the start of a comment",
                "delimiter : string, optional": "The string used to separate values.  The default is whitespace.",
                "data : bool or list, optional": "If False write no edge data.\nIf True write a string representation of the edge data dictionary..\nIf a list (or other iterable) is provided, write the  keys specified\nin the list.",
                "encoding: string, optional": "Specify which encoding to use when writing file."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.path_graph(4)\nnx.write_edgelist(G,\"test.edgelist\")\nG=nx.path_graph(4)\nfh=open(\"test.edgelist\",\"wb\")\nnx.write_edgelist(G,fh)\nnx.write_edgelist(G,\"test.edgelist.gz\")\nnx.write_edgelist(G,\"test.edgelist.gz\",data=False)\nG=nx.Graph()\nG.add_edge(1,2,weight=7,color=\"red\")\nnx.write_edgelist(G,\"test.edgelist\",data=False)\nnx.write_edgelist(G,\"test.edgelist\",data=[\"color\"])\nnx.write_edgelist(G,\"test.edgelist\",data=[\"color\",\"weight\"])"
        }
    },
    {
        "Section ID": "immediate_dominators",
        "Description": [
            "Returns the immediate dominators of all nodes of a directed graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : a DiGraph or MultiDiGraph": "The graph where dominance is to be computed.",
                "start : node": "The start node of dominance computation."
            },
            "Returns:": {
                "idom : dict keyed by nodes": "A dict containing the immediate dominators of each node reachable fromstart."
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis undirected.",
                "NetworkXError": "Ifstartis not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Except for start , the immediate dominators are the parents of their\ncorresponding nodes in the dominator tree.",
            "References": "[1]K. D. Cooper, T. J. Harvey, and K. Kennedy.\nA simple, fast dominance algorithm.\nSoftware Practice & Experience, 4:110, 2001.",
            "Examples": "G=nx.DiGraph([(1,2),(1,3),(2,5),(3,4),(4,5)])\nsorted(nx.immediate_dominators(G,1).items())\n# [(1, 1), (2, 1), (3, 1), (4, 3), (5, 1)]"
        }
    },
    {
        "Section ID": "biadjacency_matrix",
        "Description": [
            "Returns the biadjacency matrix of the bipartite graph G.",
            "Let G=(U,V,E) be a bipartite graph with node sets U=u_{1},...,u_{r} and V=v_{1},...,v_{s} . The biadjacency\nmatrix [1] is the r x s matrix B in which b_{i,j}=1 if, and only if, (u_i,v_j)inE . If the parameter weight is\nnot None and matches the name of an edge attribute, its value is\nused instead of 1."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "row_order : list of nodes": "The rows of the matrix are ordered according to the list of nodes.",
                "column_order : list, optional": "The columns of the matrix are ordered according to the list of nodes.\nIf column_order is None, then the ordering of columns is arbitrary.",
                "dtype : NumPy data-type, optional": "A valid NumPy dtype used to initialize the array. If None, then the\nNumPy default is used.",
                "weight : string or None, optional (default=\u2019weight\u2019)": "The edge data key used to provide each value in the matrix.\nIf None, then each edge has weight 1.",
                "format : str in {\u2018bsr\u2019, \u2018csr\u2019, \u2018csc\u2019, \u2018coo\u2019, \u2018lil\u2019, \u2018dia\u2019, \u2018dok\u2019}": "The type of the matrix to be returned (default \u2018csr\u2019).  For\nsome algorithms different implementations of sparse matrices\ncan perform better.  See[2]for details."
            },
            "Returns:": {
                "M : SciPy sparse array": "Biadjacency matrix representation of the bipartite graph G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "No attempt is made to check that the input graph is bipartite. For directed bipartite graphs only successors are considered as neighbors.\nTo obtain an adjacency matrix with ones (or weight values) for both\npredecessors and successors you have to generate two biadjacency matrices\nwhere the rows of one of them are the columns of the other, and then add\none to the transpose of the other.",
            "References": "[1]https://en.wikipedia.org/wiki/Adjacency_matrix#Adjacency_matrix_of_a_bipartite_graph  [2]Scipy Dev. References, \u201cSparse Matrices\u201d,https://docs.scipy.org/doc/scipy/reference/sparse.html"
        }
    },
    {
        "Section ID": "transitive_closure",
        "Description": [
            "Returns transitive closure of a graph",
            "The transitive closure of G = (V,E) is a graph G+ = (V,E+) such that\nfor all v, w in V there is an edge (v, w) in E+ if and only if there\nis a path from v to w in G.",
            "Handling of paths from v to v has some flexibility within this definition.\nA reflexive transitive closure creates a self-loop for the path\nfrom v to v of length 0. The usual transitive closure creates a\nself-loop only if a cycle exists (a path from v to v with length > 0).\nWe also allow an option for no self-loops."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "A directed/undirected graph/multigraph.",
                "reflexive : Bool or None, optional (default: False)": "Determines when cycles create self-loops in the Transitive Closure.\nIf True, trivial cycles (length 0) create self-loops. The result\nis a reflexive transitive closure of G.\nIf False (the default) non-trivial cycles create self-loops.\nIf None, self-loops are not created."
            },
            "Returns:": {
                "NetworkX graph": "The transitive closure ofG"
            },
            "Raises:": {
                "NetworkXError": "Ifreflexivenot in{None,True,False}"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://www.ics.uci.edu/~eppstein/PADS/PartialOrder.py",
            "Examples": "The treatment of trivial (i.e. length 0) cycles is controlled by thereflexiveparameter.\nTrivial (i.e. length 0) cycles do not create self-loops whenreflexive=False(the default):\nDG=nx.DiGraph([(1,2),(2,3)])\nTC=nx.transitive_closure(DG,reflexive=False)\nTC.edges()\n# OutEdgeView([(1, 2), (1, 3), (2, 3)])\nHowever, nontrivial (i.e. length greater than 0) cycles create self-loops\nwhenreflexive=False(the default):\nDG=nx.DiGraph([(1,2),(2,3),(3,1)])\nTC=nx.transitive_closure(DG,reflexive=False)\nTC.edges()\n# OutEdgeView([(1, 2), (1, 3), (1, 1), (2, 3), (2, 1), (2, 2), (3, 1), (3, 2), (3, 3)])\nTrivial cycles (length 0) create self-loops whenreflexive=True:\nDG=nx.DiGraph([(1,2),(2,3)])\nTC=nx.transitive_closure(DG,reflexive=True)\nTC.edges()\n# OutEdgeView([(1, 2), (1, 1), (1, 3), (2, 3), (2, 2), (3, 3)])\nAnd the third option is not to create self-loops at all whenreflexive=None:\nDG=nx.DiGraph([(1,2),(2,3),(3,1)])\nTC=nx.transitive_closure(DG,reflexive=None)\nTC.edges()\n# OutEdgeView([(1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2)])"
        }
    },
    {
        "Section ID": "large_clique_size",
        "Description": [
            "Find the size of a large clique in a graph.",
            "A clique is a subset of nodes in which each pair of nodes is\nadjacent. This function is a heuristic for finding the size of a\nlarge clique in the graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": ""
            },
            "Returns:": {
                "k: integer": "The size of a large clique in the graph."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the graph is directed or is a multigraph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This implementation is from [1] . Its worst case time complexity is \\(O(n d^2)\\) , where n is the number of nodes in the graph and d is the maximum degree. This function is a heuristic, which means it may work well in\npractice, but there is no rigorous mathematical guarantee on the\nratio between the returned number and the actual largest clique size\nin the graph.",
            "References": "[1]Pattabiraman, Bharath, et al.\n\u201cFast Algorithms for the Maximum Clique Problem on Massive Graphs\nwith Applications to Overlapping Community Detection.\u201dInternet Mathematics11.4-5 (2015): 421\u2013448.\n<https://doi.org/10.1080/15427951.2014.986778>",
            "Examples": "G=nx.path_graph(10)\nnx.approximation.large_clique_size(G)\n# 2"
        }
    },
    {
        "Section ID": "relabel_nodes",
        "Description": [
            "Relabel the nodes of the graph G according to a given mapping.",
            "The original node ordering may not be preserved if copy is False and the\nmapping includes overlap between old and new labels."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "mapping : dictionary": "A dictionary with the old labels as keys and new labels as values.\nA partial mapping is allowed. Mapping 2 nodes to a single node is allowed.\nAny non-node keys in the mapping are ignored.",
                "copy : bool (optional, default=True)": "If True return a copy, or if False relabel the nodes in place."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Only the nodes specified in the mapping will be relabeled.\nAny non-node keys in the mapping are ignored. The keyword setting copy=False modifies the graph in place.\nRelabel_nodes avoids naming collisions by building a\ndirected graph from mapping which specifies the order of\nrelabelings. Naming collisions, such as a->b, b->c, are ordered\nsuch that \u201cb\u201d gets renamed to \u201cc\u201d before \u201ca\u201d gets renamed \u201cb\u201d.\nIn cases of circular mappings (e.g. a->b, b->a), modifying the\ngraph is not possible in-place and an exception is raised.\nIn that case, use copy=True. If a relabel operation on a multigraph would cause two or more\nedges to have the same source, target and key, the second edge must\nbe assigned a new key to retain all edges. The new key is set\nto the lowest non-negative integer not already used as a key\nfor edges between these two nodes. Note that this means non-numeric\nkeys may be replaced by numeric keys.",
            "Examples": "To create a new graph with nodes relabeled according to a given\ndictionary:\nG=nx.path_graph(3)\nsorted(G)\n# [0, 1, 2]\nmapping={0:\"a\",1:\"b\",2:\"c\"}\nH=nx.relabel_nodes(G,mapping)\nsorted(H)\n# ['a', 'b', 'c']\nNodes can be relabeled with any hashable object, including numbers\nand strings:\nimportstring\nG=nx.path_graph(26)# nodes are integers 0 through 25\nsorted(G)[:3]\n# [0, 1, 2]\nmapping=dict(zip(G,string.ascii_lowercase))\nG=nx.relabel_nodes(G,mapping)# nodes are characters a through z\nsorted(G)[:3]\n# ['a', 'b', 'c']\nmapping=dict(zip(G,range(1,27)))\nG=nx.relabel_nodes(G,mapping)# nodes are integers 1 through 26\nsorted(G)[:3]\n# [1, 2, 3]\nTo perform a partial in-place relabeling, provide a dictionary\nmapping only a subset of the nodes, and set thecopykeyword\nargument to False:\nG=nx.path_graph(3)# nodes 0-1-2\nmapping={0:\"a\",1:\"b\"}# 0->'a' and 1->'b'\nG=nx.relabel_nodes(G,mapping,copy=False)\nsorted(G,key=str)\n# [2, 'a', 'b']\nA mapping can also be given as a function:\nG=nx.path_graph(3)\nH=nx.relabel_nodes(G,lambdax:x**2)\nlist(H)\n# [0, 1, 4]\nIn a multigraph, relabeling two or more nodes to the same new node\nwill retain all edges, but may change the edge keys in the process:\nG=nx.MultiGraph()\nG.add_edge(0,1,value=\"a\")# returns the key for this edge\n# 0\nG.add_edge(0,2,value=\"b\")\n# 0\nG.add_edge(0,3,value=\"c\")\n# 0\nmapping={1:4,2:4,3:4}\nH=nx.relabel_nodes(G,mapping,copy=True)\nprint(H[0])\n# {4: {0: {'value': 'a'}, 1: {'value': 'b'}, 2: {'value': 'c'}}}\nThis works for in-place relabeling too:\nG=nx.relabel_nodes(G,mapping,copy=False)\nprint(G[0])\n# {4: {0: {'value': 'a'}, 1: {'value': 'b'}, 2: {'value': 'c'}}}"
        }
    },
    {
        "Section ID": "all_triplets",
        "Description": [
            "Returns a generator of all possible sets of 3 nodes in a DiGraph."
        ],
        "Field List": {
            "Parameters:": {
                "G : digraph": "A NetworkX DiGraph"
            },
            "Returns:": {
                "triplets : generator of 3-tuples": "Generator of tuples of 3 nodes"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.DiGraph([(1,2),(2,3),(3,4)])\nlist(nx.all_triplets(G))\n# [(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)]"
        }
    },
    {
        "Section ID": "minimum_st_edge_cut",
        "Description": [
            "Returns the edges of the cut-set of a minimum (s, t)-cut.",
            "This function returns the set of edges of minimum cardinality that,\nif removed, would destroy all paths among source and target in G.\nEdge weights are not considered. See minimum_cut() for\ncomputing minimum cuts considering edge weights."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "s : node": "Source node for the flow.",
                "t : node": "Sink node for the flow.",
                "auxiliary : NetworkX DiGraph": "Auxiliary digraph to compute flow based node connectivity. It has\nto have a graph attribute called mapping with a dictionary mapping\nnode names in G and in the auxiliary digraph. If provided\nit will be reused instead of recreated. Default value: None.",
                "flow_func : function": "A function for computing the maximum flow among a pair of nodes.\nThe function has to accept at least three parameters: a Digraph,\na source node, and a target node. And return a residual network\nthat follows NetworkX conventions (seemaximum_flow()for\ndetails). If flow_func is None, the default maximum flow function\n(edmonds_karp()) is used. Seenode_connectivity()for\ndetails. The choice of the default function may change from version\nto version and should not be relied on. Default value: None.",
                "residual : NetworkX DiGraph": "Residual network to compute maximum flow. If provided it will be\nreused instead of recreated. Default value: None."
            },
            "Returns:": {
                "cutset : set": "Set of edges that, if removed from the graph, will disconnect it."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "This function is not imported in the base NetworkX namespace, so you\nhave to explicitly import it from the connectivity package:\nfromnetworkx.algorithms.connectivityimportminimum_st_edge_cut\nWe use in this example the platonic icosahedral graph, which has edge\nconnectivity 5.\nG=nx.icosahedral_graph()\nlen(minimum_st_edge_cut(G,0,6))\n# 5\nIf you need to compute local edge cuts on several pairs of\nnodes in the same graph, it is recommended that you reuse the\ndata structures that NetworkX uses in the computation: the\nauxiliary digraph for edge connectivity, and the residual\nnetwork for the underlying maximum flow computation.\nExample of how to compute local edge cuts among all pairs of\nnodes of the platonic icosahedral graph reusing the data\nstructures.\nimportitertools\n# You also have to explicitly import the function for\n# building the auxiliary digraph from the connectivity package\nfromnetworkx.algorithms.connectivityimportbuild_auxiliary_edge_connectivity\nH=build_auxiliary_edge_connectivity(G)\n# And the function for building the residual network from the\n# flow package\nfromnetworkx.algorithms.flowimportbuild_residual_network\n# Note that the auxiliary digraph has an edge attribute named capacity\nR=build_residual_network(H,\"capacity\")\nresult=dict.fromkeys(G,dict())\n# Reuse the auxiliary digraph and the residual network by passing them\n# as parameters\nforu,vinitertools.combinations(G,2):\nk=len(minimum_st_edge_cut(G,u,v,auxiliary=H,residual=R))\nresult[u][v]=k\nall(result[u][v]==5foru,vinitertools.combinations(G,2))\n# True\nYou can also use alternative flow algorithms for computing edge\ncuts. For instance, in dense networks the algorithmshortest_augmenting_path()will usually perform better than\nthe defaultedmonds_karp()which is faster for sparse\nnetworks with highly skewed degree distributions. Alternative flow\nfunctions have to be explicitly imported from the flow package.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\nlen(minimum_st_edge_cut(G,0,6,flow_func=shortest_augmenting_path))\n# 5"
        }
    },
    {
        "Section ID": "periphery",
        "Description": [
            "Returns the periphery of the graph G.",
            "The periphery is the set of nodes with eccentricity equal to the diameter."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A graph",
                "e : eccentricity dictionary, optional": "A precomputed dictionary of eccentricities.",
                "weight : string, function, or None": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number.If this is None, every edge has weight/distance/cost 1.Weights stored as floating point values can lead to small round-off\nerrors in distances. Use integer weights to avoid this.Weights should be positive, since they are distances."
            },
            "Returns:": {
                "p : list": "List of nodes in periphery"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph([(1,2),(1,3),(1,4),(3,4),(3,5),(4,5)])\nnx.periphery(G)\n# [2, 5]"
        }
    },
    {
        "Section ID": "is_bipartite_node_set",
        "Description": [
            "Returns True if nodes and G/nodes are a bipartition of G."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "nodes: list or container": "Check if nodes are a one of a bipartite set."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "An exception is raised if the input nodes are not distinct, because in this\ncase some bipartite algorithms will yield incorrect results.\nFor connected graphs the bipartite sets are unique.  This function handles\ndisconnected graphs.",
            "Examples": "fromnetworkx.algorithmsimportbipartite\nG=nx.path_graph(4)\nX=set([1,3])\nbipartite.is_bipartite_node_set(G,X)\n# True"
        }
    },
    {
        "Section ID": "from_numpy_array",
        "Description": [
            "Returns a graph from a 2D NumPy array.",
            "The 2D NumPy array is interpreted as an adjacency matrix for the graph."
        ],
        "Field List": {
            "Parameters:": {
                "A : a 2D numpy.ndarray": "An adjacency matrix representation of a graph",
                "parallel_edges : Boolean": "If this is True,create_usingis a multigraph, andAis an\ninteger array, then entry(i, j)in the array is interpreted as the\nnumber of parallel edges joining verticesiandjin the graph.\nIf it is False, then the entries in the array are interpreted as\nthe weight of a single edge joining the vertices.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated.",
                "edge_attr : String, optional (default=\u201dweight\u201d)": "The attribute to which the array values are assigned on each edge. If\nit is None, edge attributes will not be assigned."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For directed graphs, explicitly mention create_using=nx.DiGraph,\nand entry i,j of A corresponds to an edge from i to j. If create_using is networkx.MultiGraph or networkx.MultiDiGraph , parallel_edges is True, and the\nentries of A are of type int , then this function returns a\nmultigraph (of the same type as create_using ) with parallel edges. If create_using indicates an undirected multigraph, then only the edges\nindicated by the upper triangle of the array A will be added to the\ngraph. If edge_attr is Falsy (False or None), edge attributes will not be\nassigned, and the array data will be treated like a binary mask of\nedge presence or absence. Otherwise, the attributes will be assigned\nas follows: If the NumPy array has a single data type for each array entry it\nwill be converted to an appropriate Python data type. If the NumPy array has a user-specified compound data type the names\nof the data fields will be used as attribute keys in the resulting\nNetworkX graph.",
            "Examples": "Simple integer weights on edges:\nimportnumpyasnp\nA=np.array([[1,1],[2,1]])\nG=nx.from_numpy_array(A)\nG.edges(data=True)\n# EdgeDataView([(0, 0, {'weight': 1}), (0, 1, {'weight': 2}), (1, 1, {'weight': 1})])\nIfcreate_usingindicates a multigraph and the array has only integer\nentries andparallel_edgesis False, then the entries will be treated\nas weights for edges joining the nodes (without creating parallel edges):\nA=np.array([[1,1],[1,2]])\nG=nx.from_numpy_array(A,create_using=nx.MultiGraph)\nG[1][1]\n# AtlasView({0: {'weight': 2}})\nIfcreate_usingindicates a multigraph and the array has only integer\nentries andparallel_edgesis True, then the entries will be treated\nas the number of parallel edges joining those two vertices:\nA=np.array([[1,1],[1,2]])\ntemp=nx.MultiGraph()\nG=nx.from_numpy_array(A,parallel_edges=True,create_using=temp)\nG[1][1]\n# AtlasView({0: {'weight': 1}, 1: {'weight': 1}})\nUser defined compound data type on edges:\ndt=[(\"weight\",float),(\"cost\",int)]\nA=np.array([[(1.0,2)]],dtype=dt)\nG=nx.from_numpy_array(A)\nG.edges()\n# EdgeView([(0, 0)])\nG[0][0][\"cost\"]\n# 2\nG[0][0][\"weight\"]\n# 1.0"
        }
    },
    {
        "Section ID": "number_of_isolates",
        "Description": [
            "Returns the number of isolates in the graph.",
            "An isolate is a node with no neighbors (that is, with degree\nzero). For directed graphs, this means no in-neighbors and no\nout-neighbors."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": ""
            },
            "Returns:": {
                "int": "The number of degree zero nodes in the graphG."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "cycle_basis",
        "Description": [
            "Returns a list of cycles which form a basis for cycles of G.",
            "A basis for cycles of a network is a minimal collection of\ncycles such that any cycle in the network can be written\nas a sum of cycles in the basis.  Here summation of cycles\nis defined as \u201cexclusive or\u201d of the edges. Cycle bases are\nuseful, e.g. when deriving equations for electric circuits\nusing Kirchhoff\u2019s Laws."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "",
                "root : node, optional": "Specify starting node for basis."
            },
            "Returns:": {
                "A list of cycle lists.  Each cycle list is a list of nodes": "",
                "which forms a cycle (loop) in G.": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This is adapted from algorithm CACM 491 [1] .",
            "References": "[1]Paton, K. An algorithm for finding a fundamental set of\ncycles of a graph. Comm. ACM 12, 9 (Sept 1969), 514-518.",
            "Examples": "G=nx.Graph()\nnx.add_cycle(G,[0,1,2,3])\nnx.add_cycle(G,[0,3,4,5])\nnx.cycle_basis(G,0)\n# [[3, 4, 5, 0], [1, 2, 3, 0]]"
        }
    },
    {
        "Section ID": "johnson",
        "Description": [
            "Uses Johnson\u2019s Algorithm to compute shortest paths.",
            "Johnson\u2019s Algorithm finds a shortest path between each pair of\nnodes in a weighted graph even if negative weights are present."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number."
            },
            "Returns:": {
                "distance : dictionary": "Dictionary, keyed by source and target, of shortest paths."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Johnson\u2019s algorithm is suitable even for graphs with negative weights. It\nworks by using the Bellman\u2013Ford algorithm to compute a transformation of\nthe input graph that removes all negative weights, allowing Dijkstra\u2019s\nalgorithm to be used on the transformed graph. The time complexity of this algorithm is \\(O(n^2 \\log n + n m)\\) ,\nwhere \\(n\\) is the number of nodes and \\(m\\) the number of edges in the\ngraph. For dense graphs, this may be faster than the Floyd\u2013Warshall\nalgorithm.",
            "Examples": "graph=nx.DiGraph()\ngraph.add_weighted_edges_from(\n[(\"0\",\"3\",3),(\"0\",\"1\",-5),(\"0\",\"2\",2),(\"1\",\"2\",4),(\"2\",\"3\",1)]\n)\npaths=nx.johnson(graph,weight=\"weight\")\npaths[\"0\"][\"2\"]\n# ['0', '1', '2']"
        }
    },
    {
        "Section ID": "second_order_centrality",
        "Description": [
            "Compute the second order centrality for nodes of G.",
            "The second order centrality of a given node is the standard deviation of\nthe return times to that node of a perpetual random walk on G:"
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX connected and undirected graph.",
                "weight : string or None, optional (default=\u201dweight\u201d)": "The name of an edge attribute that holds the numerical value\nused as a weight. If None then each edge has weight 1."
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary keyed by node with second order centrality as the value."
            },
            "Raises:": {
                "NetworkXException": "If the graph G is empty, non connected or has negative weights."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Lower values of second order centrality indicate higher centrality. The algorithm is from Kermarrec, Le Merrer, Sericola and Tr\u00e9dan [1] . This code implements the analytical version of the algorithm, i.e.,\nthere is no simulation of a random walk process involved. The random walk\nis here unbiased (corresponding to eq 6 of the paper [1] ), thus the\ncentrality values are the standard deviations for random walk return times\non the transformed input graph G (equal in-degree at each nodes by adding\nself-loops). Complexity of this implementation, made to run locally on a single machine,\nis O(n^3), with n the size of G, which makes it viable only for small\ngraphs.",
            "References": "[1](1,2)Anne-Marie Kermarrec, Erwan Le Merrer, Bruno Sericola, Gilles Tr\u00e9dan\n\u201cSecond order centrality: Distributed assessment of nodes criticity in\ncomplex networks\u201d, Elsevier Computer Communications 34(5):619-628, 2011.",
            "Examples": "G=nx.star_graph(10)\nsoc=nx.second_order_centrality(G)\nprint(sorted(soc.items(),key=lambdax:x[1])[0][0])# pick first id\n# 0"
        }
    },
    {
        "Section ID": "is_attracting_component",
        "Description": [
            "Returns True if G consists of a single attracting component."
        ],
        "Field List": {
            "Parameters:": {
                "G : DiGraph, MultiDiGraph": "The graph to be analyzed."
            },
            "Returns:": {
                "attracting : bool": "True ifGhas a single attracting component. Otherwise, False."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the input graph is undirected."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "partial_duplication_graph",
        "Description": [
            "Returns a random graph using the partial duplication model."
        ],
        "Field List": {
            "Parameters:": {
                "N : int": "The total number of nodes in the final graph.",
                "n : int": "The number of nodes in the initial clique.",
                "p : float": "The probability of joining each neighbor of a node to the\nduplicate node. Must be a number in the between zero and one,\ninclusive.",
                "q : float": "The probability of joining the source node to the duplicate\nnode. Must be a number in the between zero and one, inclusive.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "A graph of nodes is grown by creating a fully connected graph\nof size n . The following procedure is then repeated until\na total of N nodes have been reached.",
            "References": "[1]Knudsen Michael, and Carsten Wiuf. \u201cA Markov chain approach to\nrandomly grown graphs.\u201d Journal of Applied Mathematics 2008.\n<https://doi.org/10.1155/2008/190836>"
        }
    },
    {
        "Section ID": "simrank_similarity",
        "Description": [
            "Returns the SimRank similarity of nodes in the graph G .",
            "SimRank is a similarity metric that says \u201ctwo objects are considered\nto be similar if they are referenced by similar objects.\u201d [1] .",
            "The pseudo-code definition from the paper is:",
            "where G is the graph, u is the source, v is the target,\nand C is a float decay or importance factor between 0 and 1.",
            "The SimRank algorithm for determining node similarity is defined in [2] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A NetworkX graph",
                "source : node": "If this is specified, the returned dictionary maps each nodevin the graph to the similarity betweensourceandv.",
                "target : node": "If bothsourceandtargetare specified, the similarity\nvalue betweensourceandtargetis returned. Iftargetis specified butsourceis not, this argument is\nignored.",
                "importance_factor : float": "The relative importance of indirect neighbors with respect to\ndirect neighbors.",
                "max_iterations : integer": "Maximum number of iterations.",
                "tolerance : float": "Error tolerance used to check convergence. When an iteration of\nthe algorithm finds that no similarity value changes more than\nthis amount, the algorithm halts."
            },
            "Returns:": {
                "similarity : dictionary or float": "Ifsourceandtargetare bothNone, this returns a\ndictionary of dictionaries, where keys are node pairs and value\nare similarity of the pair of nodes.Ifsourceis notNonebuttargetis, this returns a\ndictionary mapping node to the similarity ofsourceand that\nnode.If neithersourcenortargetisNone, this returns\nthe similarity value for the given pair of nodes."
            },
            "Raises:": {
                "ExceededMaxIterations": "If the algorithm does not converge withinmax_iterations.",
                "NodeNotFound": "If eithersourceortargetis not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://en.wikipedia.org/wiki/SimRank  [2]G. Jeh and J. Widom.\n\u201cSimRank: a measure of structural-context similarity\u201d,\nIn KDD\u201902: Proceedings of the Eighth ACM SIGKDD\nInternational Conference on Knowledge Discovery and Data Mining,\npp. 538\u2013543. ACM Press, 2002.",
            "Examples": "G=nx.cycle_graph(2)\nnx.simrank_similarity(G)\n# {0: {0: 1.0, 1: 0.0}, 1: {0: 0.0, 1: 1.0}}\nnx.simrank_similarity(G,source=0)\n# {0: 1.0, 1: 0.0}\nnx.simrank_similarity(G,source=0,target=0)\n# 1.0\nThe result of this function can be converted to a numpy array\nrepresenting the SimRank matrix by using the node order of the\ngraph to determine which row and column represent each node.\nOther ordering of nodes is also possible.\nimportnumpyasnp\nsim=nx.simrank_similarity(G)\nnp.array([[sim[u][v]forvinG]foruinG])\n# array([[1., 0.],\n#        [0., 1.]])\nsim_1d=nx.simrank_similarity(G,source=0)\nnp.array([sim[0][v]forvinG])\n# array([1., 0.])"
        }
    },
    {
        "Section ID": "node_link_graph",
        "Description": [
            "Returns graph from node-link data format.\nUseful for de-serialization from JSON."
        ],
        "Field List": {
            "Parameters:": {
                "data : dict": "node-link formatted graph data",
                "directed : bool": "If True, and direction not specified in data, return a directed graph.",
                "multigraph : bool": "If True, and multigraph not specified in data, return a multigraph.",
                "source : string": "A string that provides the \u2018source\u2019 attribute name for storing NetworkX-internal graph data.",
                "target : string": "A string that provides the \u2018target\u2019 attribute name for storing NetworkX-internal graph data.",
                "name : string": "A string that provides the \u2018name\u2019 attribute name for storing NetworkX-internal graph data.",
                "key : string": "A string that provides the \u2018key\u2019 attribute name for storing NetworkX-internal graph data.",
                "link : string": "A string that provides the \u2018link\u2019 attribute name for storing NetworkX-internal graph data."
            },
            "Returns:": {
                "G : NetworkX graph": "A NetworkX graph object"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Attribute \u2018key\u2019 is only used for multigraphs. To use node_link_data in conjunction with node_link_graph ,\nthe keyword names for the attributes must match.",
            "Examples": "Create data in node-link format by converting a graph.\nG=nx.Graph([(\"A\",\"B\")])\ndata=nx.node_link_data(G)\ndata\n# {'directed': False, 'multigraph': False, 'graph': {}, 'nodes': [{'id': 'A'}, {'id': 'B'}], 'links': [{'source': 'A', 'target': 'B'}]}\nRevert data in node-link format to a graph.\nH=nx.node_link_graph(data)\nprint(H.edges)\n# [('A', 'B')]\nTo serialize and deserialize a graph with JSON,\nimportjson\nd=json.dumps(node_link_data(G))\nH=node_link_graph(json.loads(d))\nprint(G.edges,H.edges)\n# [('A', 'B')] [('A', 'B')]"
        }
    },
    {
        "Section ID": "k_edge_components",
        "Description": [
            "Generates nodes in each maximal k-edge-connected component in G."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "k : Integer": "Desired edge connectivity"
            },
            "Returns:": {
                "k_edge_components : a generator of k-edge-ccs. Each set of returned nodes": "will have k-edge-connectivity in the graph G."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the input graph is a multigraph.",
                "ValueError:": "If k is less than 1"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Attempts to use the most efficient implementation available based on k.\nIf k=1, this is simply connected components for directed graphs and\nconnected components for undirected graphs.\nIf k=2 on an efficient bridge connected component algorithm from _[1] is\nrun based on the chain decomposition.\nOtherwise, the algorithm from _[2] is used.",
            "References": "[1]https://en.wikipedia.org/wiki/Bridge_%28graph_theory%29  [2]Wang, Tianhao, et al. (2015) A simple algorithm for finding all\nk-edge-connected components.http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0136264",
            "Examples": "importitertoolsasit\nfromnetworkx.utilsimportpairwise\npaths=[\n(1,2,4,3,1,4),\n(5,6,7,8,5,7,8,6),\n]\nG=nx.Graph()\nG.add_nodes_from(it.chain(*paths))\nG.add_edges_from(it.chain(*[pairwise(path)forpathinpaths]))\n# note this returns {1, 4} unlike k_edge_subgraphs\nsorted(map(sorted,nx.k_edge_components(G,k=3)))\n# [[1, 4], [2], [3], [5, 6, 7, 8]]"
        }
    },
    {
        "Section ID": "laplacian_matrix",
        "Description": [
            "Returns the Laplacian matrix of G.",
            "The graph Laplacian is the matrix L = D - A, where\nA is the adjacency matrix and D is the diagonal matrix of node degrees."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "nodelist : list, optional": "The rows and columns are ordered according to the nodes in nodelist.\nIf nodelist is None, then the ordering is produced by G.nodes().",
                "weight : string or None, optional (default=\u2019weight\u2019)": "The edge data key used to compute each value in the matrix.\nIf None, then each edge has weight 1."
            },
            "Returns:": {
                "L : SciPy sparse array": "The Laplacian matrix of G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For MultiGraph, the edges weights are summed. This returns an unnormalized matrix. For a normalized output,\nuse normalized_laplacian_matrix , directed_laplacian_matrix ,\nor directed_combinatorial_laplacian_matrix . This calculation uses the out-degree of the graph G . To use the\nin-degree for calculations instead, use G.reverse(copy=False) and\ntake the transpose.",
            "References": "[1]Langville, Amy N., and Carl D. Meyer. Google\u2019s PageRank and Beyond:\nThe Science of Search Engine Rankings. Princeton University Press, 2006.",
            "Examples": "For graphs with multiple connected components, L is permutation-similar\nto a block diagonal matrix where each block is the respective Laplacian\nmatrix for each component.\nG=nx.Graph([(1,2),(2,3),(4,5)])\nprint(nx.laplacian_matrix(G).toarray())\n# [[ 1 -1  0  0  0]\n#  [-1  2 -1  0  0]\n#  [ 0 -1  1  0  0]\n#  [ 0  0  0  1 -1]\n#  [ 0  0  0 -1  1]]\nedges=[\n(1,2),\n(2,1),\n(2,4),\n(4,3),\n(3,4),\n]\nDiG=nx.DiGraph(edges)\nprint(nx.laplacian_matrix(DiG).toarray())\n# [[ 1 -1  0  0]\n#  [-1  2 -1  0]\n#  [ 0  0  1 -1]\n#  [ 0  0 -1  1]]\nNotice that node 4 is represented by the third column and row. This is because\nby default the row/column order is the order ofG.nodes(i.e. the node added\norder \u2013 in the edgelist, 4 first appears in (2, 4), before node 3 in edge (4, 3).)\nTo control the node order of the matrix, use thenodelistargument.\nprint(nx.laplacian_matrix(DiG,nodelist=[1,2,3,4]).toarray())\n# [[ 1 -1  0  0]\n#  [-1  2  0 -1]\n#  [ 0  0  1 -1]\n#  [ 0  0 -1  1]]\nThis calculation uses the out-degree of the graphG. To use the\nin-degree for calculations instead, useG.reverse(copy=False)and\ntake the transpose.\nprint(nx.laplacian_matrix(DiG.reverse(copy=False)).toarray().T)\n# [[ 1 -1  0  0]\n#  [-1  1 -1  0]\n#  [ 0  0  2 -1]\n#  [ 0  0 -1  1]]"
        }
    },
    {
        "Section ID": "flow_hierarchy",
        "Description": [
            "Returns the flow hierarchy of a directed network.",
            "Flow hierarchy is defined as the fraction of edges not participating\nin cycles in a directed graph [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : DiGraph or MultiDiGraph": "A directed graph",
                "weight : string, optional (default=None)": "Attribute to use for edge weights. If None the weight defaults to 1."
            },
            "Returns:": {
                "h : float": "Flow hierarchy value"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The algorithm described in [1] computes the flow hierarchy through\nexponentiation of the adjacency matrix.  This function implements an\nalternative approach that finds strongly connected components.\nAn edge is in a cycle if and only if it is in a strongly connected\ncomponent, which can be found in \\(O(m)\\) time using Tarjan\u2019s algorithm.",
            "References": "[1](1,2)Luo, J.; Magee, C.L. (2011),\nDetecting evolving patterns of self-organizing networks by flow\nhierarchy measurement, Complexity, Volume 16 Issue 6 53-61.\nDOI: 10.1002/cplx.20368http://web.mit.edu/~cmagee/www/documents/28-DetectingEvolvingPatterns_FlowHierarchy.pdf"
        }
    },
    {
        "Section ID": "edge_current_flow_betweenness_centrality_subset",
        "Description": [
            "Compute current-flow betweenness centrality for edges using subsets\nof nodes.",
            "Current-flow betweenness centrality uses an electrical current\nmodel for information spreading in contrast to betweenness\ncentrality which uses shortest paths.",
            "Current-flow betweenness centrality is also known as\nrandom-walk betweenness centrality [2] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "sources: list of nodes": "Nodes to use as sources for current",
                "targets: list of nodes": "Nodes to use as sinks for current",
                "normalized : bool, optional (default=True)": "If True the betweenness values are normalized by b=b/(n-1)(n-2) where\nn is the number of nodes in G.",
                "weight : string or None, optional (default=None)": "Key for edge data used as the edge weight.\nIf None, then use 1 as each edge weight.\nThe weight reflects the capacity or the strength of the\nedge.",
                "dtype: data type (float)": "Default data type for internal matrices.\nSet to np.float32 for lower memory consumption.",
                "solver: string (default=\u2019lu\u2019)": "Type of linear solver to use for computing the flow matrix.\nOptions are \u201cfull\u201d (uses most memory), \u201clu\u201d (recommended), and\n\u201ccg\u201d (uses least memory)."
            },
            "Returns:": {
                "nodes : dict": "Dictionary of edge tuples with betweenness centrality as the value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Current-flow betweenness can be computed in \\(O(I(n-1)+mn \\log n)\\) time [1] , where \\(I(n-1)\\) is the time needed to compute the\ninverse Laplacian.  For a full matrix this is \\(O(n^3)\\) but using\nsparse methods you can achieve \\(O(nm{\\sqrt k})\\) where \\(k\\) is the\nLaplacian matrix condition number. The space required is \\(O(nw)\\) where \\(w\\) is the width of the sparse\nLaplacian matrix.  Worse case is \\(w=n\\) for \\(O(n^2)\\) . If the edges have a \u2018weight\u2019 attribute they will be used as\nweights in this algorithm.  Unspecified weights are set to 1.",
            "References": "[1]Centrality Measures Based on Current Flow.\nUlrik Brandes and Daniel Fleischer,\nProc. 22nd Symp. Theoretical Aspects of Computer Science (STACS \u201805).\nLNCS 3404, pp. 533-544. Springer-Verlag, 2005.https://doi.org/10.1007/978-3-540-31856-9_44  [2]A measure of betweenness centrality based on random walks,\nM. E. J. Newman, Social Networks 27, 39-54 (2005)."
        }
    },
    {
        "Section ID": "max_weight_clique",
        "Description": [
            "Find a maximum weight clique in G.",
            "A clique in a graph is a set of nodes such that every two distinct nodes\nare adjacent.  The weight of a clique is the sum of the weights of its\nnodes.  A maximum weight clique of graph G is a clique C in G such that\nno clique in G has weight greater than the weight of C."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected graph",
                "weight : string or None, optional (default=\u2019weight\u2019)": "The node attribute that holds the integer value used as a weight.\nIf None, then each node has weight 1."
            },
            "Returns:": {
                "clique : list": "the nodes of a maximum weight clique",
                "weight : int": "the weight of a maximum weight clique"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The implementation is recursive, and therefore it may run into recursion\ndepth issues if G contains a clique whose number of nodes is close to the\nrecursion depth limit. At each search node, the algorithm greedily constructs a weighted\nindependent set cover of part of the graph in order to find a small set of\nnodes on which to branch.  The algorithm is very similar to the algorithm\nof Tavares et al. [1] , other than the fact that the NetworkX version does\nnot use bitsets.  This style of algorithm for maximum weight clique (and\nmaximum weight independent set, which is the same problem but on the\ncomplement graph) has a decades-long history.  See Algorithm B of Warren\nand Hicks [2] and the references in that paper.",
            "References": "[1]Tavares, W.A., Neto, M.B.C., Rodrigues, C.D., Michelon, P.: Um\nalgoritmo de branch and bound para o problema da clique m\u00e1xima\nponderada.  Proceedings of XLVII SBPO 1 (2015).  [2]Warren, Jeffrey S, Hicks, Illya V.: Combinatorial Branch-and-Bound\nfor the Maximum Weight Independent Set Problem.  Technical Report,\nTexas A&M University (2016)."
        }
    },
    {
        "Section ID": "cycle_graph",
        "Description": [
            "Returns the cycle graph \\(C_n\\) of cyclically connected nodes.",
            "\\(C_n\\) is a path with its two end-nodes connected.",
            "( Sourcecode , png )"
        ],
        "Field List": {
            "Parameters:": {
                "n : int or iterable container of nodes": "If n is an integer, nodes are fromrange(n).\nIf n is a container of nodes, those nodes appear in the graph.\nWarning: n is not checked for duplicates and if present the\nresulting graph may not be as desired. Make sure you have no duplicates.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "If create_using is directed, the direction is in increasing order."
        }
    },
    {
        "Section ID": "stoer_wagner",
        "Description": [
            "Returns the weighted minimum edge cut using the Stoer-Wagner algorithm.",
            "Determine the minimum edge cut of a connected graph using the\nStoer-Wagner algorithm. In weighted cases, all weights must be\nnonnegative.",
            "The running time of the algorithm depends on the type of heaps used:"
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Edges of the graph are expected to have an attribute named by the\nweight parameter below. If this attribute is not present, the edge is\nconsidered to have unit weight.",
                "weight : string": "Name of the weight attribute of the edges. If the attribute is not\npresent, unit weight is assumed. Default value: \u2018weight\u2019.",
                "heap : class": "Type of heap to be used in the algorithm. It should be a subclass ofMinHeapor implement a compatible interface.If a stock heap implementation is to be used,BinaryHeapis\nrecommended overPairingHeapfor Python implementations without\noptimized attribute accesses (e.g., CPython) despite a slower\nasymptotic running time. For Python implementations with optimized\nattribute accesses (e.g., PyPy),PairingHeapprovides better\nperformance. Default value:BinaryHeap."
            },
            "Returns:": {
                "cut_value : integer or float": "The sum of weights of edges in a minimum cut.",
                "partition : pair of node lists": "A partitioning of the nodes that defines a minimum cut."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the graph is directed or a multigraph.",
                "NetworkXError": "If the graph has less than two nodes, is not connected or has a\nnegative-weighted edge."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph()\nG.add_edge(\"x\",\"a\",weight=3)\nG.add_edge(\"x\",\"b\",weight=1)\nG.add_edge(\"a\",\"c\",weight=3)\nG.add_edge(\"b\",\"c\",weight=5)\nG.add_edge(\"b\",\"d\",weight=4)\nG.add_edge(\"d\",\"e\",weight=2)\nG.add_edge(\"c\",\"y\",weight=2)\nG.add_edge(\"e\",\"y\",weight=3)\ncut_value,partition=nx.stoer_wagner(G)\ncut_value\n# 4"
        }
    },
    {
        "Section ID": "from_pandas_adjacency",
        "Description": [
            "Returns a graph from Pandas DataFrame.",
            "The Pandas DataFrame is interpreted as an adjacency matrix for the graph."
        ],
        "Field List": {
            "Parameters:": {
                "df : Pandas DataFrame": "An adjacency matrix representation of a graph",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For directed graphs, explicitly mention create_using=nx.DiGraph,\nand entry i,j of df corresponds to an edge from i to j. If df has a single data type for each entry it will be converted to an\nappropriate Python data type. If you have node attributes stored in a separate dataframe df_nodes ,\nyou can load those attributes to the graph G using the following code: `df_nodes=pd.DataFrame({\"node_id\":[1,2,3],\"attribute1\":[\"A\",\"B\",\"C\"]})G.add_nodes_from((n,dict(d))forn,dindf_nodes.iterrows())` If df has a user-specified compound data type the names\nof the data fields will be used as attribute keys in the resulting\nNetworkX graph.",
            "Examples": "Simple integer weights on edges:\nimportpandasaspd\npd.options.display.max_columns=20\ndf=pd.DataFrame([[1,1],[2,1]])\ndf\n#    0  1\n# 0  1  1\n# 1  2  1\nG=nx.from_pandas_adjacency(df)\nG.name=\"Graph from pandas adjacency matrix\"\nprint(G)\n# Graph named 'Graph from pandas adjacency matrix' with 2 nodes and 3 edges"
        }
    },
    {
        "Section ID": "spectral_ordering",
        "Description": [
            "Compute the spectral_ordering of a graph.",
            "The spectral ordering of a graph is an ordering of its nodes where nodes\nin the same weakly connected components appear contiguous and ordered by\ntheir corresponding elements in the Fiedler vector of the component."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A graph.",
                "weight : object, optional (default: None)": "The data key used to determine the weight of each edge. If None, then\neach edge has unit weight.",
                "normalized : bool, optional (default: False)": "Whether the normalized Laplacian matrix is used.",
                "tol : float, optional (default: 1e-8)": "Tolerance of relative residual in eigenvalue computation.",
                "method : string, optional (default: \u2018tracemin_pcg\u2019)": "Method of eigenvalue computation. It must be one of the tracemin\noptions shown below (TraceMIN), \u2018lanczos\u2019 (Lanczos iteration)\nor \u2018lobpcg\u2019 (LOBPCG).The TraceMIN algorithm uses a linear system solver. The following\nvalues allow specifying the solver to be used.ValueSolver\u2018tracemin_pcg\u2019Preconditioned conjugate gradient method\u2018tracemin_lu\u2019LU factorization",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "spectral_ordering : NumPy array of floats.": "Spectral ordering of nodes."
            },
            "Raises:": {
                "NetworkXError": "If G is empty."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weights are interpreted by their absolute values. For MultiGraph\u2019s,\nweights of parallel edges are summed. Zero-weighted edges are ignored."
        }
    },
    {
        "Section ID": "numeric_assortativity_coefficient",
        "Description": [
            "Compute assortativity for numerical node attributes.",
            "Assortativity measures the similarity of connections\nin the graph with respect to the given numeric attribute."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "attribute : string": "Node attribute key.",
                "nodes: list or iterable (optional)": "Compute numeric assortativity only for attributes of nodes in\ncontainer. The default is all nodes."
            },
            "Returns:": {
                "r: float": "Assortativity of graph for given attribute"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This computes Eq. (21) in Ref. [1] , which is the Pearson correlation\ncoefficient of the specified (scalar valued) attribute across edges.",
            "References": "[1]M. E. J. Newman, Mixing patterns in networks\nPhysical Review E, 67 026126, 2003",
            "Examples": "G=nx.Graph()\nG.add_nodes_from([0,1],size=2)\nG.add_nodes_from([2,3],size=3)\nG.add_edges_from([(0,1),(2,3)])\nprint(nx.numeric_assortativity_coefficient(G,\"size\"))\n# 1.0"
        }
    },
    {
        "Section ID": "degrees",
        "Description": [
            "Returns the degrees of the two node sets in the bipartite graph B."
        ],
        "Field List": {
            "Parameters:": {
                "B : NetworkX graph": "",
                "nodes: list or container": "Nodes in one node set of the bipartite graph.",
                "weight : string or None, optional (default=None)": "The edge attribute that holds the numerical value used as a weight.\nIf None, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node."
            },
            "Returns:": {
                "(degX,degY) : tuple of dictionaries": "The degrees of the two bipartite sets as dictionaries keyed by node."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The container of nodes passed as argument must contain all nodes\nin one of the two bipartite node sets to avoid ambiguity in the\ncase of disconnected graphs.\nSee bipartitedocumentation for further details on how bipartite graphs are handled in NetworkX.",
            "Examples": "fromnetworkx.algorithmsimportbipartite\nG=nx.complete_bipartite_graph(3,2)\nY=set([3,4])\ndegX,degY=bipartite.degrees(G,Y)\ndict(degX)\n# {0: 2, 1: 2, 2: 2}"
        }
    },
    {
        "Section ID": "treewidth_min_degree",
        "Description": [
            "Returns a treewidth decomposition using the Minimum Degree heuristic.",
            "The heuristic chooses the nodes according to their degree, i.e., first\nthe node with the lowest degree is chosen, then the graph is updated\nand the corresponding node is removed. Next, a new node with the lowest\ndegree is chosen, and so on."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": ""
            },
            "Returns:": {
                "Treewidth decomposition : (int, Graph) tuple": "2-tuple with treewidth and the corresponding decomposed tree."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "argmap",
        "Description": [
            "A decorator to apply a map to arguments before calling the function",
            "This class provides a decorator that maps (transforms) arguments of the function\nbefore the function is called. Thus for example, we have similar code\nin many functions to determine whether an argument is the number of nodes\nto be created, or a list of nodes to be handled. The decorator provides\nthe code to accept either \u2013 transforming the indicated argument into a\nlist of nodes before the actual function is called.",
            "This decorator class allows us to process single or multiple arguments.\nThe arguments to be processed can be specified by string, naming the argument,\nor by index, specifying the item in the args list."
        ],
        "Field List": {
            "Parameters:": {
                "func : callable": "The function to apply to arguments",
                "*args : iterable of (int, str or tuple)": "A list of parameters, specified either as strings (their names), ints\n(numerical indices) or tuples, which may contain ints, strings, and\n(recursively) tuples. Each indicates which parameters the decorator\nshould map. Tuples indicate that the map function takes (and returns)\nmultiple parameters in the same order and nested structure as indicated\nhere.",
                "try_finally : bool (default: False)": "When True, wrap the function call in a try-finally block with code\nfor the finally block created byfunc. This is used when the map\nfunction constructs an object (like a file handle) that requires\npost-processing (like closing).Note: try_finally decorators cannot be used to decorate generator\nfunctions."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "An object of this class is callable and intended to be used when\ndefining a decorator. Generally, a decorator takes a function as input\nand constructs a function as output. Specifically, an argmap object\nreturns the input function decorated/wrapped so that specified arguments\nare mapped (transformed) to new values before the decorated function is called. As an overview, the argmap object returns a new function with all the\ndunder values of the original function (like __doc__ , __name__ , etc).\nCode for this decorated function is built based on the original function\u2019s\nsignature. It starts by mapping the input arguments to potentially new\nvalues. Then it calls the decorated function with these new values in place\nof the indicated arguments that have been mapped. The return value of the\noriginal function is then returned. This new function is the function that\nis actually called by the user.",
            "Examples": "Most of these examples use@argmap(...)to apply the decorator to\nthe function defined on the next line.\nIn the NetworkX codebase however,argmapis used within a function to\nconstruct a decorator. That is, the decorator defines a mapping function\nand then usesargmapto build and return a decorated function.\nA simple example is a decorator that specifies which currency to report money.\nThe decorator (namedconvert_to) would be used like:\n@convert_to(\"US_Dollars\",\"income\")defshow_me_the_money(name,income):print(f\"{name} : {income}\")\nAnd the code to create the decorator might be:\ndefconvert_to(currency,which_arg):def_convert(amount):ifamount.currency!=currency:amount=amount.to_currency(currency)returnamountreturnargmap(_convert,which_arg)\nDespite this common idiom for argmap, most of the following examples\nuse the@argmap(...)idiom to save space.\nHere\u2019s an example use of argmap to sum the elements of two of the functions\narguments. The decorated function:\n@argmap(sum,\"xlist\",\"zlist\")deffoo(xlist,y,zlist):returnxlist-y+zlist\nis syntactic sugar for:\ndeffoo(xlist,y,zlist):x=sum(xlist)z=sum(zlist)returnx-y+z\nand is equivalent to (using argument indexes):\n@argmap(sum,\"xlist\",2)deffoo(xlist,y,zlist):returnxlist-y+zlist\nor:\n@argmap(sum,\"zlist\",0)deffoo(xlist,y,zlist):returnxlist-y+zlist\nTransforming functions can be applied to multiple arguments, such as:\ndefswap(x,y):returny,x# the 2-tuple tells argmap that the map `swap` has 2 inputs/outputs.@argmap(swap,(\"a\",\"b\")):deffoo(a,b,c):returna/b*c\nis equivalent to:\ndeffoo(a,b,c):a,b=swap(a,b)returna/b*c\nMore generally, the applied arguments can be nested tuples of strings or ints.\nThe syntax@argmap(some_func,(\"a\",(\"b\",\"c\")))would expectsome_functo\naccept 2 inputs with the second expected to be a 2-tuple. It should then return\n2 outputs with the second a 2-tuple. The returns values would replace input \u201ca\u201d\n\u201cb\u201d and \u201cc\u201d respectively. Similarly for@argmap(some_func,(0,(\"b\",2))).\nAlso, note that an index larger than the number of named parameters is allowed\nfor variadic functions. For example:\ndefdouble(a):return2*a@argmap(double,3)defoverflow(a,*args):returna,argsprint(overflow(1,2,3,4,5,6))# output is 1, (2, 3, 8, 5, 6)\nTry Finally\nAdditionally, thisargmapclass can be used to create a decorator that\ninitiates a try\u2026finally block. The decorator must be written to return\nboth the transformed argument and a closing function.\nThis feature was included to enable theopen_filedecorator which might\nneed to close the file or not depending on whether it had to open that file.\nThis feature uses the keyword-onlytry_finallyargument to@argmap.\nFor example this map opens a file and then makes sure it is closed:\ndefopen_file(fn):f=open(fn)returnf,lambda:f.close()\nThe decorator applies that to the functionfoo:\n@argmap(open_file,\"file\",try_finally=True)deffoo(file):print(file.read())\nis syntactic sugar for:\ndeffoo(file):file,close_file=open_file(file)try:print(file.read())finally:close_file()\nand is equivalent to (using indexes):\n@argmap(open_file,0,try_finally=True)deffoo(file):print(file.read())\nHere\u2019s an example of the try_finally feature used to create a decorator:\ndefmy_closing_decorator(which_arg):def_opener(path):ifpathisNone:path=open(path)fclose=path.closeelse:# assume `path` handles the closingfclose=lambda:Nonereturnpath,fclosereturnargmap(_opener,which_arg,try_finally=True)\nwhich can then be used as:\n@my_closing_decorator(\"file\")deffancy_reader(file=None):# this code doesn't need to worry about closing the fileprint(file.read())\nDecorators with try_finally = True cannot be used with generator functions,\nbecause thefinallyblock is evaluated before the generator is exhausted:\n@argmap(open_file,\"file\",try_finally=True)deffile_to_lines(file):forlineinfile.readlines():yieldline\nis equivalent to:\ndeffile_to_lines_wrapped(file):forlineinfile.readlines():yieldlinedeffile_to_lines_wrapper(file):try:file=open_file(file)returnfile_to_lines_wrapped(file)finally:file.close()\nwhich behaves similarly to:\ndeffile_to_lines_whoops(file):file=open_file(file)file.close()forlineinfile.readlines():yieldline\nbecause thefinallyblock offile_to_lines_wrapperis executed before\nthe caller has a chance to exhaust the iterator."
        }
    },
    {
        "Section ID": "reverse_cuthill_mckee_ordering",
        "Description": [
            "Generate an ordering (permutation) of the graph nodes to make\na sparse matrix.",
            "Uses the reverse Cuthill-McKee heuristic (based on breadth-first search) [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "heuristic : function, optional": "Function to choose starting node for RCM algorithm.  If None\na node from a pseudo-peripheral pair is used.  A user-defined function\ncan be supplied that takes a graph object and returns a single node."
            },
            "Returns:": {
                "nodes : generator": "Generator of nodes in reverse Cuthill-McKee ordering."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The optimal solution the bandwidth reduction is NP-complete [2] .",
            "References": "[1]E. Cuthill and J. McKee.\nReducing the bandwidth of sparse symmetric matrices,\nIn Proc. 24th Nat. Conf. ACM, pages 157-72, 1969.http://doi.acm.org/10.1145/800195.805928  [2]Steven S. Skiena. 1997. The Algorithm Design Manual.\nSpringer-Verlag New York, Inc., New York, NY, USA.",
            "Examples": "fromnetworkx.utilsimportreverse_cuthill_mckee_ordering\nG=nx.path_graph(4)\nrcm=list(reverse_cuthill_mckee_ordering(G))\nA=nx.adjacency_matrix(G,nodelist=rcm)\nSmallest degree node as heuristic function:\ndefsmallest_degree(G):\nreturnmin(G,key=G.degree)\nrcm=list(reverse_cuthill_mckee_ordering(G,heuristic=smallest_degree))"
        }
    },
    {
        "Section ID": "maximal_extendability",
        "Description": [
            "Computes the extendability of a graph.",
            "The extendability of a graph is defined as the maximum \\(k\\) for which G is \\(k\\) -extendable. Graph G is \\(k\\) -extendable if and only if G has a\nperfect matching and every set of \\(k\\) independent edges can be extended\nto a perfect matching in G ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "A fully-connected bipartite graph without self-loops"
            },
            "Returns:": {
                "extendability : int": ""
            },
            "Raises:": {
                "NetworkXError": "If the graphGis disconnected.\nIf the graphGis not bipartite.\nIf the graphGdoes not contain a perfect matching.\nIf the residual graph ofGis not strongly connected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Definition:\nLet G be a simple, connected, undirected and bipartite graph with a perfect\nmatching M and bipartition (U,V). The residual graph of G , denoted by \\(G_M\\) ,\nis the graph obtained from G by directing the edges of M from V to U and the\nedges that do not belong to M from U to V. Lemma [1] :\nLet M be a perfect matching of G . G is \\(k\\) -extendable if and only if its residual\ngraph \\(G_M\\) is strongly connected and there are \\(k\\) vertex-disjoint directed\npaths between every vertex of U and every vertex of V. Assuming that input graph G is undirected, simple, connected, bipartite and contains\na perfect matching M, this function constructs the residual graph \\(G_M\\) of G and\nreturns the minimum value among the maximum vertex-disjoint directed paths between\nevery vertex of U and every vertex of V in \\(G_M\\) . By combining the definitions\nand the lemma, this value represents the extendability of the graph G . Time complexity O( \\(n^3\\)  \\(m^2\\) )) where \\(n\\) is the number of vertices\nand \\(m\\) is the number of edges.",
            "References": "[1]\u201cA polynomial algorithm for the extendability problem in bipartite graphs\u201d,\nJ. Lakhal, L. Litzler, Information Processing Letters, 1998.  [2]\u201cOn n-extendible graphs\u201d, M. D. Plummer, Discrete Mathematics, 31:201\u2013210, 1980https://doi.org/10.1016/0012-365X(80)90037-0"
        }
    },
    {
        "Section ID": "dfs_predecessors",
        "Description": [
            "Returns dictionary of predecessors in depth-first-search from source."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node, optional": "Specify starting node for depth-first search.\nNote that you will get predecessors for all nodes in the\ncomponent containingsource. This input only specifies\nwhere the DFS starts.",
                "depth_limit : int, optional (default=len(G))": "Specify the maximum search depth.",
                "sort_neighbors : function (default=None)": "A function that takes an iterator over nodes as the input, and\nreturns an iterable of the same nodes with a custom ordering.\nFor example,sortedwill sort the nodes in increasing order."
            },
            "Returns:": {
                "pred: dict": "A dictionary with nodes as keys and predecessor nodes as values."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "If a source is not specified then a source is chosen arbitrarily and\nrepeatedly until all components in the graph are searched. The implementation of this function is adapted from David Eppstein\u2019s\ndepth-first search function in PADS , with modifications\nto allow depth limits based on the Wikipedia article\n\u201c Depth-limited search \u201d.",
            "Examples": "G=nx.path_graph(4)\nnx.dfs_predecessors(G,source=0)\n# {1: 0, 2: 1, 3: 2}\nnx.dfs_predecessors(G,source=0,depth_limit=2)\n# {1: 0, 2: 1}"
        }
    },
    {
        "Section ID": "number_of_walks",
        "Description": [
            "Returns the number of walks connecting each pair of nodes in G",
            "A walk is a sequence of nodes in which each adjacent pair of nodes\nin the sequence is adjacent in the graph. A walk can repeat the same\nedge and go in the opposite direction just as people can walk on a\nset of paths, but standing still is not counted as part of the walk.",
            "This function only counts the walks with walk_length edges. Note that\nthe number of nodes in the walk sequence is one more than walk_length .\nThe number of walks can grow very quickly on a larger graph\nand with a larger walk length."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "walk_length : int": "A nonnegative integer representing the length of a walk."
            },
            "Returns:": {
                "dict": "A dictionary of dictionaries in which outer keys are source\nnodes, inner keys are target nodes, and inner values are the\nnumber of walks of lengthwalk_lengthconnecting those nodes."
            },
            "Raises:": {
                "ValueError": "Ifwalk_lengthis negative"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph([(0,1),(1,2)])\nwalks=nx.number_of_walks(G,2)\nwalks\n# {0: {0: 1, 1: 0, 2: 1}, 1: {0: 0, 1: 2, 2: 0}, 2: {0: 1, 1: 0, 2: 1}}\ntotal_walks=sum(sum(tgts.values())for_,tgtsinwalks.items())\nYou can also get the number of walks from a specific source node using the\nreturned dictionary. For example, number of walks of length 1 from node 0\ncan be found as follows:\nwalks=nx.number_of_walks(G,1)\nwalks[0]\n# {0: 0, 1: 1, 2: 0}\nsum(walks[0].values())# walks from 0 of length 1\n# 1\nSimilarly, a target node can also be specified:\nwalks[0][1]\n# 1"
        }
    },
    {
        "Section ID": "to_graph6_bytes",
        "Description": [
            "Convert a simple undirected graph to bytes in graph6 format."
        ],
        "Field List": {
            "Parameters:": {
                "G : Graph (undirected)": "",
                "nodes: list or iterable": "Nodes are labeled 0\u2026n-1 in the order provided.  If None the ordering\ngiven byG.nodes()is used.",
                "header: bool": "If True add \u2018>>graph6<<\u2019 bytes to head of data."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the graph is directed or is a multigraph.",
                "ValueError": "If the graph has at least2**36nodes; the graph6 format\nis only defined for graphs of order less than2**36."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The returned bytes end with a newline character. The format does not support edge or node labels, parallel edges or\nself loops. If self loops are present they are silently ignored.",
            "References": "[1]Graph6 specification\n<http://users.cecs.anu.edu.au/~bdm/data/formats.html>",
            "Examples": "nx.to_graph6_bytes(nx.path_graph(2))\n# b'>>graph6<<A_\\n'"
        }
    },
    {
        "Section ID": "dual_barabasi_albert_graph",
        "Description": [
            "Returns a random graph using dual Barab\u00e1si\u2013Albert preferential attachment",
            "A graph of \\(n\\) nodes is grown by attaching new nodes each with either \\(m_1\\) edges (with probability \\(p\\) ) or \\(m_2\\) edges (with probability \\(1-p\\) ) that\nare preferentially attached to existing nodes with high degree."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "Number of nodes",
                "m1 : int": "Number of edges to link each new node to existing nodes with probability\\(p\\)",
                "m2 : int": "Number of edges to link each new node to existing nodes with probability\\(1-p\\)",
                "p : float": "The probability of attaching\\(m_1\\)edges (as opposed to\\(m_2\\)edges)",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "initial_graph : Graph or None (default)": "Initial network for Barab\u00e1si\u2013Albert algorithm.\nA copy ofinitial_graphis used.\nIt should be connected for most use cases.\nIf None, starts from an star graph on max(m1, m2) + 1 nodes."
            },
            "Returns:": {
                "G : Graph": ""
            },
            "Raises:": {
                "NetworkXError": "Ifm1andm2do not satisfy1<=m1,m2<n, orpdoes not satisfy0<=p<=1, or\nthe initial graph number of nodes m0 does not satisfy m1, m2 <= m0 <= n."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Moshiri \u201cThe dual-Barabasi-Albert model\u201d, arXiv:1810.10538."
        }
    },
    {
        "Section ID": "margulis_gabber_galil_graph",
        "Description": [
            "Returns the Margulis-Gabber-Galil undirected MultiGraph on n^2 nodes.",
            "The undirected MultiGraph is regular with degree 8 . Nodes are integer\npairs. The second-largest eigenvalue of the adjacency matrix of the graph\nis at most 5sqrt{2} , regardless of n ."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "Determines the number of nodes in the graph:n^2.",
                "create_using : NetworkX graph constructor, optional (default MultiGraph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : graph": "The constructed undirected multigraph."
            },
            "Raises:": {
                "NetworkXError": "If the graph is directed or not a multigraph."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "single_source_shortest_path_length",
        "Description": [
            "Compute the shortest path lengths from source to all reachable nodes."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node": "Starting node for path",
                "cutoff : integer, optional": "Depth to stop the search. Only paths of length <= cutoff are returned."
            },
            "Returns:": {
                "lengths : dict": "Dict keyed by node to shortest path length to source."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.path_graph(5)\nlength=nx.single_source_shortest_path_length(G,0)\nlength[4]\n# 4\nfornodeinlength:\nprint(f\"{node}: {length[node]}\")\n# 0: 0\n# 1: 1\n# 2: 2\n# 3: 3\n# 4: 4"
        }
    },
    {
        "Section ID": "ancestors",
        "Description": [
            "Returns all nodes having a path to source in G ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "",
                "source : node inG": ""
            },
            "Returns:": {
                "set()": "The ancestors ofsourceinG"
            },
            "Raises:": {
                "NetworkXError": "If nodesourceis not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "DG=nx.path_graph(5,create_using=nx.DiGraph)\nsorted(nx.ancestors(DG,2))\n# [0, 1]\nThesourcenode is not an ancestor of itself, but can be included manually:\nsorted(nx.ancestors(DG,2)|{2})\n# [0, 1, 2]"
        }
    },
    {
        "Section ID": "union",
        "Description": [],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "edge_subgraph",
        "Description": [
            "Returns a view of the subgraph induced by the specified edges.",
            "The induced subgraph contains each edge in edges and each\nnode incident to any of those edges."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "",
                "edges : iterable": "An iterable of edges. Edges not present inGare ignored."
            },
            "Returns:": {
                "subgraph : SubGraph View": "A read-only edge-induced subgraph ofG.\nChanges toGare reflected in the view."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "To create a mutable subgraph with its own copies of nodes\nedges and attributes use subgraph.copy() or Graph(subgraph) If you create a subgraph of a subgraph recursively you can end up\nwith a chain of subgraphs that becomes very slow with about 15\nnested subgraph views. Luckily the edge_subgraph filter nests\nnicely so you can use the original graph as G in this function\nto avoid chains. We do not rule out chains programmatically so\nthat odd cases like an edge_subgraph of a restricted_view can be created.",
            "Examples": "G=nx.path_graph(5)\nH=G.edge_subgraph([(0,1),(3,4)])\nlist(H.nodes)\n# [0, 1, 3, 4]\nlist(H.edges)\n# [(0, 1), (3, 4)]"
        }
    },
    {
        "Section ID": "single_target_shortest_path",
        "Description": [
            "Compute shortest path to target from all nodes that reach target."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "target : node label": "Target node for path",
                "cutoff : integer, optional": "Depth to stop the search. Only paths of length <= cutoff are returned."
            },
            "Returns:": {
                "paths : dictionary": "Dictionary, keyed by target, of shortest paths."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The shortest path is not necessarily unique. So there can be multiple\npaths between the source and each target node, all of which have the\nsame \u2018shortest\u2019 length. For each target node, this function returns\nonly one of those paths.",
            "Examples": "G=nx.path_graph(5,create_using=nx.DiGraph())\npath=nx.single_target_shortest_path(G,4)\npath[0]\n# [0, 1, 2, 3, 4]"
        }
    },
    {
        "Section ID": "find_asteroidal_triple",
        "Description": [
            "Find an asteroidal triple in the given graph.",
            "An asteroidal triple is a triple of non-adjacent vertices such that\nthere exists a path between any two of them which avoids the closed\nneighborhood of the third. It checks all independent triples of vertices\nand whether they are an asteroidal triple or not. This is done with the\nhelp of a data structure called a component structure.\nA component structure encodes information about which vertices belongs to\nthe same connected component when the closed neighborhood of a given vertex\nis removed from the graph. The algorithm used to check is the trivial\none, outlined in [1] , which has a runtime of \\(O(|V||\\overline{E} + |V||E|)\\) , where the second term is the\ncreation of the component structure."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "The graph to check whether is AT-free or not"
            },
            "Returns:": {
                "list or None": "An asteroidal triple is returned as a list of nodes. If no asteroidal\ntriple exists, i.e. the graph is AT-free, then None is returned.\nThe returned value depends on the certificate parameter. The default\noption is a bool which is True if the graph is AT-free, i.e. the\ngiven graph contains no asteroidal triples, and False otherwise, i.e.\nif the graph contains at least one asteroidal triple."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The component structure and the algorithm is described in [1] . The current\nimplementation implements the trivial algorithm for simple graphs.",
            "References": "[1](1,2)Ekkehard K\u00f6hler,\n\u201cRecognizing Graphs without asteroidal triples\u201d,\nJournal of Discrete Algorithms 2, pages 439-452, 2004.https://www.sciencedirect.com/science/article/pii/S157086670400019X"
        }
    },
    {
        "Section ID": "color",
        "Description": [
            "Returns a two-coloring of the graph.",
            "Raises an exception if the graph is not bipartite."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": ""
            },
            "Returns:": {
                "color : dictionary": "A dictionary keyed by node with a 1 or 0 as data for each node color."
            },
            "Raises:": {
                "NetworkXError": "If the graph is not two-colorable."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "fromnetworkx.algorithmsimportbipartite\nG=nx.path_graph(4)\nc=bipartite.color(G)\nprint(c)\n# {0: 1, 1: 0, 2: 1, 3: 0}\nYou can use this to set a node attribute indicating the bipartite set:\nnx.set_node_attributes(G,c,\"bipartite\")\nprint(G.nodes[0][\"bipartite\"])\n# 1\nprint(G.nodes[1][\"bipartite\"])\n# 0"
        }
    },
    {
        "Section ID": "single_source_bellman_ford_path_length",
        "Description": [
            "Compute the shortest path length between source and all other\nreachable nodes for a weighted graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node label": "Starting node for path",
                "weight : string or function (default=\u201dweight\u201d)": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number."
            },
            "Returns:": {
                "length : dictionary": "Dictionary of shortest path length keyed by target"
            },
            "Raises:": {
                "NodeNotFound": "Ifsourceis not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.",
            "Examples": "G=nx.path_graph(5)\nlength=nx.single_source_bellman_ford_path_length(G,0)\nlength[4]\n# 4\nfornodein[0,1,2,3,4]:\nprint(f\"{node}: {length[node]}\")\n# 0: 0\n# 1: 1\n# 2: 2\n# 3: 3\n# 4: 4"
        }
    },
    {
        "Section ID": "reconstruct_path",
        "Description": [
            "Reconstruct a path from source to target using the predecessors\ndict as returned by floyd_warshall_predecessor_and_distance"
        ],
        "Field List": {
            "Parameters:": {
                "source : node": "Starting node for path",
                "target : node": "Ending node for path",
                "predecessors: dictionary": "Dictionary, keyed by source and target, of predecessors in the\nshortest path, as returned by floyd_warshall_predecessor_and_distance"
            },
            "Returns:": {
                "path : list": "A list of nodes containing the shortest path from source to targetIf source and target are the same, an empty list is returned"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This function is meant to give more applicability to the\nfloyd_warshall_predecessor_and_distance function"
        }
    },
    {
        "Section ID": "minimum_cut_value",
        "Description": [
            "Compute the value of a minimum (s, t)-cut.",
            "Use the max-flow min-cut theorem, i.e., the capacity of a minimum\ncapacity cut is equal to the flow value of a maximum flow."
        ],
        "Field List": {
            "Parameters:": {
                "flowG : NetworkX graph": "Edges of the graph are expected to have an attribute called\n\u2018capacity\u2019. If this attribute is not present, the edge is\nconsidered to have infinite capacity.",
                "_s : node": "Source node for the flow.",
                "_t : node": "Sink node for the flow.",
                "capacity : string": "Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: \u2018capacity\u2019.",
                "flow_func : function": "A function for computing the maximum flow among a pair of nodes\nin a capacitated graph. The function has to accept at least three\nparameters: a Graph or Digraph, a source node, and a target node.\nAnd return a residual network that follows NetworkX conventions\n(see Notes). If flow_func is None, the default maximum\nflow function (preflow_push()) is used. See below for\nalternative algorithms. The choice of the default function may change\nfrom version to version and should not be relied on. Default value:\nNone.",
                "kwargs : Any other keyword parameter is passed to the function that": "computes the maximum flow."
            },
            "Returns:": {
                "cut_value : integer, float": "Value of the minimum cut."
            },
            "Raises:": {
                "NetworkXUnbounded": "If the graph has a path of infinite capacity, all cuts have\ninfinite capacity and the function raises a NetworkXError."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The function used in the flow_func parameter has to return a residual\nnetwork that follows NetworkX conventions: The residual network R from an input graph G has the\nsame nodes as G . R is a DiGraph that contains a pair\nof edges (u,v) and (v,u) iff (u,v) is not a\nself-loop, and at least one of (u,v) and (v,u) exists\nin G . For each edge (u,v) in R , R[u][v]['capacity'] is equal to the capacity of (u,v) in G if it exists\nin G or zero otherwise. If the capacity is infinite, R[u][v]['capacity'] will have a high arbitrary finite value\nthat does not affect the solution of the problem. This value is stored in R.graph['inf'] . For each edge (u,v) in R , R[u][v]['flow'] represents the flow function of (u,v) and\nsatisfies R[u][v]['flow']==-R[v][u]['flow'] . The flow value, defined as the total flow into t , the sink, is\nstored in R.graph['flow_value'] . Reachability to t using\nonly edges (u,v) such that R[u][v]['flow']<R[u][v]['capacity'] induces a minimum s - t cut. Specific algorithms may store extra data in R . The function should supports an optional boolean parameter value_only. When\nTrue, it can optionally terminate the algorithm as soon as the maximum flow\nvalue and the minimum cut can be determined.",
            "Examples": "G=nx.DiGraph()\nG.add_edge(\"x\",\"a\",capacity=3.0)\nG.add_edge(\"x\",\"b\",capacity=1.0)\nG.add_edge(\"a\",\"c\",capacity=3.0)\nG.add_edge(\"b\",\"c\",capacity=5.0)\nG.add_edge(\"b\",\"d\",capacity=4.0)\nG.add_edge(\"d\",\"e\",capacity=2.0)\nG.add_edge(\"c\",\"y\",capacity=2.0)\nG.add_edge(\"e\",\"y\",capacity=3.0)\nminimum_cut_value computes only the value of the\nminimum cut:\ncut_value=nx.minimum_cut_value(G,\"x\",\"y\")\ncut_value\n# 3.0\nYou can also use alternative algorithms for computing the\nminimum cut by using the flow_func parameter.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\ncut_value==nx.minimum_cut_value(G,\"x\",\"y\",flow_func=shortest_augmenting_path)\n# True"
        }
    },
    {
        "Section ID": "interval_graph",
        "Description": [
            "Generates an interval graph for a list of intervals given.",
            "In graph theory, an interval graph is an undirected graph formed from a set\nof closed intervals on the real line, with a vertex for each interval\nand an edge between vertices whose intervals intersect.\nIt is the intersection graph of the intervals.",
            "More information can be found at: https://en.wikipedia.org/wiki/Interval_graph"
        ],
        "Field List": {
            "Parameters:": {
                "intervals : a sequence of intervals, say (l, r) where l is the left end,": "",
                "and r is the right end of the closed interval.": ""
            },
            "Returns:": {
                "G : networkx graph": ""
            },
            "Raises:": {
                "TypeError": "ifintervalscontains None or an element which is not\ncollections.abc.Sequence or not a length of 2.",
                "ValueError": "ifintervalscontains an interval such that min1 > max1\nwhere min1,max1 = interval"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "intervals=[(-2,3),[1,4],(2,3),(4,6)]\nG=nx.interval_graph(intervals)\nsorted(G.edges)\n# [((-2, 3), (1, 4)), ((-2, 3), (2, 3)), ((1, 4), (2, 3)), ((1, 4), (4, 6))]"
        }
    },
    {
        "Section ID": "clustering",
        "Description": [
            "Compute a bipartite clustering coefficient for nodes.",
            "The bipartite clustering coefficient is a measure of local density\nof connections defined as [1] :",
            "where N(N(u)) are the second order neighbors of u in G excluding u ,\nand c_{uv} is the pairwise clustering coefficient between nodes u and v .",
            "The mode selects the function for c_{uv} which can be:",
            "dot :",
            "min :",
            "max :"
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A bipartite graph",
                "nodes : list or iterable (optional)": "Compute bipartite clustering for these nodes. The default\nis all nodes in G.",
                "mode : string": "The pairwise bipartite clustering method to be used in the computation.\nIt must be \u201cdot\u201d, \u201cmax\u201d, or \u201cmin\u201d."
            },
            "Returns:": {
                "clustering : dictionary": "A dictionary keyed by node with the clustering coefficient value."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Latapy, Matthieu, Cl\u00e9mence Magnien, and Nathalie Del Vecchio (2008).\nBasic notions for the analysis of large two-mode networks.\nSocial Networks 30(1), 31\u201348.",
            "Examples": "fromnetworkx.algorithmsimportbipartite\nG=nx.path_graph(4)# path graphs are bipartite\nc=bipartite.clustering(G)\nc[0]\n# 0.5\nc=bipartite.clustering(G,mode=\"min\")\nc[0]\n# 1.0"
        }
    },
    {
        "Section ID": "trophic_incoherence_parameter",
        "Description": [
            "Compute the trophic incoherence parameter of a graph.",
            "Trophic coherence is defined as the homogeneity of the distribution of\ntrophic distances: the more similar, the more coherent. This is measured by\nthe standard deviation of the trophic differences and referred to as the\ntrophic incoherence parameter \\(q\\) by [1]."
        ],
        "Field List": {
            "Parameters:": {
                "G : DiGraph": "A directed networkx graph",
                "cannibalism: Boolean": "If set to False, self edges are not considered in the calculation"
            },
            "Returns:": {
                "trophic_incoherence_parameter : float": "The trophic coherence of a graph"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Samuel Johnson, Virginia Dominguez-Garcia, Luca Donetti, Miguel A.\nMunoz (2014) PNAS \u201cTrophic coherence determines food-web stability\u201d"
        }
    },
    {
        "Section ID": "is_strongly_regular",
        "Description": [
            "Returns True if and only if the given graph is strongly\nregular.",
            "An undirected graph is strongly regular if",
            "Each strongly regular graph is a distance-regular graph.\nConversely, if a distance-regular graph has diameter two, then it is\na strongly regular graph. For more information on distance-regular\ngraphs, see is_distance_regular() ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "An undirected graph."
            },
            "Returns:": {
                "bool": "WhetherGis strongly regular."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "The cycle graph on five vertices is strongly regular. It is\ntwo-regular, each pair of adjacent vertices has no shared neighbors,\nand each pair of nonadjacent vertices has one shared neighbor:\nG=nx.cycle_graph(5)\nnx.is_strongly_regular(G)\n# True"
        }
    },
    {
        "Section ID": "weisfeiler_lehman_graph_hash",
        "Description": [
            "Return Weisfeiler Lehman (WL) graph hash.",
            "The function iteratively aggregates and hashes neighborhoods of each node.\nAfter each node\u2019s neighbors are hashed to obtain updated node labels,\na hashed histogram of resulting labels is returned as the final hash.",
            "Hashes are identical for isomorphic graphs and strong guarantees that\nnon-isomorphic graphs will get different hashes. See [1] for details.",
            "If no node or edge attributes are provided, the degree of each node\nis used as its initial label.\nOtherwise, node and/or edge labels are used to compute the hash."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "The graph to be hashed.\nCan have node and/or edge attributes. Can also have no attributes.",
                "edge_attr : string, optional (default=None)": "The key in edge attribute dictionary to be used for hashing.\nIf None, edge labels are ignored.",
                "node_attr: string, optional (default=None)": "The key in node attribute dictionary to be used for hashing.\nIf None, and no edge_attr given, use the degrees of the nodes as labels.",
                "iterations: int, optional (default=3)": "Number of neighbor aggregations to perform.\nShould be larger for larger graphs.",
                "digest_size: int, optional (default=16)": "Size (in bits) of blake2b hash digest to use for hashing node labels."
            },
            "Returns:": {
                "h : string": "Hexadecimal string corresponding to hash of the input graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "To return the WL hashes of each subgraph of a graph, use weisfeiler_lehman_subgraph_hashes Similarity between hashes does not imply similarity between graphs.",
            "References": "[1]Shervashidze, Nino, Pascal Schweitzer, Erik Jan Van Leeuwen,\nKurt Mehlhorn, and Karsten M. Borgwardt. Weisfeiler Lehman\nGraph Kernels. Journal of Machine Learning Research. 2011.http://www.jmlr.org/papers/volume12/shervashidze11a/shervashidze11a.pdf",
            "Examples": "Two graphs with edge attributes that are isomorphic, except for\ndifferences in the edge labels.\nG1=nx.Graph()\nG1.add_edges_from(\n[\n(1,2,{\"label\":\"A\"}),\n(2,3,{\"label\":\"A\"}),\n(3,1,{\"label\":\"A\"}),\n(1,4,{\"label\":\"B\"}),\n]\n)\nG2=nx.Graph()\nG2.add_edges_from(\n[\n(5,6,{\"label\":\"B\"}),\n(6,7,{\"label\":\"A\"}),\n(7,5,{\"label\":\"A\"}),\n(7,8,{\"label\":\"A\"}),\n]\n)\nOmitting theedge_attroption, results in identical hashes.\nnx.weisfeiler_lehman_graph_hash(G1)\n# '7bc4dde9a09d0b94c5097b219891d81a'\nnx.weisfeiler_lehman_graph_hash(G2)\n# '7bc4dde9a09d0b94c5097b219891d81a'\nWith edge labels, the graphs are no longer assigned\nthe same hash digest.\nnx.weisfeiler_lehman_graph_hash(G1,edge_attr=\"label\")\n# 'c653d85538bcf041d88c011f4f905f10'\nnx.weisfeiler_lehman_graph_hash(G2,edge_attr=\"label\")\n# '3dcd84af1ca855d0eff3c978d88e7ec7'"
        }
    },
    {
        "Section ID": "hide_edges",
        "Description": [
            "Returns a filter function that hides specific undirected edges."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "to_latex",
        "Description": [
            "Return latex code to draw the graph(s) in Gbunch",
            "The TikZ drawing utility in LaTeX is used to draw the graph(s).\nIf Gbunch is a graph, it is drawn in a figure environment.\nIf Gbunch is an iterable of graphs, each is drawn in a subfigure environment\nwithin a single figure environment.",
            "If as_document is True, the figure is wrapped inside a document environment\nso that the resulting string is ready to be compiled by LaTeX. Otherwise,\nthe string is ready for inclusion in a larger tex document using \\include or \\input statements."
        ],
        "Field List": {
            "Parameters:": {
                "Gbunch : NetworkX graph or iterable of NetworkX graphs": "The NetworkX graph to be drawn or an iterable of graphs\nto be drawn inside subfigures of a single figure.",
                "pos : string or list of strings": "The name of the node attribute onGthat holds the position of each node.\nPositions can be sequences of length 2 with numbers for (x,y) coordinates.\nThey can also be strings to denote positions in TikZ style, such as (x, y)\nor (angle:radius).\nIf a dict, it should be keyed by node to a position.\nIf an empty dict, a circular layout is computed by TikZ.\nIf you are drawing many graphs in subfigures, use a list of position dicts.",
                "tikz_options : string": "The tikzpicture options description defining the options for the picture.\nOften large scale options like[scale=2].",
                "default_node_options : string": "The draw options for a path of nodes. Individual node options override these.",
                "node_options : string or dict": "The name of the node attribute onGthat holds the options for each node.\nOr a dict keyed by node to a string holding the options for that node.",
                "node_label : string or dict": "The name of the node attribute onGthat holds the node label (text)\ndisplayed for each node. If the attribute is \u201c\u201d or not present, the node\nitself is drawn as a string. LaTeX processing such as\"$A_1$\"is allowed.\nOr a dict keyed by node to a string holding the label for that node.",
                "default_edge_options : string": "The options for the scope drawing all edges. The default is \u201c[-]\u201d for\nundirected graphs and \u201c[->]\u201d for directed graphs.",
                "edge_options : string or dict": "The name of the edge attribute onGthat holds the options for each edge.\nIf the edge is a self-loop and\"loop\"notinedge_optionsthe option\n\u201cloop,\u201d is added to the options for the self-loop edge. Hence you can\nuse \u201c[loop above]\u201d explicitly, but the default is \u201c[loop]\u201d.\nOr a dict keyed by edge to a string holding the options for that edge.",
                "edge_label : string or dict": "The name of the edge attribute onGthat holds the edge label (text)\ndisplayed for each edge. If the attribute is \u201c\u201d or not present, no edge\nlabel is drawn.\nOr a dict keyed by edge to a string holding the label for that edge.",
                "edge_label_options : string or dict": "The name of the edge attribute onGthat holds the label options for\neach edge. For example, \u201c[sloped,above,blue]\u201d. The default is no options.\nOr a dict keyed by edge to a string holding the label options for that edge.",
                "caption : string": "The caption string for the figure environment",
                "latex_label : string": "The latex label used for the figure for easy referral from the main text",
                "sub_captions : list of strings": "The sub_caption string for each subfigure in the figure",
                "sub_latex_labels : list of strings": "The latex label for each subfigure in the figure",
                "n_rows : int": "The number of rows of subfigures to arrange for multiple graphs",
                "as_document : bool": "Whether to wrap the latex code in a document environment for compiling",
                "document_wrapper : formatted text string with variablecontent.": "This text is called to evaluate the content embedded in a document\nenvironment with a preamble setting up TikZ.",
                "figure_wrapper : formatted text string": "This text is evaluated with variablescontent,captionandlabel.\nIt wraps the content and if a caption is provided, adds the latex code for\nthat caption, and if a label is provided, adds the latex code for a label.",
                "subfigure_wrapper : formatted text string": "This text evaluate variablessize,content,captionandlabel.\nIt wraps the content and if a caption is provided, adds the latex code for\nthat caption, and if a label is provided, adds the latex code for a label.\nThe size is the vertical size of each row of subfigures as a fraction."
            },
            "Returns:": {
                "latex_code : string": "The text string which draws the desired graph(s) when compiled by LaTeX."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "pappus_graph",
        "Description": [
            "Returns the Pappus graph.",
            "The Pappus graph is a cubic symmetric distance-regular graph with 18 nodes\nand 27 edges. It is Hamiltonian and can be represented in LCF notation as\n[5,7,-7,7,-7,-5]^3 [1] ."
        ],
        "Field List": {
            "Returns:": {
                "G : networkx Graph": "Pappus graph"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://en.wikipedia.org/wiki/Pappus_graph"
        }
    },
    {
        "Section ID": "robins_alexander_clustering",
        "Description": [
            "Compute the bipartite clustering of G.",
            "Robins and Alexander [1] defined bipartite clustering coefficient as\nfour times the number of four cycles C_4 divided by the number of\nthree paths L_3 in a bipartite graph:"
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "a bipartite graph"
            },
            "Returns:": {
                "clustering : float": "The Robins and Alexander bipartite clustering for the input graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Robins, G. and M. Alexander (2004). Small worlds among interlocking\ndirectors: Network structure and distance in bipartite graphs.\nComputational & Mathematical Organization Theory 10(1), 69\u201394.",
            "Examples": "fromnetworkx.algorithmsimportbipartite\nG=nx.davis_southern_women_graph()\nprint(round(bipartite.robins_alexander_clustering(G),3))\n# 0.468"
        }
    },
    {
        "Section ID": "geometric_edges",
        "Description": [
            "Returns edge list of node pairs within radius of each other."
        ],
        "Field List": {
            "Parameters:": {
                "G : networkx graph": "The graph from which to generate the edge list. The nodes inGshould\nhave an attributeposcorresponding to the node position, which is\nused to compute the distance to other nodes.",
                "radius : scalar": "The distance threshold. Edges are included in the edge list if the\ndistance between the two nodes is less thanradius.",
                "pos_name : string, default=\u201dpos\u201d": "The name of the node attribute which represents the position of each\nnode in 2D coordinates. Every node in the Graph must have this attribute.",
                "p : scalar, default=2": "TheMinkowski distance metricused to compute\ndistances. The default value is 2, i.e. Euclidean distance."
            },
            "Returns:": {
                "edges : list": "List of edges whose distances are less thanradius"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Radius uses Minkowski distance metric p .\nIf scipy is available, scipy.spatial.cKDTree is used to speed computation.",
            "Examples": "Create a graph with nodes that have a \u201cpos\u201d attribute representing 2D\ncoordinates.\nG=nx.Graph()\nG.add_nodes_from(\n[\n(0,{\"pos\":(0,0)}),\n(1,{\"pos\":(3,0)}),\n(2,{\"pos\":(8,0)}),\n]\n)\nnx.geometric_edges(G,radius=1)\n# []\nnx.geometric_edges(G,radius=4)\n# [(0, 1)]\nnx.geometric_edges(G,radius=6)\n# [(0, 1), (1, 2)]\nnx.geometric_edges(G,radius=9)\n# [(0, 1), (0, 2), (1, 2)]"
        }
    },
    {
        "Section ID": "make_clique_bipartite",
        "Description": [
            "Returns the bipartite clique graph corresponding to G .",
            "In the returned bipartite graph, the \u201cbottom\u201d nodes are the nodes of G and the \u201ctop\u201d nodes represent the maximal cliques of G .\nThere is an edge from node v to clique C in the returned graph\nif and only if v is an element of C ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "An undirected graph.",
                "fpos : bool": "If True or not None, the returned graph will have an\nadditional attribute,pos, a dictionary mapping node to\nposition in the Euclidean plane.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "NetworkX graph": "A bipartite graph whose \u201cbottom\u201d set is the nodes of the graphG, whose \u201ctop\u201d set is the cliques ofG, and whose edges\njoin nodes ofGto the cliques that contain them.The nodes of the graphGhave the node attribute\n\u2018bipartite\u2019 set to 1 and the nodes representing cliques\nhave the node attribute \u2018bipartite\u2019 set to 0, as is the\nconvention for bipartite graphs in NetworkX."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "dict_to_numpy_array",
        "Description": [
            "Convert a dictionary of dictionaries to a numpy array\nwith optional mapping."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "astar_path_length",
        "Description": [
            "Returns the length of the shortest path between source and target using\nthe A* (\u201cA-star\u201d) algorithm."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node": "Starting node for path",
                "target : node": "Ending node for path",
                "heuristic : function": "A function to evaluate the estimate of the distance\nfrom the a node to the target.  The function takes\ntwo nodes arguments and must return a number.\nIf the heuristic is inadmissible (if it might\noverestimate the cost of reaching the goal from a node),\nthe result may not be a shortest path.\nThe algorithm does not support updating heuristic\nvalues for the same node due to caching the first\nheuristic calculation per node.",
                "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.\nIf this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge.",
                "cutoff : float, optional": "If this is provided, the search will be bounded to this value. I.e. if\nthe evaluation function surpasses this value for a node n, the node will not\nbe expanded further and will be ignored. More formally, let h\u2019(n) be the\nheuristic function, and g(n) be the cost of reaching n from the source node. Then,\nif g(n) + h\u2019(n) > cutoff, the node will not be explored further.\nNote that if the heuristic is inadmissible, it is possible that paths\nare ignored even though they satisfy the cutoff."
            },
            "Raises:": {
                "NetworkXNoPath": "If no path exists between source and target."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "all_pairs_bellman_ford_path",
        "Description": [
            "Compute shortest paths between all nodes in a weighted graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "weight : string or function (default=\u201dweight\u201d)": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number."
            },
            "Returns:": {
                "paths : iterator": "(source, dictionary) iterator with dictionary keyed by target and\nshortest path as the key value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.",
            "Examples": "G=nx.path_graph(5)\npath=dict(nx.all_pairs_bellman_ford_path(G))\npath[0][4]\n# [0, 1, 2, 3, 4]"
        }
    },
    {
        "Section ID": "find_induced_nodes",
        "Description": [
            "Returns the set of induced nodes in the path from s to t."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A chordal NetworkX graph",
                "s : node": "Source node to look for induced nodes",
                "t : node": "Destination node to look for induced nodes",
                "treewidth_bound: float": "Maximum treewidth acceptable for the graph H. The search\nfor induced nodes will end as soon as the treewidth_bound is exceeded."
            },
            "Returns:": {
                "induced_nodes : Set of nodes": "The set of induced nodes in the path from s to t in G"
            },
            "Raises:": {
                "NetworkXError": "The algorithm does not support DiGraph, MultiGraph and MultiDiGraph.\nIf the input graph is an instance of one of these classes, aNetworkXErroris raised.\nThe algorithm can only be applied to chordal graphs. If the input\ngraph is found to be non-chordal, aNetworkXErroris raised."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "G must be a chordal graph and (s,t) an edge that is not in G. If a treewidth_bound is provided, the search for induced nodes will end\nas soon as the treewidth_bound is exceeded. The algorithm is inspired by Algorithm 4 in [1] .\nA formal definition of induced node can also be found on that reference. Self Loops are ignored",
            "References": "[1]Learning Bounded Treewidth Bayesian Networks.\nGal Elidan, Stephen Gould; JMLR, 9(Dec):2699\u20132731, 2008.http://jmlr.csail.mit.edu/papers/volume9/elidan08a/elidan08a.pdf",
            "Examples": "G=nx.Graph()\nG=nx.generators.classic.path_graph(10)\ninduced_nodes=nx.find_induced_nodes(G,1,9,2)\nsorted(induced_nodes)\n# [1, 2, 3, 4, 5, 6, 7, 8, 9]"
        }
    },
    {
        "Section ID": "efficiency",
        "Description": [
            "Returns the efficiency of a pair of nodes in a graph.",
            "The efficiency of a pair of nodes is the multiplicative inverse of the\nshortest path distance between the nodes [1] . Returns 0 if no path\nbetween nodes."
        ],
        "Field List": {
            "Parameters:": {
                "G : networkx.Graph": "An undirected graph for which to compute the average local efficiency.",
                "u, v : node": "Nodes in the graphG."
            },
            "Returns:": {
                "float": "Multiplicative inverse of the shortest path distance between the nodes."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weights are ignored when computing the shortest path distances.",
            "References": "[1]Latora, Vito, and Massimo Marchiori.\n\u201cEfficient behavior of small-world networks.\u201dPhysical Review Letters87.19 (2001): 198701.\n<https://doi.org/10.1103/PhysRevLett.87.198701>",
            "Examples": "G=nx.Graph([(0,1),(0,2),(0,3),(1,2),(1,3)])\nnx.efficiency(G,2,3)# this gives efficiency for node 2 and 3\n# 0.5"
        }
    },
    {
        "Section ID": "sudoku_graph",
        "Description": [
            "Returns the n-Sudoku graph. The default value of n is 3.",
            "The n-Sudoku graph is a graph with n^4 vertices, corresponding to the\ncells of an n^2 by n^2 grid. Two distinct vertices are adjacent if and\nonly if they belong to the same row, column, or n-by-n box."
        ],
        "Field List": {
            "Parameters:": {
                "n: integer": "The order of the Sudoku graph, equal to the square root of the\nnumber of rows. The default is 3."
            },
            "Returns:": {
                "NetworkX graph": "The n-Sudoku graph Sud(n)."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Herzberg, A. M., & Murty, M. R. (2007). Sudoku squares and chromatic\npolynomials. Notices of the AMS, 54(6), 708-717.  [2]Sander, Torsten (2009), \u201cSudoku graphs are integral\u201d,\nElectronic Journal of Combinatorics, 16 (1): Note 25, 7pp, MR 2529816  [3]Wikipedia contributors. \u201cGlossary of Sudoku.\u201d Wikipedia, The Free\nEncyclopedia, 3 Dec. 2019. Web. 22 Dec. 2019.",
            "Examples": "G=nx.sudoku_graph()\nG.number_of_nodes()\n# 81\nG.number_of_edges()\n# 810\nsorted(G.neighbors(42))\n# [6, 15, 24, 33, 34, 35, 36, 37, 38, 39, 40, 41, 43, 44, 51, 52, 53, 60, 69, 78]\nG=nx.sudoku_graph(2)\nG.number_of_nodes()\n# 16\nG.number_of_edges()\n# 56"
        }
    },
    {
        "Section ID": "write_network_text",
        "Description": [
            "Creates a nice text representation of a graph",
            "This works via a depth-first traversal of the graph and writing a line for\neach unique node encountered. Non-tree edges are written to the right of\neach node, and connection to a non-tree edge is indicated with an ellipsis.\nThis representation works best when the input graph is a forest, but any\ngraph can be represented."
        ],
        "Field List": {
            "Parameters:": {
                "graph : nx.DiGraph | nx.Graph": "Graph to represent",
                "path : string or file or callable or None": "Filename or file handle for data output.\nif a function, then it will be called for each generated line.\nif None, this will default to \u201csys.stdout.write\u201d",
                "with_labels : bool | str": "If True will use the \u201clabel\u201d attribute of a node to display if it\nexists otherwise it will use the node value itself. If given as a\nstring, then that attribute name will be used instead of \u201clabel\u201d.\nDefaults to True.",
                "sources : List": "Specifies which nodes to start traversal from. Note: nodes that are not\nreachable from one of these sources may not be shown. If unspecified,\nthe minimal set of nodes needed to reach all others will be used.",
                "max_depth : int | None": "The maximum depth to traverse before stopping. Defaults to None.",
                "ascii_only : Boolean": "If True only ASCII characters are used to construct the visualization",
                "end : string": "The line ending character",
                "vertical_chains : Boolean": "If True, chains of nodes will be drawn vertically when possible."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "graph=nx.balanced_tree(r=2,h=2,create_using=nx.DiGraph)\nnx.write_network_text(graph)\n# \u2559\u2500\u2500 0\n#     \u251c\u2500\u257c 1\n#     \u2502   \u251c\u2500\u257c 3\n#     \u2502   \u2514\u2500\u257c 4\n#     \u2514\u2500\u257c 2\n#         \u251c\u2500\u257c 5\n#         \u2514\u2500\u257c 6\n# A near tree with one non-tree edge\ngraph.add_edge(5,1)\nnx.write_network_text(graph)\n# \u2559\u2500\u2500 0\n#     \u251c\u2500\u257c 1 \u257e 5\n#     \u2502   \u251c\u2500\u257c 3\n#     \u2502   \u2514\u2500\u257c 4\n#     \u2514\u2500\u257c 2\n#         \u251c\u2500\u257c 5\n#         \u2502   \u2514\u2500\u257c  ...\n#         \u2514\u2500\u257c 6\ngraph=nx.cycle_graph(5)\nnx.write_network_text(graph)\n# \u2559\u2500\u2500 0\n#     \u251c\u2500\u2500 1\n#     \u2502   \u2514\u2500\u2500 2\n#     \u2502       \u2514\u2500\u2500 3\n#     \u2502           \u2514\u2500\u2500 4 \u2500 0\n#     \u2514\u2500\u2500  ...\ngraph=nx.cycle_graph(5,nx.DiGraph)\nnx.write_network_text(graph,vertical_chains=True)\n# \u2559\u2500\u2500 0 \u257e 4\n#     \u257d\n#     1\n#     \u257d\n#     2\n#     \u257d\n#     3\n#     \u257d\n#     4\n#     \u2514\u2500\u257c  ...\nnx.write_network_text(graph,vertical_chains=True,ascii_only=True)\n# +-- 0 <- 4\n#     !\n#     1\n#     !\n#     2\n#     !\n#     3\n#     !\n#     4\n#     L->  ...\ngraph=nx.generators.barbell_graph(4,2)\nnx.write_network_text(graph,vertical_chains=False)\n# \u2559\u2500\u2500 4\n#     \u251c\u2500\u2500 5\n#     \u2502   \u2514\u2500\u2500 6\n#     \u2502       \u251c\u2500\u2500 7\n#     \u2502       \u2502   \u251c\u2500\u2500 8 \u2500 6\n#     \u2502       \u2502   \u2502   \u2514\u2500\u2500 9 \u2500 6, 7\n#     \u2502       \u2502   \u2514\u2500\u2500  ...\n#     \u2502       \u2514\u2500\u2500  ...\n#     \u2514\u2500\u2500 3\n#         \u251c\u2500\u2500 0\n#         \u2502   \u251c\u2500\u2500 1 \u2500 3\n#         \u2502   \u2502   \u2514\u2500\u2500 2 \u2500 0, 3\n#         \u2502   \u2514\u2500\u2500  ...\n#         \u2514\u2500\u2500  ...\nnx.write_network_text(graph,vertical_chains=True)\n# \u2559\u2500\u2500 4\n#     \u251c\u2500\u2500 5\n#     \u2502   \u2502\n#     \u2502   6\n#     \u2502   \u251c\u2500\u2500 7\n#     \u2502   \u2502   \u251c\u2500\u2500 8 \u2500 6\n#     \u2502   \u2502   \u2502   \u2502\n#     \u2502   \u2502   \u2502   9 \u2500 6, 7\n#     \u2502   \u2502   \u2514\u2500\u2500  ...\n#     \u2502   \u2514\u2500\u2500  ...\n#     \u2514\u2500\u2500 3\n#         \u251c\u2500\u2500 0\n#         \u2502   \u251c\u2500\u2500 1 \u2500 3\n#         \u2502   \u2502   \u2502\n#         \u2502   \u2502   2 \u2500 0, 3\n#         \u2502   \u2514\u2500\u2500  ...\n#         \u2514\u2500\u2500  ...\ngraph=nx.complete_graph(5,create_using=nx.Graph)\nnx.write_network_text(graph)\n# \u2559\u2500\u2500 0\n#     \u251c\u2500\u2500 1\n#     \u2502   \u251c\u2500\u2500 2 \u2500 0\n#     \u2502   \u2502   \u251c\u2500\u2500 3 \u2500 0, 1\n#     \u2502   \u2502   \u2502   \u2514\u2500\u2500 4 \u2500 0, 1, 2\n#     \u2502   \u2502   \u2514\u2500\u2500  ...\n#     \u2502   \u2514\u2500\u2500  ...\n#     \u2514\u2500\u2500  ...\ngraph=nx.complete_graph(3,create_using=nx.DiGraph)\nnx.write_network_text(graph)\n# \u2559\u2500\u2500 0 \u257e 1, 2\n#     \u251c\u2500\u257c 1 \u257e 2\n#     \u2502   \u251c\u2500\u257c 2 \u257e 0\n#     \u2502   \u2502   \u2514\u2500\u257c  ...\n#     \u2502   \u2514\u2500\u257c  ...\n#     \u2514\u2500\u257c  ..."
        }
    },
    {
        "Section ID": "group_degree_centrality",
        "Description": [
            "Compute the group degree centrality for a group of nodes.",
            "Group degree centrality of a group of nodes \\(S\\) is the fraction\nof non-group members connected to group members."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.",
                "S : list or set": "S is a group of nodes which belong to G, for which group degree\ncentrality is to be calculated."
            },
            "Returns:": {
                "centrality : float": "Group degree centrality of the group S."
            },
            "Raises:": {
                "NetworkXError": "If node(s) in S are not in G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The measure was introduced in [1] . The number of nodes in the group must be a maximum of n - 1 where n is the total number of nodes in the graph.",
            "References": "[1]M G Everett and S P Borgatti:\nThe Centrality of Groups and Classes.\nJournal of Mathematical Sociology. 23(3): 181-201. 1999.http://www.analytictech.com/borgatti/group_centrality.htm"
        }
    },
    {
        "Section ID": "disjoint_union",
        "Description": [
            "Combine graphs G and H. The nodes are assumed to be unique (disjoint).",
            "This algorithm automatically relabels nodes to avoid name collisions."
        ],
        "Field List": {
            "Parameters:": {
                "G,H : graph": "A NetworkX graph"
            },
            "Returns:": {
                "U : A union graph with the same type as G.": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "A new graph is created, of the same class as G.  It is recommended\nthat G and H be either both directed or both undirected. The nodes of G are relabeled 0 to len(G)-1, and the nodes of H are\nrelabeled len(G) to len(G)+len(H)-1. Renumbering forces G and H to be disjoint, so no exception is ever raised for a name collision.\nTo preserve the check for common nodes, use union(). Edge and node attributes are propagated from G and H to the union graph.\nGraph attributes are also propagated, but if they are present in both G and H,\nthen the value from H is used. To combine graphs that have common nodes, consider compose(G, H)\nor the method, Graph.update().",
            "Examples": "G=nx.Graph([(0,1),(0,2),(1,2)])\nH=nx.Graph([(0,3),(1,2),(2,3)])\nG.nodes[0][\"key1\"]=5\nH.nodes[0][\"key2\"]=10\nU=nx.disjoint_union(G,H)\nU.nodes(data=True)\n# NodeDataView({0: {'key1': 5}, 1: {}, 2: {}, 3: {'key2': 10}, 4: {}, 5: {}, 6: {}})\nU.edges\n# EdgeView([(0, 1), (0, 2), (1, 2), (3, 4), (4, 6), (5, 6)])"
        }
    },
    {
        "Section ID": "descendants_at_distance",
        "Description": [
            "Returns all nodes at a fixed distance from source in G ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A graph",
                "source : node inG": "",
                "distance : the distance of the wanted nodes fromsource": ""
            },
            "Returns:": {
                "set()": "The descendants ofsourceinGat the givendistancefromsource"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.path_graph(5)\nnx.descendants_at_distance(G,2,2)\n# {0, 4}\nH=nx.DiGraph()\nH.add_edges_from([(0,1),(0,2),(1,3),(1,4),(2,5),(2,6)])\nnx.descendants_at_distance(H,0,2)\n# {3, 4, 5, 6}\nnx.descendants_at_distance(H,5,0)\n# {5}\nnx.descendants_at_distance(H,5,1)\n# set()"
        }
    },
    {
        "Section ID": "write_sparse6",
        "Description": [
            "Write graph G to given path in sparse6 format."
        ],
        "Field List": {
            "Parameters:": {
                "G : Graph (undirected)": "",
                "path : file or string": "File or filename to write",
                "nodes: list or iterable": "Nodes are labeled 0\u2026n-1 in the order provided.  If None the ordering\ngiven by G.nodes() is used.",
                "header: bool": "If True add \u2018>>sparse6<<\u2019 string to head of data"
            },
            "Raises:": {
                "NetworkXError": "If the graph is directed"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The format does not support edge or node labels.",
            "References": "[1]Sparse6 specification\n<https://users.cecs.anu.edu.au/~bdm/data/formats.html>",
            "Examples": "You can write a sparse6 file by giving the path to the file:\nimporttempfile\nwithtempfile.NamedTemporaryFile(delete=False)asf:\nnx.write_sparse6(nx.path_graph(2),f.name)\nprint(f.read())\n# b'>>sparse6<<:An\\n'\nYou can also write a sparse6 file by giving an open file-like object:\nwithtempfile.NamedTemporaryFile()asf:\nnx.write_sparse6(nx.path_graph(2),f)\n_=f.seek(0)\nprint(f.read())\n# b'>>sparse6<<:An\\n'"
        }
    },
    {
        "Section ID": "preferential_attachment",
        "Description": [
            "Compute the preferential attachment score of all node pairs in ebunch.",
            "Preferential attachment score of u and v is defined as",
            "where \\(\\Gamma(u)\\) denotes the set of neighbors of \\(u\\) ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "NetworkX undirected graph.",
                "ebunch : iterable of node pairs, optional (default = None)": "Preferential attachment score will be computed for each pair of\nnodes given in the iterable. The pairs must be given as\n2-tuples (u, v) where u and v are nodes in the graph. If ebunch\nis None then all nonexistent edges in the graph will be used.\nDefault value: None."
            },
            "Returns:": {
                "piter : iterator": "An iterator of 3-tuples in the form (u, v, p) where (u, v) is a\npair of nodes and p is their preferential attachment score."
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis aDiGraph, aMultigraphor aMultiDiGraph.",
                "NodeNotFound": "Ifebunchhas a node that is not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]D. Liben-Nowell, J. Kleinberg.\nThe Link Prediction Problem for Social Networks (2004).http://www.cs.cornell.edu/home/kleinber/link-pred.pdf",
            "Examples": "G=nx.complete_graph(5)\npreds=nx.preferential_attachment(G,[(0,1),(2,3)])\nforu,v,pinpreds:\nprint(f\"({u}, {v}) -> {p}\")\n# (0, 1) -> 16\n# (2, 3) -> 16"
        }
    },
    {
        "Section ID": "truncated_cube_graph",
        "Description": [
            "Returns the skeleton of the truncated cube.",
            "The truncated cube is an Archimedean solid with 14 regular\nfaces (6 octagonal and 8 triangular), 36 edges and 24 nodes [1] .\nThe truncated cube is created by truncating (cutting off) the tips\nof the cube one third of the way into each edge [2] ."
        ],
        "Field List": {
            "Parameters:": {
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : networkx Graph": "Skeleton of the truncated cube"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://en.wikipedia.org/wiki/Truncated_cube  [2]https://www.coolmath.com/reference/polyhedra-truncated-cube"
        }
    },
    {
        "Section ID": "cytoscape_graph",
        "Description": [
            "Create a NetworkX graph from a dictionary in cytoscape JSON format."
        ],
        "Field List": {
            "Parameters:": {
                "data : dict": "A dictionary of data conforming to cytoscape JSON format.",
                "name : string": "A string which is mapped to the \u2018name\u2019 node element in cyjs format.\nMust not have the same value asident.",
                "ident : string": "A string which is mapped to the \u2018id\u2019 node element in cyjs format.\nMust not have the same value asname."
            },
            "Returns:": {
                "graph : a NetworkX graph instance": "Thegraphcan be an instance ofGraph,DiGraph,MultiGraph, orMultiDiGraphdepending on the input data."
            },
            "Raises:": {
                "NetworkXError": "If thenameandidentattributes are identical."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Cytoscape user\u2019s manual:http://manual.cytoscape.org/en/stable/index.html",
            "Examples": "data_dict={\n\"data\":[],\n\"directed\":False,\n\"multigraph\":False,\n\"elements\":{\n\"nodes\":[\n{\"data\":{\"id\":\"0\",\"value\":0,\"name\":\"0\"}},\n{\"data\":{\"id\":\"1\",\"value\":1,\"name\":\"1\"}},\n],\n\"edges\":[{\"data\":{\"source\":0,\"target\":1}}],\n},\n}\nG=nx.cytoscape_graph(data_dict)\nG.name\n# ''\nG.nodes()\n# NodeView((0, 1))\nG.nodes(data=True)[0]\n# {'id': '0', 'value': 0, 'name': '0'}\nG.edges(data=True)\n# EdgeDataView([(0, 1, {'source': 0, 'target': 1})])"
        }
    },
    {
        "Section ID": "attribute_mixing_dict",
        "Description": [
            "Returns dictionary representation of mixing matrix for attribute."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "NetworkX graph object.",
                "attribute : string": "Node attribute key.",
                "nodes: list or iterable (optional)": "Unse nodes in container to build the dict. The default is all nodes.",
                "normalized : bool (default=False)": "Return counts if False or probabilities if True."
            },
            "Returns:": {
                "d : dictionary": "Counts or joint probability of occurrence of attribute pairs."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph()\nG.add_nodes_from([0,1],color=\"red\")\nG.add_nodes_from([2,3],color=\"blue\")\nG.add_edge(1,3)\nd=nx.attribute_mixing_dict(G,\"color\")\nprint(d[\"red\"][\"blue\"])\n# 1\nprint(d[\"blue\"][\"red\"])# d symmetric for undirected graphs\n# 1"
        }
    },
    {
        "Section ID": "to_nested_tuple",
        "Description": [
            "Returns a nested tuple representation of the given tree.",
            "The nested tuple representation of a tree is defined\nrecursively. The tree with one node and no edges is represented by\nthe empty tuple, () . A tree with k subtrees is represented\nby a tuple of length k in which each element is the nested tuple\nrepresentation of a subtree."
        ],
        "Field List": {
            "Parameters:": {
                "T : NetworkX graph": "An undirected graph object representing a tree.",
                "root : node": "The node inTto interpret as the root of the tree.",
                "canonical_form : bool": "IfTrue, each tuple is sorted so that the function returns\na canonical form for rooted trees. This means \u201clighter\u201d subtrees\nwill appear as nested tuples before \u201cheavier\u201d subtrees. In this\nway, each isomorphic rooted tree has the same nested tuple\nrepresentation."
            },
            "Returns:": {
                "tuple": "A nested tuple representation of the tree."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This function is not the inverse of from_nested_tuple() ; the\nonly guarantee is that the rooted trees are isomorphic.",
            "Examples": "The tree need not be a balanced binary tree:\nT=nx.Graph()\nT.add_edges_from([(0,1),(0,2),(0,3)])\nT.add_edges_from([(1,4),(1,5)])\nT.add_edges_from([(3,6),(3,7)])\nroot=0\nnx.to_nested_tuple(T,root)\n# (((), ()), (), ((), ()))\nContinuing the above example, ifcanonical_formisTrue, the\nnested tuples will be sorted:\nnx.to_nested_tuple(T,root,canonical_form=True)\n# ((), ((), ()), ((), ()))\nEven the path graph can be interpreted as a tree:\nT=nx.path_graph(4)\nroot=0\nnx.to_nested_tuple(T,root)\n# ((((),),),)"
        }
    },
    {
        "Section ID": "havel_hakimi_graph",
        "Description": [
            "Returns a simple graph with given degree sequence constructed\nusing the Havel-Hakimi algorithm."
        ],
        "Field List": {
            "Parameters:": {
                "deg_sequence: list of integers": "Each integer corresponds to the degree of a node (need not be sorted).",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated.\nDirected graphs are not allowed."
            },
            "Raises:": {
                "NetworkXException": "For a non-graphical degree sequence (i.e. one\nnot realizable by some simple graph)."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The Havel-Hakimi algorithm constructs a simple graph by\nsuccessively connecting the node of highest degree to other nodes\nof highest degree, resorting remaining nodes by degree, and\nrepeating the process. The resulting graph has a high\ndegree-associativity.  Nodes are labeled 1,.., len(deg_sequence),\ncorresponding to their position in deg_sequence. The basic algorithm is from Hakimi [1] and was generalized by\nKleitman and Wang [2] .",
            "References": "[1]Hakimi S., On Realizability of a Set of Integers as\nDegrees of the Vertices of a Linear Graph. I,\nJournal of SIAM, 10(3), pp. 496-506 (1962)  [2]Kleitman D.J. and Wang D.L.\nAlgorithms for Constructing Graphs and Digraphs with Given Valences\nand Factors  Discrete Mathematics, 6(1), pp. 79-88 (1973)"
        }
    },
    {
        "Section ID": "draw_networkx_labels",
        "Description": [
            "Draw node labels on the graph G."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph",
                "pos : dictionary": "A dictionary with nodes as keys and positions as values.\nPositions should be sequences of length 2.",
                "labels : dictionary (default={n: n for n in G})": "Node labels in a dictionary of text labels keyed by node.\nNode-keys in labels should appear as keys inpos.\nIf needed use:{n:labforn,labinlabels.items()ifninpos}",
                "font_size : int (default=12)": "Font size for text labels",
                "font_color : color (default=\u2019k\u2019 black)": "Font color string. Color can be string or rgb (or rgba) tuple of\nfloats from 0-1.",
                "font_weight : string (default=\u2019normal\u2019)": "Font weight",
                "font_family : string (default=\u2019sans-serif\u2019)": "Font family",
                "alpha : float or None (default=None)": "The text transparency",
                "bbox : Matplotlib bbox, (default is Matplotlib\u2019s ax.text default)": "Specify text box properties (e.g. shape, color etc.) for node labels.",
                "horizontalalignment : string (default=\u2019center\u2019)": "Horizontal alignment {\u2018center\u2019, \u2018right\u2019, \u2018left\u2019}",
                "verticalalignment : string (default=\u2019center\u2019)": "Vertical alignment {\u2018center\u2019, \u2018top\u2019, \u2018bottom\u2019, \u2018baseline\u2019, \u2018center_baseline\u2019}",
                "ax : Matplotlib Axes object, optional": "Draw the graph in the specified Matplotlib axes.",
                "clip_on : bool (default=True)": "Turn on clipping of node labels at axis boundaries",
                "hide_ticks : bool, optional": "Hide ticks of axes. WhenTrue(the default), ticks and ticklabels\nare removed from the axes. To set ticks and tick labels to the pyplot default,\nusehide_ticks=False."
            },
            "Returns:": {
                "dict": "dictof labels keyed on the nodes"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.dodecahedral_graph()\nlabels=nx.draw_networkx_labels(G,pos=nx.spring_layout(G))\nAlso see the NetworkX drawing examples athttps://networkx.org/documentation/latest/auto_examples/index.html"
        }
    },
    {
        "Section ID": "onion_layers",
        "Description": [
            "Returns the layer of each vertex in an onion decomposition of the graph.",
            "The onion decomposition refines the k-core decomposition by providing\ninformation on the internal organization of each k-shell. It is usually\nused alongside the corenumbers ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "An undirected graph without self loops."
            },
            "Returns:": {
                "od_layers : dictionary": "A dictionary keyed by node to the onion layer. The layers are\ncontiguous integers starting at 1."
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis a multigraph or directed graph or if it contains self loops."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Multi-scale structure and topological anomaly detection via a new\nnetwork statistic: The onion decomposition\nL. H\u00e9bert-Dufresne, J. A. Grochow, and A. Allard\nScientific Reports 6, 31708 (2016)http://doi.org/10.1038/srep31708  [2]Percolation and the effective structure of complex networks\nA. Allard and L. H\u00e9bert-Dufresne\nPhysical Review X 9, 011023 (2019)http://doi.org/10.1103/PhysRevX.9.011023",
            "Examples": "degrees=[0,1,2,2,2,2,3]\nH=nx.havel_hakimi_graph(degrees)\nH.degree\n# DegreeView({0: 1, 1: 2, 2: 2, 3: 2, 4: 2, 5: 3, 6: 0})\nnx.onion_layers(H)\n# {6: 1, 0: 2, 4: 3, 1: 4, 2: 4, 3: 4, 5: 4}"
        }
    },
    {
        "Section ID": "check_planarity",
        "Description": [
            "Check if a graph is planar and return a counterexample or an embedding.",
            "A graph is planar iff it can be drawn in a plane without\nany edge intersections."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "counterexample : bool": "A Kuratowski subgraph (to proof non planarity) is only returned if set\nto true."
            },
            "Returns:": {
                "(is_planar, certificate) : (bool, NetworkX graph) tuple": "is_planar is true if the graph is planar.\nIf the graph is planarcertificateis a PlanarEmbedding\notherwise it is a Kuratowski subgraph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "A (combinatorial) embedding consists of cyclic orderings of the incident\nedges at each vertex. Given such an embedding there are multiple approaches\ndiscussed in literature to drawing the graph (subject to various\nconstraints, e.g. integer coordinates), see e.g. [2]. The planarity check algorithm and extraction of the combinatorial embedding\nis based on the Left-Right Planarity Test [1]. A counterexample is only generated if the corresponding parameter is set,\nbecause the complexity of the counterexample generation is higher.",
            "References": "[1]Ulrik Brandes:\nThe Left-Right Planarity Test\n2009http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.217.9208  [2]Takao Nishizeki, Md Saidur Rahman:\nPlanar graph drawing\nLecture Notes Series on Computing: Volume 12\n2004",
            "Examples": "G=nx.Graph([(0,1),(0,2)])\nis_planar,P=nx.check_planarity(G)\nprint(is_planar)\n# True\nWhenGis planar, aPlanarEmbeddinginstance is returned:\nP.get_data()\n# {0: [1, 2], 1: [0], 2: [0]}"
        }
    },
    {
        "Section ID": "complete_bipartite_graph",
        "Description": [
            "Returns the complete bipartite graph K_{n_1,n_2} .",
            "The graph is composed of two partitions with nodes 0 to (n1 - 1)\nin the first and nodes n1 to (n1 + n2 - 1) in the second.\nEach node in the first is connected to each node in the second."
        ],
        "Field List": {
            "Parameters:": {
                "n1, n2 : integer or iterable container of nodes": "If integers, nodes are fromrange(n1)andrange(n1,n1+n2).\nIf a container, the elements are the nodes.",
                "create_using : NetworkX graph instance, (default: nx.Graph)": "Return graph of this type."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Nodes are the integers 0 to n1+n2-1 unless either n1 or n2 are\ncontainers of nodes. If only one of n1 or n2 are integers, that\ninteger is replaced by range of that integer. The nodes are assigned the attribute \u2018bipartite\u2019 with the value 0 or 1\nto indicate which bipartite set the node belongs to. This function is not imported in the main namespace.\nTo use it use nx.bipartite.complete_bipartite_graph"
        }
    },
    {
        "Section ID": "identified_nodes",
        "Description": [
            "Returns the graph that results from contracting u and v .",
            "Node contraction identifies the two nodes as a single node incident to any\nedge that was incident to the original two nodes."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "The graph whose nodes will be contracted.",
                "u, v : nodes": "Must be nodes inG.",
                "self_loops : Boolean": "If this is True, any edges joininguandvinGbecome\nself-loops on the new node in the returned graph.",
                "copy : Boolean": "If this is True (default True), make a copy ofGand return that instead of directly changingG."
            },
            "Returns:": {
                "Networkx graph": "If Copy is True,\nA new graph object of the same type asG(leavingGunmodified)\nwithuandvidentified in a single node. The right nodevwill be merged into the nodeu, so onlyuwill appear in the\nreturned graph.\nIf copy is False,\nModifiesGwithuandvidentified in a single node.\nThe right nodevwill be merged into the nodeu, so\nonlyuwill appear in the returned graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For multigraphs, the edge keys for the realigned edges may\nnot be the same as the edge keys for the old edges. This is\nnatural because edge keys are unique only within each pair of nodes. For non-multigraphs where u and v are adjacent to a third node w , the edge ( v , w ) will be contracted into the edge ( u , w ) with its attributes stored into a \u201ccontraction\u201d attribute. This function is also available as identified_nodes .",
            "Examples": "Contracting two nonadjacent nodes of the cycle graph on four nodesC_4yields the path graph (ignoring parallel edges):\nG=nx.cycle_graph(4)\nM=nx.contracted_nodes(G,1,3)\nP3=nx.path_graph(3)\nnx.is_isomorphic(M,P3)\n# True\nG=nx.MultiGraph(P3)\nM=nx.contracted_nodes(G,0,2)\nM.edges\n# MultiEdgeView([(0, 1, 0), (0, 1, 1)])\nG=nx.Graph([(1,2),(2,2)])\nH=nx.contracted_nodes(G,1,2,self_loops=False)\nlist(H.nodes())\n# [1]\nlist(H.edges())\n# [(1, 1)]\nIn aMultiDiGraphwith a self loop, the in and out edges will\nbe treated separately as edges, so while contracting a node which\nhas a self loop the contraction will add multiple edges:\nG=nx.MultiDiGraph([(1,2),(2,2)])\nH=nx.contracted_nodes(G,1,2)\nlist(H.edges())# edge 1->2, 2->2, 2<-2 from the original Graph G\n# [(1, 1), (1, 1), (1, 1)]\nH=nx.contracted_nodes(G,1,2,self_loops=False)\nlist(H.edges())# edge 2->2, 2<-2 from the original Graph G\n# [(1, 1), (1, 1)]"
        }
    },
    {
        "Section ID": "from_sparse6_bytes",
        "Description": [
            "Read an undirected graph in sparse6 format from string."
        ],
        "Field List": {
            "Parameters:": {
                "string : string": "Data in sparse6 format"
            },
            "Returns:": {
                "G : Graph": ""
            },
            "Raises:": {
                "NetworkXError": "If the string is unable to be parsed in sparse6 format"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Sparse6 specification\n<https://users.cecs.anu.edu.au/~bdm/data/formats.html>",
            "Examples": "G=nx.from_sparse6_bytes(b\":A_\")\nsorted(G.edges())\n# [(0, 1), (0, 1), (0, 1)]"
        }
    },
    {
        "Section ID": "is_planar",
        "Description": [
            "Returns True if and only if G is planar.",
            "A graph is planar iff it can be drawn in a plane without\nany edge intersections."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": ""
            },
            "Returns:": {
                "bool": "Whether the graph is planar."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph([(0,1),(0,2)])\nnx.is_planar(G)\n# True\nnx.is_planar(nx.complete_graph(5))\n# False"
        }
    },
    {
        "Section ID": "random_powerlaw_tree_sequence",
        "Description": [
            "Returns a degree sequence for a tree with a power law distribution."
        ],
        "Field List": {
            "Parameters:": {
                "n : int,": "The number of nodes.",
                "gamma : float": "Exponent of the power law.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "tries : int": "Number of attempts to adjust the sequence to make it a tree."
            },
            "Raises:": {
                "NetworkXError": "If no valid sequence is found within the maximum number of\nattempts."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "A trial power law degree sequence is chosen and then elements are\nswapped with new elements from a power law distribution until\nthe sequence makes a tree (by checking, for example, that the number of\nedges is one smaller than the number of nodes)."
        }
    },
    {
        "Section ID": "constraint",
        "Description": [
            "Returns the constraint on all nodes in the graph G .",
            "The constraint is a measure of the extent to which a node v is\ninvested in those nodes that are themselves invested in the\nneighbors of v . Formally, the constraint on v , denoted c(v) ,\nis defined by",
            "where \\(N(v)\\) is the subset of the neighbors of v that are either\npredecessors or successors of v and \\(\\ell(v, w)\\) is the local\nconstraint on v with respect to w  [1] . For the definition of local\nconstraint, see local_constraint() ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "The graph containingv. This can be either directed or undirected.",
                "nodes : container, optional": "Container of nodes in the graphGto compute the constraint. If\nNone, the constraint of every node is computed.",
                "weight : None or string, optional": "If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight."
            },
            "Returns:": {
                "dict": "Dictionary with nodes as keys and the constraint on the node as values."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Burt, Ronald S.\n\u201cStructural holes and good ideas\u201d.\nAmerican Journal of Sociology (110): 349\u2013399."
        }
    },
    {
        "Section ID": "node_link_data",
        "Description": [
            "Returns data in node-link format that is suitable for JSON serialization\nand use in JavaScript documents."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : string": "A string that provides the \u2018source\u2019 attribute name for storing NetworkX-internal graph data.",
                "target : string": "A string that provides the \u2018target\u2019 attribute name for storing NetworkX-internal graph data.",
                "name : string": "A string that provides the \u2018name\u2019 attribute name for storing NetworkX-internal graph data.",
                "key : string": "A string that provides the \u2018key\u2019 attribute name for storing NetworkX-internal graph data.",
                "link : string": "A string that provides the \u2018link\u2019 attribute name for storing NetworkX-internal graph data."
            },
            "Returns:": {
                "data : dict": "A dictionary with node-link formatted data."
            },
            "Raises:": {
                "NetworkXError": "If the values of \u2018source\u2019, \u2018target\u2019 and \u2018key\u2019 are not unique."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Graph, node, and link attributes are stored in this format.  Note that\nattribute keys will be converted to strings in order to comply with JSON. Attribute \u2018key\u2019 is only used for multigraphs. To use node_link_data in conjunction with node_link_graph ,\nthe keyword names for the attributes must match.",
            "Examples": "G=nx.Graph([(\"A\",\"B\")])\ndata1=nx.node_link_data(G)\ndata1\n# {'directed': False, 'multigraph': False, 'graph': {}, 'nodes': [{'id': 'A'}, {'id': 'B'}], 'links': [{'source': 'A', 'target': 'B'}]}\nTo serialize with JSON\nimportjson\ns1=json.dumps(data1)\ns1\n# '{\"directed\": false, \"multigraph\": false, \"graph\": {}, \"nodes\": [{\"id\": \"A\"}, {\"id\": \"B\"}], \"links\": [{\"source\": \"A\", \"target\": \"B\"}]}'\nA graph can also be serialized by passingnode_link_dataas an encoder function. The two methods are equivalent.\ns1=json.dumps(G,default=nx.node_link_data)\ns1\n# '{\"directed\": false, \"multigraph\": false, \"graph\": {}, \"nodes\": [{\"id\": \"A\"}, {\"id\": \"B\"}], \"links\": [{\"source\": \"A\", \"target\": \"B\"}]}'\nThe attribute names for storing NetworkX-internal graph data can\nbe specified as keyword options.\nH=nx.gn_graph(2)\ndata2=nx.node_link_data(H,link=\"edges\",source=\"from\",target=\"to\")\ndata2\n# {'directed': True, 'multigraph': False, 'graph': {}, 'nodes': [{'id': 0}, {'id': 1}], 'edges': [{'from': 1, 'to': 0}]}"
        }
    },
    {
        "Section ID": "degree_centrality",
        "Description": [
            "Compute the degree centrality for nodes.",
            "The degree centrality for a node v is the fraction of nodes it\nis connected to."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph"
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of nodes with degree centrality as the value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The degree centrality values are normalized by dividing by the maximum\npossible degree in a simple graph n-1 where n is the number of nodes in G. For multigraphs or graphs with self loops the maximum degree might\nbe higher than n-1 and values of degree centrality greater than 1\nare possible.",
            "Examples": "G=nx.Graph([(0,1),(0,2),(0,3),(1,2),(1,3)])\nnx.degree_centrality(G)\n# {0: 1.0, 1: 1.0, 2: 0.6666666666666666, 3: 0.6666666666666666}"
        }
    },
    {
        "Section ID": "all_pairs_bellman_ford_path_length",
        "Description": [
            "Compute shortest path lengths between all nodes in a weighted graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "weight : string or function (default=\u201dweight\u201d)": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number."
            },
            "Returns:": {
                "distance : iterator": "(source, dictionary) iterator with dictionary keyed by target and\nshortest path length as the key value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The dictionary returned only has keys for reachable node pairs.",
            "Examples": "G=nx.path_graph(5)\nlength=dict(nx.all_pairs_bellman_ford_path_length(G))\nfornodein[0,1,2,3,4]:\nprint(f\"1 - {node}: {length[1][node]}\")\n# 1 - 0: 1\n# 1 - 1: 0\n# 1 - 2: 1\n# 1 - 3: 2\n# 1 - 4: 3\nlength[3][2]\n# 1\nlength[2][2]\n# 0"
        }
    },
    {
        "Section ID": "is_graphical",
        "Description": [
            "Returns True if sequence is a valid degree sequence.",
            "A degree sequence is valid if some graph can realize it."
        ],
        "Field List": {
            "Parameters:": {
                "sequence : list or iterable container": "A sequence of integer node degrees",
                "method : \u201ceg\u201d | \u201chh\u201d  (default: \u2018eg\u2019)": "The method used to validate the degree sequence.\n\u201ceg\u201d corresponds to the Erd\u0151s-Gallai algorithm[EG1960],[choudum1986], and\n\u201chh\u201d to the Havel-Hakimi algorithm[havel1955],[hakimi1962],[CL1996]."
            },
            "Returns:": {
                "valid : bool": "True if the sequence is a valid degree sequence and False if not."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[EG1960]Erd\u0151s and Gallai, Mat. Lapok 11 264, 1960.  [choudum1986]S.A. Choudum. \u201cA simple proof of the Erd\u0151s-Gallai theorem on\ngraph sequences.\u201d Bulletin of the Australian Mathematical Society, 33,\npp 67-70, 1986.https://doi.org/10.1017/S0004972700002872  [havel1955]Havel, V. \u201cA Remark on the Existence of Finite Graphs\u201d\nCasopis Pest. Mat. 80, 477-480, 1955.  [hakimi1962]Hakimi, S. \u201cOn the Realizability of a Set of Integers as\nDegrees of the Vertices of a Graph.\u201d SIAM J. Appl. Math. 10, 496-506, 1962.  [CL1996]G. Chartrand and L. Lesniak, \u201cGraphs and Digraphs\u201d,\nChapman and Hall/CRC, 1996.",
            "Examples": "G=nx.path_graph(4)\nsequence=(dforn,dinG.degree())\nnx.is_graphical(sequence)\n# True\nTo test a non-graphical sequence:\n>>> sequence_list = [d for n, d in G.degree()]\n>>> sequence_list[-1] += 1\n>>> nx.is_graphical(sequence_list)\nFalse"
        }
    },
    {
        "Section ID": "powerlaw_sequence",
        "Description": [
            "Return sample sequence of length n from a power law distribution."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "edge_current_flow_betweenness_centrality",
        "Description": [
            "Compute current-flow betweenness centrality for edges.",
            "Current-flow betweenness centrality uses an electrical current\nmodel for information spreading in contrast to betweenness\ncentrality which uses shortest paths.",
            "Current-flow betweenness centrality is also known as\nrandom-walk betweenness centrality [2] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "normalized : bool, optional (default=True)": "If True the betweenness values are normalized by 2/[(n-1)(n-2)] where\nn is the number of nodes in G.",
                "weight : string or None, optional (default=None)": "Key for edge data used as the edge weight.\nIf None, then use 1 as each edge weight.\nThe weight reflects the capacity or the strength of the\nedge.",
                "dtype : data type (default=float)": "Default data type for internal matrices.\nSet to np.float32 for lower memory consumption.",
                "solver : string (default=\u2019full\u2019)": "Type of linear solver to use for computing the flow matrix.\nOptions are \u201cfull\u201d (uses most memory), \u201clu\u201d (recommended), and\n\u201ccg\u201d (uses least memory)."
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of edge tuples with betweenness centrality as the value."
            },
            "Raises:": {
                "NetworkXError": "The algorithm does not support DiGraphs.\nIf the input graph is an instance of DiGraph class, NetworkXError\nis raised."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Current-flow betweenness can be computed in \\(O(I(n-1)+mn \\log n)\\) time [1] , where \\(I(n-1)\\) is the time needed to compute the\ninverse Laplacian.  For a full matrix this is \\(O(n^3)\\) but using\nsparse methods you can achieve \\(O(nm{\\sqrt k})\\) where \\(k\\) is the\nLaplacian matrix condition number. The space required is \\(O(nw)\\) where \\(w\\) is the width of the sparse\nLaplacian matrix.  Worse case is \\(w=n\\) for \\(O(n^2)\\) . If the edges have a \u2018weight\u2019 attribute they will be used as\nweights in this algorithm.  Unspecified weights are set to 1.",
            "References": "[1]Centrality Measures Based on Current Flow.\nUlrik Brandes and Daniel Fleischer,\nProc. 22nd Symp. Theoretical Aspects of Computer Science (STACS \u201805).\nLNCS 3404, pp. 533-544. Springer-Verlag, 2005.https://doi.org/10.1007/978-3-540-31856-9_44  [2]A measure of betweenness centrality based on random walks,\nM. E. J. Newman, Social Networks 27, 39-54 (2005)."
        }
    },
    {
        "Section ID": "bull_graph",
        "Description": [
            "Returns the Bull Graph",
            "The Bull Graph has 5 nodes and 5 edges. It is a planar undirected\ngraph in the form of a triangle with two disjoint pendant edges [1] The name comes from the triangle and pendant edges representing\nrespectively the body and legs of a bull."
        ],
        "Field List": {
            "Parameters:": {
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : networkx Graph": "A bull graph with 5 nodes"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://en.wikipedia.org/wiki/Bull_graph."
        }
    },
    {
        "Section ID": "LFR_benchmark_graph",
        "Description": [
            "Returns the LFR benchmark graph.",
            "This algorithm proceeds as follows:"
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "Number of nodes in the created graph.",
                "tau1 : float": "Power law exponent for the degree distribution of the created\ngraph. This value must be strictly greater than one.",
                "tau2 : float": "Power law exponent for the community size distribution in the\ncreated graph. This value must be strictly greater than one.",
                "mu : float": "Fraction of inter-community edges incident to each node. This\nvalue must be in the interval [0, 1].",
                "average_degree : float": "Desired average degree of nodes in the created graph. This value\nmust be in the interval [0,n]. Exactly one of this andmin_degreemust be specified, otherwise aNetworkXErroris raised.",
                "min_degree : int": "Minimum degree of nodes in the created graph. This value must be\nin the interval [0,n]. Exactly one of this andaverage_degreemust be specified, otherwise aNetworkXErroris raised.",
                "max_degree : int": "Maximum degree of nodes in the created graph. If not specified,\nthis is set ton, the total number of nodes in the graph.",
                "min_community : int": "Minimum size of communities in the graph. If not specified, this\nis set tomin_degree.",
                "max_community : int": "Maximum size of communities in the graph. If not specified, this\nis set ton, the total number of nodes in the graph.",
                "tol : float": "Tolerance when comparing floats, specifically when comparing\naverage degree values.",
                "max_iters : int": "Maximum number of iterations to try to create the community sizes,\ndegree distribution, and community affiliations.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "G : NetworkX graph": "The LFR benchmark graph generated according to the specified\nparameters.Each node in the graph has a node attribute'community'that\nstores the community (that is, the set of nodes) that includes\nit."
            },
            "Raises:": {
                "NetworkXError": "If any of the parameters do not meet their upper and lower bounds:tau1andtau2must be strictly greater than 1.mumust be in [0, 1].max_degreemust be in {1, \u2026,n}.min_communityandmax_communitymust be in {0, \u2026,n}.If not exactly one ofaverage_degreeandmin_degreeis\nspecified.Ifmin_degreeis not specified and a suitablemin_degreecannot be found.",
                "ExceededMaxIterations": "If a valid degree sequence cannot be created withinmax_itersnumber of iterations.If a valid set of community sizes cannot be created withinmax_itersnumber of iterations.If a valid community assignment cannot be created within10*n*max_itersnumber of iterations."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm differs slightly from the original way it was\npresented in [1].",
            "References": "[1]\u201cBenchmark graphs for testing community detection algorithms\u201d,\nAndrea Lancichinetti, Santo Fortunato, and Filippo Radicchi,\nPhys. Rev. E 78, 046110 2008  [2]https://www.santofortunato.net/resources",
            "Examples": "Basic usage:\nfromnetworkx.generators.communityimportLFR_benchmark_graph\nn=250\ntau1=3\ntau2=1.5\nmu=0.1\nG=LFR_benchmark_graph(\nn,tau1,tau2,mu,average_degree=5,min_community=20,seed=10\n)\nContinuing the example above, you can get the communities from the\nnode attributes of the graph:\ncommunities={frozenset(G.nodes[v][\"community\"])forvinG}"
        }
    },
    {
        "Section ID": "subgraph_centrality",
        "Description": [
            "Returns subgraph centrality for each node in G.",
            "Subgraph centrality  of a node n is the sum of weighted closed\nwalks of all lengths starting and ending at node n . The weights\ndecrease with path length. Each closed walk is associated with a\nconnected subgraph ( [1] )."
        ],
        "Field List": {
            "Parameters:": {
                "G: graph": ""
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of nodes with subgraph centrality as the value."
            },
            "Raises:": {
                "NetworkXError": "If the graph is not undirected and simple."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This version of the algorithm computes eigenvalues and eigenvectors\nof the adjacency matrix. Subgraph centrality of a node u in G can be found using\na spectral decomposition of the adjacency matrix [1] ,",
            "References": "[1](1,2,3)Ernesto Estrada, Juan A. Rodriguez-Velazquez,\n\u201cSubgraph centrality in complex networks\u201d,\nPhysical Review E 71, 056103 (2005).https://arxiv.org/abs/cond-mat/0504730",
            "Examples": "(Example from[1])\n>>> G = nx.Graph(\n\u2026     [\n\u2026         (1, 2),\n\u2026         (1, 5),\n\u2026         (1, 8),\n\u2026         (2, 3),\n\u2026         (2, 8),\n\u2026         (3, 4),\n\u2026         (3, 6),\n\u2026         (4, 5),\n\u2026         (4, 7),\n\u2026         (5, 6),\n\u2026         (6, 7),\n\u2026         (7, 8),\n\u2026     ]\n\u2026 )\n>>> sc = nx.subgraph_centrality(G)\n>>> print([f\u201d{node} {sc[node]:0.2f}\u201d for node in sorted(sc)])\n[\u20181 3.90\u2019, \u20182 3.90\u2019, \u20183 3.64\u2019, \u20184 3.71\u2019, \u20185 3.64\u2019, \u20186 3.71\u2019, \u20187 3.64\u2019, \u20188 3.90\u2019]"
        }
    },
    {
        "Section ID": "mixing_expansion",
        "Description": [
            "Returns the mixing expansion between two node sets.",
            "The mixing expansion is the quotient of the cut size and twice the\nnumber of edges in the graph. [1]"
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "S : collection": "A collection of nodes inG.",
                "T : collection": "A collection of nodes inG.",
                "weight : object": "Edge attribute key to use as weight. If not specified, edges\nhave weight one."
            },
            "Returns:": {
                "number": "The mixing expansion between the two setsSandT."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Vadhan, Salil P.\n\u201cPseudorandomness.\u201dFoundations and Trends\nin Theoretical Computer Science7.1\u20133 (2011): 1\u2013336.\n<https://doi.org/10.1561/0400000010>"
        }
    },
    {
        "Section ID": "number_of_cliques",
        "Description": [
            "Returns the number of maximal cliques for each node.",
            "Returns a single or list depending on input nodes.\nOptional list of cliques can be input if already computed."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "is_isomorphic",
        "Description": [
            "Returns True if the graphs G1 and G2 are isomorphic and False otherwise."
        ],
        "Field List": {
            "Parameters:": {
                "G1, G2: graphs": "The two graphs G1 and G2 must be the same type.",
                "node_match : callable": "A function that returns True if node n1 in G1 and n2 in G2 should\nbe considered equal during the isomorphism test.\nIf node_match is not specified then node attributes are not considered.The function will be called likenode_match(G1.nodes[n1], G2.nodes[n2]).That is, the function will receive the node attribute dictionaries\nfor n1 and n2 as inputs.",
                "edge_match : callable": "A function that returns True if the edge attribute dictionary\nfor the pair of nodes (u1, v1) in G1 and (u2, v2) in G2 should\nbe considered equal during the isomorphism test.  If edge_match is\nnot specified then edge attributes are not considered.The function will be called likeedge_match(G1[u1][v1], G2[u2][v2]).That is, the function will receive the edge attribute dictionaries\nof the edges under consideration."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Uses the vf2 algorithm [1] .",
            "References": "[1]L. P. Cordella, P. Foggia, C. Sansone, M. Vento,\n\u201cAn Improved Algorithm for Matching Large Graphs\u201d,\n3rd IAPR-TC15 Workshop  on Graph-based Representations in\nPattern Recognition, Cuen, pp. 149-159, 2001.https://www.researchgate.net/publication/200034365_An_Improved_Algorithm_for_Matching_Large_Graphs",
            "Examples": "importnetworkx.algorithms.isomorphismasiso\nFor digraphs G1 and G2, using \u2018weight\u2019 edge attribute (default: 1)\nG1=nx.DiGraph()\nG2=nx.DiGraph()\nnx.add_path(G1,[1,2,3,4],weight=1)\nnx.add_path(G2,[10,20,30,40],weight=2)\nem=iso.numerical_edge_match(\"weight\",1)\nnx.is_isomorphic(G1,G2)# no weights considered\n# True\nnx.is_isomorphic(G1,G2,edge_match=em)# match weights\n# False\nFor multidigraphs G1 and G2, using \u2018fill\u2019 node attribute (default: \u2018\u2019)\nG1=nx.MultiDiGraph()\nG2=nx.MultiDiGraph()\nG1.add_nodes_from([1,2,3],fill=\"red\")\nG2.add_nodes_from([10,20,30,40],fill=\"red\")\nnx.add_path(G1,[1,2,3,4],weight=3,linewidth=2.5)\nnx.add_path(G2,[10,20,30,40],weight=3)\nnm=iso.categorical_node_match(\"fill\",\"red\")\nnx.is_isomorphic(G1,G2,node_match=nm)\n# True\nFor multidigraphs G1 and G2, using \u2018weight\u2019 edge attribute (default: 7)\nG1.add_edge(1,2,weight=7)\n# 1\nG2.add_edge(10,20)\n# 1\nem=iso.numerical_multiedge_match(\"weight\",7,rtol=1e-6)\nnx.is_isomorphic(G1,G2,edge_match=em)\n# True\nFor multigraphs G1 and G2, using \u2018weight\u2019 and \u2018linewidth\u2019 edge attributes\nwith default values 7 and 2.5. Also using \u2018fill\u2019 node attribute with\ndefault value \u2018red\u2019.\nem=iso.numerical_multiedge_match([\"weight\",\"linewidth\"],[7,2.5])\nnm=iso.categorical_node_match(\"fill\",\"red\")\nnx.is_isomorphic(G1,G2,edge_match=em,node_match=nm)\n# True"
        }
    },
    {
        "Section ID": "ego_graph",
        "Description": [
            "Returns induced subgraph of neighbors centered at node n within\na given radius."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX Graph or DiGraph",
                "n : node": "A single node",
                "radius : number, optional": "Include all neighbors of distance<=radius from n.",
                "center : bool, optional": "If False, do not include center node in graph",
                "undirected : bool, optional": "If True use both in- and out-neighbors of directed graphs.",
                "distance : key, optional": "Use specified edge data key as distance.  For example, setting\ndistance=\u2019weight\u2019 will use the edge weight to measure the\ndistance from the node n."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For directed graphs D this produces the \u201cout\u201d neighborhood\nor successors.  If you want the neighborhood of predecessors\nfirst reverse the graph with D.reverse().  If you want both\ndirections use the keyword argument undirected=True. Node, edge, and graph attributes are copied to the returned subgraph."
        }
    },
    {
        "Section ID": "greedy_modularity_communities",
        "Description": [
            "Find communities in G using greedy modularity maximization.",
            "This function uses Clauset-Newman-Moore greedy modularity maximization [2] to find the community partition with the largest modularity.",
            "Greedy modularity maximization begins with each node in its own community\nand repeatedly joins the pair of communities that lead to the largest\nmodularity until no further increase in modularity is possible (a maximum).\nTwo keyword arguments adjust the stopping condition. cutoff is a lower\nlimit on the number of communities so you can stop the process before\nreaching a maximum (used to save computation time). best_n is an upper\nlimit on the number of communities so you can make the process continue\nuntil at most n communities remain even if the maximum modularity occurs\nfor more. To obtain exactly n communities, set both cutoff and best_n to n.",
            "This function maximizes the generalized modularity, where resolution is the resolution parameter, often expressed as \\(\\gamma\\) .\nSee modularity() ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "weight : string or None, optional (default=None)": "The name of an edge attribute that holds the numerical value used\nas a weight.  If None, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node.",
                "resolution : float, optional (default=1)": "If resolution is less than 1, modularity favors larger communities.\nGreater than 1 favors smaller communities.",
                "cutoff : int, optional (default=1)": "A minimum number of communities below which the merging process stops.\nThe process stops at this number of communities even if modularity\nis not maximized. The goal is to let the user stop the process early.\nThe process stops before the cutoff if it finds a maximum of modularity.",
                "best_n : int or None, optional (default=None)": "A maximum number of communities above which the merging process will\nnot stop. This forces community merging to continue after modularity\nstarts to decrease untilbest_ncommunities remain.\nIfNone, don\u2019t force it to continue beyond a maximum."
            },
            "Returns:": {
                "communities: list": "A list of frozensets of nodes, one for each community.\nSorted by length with largest communities first."
            },
            "Raises:": {
                "ValueError : If thecutofforbest_nvalue is not in the range": "[1,G.number_of_nodes()], or ifbest_n<cutoff."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Newman, M. E. J. \u201cNetworks: An Introduction\u201d, page 224\nOxford University Press 2011.  [2]Clauset, A., Newman, M. E., & Moore, C.\n\u201cFinding community structure in very large networks.\u201d\nPhysical Review E 70(6), 2004.  [3]Reichardt and Bornholdt \u201cStatistical Mechanics of Community\nDetection\u201d Phys. Rev. E74, 2006.  [4]Newman, M. E. J.\u201dAnalysis of weighted networks\u201d\nPhysical Review E 70(5 Pt 2):056131, 2004.",
            "Examples": "G=nx.karate_club_graph()\nc=nx.community.greedy_modularity_communities(G)\nsorted(c[0])\n# [8, 14, 15, 18, 20, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33]"
        }
    },
    {
        "Section ID": "neighbors",
        "Description": [
            "Returns an iterator over all neighbors of node n.",
            "This function wraps the G.neighbors function."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "random_weighted_sample",
        "Description": [
            "Returns k items without replacement from a weighted sample.",
            "The input is a dictionary of items with weights as values."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "strategy_independent_set",
        "Description": [
            "Uses a greedy independent set removal strategy to determine the\ncolors.",
            "This function updates colors  in-place and return None ,\nunlike the other strategy functions in this module.",
            "This algorithm repeatedly finds and removes a maximal independent\nset, assigning each node in the set an unused color.",
            "G is a NetworkX graph.",
            "This strategy is related to strategy_smallest_last() : in that\nstrategy, an independent set of size one is chosen at each step\ninstead of a maximal independent set."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "is_chordal",
        "Description": [
            "Checks whether G is a chordal graph.",
            "A graph is chordal if every cycle of length at least 4 has a chord\n(an edge joining two nodes not adjacent in the cycle)."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph."
            },
            "Returns:": {
                "chordal : bool": "True if G is a chordal graph and False otherwise."
            },
            "Raises:": {
                "NetworkXNotImplemented": "The algorithm does not support DiGraph, MultiGraph and MultiDiGraph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The routine tries to go through every node following maximum cardinality\nsearch. It returns False when it finds that the separator for any node\nis not a clique.  Based on the algorithms in [1] . Self loops are ignored.",
            "References": "[1]R. E. Tarjan and M. Yannakakis, Simple linear-time algorithms\nto test chordality of graphs, test acyclicity of hypergraphs, and\nselectively reduce acyclic hypergraphs, SIAM J. Comput., 13 (1984),\npp. 566\u2013579.",
            "Examples": "e=[\n(1,2),\n(1,3),\n(2,3),\n(2,4),\n(3,4),\n(3,5),\n(3,6),\n(4,5),\n(4,6),\n(5,6),\n]\nG=nx.Graph(e)\nnx.is_chordal(G)\n# True"
        }
    },
    {
        "Section ID": "approximate_current_flow_betweenness_centrality",
        "Description": [
            "Compute the approximate current-flow betweenness centrality for nodes.",
            "Approximates the current-flow betweenness centrality within absolute\nerror of epsilon with high probability [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "normalized : bool, optional (default=True)": "If True the betweenness values are normalized by 2/[(n-1)(n-2)] where\nn is the number of nodes in G.",
                "weight : string or None, optional (default=None)": "Key for edge data used as the edge weight.\nIf None, then use 1 as each edge weight.\nThe weight reflects the capacity or the strength of the\nedge.",
                "dtype : data type (float)": "Default data type for internal matrices.\nSet to np.float32 for lower memory consumption.",
                "solver : string (default=\u2019full\u2019)": "Type of linear solver to use for computing the flow matrix.\nOptions are \u201cfull\u201d (uses most memory), \u201clu\u201d (recommended), and\n\u201ccg\u201d (uses least memory).",
                "epsilon: float": "Absolute error tolerance.",
                "kmax: int": "Maximum number of sample node pairs to use for approximation.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of nodes with betweenness centrality as the value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The running time is \\(O((1/\\epsilon^2)m{\\sqrt k} \\log n)\\) and the space required is \\(O(m)\\) for \\(n\\) nodes and \\(m\\) edges. If the edges have a \u2018weight\u2019 attribute they will be used as\nweights in this algorithm.  Unspecified weights are set to 1.",
            "References": "[1]Ulrik Brandes and Daniel Fleischer:\nCentrality Measures Based on Current Flow.\nProc. 22nd Symp. Theoretical Aspects of Computer Science (STACS \u201805).\nLNCS 3404, pp. 533-544. Springer-Verlag, 2005.https://doi.org/10.1007/978-3-540-31856-9_44"
        }
    },
    {
        "Section ID": "is_bipartite",
        "Description": [
            "Returns True if graph G is bipartite, False if not."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "fromnetworkx.algorithmsimportbipartite\nG=nx.path_graph(4)\nprint(bipartite.is_bipartite(G))\n# True"
        }
    },
    {
        "Section ID": "kl_connected_subgraph",
        "Description": [
            "Returns the maximum locally (k,l) -connected subgraph of G .",
            "A graph is locally (k,l) -connected if for each edge (u,v) in the\ngraph there are at least l edge-disjoint paths of length at most k joining u to v ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "The graph in which to find a maximum locally(k,l)-connected\nsubgraph.",
                "k : integer": "The maximum length of paths to consider. A higher number means a looser\nconnectivity requirement.",
                "l : integer": "The number of edge-disjoint paths. A higher number means a stricter\nconnectivity requirement.",
                "low_memory : bool": "If this is True, this function uses an algorithm that uses slightly\nmore time but less memory.",
                "same_as_graph : bool": "If True then return a tuple of the form(H,is_same),\nwhereHis the maximum locally(k,l)-connected subgraph andis_sameis a Boolean representing whetherGis locally(k,l)-connected (and hence, whetherHis simply a copy of the input\ngraphG)."
            },
            "Returns:": {
                "NetworkX graph or two-tuple": "Ifsame_as_graphis True, then this function returns a\ntwo-tuple as described above. Otherwise, it returns only the maximum\nlocally(k,l)-connected subgraph."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Chung, Fan and Linyuan Lu. \u201cThe Small World Phenomenon in Hybrid\nPower Law Graphs.\u201dComplex Networks. Springer Berlin Heidelberg,\n2004. 89\u2013104."
        }
    },
    {
        "Section ID": "house_x_graph",
        "Description": [
            "Returns the House graph with a cross inside the house square.",
            "The House X-graph is the House graph plus the two edges connecting diagonally\nopposite vertices of the square base. It is also one of the two graphs\nobtained by removing two edges from the pentatope graph [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : networkx Graph": "House graph with diagonal vertices connected"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://mathworld.wolfram.com/HouseGraph.html"
        }
    },
    {
        "Section ID": "edge_betweenness_centrality_subset",
        "Description": [
            "Compute betweenness centrality for edges for a subset of nodes.",
            "where \\(S\\) is the set of sources, \\(T\\) is the set of targets, \\(\\sigma(s, t)\\) is the number of shortest \\((s, t)\\) -paths,\nand \\(\\sigma(s, t|e)\\) is the number of those paths\npassing through edge \\(e\\)  [2] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph.",
                "sources: list of nodes": "Nodes to use as sources for shortest paths in betweenness",
                "targets: list of nodes": "Nodes to use as targets for shortest paths in betweenness",
                "normalized : bool, optional": "If True the betweenness values are normalized by2/(n(n-1))for graphs, and1/(n(n-1))for directed graphs wherenis the number of nodes in G.",
                "weight : None or string, optional (default=None)": "If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight.\nWeights are used to calculate weighted shortest paths, so they are\ninterpreted as distances."
            },
            "Returns:": {
                "edges : dictionary": "Dictionary of edges with Betweenness centrality as the value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The basic algorithm is from [1] . For weighted graphs the edge weights must be greater than zero.\nZero edge weights can produce an infinite number of equal length\npaths between pairs of nodes. The normalization might seem a little strange but it is the same\nas in edge_betweenness_centrality() and is designed to make\nedge_betweenness_centrality(G) be the same as\nedge_betweenness_centrality_subset(G,sources=G.nodes(),targets=G.nodes()).",
            "References": "[1]Ulrik Brandes, A Faster Algorithm for Betweenness Centrality.\nJournal of Mathematical Sociology 25(2):163-177, 2001.https://doi.org/10.1080/0022250X.2001.9990249  [2]Ulrik Brandes: On Variants of Shortest-Path Betweenness\nCentrality and their Generic Computation.\nSocial Networks 30(2):136-145, 2008.https://doi.org/10.1016/j.socnet.2007.11.001"
        }
    },
    {
        "Section ID": "read_dot",
        "Description": [
            "Returns a NetworkX MultiGraph or MultiDiGraph from the\ndot file with the passed path.",
            "If this file contains multiple graphs, only the first such graph is\nreturned. All graphs _except_ the first are silently ignored."
        ],
        "Field List": {
            "Parameters:": {
                "path : str or file": "Filename or file handle."
            },
            "Returns:": {
                "G : MultiGraph or MultiDiGraph": "AMultiGraphorMultiDiGraph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Use G=nx.Graph(nx.nx_pydot.read_dot(path)) to return a Graph instead of a MultiGraph ."
        }
    },
    {
        "Section ID": "global_efficiency",
        "Description": [
            "Returns the average global efficiency of the graph.",
            "The efficiency of a pair of nodes in a graph is the multiplicative\ninverse of the shortest path distance between the nodes. The average\nglobal efficiency of a graph is the average efficiency of all pairs of\nnodes [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : networkx.Graph": "An undirected graph for which to compute the average global efficiency."
            },
            "Returns:": {
                "float": "The average global efficiency of the graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weights are ignored when computing the shortest path distances.",
            "References": "[1]Latora, Vito, and Massimo Marchiori.\n\u201cEfficient behavior of small-world networks.\u201dPhysical Review Letters87.19 (2001): 198701.\n<https://doi.org/10.1103/PhysRevLett.87.198701>",
            "Examples": "G=nx.Graph([(0,1),(0,2),(0,3),(1,2),(1,3)])\nround(nx.global_efficiency(G),12)\n# 0.916666666667"
        }
    },
    {
        "Section ID": "edmonds_karp",
        "Description": [
            "Find a maximum single-commodity flow using the Edmonds-Karp algorithm.",
            "This function returns the residual network resulting after computing\nthe maximum flow. See below for details about the conventions\nNetworkX uses for defining residual networks.",
            "This algorithm has a running time of \\(O(n m^2)\\) for \\(n\\) nodes and \\(m\\) edges."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Edges of the graph are expected to have an attribute called\n\u2018capacity\u2019. If this attribute is not present, the edge is\nconsidered to have infinite capacity.",
                "s : node": "Source node for the flow.",
                "t : node": "Sink node for the flow.",
                "capacity : string": "Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: \u2018capacity\u2019.",
                "residual : NetworkX graph": "Residual network on which the algorithm is to be executed. If None, a\nnew residual network is created. Default value: None.",
                "value_only : bool": "If True compute only the value of the maximum flow. This parameter\nwill be ignored by this algorithm because it is not applicable.",
                "cutoff : integer, float": "If specified, the algorithm will terminate when the flow value reaches\nor exceeds the cutoff. In this case, it may be unable to immediately\ndetermine a minimum cut. Default value: None."
            },
            "Returns:": {
                "R : NetworkX DiGraph": "Residual network after computing the maximum flow."
            },
            "Raises:": {
                "NetworkXError": "The algorithm does not support MultiGraph and MultiDiGraph. If\nthe input graph is an instance of one of these two classes, a\nNetworkXError is raised.",
                "NetworkXUnbounded": "If the graph has a path of infinite capacity, the value of a\nfeasible flow on the graph is unbounded above and the function\nraises a NetworkXUnbounded."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The residual network R from an input graph G has the\nsame nodes as G . R is a DiGraph that contains a pair\nof edges (u,v) and (v,u) iff (u,v) is not a\nself-loop, and at least one of (u,v) and (v,u) exists\nin G . For each edge (u,v) in R , R[u][v]['capacity'] is equal to the capacity of (u,v) in G if it exists\nin G or zero otherwise. If the capacity is infinite, R[u][v]['capacity'] will have a high arbitrary finite value\nthat does not affect the solution of the problem. This value is stored in R.graph['inf'] . For each edge (u,v) in R , R[u][v]['flow'] represents the flow function of (u,v) and\nsatisfies R[u][v]['flow']==-R[v][u]['flow'] . The flow value, defined as the total flow into t , the sink, is\nstored in R.graph['flow_value'] . If cutoff is not\nspecified, reachability to t using only edges (u,v) such\nthat R[u][v]['flow']<R[u][v]['capacity'] induces a minimum s - t cut.",
            "Examples": "fromnetworkx.algorithms.flowimportedmonds_karp\nThe functions that implement flow algorithms and output a residual\nnetwork, such as this one, are not imported to the base NetworkX\nnamespace, so you have to explicitly import them from the flow package.\nG=nx.DiGraph()\nG.add_edge(\"x\",\"a\",capacity=3.0)\nG.add_edge(\"x\",\"b\",capacity=1.0)\nG.add_edge(\"a\",\"c\",capacity=3.0)\nG.add_edge(\"b\",\"c\",capacity=5.0)\nG.add_edge(\"b\",\"d\",capacity=4.0)\nG.add_edge(\"d\",\"e\",capacity=2.0)\nG.add_edge(\"c\",\"y\",capacity=2.0)\nG.add_edge(\"e\",\"y\",capacity=3.0)\nR=edmonds_karp(G,\"x\",\"y\")\nflow_value=nx.maximum_flow_value(G,\"x\",\"y\")\nflow_value\n# 3.0\nflow_value==R.graph[\"flow_value\"]\n# True"
        }
    },
    {
        "Section ID": "gnm_random_graph",
        "Description": [
            "Returns a \\(G_{n,m}\\) random graph.",
            "In the \\(G_{n,m}\\) model, a graph is chosen uniformly at random from the set\nof all graphs with \\(n\\) nodes and \\(m\\) edges.",
            "This algorithm should be faster than dense_gnm_random_graph() for\nsparse graphs."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes.",
                "m : int": "The number of edges.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "directed : bool, optional (default=False)": "If True return a directed graph"
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "bridges",
        "Description": [
            "Generate all bridges in a graph.",
            "A bridge in a graph is an edge whose removal causes the number of\nconnected components of the graph to increase.  Equivalently, a bridge is an\nedge that does not belong to any cycle. Bridges are also known as cut-edges,\nisthmuses, or cut arcs."
        ],
        "Field List": {
            "Parameters:": {
                "G : undirected graph": "",
                "root : node (optional)": "A node in the graphG. If specified, only the bridges in the\nconnected component containing this node will be returned."
            },
            "Yields:": {
                "e : edge": "An edge in the graph whose removal disconnects the graph (or\ncauses the number of connected components to increase)."
            },
            "Raises:": {
                "NodeNotFound": "Ifrootis not in the graphG.",
                "NetworkXNotImplemented": "IfGis a directed graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This is an implementation of the algorithm described in [1] .  An edge is a\nbridge if and only if it is not contained in any chain. Chains are found\nusing the networkx.chain_decomposition() function. The algorithm described in [1] requires a simple graph. If the provided\ngraph is a multigraph, we convert it to a simple graph and verify that any\nbridges discovered by the chain decomposition algorithm are not multi-edges. Ignoring polylogarithmic factors, the worst-case time complexity is the\nsame as the networkx.chain_decomposition() function, \\(O(m + n)\\) , where \\(n\\) is the number of nodes in the graph and \\(m\\) is\nthe number of edges.",
            "References": "[1](1,2)https://en.wikipedia.org/wiki/Bridge_%28graph_theory%29#Bridge-Finding_with_Chain_Decompositions",
            "Examples": "The barbell graph with parameter zero has a single bridge:\nG=nx.barbell_graph(10,0)\nlist(nx.bridges(G))\n# [(9, 10)]"
        }
    },
    {
        "Section ID": "edges_equal",
        "Description": [
            "Check if edges are equal.",
            "Equality here means equal as Python objects.\nEdge data must match if included.\nThe order of the edges is not relevant."
        ],
        "Field List": {
            "Parameters:": {
                "edges1, edges2 : iterables of with u, v nodes as": "edge tuples (u, v), or\nedge tuples with data dicts (u, v, d), or\nedge tuples with keys and data dicts (u, v, k, d)"
            },
            "Returns:": {
                "bool": "True if edges are equal, False otherwise."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "closeness_vitality",
        "Description": [
            "Returns the closeness vitality for nodes in the graph.",
            "The closeness vitality of a node, defined in Section 3.6.2 of [1],\nis the change in the sum of distances between all node pairs when\nexcluding that node."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A strongly-connected graph.",
                "weight : string": "The name of the edge attribute used as weight. This is passed\ndirectly to thewiener_index()function.",
                "node : object": "If specified, only the closeness vitality for this node will be\nreturned. Otherwise, a dictionary mapping each node to its\ncloseness vitality will be returned."
            },
            "Returns:": {
                "dictionary or float": "Ifnodeis None, this function returns a dictionary\nwith nodes as keys and closeness vitality as the\nvalue. Otherwise, it returns only the closeness vitality for the\nspecifiednode.The closeness vitality of a node may be negative infinity if\nremoving that node would disconnect the graph."
            },
            "Other Parameters:": {
                "wiener_index : number": "If you have already computed the Wiener index of the graphG, you can provide that value here. Otherwise, it will be\ncomputed for you."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Ulrik Brandes, Thomas Erlebach (eds.).Network Analysis: Methodological Foundations.\nSpringer, 2005.\n<http://books.google.com/books?id=TTNhSm7HYrIC>",
            "Examples": "G=nx.cycle_graph(3)\nnx.closeness_vitality(G)\n# {0: 2.0, 1: 2.0, 2: 2.0}"
        }
    },
    {
        "Section ID": "floyd_warshall",
        "Description": [
            "Find all-pairs shortest path lengths using Floyd\u2019s algorithm."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "weight: string, optional (default= \u2018weight\u2019)": "Edge data key corresponding to the edge weight."
            },
            "Returns:": {
                "distance : dict": "A dictionary,  keyed by source and target, of shortest paths distances\nbetween nodes."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Floyd\u2019s algorithm is appropriate for finding shortest paths\nin dense graphs or graphs with negative weights when Dijkstra\u2019s algorithm\nfails.  This algorithm can still fail if there are negative cycles.\nIt has running time \\(O(n^3)\\) with running space of \\(O(n^2)\\) .",
            "Examples": "G=nx.DiGraph()\nG.add_weighted_edges_from([(0,1,5),(1,2,2),(2,3,-3),(1,3,10),(3,2,8)])\nfw=nx.floyd_warshall(G,weight=\"weight\")\nresults={a:dict(b)fora,binfw.items()}\nprint(results)\n# {0: {0: 0, 1: 5, 2: 7, 3: 4}, 1: {1: 0, 2: 2, 3: -1, 0: inf}, 2: {2: 0, 3: -3, 0: inf, 1: inf}, 3: {3: 0, 2: 8, 0: inf, 1: inf}}"
        }
    },
    {
        "Section ID": "reverse_havel_hakimi_graph",
        "Description": [
            "Returns a bipartite graph from two given degree sequences using a\nHavel-Hakimi style construction.",
            "The graph is composed of two partitions. Set A has nodes 0 to\n(len(aseq) - 1) and set B has nodes len(aseq) to (len(bseq) - 1).\nNodes from set A are connected to nodes in the set B by connecting\nthe highest degree nodes in set A to the lowest degree nodes in\nset B until all stubs are connected."
        ],
        "Field List": {
            "Parameters:": {
                "aseq : list": "Degree sequence for node set A.",
                "bseq : list": "Degree sequence for node set B.",
                "create_using : NetworkX graph instance, optional": "Return graph of this type."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The sum of the two sequences must be equal: sum(aseq)=sum(bseq)\nIf no graph type is specified use MultiGraph with parallel edges.\nIf you want a graph with no parallel edges use create_using=Graph()\nbut then the resulting degree sequences might not be exact. The nodes are assigned the attribute \u2018bipartite\u2019 with the value 0 or 1\nto indicate which bipartite set the node belongs to. This function is not imported in the main namespace.\nTo use it use nx.bipartite.reverse_havel_hakimi_graph"
        }
    },
    {
        "Section ID": "FilterAtlas",
        "Description": [
            "A read-only Mapping of Mappings with filtering criteria for nodes.",
            "It is a view into a dict-of-dict data structure, and it selects only\nnodes that meet the criteria defined by NODE_OK ."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "graph_atlas_g",
        "Description": [
            "Returns the list of all graphs with up to seven nodes named in the\nGraph Atlas.",
            "The graphs are listed in increasing order by",
            "in that order, with three exceptions as described in the Notes section below. This causes the list to correspond with the index of\nthe graphs in the Graph Atlas [atlas] , with the first graph, G[0] , being the null graph."
        ],
        "Field List": {
            "Returns:": {
                "list": "A list ofGraphobjects, the one at indexicorresponding to the graphiin the Graph Atlas."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This function may be expensive in both time and space, since it\nreads a large file sequentially in order to populate the list. Although the NetworkX atlas functions match the order of graphs\ngiven in the \u201cAtlas of Graphs\u201d book, there are (at least) three\nerrors in the ordering described in the book. The following three\npairs of nodes violate the lexicographically nondecreasing sorted\ndegree sequence rule:",
            "References": "[atlas]Ronald C. Read and Robin J. Wilson,An Atlas of Graphs.\nOxford University Press, 1998."
        }
    },
    {
        "Section ID": "set_node_attributes",
        "Description": [
            "Sets node attributes from a given value or dictionary of values."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "",
                "values : scalar value, dict-like": "What the node attribute should be set to.  Ifvaluesis\nnot a dictionary, then it is treated as a single attribute value\nthat is then applied to every node inG.  This means that if\nyou provide a mutable object, like a list, updates to that object\nwill be reflected in the node attribute for every node.\nThe attribute name will bename.Ifvaluesis a dict or a dict of dict, it should be keyed\nby node to either an attribute value or a dict of attribute key/value\npairs used to update the node\u2019s attributes.",
                "name : string (optional, default=None)": "Name of the node attribute to set if values is a scalar."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "After computing some property of the nodes of a graph, you may want\nto assign a node attribute to store the value of that property for\neach node:\nG=nx.path_graph(3)\nbb=nx.betweenness_centrality(G)\nisinstance(bb,dict)\n# True\nnx.set_node_attributes(G,bb,\"betweenness\")\nG.nodes[1][\"betweenness\"]\n# 1.0\nIf you provide a list as the second argument, updates to the list\nwill be reflected in the node attribute for each node:\nG=nx.path_graph(3)\nlabels=[]\nnx.set_node_attributes(G,labels,\"labels\")\nlabels.append(\"foo\")\nG.nodes[0][\"labels\"]\n# ['foo']\nG.nodes[1][\"labels\"]\n# ['foo']\nG.nodes[2][\"labels\"]\n# ['foo']\nIf you provide a dictionary of dictionaries as the second argument,\nthe outer dictionary is assumed to be keyed by node to an inner\ndictionary of node attributes for that node:\nG=nx.path_graph(3)\nattrs={0:{\"attr1\":20,\"attr2\":\"nothing\"},1:{\"attr2\":3}}\nnx.set_node_attributes(G,attrs)\nG.nodes[0][\"attr1\"]\n# 20\nG.nodes[0][\"attr2\"]\n# 'nothing'\nG.nodes[1][\"attr2\"]\n# 3\nG.nodes[2]\n# {}\nNote that if the dictionary contains nodes that are not inG, the\nvalues are silently ignored:\nG=nx.Graph()\nG.add_node(0)\nnx.set_node_attributes(G,{0:\"red\",1:\"blue\"},name=\"color\")\nG.nodes[0][\"color\"]\n# 'red'\n1inG.nodes\n# False"
        }
    },
    {
        "Section ID": "min_cost_flow",
        "Description": [
            "Returns a minimum cost flow satisfying all demands in digraph G.",
            "G is a digraph with edge costs and capacities and in which nodes\nhave demand, i.e., they want to send or receive some amount of\nflow. A negative demand means that the node wants to send flow, a\npositive demand means that the node want to receive flow. A flow on\nthe digraph G satisfies all demand if the net flow into each node\nis equal to the demand of that node."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "DiGraph on which a minimum cost flow satisfying all demands is\nto be found.",
                "demand : string": "Nodes of the graph G are expected to have an attribute demand\nthat indicates how much flow a node wants to send (negative\ndemand) or receive (positive demand). Note that the sum of the\ndemands should be 0 otherwise the problem in not feasible. If\nthis attribute is not present, a node is considered to have 0\ndemand. Default value: \u2018demand\u2019.",
                "capacity : string": "Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: \u2018capacity\u2019.",
                "weight : string": "Edges of the graph G are expected to have an attribute weight\nthat indicates the cost incurred by sending one unit of flow on\nthat edge. If not present, the weight is considered to be 0.\nDefault value: \u2018weight\u2019."
            },
            "Returns:": {
                "flowDict : dictionary": "Dictionary of dictionaries keyed by nodes such that\nflowDict[u][v] is the flow edge (u, v)."
            },
            "Raises:": {
                "NetworkXError": "This exception is raised if the input graph is not directed or\nnot connected.",
                "NetworkXUnfeasible": "This exception is raised in the following situations:The sum of the demands is not zero. Then, there is no\nflow satisfying all demands.There is no flow satisfying all demand.",
                "NetworkXUnbounded": "This exception is raised if the digraph G has a cycle of\nnegative cost and infinite capacity. Then, the cost of a flow\nsatisfying all demands is unbounded below."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm is not guaranteed to work if edge weights or demands\nare floating point numbers (overflows and roundoff errors can\ncause problems). As a workaround you can use integer numbers by\nmultiplying the relevant edge attributes by a convenient\nconstant factor (eg 100).",
            "Examples": "A simple example of a min cost flow problem.\nG=nx.DiGraph()\nG.add_node(\"a\",demand=-5)\nG.add_node(\"d\",demand=5)\nG.add_edge(\"a\",\"b\",weight=3,capacity=4)\nG.add_edge(\"a\",\"c\",weight=6,capacity=10)\nG.add_edge(\"b\",\"d\",weight=1,capacity=9)\nG.add_edge(\"c\",\"d\",weight=2,capacity=5)\nflowDict=nx.min_cost_flow(G)\nflowDict\n# {'a': {'b': 4, 'c': 1}, 'd': {}, 'b': {'d': 4}, 'c': {'d': 1}}"
        }
    },
    {
        "Section ID": "min_weight_matching",
        "Description": [
            "Computing a minimum-weight maximal matching of G.",
            "Use the maximum-weight algorithm with edge weights subtracted\nfrom the maximum weight of all edges.",
            "A matching is a subset of edges in which no node occurs more than once.\nThe weight of a matching is the sum of the weights of its edges.\nA maximal matching cannot add more edges and still be a matching.\nThe cardinality of a matching is the number of matched edges.",
            "This method replaces the edge weights with 1 plus the maximum edge weight\nminus the original edge weight.",
            "new_weight = (max_weight + 1) - edge_weight",
            "then runs max_weight_matching() with the new weights.\nThe max weight matching with these new weights corresponds\nto the min weight matching using the original weights.\nAdding 1 to the max edge weight keeps all edge weights positive\nand as integers if they started as integers.",
            "You might worry that adding 1 to each weight would make the algorithm\nfavor matchings with more edges. But we use the parameter maxcardinality=True in max_weight_matching to ensure that the\nnumber of edges in the competing matchings are the same and thus\nthe optimum does not change due to changes in the number of edges.",
            "Read the documentation of max_weight_matching for more information."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected graph",
                "weight: string, optional (default=\u2019weight\u2019)": "Edge data key corresponding to the edge weight.\nIf key not found, uses 1 as weight."
            },
            "Returns:": {
                "matching : set": "A minimal weight matching of the graph."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "density",
        "Description": [
            "Returns the density of a graph.",
            "The density for undirected graphs is",
            "and for directed graphs is",
            "where n is the number of nodes and m is the number of edges in G .",
            "Notes",
            "The density is 0 for a graph without edges and 1 for a complete graph.\nThe density of multigraphs can be higher than 1.",
            "Self loops are counted in the total number of edges so graphs with self\nloops can have density higher than 1."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The density is 0 for a graph without edges and 1 for a complete graph.\nThe density of multigraphs can be higher than 1. Self loops are counted in the total number of edges so graphs with self\nloops can have density higher than 1."
        }
    },
    {
        "Section ID": "write_dot",
        "Description": [
            "Write NetworkX graph G to Graphviz dot format on path.",
            "Path can be a string or a file handle."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section_id": "Graph",
        "Section ID": "Graph"
    },
    {
        "Section_id": "Graph",
        "Description": [
            "Base class for undirected graphs.",
            "A Graph stores nodes and edges with optional data, or attributes.",
            "Graphs hold undirected edges.  Self loops are allowed but multiple\n(parallel) edges are not.",
            "Nodes can be arbitrary (hashable) Python objects with optional\nkey/value attributes, except that None is not allowed as a node.",
            "Edges are represented as links between nodes with optional\nkey/value attributes."
        ]
    },
    {
        "Field List > Parameters:": {
            "incoming_graph_data : input graph (optional, default: None)": "Data to initialize graph. If None (default) an empty\ngraph is created.  The data can be any format that is supported\nby the to_networkx_graph() function, currently including edge list,\ndict of dicts, dict of lists, NetworkX graph, 2D NumPy array, SciPy\nsparse matrix, or PyGraphviz graph.",
            "attr : keyword arguments, optional (default= no attributes)": "Attributes to add to graph as key=value pairs."
        },
        "Section_id": "Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Section ID": "__init__"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Path": "networkx.Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Description": [
            "Initialize a graph with edges, name, or graph attributes."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "incoming_graph_data : input graph (optional, default: None)": "Data to initialize graph. If None (default) an empty\ngraph is created.  The data can be an edge list, or any\nNetworkX graph object.  If the corresponding optional Python\npackages are installed the data can also be a 2D NumPy array, a\nSciPy sparse array, or a PyGraphviz graph.",
                "attr : keyword arguments, optional (default= no attributes)": "Attributes to add to graph as key=value pairs."
            },
            "Methods": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG=nx.Graph(name=\"my graph\")\ne=[(1,2),(2,3),(3,4)]# list of edges\nG=nx.Graph(e)\nArbitrary graph attribute pairs (key=value) may be assigned\nG=nx.Graph(e,day=\"Friday\")\nG.graph\n# {'day': 'Friday'}"
        },
        "Section_id": "Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Section ID": "add_node"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Path": "networkx.Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Description": [
            "Add a single node node_for_adding and update node attributes."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "node_for_adding : node": "A node can be any hashable Python object except None.",
                "attr : keyword arguments, optional": "Set or change node attributes using key=value."
            },
            "Methods": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "A hashable object is one that can be used as a key in a Python\ndictionary. This includes strings, numbers, tuples of strings\nand numbers, etc. On many platforms hashable items also include mutables such as\nNetworkX Graphs, though one should be careful that the hash\ndoesn\u2019t change on mutables.",
            "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_node(1)\nG.add_node(\"Hello\")\nK3=nx.Graph([(0,1),(1,2),(2,0)])\nG.add_node(K3)\nG.number_of_nodes()\n# 3\nUse keywords set/change node attributes:\nG.add_node(1,size=10)\nG.add_node(3,weight=0.4,UTM=(\"13S\",382871,3972649))"
        },
        "Section_id": "Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Section ID": "add_nodes_from"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Path": "networkx.Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Description": [
            "Add multiple nodes."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "nodes_for_adding : iterable container": "A container of nodes (list, dict, set, etc.).\nOR\nA container of (node, attribute dict) tuples.\nNode attributes are updated using the attribute dict.",
                "attr : keyword arguments, optional (default= no attributes)": "Update attributes for all nodes in nodes.\nNode attributes specified in nodes as a tuple take\nprecedence over attributes specified via keyword arguments."
            },
            "Methods": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "When adding nodes from an iterator over the graph you are changing,\na RuntimeError can be raised with message: RuntimeError:dictionarychangedsizeduringiteration . This\nhappens when the graph\u2019s underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using list(iterator_of_nodes) , and pass this\nobject to G.add_nodes_from .",
            "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_nodes_from(\"Hello\")\nK3=nx.Graph([(0,1),(1,2),(2,0)])\nG.add_nodes_from(K3)\nsorted(G.nodes(),key=str)\n# [0, 1, 2, 'H', 'e', 'l', 'o']\nUse keywords to update specific node attributes for every node.\nG.add_nodes_from([1,2],size=10)\nG.add_nodes_from([3,4],weight=0.4)\nUse (node, attrdict) tuples to update attributes for specific nodes.\nG.add_nodes_from([(1,dict(size=11)),(2,{\"color\":\"blue\"})])\nG.nodes[1][\"size\"]\n# 11\nH=nx.Graph()\nH.add_nodes_from(G.nodes(data=True))\nH.nodes[1][\"size\"]\n# 11\nEvaluate an iterator over a graph if using it to modify the same graph\nG=nx.Graph([(0,1),(1,2),(3,4)])\n# wrong way - will raise RuntimeError\n# G.add_nodes_from(n + 1 for n in G.nodes)\n# correct way\nG.add_nodes_from(list(n+1forninG.nodes))"
        },
        "Section_id": "Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Section ID": "remove_node"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Path": "networkx.Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Description": [
            "Remove node n.",
            "Removes the node n and all adjacent edges.\nAttempting to remove a nonexistent node will raise an exception."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "n : node": "A node in the graph"
            },
            "Raises:": {
                "NetworkXError": "If n is not in the graph."
            },
            "Methods": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(3)# or DiGraph, MultiGraph, MultiDiGraph, etc\nlist(G.edges)\n# [(0, 1), (1, 2)]\nG.remove_node(1)\nlist(G.edges)\n# []"
        },
        "Section_id": "Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Section ID": "remove_nodes_from"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Path": "networkx.Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Description": [
            "Remove multiple nodes."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "nodes : iterable container": "A container of nodes (list, dict, set, etc.).  If a node\nin the container is not in the graph it is silently\nignored."
            },
            "Methods": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "When removing nodes from an iterator over the graph you are changing,\na RuntimeError will be raised with message: RuntimeError:dictionarychangedsizeduringiteration . This\nhappens when the graph\u2019s underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using list(iterator_of_nodes) , and pass this\nobject to G.remove_nodes_from .",
            "Examples": "G=nx.path_graph(3)# or DiGraph, MultiGraph, MultiDiGraph, etc\ne=list(G.nodes)\ne\n# [0, 1, 2]\nG.remove_nodes_from(e)\nlist(G.nodes)\n# []\nEvaluate an iterator over a graph if using it to modify the same graph\nG=nx.Graph([(0,1),(1,2),(3,4)])\n# this command will fail, as the graph's dict is modified during iteration\n# G.remove_nodes_from(n for n in G.nodes if n < 2)\n# this command will work, since the dictionary underlying graph is not modified\nG.remove_nodes_from(list(nforninG.nodesifn<2))"
        },
        "Section_id": "Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Section ID": "add_edge"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Path": "networkx.Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Description": [
            "Add an edge between u and v.",
            "The nodes u and v will be automatically added if they are\nnot already in the graph.",
            "Edge attributes can be specified with keywords or by directly\naccessing the edge\u2019s attribute dictionary. See examples below."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "u_of_edge, v_of_edge : nodes": "Nodes can be, for example, strings or numbers.\nNodes must be hashable (and not None) Python objects.",
                "attr : keyword arguments, optional": "Edge data (or labels or objects) can be assigned using\nkeyword arguments."
            },
            "Methods": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "Adding an edge that already exists updates the edge data. Many NetworkX algorithms designed for weighted graphs use\nan edge attribute (by default weight ) to hold a numerical value.",
            "Examples": "The following all add the edge e=(1, 2) to graph G:\nG=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\ne=(1,2)\nG.add_edge(1,2)# explicit two-node form\nG.add_edge(*e)# single edge as tuple of two nodes\nG.add_edges_from([(1,2)])# add edges from iterable container\nAssociate data to edges using keywords:\nG.add_edge(1,2,weight=3)\nG.add_edge(1,3,weight=7,capacity=15,length=342.7)\nFor non-string attribute keys, use subscript notation.\nG.add_edge(1,2)\nG[1][2].update({0:5})\nG.edges[1,2].update({0:5})"
        },
        "Section_id": "Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Section ID": "add_edges_from"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Path": "networkx.Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Description": [
            "Add all the edges in ebunch_to_add."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "ebunch_to_add : container of edges": "Each edge given in the container will be added to the\ngraph. The edges must be given as 2-tuples (u, v) or\n3-tuples (u, v, d) where d is a dictionary containing edge data.",
                "attr : keyword arguments, optional": "Edge data (or labels or objects) can be assigned using\nkeyword arguments."
            },
            "Methods": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "Adding the same edge twice has no effect but any edge data\nwill be updated when each duplicate edge is added. Edge attributes specified in an ebunch take precedence over\nattributes specified via keyword arguments. When adding edges from an iterator over the graph you are changing,\na RuntimeError can be raised with message: RuntimeError:dictionarychangedsizeduringiteration . This\nhappens when the graph\u2019s underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using list(iterator_of_edges) , and pass this\nobject to G.add_edges_from .",
            "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_edges_from([(0,1),(1,2)])# using a list of edge tuples\ne=zip(range(0,3),range(1,4))\nG.add_edges_from(e)# Add the path graph 0-1-2-3\nAssociate data to edges\nG.add_edges_from([(1,2),(2,3)],weight=3)\nG.add_edges_from([(3,4),(1,4)],label=\"WN2898\")\nEvaluate an iterator over a graph if using it to modify the same graph\nG=nx.Graph([(1,2),(2,3),(3,4)])\n# Grow graph by one new node, adding edges to all existing nodes.\n# wrong way - will raise RuntimeError\n# G.add_edges_from(((5, n) for n in G.nodes))\n# correct way - note that there will be no self-edge for node 5\nG.add_edges_from(list((5,n)forninG.nodes))"
        },
        "Section_id": "Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Section ID": "add_weighted_edges_from"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Path": "networkx.Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Description": [
            "Add weighted edges in ebunch_to_add with specified weight attr"
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "ebunch_to_add : container of edges": "Each edge given in the list or container will be added\nto the graph. The edges must be given as 3-tuples (u, v, w)\nwhere w is a number.",
                "weight : string, optional (default= \u2018weight\u2019)": "The attribute name for the edge weights to be added.",
                "attr : keyword arguments, optional (default= no attributes)": "Edge attributes to add/update for all edges."
            },
            "Methods": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "Adding the same edge twice for Graph/DiGraph simply updates\nthe edge data. For MultiGraph/MultiDiGraph, duplicate edges\nare stored. When adding edges from an iterator over the graph you are changing,\na RuntimeError can be raised with message: RuntimeError:dictionarychangedsizeduringiteration . This\nhappens when the graph\u2019s underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using list(iterator_of_edges) , and pass this\nobject to G.add_weighted_edges_from .",
            "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_weighted_edges_from([(0,1,3.0),(1,2,7.5)])\nEvaluate an iterator over edges before passing it\nG=nx.Graph([(1,2),(2,3),(3,4)])\nweight=0.1\n# Grow graph by one new node, adding edges to all existing nodes.\n# wrong way - will raise RuntimeError\n# G.add_weighted_edges_from(((5, n, weight) for n in G.nodes))\n# correct way - note that there will be no self-edge for node 5\nG.add_weighted_edges_from(list((5,n,weight)forninG.nodes))"
        },
        "Section_id": "Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Section ID": "remove_edge"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Path": "networkx.Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Description": [
            "Remove the edge between u and v."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "u, v : nodes": "Remove the edge between nodes u and v."
            },
            "Raises:": {
                "NetworkXError": "If there is not an edge between u and v."
            },
            "Methods": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(4)# or DiGraph, etc\nG.remove_edge(0,1)\ne=(1,2)\nG.remove_edge(*e)# unpacks e from an edge tuple\ne=(2,3,{\"weight\":7})# an edge with attribute data\nG.remove_edge(*e[:2])# select first part of edge tuple"
        },
        "Section_id": "Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Section ID": "remove_edges_from"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Path": "networkx.Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Description": [
            "Remove all edges specified in ebunch."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "ebunch: list or container of edge tuples": "Each edge given in the list or container will be removed\nfrom the graph. The edges can be:2-tuples (u, v) edge between u and v.3-tuples (u, v, k) where k is ignored."
            },
            "Methods": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "Will fail silently if an edge in ebunch is not in the graph.",
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nebunch=[(1,2),(2,3)]\nG.remove_edges_from(ebunch)"
        },
        "Section_id": "Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Section ID": "update"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Path": "networkx.Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Description": [
            "Update the graph using nodes/edges/graphs as input.",
            "Like dict.update, this method takes a graph as input, adding the\ngraph\u2019s nodes and edges to this graph. It can also take two inputs:\nedges and nodes. Finally it can take either edges or nodes.\nTo specify only nodes the keyword nodes must be used.",
            "The collections of edges and nodes are treated similarly to\nthe add_edges_from/add_nodes_from methods. When iterated, they\nshould yield 2-tuples (u, v) or 3-tuples (u, v, datadict)."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "edges : Graph object, collection of edges, or None": "The first parameter can be a graph or some edges. If it has\nattributesnodesandedges, then it is taken to be a\nGraph-like object and those attributes are used as collections\nof nodes and edges to be added to the graph.\nIf the first parameter does not have those attributes, it is\ntreated as a collection of edges and added to the graph.\nIf the first argument is None, no edges are added.",
                "nodes : collection of nodes, or None": "The second parameter is treated as a collection of nodes\nto be added to the graph unless it is None.\nIfedgesisNoneandnodesisNonean exception is raised.\nIf the first parameter is a Graph, thennodesis ignored."
            },
            "Methods": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "It you want to update the graph using an adjacency structure\nit is straightforward to obtain the edges/nodes from adjacency.\nThe following examples provide common cases, your adjacency may\nbe slightly different and require tweaks of these examples:",
            "Examples": "G=nx.path_graph(5)\nG.update(nx.complete_graph(range(4,10)))\nfromitertoolsimportcombinations\nedges=(\n(u,v,{\"power\":u*v})\nforu,vincombinations(range(10,20),2)\nifu*v<225\n)\nnodes=[1000]# for singleton, use a container\nG.update(edges,nodes)"
        },
        "Section_id": "Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Section ID": "clear"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Path": "networkx.Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Description": [
            "Remove all nodes and edges from the graph.",
            "This also removes the name, and all graph, node, and edge attributes.",
            "Examples"
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Methods": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.clear()\nlist(G.nodes)\n# []\nlist(G.edges)\n# []"
        },
        "Section_id": "Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Section ID": "clear_edges"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Path": "networkx.Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Description": [
            "Remove all edges from the graph without altering nodes.",
            "Examples"
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Methods": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.clear_edges()\nlist(G.nodes)\n# [0, 1, 2, 3]\nlist(G.edges)\n# []"
        },
        "Section_id": "Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Section ID": "nodes"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Path": "networkx.Graph"
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "data : string or bool, optional (default=False)": "The node attribute returned in 2-tuple (n, ddict[data]).\nIf True, return entire node attribute dict as (n, ddict).\nIf False, return just the nodes n.",
                "default : value, optional (default=None)": "Value used for nodes that don\u2019t have the requested attribute.\nOnly relevant if data is not True or False."
            },
            "Returns:": {
                "NodeView": "Allows set-like operations over the nodes as well as node\nattribute dict lookup and calling to get a NodeDataView.\nA NodeDataView iterates over(n,data)and has no set operations.\nA NodeView iterates overnand includes set operations.When called, if data is False, an iterator over nodes.\nOtherwise an iterator of 2-tuples (node, attribute value)\nwhere the attribute is specified indata.\nIf data is True then the attribute becomes the\nentire data dictionary."
            },
            "Methods": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "If your node data is not needed, it is simpler and equivalent\nto use the expression forninG , or list(G) .",
            "Examples": "There are two simple ways of getting a list of all nodes in the graph:\nG=nx.path_graph(3)\nlist(G.nodes)\n# [0, 1, 2]\nlist(G)\n# [0, 1, 2]\nTo get the node data along with the nodes:\nG.add_node(1,time=\"5pm\")\nG.nodes[0][\"foo\"]=\"bar\"\nlist(G.nodes(data=True))\n# [(0, {'foo': 'bar'}), (1, {'time': '5pm'}), (2, {})]\nlist(G.nodes.data())\n# [(0, {'foo': 'bar'}), (1, {'time': '5pm'}), (2, {})]\nlist(G.nodes(data=\"foo\"))\n# [(0, 'bar'), (1, None), (2, None)]\nlist(G.nodes.data(\"foo\"))\n# [(0, 'bar'), (1, None), (2, None)]\nlist(G.nodes(data=\"time\"))\n# [(0, None), (1, '5pm'), (2, None)]\nlist(G.nodes.data(\"time\"))\n# [(0, None), (1, '5pm'), (2, None)]\nlist(G.nodes(data=\"time\",default=\"Not Available\"))\n# [(0, 'Not Available'), (1, '5pm'), (2, 'Not Available')]\nlist(G.nodes.data(\"time\",default=\"Not Available\"))\n# [(0, 'Not Available'), (1, '5pm'), (2, 'Not Available')]\nIf some of your nodes have an attribute and the rest are assumed\nto have a default attribute value you can create a dictionary\nfrom node/attribute pairs using thedefaultkeyword argument\nto guarantee the value is never None:\nG=nx.Graph()\nG.add_node(0)\nG.add_node(1,weight=2)\nG.add_node(2,weight=3)\ndict(G.nodes(data=\"weight\",default=1))\n# {0: 1, 1: 2, 2: 3}"
        },
        "Section_id": "Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Section ID": "__iter__"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Path": "networkx.Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Description": [
            "Iterate over the nodes. Use: \u2018for n in G\u2019."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Returns:": {
                "niter : iterator": "An iterator over all nodes in the graph."
            },
            "Methods": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\n[nforninG]\n# [0, 1, 2, 3]\nlist(G)\n# [0, 1, 2, 3]"
        },
        "Section_id": "Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Section ID": "has_node"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Path": "networkx.Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Description": [
            "Returns True if the graph contains the node n.",
            "Identical to ninG"
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "n : node": ""
            },
            "Methods": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(3)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.has_node(0)\n# True\nIt is more readable and simpler to use\n0inG\n# True"
        },
        "Section_id": "Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Section ID": "__contains__"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Path": "networkx.Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Description": [
            "Returns True if n is a node, False otherwise. Use: \u2018n in G\u2019.",
            "Examples"
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Methods": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\n1inG\n# True"
        },
        "Section_id": "Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Section ID": "edges"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Path": "networkx.Graph"
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "nbunch : single node, container, or all nodes (default= all nodes)": "The view will only report edges from these nodes.",
                "data : string or bool, optional (default=False)": "The edge attribute returned in 3-tuple (u, v, ddict[data]).\nIf True, return edge attribute dict in 3-tuple (u, v, ddict).\nIf False, return 2-tuple (u, v).",
                "default : value, optional (default=None)": "Value used for edges that don\u2019t have the requested attribute.\nOnly relevant if data is not True or False."
            },
            "Returns:": {
                "edges : EdgeView": "A view of edge attributes, usually it iterates over (u, v)\nor (u, v, d) tuples of edges, but can also be used for\nattribute lookup asedges[u,v]['foo']."
            },
            "Methods": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "Nodes in nbunch that are not in the graph will be (quietly) ignored.\nFor directed graphs this returns the out-edges.",
            "Examples": "G=nx.path_graph(3)# or MultiGraph, etc\nG.add_edge(2,3,weight=5)\n[eforeinG.edges]\n# [(0, 1), (1, 2), (2, 3)]\nG.edges.data()# default data is {} (empty dict)\n# EdgeDataView([(0, 1, {}), (1, 2, {}), (2, 3, {'weight': 5})])\nG.edges.data(\"weight\",default=1)\n# EdgeDataView([(0, 1, 1), (1, 2, 1), (2, 3, 5)])\nG.edges([0,3])# only edges from these nodes\n# EdgeDataView([(0, 1), (3, 2)])\nG.edges(0)# only edges from node 0\n# EdgeDataView([(0, 1)])"
        },
        "Section_id": "Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Section ID": "has_edge"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Path": "networkx.Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Description": [
            "Returns True if the edge (u, v) is in the graph.",
            "This is the same as vinG[u] without KeyError exceptions."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "u, v : nodes": "Nodes can be, for example, strings or numbers.\nNodes must be hashable (and not None) Python objects."
            },
            "Returns:": {
                "edge_ind : bool": "True if edge is in the graph, False otherwise."
            },
            "Methods": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.has_edge(0,1)# using two nodes\n# True\ne=(0,1)\nG.has_edge(*e)#  e is a 2-tuple (u, v)\n# True\ne=(0,1,{\"weight\":7})\nG.has_edge(*e[:2])# e is a 3-tuple (u, v, data_dictionary)\n# True\nThe following syntax are equivalent:\nG.has_edge(0,1)\n# True\n1inG[0]# though this gives KeyError if 0 not in G\n# True"
        },
        "Section_id": "Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Section ID": "get_edge_data"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Path": "networkx.Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Description": [
            "Returns the attribute dictionary associated with edge (u, v).",
            "This is identical to G[u][v] except the default is returned\ninstead of an exception if the edge doesn\u2019t exist."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "u, v : nodes": "",
                "default:  any Python object (default=None)": "Value to return if the edge (u, v) is not found."
            },
            "Returns:": {
                "edge_dict : dictionary": "The edge attribute dictionary."
            },
            "Methods": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG[0][1]\n# {}\nWarning: Assigning toG[u][v]is not permitted.\nBut it is safe to assign attributesG[u][v]['foo']\nG[0][1][\"weight\"]=7\nG[0][1][\"weight\"]\n# 7\nG[1][0][\"weight\"]\n# 7\nG=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.get_edge_data(0,1)# default edge data is {}\n# {}\ne=(0,1)\nG.get_edge_data(*e)# tuple form\n# {}\nG.get_edge_data(\"a\",\"b\",default=0)# edge not in graph, return 0\n# 0"
        },
        "Section_id": "Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Section ID": "neighbors"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Path": "networkx.Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Description": [
            "Returns an iterator over all neighbors of node n.",
            "This is identical to iter(G[n])"
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "n : node": "A node in the graph"
            },
            "Returns:": {
                "neighbors : iterator": "An iterator over all neighbors of node n"
            },
            "Raises:": {
                "NetworkXError": "If the node n is not in the graph."
            },
            "Methods": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "Alternate ways to access the neighbors are G.adj[n] or G[n] :",
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\n[nforninG.neighbors(0)]\n# [1]"
        },
        "Section_id": "Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Section ID": "adj"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Path": "networkx.Graph"
    },
    {
        "Field List > Methods > Field List": {
            "Methods": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Rubrics": {},
        "Section_id": "Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Section ID": "__getitem__"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Path": "networkx.Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Description": [
            "Returns a dict of neighbors of node n.  Use: \u2018G[n]\u2019."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "n : node": "A node in the graph."
            },
            "Returns:": {
                "adj_dict : dictionary": "The adjacency dictionary for nodes connected to n."
            },
            "Methods": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "G[n] is the same as G.adj[n] and similar to G.neighbors(n)\n(which is an iterator over G.adj[n])",
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG[0]\n# AtlasView({1: {}})"
        },
        "Section_id": "Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Section ID": "adjacency"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Path": "networkx.Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Description": [
            "Returns an iterator over (node, adjacency dict) tuples for all nodes.",
            "For directed graphs, only outgoing neighbors/adjacencies are included."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Returns:": {
                "adj_iter : iterator": "An iterator over (node, adjacency dictionary) for all nodes in\nthe graph."
            },
            "Methods": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\n[(n,nbrdict)forn,nbrdictinG.adjacency()]\n# [(0, {1: {}}), (1, {0: {}, 2: {}}), (2, {1: {}, 3: {}}), (3, {2: {}})]"
        },
        "Section_id": "Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Section ID": "nbunch_iter"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Path": "networkx.Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Description": [
            "Returns an iterator over nodes contained in nbunch that are\nalso in the graph.",
            "The nodes in nbunch are checked for membership in the graph\nand if not are silently ignored."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "nbunch : single node, container, or all nodes (default= all nodes)": "The view will only report edges incident to these nodes."
            },
            "Returns:": {
                "niter : iterator": "An iterator over nodes in nbunch that are also in the graph.\nIf nbunch is None, iterate over all nodes in the graph."
            },
            "Raises:": {
                "NetworkXError": "If nbunch is not a node or sequence of nodes.\nIf a node in nbunch is not hashable."
            },
            "Methods": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "When nbunch is an iterator, the returned iterator yields values\ndirectly from nbunch, becoming exhausted when nbunch is exhausted. To test whether nbunch is a single node, one can use\n\u201cif nbunch in self:\u201d, even after processing with this routine. If nbunch is not a node or a (possibly empty) sequence/iterator\nor None, a NetworkXError is raised.  Also, if any object in\nnbunch is not hashable, a NetworkXError is raised."
        },
        "Section_id": "Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Section ID": "order"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Path": "networkx.Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Description": [
            "Returns the number of nodes in the graph."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Returns:": {
                "nnodes : int": "The number of nodes in the graph."
            },
            "Methods": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(3)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.order()\n# 3"
        },
        "Section_id": "Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Section ID": "number_of_nodes"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Path": "networkx.Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Description": [
            "Returns the number of nodes in the graph."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Returns:": {
                "nnodes : int": "The number of nodes in the graph."
            },
            "Methods": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(3)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.number_of_nodes()\n# 3"
        },
        "Section_id": "Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Section ID": "__len__"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Path": "networkx.Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Description": [
            "Returns the number of nodes in the graph. Use: \u2018len(G)\u2019."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Returns:": {
                "nnodes : int": "The number of nodes in the graph."
            },
            "Methods": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nlen(G)\n# 4"
        },
        "Section_id": "Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Section ID": "degree"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Path": "networkx.Graph"
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "nbunch : single node, container, or all nodes (default= all nodes)": "The view will only report edges incident to these nodes.",
                "weight : string or None, optional (default=None)": "The name of an edge attribute that holds the numerical value used\nas a weight.  If None, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node."
            },
            "Returns:": {
                "DegreeView or int": "If multiple nodes are requested (the default), returns aDegreeViewmapping nodes to their degree.\nIf a single node is requested, returns the degree of the node as an integer."
            },
            "Methods": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.degree[0]# node 0 has degree 1\n# 1\nlist(G.degree([0,1,2]))\n# [(0, 1), (1, 2), (2, 2)]"
        },
        "Section_id": "Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Section ID": "size"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Path": "networkx.Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Description": [
            "Returns the number of edges or total of all edge weights."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "weight : string or None, optional (default=None)": "The edge attribute that holds the numerical value used\nas a weight. If None, then each edge has weight 1."
            },
            "Returns:": {
                "size : numeric": "The number of edges or\n(if weight keyword is provided) the total weight sum.If weight is None, returns an int. Otherwise a float\n(or more general numeric if the weights are more general)."
            },
            "Methods": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.size()\n# 3\nG=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_edge(\"a\",\"b\",weight=2)\nG.add_edge(\"b\",\"c\",weight=4)\nG.size()\n# 2\nG.size(weight=\"weight\")\n# 6.0"
        },
        "Section_id": "Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Section ID": "number_of_edges"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Path": "networkx.Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Description": [
            "Returns the number of edges between two nodes."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "u, v : nodes, optional (default=all edges)": "If u and v are specified, return the number of edges between\nu and v. Otherwise return the total number of all edges."
            },
            "Returns:": {
                "nedges : int": "The number of edges in the graph.  If nodesuandvare\nspecified return the number of edges between those nodes. If\nthe graph is directed, this only returns the number of edges\nfromutov."
            },
            "Methods": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "For undirected graphs, this method counts the total number of\nedges in the graph:\nG=nx.path_graph(4)\nG.number_of_edges()\n# 3\nIf you specify two nodes, this counts the total number of edges\njoining the two nodes:\nG.number_of_edges(0,1)\n# 1\nFor directed graphs, this method can count the total number of\ndirected edges fromutov:\nG=nx.DiGraph()\nG.add_edge(0,1)\nG.add_edge(1,0)\nG.number_of_edges(0,1)\n# 1"
        },
        "Section_id": "Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Section ID": "copy"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Path": "networkx.Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Description": [
            "Returns a copy of the graph.",
            "The copy method by default returns an independent shallow copy\nof the graph and attributes. That is, if an attribute is a\ncontainer, that container is shared by the original an the copy.\nUse Python\u2019s copy.deepcopy for new containers.",
            "If as_view is True then a view is returned instead of a copy."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "as_view : bool, optional (default=False)": "If True, the returned graph-view provides a read-only view\nof the original graph without actually copying any data."
            },
            "Returns:": {
                "G : Graph": "A copy of the graph."
            },
            "Methods": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "All copies reproduce the graph structure, but data attributes\nmay be handled in different ways. There are four types of copies\nof a graph that people might want. Deepcopy \u2013 A \u201cdeepcopy\u201d copies the graph structure as well as\nall data attributes and any objects they might contain.\nThe entire graph object is new so that changes in the copy\ndo not affect the original object. (see Python\u2019s copy.deepcopy) Data Reference (Shallow) \u2013 For a shallow copy the graph structure\nis copied but the edge, node and graph attribute dicts are\nreferences to those in the original graph. This saves\ntime and memory but could cause confusion if you change an attribute\nin one graph and it changes the attribute in the other.\nNetworkX does not provide this level of shallow copy. Independent Shallow \u2013 This copy creates new independent attribute\ndicts and then does a shallow copy of the attributes. That is, any\nattributes that are containers are shared between the new graph\nand the original. This is exactly what dict.copy() provides.\nYou can obtain this style copy using:",
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nH=G.copy()"
        },
        "Section_id": "Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Section ID": "to_undirected"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Path": "networkx.Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Description": [
            "Returns an undirected copy of the graph."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "as_view : bool (optional, default=False)": "If True return a view of the original undirected graph."
            },
            "Returns:": {
                "G : Graph/MultiGraph": "A deepcopy of the graph."
            },
            "Methods": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "This returns a \u201cdeepcopy\u201d of the edge, node, and\ngraph attributes which attempts to completely copy\nall of the data and references. This is in contrast to the similar G=nx.DiGraph(D) which returns a\nshallow copy of the data. See the Python copy module for more information on shallow\nand deep copies, https://docs.python.org/3/library/copy.html . Warning: If you have subclassed DiGraph to use dict-like objects\nin the data structure, those changes do not transfer to the\nGraph created by this method.",
            "Examples": "G=nx.path_graph(2)# or MultiGraph, etc\nH=G.to_directed()\nlist(H.edges)\n# [(0, 1), (1, 0)]\nG2=H.to_undirected()\nlist(G2.edges)\n# [(0, 1)]"
        },
        "Section_id": "Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Section ID": "to_directed"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Path": "networkx.Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Description": [
            "Returns a directed representation of the graph."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Returns:": {
                "G : DiGraph": "A directed graph with the same name, same nodes, and with\neach edge (u, v, data) replaced by two directed edges\n(u, v, data) and (v, u, data)."
            },
            "Methods": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "This returns a \u201cdeepcopy\u201d of the edge, node, and\ngraph attributes which attempts to completely copy\nall of the data and references. This is in contrast to the similar D=DiGraph(G) which returns a\nshallow copy of the data. See the Python copy module for more information on shallow\nand deep copies, https://docs.python.org/3/library/copy.html . Warning: If you have subclassed Graph to use dict-like objects\nin the data structure, those changes do not transfer to the\nDiGraph created by this method.",
            "Examples": "G=nx.Graph()# or MultiGraph, etc\nG.add_edge(0,1)\nH=G.to_directed()\nlist(H.edges)\n# [(0, 1), (1, 0)]\nIf already directed, return a (deep) copy\nG=nx.DiGraph()# or MultiDiGraph, etc\nG.add_edge(0,1)\nH=G.to_directed()\nlist(H.edges)\n# [(0, 1)]"
        },
        "Section_id": "Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Section ID": "subgraph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Path": "networkx.Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Description": [
            "Returns a SubGraph view of the subgraph induced on nodes .",
            "The induced subgraph of the graph contains the nodes in nodes and the edges between those nodes."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "nodes : list, iterable": "A container of nodes which will be iterated through once."
            },
            "Returns:": {
                "G : SubGraph View": "A subgraph view of the graph. The graph structure cannot be\nchanged but node/edge attributes can and are shared with the\noriginal graph."
            },
            "Methods": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "The graph, edge and node attributes are shared with the original graph.\nChanges to the graph structure is ruled out by the view, but changes\nto attributes are reflected in the original graph. To create a subgraph with its own copy of the edge/node attributes use:\nG.subgraph(nodes).copy() For an inplace reduction of a graph to a subgraph you can remove nodes:\nG.remove_nodes_from([n for n in G if n not in set(nodes)]) Subgraph views are sometimes NOT what you want. In most cases where\nyou want to do more than simply look at the induced edges, it makes\nmore sense to just create the subgraph as its own graph with code like:",
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nH=G.subgraph([0,1,2])\nlist(H.edges)\n# [(0, 1), (1, 2)]"
        },
        "Section_id": "Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Section ID": "edge_subgraph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Path": "networkx.Graph"
    },
    {
        "Section_id": "Graph",
        "Field List > Methods > Description": [
            "Returns the subgraph induced by the specified edges.",
            "The induced subgraph contains each edge in edges and each\nnode incident to any one of those edges."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "edges : iterable": "An iterable of edges in this graph."
            },
            "Returns:": {
                "G : Graph": "An edge-induced subgraph of this graph with the same edge\nattributes."
            },
            "Methods": []
        },
        "Section_id": "Graph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "The graph, edge, and node attributes in the returned subgraph\nview are references to the corresponding attributes in the original\ngraph. The view is read-only. To create a full graph version of the subgraph with its own copy\nof the edge or node attributes, use:",
            "Examples": "G=nx.path_graph(5)\nH=G.edge_subgraph([(0,1),(3,4)])\nlist(H.nodes)\n# [0, 1, 3, 4]\nlist(H.edges)\n# [(0, 1), (3, 4)]"
        },
        "Section_id": "Graph"
    },
    {
        "Rubrics": {
            "Examples": "Create an empty graph structure (a \u201cnull graph\u201d) with no nodes and\nno edges.\nG=nx.Graph()\nG can be grown in several ways.\nNodes:\nAdd one node at a time:\nG.add_node(1)\nAdd the nodes from any container (a list, dict, set or\neven the lines from a file or the nodes from another graph).\nG.add_nodes_from([2,3])\nG.add_nodes_from(range(100,110))\nH=nx.path_graph(10)\nG.add_nodes_from(H)\nIn addition to strings and integers any hashable Python object\n(except None) can represent a node, e.g. a customized node object,\nor even another Graph.\nG.add_node(H)\nEdges:\nG can also be grown by adding edges.\nAdd one edge,\nG.add_edge(1,2)\na list of edges,\nG.add_edges_from([(1,2),(1,3)])\nor a collection of edges,\nG.add_edges_from(H.edges)\nIf some edges connect nodes not yet in the graph, the nodes\nare added automatically.  There are no errors when adding\nnodes or edges that already exist.\nAttributes:\nEach graph, node, and edge can hold key/value attribute pairs\nin an associated attribute dictionary (the keys must be hashable).\nBy default these are empty, but can be added or changed using\nadd_edge, add_node or direct manipulation of the attribute\ndictionaries named graph, node and edge respectively.\nG=nx.Graph(day=\"Friday\")\nG.graph\n# {'day': 'Friday'}\nAdd node attributes using add_node(), add_nodes_from() or G.nodes\nG.add_node(1,time=\"5pm\")\nG.add_nodes_from([3],time=\"2pm\")\nG.nodes[1]\n# {'time': '5pm'}\nG.nodes[1][\"room\"]=714# node must exist already to use G.nodes\ndelG.nodes[1][\"room\"]# remove attribute\nlist(G.nodes(data=True))\n# [(1, {'time': '5pm'}), (3, {'time': '2pm'})]\nAdd edge attributes using add_edge(), add_edges_from(), subscript\nnotation, or G.edges.\nG.add_edge(1,2,weight=4.7)\nG.add_edges_from([(3,4),(4,5)],color=\"red\")\nG.add_edges_from([(1,2,{\"color\":\"blue\"}),(2,3,{\"weight\":8})])\nG[1][2][\"weight\"]=4.7\nG.edges[1,2][\"weight\"]=4\nWarning: we protect the graph data structure by makingG.edgesa\nread-only dict-like structure. However, you can assign to attributes\nin e.g.G.edges[1,2]. Thus, use 2 sets of brackets to add/change\ndata attributes:G.edges[1,2]['weight']=4(For multigraphs:MG.edges[u,v,key][name]=value).\nShortcuts:\nMany common graph features allow python syntax to speed reporting.\n1inG# check if node in graph\n# True\n[nforninGifn<3]# iterate through nodes\n# [1, 2]\nlen(G)# number of nodes in graph\n# 5\nOften the best way to traverse all edges of a graph is via the neighbors.\nThe neighbors are reported as an adjacency-dictG.adjorG.adjacency()\nforn,nbrsdictinG.adjacency():\nfornbr,eattrinnbrsdict.items():\nif\"weight\"ineattr:\n# Do something useful with the edges\npass\nBut the edges() method is often more convenient:\nforu,v,weightinG.edges.data(\"weight\"):\nifweightisnotNone:\n# Do something useful with the edges\npass\nReporting:\nSimple graph information is obtained using object-attributes and methods.\nReporting typically provides views instead of containers to reduce memory\nusage. The views update as the graph is updated similarly to dict-views.\nThe objectsnodes,edgesandadjprovide access to data attributes\nvia lookup (e.g.nodes[n],edges[u,v],adj[u][v]) and iteration\n(e.g.nodes.items(),nodes.data('color'),nodes.data('color',default='blue')and similarly foredges)\nViews exist fornodes,edges,neighbors()/adjanddegree.\nFor details on these and other miscellaneous methods, see below.\nSubclasses (Advanced):\nThe Graph class uses a dict-of-dict-of-dict data structure.\nThe outer dict (node_dict) holds adjacency information keyed by node.\nThe next dict (adjlist_dict) represents the adjacency information and holds\nedge data keyed by neighbor.  The inner dict (edge_attr_dict) represents\nthe edge data and holds edge attribute values keyed by attribute names.\nEach of these three dicts can be replaced in a subclass by a user defined\ndict-like object. In general, the dict-like features should be\nmaintained but extra features can be added. To replace one of the\ndicts create a new graph class by changing the class(!) variable\nholding the factory for that dict-like structure."
        },
        "Section_id": "Graph"
    },
    {
        "Section_id": "DiGraph",
        "Section ID": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Description": [
            "Base class for directed graphs.",
            "A DiGraph stores nodes and edges with optional data, or attributes.",
            "DiGraphs hold directed edges.  Self loops are allowed but multiple\n(parallel) edges are not.",
            "Nodes can be arbitrary (hashable) Python objects with optional\nkey/value attributes. By convention None is not used as a node.",
            "Edges are represented as links between nodes with optional\nkey/value attributes."
        ]
    },
    {
        "Field List > Parameters:": {
            "incoming_graph_data : input graph (optional, default: None)": "Data to initialize graph. If None (default) an empty\ngraph is created.  The data can be any format that is supported\nby the to_networkx_graph() function, currently including edge list,\ndict of dicts, dict of lists, NetworkX graph, 2D NumPy array, SciPy\nsparse matrix, or PyGraphviz graph.",
            "attr : keyword arguments, optional (default= no attributes)": "Attributes to add to graph as key=value pairs."
        },
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "__init__"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Description": [
            "Initialize a graph with edges, name, or graph attributes."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "incoming_graph_data : input graph (optional, default: None)": "Data to initialize graph.  If None (default) an empty\ngraph is created.  The data can be an edge list, or any\nNetworkX graph object.  If the corresponding optional Python\npackages are installed the data can also be a 2D NumPy array, a\nSciPy sparse array, or a PyGraphviz graph.",
                "attr : keyword arguments, optional (default= no attributes)": "Attributes to add to graph as key=value pairs."
            },
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG=nx.Graph(name=\"my graph\")\ne=[(1,2),(2,3),(3,4)]# list of edges\nG=nx.Graph(e)\nArbitrary graph attribute pairs (key=value) may be assigned\nG=nx.Graph(e,day=\"Friday\")\nG.graph\n# {'day': 'Friday'}"
        },
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "add_node"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Description": [
            "Add a single node node_for_adding and update node attributes."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "node_for_adding : node": "A node can be any hashable Python object except None.",
                "attr : keyword arguments, optional": "Set or change node attributes using key=value."
            },
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "A hashable object is one that can be used as a key in a Python\ndictionary. This includes strings, numbers, tuples of strings\nand numbers, etc. On many platforms hashable items also include mutables such as\nNetworkX Graphs, though one should be careful that the hash\ndoesn\u2019t change on mutables.",
            "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_node(1)\nG.add_node(\"Hello\")\nK3=nx.Graph([(0,1),(1,2),(2,0)])\nG.add_node(K3)\nG.number_of_nodes()\n# 3\nUse keywords set/change node attributes:\nG.add_node(1,size=10)\nG.add_node(3,weight=0.4,UTM=(\"13S\",382871,3972649))"
        },
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "add_nodes_from"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Description": [
            "Add multiple nodes."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "nodes_for_adding : iterable container": "A container of nodes (list, dict, set, etc.).\nOR\nA container of (node, attribute dict) tuples.\nNode attributes are updated using the attribute dict.",
                "attr : keyword arguments, optional (default= no attributes)": "Update attributes for all nodes in nodes.\nNode attributes specified in nodes as a tuple take\nprecedence over attributes specified via keyword arguments."
            },
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "When adding nodes from an iterator over the graph you are changing,\na RuntimeError can be raised with message: RuntimeError:dictionarychangedsizeduringiteration . This\nhappens when the graph\u2019s underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using list(iterator_of_nodes) , and pass this\nobject to G.add_nodes_from .",
            "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_nodes_from(\"Hello\")\nK3=nx.Graph([(0,1),(1,2),(2,0)])\nG.add_nodes_from(K3)\nsorted(G.nodes(),key=str)\n# [0, 1, 2, 'H', 'e', 'l', 'o']\nUse keywords to update specific node attributes for every node.\nG.add_nodes_from([1,2],size=10)\nG.add_nodes_from([3,4],weight=0.4)\nUse (node, attrdict) tuples to update attributes for specific nodes.\nG.add_nodes_from([(1,dict(size=11)),(2,{\"color\":\"blue\"})])\nG.nodes[1][\"size\"]\n# 11\nH=nx.Graph()\nH.add_nodes_from(G.nodes(data=True))\nH.nodes[1][\"size\"]\n# 11\nEvaluate an iterator over a graph if using it to modify the same graph\nG=nx.DiGraph([(0,1),(1,2),(3,4)])\n# wrong way - will raise RuntimeError\n# G.add_nodes_from(n + 1 for n in G.nodes)\n# correct way\nG.add_nodes_from(list(n+1forninG.nodes))"
        },
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "remove_node"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Description": [
            "Remove node n.",
            "Removes the node n and all adjacent edges.\nAttempting to remove a nonexistent node will raise an exception."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "n : node": "A node in the graph"
            },
            "Raises:": {
                "NetworkXError": "If n is not in the graph."
            },
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(3)# or DiGraph, MultiGraph, MultiDiGraph, etc\nlist(G.edges)\n# [(0, 1), (1, 2)]\nG.remove_node(1)\nlist(G.edges)\n# []"
        },
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "remove_nodes_from"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Description": [
            "Remove multiple nodes."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "nodes : iterable container": "A container of nodes (list, dict, set, etc.).  If a node\nin the container is not in the graph it is silently ignored."
            },
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "When removing nodes from an iterator over the graph you are changing,\na RuntimeError will be raised with message: RuntimeError:dictionarychangedsizeduringiteration . This\nhappens when the graph\u2019s underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using list(iterator_of_nodes) , and pass this\nobject to G.remove_nodes_from .",
            "Examples": "G=nx.path_graph(3)# or DiGraph, MultiGraph, MultiDiGraph, etc\ne=list(G.nodes)\ne\n# [0, 1, 2]\nG.remove_nodes_from(e)\nlist(G.nodes)\n# []\nEvaluate an iterator over a graph if using it to modify the same graph\nG=nx.DiGraph([(0,1),(1,2),(3,4)])\n# this command will fail, as the graph's dict is modified during iteration\n# G.remove_nodes_from(n for n in G.nodes if n < 2)\n# this command will work, since the dictionary underlying graph is not modified\nG.remove_nodes_from(list(nforninG.nodesifn<2))"
        },
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "add_edge"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Description": [
            "Add an edge between u and v.",
            "The nodes u and v will be automatically added if they are\nnot already in the graph.",
            "Edge attributes can be specified with keywords or by directly\naccessing the edge\u2019s attribute dictionary. See examples below."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "u_of_edge, v_of_edge : nodes": "Nodes can be, for example, strings or numbers.\nNodes must be hashable (and not None) Python objects.",
                "attr : keyword arguments, optional": "Edge data (or labels or objects) can be assigned using\nkeyword arguments."
            },
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "Adding an edge that already exists updates the edge data. Many NetworkX algorithms designed for weighted graphs use\nan edge attribute (by default weight ) to hold a numerical value.",
            "Examples": "The following all add the edge e=(1, 2) to graph G:\nG=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\ne=(1,2)\nG.add_edge(1,2)# explicit two-node form\nG.add_edge(*e)# single edge as tuple of two nodes\nG.add_edges_from([(1,2)])# add edges from iterable container\nAssociate data to edges using keywords:\nG.add_edge(1,2,weight=3)\nG.add_edge(1,3,weight=7,capacity=15,length=342.7)\nFor non-string attribute keys, use subscript notation.\nG.add_edge(1,2)\nG[1][2].update({0:5})\nG.edges[1,2].update({0:5})"
        },
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "add_edges_from"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Description": [
            "Add all the edges in ebunch_to_add."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "ebunch_to_add : container of edges": "Each edge given in the container will be added to the\ngraph. The edges must be given as 2-tuples (u, v) or\n3-tuples (u, v, d) where d is a dictionary containing edge data.",
                "attr : keyword arguments, optional": "Edge data (or labels or objects) can be assigned using\nkeyword arguments."
            },
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "Adding the same edge twice has no effect but any edge data\nwill be updated when each duplicate edge is added. Edge attributes specified in an ebunch take precedence over\nattributes specified via keyword arguments. When adding edges from an iterator over the graph you are changing,\na RuntimeError can be raised with message: RuntimeError:dictionarychangedsizeduringiteration . This\nhappens when the graph\u2019s underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using list(iterator_of_edges) , and pass this\nobject to G.add_edges_from .",
            "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_edges_from([(0,1),(1,2)])# using a list of edge tuples\ne=zip(range(0,3),range(1,4))\nG.add_edges_from(e)# Add the path graph 0-1-2-3\nAssociate data to edges\nG.add_edges_from([(1,2),(2,3)],weight=3)\nG.add_edges_from([(3,4),(1,4)],label=\"WN2898\")\nEvaluate an iterator over a graph if using it to modify the same graph\nG=nx.DiGraph([(1,2),(2,3),(3,4)])\n# Grow graph by one new node, adding edges to all existing nodes.\n# wrong way - will raise RuntimeError\n# G.add_edges_from(((5, n) for n in G.nodes))\n# right way - note that there will be no self-edge for node 5\nG.add_edges_from(list((5,n)forninG.nodes))"
        },
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "add_weighted_edges_from"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Description": [
            "Add weighted edges in ebunch_to_add with specified weight attr"
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "ebunch_to_add : container of edges": "Each edge given in the list or container will be added\nto the graph. The edges must be given as 3-tuples (u, v, w)\nwhere w is a number.",
                "weight : string, optional (default= \u2018weight\u2019)": "The attribute name for the edge weights to be added.",
                "attr : keyword arguments, optional (default= no attributes)": "Edge attributes to add/update for all edges."
            },
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "Adding the same edge twice for Graph/DiGraph simply updates\nthe edge data. For MultiGraph/MultiDiGraph, duplicate edges\nare stored. When adding edges from an iterator over the graph you are changing,\na RuntimeError can be raised with message: RuntimeError:dictionarychangedsizeduringiteration . This\nhappens when the graph\u2019s underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using list(iterator_of_edges) , and pass this\nobject to G.add_weighted_edges_from .",
            "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_weighted_edges_from([(0,1,3.0),(1,2,7.5)])\nEvaluate an iterator over edges before passing it\nG=nx.Graph([(1,2),(2,3),(3,4)])\nweight=0.1\n# Grow graph by one new node, adding edges to all existing nodes.\n# wrong way - will raise RuntimeError\n# G.add_weighted_edges_from(((5, n, weight) for n in G.nodes))\n# correct way - note that there will be no self-edge for node 5\nG.add_weighted_edges_from(list((5,n,weight)forninG.nodes))"
        },
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "remove_edge"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Description": [
            "Remove the edge between u and v."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "u, v : nodes": "Remove the edge between nodes u and v."
            },
            "Raises:": {
                "NetworkXError": "If there is not an edge between u and v."
            },
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.Graph()# or DiGraph, etc\nnx.add_path(G,[0,1,2,3])\nG.remove_edge(0,1)\ne=(1,2)\nG.remove_edge(*e)# unpacks e from an edge tuple\ne=(2,3,{\"weight\":7})# an edge with attribute data\nG.remove_edge(*e[:2])# select first part of edge tuple"
        },
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "remove_edges_from"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Description": [
            "Remove all edges specified in ebunch."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "ebunch: list or container of edge tuples": "Each edge given in the list or container will be removed\nfrom the graph. The edges can be:2-tuples (u, v) edge between u and v.3-tuples (u, v, k) where k is ignored."
            },
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "Will fail silently if an edge in ebunch is not in the graph.",
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nebunch=[(1,2),(2,3)]\nG.remove_edges_from(ebunch)"
        },
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "update"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Description": [
            "Update the graph using nodes/edges/graphs as input.",
            "Like dict.update, this method takes a graph as input, adding the\ngraph\u2019s nodes and edges to this graph. It can also take two inputs:\nedges and nodes. Finally it can take either edges or nodes.\nTo specify only nodes the keyword nodes must be used.",
            "The collections of edges and nodes are treated similarly to\nthe add_edges_from/add_nodes_from methods. When iterated, they\nshould yield 2-tuples (u, v) or 3-tuples (u, v, datadict)."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "edges : Graph object, collection of edges, or None": "The first parameter can be a graph or some edges. If it has\nattributesnodesandedges, then it is taken to be a\nGraph-like object and those attributes are used as collections\nof nodes and edges to be added to the graph.\nIf the first parameter does not have those attributes, it is\ntreated as a collection of edges and added to the graph.\nIf the first argument is None, no edges are added.",
                "nodes : collection of nodes, or None": "The second parameter is treated as a collection of nodes\nto be added to the graph unless it is None.\nIfedgesisNoneandnodesisNonean exception is raised.\nIf the first parameter is a Graph, thennodesis ignored."
            },
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "It you want to update the graph using an adjacency structure\nit is straightforward to obtain the edges/nodes from adjacency.\nThe following examples provide common cases, your adjacency may\nbe slightly different and require tweaks of these examples:",
            "Examples": "G=nx.path_graph(5)\nG.update(nx.complete_graph(range(4,10)))\nfromitertoolsimportcombinations\nedges=(\n(u,v,{\"power\":u*v})\nforu,vincombinations(range(10,20),2)\nifu*v<225\n)\nnodes=[1000]# for singleton, use a container\nG.update(edges,nodes)"
        },
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "clear"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Description": [
            "Remove all nodes and edges from the graph.",
            "This also removes the name, and all graph, node, and edge attributes.",
            "Examples"
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.clear()\nlist(G.nodes)\n# []\nlist(G.edges)\n# []"
        },
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "clear_edges"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Description": [
            "Remove all edges from the graph without altering nodes.",
            "Examples"
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.clear_edges()\nlist(G.nodes)\n# [0, 1, 2, 3]\nlist(G.edges)\n# []"
        },
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "nodes"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "data : string or bool, optional (default=False)": "The node attribute returned in 2-tuple (n, ddict[data]).\nIf True, return entire node attribute dict as (n, ddict).\nIf False, return just the nodes n.",
                "default : value, optional (default=None)": "Value used for nodes that don\u2019t have the requested attribute.\nOnly relevant if data is not True or False."
            },
            "Returns:": {
                "NodeView": "Allows set-like operations over the nodes as well as node\nattribute dict lookup and calling to get a NodeDataView.\nA NodeDataView iterates over(n,data)and has no set operations.\nA NodeView iterates overnand includes set operations.When called, if data is False, an iterator over nodes.\nOtherwise an iterator of 2-tuples (node, attribute value)\nwhere the attribute is specified indata.\nIf data is True then the attribute becomes the\nentire data dictionary."
            },
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "If your node data is not needed, it is simpler and equivalent\nto use the expression forninG , or list(G) .",
            "Examples": "There are two simple ways of getting a list of all nodes in the graph:\nG=nx.path_graph(3)\nlist(G.nodes)\n# [0, 1, 2]\nlist(G)\n# [0, 1, 2]\nTo get the node data along with the nodes:\nG.add_node(1,time=\"5pm\")\nG.nodes[0][\"foo\"]=\"bar\"\nlist(G.nodes(data=True))\n# [(0, {'foo': 'bar'}), (1, {'time': '5pm'}), (2, {})]\nlist(G.nodes.data())\n# [(0, {'foo': 'bar'}), (1, {'time': '5pm'}), (2, {})]\nlist(G.nodes(data=\"foo\"))\n# [(0, 'bar'), (1, None), (2, None)]\nlist(G.nodes.data(\"foo\"))\n# [(0, 'bar'), (1, None), (2, None)]\nlist(G.nodes(data=\"time\"))\n# [(0, None), (1, '5pm'), (2, None)]\nlist(G.nodes.data(\"time\"))\n# [(0, None), (1, '5pm'), (2, None)]\nlist(G.nodes(data=\"time\",default=\"Not Available\"))\n# [(0, 'Not Available'), (1, '5pm'), (2, 'Not Available')]\nlist(G.nodes.data(\"time\",default=\"Not Available\"))\n# [(0, 'Not Available'), (1, '5pm'), (2, 'Not Available')]\nIf some of your nodes have an attribute and the rest are assumed\nto have a default attribute value you can create a dictionary\nfrom node/attribute pairs using thedefaultkeyword argument\nto guarantee the value is never None:\nG=nx.Graph()\nG.add_node(0)\nG.add_node(1,weight=2)\nG.add_node(2,weight=3)\ndict(G.nodes(data=\"weight\",default=1))\n# {0: 1, 1: 2, 2: 3}"
        },
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "__iter__"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Description": [
            "Iterate over the nodes. Use: \u2018for n in G\u2019."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Returns:": {
                "niter : iterator": "An iterator over all nodes in the graph."
            },
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\n[nforninG]\n# [0, 1, 2, 3]\nlist(G)\n# [0, 1, 2, 3]"
        },
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "has_node"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Description": [
            "Returns True if the graph contains the node n.",
            "Identical to ninG"
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "n : node": ""
            },
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(3)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.has_node(0)\n# True\nIt is more readable and simpler to use\n0inG\n# True"
        },
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "__contains__"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Description": [
            "Returns True if n is a node, False otherwise. Use: \u2018n in G\u2019.",
            "Examples"
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\n1inG\n# True"
        },
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "edges"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "nbunch : single node, container, or all nodes (default= all nodes)": "The view will only report edges from these nodes.",
                "data : string or bool, optional (default=False)": "The edge attribute returned in 3-tuple (u, v, ddict[data]).\nIf True, return edge attribute dict in 3-tuple (u, v, ddict).\nIf False, return 2-tuple (u, v).",
                "default : value, optional (default=None)": "Value used for edges that don\u2019t have the requested attribute.\nOnly relevant if data is not True or False."
            },
            "Returns:": {
                "edges : OutEdgeView": "A view of edge attributes, usually it iterates over (u, v)\nor (u, v, d) tuples of edges, but can also be used for\nattribute lookup asedges[u,v]['foo']."
            },
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "Nodes in nbunch that are not in the graph will be (quietly) ignored.\nFor directed graphs this returns the out-edges.",
            "Examples": "G=nx.DiGraph()# or MultiDiGraph, etc\nnx.add_path(G,[0,1,2])\nG.add_edge(2,3,weight=5)\n[eforeinG.edges]\n# [(0, 1), (1, 2), (2, 3)]\nG.edges.data()# default data is {} (empty dict)\n# OutEdgeDataView([(0, 1, {}), (1, 2, {}), (2, 3, {'weight': 5})])\nG.edges.data(\"weight\",default=1)\n# OutEdgeDataView([(0, 1, 1), (1, 2, 1), (2, 3, 5)])\nG.edges([0,2])# only edges originating from these nodes\n# OutEdgeDataView([(0, 1), (2, 3)])\nG.edges(0)# only edges from node 0\n# OutEdgeDataView([(0, 1)])"
        },
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "out_edges"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "nbunch : single node, container, or all nodes (default= all nodes)": "The view will only report edges from these nodes.",
                "data : string or bool, optional (default=False)": "The edge attribute returned in 3-tuple (u, v, ddict[data]).\nIf True, return edge attribute dict in 3-tuple (u, v, ddict).\nIf False, return 2-tuple (u, v).",
                "default : value, optional (default=None)": "Value used for edges that don\u2019t have the requested attribute.\nOnly relevant if data is not True or False."
            },
            "Returns:": {
                "edges : OutEdgeView": "A view of edge attributes, usually it iterates over (u, v)\nor (u, v, d) tuples of edges, but can also be used for\nattribute lookup asedges[u,v]['foo']."
            },
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "Nodes in nbunch that are not in the graph will be (quietly) ignored.\nFor directed graphs this returns the out-edges.",
            "Examples": "G=nx.DiGraph()# or MultiDiGraph, etc\nnx.add_path(G,[0,1,2])\nG.add_edge(2,3,weight=5)\n[eforeinG.edges]\n# [(0, 1), (1, 2), (2, 3)]\nG.edges.data()# default data is {} (empty dict)\n# OutEdgeDataView([(0, 1, {}), (1, 2, {}), (2, 3, {'weight': 5})])\nG.edges.data(\"weight\",default=1)\n# OutEdgeDataView([(0, 1, 1), (1, 2, 1), (2, 3, 5)])\nG.edges([0,2])# only edges originating from these nodes\n# OutEdgeDataView([(0, 1), (2, 3)])\nG.edges(0)# only edges from node 0\n# OutEdgeDataView([(0, 1)])"
        },
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "in_edges"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "nbunch : single node, container, or all nodes (default= all nodes)": "The view will only report edges incident to these nodes.",
                "data : string or bool, optional (default=False)": "The edge attribute returned in 3-tuple (u, v, ddict[data]).\nIf True, return edge attribute dict in 3-tuple (u, v, ddict).\nIf False, return 2-tuple (u, v).",
                "default : value, optional (default=None)": "Value used for edges that don\u2019t have the requested attribute.\nOnly relevant if data is not True or False."
            },
            "Returns:": {
                "in_edges : InEdgeView or InEdgeDataView": "A view of edge attributes, usually it iterates over (u, v)\nor (u, v, d) tuples of edges, but can also be used for\nattribute lookup asedges[u,v]['foo']."
            },
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.DiGraph()\nG.add_edge(1,2,color=\"blue\")\nG.in_edges()\n# InEdgeView([(1, 2)])\nG.in_edges(nbunch=2)\n# InEdgeDataView([(1, 2)])"
        },
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "has_edge"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Description": [
            "Returns True if the edge (u, v) is in the graph.",
            "This is the same as vinG[u] without KeyError exceptions."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "u, v : nodes": "Nodes can be, for example, strings or numbers.\nNodes must be hashable (and not None) Python objects."
            },
            "Returns:": {
                "edge_ind : bool": "True if edge is in the graph, False otherwise."
            },
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.has_edge(0,1)# using two nodes\n# True\ne=(0,1)\nG.has_edge(*e)#  e is a 2-tuple (u, v)\n# True\ne=(0,1,{\"weight\":7})\nG.has_edge(*e[:2])# e is a 3-tuple (u, v, data_dictionary)\n# True\nThe following syntax are equivalent:\nG.has_edge(0,1)\n# True\n1inG[0]# though this gives KeyError if 0 not in G\n# True"
        },
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "get_edge_data"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Description": [
            "Returns the attribute dictionary associated with edge (u, v).",
            "This is identical to G[u][v] except the default is returned\ninstead of an exception if the edge doesn\u2019t exist."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "u, v : nodes": "",
                "default:  any Python object (default=None)": "Value to return if the edge (u, v) is not found."
            },
            "Returns:": {
                "edge_dict : dictionary": "The edge attribute dictionary."
            },
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG[0][1]\n# {}\nWarning: Assigning toG[u][v]is not permitted.\nBut it is safe to assign attributesG[u][v]['foo']\nG[0][1][\"weight\"]=7\nG[0][1][\"weight\"]\n# 7\nG[1][0][\"weight\"]\n# 7\nG=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.get_edge_data(0,1)# default edge data is {}\n# {}\ne=(0,1)\nG.get_edge_data(*e)# tuple form\n# {}\nG.get_edge_data(\"a\",\"b\",default=0)# edge not in graph, return 0\n# 0"
        },
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "neighbors"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Description": [
            "Returns an iterator over successor nodes of n.",
            "A successor of n is a node m such that there exists a directed\nedge from n to m."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "n : node": "A node in the graph"
            },
            "Raises:": {
                "NetworkXError": "If n is not in the graph."
            },
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "neighbors() and successors() are the same."
        },
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "adj"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Field List > Methods > Field List": {
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {},
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "__getitem__"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Description": [
            "Returns a dict of neighbors of node n.  Use: \u2018G[n]\u2019."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "n : node": "A node in the graph."
            },
            "Returns:": {
                "adj_dict : dictionary": "The adjacency dictionary for nodes connected to n."
            },
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "G[n] is the same as G.adj[n] and similar to G.neighbors(n)\n(which is an iterator over G.adj[n])",
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG[0]\n# AtlasView({1: {}})"
        },
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "successors"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Description": [
            "Returns an iterator over successor nodes of n.",
            "A successor of n is a node m such that there exists a directed\nedge from n to m."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "n : node": "A node in the graph"
            },
            "Raises:": {
                "NetworkXError": "If n is not in the graph."
            },
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "neighbors() and successors() are the same."
        },
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "succ"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Field List > Methods > Field List": {
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {},
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "predecessors"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Description": [
            "Returns an iterator over predecessor nodes of n.",
            "A predecessor of n is a node m such that there exists a directed\nedge from m to n."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "n : node": "A node in the graph"
            },
            "Raises:": {
                "NetworkXError": "If n is not in the graph."
            },
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {},
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "pred"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Field List > Methods > Field List": {
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {},
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "adjacency"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Description": [
            "Returns an iterator over (node, adjacency dict) tuples for all nodes.",
            "For directed graphs, only outgoing neighbors/adjacencies are included."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Returns:": {
                "adj_iter : iterator": "An iterator over (node, adjacency dictionary) for all nodes in\nthe graph."
            },
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\n[(n,nbrdict)forn,nbrdictinG.adjacency()]\n# [(0, {1: {}}), (1, {0: {}, 2: {}}), (2, {1: {}, 3: {}}), (3, {2: {}})]"
        },
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "nbunch_iter"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Description": [
            "Returns an iterator over nodes contained in nbunch that are\nalso in the graph.",
            "The nodes in nbunch are checked for membership in the graph\nand if not are silently ignored."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "nbunch : single node, container, or all nodes (default= all nodes)": "The view will only report edges incident to these nodes."
            },
            "Returns:": {
                "niter : iterator": "An iterator over nodes in nbunch that are also in the graph.\nIf nbunch is None, iterate over all nodes in the graph."
            },
            "Raises:": {
                "NetworkXError": "If nbunch is not a node or sequence of nodes.\nIf a node in nbunch is not hashable."
            },
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "When nbunch is an iterator, the returned iterator yields values\ndirectly from nbunch, becoming exhausted when nbunch is exhausted. To test whether nbunch is a single node, one can use\n\u201cif nbunch in self:\u201d, even after processing with this routine. If nbunch is not a node or a (possibly empty) sequence/iterator\nor None, a NetworkXError is raised.  Also, if any object in\nnbunch is not hashable, a NetworkXError is raised."
        },
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "order"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Description": [
            "Returns the number of nodes in the graph."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Returns:": {
                "nnodes : int": "The number of nodes in the graph."
            },
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(3)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.order()\n# 3"
        },
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "number_of_nodes"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Description": [
            "Returns the number of nodes in the graph."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Returns:": {
                "nnodes : int": "The number of nodes in the graph."
            },
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(3)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.number_of_nodes()\n# 3"
        },
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "__len__"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Description": [
            "Returns the number of nodes in the graph. Use: \u2018len(G)\u2019."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Returns:": {
                "nnodes : int": "The number of nodes in the graph."
            },
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nlen(G)\n# 4"
        },
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "degree"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "nbunch : single node, container, or all nodes (default= all nodes)": "The view will only report edges incident to these nodes.",
                "weight : string or None, optional (default=None)": "The name of an edge attribute that holds the numerical value used\nas a weight.  If None, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node."
            },
            "Returns:": {
                "DiDegreeView or int": "If multiple nodes are requested (the default), returns aDiDegreeViewmapping nodes to their degree.\nIf a single node is requested, returns the degree of the node as an integer."
            },
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.DiGraph()# or MultiDiGraph\nnx.add_path(G,[0,1,2,3])\nG.degree(0)# node 0 with degree 1\n# 1\nlist(G.degree([0,1,2]))\n# [(0, 1), (1, 2), (2, 2)]"
        },
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "in_degree"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "nbunch : single node, container, or all nodes (default= all nodes)": "The view will only report edges incident to these nodes.",
                "weight : string or None, optional (default=None)": "The name of an edge attribute that holds the numerical value used\nas a weight.  If None, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node."
            },
            "Returns:": {
                "If a single node is requested": "",
                "deg : int": "In-degree of the node",
                "OR if multiple nodes are requested": "",
                "nd_iter : iterator": "The iterator returns two-tuples of (node, in-degree)."
            },
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.DiGraph()\nnx.add_path(G,[0,1,2,3])\nG.in_degree(0)# node 0 with degree 0\n# 0\nlist(G.in_degree([0,1,2]))\n# [(0, 0), (1, 1), (2, 1)]"
        },
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "out_degree"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "nbunch : single node, container, or all nodes (default= all nodes)": "The view will only report edges incident to these nodes.",
                "weight : string or None, optional (default=None)": "The name of an edge attribute that holds the numerical value used\nas a weight.  If None, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node."
            },
            "Returns:": {
                "If a single node is requested": "",
                "deg : int": "Out-degree of the node",
                "OR if multiple nodes are requested": "",
                "nd_iter : iterator": "The iterator returns two-tuples of (node, out-degree)."
            },
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.DiGraph()\nnx.add_path(G,[0,1,2,3])\nG.out_degree(0)# node 0 with degree 1\n# 1\nlist(G.out_degree([0,1,2]))\n# [(0, 1), (1, 1), (2, 1)]"
        },
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "size"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Description": [
            "Returns the number of edges or total of all edge weights."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "weight : string or None, optional (default=None)": "The edge attribute that holds the numerical value used\nas a weight. If None, then each edge has weight 1."
            },
            "Returns:": {
                "size : numeric": "The number of edges or\n(if weight keyword is provided) the total weight sum.If weight is None, returns an int. Otherwise a float\n(or more general numeric if the weights are more general)."
            },
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.size()\n# 3\nG=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_edge(\"a\",\"b\",weight=2)\nG.add_edge(\"b\",\"c\",weight=4)\nG.size()\n# 2\nG.size(weight=\"weight\")\n# 6.0"
        },
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "number_of_edges"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Description": [
            "Returns the number of edges between two nodes."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "u, v : nodes, optional (default=all edges)": "If u and v are specified, return the number of edges between\nu and v. Otherwise return the total number of all edges."
            },
            "Returns:": {
                "nedges : int": "The number of edges in the graph.  If nodesuandvare\nspecified return the number of edges between those nodes. If\nthe graph is directed, this only returns the number of edges\nfromutov."
            },
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "For undirected graphs, this method counts the total number of\nedges in the graph:\nG=nx.path_graph(4)\nG.number_of_edges()\n# 3\nIf you specify two nodes, this counts the total number of edges\njoining the two nodes:\nG.number_of_edges(0,1)\n# 1\nFor directed graphs, this method can count the total number of\ndirected edges fromutov:\nG=nx.DiGraph()\nG.add_edge(0,1)\nG.add_edge(1,0)\nG.number_of_edges(0,1)\n# 1"
        },
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "copy"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Description": [
            "Returns a copy of the graph.",
            "The copy method by default returns an independent shallow copy\nof the graph and attributes. That is, if an attribute is a\ncontainer, that container is shared by the original an the copy.\nUse Python\u2019s copy.deepcopy for new containers.",
            "If as_view is True then a view is returned instead of a copy."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "as_view : bool, optional (default=False)": "If True, the returned graph-view provides a read-only view\nof the original graph without actually copying any data."
            },
            "Returns:": {
                "G : Graph": "A copy of the graph."
            },
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "All copies reproduce the graph structure, but data attributes\nmay be handled in different ways. There are four types of copies\nof a graph that people might want. Deepcopy \u2013 A \u201cdeepcopy\u201d copies the graph structure as well as\nall data attributes and any objects they might contain.\nThe entire graph object is new so that changes in the copy\ndo not affect the original object. (see Python\u2019s copy.deepcopy) Data Reference (Shallow) \u2013 For a shallow copy the graph structure\nis copied but the edge, node and graph attribute dicts are\nreferences to those in the original graph. This saves\ntime and memory but could cause confusion if you change an attribute\nin one graph and it changes the attribute in the other.\nNetworkX does not provide this level of shallow copy. Independent Shallow \u2013 This copy creates new independent attribute\ndicts and then does a shallow copy of the attributes. That is, any\nattributes that are containers are shared between the new graph\nand the original. This is exactly what dict.copy() provides.\nYou can obtain this style copy using:",
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nH=G.copy()"
        },
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "to_undirected"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Description": [
            "Returns an undirected representation of the digraph."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "reciprocal : bool (optional)": "If True only keep edges that appear in both directions\nin the original digraph.",
                "as_view : bool (optional, default=False)": "If True return an undirected view of the original directed graph."
            },
            "Returns:": {
                "G : Graph": "An undirected graph with the same name and nodes and\nwith edge (u, v, data) if either (u, v, data) or (v, u, data)\nis in the digraph.  If both edges exist in digraph and\ntheir edge data is different, only one edge is created\nwith an arbitrary choice of which edge data to use.\nYou must check and correct for this manually if desired."
            },
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "If edges in both directions (u, v) and (v, u) exist in the\ngraph, attributes for the new undirected edge will be a combination of\nthe attributes of the directed edges.  The edge data is updated\nin the (arbitrary) order that the edges are encountered.  For\nmore customized control of the edge attributes use add_edge(). This returns a \u201cdeepcopy\u201d of the edge, node, and\ngraph attributes which attempts to completely copy\nall of the data and references. This is in contrast to the similar G=DiGraph(D) which returns a\nshallow copy of the data. See the Python copy module for more information on shallow\nand deep copies, https://docs.python.org/3/library/copy.html . Warning: If you have subclassed DiGraph to use dict-like objects\nin the data structure, those changes do not transfer to the\nGraph created by this method.",
            "Examples": "G=nx.path_graph(2)# or MultiGraph, etc\nH=G.to_directed()\nlist(H.edges)\n# [(0, 1), (1, 0)]\nG2=H.to_undirected()\nlist(G2.edges)\n# [(0, 1)]"
        },
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "to_directed"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Description": [
            "Returns a directed representation of the graph."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Returns:": {
                "G : DiGraph": "A directed graph with the same name, same nodes, and with\neach edge (u, v, data) replaced by two directed edges\n(u, v, data) and (v, u, data)."
            },
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "This returns a \u201cdeepcopy\u201d of the edge, node, and\ngraph attributes which attempts to completely copy\nall of the data and references. This is in contrast to the similar D=DiGraph(G) which returns a\nshallow copy of the data. See the Python copy module for more information on shallow\nand deep copies, https://docs.python.org/3/library/copy.html . Warning: If you have subclassed Graph to use dict-like objects\nin the data structure, those changes do not transfer to the\nDiGraph created by this method.",
            "Examples": "G=nx.Graph()# or MultiGraph, etc\nG.add_edge(0,1)\nH=G.to_directed()\nlist(H.edges)\n# [(0, 1), (1, 0)]\nIf already directed, return a (deep) copy\nG=nx.DiGraph()# or MultiDiGraph, etc\nG.add_edge(0,1)\nH=G.to_directed()\nlist(H.edges)\n# [(0, 1)]"
        },
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "subgraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Description": [
            "Returns a SubGraph view of the subgraph induced on nodes .",
            "The induced subgraph of the graph contains the nodes in nodes and the edges between those nodes."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "nodes : list, iterable": "A container of nodes which will be iterated through once."
            },
            "Returns:": {
                "G : SubGraph View": "A subgraph view of the graph. The graph structure cannot be\nchanged but node/edge attributes can and are shared with the\noriginal graph."
            },
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "The graph, edge and node attributes are shared with the original graph.\nChanges to the graph structure is ruled out by the view, but changes\nto attributes are reflected in the original graph. To create a subgraph with its own copy of the edge/node attributes use:\nG.subgraph(nodes).copy() For an inplace reduction of a graph to a subgraph you can remove nodes:\nG.remove_nodes_from([n for n in G if n not in set(nodes)]) Subgraph views are sometimes NOT what you want. In most cases where\nyou want to do more than simply look at the induced edges, it makes\nmore sense to just create the subgraph as its own graph with code like:",
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nH=G.subgraph([0,1,2])\nlist(H.edges)\n# [(0, 1), (1, 2)]"
        },
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "edge_subgraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Description": [
            "Returns the subgraph induced by the specified edges.",
            "The induced subgraph contains each edge in edges and each\nnode incident to any one of those edges."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "edges : iterable": "An iterable of edges in this graph."
            },
            "Returns:": {
                "G : Graph": "An edge-induced subgraph of this graph with the same edge\nattributes."
            },
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "The graph, edge, and node attributes in the returned subgraph\nview are references to the corresponding attributes in the original\ngraph. The view is read-only. To create a full graph version of the subgraph with its own copy\nof the edge or node attributes, use:",
            "Examples": "G=nx.path_graph(5)\nH=G.edge_subgraph([(0,1),(3,4)])\nlist(H.nodes)\n# [0, 1, 3, 4]\nlist(H.edges)\n# [(0, 1), (3, 4)]"
        },
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Section ID": "reverse"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Path": "networkx.DiGraph"
    },
    {
        "Section_id": "DiGraph",
        "Field List > Methods > Description": [
            "Returns the reverse of the graph.",
            "The reverse is a graph with the same nodes and edges\nbut with the directions of the edges reversed."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "copy : bool optional (default=True)": "If True, return a new DiGraph holding the reversed edges.\nIf False, the reverse graph is created using a view of\nthe original graph."
            },
            "Methods": []
        },
        "Section_id": "DiGraph"
    },
    {
        "Field List > Methods > Rubrics": {},
        "Section_id": "DiGraph"
    },
    {
        "Rubrics": {
            "Examples": "Create an empty graph structure (a \u201cnull graph\u201d) with no nodes and\nno edges.\nG=nx.DiGraph()\nG can be grown in several ways.\nNodes:\nAdd one node at a time:\nG.add_node(1)\nAdd the nodes from any container (a list, dict, set or\neven the lines from a file or the nodes from another graph).\nG.add_nodes_from([2,3])\nG.add_nodes_from(range(100,110))\nH=nx.path_graph(10)\nG.add_nodes_from(H)\nIn addition to strings and integers any hashable Python object\n(except None) can represent a node, e.g. a customized node object,\nor even another Graph.\nG.add_node(H)\nEdges:\nG can also be grown by adding edges.\nAdd one edge,\nG.add_edge(1,2)\na list of edges,\nG.add_edges_from([(1,2),(1,3)])\nor a collection of edges,\nG.add_edges_from(H.edges)\nIf some edges connect nodes not yet in the graph, the nodes\nare added automatically.  There are no errors when adding\nnodes or edges that already exist.\nAttributes:\nEach graph, node, and edge can hold key/value attribute pairs\nin an associated attribute dictionary (the keys must be hashable).\nBy default these are empty, but can be added or changed using\nadd_edge, add_node or direct manipulation of the attribute\ndictionaries named graph, node and edge respectively.\nG=nx.DiGraph(day=\"Friday\")\nG.graph\n# {'day': 'Friday'}\nAdd node attributes using add_node(), add_nodes_from() or G.nodes\nG.add_node(1,time=\"5pm\")\nG.add_nodes_from([3],time=\"2pm\")\nG.nodes[1]\n# {'time': '5pm'}\nG.nodes[1][\"room\"]=714\ndelG.nodes[1][\"room\"]# remove attribute\nlist(G.nodes(data=True))\n# [(1, {'time': '5pm'}), (3, {'time': '2pm'})]\nAdd edge attributes using add_edge(), add_edges_from(), subscript\nnotation, or G.edges.\nG.add_edge(1,2,weight=4.7)\nG.add_edges_from([(3,4),(4,5)],color=\"red\")\nG.add_edges_from([(1,2,{\"color\":\"blue\"}),(2,3,{\"weight\":8})])\nG[1][2][\"weight\"]=4.7\nG.edges[1,2][\"weight\"]=4\nWarning: we protect the graph data structure by makingG.edges[1,2]a\nread-only dict-like structure. However, you can assign to attributes\nin e.g.G.edges[1,2]. Thus, use 2 sets of brackets to add/change\ndata attributes:G.edges[1,2]['weight']=4(For multigraphs:MG.edges[u,v,key][name]=value).\nShortcuts:\nMany common graph features allow python syntax to speed reporting.\n1inG# check if node in graph\n# True\n[nforninGifn<3]# iterate through nodes\n# [1, 2]\nlen(G)# number of nodes in graph\n# 5\nOften the best way to traverse all edges of a graph is via the neighbors.\nThe neighbors are reported as an adjacency-dictG.adjorG.adjacency()\nforn,nbrsdictinG.adjacency():\nfornbr,eattrinnbrsdict.items():\nif\"weight\"ineattr:\n# Do something useful with the edges\npass\nBut the edges reporting object is often more convenient:\nforu,v,weightinG.edges(data=\"weight\"):\nifweightisnotNone:\n# Do something useful with the edges\npass\nReporting:\nSimple graph information is obtained using object-attributes and methods.\nReporting usually provides views instead of containers to reduce memory\nusage. The views update as the graph is updated similarly to dict-views.\nThe objectsnodes,edgesandadjprovide access to data attributes\nvia lookup (e.g.nodes[n],edges[u,v],adj[u][v]) and iteration\n(e.g.nodes.items(),nodes.data('color'),nodes.data('color',default='blue')and similarly foredges)\nViews exist fornodes,edges,neighbors()/adjanddegree.\nFor details on these and other miscellaneous methods, see below.\nSubclasses (Advanced):\nThe Graph class uses a dict-of-dict-of-dict data structure.\nThe outer dict (node_dict) holds adjacency information keyed by node.\nThe next dict (adjlist_dict) represents the adjacency information and holds\nedge data keyed by neighbor.  The inner dict (edge_attr_dict) represents\nthe edge data and holds edge attribute values keyed by attribute names.\nEach of these three dicts can be replaced in a subclass by a user defined\ndict-like object. In general, the dict-like features should be\nmaintained but extra features can be added. To replace one of the\ndicts create a new graph class by changing the class(!) variable\nholding the factory for that dict-like structure. The variable names are\nnode_dict_factory, node_attr_dict_factory, adjlist_inner_dict_factory,\nadjlist_outer_dict_factory, edge_attr_dict_factory and graph_attr_dict_factory."
        },
        "Section_id": "DiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Section ID": "MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Description": [
            "An undirected graph class that can store multiedges.",
            "Multiedges are multiple edges between two nodes.  Each edge\ncan hold optional data or attributes.",
            "A MultiGraph holds undirected edges.  Self loops are allowed.",
            "Nodes can be arbitrary (hashable) Python objects with optional\nkey/value attributes. By convention None is not used as a node.",
            "Edges are represented as links between nodes with optional\nkey/value attributes, in a MultiGraph each edge has a key to\ndistinguish between multiple edges that have the same source and\ndestination nodes."
        ]
    },
    {
        "Field List > Parameters:": {
            "incoming_graph_data : input graph (optional, default: None)": "Data to initialize graph. If None (default) an empty\ngraph is created.  The data can be any format that is supported\nby the to_networkx_graph() function, currently including edge list,\ndict of dicts, dict of lists, NetworkX graph, 2D NumPy array,\nSciPy sparse array, or PyGraphviz graph.",
            "multigraph_input : bool or None (default None)": "Note: Only used whenincoming_graph_datais a dict.\nIf True,incoming_graph_datais assumed to be a\ndict-of-dict-of-dict-of-dict structure keyed by\nnode to neighbor to edge keys to edge data for multi-edges.\nA NetworkXError is raised if this is not the case.\nIf False,to_networkx_graph()is used to try to determine\nthe dict\u2019s graph data structure as either a dict-of-dict-of-dict\nkeyed by node to neighbor to edge data, or a dict-of-iterable\nkeyed by node to neighbors.\nIf None, the treatment for True is tried, but if it fails,\nthe treatment for False is tried.",
            "attr : keyword arguments, optional (default= no attributes)": "Attributes to add to graph as key=value pairs."
        },
        "Section_id": "MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Section ID": "__init__"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Path": "networkx.MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Description": [
            "Initialize a graph with edges, name, or graph attributes."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "incoming_graph_data : input graph": "Data to initialize graph.  If incoming_graph_data=None (default)\nan empty graph is created.  The data can be an edge list, or any\nNetworkX graph object.  If the corresponding optional Python\npackages are installed the data can also be a 2D NumPy array, a\nSciPy sparse array, or a PyGraphviz graph.",
                "multigraph_input : bool or None (default None)": "Note: Only used whenincoming_graph_datais a dict.\nIf True,incoming_graph_datais assumed to be a\ndict-of-dict-of-dict-of-dict structure keyed by\nnode to neighbor to edge keys to edge data for multi-edges.\nA NetworkXError is raised if this is not the case.\nIf False,to_networkx_graph()is used to try to determine\nthe dict\u2019s graph data structure as either a dict-of-dict-of-dict\nkeyed by node to neighbor to edge data, or a dict-of-iterable\nkeyed by node to neighbors.\nIf None, the treatment for True is tried, but if it fails,\nthe treatment for False is tried.",
                "attr : keyword arguments, optional (default= no attributes)": "Attributes to add to graph as key=value pairs."
            },
            "Methods": []
        },
        "Section_id": "MultiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.MultiGraph()\nG=nx.MultiGraph(name=\"my graph\")\ne=[(1,2),(1,2),(2,3),(3,4)]# list of edges\nG=nx.MultiGraph(e)\nArbitrary graph attribute pairs (key=value) may be assigned\nG=nx.MultiGraph(e,day=\"Friday\")\nG.graph\n# {'day': 'Friday'}"
        },
        "Section_id": "MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Section ID": "add_node"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Path": "networkx.MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Description": [
            "Add a single node node_for_adding and update node attributes."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "node_for_adding : node": "A node can be any hashable Python object except None.",
                "attr : keyword arguments, optional": "Set or change node attributes using key=value."
            },
            "Methods": []
        },
        "Section_id": "MultiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "A hashable object is one that can be used as a key in a Python\ndictionary. This includes strings, numbers, tuples of strings\nand numbers, etc. On many platforms hashable items also include mutables such as\nNetworkX Graphs, though one should be careful that the hash\ndoesn\u2019t change on mutables.",
            "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_node(1)\nG.add_node(\"Hello\")\nK3=nx.Graph([(0,1),(1,2),(2,0)])\nG.add_node(K3)\nG.number_of_nodes()\n# 3\nUse keywords set/change node attributes:\nG.add_node(1,size=10)\nG.add_node(3,weight=0.4,UTM=(\"13S\",382871,3972649))"
        },
        "Section_id": "MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Section ID": "add_nodes_from"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Path": "networkx.MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Description": [
            "Add multiple nodes."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "nodes_for_adding : iterable container": "A container of nodes (list, dict, set, etc.).\nOR\nA container of (node, attribute dict) tuples.\nNode attributes are updated using the attribute dict.",
                "attr : keyword arguments, optional (default= no attributes)": "Update attributes for all nodes in nodes.\nNode attributes specified in nodes as a tuple take\nprecedence over attributes specified via keyword arguments."
            },
            "Methods": []
        },
        "Section_id": "MultiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "When adding nodes from an iterator over the graph you are changing,\na RuntimeError can be raised with message: RuntimeError:dictionarychangedsizeduringiteration . This\nhappens when the graph\u2019s underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using list(iterator_of_nodes) , and pass this\nobject to G.add_nodes_from .",
            "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_nodes_from(\"Hello\")\nK3=nx.Graph([(0,1),(1,2),(2,0)])\nG.add_nodes_from(K3)\nsorted(G.nodes(),key=str)\n# [0, 1, 2, 'H', 'e', 'l', 'o']\nUse keywords to update specific node attributes for every node.\nG.add_nodes_from([1,2],size=10)\nG.add_nodes_from([3,4],weight=0.4)\nUse (node, attrdict) tuples to update attributes for specific nodes.\nG.add_nodes_from([(1,dict(size=11)),(2,{\"color\":\"blue\"})])\nG.nodes[1][\"size\"]\n# 11\nH=nx.Graph()\nH.add_nodes_from(G.nodes(data=True))\nH.nodes[1][\"size\"]\n# 11\nEvaluate an iterator over a graph if using it to modify the same graph\nG=nx.Graph([(0,1),(1,2),(3,4)])\n# wrong way - will raise RuntimeError\n# G.add_nodes_from(n + 1 for n in G.nodes)\n# correct way\nG.add_nodes_from(list(n+1forninG.nodes))"
        },
        "Section_id": "MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Section ID": "remove_node"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Path": "networkx.MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Description": [
            "Remove node n.",
            "Removes the node n and all adjacent edges.\nAttempting to remove a nonexistent node will raise an exception."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "n : node": "A node in the graph"
            },
            "Raises:": {
                "NetworkXError": "If n is not in the graph."
            },
            "Methods": []
        },
        "Section_id": "MultiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(3)# or DiGraph, MultiGraph, MultiDiGraph, etc\nlist(G.edges)\n# [(0, 1), (1, 2)]\nG.remove_node(1)\nlist(G.edges)\n# []"
        },
        "Section_id": "MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Section ID": "remove_nodes_from"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Path": "networkx.MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Description": [
            "Remove multiple nodes."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "nodes : iterable container": "A container of nodes (list, dict, set, etc.).  If a node\nin the container is not in the graph it is silently\nignored."
            },
            "Methods": []
        },
        "Section_id": "MultiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "When removing nodes from an iterator over the graph you are changing,\na RuntimeError will be raised with message: RuntimeError:dictionarychangedsizeduringiteration . This\nhappens when the graph\u2019s underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using list(iterator_of_nodes) , and pass this\nobject to G.remove_nodes_from .",
            "Examples": "G=nx.path_graph(3)# or DiGraph, MultiGraph, MultiDiGraph, etc\ne=list(G.nodes)\ne\n# [0, 1, 2]\nG.remove_nodes_from(e)\nlist(G.nodes)\n# []\nEvaluate an iterator over a graph if using it to modify the same graph\nG=nx.Graph([(0,1),(1,2),(3,4)])\n# this command will fail, as the graph's dict is modified during iteration\n# G.remove_nodes_from(n for n in G.nodes if n < 2)\n# this command will work, since the dictionary underlying graph is not modified\nG.remove_nodes_from(list(nforninG.nodesifn<2))"
        },
        "Section_id": "MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Section ID": "add_edge"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Path": "networkx.MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Description": [
            "Add an edge between u and v.",
            "The nodes u and v will be automatically added if they are\nnot already in the graph.",
            "Edge attributes can be specified with keywords or by directly\naccessing the edge\u2019s attribute dictionary. See examples below."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "u_for_edge, v_for_edge : nodes": "Nodes can be, for example, strings or numbers.\nNodes must be hashable (and not None) Python objects.",
                "key : hashable identifier, optional (default=lowest unused integer)": "Used to distinguish multiedges between a pair of nodes.",
                "attr : keyword arguments, optional": "Edge data (or labels or objects) can be assigned using\nkeyword arguments."
            },
            "Returns:": {
                "The edge key assigned to the edge.": ""
            },
            "Methods": []
        },
        "Section_id": "MultiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "To replace/update edge data, use the optional key argument\nto identify a unique edge.  Otherwise a new edge will be created. NetworkX algorithms designed for weighted graphs cannot use\nmultigraphs directly because it is not clear how to handle\nmultiedge weights.  Convert to Graph using edge attribute\n\u2018weight\u2019 to enable weighted graph algorithms. Default keys are generated using the method new_edge_key() .\nThis method can be overridden by subclassing the base class and\nproviding a custom new_edge_key() method.",
            "Examples": "The following each add an additional edge e=(1, 2) to graph G:\nG=nx.MultiGraph()\ne=(1,2)\nekey=G.add_edge(1,2)# explicit two-node form\nG.add_edge(*e)# single edge as tuple of two nodes\n# 1\nG.add_edges_from([(1,2)])# add edges from iterable container\n# [2]\nAssociate data to edges using keywords:\nekey=G.add_edge(1,2,weight=3)\nekey=G.add_edge(1,2,key=0,weight=4)# update data for key=0\nekey=G.add_edge(1,3,weight=7,capacity=15,length=342.7)\nFor non-string attribute keys, use subscript notation.\nekey=G.add_edge(1,2)\nG[1][2][0].update({0:5})\nG.edges[1,2,0].update({0:5})"
        },
        "Section_id": "MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Section ID": "add_edges_from"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Path": "networkx.MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Description": [
            "Add all the edges in ebunch_to_add."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "ebunch_to_add : container of edges": "Each edge given in the container will be added to the\ngraph. The edges can be:2-tuples (u, v) or3-tuples (u, v, d) for an edge data dict d, or3-tuples (u, v, k) for not iterable key k, or4-tuples (u, v, k, d) for an edge with data and key k",
                "attr : keyword arguments, optional": "Edge data (or labels or objects) can be assigned using\nkeyword arguments."
            },
            "Returns:": {
                "A list of edge keys assigned to the edges in : ebunch : .": ""
            },
            "Methods": []
        },
        "Section_id": "MultiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "Adding the same edge twice has no effect but any edge data\nwill be updated when each duplicate edge is added. Edge attributes specified in an ebunch take precedence over\nattributes specified via keyword arguments. Default keys are generated using the method new_edge_key() .\nThis method can be overridden by subclassing the base class and\nproviding a custom new_edge_key() method. When adding edges from an iterator over the graph you are changing,\na RuntimeError can be raised with message: RuntimeError:dictionarychangedsizeduringiteration . This\nhappens when the graph\u2019s underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using list(iterator_of_edges) , and pass this\nobject to G.add_edges_from .",
            "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_edges_from([(0,1),(1,2)])# using a list of edge tuples\ne=zip(range(0,3),range(1,4))\nG.add_edges_from(e)# Add the path graph 0-1-2-3\nAssociate data to edges\nG.add_edges_from([(1,2),(2,3)],weight=3)\nG.add_edges_from([(3,4),(1,4)],label=\"WN2898\")\nEvaluate an iterator over a graph if using it to modify the same graph\nG=nx.MultiGraph([(1,2),(2,3),(3,4)])\n# Grow graph by one new node, adding edges to all existing nodes.\n# wrong way - will raise RuntimeError\n# G.add_edges_from(((5, n) for n in G.nodes))\n# right way - note that there will be no self-edge for node 5\nassigned_keys=G.add_edges_from(list((5,n)forninG.nodes))"
        },
        "Section_id": "MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Section ID": "add_weighted_edges_from"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Path": "networkx.MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Description": [
            "Add weighted edges in ebunch_to_add with specified weight attr"
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "ebunch_to_add : container of edges": "Each edge given in the list or container will be added\nto the graph. The edges must be given as 3-tuples (u, v, w)\nwhere w is a number.",
                "weight : string, optional (default= \u2018weight\u2019)": "The attribute name for the edge weights to be added.",
                "attr : keyword arguments, optional (default= no attributes)": "Edge attributes to add/update for all edges."
            },
            "Methods": []
        },
        "Section_id": "MultiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "Adding the same edge twice for Graph/DiGraph simply updates\nthe edge data. For MultiGraph/MultiDiGraph, duplicate edges\nare stored. When adding edges from an iterator over the graph you are changing,\na RuntimeError can be raised with message: RuntimeError:dictionarychangedsizeduringiteration . This\nhappens when the graph\u2019s underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using list(iterator_of_edges) , and pass this\nobject to G.add_weighted_edges_from .",
            "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_weighted_edges_from([(0,1,3.0),(1,2,7.5)])\nEvaluate an iterator over edges before passing it\nG=nx.Graph([(1,2),(2,3),(3,4)])\nweight=0.1\n# Grow graph by one new node, adding edges to all existing nodes.\n# wrong way - will raise RuntimeError\n# G.add_weighted_edges_from(((5, n, weight) for n in G.nodes))\n# correct way - note that there will be no self-edge for node 5\nG.add_weighted_edges_from(list((5,n,weight)forninG.nodes))"
        },
        "Section_id": "MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Section ID": "new_edge_key"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Path": "networkx.MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Description": [
            "Returns an unused key for edges between nodes u and v .",
            "The nodes u and v do not need to be already in the graph."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "u, v : nodes": ""
            },
            "Returns:": {
                "key : int": ""
            },
            "Methods": []
        },
        "Section_id": "MultiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "In the standard MultiGraph class the new key is the number of existing\nedges between u and v (increased if necessary to ensure unused).\nThe first edge will have key 0, then 1, etc. If an edge is removed\nfurther new_edge_keys may not be in this order."
        },
        "Section_id": "MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Section ID": "remove_edge"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Path": "networkx.MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Description": [
            "Remove an edge between u and v."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "u, v : nodes": "Remove an edge between nodes u and v.",
                "key : hashable identifier, optional (default=None)": "Used to distinguish multiple edges between a pair of nodes.\nIf None, remove a single edge between u and v. If there are\nmultiple edges, removes the last edge added in terms of\ninsertion order."
            },
            "Raises:": {
                "NetworkXError": "If there is not an edge between u and v, or\nif there is no edge with the specified key."
            },
            "Methods": []
        },
        "Section_id": "MultiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.MultiGraph()\nnx.add_path(G,[0,1,2,3])\nG.remove_edge(0,1)\ne=(1,2)\nG.remove_edge(*e)# unpacks e from an edge tuple\nFor multiple edges\nG=nx.MultiGraph()# or MultiDiGraph, etc\nG.add_edges_from([(1,2),(1,2),(1,2)])# key_list returned\n# [0, 1, 2]\nWhenkey=None(the default), edges are removed in the opposite\norder that they were added:\nG.remove_edge(1,2)\nG.edges(keys=True)\n# MultiEdgeView([(1, 2, 0), (1, 2, 1)])\nG.remove_edge(2,1)# edges are not directed\nG.edges(keys=True)\n# MultiEdgeView([(1, 2, 0)])\nFor edges with keys\nG=nx.MultiGraph()\nG.add_edge(1,2,key=\"first\")\n# 'first'\nG.add_edge(1,2,key=\"second\")\n# 'second'\nG.remove_edge(1,2,key=\"first\")\nG.edges(keys=True)\n# MultiEdgeView([(1, 2, 'second')])"
        },
        "Section_id": "MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Section ID": "remove_edges_from"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Path": "networkx.MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Description": [
            "Remove all edges specified in ebunch."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "ebunch: list or container of edge tuples": "Each edge given in the list or container will be removed\nfrom the graph. The edges can be:2-tuples (u, v) A single edge between u and v is removed.3-tuples (u, v, key) The edge identified by key is removed.4-tuples (u, v, key, data) where data is ignored."
            },
            "Methods": []
        },
        "Section_id": "MultiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "Will fail silently if an edge in ebunch is not in the graph.",
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nebunch=[(1,2),(2,3)]\nG.remove_edges_from(ebunch)\nRemoving multiple copies of edges\nG=nx.MultiGraph()\nkeys=G.add_edges_from([(1,2),(1,2),(1,2)])\nG.remove_edges_from([(1,2),(2,1)])# edges aren't directed\nlist(G.edges())\n# [(1, 2)]\nG.remove_edges_from([(1,2),(1,2)])# silently ignore extra copy\nlist(G.edges)# now empty graph\n# []\nWhen the edge is a 2-tuple(u,v)but there are multiple edges between\nu and v in the graph, the most recent edge (in terms of insertion\norder) is removed.\nG=nx.MultiGraph()\nforkeyin(\"x\",\"y\",\"a\"):\nk=G.add_edge(0,1,key=key)\nG.edges(keys=True)\n# MultiEdgeView([(0, 1, 'x'), (0, 1, 'y'), (0, 1, 'a')])\nG.remove_edges_from([(0,1)])\nG.edges(keys=True)\n# MultiEdgeView([(0, 1, 'x'), (0, 1, 'y')])"
        },
        "Section_id": "MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Section ID": "update"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Path": "networkx.MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Description": [
            "Update the graph using nodes/edges/graphs as input.",
            "Like dict.update, this method takes a graph as input, adding the\ngraph\u2019s nodes and edges to this graph. It can also take two inputs:\nedges and nodes. Finally it can take either edges or nodes.\nTo specify only nodes the keyword nodes must be used.",
            "The collections of edges and nodes are treated similarly to\nthe add_edges_from/add_nodes_from methods. When iterated, they\nshould yield 2-tuples (u, v) or 3-tuples (u, v, datadict)."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "edges : Graph object, collection of edges, or None": "The first parameter can be a graph or some edges. If it has\nattributesnodesandedges, then it is taken to be a\nGraph-like object and those attributes are used as collections\nof nodes and edges to be added to the graph.\nIf the first parameter does not have those attributes, it is\ntreated as a collection of edges and added to the graph.\nIf the first argument is None, no edges are added.",
                "nodes : collection of nodes, or None": "The second parameter is treated as a collection of nodes\nto be added to the graph unless it is None.\nIfedgesisNoneandnodesisNonean exception is raised.\nIf the first parameter is a Graph, thennodesis ignored."
            },
            "Methods": []
        },
        "Section_id": "MultiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "It you want to update the graph using an adjacency structure\nit is straightforward to obtain the edges/nodes from adjacency.\nThe following examples provide common cases, your adjacency may\nbe slightly different and require tweaks of these examples:",
            "Examples": "G=nx.path_graph(5)\nG.update(nx.complete_graph(range(4,10)))\nfromitertoolsimportcombinations\nedges=(\n(u,v,{\"power\":u*v})\nforu,vincombinations(range(10,20),2)\nifu*v<225\n)\nnodes=[1000]# for singleton, use a container\nG.update(edges,nodes)"
        },
        "Section_id": "MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Section ID": "clear"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Path": "networkx.MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Description": [
            "Remove all nodes and edges from the graph.",
            "This also removes the name, and all graph, node, and edge attributes.",
            "Examples"
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Methods": []
        },
        "Section_id": "MultiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.clear()\nlist(G.nodes)\n# []\nlist(G.edges)\n# []"
        },
        "Section_id": "MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Section ID": "clear_edges"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Path": "networkx.MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Description": [
            "Remove all edges from the graph without altering nodes.",
            "Examples"
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Methods": []
        },
        "Section_id": "MultiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.clear_edges()\nlist(G.nodes)\n# [0, 1, 2, 3]\nlist(G.edges)\n# []"
        },
        "Section_id": "MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Section ID": "nodes"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Path": "networkx.MultiGraph"
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "data : string or bool, optional (default=False)": "The node attribute returned in 2-tuple (n, ddict[data]).\nIf True, return entire node attribute dict as (n, ddict).\nIf False, return just the nodes n.",
                "default : value, optional (default=None)": "Value used for nodes that don\u2019t have the requested attribute.\nOnly relevant if data is not True or False."
            },
            "Returns:": {
                "NodeView": "Allows set-like operations over the nodes as well as node\nattribute dict lookup and calling to get a NodeDataView.\nA NodeDataView iterates over(n,data)and has no set operations.\nA NodeView iterates overnand includes set operations.When called, if data is False, an iterator over nodes.\nOtherwise an iterator of 2-tuples (node, attribute value)\nwhere the attribute is specified indata.\nIf data is True then the attribute becomes the\nentire data dictionary."
            },
            "Methods": []
        },
        "Section_id": "MultiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "If your node data is not needed, it is simpler and equivalent\nto use the expression forninG , or list(G) .",
            "Examples": "There are two simple ways of getting a list of all nodes in the graph:\nG=nx.path_graph(3)\nlist(G.nodes)\n# [0, 1, 2]\nlist(G)\n# [0, 1, 2]\nTo get the node data along with the nodes:\nG.add_node(1,time=\"5pm\")\nG.nodes[0][\"foo\"]=\"bar\"\nlist(G.nodes(data=True))\n# [(0, {'foo': 'bar'}), (1, {'time': '5pm'}), (2, {})]\nlist(G.nodes.data())\n# [(0, {'foo': 'bar'}), (1, {'time': '5pm'}), (2, {})]\nlist(G.nodes(data=\"foo\"))\n# [(0, 'bar'), (1, None), (2, None)]\nlist(G.nodes.data(\"foo\"))\n# [(0, 'bar'), (1, None), (2, None)]\nlist(G.nodes(data=\"time\"))\n# [(0, None), (1, '5pm'), (2, None)]\nlist(G.nodes.data(\"time\"))\n# [(0, None), (1, '5pm'), (2, None)]\nlist(G.nodes(data=\"time\",default=\"Not Available\"))\n# [(0, 'Not Available'), (1, '5pm'), (2, 'Not Available')]\nlist(G.nodes.data(\"time\",default=\"Not Available\"))\n# [(0, 'Not Available'), (1, '5pm'), (2, 'Not Available')]\nIf some of your nodes have an attribute and the rest are assumed\nto have a default attribute value you can create a dictionary\nfrom node/attribute pairs using thedefaultkeyword argument\nto guarantee the value is never None:\nG=nx.Graph()\nG.add_node(0)\nG.add_node(1,weight=2)\nG.add_node(2,weight=3)\ndict(G.nodes(data=\"weight\",default=1))\n# {0: 1, 1: 2, 2: 3}"
        },
        "Section_id": "MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Section ID": "__iter__"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Path": "networkx.MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Description": [
            "Iterate over the nodes. Use: \u2018for n in G\u2019."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Returns:": {
                "niter : iterator": "An iterator over all nodes in the graph."
            },
            "Methods": []
        },
        "Section_id": "MultiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\n[nforninG]\n# [0, 1, 2, 3]\nlist(G)\n# [0, 1, 2, 3]"
        },
        "Section_id": "MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Section ID": "has_node"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Path": "networkx.MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Description": [
            "Returns True if the graph contains the node n.",
            "Identical to ninG"
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "n : node": ""
            },
            "Methods": []
        },
        "Section_id": "MultiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(3)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.has_node(0)\n# True\nIt is more readable and simpler to use\n0inG\n# True"
        },
        "Section_id": "MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Section ID": "__contains__"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Path": "networkx.MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Description": [
            "Returns True if n is a node, False otherwise. Use: \u2018n in G\u2019.",
            "Examples"
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Methods": []
        },
        "Section_id": "MultiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\n1inG\n# True"
        },
        "Section_id": "MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Section ID": "edges"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Path": "networkx.MultiGraph"
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "nbunch : single node, container, or all nodes (default= all nodes)": "The view will only report edges from these nodes.",
                "data : string or bool, optional (default=False)": "The edge attribute returned in 3-tuple (u, v, ddict[data]).\nIf True, return edge attribute dict in 3-tuple (u, v, ddict).\nIf False, return 2-tuple (u, v).",
                "keys : bool, optional (default=False)": "If True, return edge keys with each edge, creating (u, v, k)\ntuples or (u, v, k, d) tuples if data is also requested.",
                "default : value, optional (default=None)": "Value used for edges that don\u2019t have the requested attribute.\nOnly relevant if data is not True or False."
            },
            "Returns:": {
                "edges : MultiEdgeView": "A view of edge attributes, usually it iterates over (u, v)\n(u, v, k) or (u, v, k, d) tuples of edges, but can also be\nused for attribute lookup asedges[u,v,k]['foo']."
            },
            "Methods": []
        },
        "Section_id": "MultiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "Nodes in nbunch that are not in the graph will be (quietly) ignored.\nFor directed graphs this returns the out-edges.",
            "Examples": "G=nx.MultiGraph()\nnx.add_path(G,[0,1,2])\nkey=G.add_edge(2,3,weight=5)\nkey2=G.add_edge(2,1,weight=2)# multi-edge\n[eforeinG.edges()]\n# [(0, 1), (1, 2), (1, 2), (2, 3)]\nG.edges.data()# default data is {} (empty dict)\n# MultiEdgeDataView([(0, 1, {}), (1, 2, {}), (1, 2, {'weight': 2}), (2, 3, {'weight': 5})])\nG.edges.data(\"weight\",default=1)\n# MultiEdgeDataView([(0, 1, 1), (1, 2, 1), (1, 2, 2), (2, 3, 5)])\nG.edges(keys=True)# default keys are integers\n# MultiEdgeView([(0, 1, 0), (1, 2, 0), (1, 2, 1), (2, 3, 0)])\nG.edges.data(keys=True)\n# MultiEdgeDataView([(0, 1, 0, {}), (1, 2, 0, {}), (1, 2, 1, {'weight': 2}), (2, 3, 0, {'weight': 5})])\nG.edges.data(\"weight\",default=1,keys=True)\n# MultiEdgeDataView([(0, 1, 0, 1), (1, 2, 0, 1), (1, 2, 1, 2), (2, 3, 0, 5)])\nG.edges([0,3])# Note ordering of tuples from listed sources\n# MultiEdgeDataView([(0, 1), (3, 2)])\nG.edges([0,3,2,1])# Note ordering of tuples\n# MultiEdgeDataView([(0, 1), (3, 2), (2, 1), (2, 1)])\nG.edges(0)\n# MultiEdgeDataView([(0, 1)])"
        },
        "Section_id": "MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Section ID": "has_edge"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Path": "networkx.MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Description": [
            "Returns True if the graph has an edge between nodes u and v.",
            "This is the same as vinG[u]orkeyinG[u][v] without KeyError exceptions."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "u, v : nodes": "Nodes can be, for example, strings or numbers.",
                "key : hashable identifier, optional (default=None)": "If specified return True only if the edge with\nkey is found."
            },
            "Returns:": {
                "edge_ind : bool": "True if edge is in the graph, False otherwise."
            },
            "Methods": []
        },
        "Section_id": "MultiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "Can be called either using two nodes u, v, an edge tuple (u, v),\nor an edge tuple (u, v, key).\nG=nx.MultiGraph()# or MultiDiGraph\nnx.add_path(G,[0,1,2,3])\nG.has_edge(0,1)# using two nodes\n# True\ne=(0,1)\nG.has_edge(*e)#  e is a 2-tuple (u, v)\n# True\nG.add_edge(0,1,key=\"a\")\n# 'a'\nG.has_edge(0,1,key=\"a\")# specify key\n# True\nG.has_edge(1,0,key=\"a\")# edges aren't directed\n# True\ne=(0,1,\"a\")\nG.has_edge(*e)# e is a 3-tuple (u, v, 'a')\n# True\nThe following syntax are equivalent:\nG.has_edge(0,1)\n# True\n1inG[0]# though this gives :exc:`KeyError` if 0 not in G\n# True\n0inG[1]# other order; also gives :exc:`KeyError` if 0 not in G\n# True"
        },
        "Section_id": "MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Section ID": "get_edge_data"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Path": "networkx.MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Description": [
            "Returns the attribute dictionary associated with edge (u, v,\nkey).",
            "If a key is not provided, returns a dictionary mapping edge keys\nto attribute dictionaries for each edge between u and v.",
            "This is identical to G[u][v][key] except the default is returned\ninstead of an exception is the edge doesn\u2019t exist."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "u, v : nodes": "",
                "default : any Python object (default=None)": "Value to return if the specific edge (u, v, key) is not\nfound, OR if there are no edges between u and v and no key\nis specified.",
                "key : hashable identifier, optional (default=None)": "Return data only for the edge with specified key, as an\nattribute dictionary (rather than a dictionary mapping keys\nto attribute dictionaries)."
            },
            "Returns:": {
                "edge_dict : dictionary": "The edge attribute dictionary, OR a dictionary mapping edge\nkeys to attribute dictionaries for each of those edges if no\nspecific key is provided (even if there\u2019s only one edge\nbetween u and v)."
            },
            "Methods": []
        },
        "Section_id": "MultiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.MultiGraph()# or MultiDiGraph\nkey=G.add_edge(0,1,key=\"a\",weight=7)\nG[0][1][\"a\"]# key='a'\n# {'weight': 7}\nG.edges[0,1,\"a\"]# key='a'\n# {'weight': 7}\nWarning: we protect the graph data structure by makingG.edgesandG[1][2]read-only dict-like structures.\nHowever, you can assign values to attributes in e.g.G.edges[1,2,'a']orG[1][2]['a']using an additional\nbracket as shown next. You need to specify all edge info\nto assign to the edge data associated with an edge.\nG[0][1][\"a\"][\"weight\"]=10\nG.edges[0,1,\"a\"][\"weight\"]=10\nG[0][1][\"a\"][\"weight\"]\n# 10\nG.edges[1,0,\"a\"][\"weight\"]\n# 10\nG=nx.MultiGraph()# or MultiDiGraph\nnx.add_path(G,[0,1,2,3])\nG.edges[0,1,0][\"weight\"]=5\nG.get_edge_data(0,1)\n# {0: {'weight': 5}}\ne=(0,1)\nG.get_edge_data(*e)# tuple form\n# {0: {'weight': 5}}\nG.get_edge_data(3,0)# edge not in graph, returns None\nG.get_edge_data(3,0,default=0)# edge not in graph, return default\n# 0\nG.get_edge_data(1,0,0)# specific key gives back\n# {'weight': 5}"
        },
        "Section_id": "MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Section ID": "neighbors"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Path": "networkx.MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Description": [
            "Returns an iterator over all neighbors of node n.",
            "This is identical to iter(G[n])"
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "n : node": "A node in the graph"
            },
            "Returns:": {
                "neighbors : iterator": "An iterator over all neighbors of node n"
            },
            "Raises:": {
                "NetworkXError": "If the node n is not in the graph."
            },
            "Methods": []
        },
        "Section_id": "MultiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "Alternate ways to access the neighbors are G.adj[n] or G[n] :",
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\n[nforninG.neighbors(0)]\n# [1]"
        },
        "Section_id": "MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Section ID": "adj"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Path": "networkx.MultiGraph"
    },
    {
        "Field List > Methods > Field List": {
            "Methods": []
        },
        "Section_id": "MultiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "e=[(1,2),(1,2),(1,3),(3,4)]# list of edges\nG=nx.MultiGraph(e)\nG.edges[1,2,0][\"weight\"]=3\nresult=set()\nforedgekey,datainG[1][2].items():\nresult.add(data.get(\"weight\",1))\nresult\n# {1, 3}\nFor directed graphs,G.adjholds outgoing (successor) info."
        },
        "Section_id": "MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Section ID": "__getitem__"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Path": "networkx.MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Description": [
            "Returns a dict of neighbors of node n.  Use: \u2018G[n]\u2019."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "n : node": "A node in the graph."
            },
            "Returns:": {
                "adj_dict : dictionary": "The adjacency dictionary for nodes connected to n."
            },
            "Methods": []
        },
        "Section_id": "MultiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "G[n] is the same as G.adj[n] and similar to G.neighbors(n)\n(which is an iterator over G.adj[n])",
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG[0]\n# AtlasView({1: {}})"
        },
        "Section_id": "MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Section ID": "adjacency"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Path": "networkx.MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Description": [
            "Returns an iterator over (node, adjacency dict) tuples for all nodes.",
            "For directed graphs, only outgoing neighbors/adjacencies are included."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Returns:": {
                "adj_iter : iterator": "An iterator over (node, adjacency dictionary) for all nodes in\nthe graph."
            },
            "Methods": []
        },
        "Section_id": "MultiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\n[(n,nbrdict)forn,nbrdictinG.adjacency()]\n# [(0, {1: {}}), (1, {0: {}, 2: {}}), (2, {1: {}, 3: {}}), (3, {2: {}})]"
        },
        "Section_id": "MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Section ID": "nbunch_iter"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Path": "networkx.MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Description": [
            "Returns an iterator over nodes contained in nbunch that are\nalso in the graph.",
            "The nodes in nbunch are checked for membership in the graph\nand if not are silently ignored."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "nbunch : single node, container, or all nodes (default= all nodes)": "The view will only report edges incident to these nodes."
            },
            "Returns:": {
                "niter : iterator": "An iterator over nodes in nbunch that are also in the graph.\nIf nbunch is None, iterate over all nodes in the graph."
            },
            "Raises:": {
                "NetworkXError": "If nbunch is not a node or sequence of nodes.\nIf a node in nbunch is not hashable."
            },
            "Methods": []
        },
        "Section_id": "MultiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "When nbunch is an iterator, the returned iterator yields values\ndirectly from nbunch, becoming exhausted when nbunch is exhausted. To test whether nbunch is a single node, one can use\n\u201cif nbunch in self:\u201d, even after processing with this routine. If nbunch is not a node or a (possibly empty) sequence/iterator\nor None, a NetworkXError is raised.  Also, if any object in\nnbunch is not hashable, a NetworkXError is raised."
        },
        "Section_id": "MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Section ID": "order"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Path": "networkx.MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Description": [
            "Returns the number of nodes in the graph."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Returns:": {
                "nnodes : int": "The number of nodes in the graph."
            },
            "Methods": []
        },
        "Section_id": "MultiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(3)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.order()\n# 3"
        },
        "Section_id": "MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Section ID": "number_of_nodes"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Path": "networkx.MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Description": [
            "Returns the number of nodes in the graph."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Returns:": {
                "nnodes : int": "The number of nodes in the graph."
            },
            "Methods": []
        },
        "Section_id": "MultiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(3)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.number_of_nodes()\n# 3"
        },
        "Section_id": "MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Section ID": "__len__"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Path": "networkx.MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Description": [
            "Returns the number of nodes in the graph. Use: \u2018len(G)\u2019."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Returns:": {
                "nnodes : int": "The number of nodes in the graph."
            },
            "Methods": []
        },
        "Section_id": "MultiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nlen(G)\n# 4"
        },
        "Section_id": "MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Section ID": "degree"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Path": "networkx.MultiGraph"
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "nbunch : single node, container, or all nodes (default= all nodes)": "The view will only report edges incident to these nodes.",
                "weight : string or None, optional (default=None)": "The name of an edge attribute that holds the numerical value used\nas a weight.  If None, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node."
            },
            "Returns:": {
                "MultiDegreeView or int": "If multiple nodes are requested (the default), returns aMultiDegreeViewmapping nodes to their degree.\nIf a single node is requested, returns the degree of the node as an integer."
            },
            "Methods": []
        },
        "Section_id": "MultiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nnx.add_path(G,[0,1,2,3])\nG.degree(0)# node 0 with degree 1\n# 1\nlist(G.degree([0,1]))\n# [(0, 1), (1, 2)]"
        },
        "Section_id": "MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Section ID": "size"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Path": "networkx.MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Description": [
            "Returns the number of edges or total of all edge weights."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "weight : string or None, optional (default=None)": "The edge attribute that holds the numerical value used\nas a weight. If None, then each edge has weight 1."
            },
            "Returns:": {
                "size : numeric": "The number of edges or\n(if weight keyword is provided) the total weight sum.If weight is None, returns an int. Otherwise a float\n(or more general numeric if the weights are more general)."
            },
            "Methods": []
        },
        "Section_id": "MultiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.size()\n# 3\nG=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_edge(\"a\",\"b\",weight=2)\nG.add_edge(\"b\",\"c\",weight=4)\nG.size()\n# 2\nG.size(weight=\"weight\")\n# 6.0"
        },
        "Section_id": "MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Section ID": "number_of_edges"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Path": "networkx.MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Description": [
            "Returns the number of edges between two nodes."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "u, v : nodes, optional (Default=all edges)": "If u and v are specified, return the number of edges between\nu and v. Otherwise return the total number of all edges."
            },
            "Returns:": {
                "nedges : int": "The number of edges in the graph.  If nodesuandvare\nspecified return the number of edges between those nodes. If\nthe graph is directed, this only returns the number of edges\nfromutov."
            },
            "Methods": []
        },
        "Section_id": "MultiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "For undirected multigraphs, this method counts the total number\nof edges in the graph:\nG=nx.MultiGraph()\nG.add_edges_from([(0,1),(0,1),(1,2)])\n# [0, 1, 0]\nG.number_of_edges()\n# 3\nIf you specify two nodes, this counts the total number of edges\njoining the two nodes:\nG.number_of_edges(0,1)\n# 2\nFor directed multigraphs, this method can count the total number\nof directed edges fromutov:\nG=nx.MultiDiGraph()\nG.add_edges_from([(0,1),(0,1),(1,0)])\n# [0, 1, 0]\nG.number_of_edges(0,1)\n# 2\nG.number_of_edges(1,0)\n# 1"
        },
        "Section_id": "MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Section ID": "copy"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Path": "networkx.MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Description": [
            "Returns a copy of the graph.",
            "The copy method by default returns an independent shallow copy\nof the graph and attributes. That is, if an attribute is a\ncontainer, that container is shared by the original an the copy.\nUse Python\u2019s copy.deepcopy for new containers.",
            "If as_view is True then a view is returned instead of a copy."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "as_view : bool, optional (default=False)": "If True, the returned graph-view provides a read-only view\nof the original graph without actually copying any data."
            },
            "Returns:": {
                "G : Graph": "A copy of the graph."
            },
            "Methods": []
        },
        "Section_id": "MultiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "All copies reproduce the graph structure, but data attributes\nmay be handled in different ways. There are four types of copies\nof a graph that people might want. Deepcopy \u2013 A \u201cdeepcopy\u201d copies the graph structure as well as\nall data attributes and any objects they might contain.\nThe entire graph object is new so that changes in the copy\ndo not affect the original object. (see Python\u2019s copy.deepcopy) Data Reference (Shallow) \u2013 For a shallow copy the graph structure\nis copied but the edge, node and graph attribute dicts are\nreferences to those in the original graph. This saves\ntime and memory but could cause confusion if you change an attribute\nin one graph and it changes the attribute in the other.\nNetworkX does not provide this level of shallow copy. Independent Shallow \u2013 This copy creates new independent attribute\ndicts and then does a shallow copy of the attributes. That is, any\nattributes that are containers are shared between the new graph\nand the original. This is exactly what dict.copy() provides.\nYou can obtain this style copy using:",
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nH=G.copy()"
        },
        "Section_id": "MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Section ID": "to_undirected"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Path": "networkx.MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Description": [
            "Returns an undirected copy of the graph."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Returns:": {
                "G : Graph/MultiGraph": "A deepcopy of the graph."
            },
            "Methods": []
        },
        "Section_id": "MultiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "This returns a \u201cdeepcopy\u201d of the edge, node, and\ngraph attributes which attempts to completely copy\nall of the data and references. This is in contrast to the similar G=nx.MultiGraph(D) which returns a shallow copy of the data. See the Python copy module for more information on shallow\nand deep copies, https://docs.python.org/3/library/copy.html . Warning: If you have subclassed MultiGraph to use dict-like\nobjects in the data structure, those changes do not transfer\nto the MultiGraph created by this method.",
            "Examples": "G=nx.MultiGraph([(0,1),(0,1),(1,2)])\nH=G.to_directed()\nlist(H.edges)\n# [(0, 1, 0), (0, 1, 1), (1, 0, 0), (1, 0, 1), (1, 2, 0), (2, 1, 0)]\nG2=H.to_undirected()\nlist(G2.edges)\n# [(0, 1, 0), (0, 1, 1), (1, 2, 0)]"
        },
        "Section_id": "MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Section ID": "to_directed"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Path": "networkx.MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Description": [
            "Returns a directed representation of the graph."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Returns:": {
                "G : MultiDiGraph": "A directed graph with the same name, same nodes, and with\neach edge (u, v, k, data) replaced by two directed edges\n(u, v, k, data) and (v, u, k, data)."
            },
            "Methods": []
        },
        "Section_id": "MultiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "This returns a \u201cdeepcopy\u201d of the edge, node, and\ngraph attributes which attempts to completely copy\nall of the data and references. This is in contrast to the similar D=MultiDiGraph(G) which\nreturns a shallow copy of the data. See the Python copy module for more information on shallow\nand deep copies, https://docs.python.org/3/library/copy.html . Warning: If you have subclassed MultiGraph to use dict-like objects\nin the data structure, those changes do not transfer to the\nMultiDiGraph created by this method.",
            "Examples": "G=nx.MultiGraph()\nG.add_edge(0,1)\n# 0\nG.add_edge(0,1)\n# 1\nH=G.to_directed()\nlist(H.edges)\n# [(0, 1, 0), (0, 1, 1), (1, 0, 0), (1, 0, 1)]\nIf already directed, return a (deep) copy\nG=nx.MultiDiGraph()\nG.add_edge(0,1)\n# 0\nH=G.to_directed()\nlist(H.edges)\n# [(0, 1, 0)]"
        },
        "Section_id": "MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Section ID": "subgraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Path": "networkx.MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Description": [
            "Returns a SubGraph view of the subgraph induced on nodes .",
            "The induced subgraph of the graph contains the nodes in nodes and the edges between those nodes."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "nodes : list, iterable": "A container of nodes which will be iterated through once."
            },
            "Returns:": {
                "G : SubGraph View": "A subgraph view of the graph. The graph structure cannot be\nchanged but node/edge attributes can and are shared with the\noriginal graph."
            },
            "Methods": []
        },
        "Section_id": "MultiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "The graph, edge and node attributes are shared with the original graph.\nChanges to the graph structure is ruled out by the view, but changes\nto attributes are reflected in the original graph. To create a subgraph with its own copy of the edge/node attributes use:\nG.subgraph(nodes).copy() For an inplace reduction of a graph to a subgraph you can remove nodes:\nG.remove_nodes_from([n for n in G if n not in set(nodes)]) Subgraph views are sometimes NOT what you want. In most cases where\nyou want to do more than simply look at the induced edges, it makes\nmore sense to just create the subgraph as its own graph with code like:",
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nH=G.subgraph([0,1,2])\nlist(H.edges)\n# [(0, 1), (1, 2)]"
        },
        "Section_id": "MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Section ID": "edge_subgraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Path": "networkx.MultiGraph"
    },
    {
        "Section_id": "MultiGraph",
        "Field List > Methods > Description": [
            "Returns the subgraph induced by the specified edges.",
            "The induced subgraph contains each edge in edges and each\nnode incident to any one of those edges."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "edges : iterable": "An iterable of edges in this graph."
            },
            "Returns:": {
                "G : Graph": "An edge-induced subgraph of this graph with the same edge\nattributes."
            },
            "Methods": []
        },
        "Section_id": "MultiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "The graph, edge, and node attributes in the returned subgraph\nview are references to the corresponding attributes in the original\ngraph. The view is read-only. To create a full graph version of the subgraph with its own copy\nof the edge or node attributes, use:",
            "Examples": "G=nx.path_graph(5)\nH=G.edge_subgraph([(0,1),(3,4)])\nlist(H.nodes)\n# [0, 1, 3, 4]\nlist(H.edges)\n# [(0, 1), (3, 4)]"
        },
        "Section_id": "MultiGraph"
    },
    {
        "Rubrics": {
            "Examples": "Create an empty graph structure (a \u201cnull graph\u201d) with no nodes and\nno edges.\nG=nx.MultiGraph()\nG can be grown in several ways.\nNodes:\nAdd one node at a time:\nG.add_node(1)\nAdd the nodes from any container (a list, dict, set or\neven the lines from a file or the nodes from another graph).\nG.add_nodes_from([2,3])\nG.add_nodes_from(range(100,110))\nH=nx.path_graph(10)\nG.add_nodes_from(H)\nIn addition to strings and integers any hashable Python object\n(except None) can represent a node, e.g. a customized node object,\nor even another Graph.\nG.add_node(H)\nEdges:\nG can also be grown by adding edges.\nAdd one edge,\nkey=G.add_edge(1,2)\na list of edges,\nkeys=G.add_edges_from([(1,2),(1,3)])\nor a collection of edges,\nkeys=G.add_edges_from(H.edges)\nIf some edges connect nodes not yet in the graph, the nodes\nare added automatically.  If an edge already exists, an additional\nedge is created and stored using a key to identify the edge.\nBy default the key is the lowest unused integer.\nkeys=G.add_edges_from([(4,5,{\"route\":28}),(4,5,{\"route\":37})])\nG[4]\n# AdjacencyView({3: {0: {}}, 5: {0: {}, 1: {'route': 28}, 2: {'route': 37}}})\nAttributes:\nEach graph, node, and edge can hold key/value attribute pairs\nin an associated attribute dictionary (the keys must be hashable).\nBy default these are empty, but can be added or changed using\nadd_edge, add_node or direct manipulation of the attribute\ndictionaries named graph, node and edge respectively.\nG=nx.MultiGraph(day=\"Friday\")\nG.graph\n# {'day': 'Friday'}\nAdd node attributes using add_node(), add_nodes_from() or G.nodes\nG.add_node(1,time=\"5pm\")\nG.add_nodes_from([3],time=\"2pm\")\nG.nodes[1]\n# {'time': '5pm'}\nG.nodes[1][\"room\"]=714\ndelG.nodes[1][\"room\"]# remove attribute\nlist(G.nodes(data=True))\n# [(1, {'time': '5pm'}), (3, {'time': '2pm'})]\nAdd edge attributes using add_edge(), add_edges_from(), subscript\nnotation, or G.edges.\nkey=G.add_edge(1,2,weight=4.7)\nkeys=G.add_edges_from([(3,4),(4,5)],color=\"red\")\nkeys=G.add_edges_from([(1,2,{\"color\":\"blue\"}),(2,3,{\"weight\":8})])\nG[1][2][0][\"weight\"]=4.7\nG.edges[1,2,0][\"weight\"]=4\nWarning: we protect the graph data structure by makingG.edges[1,2,0]a read-only dict-like structure. However, you can assign to\nattributes in e.g.G.edges[1,2,0]. Thus, use 2 sets of brackets\nto add/change data attributes:G.edges[1,2,0]['weight']=4.\nShortcuts:\nMany common graph features allow python syntax to speed reporting.\n1inG# check if node in graph\n# True\n[nforninGifn<3]# iterate through nodes\n# [1, 2]\nlen(G)# number of nodes in graph\n# 5\nG[1]# adjacency dict-like view mapping neighbor -> edge key -> edge attributes\n# AdjacencyView({2: {0: {'weight': 4}, 1: {'color': 'blue'}}})\nOften the best way to traverse all edges of a graph is via the neighbors.\nThe neighbors are reported as an adjacency-dictG.adjorG.adjacency().\nforn,nbrsdictinG.adjacency():\nfornbr,keydictinnbrsdict.items():\nforkey,eattrinkeydict.items():\nif\"weight\"ineattr:\n# Do something useful with the edges\npass\nBut the edges() method is often more convenient:\nforu,v,keys,weightinG.edges(data=\"weight\",keys=True):\nifweightisnotNone:\n# Do something useful with the edges\npass\nReporting:\nSimple graph information is obtained using methods and object-attributes.\nReporting usually provides views instead of containers to reduce memory\nusage. The views update as the graph is updated similarly to dict-views.\nThe objectsnodes,edgesandadjprovide access to data attributes\nvia lookup (e.g.nodes[n],edges[u,v,k],adj[u][v]) and iteration\n(e.g.nodes.items(),nodes.data('color'),nodes.data('color',default='blue')and similarly foredges)\nViews exist fornodes,edges,neighbors()/adjanddegree.\nFor details on these and other miscellaneous methods, see below.\nSubclasses (Advanced):\nThe MultiGraph class uses a dict-of-dict-of-dict-of-dict data structure.\nThe outer dict (node_dict) holds adjacency information keyed by node.\nThe next dict (adjlist_dict) represents the adjacency information\nand holds edge_key dicts keyed by neighbor. The edge_key dict holds\neach edge_attr dict keyed by edge key. The inner dict\n(edge_attr_dict) represents the edge data and holds edge attribute\nvalues keyed by attribute names.\nEach of these four dicts in the dict-of-dict-of-dict-of-dict\nstructure can be replaced by a user defined dict-like object.\nIn general, the dict-like features should be maintained but\nextra features can be added. To replace one of the dicts create\na new graph class by changing the class(!) variable holding the\nfactory for that dict-like structure. The variable names are\nnode_dict_factory, node_attr_dict_factory, adjlist_inner_dict_factory,\nadjlist_outer_dict_factory, edge_key_dict_factory, edge_attr_dict_factory\nand graph_attr_dict_factory."
        },
        "Section_id": "MultiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Section ID": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Description": [
            "A directed graph class that can store multiedges.",
            "Multiedges are multiple edges between two nodes.  Each edge\ncan hold optional data or attributes.",
            "A MultiDiGraph holds directed edges.  Self loops are allowed.",
            "Nodes can be arbitrary (hashable) Python objects with optional\nkey/value attributes. By convention None is not used as a node.",
            "Edges are represented as links between nodes with optional\nkey/value attributes."
        ]
    },
    {
        "Field List > Parameters:": {
            "incoming_graph_data : input graph (optional, default: None)": "Data to initialize graph. If None (default) an empty\ngraph is created.  The data can be any format that is supported\nby the to_networkx_graph() function, currently including edge list,\ndict of dicts, dict of lists, NetworkX graph, 2D NumPy array, SciPy\nsparse matrix, or PyGraphviz graph.",
            "multigraph_input : bool or None (default None)": "Note: Only used whenincoming_graph_datais a dict.\nIf True,incoming_graph_datais assumed to be a\ndict-of-dict-of-dict-of-dict structure keyed by\nnode to neighbor to edge keys to edge data for multi-edges.\nA NetworkXError is raised if this is not the case.\nIf False,to_networkx_graph()is used to try to determine\nthe dict\u2019s graph data structure as either a dict-of-dict-of-dict\nkeyed by node to neighbor to edge data, or a dict-of-iterable\nkeyed by node to neighbors.\nIf None, the treatment for True is tried, but if it fails,\nthe treatment for False is tried.",
            "attr : keyword arguments, optional (default= no attributes)": "Attributes to add to graph as key=value pairs."
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "__init__"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Description": [
            "Initialize a graph with edges, name, or graph attributes."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "incoming_graph_data : input graph": "Data to initialize graph.  If incoming_graph_data=None (default)\nan empty graph is created.  The data can be an edge list, or any\nNetworkX graph object.  If the corresponding optional Python\npackages are installed the data can also be a 2D NumPy array, a\nSciPy sparse array, or a PyGraphviz graph.",
                "multigraph_input : bool or None (default None)": "Note: Only used whenincoming_graph_datais a dict.\nIf True,incoming_graph_datais assumed to be a\ndict-of-dict-of-dict-of-dict structure keyed by\nnode to neighbor to edge keys to edge data for multi-edges.\nA NetworkXError is raised if this is not the case.\nIf False,to_networkx_graph()is used to try to determine\nthe dict\u2019s graph data structure as either a dict-of-dict-of-dict\nkeyed by node to neighbor to edge data, or a dict-of-iterable\nkeyed by node to neighbors.\nIf None, the treatment for True is tried, but if it fails,\nthe treatment for False is tried.",
                "attr : keyword arguments, optional (default= no attributes)": "Attributes to add to graph as key=value pairs."
            },
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG=nx.Graph(name=\"my graph\")\ne=[(1,2),(2,3),(3,4)]# list of edges\nG=nx.Graph(e)\nArbitrary graph attribute pairs (key=value) may be assigned\nG=nx.Graph(e,day=\"Friday\")\nG.graph\n# {'day': 'Friday'}"
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "add_node"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Description": [
            "Add a single node node_for_adding and update node attributes."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "node_for_adding : node": "A node can be any hashable Python object except None.",
                "attr : keyword arguments, optional": "Set or change node attributes using key=value."
            },
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "A hashable object is one that can be used as a key in a Python\ndictionary. This includes strings, numbers, tuples of strings\nand numbers, etc. On many platforms hashable items also include mutables such as\nNetworkX Graphs, though one should be careful that the hash\ndoesn\u2019t change on mutables.",
            "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_node(1)\nG.add_node(\"Hello\")\nK3=nx.Graph([(0,1),(1,2),(2,0)])\nG.add_node(K3)\nG.number_of_nodes()\n# 3\nUse keywords set/change node attributes:\nG.add_node(1,size=10)\nG.add_node(3,weight=0.4,UTM=(\"13S\",382871,3972649))"
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "add_nodes_from"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Description": [
            "Add multiple nodes."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "nodes_for_adding : iterable container": "A container of nodes (list, dict, set, etc.).\nOR\nA container of (node, attribute dict) tuples.\nNode attributes are updated using the attribute dict.",
                "attr : keyword arguments, optional (default= no attributes)": "Update attributes for all nodes in nodes.\nNode attributes specified in nodes as a tuple take\nprecedence over attributes specified via keyword arguments."
            },
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "When adding nodes from an iterator over the graph you are changing,\na RuntimeError can be raised with message: RuntimeError:dictionarychangedsizeduringiteration . This\nhappens when the graph\u2019s underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using list(iterator_of_nodes) , and pass this\nobject to G.add_nodes_from .",
            "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_nodes_from(\"Hello\")\nK3=nx.Graph([(0,1),(1,2),(2,0)])\nG.add_nodes_from(K3)\nsorted(G.nodes(),key=str)\n# [0, 1, 2, 'H', 'e', 'l', 'o']\nUse keywords to update specific node attributes for every node.\nG.add_nodes_from([1,2],size=10)\nG.add_nodes_from([3,4],weight=0.4)\nUse (node, attrdict) tuples to update attributes for specific nodes.\nG.add_nodes_from([(1,dict(size=11)),(2,{\"color\":\"blue\"})])\nG.nodes[1][\"size\"]\n# 11\nH=nx.Graph()\nH.add_nodes_from(G.nodes(data=True))\nH.nodes[1][\"size\"]\n# 11\nEvaluate an iterator over a graph if using it to modify the same graph\nG=nx.DiGraph([(0,1),(1,2),(3,4)])\n# wrong way - will raise RuntimeError\n# G.add_nodes_from(n + 1 for n in G.nodes)\n# correct way\nG.add_nodes_from(list(n+1forninG.nodes))"
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "remove_node"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Description": [
            "Remove node n.",
            "Removes the node n and all adjacent edges.\nAttempting to remove a nonexistent node will raise an exception."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "n : node": "A node in the graph"
            },
            "Raises:": {
                "NetworkXError": "If n is not in the graph."
            },
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(3)# or DiGraph, MultiGraph, MultiDiGraph, etc\nlist(G.edges)\n# [(0, 1), (1, 2)]\nG.remove_node(1)\nlist(G.edges)\n# []"
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "remove_nodes_from"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Description": [
            "Remove multiple nodes."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "nodes : iterable container": "A container of nodes (list, dict, set, etc.).  If a node\nin the container is not in the graph it is silently ignored."
            },
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "When removing nodes from an iterator over the graph you are changing,\na RuntimeError will be raised with message: RuntimeError:dictionarychangedsizeduringiteration . This\nhappens when the graph\u2019s underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using list(iterator_of_nodes) , and pass this\nobject to G.remove_nodes_from .",
            "Examples": "G=nx.path_graph(3)# or DiGraph, MultiGraph, MultiDiGraph, etc\ne=list(G.nodes)\ne\n# [0, 1, 2]\nG.remove_nodes_from(e)\nlist(G.nodes)\n# []\nEvaluate an iterator over a graph if using it to modify the same graph\nG=nx.DiGraph([(0,1),(1,2),(3,4)])\n# this command will fail, as the graph's dict is modified during iteration\n# G.remove_nodes_from(n for n in G.nodes if n < 2)\n# this command will work, since the dictionary underlying graph is not modified\nG.remove_nodes_from(list(nforninG.nodesifn<2))"
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "add_edge"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Description": [
            "Add an edge between u and v.",
            "The nodes u and v will be automatically added if they are\nnot already in the graph.",
            "Edge attributes can be specified with keywords or by directly\naccessing the edge\u2019s attribute dictionary. See examples below."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "u_for_edge, v_for_edge : nodes": "Nodes can be, for example, strings or numbers.\nNodes must be hashable (and not None) Python objects.",
                "key : hashable identifier, optional (default=lowest unused integer)": "Used to distinguish multiedges between a pair of nodes.",
                "attr : keyword arguments, optional": "Edge data (or labels or objects) can be assigned using\nkeyword arguments."
            },
            "Returns:": {
                "The edge key assigned to the edge.": ""
            },
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "To replace/update edge data, use the optional key argument\nto identify a unique edge.  Otherwise a new edge will be created. NetworkX algorithms designed for weighted graphs cannot use\nmultigraphs directly because it is not clear how to handle\nmultiedge weights.  Convert to Graph using edge attribute\n\u2018weight\u2019 to enable weighted graph algorithms. Default keys are generated using the method new_edge_key() .\nThis method can be overridden by subclassing the base class and\nproviding a custom new_edge_key() method.",
            "Examples": "The following all add the edge e=(1, 2) to graph G:\nG=nx.MultiDiGraph()\ne=(1,2)\nkey=G.add_edge(1,2)# explicit two-node form\nG.add_edge(*e)# single edge as tuple of two nodes\n# 1\nG.add_edges_from([(1,2)])# add edges from iterable container\n# [2]\nAssociate data to edges using keywords:\nkey=G.add_edge(1,2,weight=3)\nkey=G.add_edge(1,2,key=0,weight=4)# update data for key=0\nkey=G.add_edge(1,3,weight=7,capacity=15,length=342.7)\nFor non-string attribute keys, use subscript notation.\nekey=G.add_edge(1,2)\nG[1][2][0].update({0:5})\nG.edges[1,2,0].update({0:5})"
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "add_edges_from"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Description": [
            "Add all the edges in ebunch_to_add."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "ebunch_to_add : container of edges": "Each edge given in the container will be added to the\ngraph. The edges can be:2-tuples (u, v) or3-tuples (u, v, d) for an edge data dict d, or3-tuples (u, v, k) for not iterable key k, or4-tuples (u, v, k, d) for an edge with data and key k",
                "attr : keyword arguments, optional": "Edge data (or labels or objects) can be assigned using\nkeyword arguments."
            },
            "Returns:": {
                "A list of edge keys assigned to the edges in : ebunch : .": ""
            },
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "Adding the same edge twice has no effect but any edge data\nwill be updated when each duplicate edge is added. Edge attributes specified in an ebunch take precedence over\nattributes specified via keyword arguments. Default keys are generated using the method new_edge_key() .\nThis method can be overridden by subclassing the base class and\nproviding a custom new_edge_key() method. When adding edges from an iterator over the graph you are changing,\na RuntimeError can be raised with message: RuntimeError:dictionarychangedsizeduringiteration . This\nhappens when the graph\u2019s underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using list(iterator_of_edges) , and pass this\nobject to G.add_edges_from .",
            "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_edges_from([(0,1),(1,2)])# using a list of edge tuples\ne=zip(range(0,3),range(1,4))\nG.add_edges_from(e)# Add the path graph 0-1-2-3\nAssociate data to edges\nG.add_edges_from([(1,2),(2,3)],weight=3)\nG.add_edges_from([(3,4),(1,4)],label=\"WN2898\")\nEvaluate an iterator over a graph if using it to modify the same graph\nG=nx.MultiGraph([(1,2),(2,3),(3,4)])\n# Grow graph by one new node, adding edges to all existing nodes.\n# wrong way - will raise RuntimeError\n# G.add_edges_from(((5, n) for n in G.nodes))\n# right way - note that there will be no self-edge for node 5\nassigned_keys=G.add_edges_from(list((5,n)forninG.nodes))"
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "add_weighted_edges_from"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Description": [
            "Add weighted edges in ebunch_to_add with specified weight attr"
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "ebunch_to_add : container of edges": "Each edge given in the list or container will be added\nto the graph. The edges must be given as 3-tuples (u, v, w)\nwhere w is a number.",
                "weight : string, optional (default= \u2018weight\u2019)": "The attribute name for the edge weights to be added.",
                "attr : keyword arguments, optional (default= no attributes)": "Edge attributes to add/update for all edges."
            },
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "Adding the same edge twice for Graph/DiGraph simply updates\nthe edge data. For MultiGraph/MultiDiGraph, duplicate edges\nare stored. When adding edges from an iterator over the graph you are changing,\na RuntimeError can be raised with message: RuntimeError:dictionarychangedsizeduringiteration . This\nhappens when the graph\u2019s underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using list(iterator_of_edges) , and pass this\nobject to G.add_weighted_edges_from .",
            "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_weighted_edges_from([(0,1,3.0),(1,2,7.5)])\nEvaluate an iterator over edges before passing it\nG=nx.Graph([(1,2),(2,3),(3,4)])\nweight=0.1\n# Grow graph by one new node, adding edges to all existing nodes.\n# wrong way - will raise RuntimeError\n# G.add_weighted_edges_from(((5, n, weight) for n in G.nodes))\n# correct way - note that there will be no self-edge for node 5\nG.add_weighted_edges_from(list((5,n,weight)forninG.nodes))"
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "new_edge_key"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Description": [
            "Returns an unused key for edges between nodes u and v .",
            "The nodes u and v do not need to be already in the graph."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "u, v : nodes": ""
            },
            "Returns:": {
                "key : int": ""
            },
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "In the standard MultiGraph class the new key is the number of existing\nedges between u and v (increased if necessary to ensure unused).\nThe first edge will have key 0, then 1, etc. If an edge is removed\nfurther new_edge_keys may not be in this order."
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "remove_edge"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Description": [
            "Remove an edge between u and v."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "u, v : nodes": "Remove an edge between nodes u and v.",
                "key : hashable identifier, optional (default=None)": "Used to distinguish multiple edges between a pair of nodes.\nIf None, remove a single edge between u and v. If there are\nmultiple edges, removes the last edge added in terms of\ninsertion order."
            },
            "Raises:": {
                "NetworkXError": "If there is not an edge between u and v, or\nif there is no edge with the specified key."
            },
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.MultiDiGraph()\nnx.add_path(G,[0,1,2,3])\nG.remove_edge(0,1)\ne=(1,2)\nG.remove_edge(*e)# unpacks e from an edge tuple\nFor multiple edges\nG=nx.MultiDiGraph()\nG.add_edges_from([(1,2),(1,2),(1,2)])# key_list returned\n# [0, 1, 2]\nWhenkey=None(the default), edges are removed in the opposite\norder that they were added:\nG.remove_edge(1,2)\nG.edges(keys=True)\n# OutMultiEdgeView([(1, 2, 0), (1, 2, 1)])\nFor edges with keys\nG=nx.MultiDiGraph()\nG.add_edge(1,2,key=\"first\")\n# 'first'\nG.add_edge(1,2,key=\"second\")\n# 'second'\nG.remove_edge(1,2,key=\"first\")\nG.edges(keys=True)\n# OutMultiEdgeView([(1, 2, 'second')])"
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "remove_edges_from"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Description": [
            "Remove all edges specified in ebunch."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "ebunch: list or container of edge tuples": "Each edge given in the list or container will be removed\nfrom the graph. The edges can be:2-tuples (u, v) A single edge between u and v is removed.3-tuples (u, v, key) The edge identified by key is removed.4-tuples (u, v, key, data) where data is ignored."
            },
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "Will fail silently if an edge in ebunch is not in the graph.",
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nebunch=[(1,2),(2,3)]\nG.remove_edges_from(ebunch)\nRemoving multiple copies of edges\nG=nx.MultiGraph()\nkeys=G.add_edges_from([(1,2),(1,2),(1,2)])\nG.remove_edges_from([(1,2),(2,1)])# edges aren't directed\nlist(G.edges())\n# [(1, 2)]\nG.remove_edges_from([(1,2),(1,2)])# silently ignore extra copy\nlist(G.edges)# now empty graph\n# []\nWhen the edge is a 2-tuple(u,v)but there are multiple edges between\nu and v in the graph, the most recent edge (in terms of insertion\norder) is removed.\nG=nx.MultiGraph()\nforkeyin(\"x\",\"y\",\"a\"):\nk=G.add_edge(0,1,key=key)\nG.edges(keys=True)\n# MultiEdgeView([(0, 1, 'x'), (0, 1, 'y'), (0, 1, 'a')])\nG.remove_edges_from([(0,1)])\nG.edges(keys=True)\n# MultiEdgeView([(0, 1, 'x'), (0, 1, 'y')])"
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "update"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Description": [
            "Update the graph using nodes/edges/graphs as input.",
            "Like dict.update, this method takes a graph as input, adding the\ngraph\u2019s nodes and edges to this graph. It can also take two inputs:\nedges and nodes. Finally it can take either edges or nodes.\nTo specify only nodes the keyword nodes must be used.",
            "The collections of edges and nodes are treated similarly to\nthe add_edges_from/add_nodes_from methods. When iterated, they\nshould yield 2-tuples (u, v) or 3-tuples (u, v, datadict)."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "edges : Graph object, collection of edges, or None": "The first parameter can be a graph or some edges. If it has\nattributesnodesandedges, then it is taken to be a\nGraph-like object and those attributes are used as collections\nof nodes and edges to be added to the graph.\nIf the first parameter does not have those attributes, it is\ntreated as a collection of edges and added to the graph.\nIf the first argument is None, no edges are added.",
                "nodes : collection of nodes, or None": "The second parameter is treated as a collection of nodes\nto be added to the graph unless it is None.\nIfedgesisNoneandnodesisNonean exception is raised.\nIf the first parameter is a Graph, thennodesis ignored."
            },
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "It you want to update the graph using an adjacency structure\nit is straightforward to obtain the edges/nodes from adjacency.\nThe following examples provide common cases, your adjacency may\nbe slightly different and require tweaks of these examples:",
            "Examples": "G=nx.path_graph(5)\nG.update(nx.complete_graph(range(4,10)))\nfromitertoolsimportcombinations\nedges=(\n(u,v,{\"power\":u*v})\nforu,vincombinations(range(10,20),2)\nifu*v<225\n)\nnodes=[1000]# for singleton, use a container\nG.update(edges,nodes)"
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "clear"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Description": [
            "Remove all nodes and edges from the graph.",
            "This also removes the name, and all graph, node, and edge attributes.",
            "Examples"
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.clear()\nlist(G.nodes)\n# []\nlist(G.edges)\n# []"
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "clear_edges"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Description": [
            "Remove all edges from the graph without altering nodes.",
            "Examples"
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.clear_edges()\nlist(G.nodes)\n# [0, 1, 2, 3]\nlist(G.edges)\n# []"
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "nodes"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "data : string or bool, optional (default=False)": "The node attribute returned in 2-tuple (n, ddict[data]).\nIf True, return entire node attribute dict as (n, ddict).\nIf False, return just the nodes n.",
                "default : value, optional (default=None)": "Value used for nodes that don\u2019t have the requested attribute.\nOnly relevant if data is not True or False."
            },
            "Returns:": {
                "NodeView": "Allows set-like operations over the nodes as well as node\nattribute dict lookup and calling to get a NodeDataView.\nA NodeDataView iterates over(n,data)and has no set operations.\nA NodeView iterates overnand includes set operations.When called, if data is False, an iterator over nodes.\nOtherwise an iterator of 2-tuples (node, attribute value)\nwhere the attribute is specified indata.\nIf data is True then the attribute becomes the\nentire data dictionary."
            },
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "If your node data is not needed, it is simpler and equivalent\nto use the expression forninG , or list(G) .",
            "Examples": "There are two simple ways of getting a list of all nodes in the graph:\nG=nx.path_graph(3)\nlist(G.nodes)\n# [0, 1, 2]\nlist(G)\n# [0, 1, 2]\nTo get the node data along with the nodes:\nG.add_node(1,time=\"5pm\")\nG.nodes[0][\"foo\"]=\"bar\"\nlist(G.nodes(data=True))\n# [(0, {'foo': 'bar'}), (1, {'time': '5pm'}), (2, {})]\nlist(G.nodes.data())\n# [(0, {'foo': 'bar'}), (1, {'time': '5pm'}), (2, {})]\nlist(G.nodes(data=\"foo\"))\n# [(0, 'bar'), (1, None), (2, None)]\nlist(G.nodes.data(\"foo\"))\n# [(0, 'bar'), (1, None), (2, None)]\nlist(G.nodes(data=\"time\"))\n# [(0, None), (1, '5pm'), (2, None)]\nlist(G.nodes.data(\"time\"))\n# [(0, None), (1, '5pm'), (2, None)]\nlist(G.nodes(data=\"time\",default=\"Not Available\"))\n# [(0, 'Not Available'), (1, '5pm'), (2, 'Not Available')]\nlist(G.nodes.data(\"time\",default=\"Not Available\"))\n# [(0, 'Not Available'), (1, '5pm'), (2, 'Not Available')]\nIf some of your nodes have an attribute and the rest are assumed\nto have a default attribute value you can create a dictionary\nfrom node/attribute pairs using thedefaultkeyword argument\nto guarantee the value is never None:\nG=nx.Graph()\nG.add_node(0)\nG.add_node(1,weight=2)\nG.add_node(2,weight=3)\ndict(G.nodes(data=\"weight\",default=1))\n# {0: 1, 1: 2, 2: 3}"
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "__iter__"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Description": [
            "Iterate over the nodes. Use: \u2018for n in G\u2019."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Returns:": {
                "niter : iterator": "An iterator over all nodes in the graph."
            },
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\n[nforninG]\n# [0, 1, 2, 3]\nlist(G)\n# [0, 1, 2, 3]"
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "has_node"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Description": [
            "Returns True if the graph contains the node n.",
            "Identical to ninG"
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "n : node": ""
            },
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(3)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.has_node(0)\n# True\nIt is more readable and simpler to use\n0inG\n# True"
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "__contains__"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Description": [
            "Returns True if n is a node, False otherwise. Use: \u2018n in G\u2019.",
            "Examples"
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\n1inG\n# True"
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "edges"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "nbunch : single node, container, or all nodes (default= all nodes)": "The view will only report edges from these nodes.",
                "data : string or bool, optional (default=False)": "The edge attribute returned in 3-tuple (u, v, ddict[data]).\nIf True, return edge attribute dict in 3-tuple (u, v, ddict).\nIf False, return 2-tuple (u, v).",
                "keys : bool, optional (default=False)": "If True, return edge keys with each edge, creating (u, v, k,\nd) tuples when data is also requested (the default) and (u,\nv, k) tuples when data is not requested.",
                "default : value, optional (default=None)": "Value used for edges that don\u2019t have the requested attribute.\nOnly relevant if data is not True or False."
            },
            "Returns:": {
                "edges : OutMultiEdgeView": "A view of edge attributes, usually it iterates over (u, v)\n(u, v, k) or (u, v, k, d) tuples of edges, but can also be\nused for attribute lookup asedges[u,v,k]['foo']."
            },
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "Nodes in nbunch that are not in the graph will be (quietly) ignored.\nFor directed graphs this returns the out-edges.",
            "Examples": "G=nx.MultiDiGraph()\nnx.add_path(G,[0,1,2])\nkey=G.add_edge(2,3,weight=5)\nkey2=G.add_edge(1,2)# second edge between these nodes\n[eforeinG.edges()]\n# [(0, 1), (1, 2), (1, 2), (2, 3)]\nlist(G.edges(data=True))# default data is {} (empty dict)\n# [(0, 1, {}), (1, 2, {}), (1, 2, {}), (2, 3, {'weight': 5})]\nlist(G.edges(data=\"weight\",default=1))\n# [(0, 1, 1), (1, 2, 1), (1, 2, 1), (2, 3, 5)]\nlist(G.edges(keys=True))# default keys are integers\n# [(0, 1, 0), (1, 2, 0), (1, 2, 1), (2, 3, 0)]\nlist(G.edges(data=True,keys=True))\n# [(0, 1, 0, {}), (1, 2, 0, {}), (1, 2, 1, {}), (2, 3, 0, {'weight': 5})]\nlist(G.edges(data=\"weight\",default=1,keys=True))\n# [(0, 1, 0, 1), (1, 2, 0, 1), (1, 2, 1, 1), (2, 3, 0, 5)]\nlist(G.edges([0,2]))\n# [(0, 1), (2, 3)]\nlist(G.edges(0))\n# [(0, 1)]\nlist(G.edges(1))\n# [(1, 2), (1, 2)]"
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "out_edges"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "nbunch : single node, container, or all nodes (default= all nodes)": "The view will only report edges from these nodes.",
                "data : string or bool, optional (default=False)": "The edge attribute returned in 3-tuple (u, v, ddict[data]).\nIf True, return edge attribute dict in 3-tuple (u, v, ddict).\nIf False, return 2-tuple (u, v).",
                "keys : bool, optional (default=False)": "If True, return edge keys with each edge, creating (u, v, k,\nd) tuples when data is also requested (the default) and (u,\nv, k) tuples when data is not requested.",
                "default : value, optional (default=None)": "Value used for edges that don\u2019t have the requested attribute.\nOnly relevant if data is not True or False."
            },
            "Returns:": {
                "edges : OutMultiEdgeView": "A view of edge attributes, usually it iterates over (u, v)\n(u, v, k) or (u, v, k, d) tuples of edges, but can also be\nused for attribute lookup asedges[u,v,k]['foo']."
            },
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "Nodes in nbunch that are not in the graph will be (quietly) ignored.\nFor directed graphs this returns the out-edges.",
            "Examples": "G=nx.MultiDiGraph()\nnx.add_path(G,[0,1,2])\nkey=G.add_edge(2,3,weight=5)\nkey2=G.add_edge(1,2)# second edge between these nodes\n[eforeinG.edges()]\n# [(0, 1), (1, 2), (1, 2), (2, 3)]\nlist(G.edges(data=True))# default data is {} (empty dict)\n# [(0, 1, {}), (1, 2, {}), (1, 2, {}), (2, 3, {'weight': 5})]\nlist(G.edges(data=\"weight\",default=1))\n# [(0, 1, 1), (1, 2, 1), (1, 2, 1), (2, 3, 5)]\nlist(G.edges(keys=True))# default keys are integers\n# [(0, 1, 0), (1, 2, 0), (1, 2, 1), (2, 3, 0)]\nlist(G.edges(data=True,keys=True))\n# [(0, 1, 0, {}), (1, 2, 0, {}), (1, 2, 1, {}), (2, 3, 0, {'weight': 5})]\nlist(G.edges(data=\"weight\",default=1,keys=True))\n# [(0, 1, 0, 1), (1, 2, 0, 1), (1, 2, 1, 1), (2, 3, 0, 5)]\nlist(G.edges([0,2]))\n# [(0, 1), (2, 3)]\nlist(G.edges(0))\n# [(0, 1)]\nlist(G.edges(1))\n# [(1, 2), (1, 2)]"
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "in_edges"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "nbunch : single node, container, or all nodes (default= all nodes)": "The view will only report edges incident to these nodes.",
                "data : string or bool, optional (default=False)": "The edge attribute returned in 3-tuple (u, v, ddict[data]).\nIf True, return edge attribute dict in 3-tuple (u, v, ddict).\nIf False, return 2-tuple (u, v).",
                "keys : bool, optional (default=False)": "If True, return edge keys with each edge, creating 3-tuples\n(u, v, k) or with data, 4-tuples (u, v, k, d).",
                "default : value, optional (default=None)": "Value used for edges that don\u2019t have the requested attribute.\nOnly relevant if data is not True or False."
            },
            "Returns:": {
                "in_edges : InMultiEdgeView or InMultiEdgeDataView": "A view of edge attributes, usually it iterates over (u, v)\nor (u, v, k) or (u, v, k, d) tuples of edges, but can also be\nused for attribute lookup asedges[u,v,k]['foo']."
            },
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {},
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "has_edge"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Description": [
            "Returns True if the graph has an edge between nodes u and v.",
            "This is the same as vinG[u]orkeyinG[u][v] without KeyError exceptions."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "u, v : nodes": "Nodes can be, for example, strings or numbers.",
                "key : hashable identifier, optional (default=None)": "If specified return True only if the edge with\nkey is found."
            },
            "Returns:": {
                "edge_ind : bool": "True if edge is in the graph, False otherwise."
            },
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "Can be called either using two nodes u, v, an edge tuple (u, v),\nor an edge tuple (u, v, key).\nG=nx.MultiGraph()# or MultiDiGraph\nnx.add_path(G,[0,1,2,3])\nG.has_edge(0,1)# using two nodes\n# True\ne=(0,1)\nG.has_edge(*e)#  e is a 2-tuple (u, v)\n# True\nG.add_edge(0,1,key=\"a\")\n# 'a'\nG.has_edge(0,1,key=\"a\")# specify key\n# True\nG.has_edge(1,0,key=\"a\")# edges aren't directed\n# True\ne=(0,1,\"a\")\nG.has_edge(*e)# e is a 3-tuple (u, v, 'a')\n# True\nThe following syntax are equivalent:\nG.has_edge(0,1)\n# True\n1inG[0]# though this gives :exc:`KeyError` if 0 not in G\n# True\n0inG[1]# other order; also gives :exc:`KeyError` if 0 not in G\n# True"
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "get_edge_data"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Description": [
            "Returns the attribute dictionary associated with edge (u, v,\nkey).",
            "If a key is not provided, returns a dictionary mapping edge keys\nto attribute dictionaries for each edge between u and v.",
            "This is identical to G[u][v][key] except the default is returned\ninstead of an exception is the edge doesn\u2019t exist."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "u, v : nodes": "",
                "default : any Python object (default=None)": "Value to return if the specific edge (u, v, key) is not\nfound, OR if there are no edges between u and v and no key\nis specified.",
                "key : hashable identifier, optional (default=None)": "Return data only for the edge with specified key, as an\nattribute dictionary (rather than a dictionary mapping keys\nto attribute dictionaries)."
            },
            "Returns:": {
                "edge_dict : dictionary": "The edge attribute dictionary, OR a dictionary mapping edge\nkeys to attribute dictionaries for each of those edges if no\nspecific key is provided (even if there\u2019s only one edge\nbetween u and v)."
            },
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.MultiGraph()# or MultiDiGraph\nkey=G.add_edge(0,1,key=\"a\",weight=7)\nG[0][1][\"a\"]# key='a'\n# {'weight': 7}\nG.edges[0,1,\"a\"]# key='a'\n# {'weight': 7}\nWarning: we protect the graph data structure by makingG.edgesandG[1][2]read-only dict-like structures.\nHowever, you can assign values to attributes in e.g.G.edges[1,2,'a']orG[1][2]['a']using an additional\nbracket as shown next. You need to specify all edge info\nto assign to the edge data associated with an edge.\nG[0][1][\"a\"][\"weight\"]=10\nG.edges[0,1,\"a\"][\"weight\"]=10\nG[0][1][\"a\"][\"weight\"]\n# 10\nG.edges[1,0,\"a\"][\"weight\"]\n# 10\nG=nx.MultiGraph()# or MultiDiGraph\nnx.add_path(G,[0,1,2,3])\nG.edges[0,1,0][\"weight\"]=5\nG.get_edge_data(0,1)\n# {0: {'weight': 5}}\ne=(0,1)\nG.get_edge_data(*e)# tuple form\n# {0: {'weight': 5}}\nG.get_edge_data(3,0)# edge not in graph, returns None\nG.get_edge_data(3,0,default=0)# edge not in graph, return default\n# 0\nG.get_edge_data(1,0,0)# specific key gives back\n# {'weight': 5}"
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "neighbors"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Description": [
            "Returns an iterator over successor nodes of n.",
            "A successor of n is a node m such that there exists a directed\nedge from n to m."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "n : node": "A node in the graph"
            },
            "Raises:": {
                "NetworkXError": "If n is not in the graph."
            },
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "neighbors() and successors() are the same."
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "adj"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Field List > Methods > Field List": {
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {},
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "__getitem__"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Description": [
            "Returns a dict of neighbors of node n.  Use: \u2018G[n]\u2019."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "n : node": "A node in the graph."
            },
            "Returns:": {
                "adj_dict : dictionary": "The adjacency dictionary for nodes connected to n."
            },
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "G[n] is the same as G.adj[n] and similar to G.neighbors(n)\n(which is an iterator over G.adj[n])",
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG[0]\n# AtlasView({1: {}})"
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "successors"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Description": [
            "Returns an iterator over successor nodes of n.",
            "A successor of n is a node m such that there exists a directed\nedge from n to m."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "n : node": "A node in the graph"
            },
            "Raises:": {
                "NetworkXError": "If n is not in the graph."
            },
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "neighbors() and successors() are the same."
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "succ"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Field List > Methods > Field List": {
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {},
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "predecessors"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Description": [
            "Returns an iterator over predecessor nodes of n.",
            "A predecessor of n is a node m such that there exists a directed\nedge from m to n."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "n : node": "A node in the graph"
            },
            "Raises:": {
                "NetworkXError": "If n is not in the graph."
            },
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {},
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "pred"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Field List > Methods > Field List": {
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {},
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "adjacency"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Description": [
            "Returns an iterator over (node, adjacency dict) tuples for all nodes.",
            "For directed graphs, only outgoing neighbors/adjacencies are included."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Returns:": {
                "adj_iter : iterator": "An iterator over (node, adjacency dictionary) for all nodes in\nthe graph."
            },
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\n[(n,nbrdict)forn,nbrdictinG.adjacency()]\n# [(0, {1: {}}), (1, {0: {}, 2: {}}), (2, {1: {}, 3: {}}), (3, {2: {}})]"
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "nbunch_iter"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Description": [
            "Returns an iterator over nodes contained in nbunch that are\nalso in the graph.",
            "The nodes in nbunch are checked for membership in the graph\nand if not are silently ignored."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "nbunch : single node, container, or all nodes (default= all nodes)": "The view will only report edges incident to these nodes."
            },
            "Returns:": {
                "niter : iterator": "An iterator over nodes in nbunch that are also in the graph.\nIf nbunch is None, iterate over all nodes in the graph."
            },
            "Raises:": {
                "NetworkXError": "If nbunch is not a node or sequence of nodes.\nIf a node in nbunch is not hashable."
            },
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "When nbunch is an iterator, the returned iterator yields values\ndirectly from nbunch, becoming exhausted when nbunch is exhausted. To test whether nbunch is a single node, one can use\n\u201cif nbunch in self:\u201d, even after processing with this routine. If nbunch is not a node or a (possibly empty) sequence/iterator\nor None, a NetworkXError is raised.  Also, if any object in\nnbunch is not hashable, a NetworkXError is raised."
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "order"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Description": [
            "Returns the number of nodes in the graph."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Returns:": {
                "nnodes : int": "The number of nodes in the graph."
            },
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(3)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.order()\n# 3"
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "number_of_nodes"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Description": [
            "Returns the number of nodes in the graph."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Returns:": {
                "nnodes : int": "The number of nodes in the graph."
            },
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(3)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.number_of_nodes()\n# 3"
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "__len__"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Description": [
            "Returns the number of nodes in the graph. Use: \u2018len(G)\u2019."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Returns:": {
                "nnodes : int": "The number of nodes in the graph."
            },
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nlen(G)\n# 4"
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "degree"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "nbunch : single node, container, or all nodes (default= all nodes)": "The view will only report edges incident to these nodes.",
                "weight : string or None, optional (default=None)": "The name of an edge attribute that holds the numerical value used\nas a weight.  If None, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node."
            },
            "Returns:": {
                "DiMultiDegreeView or int": "If multiple nodes are requested (the default), returns aDiMultiDegreeViewmapping nodes to their degree.\nIf a single node is requested, returns the degree of the node as an integer."
            },
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.MultiDiGraph()\nnx.add_path(G,[0,1,2,3])\nG.degree(0)# node 0 with degree 1\n# 1\nlist(G.degree([0,1,2]))\n# [(0, 1), (1, 2), (2, 2)]\nG.add_edge(0,1)# parallel edge\n# 1\nlist(G.degree([0,1,2]))# parallel edges are counted\n# [(0, 2), (1, 3), (2, 2)]"
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "in_degree"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "nbunch : single node, container, or all nodes (default= all nodes)": "The view will only report edges incident to these nodes.",
                "weight : string or None, optional (default=None)": "The edge attribute that holds the numerical value used\nas a weight.  If None, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node."
            },
            "Returns:": {
                "If a single node is requested": "",
                "deg : int": "Degree of the node",
                "OR if multiple nodes are requested": "",
                "nd_iter : iterator": "The iterator returns two-tuples of (node, in-degree)."
            },
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.MultiDiGraph()\nnx.add_path(G,[0,1,2,3])\nG.in_degree(0)# node 0 with degree 0\n# 0\nlist(G.in_degree([0,1,2]))\n# [(0, 0), (1, 1), (2, 1)]\nG.add_edge(0,1)# parallel edge\n# 1\nlist(G.in_degree([0,1,2]))# parallel edges counted\n# [(0, 0), (1, 2), (2, 1)]"
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "out_degree"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "nbunch : single node, container, or all nodes (default= all nodes)": "The view will only report edges incident to these nodes.",
                "weight : string or None, optional (default=None)": "The edge attribute that holds the numerical value used\nas a weight.  If None, then each edge has weight 1.\nThe degree is the sum of the edge weights."
            },
            "Returns:": {
                "If a single node is requested": "",
                "deg : int": "Degree of the node",
                "OR if multiple nodes are requested": "",
                "nd_iter : iterator": "The iterator returns two-tuples of (node, out-degree)."
            },
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.MultiDiGraph()\nnx.add_path(G,[0,1,2,3])\nG.out_degree(0)# node 0 with degree 1\n# 1\nlist(G.out_degree([0,1,2]))\n# [(0, 1), (1, 1), (2, 1)]\nG.add_edge(0,1)# parallel edge\n# 1\nlist(G.out_degree([0,1,2]))# counts parallel edges\n# [(0, 2), (1, 1), (2, 1)]"
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "size"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Description": [
            "Returns the number of edges or total of all edge weights."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "weight : string or None, optional (default=None)": "The edge attribute that holds the numerical value used\nas a weight. If None, then each edge has weight 1."
            },
            "Returns:": {
                "size : numeric": "The number of edges or\n(if weight keyword is provided) the total weight sum.If weight is None, returns an int. Otherwise a float\n(or more general numeric if the weights are more general)."
            },
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.size()\n# 3\nG=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_edge(\"a\",\"b\",weight=2)\nG.add_edge(\"b\",\"c\",weight=4)\nG.size()\n# 2\nG.size(weight=\"weight\")\n# 6.0"
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "number_of_edges"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Description": [
            "Returns the number of edges between two nodes."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "u, v : nodes, optional (Default=all edges)": "If u and v are specified, return the number of edges between\nu and v. Otherwise return the total number of all edges."
            },
            "Returns:": {
                "nedges : int": "The number of edges in the graph.  If nodesuandvare\nspecified return the number of edges between those nodes. If\nthe graph is directed, this only returns the number of edges\nfromutov."
            },
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Examples": "For undirected multigraphs, this method counts the total number\nof edges in the graph:\nG=nx.MultiGraph()\nG.add_edges_from([(0,1),(0,1),(1,2)])\n# [0, 1, 0]\nG.number_of_edges()\n# 3\nIf you specify two nodes, this counts the total number of edges\njoining the two nodes:\nG.number_of_edges(0,1)\n# 2\nFor directed multigraphs, this method can count the total number\nof directed edges fromutov:\nG=nx.MultiDiGraph()\nG.add_edges_from([(0,1),(0,1),(1,0)])\n# [0, 1, 0]\nG.number_of_edges(0,1)\n# 2\nG.number_of_edges(1,0)\n# 1"
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "copy"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Description": [
            "Returns a copy of the graph.",
            "The copy method by default returns an independent shallow copy\nof the graph and attributes. That is, if an attribute is a\ncontainer, that container is shared by the original an the copy.\nUse Python\u2019s copy.deepcopy for new containers.",
            "If as_view is True then a view is returned instead of a copy."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "as_view : bool, optional (default=False)": "If True, the returned graph-view provides a read-only view\nof the original graph without actually copying any data."
            },
            "Returns:": {
                "G : Graph": "A copy of the graph."
            },
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "All copies reproduce the graph structure, but data attributes\nmay be handled in different ways. There are four types of copies\nof a graph that people might want. Deepcopy \u2013 A \u201cdeepcopy\u201d copies the graph structure as well as\nall data attributes and any objects they might contain.\nThe entire graph object is new so that changes in the copy\ndo not affect the original object. (see Python\u2019s copy.deepcopy) Data Reference (Shallow) \u2013 For a shallow copy the graph structure\nis copied but the edge, node and graph attribute dicts are\nreferences to those in the original graph. This saves\ntime and memory but could cause confusion if you change an attribute\nin one graph and it changes the attribute in the other.\nNetworkX does not provide this level of shallow copy. Independent Shallow \u2013 This copy creates new independent attribute\ndicts and then does a shallow copy of the attributes. That is, any\nattributes that are containers are shared between the new graph\nand the original. This is exactly what dict.copy() provides.\nYou can obtain this style copy using:",
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nH=G.copy()"
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "to_undirected"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Description": [
            "Returns an undirected representation of the digraph."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "reciprocal : bool (optional)": "If True only keep edges that appear in both directions\nin the original digraph.",
                "as_view : bool (optional, default=False)": "If True return an undirected view of the original directed graph."
            },
            "Returns:": {
                "G : MultiGraph": "An undirected graph with the same name and nodes and\nwith edge (u, v, data) if either (u, v, data) or (v, u, data)\nis in the digraph.  If both edges exist in digraph and\ntheir edge data is different, only one edge is created\nwith an arbitrary choice of which edge data to use.\nYou must check and correct for this manually if desired."
            },
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "This returns a \u201cdeepcopy\u201d of the edge, node, and\ngraph attributes which attempts to completely copy\nall of the data and references. This is in contrast to the similar D=MultiDiGraph(G) which\nreturns a shallow copy of the data. See the Python copy module for more information on shallow\nand deep copies, https://docs.python.org/3/library/copy.html . Warning: If you have subclassed MultiDiGraph to use dict-like\nobjects in the data structure, those changes do not transfer\nto the MultiGraph created by this method.",
            "Examples": "G=nx.path_graph(2)# or MultiGraph, etc\nH=G.to_directed()\nlist(H.edges)\n# [(0, 1), (1, 0)]\nG2=H.to_undirected()\nlist(G2.edges)\n# [(0, 1)]"
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "to_directed"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Description": [
            "Returns a directed representation of the graph."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Returns:": {
                "G : MultiDiGraph": "A directed graph with the same name, same nodes, and with\neach edge (u, v, k, data) replaced by two directed edges\n(u, v, k, data) and (v, u, k, data)."
            },
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "This returns a \u201cdeepcopy\u201d of the edge, node, and\ngraph attributes which attempts to completely copy\nall of the data and references. This is in contrast to the similar D=MultiDiGraph(G) which\nreturns a shallow copy of the data. See the Python copy module for more information on shallow\nand deep copies, https://docs.python.org/3/library/copy.html . Warning: If you have subclassed MultiGraph to use dict-like objects\nin the data structure, those changes do not transfer to the\nMultiDiGraph created by this method.",
            "Examples": "G=nx.MultiGraph()\nG.add_edge(0,1)\n# 0\nG.add_edge(0,1)\n# 1\nH=G.to_directed()\nlist(H.edges)\n# [(0, 1, 0), (0, 1, 1), (1, 0, 0), (1, 0, 1)]\nIf already directed, return a (deep) copy\nG=nx.MultiDiGraph()\nG.add_edge(0,1)\n# 0\nH=G.to_directed()\nlist(H.edges)\n# [(0, 1, 0)]"
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "subgraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Description": [
            "Returns a SubGraph view of the subgraph induced on nodes .",
            "The induced subgraph of the graph contains the nodes in nodes and the edges between those nodes."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "nodes : list, iterable": "A container of nodes which will be iterated through once."
            },
            "Returns:": {
                "G : SubGraph View": "A subgraph view of the graph. The graph structure cannot be\nchanged but node/edge attributes can and are shared with the\noriginal graph."
            },
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "The graph, edge and node attributes are shared with the original graph.\nChanges to the graph structure is ruled out by the view, but changes\nto attributes are reflected in the original graph. To create a subgraph with its own copy of the edge/node attributes use:\nG.subgraph(nodes).copy() For an inplace reduction of a graph to a subgraph you can remove nodes:\nG.remove_nodes_from([n for n in G if n not in set(nodes)]) Subgraph views are sometimes NOT what you want. In most cases where\nyou want to do more than simply look at the induced edges, it makes\nmore sense to just create the subgraph as its own graph with code like:",
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nH=G.subgraph([0,1,2])\nlist(H.edges)\n# [(0, 1), (1, 2)]"
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "edge_subgraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Description": [
            "Returns the subgraph induced by the specified edges.",
            "The induced subgraph contains each edge in edges and each\nnode incident to any one of those edges."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "edges : iterable": "An iterable of edges in this graph."
            },
            "Returns:": {
                "G : Graph": "An edge-induced subgraph of this graph with the same edge\nattributes."
            },
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {
            "Notes": "The graph, edge, and node attributes in the returned subgraph\nview are references to the corresponding attributes in the original\ngraph. The view is read-only. To create a full graph version of the subgraph with its own copy\nof the edge or node attributes, use:",
            "Examples": "G=nx.path_graph(5)\nH=G.edge_subgraph([(0,1),(3,4)])\nlist(H.nodes)\n# [0, 1, 3, 4]\nlist(H.edges)\n# [(0, 1), (3, 4)]"
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Section ID": "reverse"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Path": "networkx.MultiDiGraph"
    },
    {
        "Section_id": "MultiDiGraph",
        "Field List > Methods > Description": [
            "Returns the reverse of the graph.",
            "The reverse is a graph with the same nodes and edges\nbut with the directions of the edges reversed."
        ]
    },
    {
        "Field List > Methods > Field List": {
            "Parameters:": {
                "copy : bool optional (default=True)": "If True, return a new DiGraph holding the reversed edges.\nIf False, the reverse graph is created using a view of\nthe original graph."
            },
            "Methods": []
        },
        "Section_id": "MultiDiGraph"
    },
    {
        "Field List > Methods > Rubrics": {},
        "Section_id": "MultiDiGraph"
    },
    {
        "Rubrics": {
            "Examples": "Create an empty graph structure (a \u201cnull graph\u201d) with no nodes and\nno edges.\nG=nx.MultiDiGraph()\nG can be grown in several ways.\nNodes:\nAdd one node at a time:\nG.add_node(1)\nAdd the nodes from any container (a list, dict, set or\neven the lines from a file or the nodes from another graph).\nG.add_nodes_from([2,3])\nG.add_nodes_from(range(100,110))\nH=nx.path_graph(10)\nG.add_nodes_from(H)\nIn addition to strings and integers any hashable Python object\n(except None) can represent a node, e.g. a customized node object,\nor even another Graph.\nG.add_node(H)\nEdges:\nG can also be grown by adding edges.\nAdd one edge,\nkey=G.add_edge(1,2)\na list of edges,\nkeys=G.add_edges_from([(1,2),(1,3)])\nor a collection of edges,\nkeys=G.add_edges_from(H.edges)\nIf some edges connect nodes not yet in the graph, the nodes\nare added automatically.  If an edge already exists, an additional\nedge is created and stored using a key to identify the edge.\nBy default the key is the lowest unused integer.\nkeys=G.add_edges_from([(4,5,dict(route=282)),(4,5,dict(route=37))])\nG[4]\n# AdjacencyView({5: {0: {}, 1: {'route': 282}, 2: {'route': 37}}})\nAttributes:\nEach graph, node, and edge can hold key/value attribute pairs\nin an associated attribute dictionary (the keys must be hashable).\nBy default these are empty, but can be added or changed using\nadd_edge, add_node or direct manipulation of the attribute\ndictionaries named graph, node and edge respectively.\nG=nx.MultiDiGraph(day=\"Friday\")\nG.graph\n# {'day': 'Friday'}\nAdd node attributes using add_node(), add_nodes_from() or G.nodes\nG.add_node(1,time=\"5pm\")\nG.add_nodes_from([3],time=\"2pm\")\nG.nodes[1]\n# {'time': '5pm'}\nG.nodes[1][\"room\"]=714\ndelG.nodes[1][\"room\"]# remove attribute\nlist(G.nodes(data=True))\n# [(1, {'time': '5pm'}), (3, {'time': '2pm'})]\nAdd edge attributes using add_edge(), add_edges_from(), subscript\nnotation, or G.edges.\nkey=G.add_edge(1,2,weight=4.7)\nkeys=G.add_edges_from([(3,4),(4,5)],color=\"red\")\nkeys=G.add_edges_from([(1,2,{\"color\":\"blue\"}),(2,3,{\"weight\":8})])\nG[1][2][0][\"weight\"]=4.7\nG.edges[1,2,0][\"weight\"]=4\nWarning: we protect the graph data structure by makingG.edges[1,2,0]a read-only dict-like structure. However, you can assign to\nattributes in e.g.G.edges[1,2,0]. Thus, use 2 sets of brackets\nto add/change data attributes:G.edges[1,2,0]['weight']=4(for multigraphs the edge key is required:MG.edges[u,v,key][name]=value).\nShortcuts:\nMany common graph features allow python syntax to speed reporting.\n1inG# check if node in graph\n# True\n[nforninGifn<3]# iterate through nodes\n# [1, 2]\nlen(G)# number of nodes in graph\n# 5\nG[1]# adjacency dict-like view mapping neighbor -> edge key -> edge attributes\n# AdjacencyView({2: {0: {'weight': 4}, 1: {'color': 'blue'}}})\nOften the best way to traverse all edges of a graph is via the neighbors.\nThe neighbors are available as an adjacency-viewG.adjobject or via\nthe methodG.adjacency().\nforn,nbrsdictinG.adjacency():\nfornbr,keydictinnbrsdict.items():\nforkey,eattrinkeydict.items():\nif\"weight\"ineattr:\n# Do something useful with the edges\npass\nBut the edges() method is often more convenient:\nforu,v,keys,weightinG.edges(data=\"weight\",keys=True):\nifweightisnotNone:\n# Do something useful with the edges\npass\nReporting:\nSimple graph information is obtained using methods and object-attributes.\nReporting usually provides views instead of containers to reduce memory\nusage. The views update as the graph is updated similarly to dict-views.\nThe objectsnodes,edgesandadjprovide access to data attributes\nvia lookup (e.g.nodes[n],edges[u,v,k],adj[u][v]) and iteration\n(e.g.nodes.items(),nodes.data('color'),nodes.data('color',default='blue')and similarly foredges)\nViews exist fornodes,edges,neighbors()/adjanddegree.\nFor details on these and other miscellaneous methods, see below.\nSubclasses (Advanced):\nThe MultiDiGraph class uses a dict-of-dict-of-dict-of-dict structure.\nThe outer dict (node_dict) holds adjacency information keyed by node.\nThe next dict (adjlist_dict) represents the adjacency information\nand holds edge_key dicts keyed by neighbor. The edge_key dict holds\neach edge_attr dict keyed by edge key. The inner dict\n(edge_attr_dict) represents the edge data and holds edge attribute\nvalues keyed by attribute names.\nEach of these four dicts in the dict-of-dict-of-dict-of-dict\nstructure can be replaced by a user defined dict-like object.\nIn general, the dict-like features should be maintained but\nextra features can be added. To replace one of the dicts create\na new graph class by changing the class(!) variable holding the\nfactory for that dict-like structure. The variable names are\nnode_dict_factory, node_attr_dict_factory, adjlist_inner_dict_factory,\nadjlist_outer_dict_factory, edge_key_dict_factory, edge_attr_dict_factory\nand graph_attr_dict_factory."
        },
        "Section_id": "MultiDiGraph"
    }
]