[
    {
        "Section ID": "freeze",
        "Description": [
            "Modify graph to prevent further change by adding or removing\nnodes or edges.",
            "Node and edge data can still be modified."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "To \u201cunfreeze\u201d a graph you must make a copy by creating a new graph object:",
            "Examples": "G=nx.path_graph(4)\nG=nx.freeze(G)\ntry:\nG.add_edge(4,5)\nexceptnx.NetworkXErroraserr:\nprint(str(err))\n# Frozen graph can't be modified"
        }
    },
    {
        "Section ID": "PlanarEmbedding",
        "Description": [
            "Represents a planar graph with its planar embedding.",
            "The planar embedding is given by a combinatorial embedding .",
            "Neighbor ordering:",
            "In comparison to a usual graph structure, the embedding also stores the\norder of all neighbors for every vertex.\nThe order of the neighbors can be given in clockwise (cw) direction or\ncounterclockwise (ccw) direction. This order is stored as edge attributes\nin the underlying directed graph. For the edge (u, v) the edge attribute\n\u2018cw\u2019 is set to the neighbor of u that follows immediately after v in\nclockwise direction.",
            "In order for a PlanarEmbedding to be valid it must fulfill multiple\nconditions. It is possible to check if these conditions are fulfilled with\nthe method check_structure() .\nThe conditions are:",
            "As long as a PlanarEmbedding is invalid only the following methods should\nbe called:",
            "Even though the graph is a subclass of nx.DiGraph, it can still be used\nfor algorithms that require undirected graphs, because the method is_directed() is overridden. This is possible, because a valid\nPlanarGraph must have edges in both directions.",
            "Half edges:",
            "In methods like add_half_edge the term \u201chalf-edge\u201d is used, which is\na term that is used in doubly connected edge lists . It is used\nto emphasize that the edge is only in one direction and there exists\nanother half-edge in the opposite direction.\nWhile conventional edges always have two faces (including outer face) next\nto them, it is possible to assign each half-edge exactly one face.\nFor a half-edge (u, v) that is oriented such that u is below v then the\nface that belongs to (u, v) is to the right of this half-edge.",
            "Examples",
            "Create an embedding of a star graph (compare nx.star_graph(3) ):",
            "Alternatively the same embedding can also be defined in counterclockwise\norientation. The following results in exactly the same PlanarEmbedding:",
            "After creating a graph, it is possible to validate that the PlanarEmbedding\nobject is correct:"
        ],
        "Field List": {
            "Parameters:": {
                "incoming_graph_data : input graph (optional, default: None)": "Data to initialize graph.  If None (default) an empty\ngraph is created.  The data can be an edge list, or any\nNetworkX graph object.  If the corresponding optional Python\npackages are installed the data can also be a 2D NumPy array, a\nSciPy sparse array, or a PyGraphviz graph.",
                "attr : keyword arguments, optional (default= no attributes)": "Attributes to add to graph as key=value pairs."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG=nx.Graph(name=\"my graph\")\ne=[(1,2),(2,3),(3,4)]# list of edges\nG=nx.Graph(e)\nArbitrary graph attribute pairs (key=value) may be assigned\nG=nx.Graph(e,day=\"Friday\")\nG.graph\n# {'day': 'Friday'}"
        }
    },
    {
        "Section ID": "triadic_census",
        "Description": [
            "Determines the triadic census of a directed graph.",
            "The triadic census is a count of how many of the 16 possible types of\ntriads are present in a directed graph. If a list of nodes is passed, then\nonly those triads are taken into account which have elements of nodelist in them."
        ],
        "Field List": {
            "Parameters:": {
                "G : digraph": "A NetworkX DiGraph",
                "nodelist : list": "List of nodes for which you want to calculate triadic census"
            },
            "Returns:": {
                "census : dict": "Dictionary with triad type as keys and number of occurrences as values."
            },
            "Raises:": {
                "ValueError": "Ifnodelistcontains duplicate nodes or nodes not inG.\nIf you want to ignore this you can preprocess withset(nodelist)&G.nodes"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm has complexity \\(O(m)\\) where \\(m\\) is the number of edges in\nthe graph. For undirected graphs, the triadic census can be computed by first converting\nthe graph into a directed graph using the G.to_directed() method.\nAfter this conversion, only the triad types 003, 102, 201 and 300 will be\npresent in the undirected scenario.",
            "References": "[1]Vladimir Batagelj and Andrej Mrvar, A subquadratic triad census\nalgorithm for large sparse networks with small maximum degree,\nUniversity of Ljubljana,http://vlado.fmf.uni-lj.si/pub/networks/doc/triads/triads.pdf",
            "Examples": "G=nx.DiGraph([(1,2),(2,3),(3,1),(3,4),(4,1),(4,2)])\ntriadic_census=nx.triadic_census(G)\nforkey,valueintriadic_census.items():\nprint(f\"{key}: {value}\")\n# 003: 0\n# 012: 0\n# 102: 0\n# 021D: 0\n# 021U: 0\n# 021C: 0\n# 111D: 0\n# 111U: 0\n# 030T: 2\n# 030C: 2\n# 201: 0\n# 120D: 0\n# 120U: 0\n# 120C: 0\n# 210: 0\n# 300: 0"
        }
    },
    {
        "Section ID": "maximum_branching",
        "Description": [
            "Returns a maximum branching from G."
        ],
        "Field List": {
            "Parameters:": {
                "G : (multi)digraph-like": "The graph to be searched.",
                "attr : str": "The edge attribute used to in determining optimality.",
                "default : float": "The value of the edge attribute used if an edge does not have\nthe attributeattr.",
                "preserve_attrs : bool": "If True, preserve the other attributes of the original graph (that are not\npassed toattr)",
                "partition : str": "The key for the edge attribute containing the partition\ndata on the graph. Edges can be included, excluded or open using theEdgePartitionenum."
            },
            "Returns:": {
                "B : (multi)digraph-like": "A maximum branching."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "from_prufer_sequence",
        "Description": [
            "Returns the tree corresponding to the given Pr\u00fcfer sequence.",
            "A Pr\u00fcfer sequence is a list of n - 2 numbers between 0 and n - 1, inclusive. The tree corresponding to a given Pr\u00fcfer\nsequence can be recovered by repeatedly joining a node in the\nsequence with a node with the smallest potential degree according to\nthe sequence."
        ],
        "Field List": {
            "Parameters:": {
                "sequence : list": "A Pr\u00fcfer sequence, which is a list ofn- 2 integers between\nzero andn- 1, inclusive."
            },
            "Returns:": {
                "NetworkX graph": "The tree corresponding to the given Pr\u00fcfer sequence."
            },
            "Raises:": {
                "NetworkXError": "If the Pr\u00fcfer sequence is not valid."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "There is a bijection from labeled trees to Pr\u00fcfer sequences. This\nfunction is the inverse of the from_prufer_sequence() function. Sometimes Pr\u00fcfer sequences use nodes labeled from 1 to n instead\nof from 0 to n - 1. This function requires nodes to be labeled in\nthe latter form. You can use networkx.relabel_nodes() to\nrelabel the nodes of your tree to the appropriate format. This implementation is from [1] and has a running time of \\(O(n)\\) .",
            "References": "[1]Wang, Xiaodong, Lei Wang, and Yingjie Wu.\n\u201cAn optimal algorithm for Prufer codes.\u201dJournal of Software Engineering and Applications2.02 (2009): 111.\n<https://doi.org/10.4236/jsea.2009.22016>",
            "Examples": "There is a bijection between Pr\u00fcfer sequences and labeled trees, so\nthis function is the inverse of theto_prufer_sequence()function:\nedges=[(0,3),(1,3),(2,3),(3,4),(4,5)]\ntree=nx.Graph(edges)\nsequence=nx.to_prufer_sequence(tree)\nsequence\n# [3, 3, 3, 4]\ntree2=nx.from_prufer_sequence(sequence)\nlist(tree2.edges())==edges\n# True"
        }
    },
    {
        "Section ID": "sets",
        "Description": [
            "Returns bipartite node sets of graph G.",
            "Raises an exception if the graph is not bipartite or if the input\ngraph is disconnected and thus more than one valid solution exists.\nSee bipartitedocumentation for further details on how bipartite graphs are handled in NetworkX."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "top_nodes : container, optional": "Container with all nodes in one bipartite node set. If not supplied\nit will be computed. But if more than one solution exists an exception\nwill be raised."
            },
            "Returns:": {
                "X : set": "Nodes from one side of the bipartite graph.",
                "Y : set": "Nodes from the other side."
            },
            "Raises:": {
                "AmbiguousSolution": "Raised if the input bipartite graph is disconnected and no container\nwith all nodes in one bipartite set is provided. When determining\nthe nodes in each bipartite set more than one valid solution is\npossible if the input graph is disconnected.",
                "NetworkXError": "Raised if the input graph is not bipartite."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "fromnetworkx.algorithmsimportbipartite\nG=nx.path_graph(4)\nX,Y=bipartite.sets(G)\nlist(X)\n# [0, 2]\nlist(Y)\n# [1, 3]"
        }
    },
    {
        "Section ID": "eigenvector_centrality_numpy",
        "Description": [
            "Compute the eigenvector centrality for the graph G.",
            "Eigenvector centrality computes the centrality for a node by adding\nthe centrality of its predecessors. The centrality for node \\(i\\) is the \\(i\\) -th element of a left eigenvector associated with the eigenvalue \\(\\lambda\\) of maximum modulus that is positive. Such an eigenvector \\(x\\) is\ndefined up to a multiplicative constant by the equation",
            "where \\(A\\) is the adjacency matrix of the graph G. By definition of\nrow-column product, the equation above is equivalent to",
            "That is, adding the eigenvector centralities of the predecessors of \\(i\\) one obtains the eigenvector centrality of \\(i\\) multiplied by \\(\\lambda\\) . In the case of undirected graphs, \\(x\\) also solves the familiar\nright-eigenvector equation \\(Ax = \\lambda x\\) .",
            "By virtue of the Perron\u2013Frobenius theorem [1] , if G is strongly\nconnected there is a unique eigenvector \\(x\\) , and all its entries\nare strictly positive.",
            "If G is not strongly connected there might be several left\neigenvectors associated with \\(\\lambda\\) , and some of their elements\nmight be zero."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph.",
                "max_iter : integer, optional (default=50)": "Maximum number of Arnoldi update iterations allowed.",
                "tol : float, optional (default=0)": "Relative accuracy for eigenvalues (stopping criterion).\nThe default value of 0 implies machine precision.",
                "weight : None or string, optional (default=None)": "If None, all edge weights are considered equal. Otherwise holds the\nname of the edge attribute used as weight. In this measure the\nweight is interpreted as the connection strength."
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of nodes with eigenvector centrality as the value. The\nassociated vector has unit Euclidean norm and the values are\nnonegative."
            },
            "Raises:": {
                "NetworkXPointlessConcept": "If the graph G is the null graph.",
                "ArpackNoConvergence": "When the requested convergence is not obtained. The currently\nconverged eigenvalues and eigenvectors can be found as\neigenvalues and eigenvectors attributes of the exception object."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Eigenvector centrality was introduced by Landau [2] for chess\ntournaments. It was later rediscovered by Wei [3] and then\npopularized by Kendall [4] in the context of sport ranking. Berge\nintroduced a general definition for graphs based on social connections [5] . Bonacich [6] reintroduced again eigenvector centrality and made\nit popular in link analysis. This function computes the left dominant eigenvector, which corresponds\nto adding the centrality of predecessors: this is the usual approach.\nTo add the centrality of successors first reverse the graph with G.reverse() . This implementation uses the SciPysparseeigenvaluesolver (ARPACK)\nto find the largest eigenvalue/eigenvector pair using Arnoldi iterations [7] .",
            "References": "[1]Abraham Berman and Robert J. Plemmons.\n\u201cNonnegative Matrices in the Mathematical Sciences.\u201d\nClassics in Applied Mathematics. SIAM, 1994.  [2]Edmund Landau.\n\u201cZur relativen Wertbemessung der Turnierresultate.\u201d\nDeutsches Wochenschach, 11:366\u2013369, 1895.  [3]Teh-Hsing Wei.\n\u201cThe Algebraic Foundations of Ranking Theory.\u201d\nPhD thesis, University of Cambridge, 1952.  [4]Maurice G. Kendall.\n\u201cFurther contributions to the theory of paired comparisons.\u201d\nBiometrics, 11(1):43\u201362, 1955.https://www.jstor.org/stable/3001479  [5]Claude Berge\n\u201cTh\u00e9orie des graphes et ses applications.\u201d\nDunod, Paris, France, 1958.  [6]Phillip Bonacich.\n\u201cTechnique for analyzing overlapping memberships.\u201d\nSociological Methodology, 4:176\u2013185, 1972.https://www.jstor.org/stable/270732  [7]Arnoldi iteration::https://en.wikipedia.org/wiki/Arnoldi_iteration",
            "Examples": "G=nx.path_graph(4)\ncentrality=nx.eigenvector_centrality_numpy(G)\nprint([f\"{node} {centrality[node]:0.2f}\"fornodeincentrality])\n# ['0 0.37', '1 0.60', '2 0.60', '3 0.37']"
        }
    },
    {
        "Section ID": "algebraic_connectivity",
        "Description": [
            "Returns the algebraic connectivity of an undirected graph.",
            "The algebraic connectivity of a connected undirected graph is the second\nsmallest eigenvalue of its Laplacian matrix."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "An undirected graph.",
                "weight : object, optional (default: None)": "The data key used to determine the weight of each edge. If None, then\neach edge has unit weight.",
                "normalized : bool, optional (default: False)": "Whether the normalized Laplacian matrix is used.",
                "tol : float, optional (default: 1e-8)": "Tolerance of relative residual in eigenvalue computation.",
                "method : string, optional (default: \u2018tracemin_pcg\u2019)": "Method of eigenvalue computation. It must be one of the tracemin\noptions shown below (TraceMIN), \u2018lanczos\u2019 (Lanczos iteration)\nor \u2018lobpcg\u2019 (LOBPCG).The TraceMIN algorithm uses a linear system solver. The following\nvalues allow specifying the solver to be used.ValueSolver\u2018tracemin_pcg\u2019Preconditioned conjugate gradient method\u2018tracemin_lu\u2019LU factorization",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "algebraic_connectivity : float": "Algebraic connectivity."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is directed.",
                "NetworkXError": "If G has less than two nodes."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weights are interpreted by their absolute values. For MultiGraph\u2019s,\nweights of parallel edges are summed. Zero-weighted edges are ignored.",
            "Examples": "For undirected graphs algebraic connectivity can tell us if a graph is connected or notGis connected iffalgebraic_connectivity(G)>0:\nG=nx.complete_graph(5)\nnx.algebraic_connectivity(G)>0\n# True\nG.add_node(10)# G is no longer connected\nnx.algebraic_connectivity(G)>0\n# False"
        }
    },
    {
        "Section ID": "strongly_connected_components",
        "Description": [
            "Generate nodes in strongly connected components of graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "A directed graph."
            },
            "Returns:": {
                "comp : generator of sets": "A generator of sets of nodes, one for each strongly connected\ncomponent of G."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Uses Tarjan\u2019s algorithm[R827335e01166-1]_ with Nuutila\u2019s modifications[R827335e01166-2]_.\nNonrecursive version of algorithm.",
            "References": "[1]Depth-first search and linear graph algorithms, R. Tarjan\nSIAM Journal of Computing 1(2):146-160, (1972).  [2]On finding the strongly connected components in a directed graph.\nE. Nuutila and E. Soisalon-Soinen\nInformation Processing Letters 49(1): 9-14, (1994)..",
            "Examples": "Generate a sorted list of strongly connected components, largest first.\nG=nx.cycle_graph(4,create_using=nx.DiGraph())\nnx.add_cycle(G,[10,11,12])\n[len(c)forcinsorted(nx.strongly_connected_components(G),key=len,reverse=True)]\n# [4, 3]\nIf you only want the largest component, it\u2019s more efficient to\nuse max instead of sort.\nlargest=max(nx.strongly_connected_components(G),key=len)"
        }
    },
    {
        "Section ID": "min_edge_cover",
        "Description": [
            "Returns a set of edges which constitutes\nthe minimum edge cover of the graph.",
            "The smallest edge cover can be found in polynomial time by finding\na maximum matching and extending it greedily so that all nodes\nare covered."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "An undirected bipartite graph.",
                "matching_algorithm : function": "A function that returns a maximum cardinality matching in a\ngiven bipartite graph. The function must take one input, the\ngraphG, and return a dictionary mapping each node to its\nmate. If not specified,hopcroft_karp_matching()will be used. Other possibilities includeeppstein_matching(),"
            },
            "Returns:": {
                "set": "A set of the edges in a minimum edge cover of the graph, given as\npairs of nodes. It contains both the edges(u,v)and(v,u)for given nodesuandvamong the edges of minimum edge cover."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "An edge cover of a graph is a set of edges such that every node of\nthe graph is incident to at least one edge of the set.\nA minimum edge cover is an edge covering of smallest cardinality. Due to its implementation, the worst-case running time of this algorithm\nis bounded by the worst-case running time of the function matching_algorithm ."
        }
    },
    {
        "Section ID": "adjacency_matrix",
        "Description": [
            "Returns adjacency matrix of G."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "nodelist : list, optional": "The rows and columns are ordered according to the nodes in nodelist.\nIf nodelist is None, then the ordering is produced by G.nodes().",
                "dtype : NumPy data-type, optional": "The desired data-type for the array.\nIf None, then the NumPy default is used.",
                "weight : string or None, optional (default=\u2019weight\u2019)": "The edge data key used to provide each value in the matrix.\nIf None, then each edge has weight 1."
            },
            "Returns:": {
                "A : SciPy sparse array": "Adjacency matrix representation of G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For directed graphs, entry i,j corresponds to an edge from i to j. If you want a pure Python adjacency matrix representation try\nnetworkx.convert.to_dict_of_dicts which will return a\ndictionary-of-dictionaries format that can be addressed as a\nsparse matrix. For MultiGraph/MultiDiGraph with parallel edges the weights are summed.\nSee to_numpy_array for other options. The convention used for self-loop edges in graphs is to assign the\ndiagonal matrix entry value to the edge weight attribute\n(or the number 1 if the edge has no weight attribute).  If the\nalternate convention of doubling the edge weight is desired the\nresulting SciPy sparse array can be modified as follows:"
        }
    },
    {
        "Section ID": "null_graph",
        "Description": [
            "Returns the Null graph with no nodes or edges.",
            "See empty_graph for the use of create_using."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "single_source_dijkstra_path_length",
        "Description": [
            "Find shortest weighted path lengths in G from a source node.",
            "Compute the shortest path length between source and all other\nreachable nodes for a weighted graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node label": "Starting node for path",
                "cutoff : integer or float, optional": "Length (sum of edge weights) at which the search is stopped.\nIf cutoff is provided, only return paths with summed weight <= cutoff.",
                "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge."
            },
            "Returns:": {
                "length : dict": "Dict keyed by node to shortest path length from source."
            },
            "Raises:": {
                "NodeNotFound": "Ifsourceis not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The weight function can be used to hide edges by returning None.\nSo weight=lambdau,v,d:1ifd['color']==\"red\"elseNone will find the shortest red path.",
            "Examples": "G=nx.path_graph(5)\nlength=nx.single_source_dijkstra_path_length(G,0)\nlength[4]\n# 4\nfornodein[0,1,2,3,4]:\nprint(f\"{node}: {length[node]}\")\n# 0: 0\n# 1: 1\n# 2: 2\n# 3: 3\n# 4: 4"
        }
    },
    {
        "Section ID": "effective_graph_resistance",
        "Description": [
            "Returns the Effective graph resistance of G.",
            "Also known as the Kirchhoff index.",
            "The effective graph resistance is defined as the sum\nof the resistance distance of every node pair in G [1] .",
            "If weight is not provided, then a weight of 1 is used for all edges.",
            "The effective graph resistance of a disconnected graph is infinite."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A graph",
                "weight : string or None, optional (default=None)": "The edge data key used to compute the effective graph resistance.\nIf None, then each edge has weight 1.",
                "invert_weight : boolean (default=True)": "Proper calculation of resistance distance requires building the\nLaplacian matrix with the reciprocal of the weight. Not required\nif the weight is already inverted. Weight cannot be zero."
            },
            "Returns:": {
                "RG : float": "The effective graph resistance ofG."
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis a directed graph.",
                "NetworkXError": "IfGdoes not contain any nodes."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The implementation is based on Theorem 2.2 in [2] . Self-loops are ignored.\nMulti-edges are contracted in one edge with weight equal to the harmonic sum of the weights.",
            "References": "[1]Wolfram\n\u201cKirchhoff Index.\u201dhttps://mathworld.wolfram.com/KirchhoffIndex.html  [2]W. Ellens, F. M. Spieksma, P. Van Mieghem, A. Jamakovic, R. E. Kooij.\nEffective graph resistance.\nLin. Alg. Appl. 435:2491-2506, 2011.",
            "Examples": "G=nx.Graph([(1,2),(1,3),(1,4),(3,4),(3,5),(4,5)])\nround(nx.effective_graph_resistance(G),10)\n# 10.25"
        }
    },
    {
        "Section ID": "is_aperiodic",
        "Description": [
            "Returns True if G is aperiodic.",
            "A directed graph is aperiodic if there is no integer k > 1 that\ndivides the length of every cycle in the graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX DiGraph": "A directed graph"
            },
            "Returns:": {
                "bool": "True if the graph is aperiodic False otherwise"
            },
            "Raises:": {
                "NetworkXError": "IfGis not directed"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This uses the method outlined in [1] , which runs in \\(O(m)\\) time\ngiven \\(m\\) edges in G . Note that a graph is not aperiodic if it is\nacyclic as every integer trivial divides length 0 cycles.",
            "References": "[1]Jarvis, J. P.; Shier, D. R. (1996),\n\u201cGraph-theoretic analysis of finite Markov chains,\u201d\nin Shier, D. R.; Wallenius, K. T., Applied Mathematical Modeling:\nA Multidisciplinary Approach, CRC Press.",
            "Examples": "A graph consisting of one cycle, the length of which is 2. Thereforek=2divides the length of every cycle in the graph and thus the graph\nisnot aperiodic:\nDG=nx.DiGraph([(1,2),(2,1)])\nnx.is_aperiodic(DG)\n# False\nA graph consisting of two cycles: one of length 2 and the other of length 3.\nThe cycle lengths are coprime, so there is no single value of k wherek>1that divides each cycle length and therefore the graph isaperiodic:\nDG=nx.DiGraph([(1,2),(2,3),(3,1),(1,4),(4,1)])\nnx.is_aperiodic(DG)\n# True\nA graph consisting of two cycles: one of length 2 and the other of length 4.\nThe lengths of the cycles share a common factork=2, and therefore\nthe graph isnot aperiodic:\nDG=nx.DiGraph([(1,2),(2,1),(3,4),(4,5),(5,6),(6,3)])\nnx.is_aperiodic(DG)\n# False\nAn acyclic graph, therefore the graph isnot aperiodic:\nDG=nx.DiGraph([(1,2),(2,3)])\nnx.is_aperiodic(DG)\n# False"
        }
    },
    {
        "Section ID": "adamic_adar_index",
        "Description": [
            "Compute the Adamic-Adar index of all node pairs in ebunch.",
            "Adamic-Adar index of u and v is defined as",
            "where \\(\\Gamma(u)\\) denotes the set of neighbors of \\(u\\) .\nThis index leads to zero-division for nodes only connected via self-loops.\nIt is intended to be used when no self-loops are present."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "NetworkX undirected graph.",
                "ebunch : iterable of node pairs, optional (default = None)": "Adamic-Adar index will be computed for each pair of nodes given\nin the iterable. The pairs must be given as 2-tuples (u, v)\nwhere u and v are nodes in the graph. If ebunch is None then all\nnonexistent edges in the graph will be used.\nDefault value: None."
            },
            "Returns:": {
                "piter : iterator": "An iterator of 3-tuples in the form (u, v, p) where (u, v) is a\npair of nodes and p is their Adamic-Adar index."
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis aDiGraph, aMultigraphor aMultiDiGraph.",
                "NodeNotFound": "Ifebunchhas a node that is not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]D. Liben-Nowell, J. Kleinberg.\nThe Link Prediction Problem for Social Networks (2004).http://www.cs.cornell.edu/home/kleinber/link-pred.pdf",
            "Examples": "G=nx.complete_graph(5)\npreds=nx.adamic_adar_index(G,[(0,1),(2,3)])\nforu,v,pinpreds:\nprint(f\"({u}, {v}) -> {p:.8f}\")\n# (0, 1) -> 2.16404256\n# (2, 3) -> 2.16404256"
        }
    },
    {
        "Section ID": "incremental_closeness_centrality",
        "Description": [
            "Incremental closeness centrality for nodes.",
            "Compute closeness centrality for nodes using level-based work filtering\nas described in Incremental Algorithms for Closeness Centrality by Sariyuce et al.",
            "Level-based work filtering detects unnecessary updates to the closeness\ncentrality and filters them out.",
            "\u2014\nFrom \u201cIncremental Algorithms for Closeness Centrality\u201d:",
            "Theorem 1: Let \\(G = (V, E)\\) be a graph and u and v be two vertices in V\nsuch that there is no edge (u, v) in E. Let \\(G' = (V, E \\cup uv)\\) Then \\(cc[s] = cc'[s]\\) if and only if \\(\\left|dG(s, u) - dG(s, v)\\right| \\leq 1\\) .",
            "Where \\(dG(u, v)\\) denotes the length of the shortest path between\ntwo vertices u, v in a graph G, cc[s] is the closeness centrality for a\nvertex s in V, and cc\u2019[s] is the closeness centrality for a\nvertex s in V, with the (u, v) edge added.\n\u2014",
            "We use Theorem 1 to filter out updates when adding or removing an edge.\nWhen adding an edge (u, v), we compute the shortest path lengths from all\nother nodes to u and to v before the node is added. When removing an edge,\nwe compute the shortest path lengths after the edge is removed. Then we\napply Theorem 1 to use previously computed closeness centrality for nodes\nwhere \\(\\left|dG(s, u) - dG(s, v)\\right| \\leq 1\\) . This works only for\nundirected, unweighted graphs; the distance argument is not supported.",
            "Closeness centrality [1] of a node u is the reciprocal of the\nsum of the shortest path distances from u to all n-1 other nodes.\nSince the sum of distances depends on the number of nodes in the\ngraph, closeness is normalized by the sum of minimum possible\ndistances n-1 .",
            "where d(v,u) is the shortest-path distance between v and u ,\nand n is the number of nodes in the graph.",
            "Notice that higher values of closeness indicate higher centrality."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "edge : tuple": "The modified edge (u, v) in the graph.",
                "prev_cc : dictionary": "The previous closeness centrality for all nodes in the graph.",
                "insertion : bool, optional": "If True (default) the edge was inserted, otherwise it was deleted from the graph.",
                "wf_improved : bool, optional (default=True)": "If True, scale by the fraction of nodes reachable. This gives the\nWasserman and Faust improved formula. For single component graphs\nit is the same as the original formula."
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of nodes with closeness centrality as the value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The closeness centrality is normalized to (n-1)/(|G|-1) where n is the number of nodes in the connected part of graph\ncontaining the node.  If the graph is not completely connected,\nthis algorithm computes the closeness centrality for each\nconnected part separately.",
            "References": "[1]Freeman, L.C., 1979. Centrality in networks: I.\nConceptual clarification.  Social Networks 1, 215\u2013239.https://doi.org/10.1016/0378-8733(78)90021-7  [2]Sariyuce, A.E. ; Kaya, K. ; Saule, E. ; Catalyiirek, U.V. Incremental\nAlgorithms for Closeness Centrality. 2013 IEEE International Conference on Big Datahttp://sariyuce.com/papers/bigdata13.pdf"
        }
    },
    {
        "Section ID": "spectral_graph_forge",
        "Description": [
            "Returns a random simple graph with spectrum resembling that of G",
            "This algorithm, called Spectral Graph Forge (SGF), computes the\neigenvectors of a given graph adjacency matrix, filters them and\nbuilds a random graph with a similar eigenstructure.\nSGF has been proved to be particularly useful for synthesizing\nrealistic social networks and it can also be used to anonymize\ngraph sensitive data."
        ],
        "Field List": {
            "Parameters:": {
                "G : Graph": "",
                "alpha : float": "Ratio representing the percentage of eigenvectors of G to consider,\nvalues in [0,1].",
                "transformation : string, optional": "Represents the intended matrix linear transformation, possible values\nare \u2018identity\u2019 and \u2018modularity\u2019",
                "seed : integer, random_state, or None (default)": "Indicator of numpy random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "H : Graph": "A graph with a similar eigenvector structure of the input one."
            },
            "Raises:": {
                "NetworkXError": "If transformation has a value different from \u2018identity\u2019 or \u2018modularity\u2019"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Spectral Graph Forge (SGF) generates a random simple graph resembling the\nglobal properties of the given one.\nIt leverages the low-rank approximation of the associated adjacency matrix\ndriven by the alpha precision parameter.\nSGF preserves the number of nodes of the input graph and their ordering.\nThis way, nodes of output graphs resemble the properties of the input one\nand attributes can be directly mapped. It considers the graph adjacency matrices which can optionally be\ntransformed to other symmetric real matrices (currently transformation\noptions include identity and modularity ).\nThe modularity transformation, in the sense of Newman\u2019s modularity matrix\nallows the focusing on community structure related properties of the graph. SGF applies a low-rank approximation whose fixed rank is computed from the\nratio alpha of the input graph adjacency matrix dimension.\nThis step performs a filtering on the input eigenvectors similar to the low\npass filtering common in telecommunications. The filtered values (after truncation) are used as input to a Bernoulli\nsampling for constructing a random adjacency matrix.",
            "References": "[1]L. Baldesi, C. T. Butts, A. Markopoulou, \u201cSpectral Graph Forge:\nGraph Generation Targeting Modularity\u201d, IEEE Infocom, \u201818.https://arxiv.org/abs/1801.01715  [2]M. Newman, \u201cNetworks: an introduction\u201d, Oxford university press,\n2010",
            "Examples": "G=nx.karate_club_graph()\nH=nx.spectral_graph_forge(G,0.3)"
        }
    },
    {
        "Section ID": "maybe_regular_expander",
        "Description": [
            "Utility for creating a random regular expander.",
            "Returns a random \\(d\\) -regular graph on \\(n\\) nodes which is an expander\ngraph with very good probability."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes.",
                "d : int": "The degree of each node.",
                "create_using : Graph Instance or Constructor": "Indicator of type of graph to return.\nIf a Graph-type instance, then clear and use it.\nIf a constructor, call it to create an empty graph.\nUse the Graph constructor by default.",
                "max_tries : int. (default: 100)": "The number of allowed loops when generating each independent cycle",
                "seed : (default: None)": "Seed used to set random number generation state. See :ref`Randomness<randomness>`."
            },
            "Returns:": {
                "G : graph": "The constructed undirected graph."
            },
            "Raises:": {
                "NetworkXError": "If\\(d % 2 != 0\\)as the degree must be even.\nIf\\(n - 1\\)is less than :math:` 2d ` as the graph is complete at most.\nIf max_tries is reached"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The nodes are numbered from \\(0\\) to \\(n - 1\\) . The graph is generated by taking \\(d / 2\\) random independent cycles. Joel Friedman proved that in this model the resulting\ngraph is an expander with probability \\(1 - O(n^{-\\tau})\\) where \\(\\tau = \\lceil (\\sqrt{d - 1}) / 2 \\rceil - 1\\) . [1]",
            "References": "[1]Joel Friedman,\nA Proof of Alon\u2019s Second Eigenvalue Conjecture and Related Problems, 2004https://arxiv.org/abs/cs/0405020",
            "Examples": "G=nx.maybe_regular_expander(n=200,d=6,seed=8020)"
        }
    },
    {
        "Section ID": "parse_pajek",
        "Description": [
            "Parse Pajek format graph from string or iterable."
        ],
        "Field List": {
            "Parameters:": {
                "lines : string or iterable": "Data in Pajek format."
            },
            "Returns:": {
                "G : NetworkX graph": ""
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "core_number",
        "Description": [
            "Returns the core number for each node.",
            "A k-core is a maximal subgraph that contains nodes of degree k or more.",
            "The core number of a node is the largest value k of a k-core containing\nthat node."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "An undirected or directed graph"
            },
            "Returns:": {
                "core_number : dictionary": "A dictionary keyed by node to the core number."
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis a multigraph or contains self loops."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For directed graphs the node degree is defined to be the\nin-degree + out-degree.",
            "References": "[1]An O(m) Algorithm for Cores Decomposition of Networks\nVladimir Batagelj and Matjaz Zaversnik, 2003.https://arxiv.org/abs/cs.DS/0310049",
            "Examples": "degrees=[0,1,2,2,2,2,3]\nH=nx.havel_hakimi_graph(degrees)\nnx.core_number(H)\n# {0: 1, 1: 2, 2: 2, 3: 2, 4: 1, 5: 2, 6: 0}\nG=nx.DiGraph()\nG.add_edges_from([(1,2),(2,1),(2,3),(2,4),(3,4),(4,3)])\nnx.core_number(G)\n# {1: 2, 2: 2, 3: 2, 4: 2}"
        }
    },
    {
        "Section ID": "biconnected_components",
        "Description": [
            "Returns a generator of sets of nodes, one set for each biconnected\ncomponent of the graph",
            "Biconnected components are maximal subgraphs such that the removal of a\nnode (and all edges incident on that node) will not disconnect the\nsubgraph. Note that nodes may be part of more than one biconnected\ncomponent.  Those nodes are articulation points, or cut vertices.  The\nremoval of articulation points will increase the number of connected\ncomponents of the graph.",
            "Notice that by convention a dyad is considered a biconnected component."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "An undirected graph."
            },
            "Returns:": {
                "nodes : generator": "Generator of sets of nodes, one set for each biconnected component."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the input graph is not undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The algorithm to find articulation points and biconnected\ncomponents is implemented using a non-recursive depth-first-search\n(DFS) that keeps track of the highest level that back edges reach\nin the DFS tree.  A node n is an articulation point if, and only\nif, there exists a subtree rooted at n such that there is no\nback edge from any successor of n that links to a predecessor of n in the DFS tree.  By keeping track of all the edges traversed\nby the DFS we can obtain the biconnected components because all\nedges of a bicomponent will be traversed consecutively between\narticulation points.",
            "References": "[1]Hopcroft, J.; Tarjan, R. (1973).\n\u201cEfficient algorithms for graph manipulation\u201d.\nCommunications of the ACM 16: 372\u2013378. doi:10.1145/362248.362272",
            "Examples": "G=nx.lollipop_graph(5,1)\nprint(nx.is_biconnected(G))\n# False\nbicomponents=list(nx.biconnected_components(G))\nlen(bicomponents)\n# 2\nG.add_edge(0,5)\nprint(nx.is_biconnected(G))\n# True\nbicomponents=list(nx.biconnected_components(G))\nlen(bicomponents)\n# 1\nYou can generate a sorted list of biconnected components, largest\nfirst, using sort.\nG.remove_edge(0,5)\n[len(c)forcinsorted(nx.biconnected_components(G),key=len,reverse=True)]\n# [5, 2]\nIf you only want the largest connected component, it\u2019s more\nefficient to use max instead of sort.\nGc=max(nx.biconnected_components(G),key=len)\nTo create the components as subgraphs use:(G.subgraph(c).copy()forcinbiconnected_components(G))"
        }
    },
    {
        "Section ID": "directed_edge_swap",
        "Description": [
            "Swap three edges in a directed graph while keeping the node degrees fixed.",
            "A directed edge swap swaps three edges such that a -> b -> c -> d becomes\na -> c -> b -> d. This pattern of swapping allows all possible states with the\nsame in- and out-degree distribution in a directed graph to be reached.",
            "If the swap would create parallel edges (e.g. if a -> c already existed in the\nprevious example), another attempt is made to find a suitable trio of edges."
        ],
        "Field List": {
            "Parameters:": {
                "G : DiGraph": "A directed graph",
                "nswap : integer (optional, default=1)": "Number of three-edge (directed) swaps to perform",
                "max_tries : integer (optional, default=100)": "Maximum number of attempts to swap edges",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "G : DiGraph": "The graph after the edges are swapped."
            },
            "Raises:": {
                "NetworkXError": "IfGis not directed, or\nIf nswap > max_tries, or\nIf there are fewer than 4 nodes or 3 edges inG.",
                "NetworkXAlgorithmError": "If the number of swap attempts exceedsmax_triesbeforenswapswaps are made"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Does not enforce any connectivity constraints. The graph G is modified in place. A later swap is allowed to undo a previous swap.",
            "References": "[1]Erd\u0151s, P\u00e9ter L., et al. \u201cA Simple Havel-Hakimi Type Algorithm to Realize\nGraphical Degree Sequences of Directed Graphs.\u201d ArXiv:0905.4913 [Math],\nJan. 2010. https://doi.org/10.48550/arXiv.0905.4913.\nPublished  2010 in Elec. J. Combinatorics (17(1)). R66.\nhttp://www.combinatorics.org/Volume_17/PDF/v17i1r66.pdf  [2]\u201cCombinatorics - Reaching All Possible Simple Directed Graphs with a given\nDegree Sequence with 2-Edge Swaps.\u201d Mathematics Stack Exchange,https://math.stackexchange.com/questions/22272/. Accessed 30 May 2022."
        }
    },
    {
        "Section ID": "read_adjlist",
        "Description": [
            "Read graph in adjacency list format from path."
        ],
        "Field List": {
            "Parameters:": {
                "path : string or file": "Filename or file handle to read.\nFilenames ending in .gz or .bz2 will be uncompressed.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated.",
                "nodetype : Python type, optional": "Convert nodes to this type.",
                "comments : string, optional": "Marker for comment lines",
                "delimiter : string, optional": "Separator for node labels.  The default is whitespace."
            },
            "Returns:": {
                "G: NetworkX graph": "The graph corresponding to the lines in adjacency list format."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This format does not store graph or node data.",
            "Examples": "G=nx.path_graph(4)\nnx.write_adjlist(G,\"test.adjlist\")\nG=nx.read_adjlist(\"test.adjlist\")\nThe path can be a filehandle or a string with the name of the file. If a\nfilehandle is provided, it has to be opened in \u2018rb\u2019 mode.\nfh=open(\"test.adjlist\",\"rb\")\nG=nx.read_adjlist(fh)\nFilenames ending in .gz or .bz2 will be compressed.\nnx.write_adjlist(G,\"test.adjlist.gz\")\nG=nx.read_adjlist(\"test.adjlist.gz\")\nThe optional nodetype is a function to convert node strings to nodetype.\nFor example\nG=nx.read_adjlist(\"test.adjlist\",nodetype=int)\nwill attempt to convert all nodes to integer type.\nSince nodes must be hashable, the function nodetype must return hashable\ntypes (e.g. int, float, str, frozenset - or tuples of those, etc.)\nThe optional create_using parameter indicates the type of NetworkX graph\ncreated.  The default isnx.Graph, an undirected graph.\nTo read the data as a directed graph use\nG=nx.read_adjlist(\"test.adjlist\",create_using=nx.DiGraph)"
        }
    },
    {
        "Section ID": "generate_edgelist",
        "Description": [
            "Generate a single line of the bipartite graph G in edge list format."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "The graph is assumed to have node attributepartset to 0,1 representing\nthe two graph parts",
                "delimiter : string, optional": "Separator for node labels",
                "data : bool or list of keys": "If False generate no edge data.  If True use a dictionary\nrepresentation of edge data.  If a list of keys use a list of data\nvalues corresponding to the keys."
            },
            "Returns:": {
                "lines : string": "Lines of data in adjlist format."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "fromnetworkx.algorithmsimportbipartite\nG=nx.path_graph(4)\nG.add_nodes_from([0,2],bipartite=0)\nG.add_nodes_from([1,3],bipartite=1)\nG[1][2][\"weight\"]=3\nG[2][3][\"capacity\"]=12\nforlineinbipartite.generate_edgelist(G,data=False):\nprint(line)\n# 0 1\n# 2 1\n# 2 3\nforlineinbipartite.generate_edgelist(G):\nprint(line)\n# 0 1 {}\n# 2 1 {'weight': 3}\n# 2 3 {'capacity': 12}\nforlineinbipartite.generate_edgelist(G,data=[\"weight\"]):\nprint(line)\n# 0 1\n# 2 1 3\n# 2 3"
        }
    },
    {
        "Section ID": "steiner_tree",
        "Description": [
            "Return an approximation to the minimum Steiner tree of a graph.",
            "The minimum Steiner tree of G w.r.t a set of terminal_nodes (also S )\nis a tree within G that spans those nodes and has minimum size (sum of\nedge weights) among all such trees.",
            "The approximation algorithm is specified with the method keyword\nargument. All three available algorithms produce a tree whose weight is\nwithin a (2-(2/l)) factor of the weight of the optimal Steiner tree,\nwhere l is the minimum number of leaf nodes across all possible Steiner\ntrees."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "terminal_nodes : list": "A list of terminal nodes for which minimum steiner tree is\nto be found.",
                "weight : string (default = \u2018weight\u2019)": "Use the edge attribute specified by this string as the edge weight.\nAny edge attribute not present defaults to 1.",
                "method : string, optional (default = \u2018mehlhorn\u2019)": "The algorithm to use to approximate the Steiner tree.\nSupported options: \u2018kou\u2019, \u2018mehlhorn\u2019.\nOther inputs produce a ValueError."
            },
            "Returns:": {
                "NetworkX graph": "Approximation to the minimum steiner tree ofGinduced byterminal_nodes."
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis directed.",
                "ValueError": "If the specifiedmethodis not supported."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For multigraphs, the edge between two nodes with minimum weight is the\nedge put into the Steiner tree.",
            "References": "[1]Steiner_tree_problem on Wikipedia.https://en.wikipedia.org/wiki/Steiner_tree_problem  [2]Kou, L., G. Markowsky, and L. Berman. 1981.\n\u2018A Fast Algorithm for Steiner Trees\u2019.\nActa Informatica 15 (2): 141\u201345.https://doi.org/10.1007/BF00288961.  [3]Mehlhorn, Kurt. 1988.\n\u2018A Faster Approximation Algorithm for the Steiner Problem in Graphs\u2019.\nInformation Processing Letters 27 (3): 125\u201328.https://doi.org/10.1016/0020-0190(88)90066-X."
        }
    },
    {
        "Section ID": "is_k_edge_connected",
        "Description": [
            "Tests to see if a graph is k-edge-connected.",
            "Is it impossible to disconnect the graph by removing fewer than k edges?\nIf so, then G is k-edge-connected."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "An undirected graph.",
                "k : integer": "edge connectivity to test for"
            },
            "Returns:": {
                "boolean": "True if G is k-edge-connected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.barbell_graph(10,0)\nnx.is_k_edge_connected(G,k=1)\n# True\nnx.is_k_edge_connected(G,k=2)\n# False"
        }
    },
    {
        "Section ID": "spectral_bisection",
        "Description": [
            "Bisect the graph using the Fiedler vector.",
            "This method uses the Fiedler vector to bisect a graph.\nThe partition is defined by the nodes which are associated with\neither positive or negative values in the vector."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "",
                "weight : str, optional (default: weight)": "The data key used to determine the weight of each edge. If None, then\neach edge has unit weight.",
                "normalized : bool, optional (default: False)": "Whether the normalized Laplacian matrix is used.",
                "tol : float, optional (default: 1e-8)": "Tolerance of relative residual in eigenvalue computation.",
                "method : string, optional (default: \u2018tracemin_pcg\u2019)": "Method of eigenvalue computation. It must be one of the tracemin\noptions shown below (TraceMIN), \u2018lanczos\u2019 (Lanczos iteration)\nor \u2018lobpcg\u2019 (LOBPCG).The TraceMIN algorithm uses a linear system solver. The following\nvalues allow specifying the solver to be used.ValueSolver\u2018tracemin_pcg\u2019Preconditioned conjugate gradient method\u2018tracemin_lu\u2019LU factorization",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "bisection : tuple of sets": "Sets with the bisection of nodes"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]M. E. J Newman \u2018Networks: An Introduction\u2019, pages 364-370\nOxford University Press 2011.",
            "Examples": "G=nx.barbell_graph(3,0)\nnx.spectral_bisection(G)\n# ({0, 1, 2}, {3, 4, 5})"
        }
    },
    {
        "Section ID": "tree_all_pairs_lowest_common_ancestor",
        "Description": [
            "Yield the lowest common ancestor for sets of pairs in a tree."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX directed graph (must be a tree)": "",
                "root : node, optional (default: None)": "The root of the subtree to operate on.\nIf None, assume the entire graph has exactly one source and use that.",
                "pairs : iterable or iterator of pairs of nodes, optional (default: None)": "The pairs of interest. If None, Defaults to all pairs of nodes\nunderrootthat have a lowest common ancestor."
            },
            "Returns:": {
                "lcas : generator of tuples((u,v),lca)whereuandvare nodes": "inpairsandlcais their lowest common ancestor."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Only defined on non-null trees represented with directed edges from\nparents to children. Uses Tarjan\u2019s off-line lowest-common-ancestors\nalgorithm. Runs in time \\(O(4 \\times (V + E + P))\\) time, where 4 is the largest\nvalue of the inverse Ackermann function likely to ever come up in actual\nuse, and \\(P\\) is the number of pairs requested (or \\(V^2\\) if all are needed). Tarjan, R. E. (1979), \u201cApplications of path compression on balanced trees\u201d,\nJournal of the ACM 26 (4): 690-715, doi:10.1145/322154.322161.",
            "Examples": "importpprint\nG=nx.DiGraph([(1,3),(2,4),(1,2)])\npprint.pprint(dict(nx.tree_all_pairs_lowest_common_ancestor(G)))\n# {(1, 1): 1,\n#  (2, 1): 1,\n#  (2, 2): 2,\n#  (3, 1): 1,\n#  (3, 2): 1,\n#  (3, 3): 3,\n#  (3, 4): 1,\n#  (4, 1): 1,\n#  (4, 2): 2,\n#  (4, 4): 4}\nWe can also usepairsargument to specify the pairs of nodes for which we\nwant to compute lowest common ancestors. Here is an example:\ndict(nx.tree_all_pairs_lowest_common_ancestor(G,pairs=[(1,4),(2,3)]))\n# {(2, 3): 1, (1, 4): 1}"
        }
    },
    {
        "Section ID": "is_digraphical",
        "Description": [
            "Returns True if some directed graph can realize the in- and out-degree\nsequences."
        ],
        "Field List": {
            "Parameters:": {
                "in_sequence : list or iterable container": "A sequence of integer node in-degrees",
                "out_sequence : list or iterable container": "A sequence of integer node out-degrees"
            },
            "Returns:": {
                "valid : bool": "True if in and out-sequences are digraphic False if not."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm is from Kleitman and Wang [1] .\nThe worst case runtime is \\(O(s \\times \\log n)\\) where \\(s\\) and \\(n\\) are the\nsum and length of the sequences respectively.",
            "References": "[1]D.J. Kleitman and D.L. Wang\nAlgorithms for Constructing Graphs and Digraphs with Given Valences\nand Factors, Discrete Mathematics, 6(1), pp. 79-88 (1973)",
            "Examples": "G=nx.DiGraph([(1,2),(1,3),(2,3),(3,4),(4,2),(5,1),(5,4)])\nin_seq=(dforn,dinG.in_degree())\nout_seq=(dforn,dinG.out_degree())\nnx.is_digraphical(in_seq,out_seq)\n# True\nTo test a non-digraphical scenario:\n>>> in_seq_list = [d for n, d in G.in_degree()]\n>>> in_seq_list[-1] += 1\n>>> nx.is_digraphical(in_seq_list, out_seq)\nFalse"
        }
    },
    {
        "Section ID": "panther_similarity",
        "Description": [
            "Returns the Panther similarity of nodes in the graph G to node v .",
            "Panther is a similarity metric that says \u201ctwo objects are considered\nto be similar if they frequently appear on the same paths.\u201d [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A NetworkX graph",
                "source : node": "Source node for which to find the topksimilar other nodes",
                "k : int (default = 5)": "The number of most similar nodes to return.",
                "path_length : int (default = 5)": "How long the randomly generated paths should be (Tin[1])",
                "c : float (default = 0.5)": "A universal positive constant used to scale the number\nof sample random paths to generate.",
                "delta : float (default = 0.1)": "The probability that the similarity\\(S\\)is not an epsilon-approximation to (R, phi),\nwhere\\(R\\)is the number of random paths and\\(\\phi\\)is the probability\nthat an element sampled from a set\\(A \\subseteq D\\), where\\(D\\)is the domain.",
                "eps : float or None (default = None)": "The error bound. Per[1], a good value issqrt(1/|E|). Therefore,\nif no value is provided, the recommended computed value will be used.",
                "weight : string or None, optional (default=\u201dweight\u201d)": "The name of an edge attribute that holds the numerical value\nused as a weight. If None then each edge has weight 1."
            },
            "Returns:": {
                "similarity : dictionary": "Dictionary of nodes to similarity scores (as floats). Note:\nthe self-similarity (i.e.,v) will not be included in\nthe returned dictionary. So, fork=5, a dictionary of\ntop 4 nodes and their similarity scores will be returned."
            },
            "Raises:": {
                "NetworkXUnfeasible": "Ifsourceis an isolated node.",
                "NodeNotFound": "Ifsourceis not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The isolated nodes in G are ignored.",
            "References": "[1](1,2,3)Zhang, J., Tang, J., Ma, C., Tong, H., Jing, Y., & Li, J.\nPanther: Fast top-k similarity search on large networks.\nIn Proceedings of the ACM SIGKDD International Conference\non Knowledge Discovery and Data Mining (Vol. 2015-August, pp. 1445\u20131454).\nAssociation for Computing Machinery.https://doi.org/10.1145/2783258.2783267.",
            "Examples": "G=nx.star_graph(10)\nsim=nx.panther_similarity(G,0)"
        }
    },
    {
        "Section ID": "degree_mixing_matrix",
        "Description": [
            "Returns mixing matrix for attribute."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "NetworkX graph object.",
                "x: string (\u2018in\u2019,\u2019out\u2019)": "The degree type for source node (directed graphs only).",
                "y: string (\u2018in\u2019,\u2019out\u2019)": "The degree type for target node (directed graphs only).",
                "nodes: list or iterable (optional)": "Build the matrix using only nodes in container.\nThe default is all nodes.",
                "weight: string or None, optional (default=None)": "The edge attribute that holds the numerical value used\nas a weight.  If None, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node.",
                "normalized : bool (default=True)": "Return counts if False or probabilities if True.",
                "mapping : dictionary, optional": "Mapping from node degree to integer index in matrix.\nIf not specified, an arbitrary ordering will be used."
            },
            "Returns:": {
                "m: numpy array": "Counts, or joint probability, of occurrence of node degree."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Definitions of degree mixing matrix vary on whether the matrix\nshould include rows for degree values that don\u2019t arise. Here we\ndo not include such empty-rows. But you can force them to appear\nby inputting a mapping that includes those values. See examples.",
            "Examples": "G=nx.star_graph(3)\nmix_mat=nx.degree_mixing_matrix(G)\nmix_mat\n# array([[0. , 0.5],\n#        [0.5, 0. ]])\nIf you want every possible degree to appear as a row, even if no nodes\nhave that degree, usemappingas follows,\nmax_degree=max(degforn,deginG.degree)\nmapping={x:xforxinrange(max_degree+1)}# identity mapping\nmix_mat=nx.degree_mixing_matrix(G,mapping=mapping)\nmix_mat\n# array([[0. , 0. , 0. , 0. ],\n#        [0. , 0. , 0. , 0.5],\n#        [0. , 0. , 0. , 0. ],\n#        [0. , 0.5, 0. , 0. ]])"
        }
    },
    {
        "Section ID": "chordless_cycles",
        "Description": [
            "Find simple chordless cycles of a graph.",
            "A simplecycle is a closed path where no node appears twice.  In a simple\ncycle, a chord is an additional edge between two nodes in the cycle.  A chordlesscycle is a simple cycle without chords.  Said differently, a\nchordless cycle is a cycle C in a graph G where the number of edges in the\ninduced graph G[C] is equal to the length of C .",
            "Note that some care must be taken in the case that G is not a simple graph\nnor a simple digraph.  Some authors limit the definition of chordless cycles\nto have a prescribed minimum length; we do not.",
            "In a directed graph, two chordless cycles are distinct if they are not\ncyclic permutations of each other.  In an undirected graph, two chordless\ncycles are distinct if they are not cyclic permutations of each other nor of\nthe other\u2019s reversal.",
            "Optionally, the cycles are bounded in length.",
            "We use an algorithm strongly inspired by that of Dias et al [1] .  It has\nbeen modified in the following ways:"
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX DiGraph": "A directed graph",
                "length_bound : int or None, optional (default=None)": "If length_bound is an int, generate all simple cycles of G with length at\nmost length_bound.  Otherwise, generate all simple cycles of G."
            },
            "Yields:": {
                "list of nodes": "Each cycle is represented by a list of nodes along the cycle."
            },
            "Raises:": {
                "ValueError": "when length_bound < 0."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "When length_bound is None, and the graph is simple, the time complexity is \\(O((n+e)(c+1))\\) for \\(n\\) nodes, \\(e\\) edges and \\(c\\) chordless cycles.",
            "References": "[1]Efficient enumeration of chordless cycles\nE. Dias and D. Castonguay and H. Longo and W.A.R. Jradihttps://arxiv.org/abs/1309.1051",
            "Examples": "sorted(list(nx.chordless_cycles(nx.complete_graph(4))))\n# [[1, 0, 2], [1, 0, 3], [2, 0, 3], [2, 1, 3]]"
        }
    },
    {
        "Section ID": "bipartite_layout",
        "Description": [
            "Position nodes in two straight lines."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph or list of nodes": "A position will be assigned to every node in G.",
                "nodes : list or container": "Nodes in one node set of the bipartite graph.\nThis set will be placed on left or top.",
                "align : string (default=\u2019vertical\u2019)": "The alignment of nodes. Vertical or horizontal.",
                "scale : number (default: 1)": "Scale factor for positions.",
                "center : array-like or None": "Coordinate pair around which to center the layout.",
                "aspect_ratio : number (default=4/3):": "The ratio of the width to the height of the layout."
            },
            "Returns:": {
                "pos : dict": "A dictionary of positions keyed by node."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm currently only works in two dimensions and does not\ntry to minimize edge crossings.",
            "Examples": "G=nx.bipartite.gnmk_random_graph(3,5,10,seed=123)\ntop=nx.bipartite.sets(G)[0]\npos=nx.bipartite_layout(G,top)"
        }
    },
    {
        "Section ID": "degree_centrality",
        "Description": [
            "Compute the degree centrality for nodes in a bipartite network.",
            "The degree centrality for a node v is the fraction of nodes\nconnected to it."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A bipartite network",
                "nodes : list or container": "Container with all nodes in one bipartite node set."
            },
            "Returns:": {
                "centrality : dictionary": "Dictionary keyed by node with bipartite degree centrality as the value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The nodes input parameter must contain all nodes in one bipartite node set,\nbut the dictionary returned contains all nodes from both bipartite node\nsets. See bipartitedocumentation for further details on how bipartite graphs are handled in NetworkX. For unipartite networks, the degree centrality values are\nnormalized by dividing by the maximum possible degree (which is n-1 where n is the number of nodes in G). In the bipartite case, the maximum possible degree of a node in a\nbipartite node set is the number of nodes in the opposite node set [1] .  The degree centrality for a node v in the bipartite\nsets U with n nodes and V with m nodes is",
            "References": "[1]Borgatti, S.P. and Halgin, D. In press. \u201cAnalyzing Affiliation\nNetworks\u201d. In Carrington, P. and Scott, J. (eds) The Sage Handbook\nof Social Network Analysis. Sage Publications.https://dx.doi.org/10.4135/9781446294413.n28",
            "Examples": "G=nx.wheel_graph(5)\ntop_nodes={0,1,2}\nnx.bipartite.degree_centrality(G,nodes=top_nodes)\n# {0: 2.0, 1: 1.5, 2: 1.5, 3: 1.0, 4: 1.0}"
        }
    },
    {
        "Section ID": "bethe_hessian_matrix",
        "Description": [
            "Returns the Bethe Hessian matrix of G.",
            "The Bethe Hessian is a family of matrices parametrized by r, defined as\nH(r) = (r^2 - 1) I - r A + D where A is the adjacency matrix, D is the\ndiagonal matrix of node degrees, and I is the identify matrix. It is equal\nto the graph laplacian when the regularizer r = 1.",
            "The default choice of regularizer should be the ratio [2]"
        ],
        "Field List": {
            "Parameters:": {
                "G : Graph": "A NetworkX graph",
                "r : float": "Regularizer parameter",
                "nodelist : list, optional": "The rows and columns are ordered according to the nodes in nodelist.\nIf nodelist is None, then the ordering is produced byG.nodes()."
            },
            "Returns:": {
                "H : scipy.sparse.csr_array": "The Bethe Hessian matrix ofG, with parameterr."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]A. Saade, F. Krzakala and L. Zdeborov\u00e1\n\u201cSpectral Clustering of Graphs with the Bethe Hessian\u201d,\nAdvances in Neural Information Processing Systems, 2014.  [2]C. M. Le, E. Levina\n\u201cEstimating the number of communities in networks by spectral methods\u201d\narXiv:1507.00827, 2015.",
            "Examples": "k=[3,2,2,1,0]\nG=nx.havel_hakimi_graph(k)\nH=nx.bethe_hessian_matrix(G)\nH.toarray()\n# array([[ 3.5625, -1.25  , -1.25  , -1.25  ,  0.    ],\n#        [-1.25  ,  2.5625, -1.25  ,  0.    ,  0.    ],\n#        [-1.25  , -1.25  ,  2.5625,  0.    ,  0.    ],\n#        [-1.25  ,  0.    ,  0.    ,  1.5625,  0.    ],\n#        [ 0.    ,  0.    ,  0.    ,  0.    ,  0.5625]])"
        }
    },
    {
        "Section ID": "complement",
        "Description": [
            "Returns the graph complement of G."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph"
            },
            "Returns:": {
                "GC : A new graph.": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Note that complement does not create self-loops and also\ndoes not produce parallel edges for MultiGraphs. Graph, node, and edge data are not propagated to the new graph.",
            "Examples": "G=nx.Graph([(1,2),(1,3),(2,3),(3,4),(3,5)])\nG_complement=nx.complement(G)\nG_complement.edges()# This shows the edges of the complemented graph\n# EdgeView([(1, 4), (1, 5), (2, 4), (2, 5), (4, 5)])"
        }
    },
    {
        "Section ID": "projected_graph",
        "Description": [
            "Returns the projection of B onto one of its node sets.",
            "Returns the graph G that is the projection of the bipartite graph B\nonto the specified nodes. They retain their attributes and are connected\nin G if they have a common neighbor in B."
        ],
        "Field List": {
            "Parameters:": {
                "B : NetworkX graph": "The input graph should be bipartite.",
                "nodes : list or iterable": "Nodes to project onto (the \u201cbottom\u201d nodes).",
                "multigraph: bool (default=False)": "If True return a multigraph where the multiple edges represent multiple\nshared neighbors.  They edge key in the multigraph is assigned to the\nlabel of the neighbor."
            },
            "Returns:": {
                "Graph : NetworkX graph or multigraph": "A graph that is the projection onto the given nodes."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "No attempt is made to verify that the input graph B is bipartite.\nReturns a simple graph that is the projection of the bipartite graph B\nonto the set of nodes given in list nodes.  If multigraph=True then\na multigraph is returned with an edge for every shared neighbor. Directed graphs are allowed as input.  The output will also then\nbe a directed graph with edges if there is a directed path between\nthe nodes. The graph and node properties are (shallow) copied to the projected graph. See bipartitedocumentation for further details on how bipartite graphs are handled in NetworkX.",
            "Examples": "fromnetworkx.algorithmsimportbipartite\nB=nx.path_graph(4)\nG=bipartite.projected_graph(B,[1,3])\nlist(G)\n# [1, 3]\nlist(G.edges())\n# [(1, 3)]\nIf nodesa, andbare connected through both nodes 1 and 2 then\nbuilding a multigraph results in two edges in the projection onto\n[a,b]:\nB=nx.Graph()\nB.add_edges_from([(\"a\",1),(\"b\",1),(\"a\",2),(\"b\",2)])\nG=bipartite.projected_graph(B,[\"a\",\"b\"],multigraph=True)\nprint([sorted((u,v))foru,vinG.edges()])\n# [['a', 'b'], ['a', 'b']]"
        }
    },
    {
        "Section ID": "tree_isomorphism",
        "Description": [
            "Given two undirected (or free) trees t1 and t2 ,\nthis routine will determine if they are isomorphic.\nIt returns the isomorphism, a mapping of the nodes of t1 onto the nodes\nof t2 , such that two trees are then identical.",
            "Note that two trees may have more than one isomorphism, and this\nroutine just returns one valid mapping."
        ],
        "Field List": {
            "Parameters:": {
                "t1 : undirected NetworkX graph": "One of the trees being compared",
                "t2 : undirected NetworkX graph": "The other tree being compared"
            },
            "Returns:": {
                "isomorphism : list": "A list of pairs in which the left element is a node int1and the right element is a node int2.  The pairs are in\narbitrary order.  If the nodes in one tree is mapped to the names in\nthe other, then trees will be identical. Note that an isomorphism\nwill not necessarily be unique.Ift1andt2are not isomorphic, then it returns the empty list."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This runs in O(n*log(n)) time for trees with n nodes."
        }
    },
    {
        "Section ID": "optimize_edit_paths",
        "Description": [
            "GED (graph edit distance) calculation: advanced interface.",
            "Graph edit path is a sequence of node and edge edit operations\ntransforming graph G1 to graph isomorphic to G2.  Edit operations\ninclude substitutions, deletions, and insertions.",
            "Graph edit distance is defined as minimum cost of edit path."
        ],
        "Field List": {
            "Parameters:": {
                "G1, G2: graphs": "The two graphs G1 and G2 must be of the same type.",
                "node_match : callable": "A function that returns True if node n1 in G1 and n2 in G2\nshould be considered equal during matching.The function will be called likenode_match(G1.nodes[n1], G2.nodes[n2]).That is, the function will receive the node attribute\ndictionaries for n1 and n2 as inputs.Ignored if node_subst_cost is specified.  If neither\nnode_match nor node_subst_cost are specified then node\nattributes are not considered.",
                "edge_match : callable": "A function that returns True if the edge attribute dictionaries\nfor the pair of nodes (u1, v1) in G1 and (u2, v2) in G2 should\nbe considered equal during matching.The function will be called likeedge_match(G1[u1][v1], G2[u2][v2]).That is, the function will receive the edge attribute\ndictionaries of the edges under consideration.Ignored if edge_subst_cost is specified.  If neither\nedge_match nor edge_subst_cost are specified then edge\nattributes are not considered.",
                "node_subst_cost, node_del_cost, node_ins_cost : callable": "Functions that return the costs of node substitution, node\ndeletion, and node insertion, respectively.The functions will be called likenode_subst_cost(G1.nodes[n1], G2.nodes[n2]),\nnode_del_cost(G1.nodes[n1]),\nnode_ins_cost(G2.nodes[n2]).That is, the functions will receive the node attribute\ndictionaries as inputs.  The functions are expected to return\npositive numeric values.Function node_subst_cost overrides node_match if specified.\nIf neither node_match nor node_subst_cost are specified then\ndefault node substitution cost of 0 is used (node attributes\nare not considered during matching).If node_del_cost is not specified then default node deletion\ncost of 1 is used.  If node_ins_cost is not specified then\ndefault node insertion cost of 1 is used.",
                "edge_subst_cost, edge_del_cost, edge_ins_cost : callable": "Functions that return the costs of edge substitution, edge\ndeletion, and edge insertion, respectively.The functions will be called likeedge_subst_cost(G1[u1][v1], G2[u2][v2]),\nedge_del_cost(G1[u1][v1]),\nedge_ins_cost(G2[u2][v2]).That is, the functions will receive the edge attribute\ndictionaries as inputs.  The functions are expected to return\npositive numeric values.Function edge_subst_cost overrides edge_match if specified.\nIf neither edge_match nor edge_subst_cost are specified then\ndefault edge substitution cost of 0 is used (edge attributes\nare not considered during matching).If edge_del_cost is not specified then default edge deletion\ncost of 1 is used.  If edge_ins_cost is not specified then\ndefault edge insertion cost of 1 is used.",
                "upper_bound : numeric": "Maximum edit distance to consider.",
                "strictly_decreasing : bool": "If True, return consecutive approximations of strictly\ndecreasing cost.  Otherwise, return all edit paths of cost\nless than or equal to the previous minimum cost.",
                "roots : 2-tuple": "Tuple where first element is a node in G1 and the second\nis a node in G2.\nThese nodes are forced to be matched in the comparison to\nallow comparison between rooted graphs.",
                "timeout : numeric": "Maximum number of seconds to execute.\nAfter timeout is met, the current best GED is returned."
            },
            "Returns:": {
                "Generator of tuples (node_edit_path, edge_edit_path, cost)": "node_edit_path : list of tuples (u, v)\nedge_edit_path : list of tuples ((u1, v1), (u2, v2))\ncost : numeric"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Zeina Abu-Aisheh, Romain Raveaux, Jean-Yves Ramel, Patrick\nMartineau. An Exact Graph Edit Distance Algorithm for Solving\nPattern Recognition Problems. 4th International Conference on\nPattern Recognition Applications and Methods 2015, Jan 2015,\nLisbon, Portugal. 2015,\n<10.5220/0005209202710278>. <hal-01168816>https://hal.archives-ouvertes.fr/hal-01168816"
        }
    },
    {
        "Section ID": "single_source_dijkstra_path",
        "Description": [
            "Find shortest weighted paths in G from a source node.",
            "Compute shortest path between source and all other reachable\nnodes for a weighted graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node": "Starting node for path.",
                "cutoff : integer or float, optional": "Length (sum of edge weights) at which the search is stopped.\nIf cutoff is provided, only return paths with summed weight <= cutoff.",
                "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge."
            },
            "Returns:": {
                "paths : dictionary": "Dictionary of shortest path lengths keyed by target."
            },
            "Raises:": {
                "NodeNotFound": "Ifsourceis not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The weight function can be used to hide edges by returning None.\nSo weight=lambdau,v,d:1ifd['color']==\"red\"elseNone will find the shortest red path.",
            "Examples": "G=nx.path_graph(5)\npath=nx.single_source_dijkstra_path(G,0)\npath[4]\n# [0, 1, 2, 3, 4]"
        }
    },
    {
        "Section ID": "dfs_postorder_nodes",
        "Description": [
            "Generate nodes in a depth-first-search post-ordering starting at source."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node, optional": "Specify starting node for depth-first search.",
                "depth_limit : int, optional (default=len(G))": "Specify the maximum search depth.",
                "sort_neighbors : function (default=None)": "A function that takes an iterator over nodes as the input, and\nreturns an iterable of the same nodes with a custom ordering.\nFor example,sortedwill sort the nodes in increasing order."
            },
            "Returns:": {
                "nodes: generator": "A generator of nodes in a depth-first-search post-ordering."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "If a source is not specified then a source is chosen arbitrarily and\nrepeatedly until all components in the graph are searched. The implementation of this function is adapted from David Eppstein\u2019s\ndepth-first search function in PADS , with modifications\nto allow depth limits based on the Wikipedia article\n\u201c Depth-limited search \u201d.",
            "Examples": "G=nx.path_graph(5)\nlist(nx.dfs_postorder_nodes(G,source=0))\n# [4, 3, 2, 1, 0]\nlist(nx.dfs_postorder_nodes(G,source=0,depth_limit=2))\n# [1, 0]"
        }
    },
    {
        "Section ID": "tree_broadcast_center",
        "Description": [
            "Return the Broadcast Center of the tree G .",
            "The broadcast center of a graph G denotes the set of nodes having\nminimum broadcast time [1] . This is a linear algorithm for determining\nthe broadcast center of a tree with N nodes, as a by-product it also\ndetermines the broadcast time from the broadcast center."
        ],
        "Field List": {
            "Parameters:": {
                "G : undirected graph": "The graph should be an undirected tree"
            },
            "Returns:": {
                "BC : (int, set) tuple": "minimum broadcast number of the tree, set of broadcast centers"
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the graph is directed or is a multigraph."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Slater, P.J., Cockayne, E.J., Hedetniemi, S.T,\nInformation dissemination in trees. SIAM J.Comput. 10(4), 692\u2013701 (1981)"
        }
    },
    {
        "Section ID": "mycielski_graph",
        "Description": [
            "Generator for the n_th Mycielski Graph.",
            "The Mycielski family of graphs is an infinite set of graphs. \\(M_1\\) is the singleton graph, \\(M_2\\) is two vertices with an\nedge, and, for \\(i > 2\\) , \\(M_i\\) is the Mycielskian of \\(M_{i-1}\\) .",
            "More information can be found at http://mathworld.wolfram.com/MycielskiGraph.html"
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The desired Mycielski Graph."
            },
            "Returns:": {
                "M : graph": "The n_th Mycielski Graph"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The first graph in the Mycielski sequence is the singleton graph.\nThe Mycielskian of this graph is not the \\(P_2\\) graph, but rather the \\(P_2\\) graph with an extra, isolated vertex. The second Mycielski\ngraph is the \\(P_2\\) graph, so the first two are hard coded.\nThe remaining graphs are generated using the Mycielski operation."
        }
    },
    {
        "Section ID": "hits",
        "Description": [
            "Returns HITS hubs and authorities values for nodes.",
            "The HITS algorithm computes two numbers for a node.\nAuthorities estimates the node value based on the incoming links.\nHubs estimates the node value based on outgoing links."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "max_iter : integer, optional": "Maximum number of iterations in power method.",
                "tol : float, optional": "Error tolerance used to check convergence in power method iteration.",
                "nstart : dictionary, optional": "Starting value of each node for power method iteration.",
                "normalized : bool (default=True)": "Normalize results by the sum of all of the values."
            },
            "Returns:": {
                "(hubs,authorities) : two-tuple of dictionaries": "Two dictionaries keyed by node containing the hub and authority\nvalues."
            },
            "Raises:": {
                "PowerIterationFailedConvergence": "If the algorithm fails to converge to the specified tolerance\nwithin the specified number of iterations of the power iteration\nmethod."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The eigenvector calculation is done by the power iteration method\nand has no guarantee of convergence.  The iteration will stop\nafter max_iter iterations or an error tolerance of\nnumber_of_nodes(G)*tol has been reached. The HITS algorithm was designed for directed graphs but this\nalgorithm does not check if the input graph is directed and will\nexecute on undirected graphs.",
            "References": "[1]A. Langville and C. Meyer,\n\u201cA survey of eigenvector methods of web information retrieval.\u201dhttp://citeseer.ist.psu.edu/713792.html  [2]Jon Kleinberg,\nAuthoritative sources in a hyperlinked environment\nJournal of the ACM 46 (5): 604-32, 1999.\ndoi:10.1145/324133.324140.\nhttp://www.cs.cornell.edu/home/kleinber/auth.pdf.",
            "Examples": "G=nx.path_graph(4)\nh,a=nx.hits(G)"
        }
    },
    {
        "Section ID": "transitive_closure_dag",
        "Description": [
            "Returns the transitive closure of a directed acyclic graph.",
            "This function is faster than the function transitive_closure , but fails\nif the graph has a cycle.",
            "The transitive closure of G = (V,E) is a graph G+ = (V,E+) such that\nfor all v, w in V there is an edge (v, w) in E+ if and only if there\nis a non-null path from v to w in G."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX DiGraph": "A directed acyclic graph (DAG)",
                "topo_order: list or tuple, optional": "A topological order for G (if None, the function will compute one)"
            },
            "Returns:": {
                "NetworkX DiGraph": "The transitive closure ofG"
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis not directed",
                "NetworkXUnfeasible": "IfGhas a cycle"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm is probably simple enough to be well-known but I didn\u2019t find\na mention in the literature.",
            "Examples": "DG=nx.DiGraph([(1,2),(2,3)])\nTC=nx.transitive_closure_dag(DG)\nTC.edges()\n# OutEdgeView([(1, 2), (1, 3), (2, 3)])"
        }
    },
    {
        "Section ID": "kamada_kawai_layout",
        "Description": [
            "Position nodes using Kamada-Kawai path-length cost-function."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph or list of nodes": "A position will be assigned to every node in G.",
                "dist : dict (default=None)": "A two-level dictionary of optimal distances between nodes,\nindexed by source and destination node.\nIf None, the distance is computed using shortest_path_length().",
                "pos : dict or None  optional (default=None)": "Initial positions for nodes as a dictionary with node as keys\nand values as a coordinate list or tuple.  If None, then use\ncircular_layout() for dim >= 2 and a linear layout for dim == 1.",
                "weight : string or None   optional (default=\u2019weight\u2019)": "The edge attribute that holds the numerical value used for\nthe edge weight.  If None, then all edge weights are 1.",
                "scale : number (default: 1)": "Scale factor for positions.",
                "center : array-like or None": "Coordinate pair around which to center the layout.",
                "dim : int": "Dimension of layout."
            },
            "Returns:": {
                "pos : dict": "A dictionary of positions keyed by node"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.path_graph(4)\npos=nx.kamada_kawai_layout(G)"
        }
    },
    {
        "Section ID": "minimum_cut",
        "Description": [
            "Compute the value and the node partition of a minimum (s, t)-cut.",
            "Use the max-flow min-cut theorem, i.e., the capacity of a minimum\ncapacity cut is equal to the flow value of a maximum flow."
        ],
        "Field List": {
            "Parameters:": {
                "flowG : NetworkX graph": "Edges of the graph are expected to have an attribute called\n\u2018capacity\u2019. If this attribute is not present, the edge is\nconsidered to have infinite capacity.",
                "_s : node": "Source node for the flow.",
                "_t : node": "Sink node for the flow.",
                "capacity : string": "Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: \u2018capacity\u2019.",
                "flow_func : function": "A function for computing the maximum flow among a pair of nodes\nin a capacitated graph. The function has to accept at least three\nparameters: a Graph or Digraph, a source node, and a target node.\nAnd return a residual network that follows NetworkX conventions\n(see Notes). If flow_func is None, the default maximum\nflow function (preflow_push()) is used. See below for\nalternative algorithms. The choice of the default function may change\nfrom version to version and should not be relied on. Default value:\nNone.",
                "kwargs : Any other keyword parameter is passed to the function that": "computes the maximum flow."
            },
            "Returns:": {
                "cut_value : integer, float": "Value of the minimum cut.",
                "partition : pair of node sets": "A partitioning of the nodes that defines a minimum cut."
            },
            "Raises:": {
                "NetworkXUnbounded": "If the graph has a path of infinite capacity, all cuts have\ninfinite capacity and the function raises a NetworkXError."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The function used in the flow_func parameter has to return a residual\nnetwork that follows NetworkX conventions: The residual network R from an input graph G has the\nsame nodes as G . R is a DiGraph that contains a pair\nof edges (u,v) and (v,u) iff (u,v) is not a\nself-loop, and at least one of (u,v) and (v,u) exists\nin G . For each edge (u,v) in R , R[u][v]['capacity'] is equal to the capacity of (u,v) in G if it exists\nin G or zero otherwise. If the capacity is infinite, R[u][v]['capacity'] will have a high arbitrary finite value\nthat does not affect the solution of the problem. This value is stored in R.graph['inf'] . For each edge (u,v) in R , R[u][v]['flow'] represents the flow function of (u,v) and\nsatisfies R[u][v]['flow']==-R[v][u]['flow'] . The flow value, defined as the total flow into t , the sink, is\nstored in R.graph['flow_value'] . Reachability to t using\nonly edges (u,v) such that R[u][v]['flow']<R[u][v]['capacity'] induces a minimum s - t cut. Specific algorithms may store extra data in R . The function should supports an optional boolean parameter value_only. When\nTrue, it can optionally terminate the algorithm as soon as the maximum flow\nvalue and the minimum cut can be determined.",
            "Examples": "G=nx.DiGraph()\nG.add_edge(\"x\",\"a\",capacity=3.0)\nG.add_edge(\"x\",\"b\",capacity=1.0)\nG.add_edge(\"a\",\"c\",capacity=3.0)\nG.add_edge(\"b\",\"c\",capacity=5.0)\nG.add_edge(\"b\",\"d\",capacity=4.0)\nG.add_edge(\"d\",\"e\",capacity=2.0)\nG.add_edge(\"c\",\"y\",capacity=2.0)\nG.add_edge(\"e\",\"y\",capacity=3.0)\nminimum_cut computes both the value of the\nminimum cut and the node partition:\ncut_value,partition=nx.minimum_cut(G,\"x\",\"y\")\nreachable,non_reachable=partition\n\u2018partition\u2019 here is a tuple with the two sets of nodes that define\nthe minimum cut. You can compute the cut set of edges that induce\nthe minimum cut as follows:\ncutset=set()\nforu,nbrsin((n,G[n])forninreachable):\ncutset.update((u,v)forvinnbrsifvinnon_reachable)\nprint(sorted(cutset))\n# [('c', 'y'), ('x', 'b')]\ncut_value==sum(G.edges[u,v][\"capacity\"]for(u,v)incutset)\n# True\nYou can also use alternative algorithms for computing the\nminimum cut by using the flow_func parameter.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\ncut_value==nx.minimum_cut(G,\"x\",\"y\",flow_func=shortest_augmenting_path)[0]\n# True"
        }
    },
    {
        "Section ID": "UnionMultiAdjacency",
        "Description": [
            "A read-only union of two dict MultiAdjacencies.",
            "The two input dict-of-dict-of-dict-of-dicts represent the union of G.succ and G.pred for MultiDiGraphs. Return values are UnionAdjacency.\nThe inner level of dict is read-write. But the outer levels are read-only."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "local_constraint",
        "Description": [
            "Returns the local constraint on the node u with respect to\nthe node v in the graph G .",
            "Formally, the local constraint on u with respect to v , denoted \\(\\ell(u, v)\\) , is defined by",
            "where \\(N(v)\\) is the set of neighbors of \\(v\\) and \\(p_{uv}\\) is the\nnormalized mutual weight of the (directed or undirected) edges\njoining \\(u\\) and \\(v\\) , for each vertex \\(u\\) and \\(v\\)  [1] . The mutual\nweight of \\(u\\) and \\(v\\) is the sum of the weights of edges joining\nthem (edge weights are assumed to be one if the graph is\nunweighted)."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "The graph containinguandv. This can be either\ndirected or undirected.",
                "u : node": "A node in the graphG.",
                "v : node": "A node in the graphG.",
                "weight : None or string, optional": "If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight."
            },
            "Returns:": {
                "float": "The constraint of the nodevin the graphG."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Burt, Ronald S.\n\u201cStructural holes and good ideas\u201d.\nAmerican Journal of Sociology (110): 349\u2013399."
        }
    },
    {
        "Section ID": "mycielskian",
        "Description": [
            "Returns the Mycielskian of a simple, undirected graph G",
            "The Mycielskian of graph preserves a graph\u2019s triangle free\nproperty while increasing the chromatic number by 1.",
            "The Mycielski Operation on a graph, \\(G=(V, E)\\) , constructs a new\ngraph with \\(2|V| + 1\\) nodes and \\(3|E| + |V|\\) edges.",
            "The construction is as follows:",
            "Let \\(V = {0, ..., n-1}\\) . Construct another vertex set \\(U = {n, ..., 2n}\\) and a vertex, w .\nConstruct a new graph, M , with vertices \\(U \\bigcup V \\bigcup w\\) .\nFor edges, \\((u, v) \\in E\\) add edges \\((u, v), (u, v + n)\\) , and \\((u + n, v)\\) to M. Finally, for all vertices \\(u \\in U\\) , add\nedge \\((u, w)\\) to M.",
            "The Mycielski Operation can be done multiple times by repeating the above\nprocess iteratively.",
            "More information can be found at https://en.wikipedia.org/wiki/Mycielskian"
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A simple, undirected NetworkX graph",
                "iterations : int": "The number of iterations of the Mycielski operation to\nperform on G. Defaults to 1. Must be a non-negative integer."
            },
            "Returns:": {
                "M : graph": "The Mycielskian of G after the specified number of iterations."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Graph, node, and edge data are not necessarily propagated to the new graph."
        }
    },
    {
        "Section ID": "from_dict_of_lists",
        "Description": [
            "Returns a graph from a dictionary of lists."
        ],
        "Field List": {
            "Parameters:": {
                "d : dictionary of lists": "A dictionary of lists adjacency representation.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "dol={0:[1]}# single edge (0,1)\nG=nx.from_dict_of_lists(dol)\nor\nG=nx.Graph(dol)# use Graph constructor"
        }
    },
    {
        "Section ID": "tadpole_graph",
        "Description": [
            "Returns the (m,n)-tadpole graph; C_m connected to P_n .",
            "This graph on m+n nodes connects a cycle of size m to a path of length n .\nIt looks like a tadpole. It is also called a kite graph or a dragon graph.",
            "( Sourcecode , png )"
        ],
        "Field List": {
            "Parameters:": {
                "m, n : int or iterable container of nodes": "If an integer, nodes are fromrange(m)andrange(m,m+n).\nIf a container of nodes, those nodes appear in the graph.\nWarning:mandnare not checked for duplicates and if present the\nresulting graph may not be as desired.The nodes formappear in the cycle graph\\(C_m\\)and the nodes\nfornappear in the path\\(P_n\\).",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "Networkx graph": "A cycle of sizemconnected to a path of lengthn."
            },
            "Raises:": {
                "NetworkXError": "Ifm<2. The tadpole graph is undefined form<2."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The 2 subgraphs are joined via an edge (m-1,m) .\nIf n=0 , this is a cycle graph. m and/or n can be a container of nodes instead of an integer."
        }
    },
    {
        "Section ID": "generate_adjlist",
        "Description": [
            "Generate a single line of the graph G in adjacency list format."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "delimiter : string, optional": "Separator for node labels"
            },
            "Returns:": {
                "lines : string": "Lines of data in adjlist format."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The default delimiter=\"\" will result in unexpected results if node names contain\nwhitespace characters. To avoid this problem, specify an alternate delimiter when spaces are\nvalid in node names. NB: This option is not available for data that isn\u2019t user-generated.",
            "Examples": "G=nx.lollipop_graph(4,3)\nforlineinnx.generate_adjlist(G):\nprint(line)\n# 0 1 2 3\n# 1 2 3\n# 2 3\n# 3 4\n# 4 5\n# 5 6\n# 6"
        }
    },
    {
        "Section ID": "lollipop_graph",
        "Description": [
            "Returns the Lollipop Graph; K_m connected to P_n .",
            "This is the Barbell Graph without the right barbell.",
            "( Sourcecode , png )"
        ],
        "Field List": {
            "Parameters:": {
                "m, n : int or iterable container of nodes": "If an integer, nodes are fromrange(m)andrange(m,m+n).\nIf a container of nodes, those nodes appear in the graph.\nWarning:mandnare not checked for duplicates and if present the\nresulting graph may not be as desired. Make sure you have no duplicates.The nodes formappear in the complete graph\\(K_m\\)and the nodes\nfornappear in the path\\(P_n\\)",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "Networkx graph": "A complete graph withmnodes connected to a path of lengthn."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The 2 subgraphs are joined via an edge (m-1,m) .\nIf n=0 , this is merely a complete graph. (This graph is an extremal example in David Aldous and Jim\nFill\u2019s etext on Random Walks on Graphs.)"
        }
    },
    {
        "Section ID": "FilterMultiAdjacency",
        "Description": [
            "A read-only Mapping of Mappings with filtering criteria\nfor nodes and edges.",
            "It is a view into a dict-of-dict-of-dict-of-dict data structure,\nand it selects nodes and edges that satisfy specific criteria\ndefined by NODE_OK and EDGE_OK , respectively."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "greedy_color",
        "Description": [
            "Color a graph using various strategies of greedy graph coloring.",
            "Attempts to color a graph using as few colors as possible, where no\nneighbors of a node can have same color as the node itself. The\ngiven strategy determines the order in which nodes are colored.",
            "The strategies are described in [1] , and smallest-last is based on [2] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "strategy : string or function(G, colors)": "A function (or a string representing a function) that provides\nthe coloring strategy, by returning nodes in the ordering they\nshould be colored.Gis the graph, andcolorsis a\ndictionary of the currently assigned colors, keyed by nodes. The\nfunction must return an iterable over all the nodes inG.If the strategy function is an iterator generator (that is, a\nfunction withyieldstatements), keep in mind that thecolorsdictionary will be updated after eachyield, since\nthis function chooses colors greedily.Ifstrategyis a string, it must be one of the following,\neach of which represents one of the built-in strategy functions.'largest_first''random_sequential''smallest_last''independent_set''connected_sequential_bfs''connected_sequential_dfs''connected_sequential'(alias for the previous strategy)'saturation_largest_first''DSATUR'(alias for the previous strategy)",
                "interchange: bool": "Will use the color interchange algorithm described by[3]if set\ntoTrue.Note thatsaturation_largest_firstandindependent_setdo not work with interchange. Furthermore, if you use\ninterchange with your own strategy function, you cannot rely\non the values in thecolorsargument."
            },
            "Returns:": {
                "A dictionary with keys representing nodes and values representing": "",
                "corresponding coloring.": ""
            },
            "Raises:": {
                "NetworkXPointlessConcept": "Ifstrategyissaturation_largest_firstorindependent_setandinterchangeisTrue."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Adrian Kosowski, and Krzysztof Manuszewski,\nClassical Coloring of Graphs, Graph Colorings, 2-19, 2004.\nISBN 0-8218-3458-4.  [2]David W. Matula, and Leland L. Beck, \u201cSmallest-last\nordering and clustering and graph coloring algorithms.\u201dJ. ACM30,\n3 (July 1983), 417\u2013427. <https://doi.org/10.1145/2402.322385>  [3]Maciej M. Sys\u0142o, Narsingh Deo, Janusz S. Kowalik,\nDiscrete Optimization Algorithms with Pascal Programs, 415-424, 1983.\nISBN 0-486-45353-7.",
            "Examples": "G=nx.cycle_graph(4)\nd=nx.coloring.greedy_color(G,strategy=\"largest_first\")\ndin[{0:0,1:1,2:0,3:1},{0:1,1:0,2:1,3:0}]\n# True"
        }
    },
    {
        "Section ID": "shortest_augmenting_path",
        "Description": [
            "Find a maximum single-commodity flow using the shortest augmenting path\nalgorithm.",
            "This function returns the residual network resulting after computing\nthe maximum flow. See below for details about the conventions\nNetworkX uses for defining residual networks.",
            "This algorithm has a running time of \\(O(n^2 m)\\) for \\(n\\) nodes and \\(m\\) edges."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Edges of the graph are expected to have an attribute called\n\u2018capacity\u2019. If this attribute is not present, the edge is\nconsidered to have infinite capacity.",
                "s : node": "Source node for the flow.",
                "t : node": "Sink node for the flow.",
                "capacity : string": "Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: \u2018capacity\u2019.",
                "residual : NetworkX graph": "Residual network on which the algorithm is to be executed. If None, a\nnew residual network is created. Default value: None.",
                "value_only : bool": "If True compute only the value of the maximum flow. This parameter\nwill be ignored by this algorithm because it is not applicable.",
                "two_phase : bool": "If True, a two-phase variant is used. The two-phase variant improves\nthe running time on unit-capacity networks from\\(O(nm)\\)to\\(O(\\min(n^{2/3}, m^{1/2}) m)\\). Default value: False.",
                "cutoff : integer, float": "If specified, the algorithm will terminate when the flow value reaches\nor exceeds the cutoff. In this case, it may be unable to immediately\ndetermine a minimum cut. Default value: None."
            },
            "Returns:": {
                "R : NetworkX DiGraph": "Residual network after computing the maximum flow."
            },
            "Raises:": {
                "NetworkXError": "The algorithm does not support MultiGraph and MultiDiGraph. If\nthe input graph is an instance of one of these two classes, a\nNetworkXError is raised.",
                "NetworkXUnbounded": "If the graph has a path of infinite capacity, the value of a\nfeasible flow on the graph is unbounded above and the function\nraises a NetworkXUnbounded."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The residual network R from an input graph G has the\nsame nodes as G . R is a DiGraph that contains a pair\nof edges (u,v) and (v,u) iff (u,v) is not a\nself-loop, and at least one of (u,v) and (v,u) exists\nin G . For each edge (u,v) in R , R[u][v]['capacity'] is equal to the capacity of (u,v) in G if it exists\nin G or zero otherwise. If the capacity is infinite, R[u][v]['capacity'] will have a high arbitrary finite value\nthat does not affect the solution of the problem. This value is stored in R.graph['inf'] . For each edge (u,v) in R , R[u][v]['flow'] represents the flow function of (u,v) and\nsatisfies R[u][v]['flow']==-R[v][u]['flow'] . The flow value, defined as the total flow into t , the sink, is\nstored in R.graph['flow_value'] . If cutoff is not\nspecified, reachability to t using only edges (u,v) such\nthat R[u][v]['flow']<R[u][v]['capacity'] induces a minimum s - t cut.",
            "Examples": "fromnetworkx.algorithms.flowimportshortest_augmenting_path\nThe functions that implement flow algorithms and output a residual\nnetwork, such as this one, are not imported to the base NetworkX\nnamespace, so you have to explicitly import them from the flow package.\nG=nx.DiGraph()\nG.add_edge(\"x\",\"a\",capacity=3.0)\nG.add_edge(\"x\",\"b\",capacity=1.0)\nG.add_edge(\"a\",\"c\",capacity=3.0)\nG.add_edge(\"b\",\"c\",capacity=5.0)\nG.add_edge(\"b\",\"d\",capacity=4.0)\nG.add_edge(\"d\",\"e\",capacity=2.0)\nG.add_edge(\"c\",\"y\",capacity=2.0)\nG.add_edge(\"e\",\"y\",capacity=3.0)\nR=shortest_augmenting_path(G,\"x\",\"y\")\nflow_value=nx.maximum_flow_value(G,\"x\",\"y\")\nflow_value\n# 3.0\nflow_value==R.graph[\"flow_value\"]\n# True"
        }
    },
    {
        "Section ID": "fast_could_be_isomorphic",
        "Description": [
            "Returns False if graphs are definitely not isomorphic.",
            "True does NOT guarantee isomorphism."
        ],
        "Field List": {
            "Parameters:": {
                "G1, G2 : graphs": "The two graphs G1 and G2 must be the same type."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Checks for matching degree and triangle sequences. The triangle\nsequence contains the number of triangles each node is part of."
        }
    },
    {
        "Section ID": "directed_havel_hakimi_graph",
        "Description": [
            "Returns a directed graph with the given degree sequences."
        ],
        "Field List": {
            "Parameters:": {
                "in_deg_sequence : list of integers": "Each list entry corresponds to the in-degree of a node.",
                "out_deg_sequence : list of integers": "Each list entry corresponds to the out-degree of a node.",
                "create_using : NetworkX graph constructor, optional (default DiGraph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : DiGraph": "A graph with the specified degree sequences.\nNodes are labeled starting at 0 with an index\ncorresponding to the position in deg_sequence"
            },
            "Raises:": {
                "NetworkXError": "If the degree sequences are not digraphical."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Algorithm as described by Kleitman and Wang [1] .",
            "References": "[1]D.J. Kleitman and D.L. Wang\nAlgorithms for Constructing Graphs and Digraphs with Given Valences\nand Factors Discrete Mathematics, 6(1), pp. 79-88 (1973)"
        }
    },
    {
        "Section ID": "random_unlabeled_tree",
        "Description": [
            "Returns a tree or list of trees chosen randomly.",
            "Returns one or more (depending on number_of_trees )\nunlabeled trees with n nodes drawn uniformly at random."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes",
                "number_of_trees : int or None (default)": "If not None, this number of trees is generated and returned.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "networkx.Graph : or list of : networkx.Graph": "A singlenetworkx.Graph(or a list thereof, ifnumber_of_treesis specified) with nodes in the set {0, \u2026,n- 1}."
            },
            "Raises:": {
                "NetworkXPointlessConcept": "Ifnis zero (because the null graph is not a tree)."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This function generates an unlabeled tree uniformly at random using\nWilf\u2019s algorithm \u201cFree\u201d of [1] . The algorithm needs to\ncompute some counting functions that are relatively expensive:\nin case several trees are needed, it is advisable to use the number_of_trees optional argument to reuse the counting\nfunctions.",
            "References": "[1]Wilf, Herbert S. \u201cThe uniform selection of free trees.\u201d\nJournal of Algorithms 2.2 (1981): 204-207.https://doi.org/10.1016/0196-6774(81)90021-3"
        }
    },
    {
        "Section ID": "betweenness_centrality",
        "Description": [
            "Compute betweenness centrality for nodes in a bipartite network.",
            "Betweenness centrality of a node v is the sum of the\nfraction of all-pairs shortest paths that pass through v .",
            "Values of betweenness are normalized by the maximum possible\nvalue which for bipartite graphs is limited by the relative size\nof the two node sets [1] .",
            "Let n be the number of nodes in the node set U and m be the number of nodes in the node set V , then\nnodes in U are normalized by dividing by",
            "where",
            "and nodes in V are normalized by dividing by",
            "where,"
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A bipartite graph",
                "nodes : list or container": "Container with all nodes in one bipartite node set."
            },
            "Returns:": {
                "betweenness : dictionary": "Dictionary keyed by node with bipartite betweenness centrality\nas the value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The nodes input parameter must contain all nodes in one bipartite node set,\nbut the dictionary returned contains all nodes from both node sets.\nSee bipartitedocumentation for further details on how bipartite graphs are handled in NetworkX.",
            "References": "[1]Borgatti, S.P. and Halgin, D. In press. \u201cAnalyzing Affiliation\nNetworks\u201d. In Carrington, P. and Scott, J. (eds) The Sage Handbook\nof Social Network Analysis. Sage Publications.https://dx.doi.org/10.4135/9781446294413.n28",
            "Examples": "G=nx.cycle_graph(4)\ntop_nodes={1,2}\nnx.bipartite.betweenness_centrality(G,nodes=top_nodes)\n# {0: 0.25, 1: 0.25, 2: 0.25, 3: 0.25}"
        }
    },
    {
        "Section ID": "modularity",
        "Description": [
            "Returns the modularity of the given partition of the graph.",
            "Modularity is defined in [1] as",
            "where \\(m\\) is the number of edges (or sum of all edge weights as in [5] ), \\(A\\) is the adjacency matrix of G , \\(k_i\\) is the (weighted) degree of \\(i\\) , \\(\\gamma\\) is the resolution parameter, and \\(\\delta(c_i, c_j)\\) is 1 if \\(i\\) and \\(j\\) are in the same community else 0.",
            "According to [2] (and verified by some algebra) this can be reduced to",
            "where the sum iterates over all communities \\(c\\) , \\(m\\) is the number of edges, \\(L_c\\) is the number of intra-community links for community \\(c\\) , \\(k_c\\) is the sum of degrees of the nodes in community \\(c\\) ,\nand \\(\\gamma\\) is the resolution parameter.",
            "The resolution parameter sets an arbitrary tradeoff between intra-group\nedges and inter-group edges. More complex grouping patterns can be\ndiscovered by analyzing the same network with multiple values of gamma\nand then combining the results [3] . That said, it is very common to\nsimply use gamma=1. More on the choice of gamma is in [4] .",
            "The second formula is the one actually used in calculation of the modularity.\nFor directed graphs the second formula replaces \\(k_c\\) with \\(k^{in}_c k^{out}_c\\) ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "",
                "communities : list or iterable of set of nodes": "These node sets must represent a partition of G\u2019s nodes.",
                "weight : string or None, optional (default=\u201dweight\u201d)": "The edge attribute that holds the numerical value used\nas a weight. If None or an edge does not have that attribute,\nthen that edge has weight 1.",
                "resolution : float (default=1)": "If resolution is less than 1, modularity favors larger communities.\nGreater than 1 favors smaller communities."
            },
            "Returns:": {
                "Q : float": "The modularity of the partition."
            },
            "Raises:": {
                "NotAPartition": "Ifcommunitiesis not a partition of the nodes ofG."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]M. E. J. Newman \u201cNetworks: An Introduction\u201d, page 224.\nOxford University Press, 2011.  [2]Clauset, Aaron, Mark EJ Newman, and Cristopher Moore.\n\u201cFinding community structure in very large networks.\u201d\nPhys. Rev. E 70.6 (2004). <https://arxiv.org/abs/cond-mat/0408187>  [3]Reichardt and Bornholdt \u201cStatistical Mechanics of Community Detection\u201d\nPhys. Rev. E 74, 016110, 2006.https://doi.org/10.1103/PhysRevE.74.016110  [4]M. E. J. Newman, \u201cEquivalence between modularity optimization and\nmaximum likelihood methods for community detection\u201d\nPhys. Rev. E 94, 052315, 2016.https://doi.org/10.1103/PhysRevE.94.052315  [5]Blondel, V.D. et al. \u201cFast unfolding of communities in large\nnetworks\u201d J. Stat. Mech 10008, 1-12 (2008).https://doi.org/10.1088/1742-5468/2008/10/P10008",
            "Examples": "G=nx.barbell_graph(3,0)\nnx.community.modularity(G,[{0,1,2},{3,4,5}])\n# 0.35714285714285715\nnx.community.modularity(G,nx.community.label_propagation_communities(G))\n# 0.35714285714285715"
        }
    },
    {
        "Section ID": "dfs_edges",
        "Description": [
            "Iterate over edges in a depth-first-search (DFS).",
            "Perform a depth-first-search over the nodes of G and yield\nthe edges in order. This may not generate all edges in G (see edge_dfs )."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node, optional": "Specify starting node for depth-first search and yield edges in\nthe component reachable from source.",
                "depth_limit : int, optional (default=len(G))": "Specify the maximum search depth.",
                "sort_neighbors : function (default=None)": "A function that takes an iterator over nodes as the input, and\nreturns an iterable of the same nodes with a custom ordering.\nFor example,sortedwill sort the nodes in increasing order."
            },
            "Yields:": {
                "edge: 2-tuple of nodes": "Yields edges resulting from the depth-first-search."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "If a source is not specified then a source is chosen arbitrarily and\nrepeatedly until all components in the graph are searched. The implementation of this function is adapted from David Eppstein\u2019s\ndepth-first search function in PADS [1] , with modifications\nto allow depth limits based on the Wikipedia article\n\u201cDepth-limited search\u201d [2] .",
            "References": "[1]http://www.ics.uci.edu/~eppstein/PADS  [2]https://en.wikipedia.org/wiki/Depth-limited_search",
            "Examples": "G=nx.path_graph(5)\nlist(nx.dfs_edges(G,source=0))\n# [(0, 1), (1, 2), (2, 3), (3, 4)]\nlist(nx.dfs_edges(G,source=0,depth_limit=2))\n# [(0, 1), (1, 2)]"
        }
    },
    {
        "Section ID": "write_gml",
        "Description": [
            "Write a graph G in GML format to the file or file handle path ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "The graph to be converted to GML.",
                "path : filename or filehandle": "The filename or filehandle to write. Files whose names end with .gz or\n.bz2 will be compressed.",
                "stringizer : callable, optional": "Astringizerwhich converts non-int/non-float/non-dict values into\nstrings. If it cannot convert a value into a string, it should raise aValueErrorto indicate that. Default value: None."
            },
            "Raises:": {
                "NetworkXError": "Ifstringizercannot convert a value into a string, or the value to\nconvert is not a string whilestringizeris None."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Graph attributes named \u2018directed\u2019, \u2018multigraph\u2019, \u2018node\u2019 or\n\u2018edge\u2019, node attributes named \u2018id\u2019 or \u2018label\u2019, edge attributes\nnamed \u2018source\u2019 or \u2018target\u2019 (or \u2018key\u2019 if G is a multigraph)\nare ignored because these attribute names are used to encode the graph\nstructure. GML files are stored using a 7-bit ASCII encoding with any extended\nASCII characters (iso8859-1) appearing as HTML character entities.\nWithout specifying a stringizer / destringizer , the code is capable of\nwriting int / float / str / dict / list data as required by the GML\nspecification.  For writing other data types, and for reading data other\nthan str you need to explicitly supply a stringizer / destringizer . Note that while we allow non-standard GML to be read from a file, we make\nsure to write GML format. In particular, underscores are not allowed in\nattribute names.\nFor additional documentation on the GML file format, please see the GML url . See the module docstring networkx.readwrite.gml for more details.",
            "Examples": "G=nx.path_graph(4)\nnx.write_gml(G,\"test.gml\")\nFilenames ending in .gz or .bz2 will be compressed.\nnx.write_gml(G,\"test.gml.gz\")"
        }
    },
    {
        "Section ID": "predecessor",
        "Description": [
            "Returns dict of predecessors for the path from source to all nodes in G."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node label": "Starting node for path",
                "target : node label, optional": "Ending node for path. If provided only predecessors between\nsource and target are returned",
                "cutoff : integer, optional": "Depth to stop the search. Only paths of length <= cutoff are returned.",
                "return_seen : bool, optional (default=None)": "Whether to return a dictionary, keyed by node, of the level (number of\nhops) to reach the node (as seen during breadth-first-search)."
            },
            "Returns:": {
                "pred : dictionary": "Dictionary, keyed by node, of predecessors in the shortest path.",
                "(pred, seen): tuple of dictionaries": "Ifreturn_seenargument is set toTrue, then a tuple of dictionaries\nis returned. The first element is the dictionary, keyed by node, of\npredecessors in the shortest path. The second element is the dictionary,\nkeyed by node, of the level (number of hops) to reach the node (as seen\nduring breadth-first-search)."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.path_graph(4)\nlist(G)\n# [0, 1, 2, 3]\nnx.predecessor(G,0)\n# {0: [], 1: [0], 2: [1], 3: [2]}\nnx.predecessor(G,0,return_seen=True)\n# ({0: [], 1: [0], 2: [1], 3: [2]}, {0: 0, 1: 1, 2: 2, 3: 3})"
        }
    },
    {
        "Section ID": "to_pydot",
        "Description": [
            "Returns a pydot graph from a NetworkX graph N."
        ],
        "Field List": {
            "Parameters:": {
                "N : NetworkX graph": "A graph created with NetworkX"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "K5=nx.complete_graph(5)\nP=nx.nx_pydot.to_pydot(K5)"
        }
    },
    {
        "Section ID": "goldberg_radzik",
        "Description": [
            "Compute shortest path lengths and predecessors on shortest paths\nin weighted graphs.",
            "The algorithm has a running time of \\(O(mn)\\) where \\(n\\) is the number of\nnodes and \\(m\\) is the number of edges.  It is slower than Dijkstra but\ncan handle negative edge weights."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "The algorithm works for all types of graphs, including directed\ngraphs and multigraphs.",
                "source: node label": "Starting node for path",
                "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number."
            },
            "Returns:": {
                "pred, dist : dictionaries": "Returns two dictionaries keyed by node to predecessor in the\npath and to the distance from the source respectively."
            },
            "Raises:": {
                "NodeNotFound": "Ifsourceis not inG.",
                "NetworkXUnbounded": "If the (di)graph contains a negative (di)cycle, the\nalgorithm raises an exception to indicate the presence of the\nnegative (di)cycle.  Note: any negative weight edge in an\nundirected graph is a negative cycle.As of NetworkX v3.2, a zero weight cycle is no longer\nincorrectly reported as a negative weight cycle."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The dictionaries returned only have keys for nodes reachable from\nthe source. In the case where the (di)graph is not connected, if a component\nnot containing the source contains a negative (di)cycle, it\nwill not be detected.",
            "Examples": "G=nx.path_graph(5,create_using=nx.DiGraph())\npred,dist=nx.goldberg_radzik(G,0)\nsorted(pred.items())\n# [(0, None), (1, 0), (2, 1), (3, 2), (4, 3)]\nsorted(dist.items())\n# [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]\nG=nx.cycle_graph(5,create_using=nx.DiGraph())\nG[1][2][\"weight\"]=-7\nnx.goldberg_radzik(G,0)Traceback (most recent call last):    ...networkx.exception.NetworkXUnboundedNegative cycle detected."
        }
    },
    {
        "Section ID": "flatten",
        "Description": [
            "Return flattened version of (possibly nested) iterable object."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "louvain_communities",
        "Description": [
            "Find the best partition of a graph using the Louvain Community Detection\nAlgorithm.",
            "Louvain Community Detection Algorithm is a simple method to extract the community\nstructure of a network. This is a heuristic method based on modularity optimization. [1]",
            "The algorithm works in 2 steps. On the first step it assigns every node to be\nin its own community and then for each node it tries to find the maximum positive\nmodularity gain by moving each node to all of its neighbor communities. If no positive\ngain is achieved the node remains in its original community.",
            "The modularity gain obtained by moving an isolated node \\(i\\) into a community \\(C\\) can\neasily be calculated by the following formula (combining [1]  [2] and some algebra):",
            "where \\(m\\) is the size of the graph, \\(k_{i,in}\\) is the sum of the weights of the links\nfrom \\(i\\) to nodes in \\(C\\) , \\(k_i\\) is the sum of the weights of the links incident to node \\(i\\) , \\(\\Sigma_{tot}\\) is the sum of the weights of the links incident to nodes in \\(C\\) and \\(\\gamma\\) is the resolution parameter.",
            "For the directed case the modularity gain can be computed using this formula according to [3]",
            "where \\(k_i^{out}\\) , \\(k_i^{in}\\) are the outer and inner weighted degrees of node \\(i\\) and \\(\\Sigma_{tot}^{in}\\) , \\(\\Sigma_{tot}^{out}\\) are the sum of in-going and out-going links incident\nto nodes in \\(C\\) .",
            "The first phase continues until no individual move can improve the modularity.",
            "The second phase consists in building a new network whose nodes are now the communities\nfound in the first phase. To do so, the weights of the links between the new nodes are given by\nthe sum of the weight of the links between nodes in the corresponding two communities. Once this\nphase is complete it is possible to reapply the first phase creating bigger communities with\nincreased modularity.",
            "The above two phases are executed until no modularity gain is achieved (or is less than\nthe threshold , or until max_levels is reached).",
            "Be careful with self-loops in the input graph. These are treated as\npreviously reduced communities \u2013 as if the process had been started\nin the middle of the algorithm. Large self-loop edge weights thus\nrepresent strong communities and in practice may be hard to add\nother nodes to.  If your input graph edge weights for self-loops\ndo not represent already reduced communities you may want to remove\nthe self-loops before inputting that graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "weight : string or None, optional (default=\u201dweight\u201d)": "The name of an edge attribute that holds the numerical value\nused as a weight. If None then each edge has weight 1.",
                "resolution : float, optional (default=1)": "If resolution is less than 1, the algorithm favors larger communities.\nGreater than 1 favors smaller communities",
                "threshold : float, optional (default=0.0000001)": "Modularity gain threshold for each level. If the gain of modularity\nbetween 2 levels of the algorithm is less than the given threshold\nthen the algorithm stops and returns the resulting communities.",
                "max_level : int or None, optional (default=None)": "The maximum number of levels (steps of the algorithm) to compute.\nMust be a positive integer or None. If None, then there is no max\nlevel and the threshold parameter determines the stopping condition.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "list": "A list of sets (partition ofG). Each set represents one community and contains\nall the nodes that constitute it."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The order in which the nodes are considered can affect the final output. In the algorithm\nthe ordering happens using a random shuffle.",
            "References": "[1](1,2)Blondel, V.D. et al. Fast unfolding of communities in\nlarge networks. J. Stat. Mech 10008, 1-12(2008).https://doi.org/10.1088/1742-5468/2008/10/P10008  [2]Traag, V.A., Waltman, L. & van Eck, N.J. From Louvain to Leiden: guaranteeing\nwell-connected communities. Sci Rep 9, 5233 (2019).https://doi.org/10.1038/s41598-019-41695-z  [3]Nicolas Dugu\u00e9, Anthony Perez. Directed Louvain : maximizing modularity in directed networks.\n[Research Report] Universit\u00e9 d\u2019Orl\u00e9ans. 2015. hal-01231784.https://hal.archives-ouvertes.fr/hal-01231784",
            "Examples": "importnetworkxasnx\nG=nx.petersen_graph()\nnx.community.louvain_communities(G,seed=123)\n# [{0, 4, 5, 7, 9}, {1, 2, 3, 6, 8}]"
        }
    },
    {
        "Section ID": "dijkstra_predecessor_and_distance",
        "Description": [
            "Compute weighted shortest path length and predecessors.",
            "Uses Dijkstra\u2019s Method to obtain the shortest weighted paths\nand return dictionaries of predecessors for each node and\ndistance for each node from the source ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node label": "Starting node for path",
                "cutoff : integer or float, optional": "Length (sum of edge weights) at which the search is stopped.\nIf cutoff is provided, only return paths with summed weight <= cutoff.",
                "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge."
            },
            "Returns:": {
                "pred, distance : dictionaries": "Returns two dictionaries representing a list of predecessors\nof a node and the distance to each node."
            },
            "Raises:": {
                "NodeNotFound": "Ifsourceis not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The list of predecessors contains more than one element only when\nthere are more than one shortest paths to the key node.",
            "Examples": "G=nx.path_graph(5,create_using=nx.DiGraph())\npred,dist=nx.dijkstra_predecessor_and_distance(G,0)\nsorted(pred.items())\n# [(0, []), (1, [0]), (2, [1]), (3, [2]), (4, [3])]\nsorted(dist.items())\n# [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]\npred,dist=nx.dijkstra_predecessor_and_distance(G,0,1)\nsorted(pred.items())\n# [(0, []), (1, [0])]\nsorted(dist.items())\n# [(0, 0), (1, 1)]"
        }
    },
    {
        "Section ID": "has_path",
        "Description": [
            "Returns True if G has a path from source to target ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node": "Starting node for path",
                "target : node": "Ending node for path"
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "gn_graph",
        "Description": [
            "Returns the growing network (GN) digraph with n nodes.",
            "The GN graph is built by adding nodes one at a time with a link to one\npreviously added node.  The target node for the link is chosen with\nprobability based on degree.  The default attachment kernel is a linear\nfunction of the degree of a node.",
            "The graph is always a (directed) tree."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes for the generated graph.",
                "kernel : function": "The attachment kernel.",
                "create_using : NetworkX graph constructor, optional (default DiGraph)": "Graph type to create. If graph instance, then cleared before populated.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]P. L. Krapivsky and S. Redner,\nOrganization of Growing Random Networks,\nPhys. Rev. E, 63, 066123, 2001.",
            "Examples": "To create the undirected GN graph, use theto_directed()method:\nD=nx.gn_graph(10)# the GN graph\nG=D.to_undirected()# the undirected version\nTo specify an attachment kernel, use thekernelkeyword argument:\nD=nx.gn_graph(10,kernel=lambdax:x**1.5)# A_k = k^1.5"
        }
    },
    {
        "Section ID": "group_betweenness_centrality",
        "Description": [
            "Compute the group betweenness centrality for a group of nodes.",
            "Group betweenness centrality of a group of nodes \\(C\\) is the sum of the\nfraction of all-pairs shortest paths that pass through any vertex in \\(C\\)",
            "where \\(V\\) is the set of nodes, \\(\\sigma(s, t)\\) is the number of\nshortest \\((s, t)\\) -paths, and \\(\\sigma(s, t|C)\\) is the number of\nthose paths passing through some node in group \\(C\\) . Note that \\((s, t)\\) are not members of the group ( \\(V-C\\) is the set of nodes\nin \\(V\\) that are not in \\(C\\) )."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.",
                "C : list or set or list of lists or list of sets": "A group or a list of groups containing nodes which belong to G, for which group betweenness\ncentrality is to be calculated.",
                "normalized : bool, optional (default=True)": "If True, group betweenness is normalized by1/((|V|-|C|)(|V|-|C|-1))where|V|is the number of nodes in G and|C|is the number of nodes in C.",
                "weight : None or string, optional (default=None)": "If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight.\nThe weight of an edge is treated as the length or distance between the two sides.",
                "endpoints : bool, optional (default=False)": "If True include the endpoints in the shortest path counts."
            },
            "Returns:": {
                "betweenness : list of floats or float": "If C is a single group then return a float. If C is a list with\nseveral groups then return a list of group betweenness centralities."
            },
            "Raises:": {
                "NodeNotFound": "If node(s) in C are not present in G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Group betweenness centrality is described in [1] and its importance discussed in [3] .\nThe initial implementation of the algorithm is mentioned in [2] . This function uses\nan improved algorithm presented in [4] . The number of nodes in the group must be a maximum of n - 2 where n is the total number of nodes in the graph. For weighted graphs the edge weights must be greater than zero.\nZero edge weights can produce an infinite number of equal length\npaths between pairs of nodes. The total number of paths between source and target is counted\ndifferently for directed and undirected graphs. Directed paths\nbetween \u201cu\u201d and \u201cv\u201d are counted as two possible paths (one each\ndirection) while undirected paths between \u201cu\u201d and \u201cv\u201d are counted\nas one path. Said another way, the sum in the expression above is\nover all s!=t for directed graphs and for s<t for undirected graphs.",
            "References": "[1]M G Everett and S P Borgatti:\nThe Centrality of Groups and Classes.\nJournal of Mathematical Sociology. 23(3): 181-201. 1999.http://www.analytictech.com/borgatti/group_centrality.htm  [2]Ulrik Brandes:\nOn Variants of Shortest-Path Betweenness\nCentrality and their Generic Computation.\nSocial Networks 30(2):136-145, 2008.http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.72.9610&rep=rep1&type=pdf  [3]Sourav Medya et. al.:\nGroup Centrality Maximization via Network Design.\nSIAM International Conference on Data Mining, SDM 2018, 126\u2013134.https://sites.cs.ucsb.edu/~arlei/pubs/sdm18.pdf  [4]Rami Puzis, Yuval Elovici, and Shlomi Dolev.\n\u201cFast algorithm for successive computation of group betweenness centrality.\u201dhttps://journals.aps.org/pre/pdf/10.1103/PhysRevE.76.056709"
        }
    },
    {
        "Section ID": "to_latex_raw",
        "Description": [
            "Return a string of the LaTeX/TikZ code to draw G",
            "This function produces just the code for the tikzpicture\nwithout any enclosing environment."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "The NetworkX graph to be drawn",
                "pos : string or dict (default \u201cpos\u201d)": "The name of the node attribute onGthat holds the position of each node.\nPositions can be sequences of length 2 with numbers for (x,y) coordinates.\nThey can also be strings to denote positions in TikZ style, such as (x, y)\nor (angle:radius).\nIf a dict, it should be keyed by node to a position.\nIf an empty dict, a circular layout is computed by TikZ.",
                "tikz_options : string": "The tikzpicture options description defining the options for the picture.\nOften large scale options like[scale=2].",
                "default_node_options : string": "The draw options for a path of nodes. Individual node options override these.",
                "node_options : string or dict": "The name of the node attribute onGthat holds the options for each node.\nOr a dict keyed by node to a string holding the options for that node.",
                "node_label : string or dict": "The name of the node attribute onGthat holds the node label (text)\ndisplayed for each node. If the attribute is \u201c\u201d or not present, the node\nitself is drawn as a string. LaTeX processing such as\"$A_1$\"is allowed.\nOr a dict keyed by node to a string holding the label for that node.",
                "default_edge_options : string": "The options for the scope drawing all edges. The default is \u201c[-]\u201d for\nundirected graphs and \u201c[->]\u201d for directed graphs.",
                "edge_options : string or dict": "The name of the edge attribute onGthat holds the options for each edge.\nIf the edge is a self-loop and\"loop\"notinedge_optionsthe option\n\u201cloop,\u201d is added to the options for the self-loop edge. Hence you can\nuse \u201c[loop above]\u201d explicitly, but the default is \u201c[loop]\u201d.\nOr a dict keyed by edge to a string holding the options for that edge.",
                "edge_label : string or dict": "The name of the edge attribute onGthat holds the edge label (text)\ndisplayed for each edge. If the attribute is \u201c\u201d or not present, no edge\nlabel is drawn.\nOr a dict keyed by edge to a string holding the label for that edge.",
                "edge_label_options : string or dict": "The name of the edge attribute onGthat holds the label options for\neach edge. For example, \u201c[sloped,above,blue]\u201d. The default is no options.\nOr a dict keyed by edge to a string holding the label options for that edge."
            },
            "Returns:": {
                "latex_code : string": "The text string which draws the desired graph(s) when compiled by LaTeX."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "draw_networkx",
        "Description": [
            "Draw the graph G using Matplotlib.",
            "Draw the graph with Matplotlib with options for node positions,\nlabeling, titles, and many other drawing features.\nSee draw() for simple drawing without labels or axes."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph",
                "pos : dictionary, optional": "A dictionary with nodes as keys and positions as values.\nIf not specified a spring layout positioning will be computed.\nSeenetworkx.drawing.layoutfor functions that\ncompute node positions.",
                "arrows : bool or None, optional (default=None)": "IfNone, directed graphs draw arrowheads withFancyArrowPatch, while undirected graphs draw edges\nviaLineCollectionfor speed.\nIfTrue, draw arrowheads with FancyArrowPatches (bendable and stylish).\nIfFalse, draw edges using LineCollection (linear and fast).\nFor directed graphs, if True draw arrowheads.\nNote: Arrows will be the same color as edges.",
                "arrowstyle : str (default=\u2019-|>\u2019 for directed graphs)": "For directed graphs, choose the style of the arrowsheads.\nFor undirected graphs default to \u2018-\u2019Seematplotlib.patches.ArrowStylefor more options.",
                "arrowsize : int or list (default=10)": "For directed graphs, choose the size of the arrow head\u2019s length and\nwidth. A list of values can be passed in to assign a different size for arrow head\u2019s length and width.\nSeematplotlib.patches.FancyArrowPatchfor attributemutation_scalefor more info.",
                "with_labels : bool (default=True)": "Set to True to draw labels on the nodes.",
                "ax : Matplotlib Axes object, optional": "Draw the graph in the specified Matplotlib axes.",
                "nodelist : list (default=list(G))": "Draw only specified nodes",
                "edgelist : list (default=list(G.edges()))": "Draw only specified edges",
                "node_size : scalar or array (default=300)": "Size of nodes.  If an array is specified it must be the\nsame length as nodelist.",
                "node_color : color or array of colors (default=\u2019#1f78b4\u2019)": "Node color. Can be a single color or a sequence of colors with the same\nlength as nodelist. Color can be string or rgb (or rgba) tuple of\nfloats from 0-1. If numeric values are specified they will be\nmapped to colors using the cmap and vmin,vmax parameters. See\nmatplotlib.scatter for more details.",
                "node_shape : string (default=\u2019o\u2019)": "The shape of the node.  Specification is as matplotlib.scatter\nmarker, one of \u2018so^>v<dph8\u2019.",
                "alpha : float or None (default=None)": "The node and edge transparency",
                "cmap : Matplotlib colormap, optional": "Colormap for mapping intensities of nodes",
                "vmin,vmax : float, optional": "Minimum and maximum for node colormap scaling",
                "linewidths : scalar or sequence (default=1.0)": "Line width of symbol border",
                "width : float or array of floats (default=1.0)": "Line width of edges",
                "edge_color : color or array of colors (default=\u2019k\u2019)": "Edge color. Can be a single color or a sequence of colors with the same\nlength as edgelist. Color can be string or rgb (or rgba) tuple of\nfloats from 0-1. If numeric values are specified they will be\nmapped to colors using the edge_cmap and edge_vmin,edge_vmax parameters.",
                "edge_cmap : Matplotlib colormap, optional": "Colormap for mapping intensities of edges",
                "edge_vmin,edge_vmax : floats, optional": "Minimum and maximum for edge colormap scaling",
                "style : string (default=solid line)": "Edge line style e.g.: \u2018-\u2019, \u2018\u2013\u2019, \u2018-.\u2019, \u2018:\u2019\nor words like \u2018solid\u2019 or \u2018dashed\u2019.\n(Seematplotlib.patches.FancyArrowPatch:linestyle)",
                "labels : dictionary (default=None)": "Node labels in a dictionary of text labels keyed by node",
                "font_size : int (default=12 for nodes, 10 for edges)": "Font size for text labels",
                "font_color : color (default=\u2019k\u2019 black)": "Font color string. Color can be string or rgb (or rgba) tuple of\nfloats from 0-1.",
                "font_weight : string (default=\u2019normal\u2019)": "Font weight",
                "font_family : string (default=\u2019sans-serif\u2019)": "Font family",
                "label : string, optional": "Label for graph legend",
                "hide_ticks : bool, optional": "Hide ticks of axes. WhenTrue(the default), ticks and ticklabels\nare removed from the axes. To set ticks and tick labels to the pyplot default,\nusehide_ticks=False.",
                "kwds : optional keywords": "See networkx.draw_networkx_nodes(), networkx.draw_networkx_edges(), and\nnetworkx.draw_networkx_labels() for a description of optional keywords."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For directed graphs, arrows  are drawn at the head end.  Arrows can be\nturned off with keyword arrows=False.",
            "Examples": "G=nx.dodecahedral_graph()\nnx.draw(G)\nnx.draw(G,pos=nx.spring_layout(G))# use spring layout\nimportmatplotlib.pyplotasplt\nlimits=plt.axis(\"off\")# turn off axis\nAlso see the NetworkX drawing examples athttps://networkx.org/documentation/latest/auto_examples/index.html"
        }
    },
    {
        "Section ID": "parse_edgelist",
        "Description": [
            "Parse lines of an edge list representation of a graph."
        ],
        "Field List": {
            "Parameters:": {
                "lines : list or iterator of strings": "Input data in edgelist format",
                "comments : string, optional": "Marker for comment lines. Default is'#'. To specify that no character\nshould be treated as a comment, usecomments=None.",
                "delimiter : string, optional": "Separator for node labels. Default isNone, meaning any whitespace.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated.",
                "nodetype : Python type, optional": "Convert nodes to this type. Default isNone, meaning no conversion is\nperformed.",
                "data : bool or list of (label,type) tuples": "IfFalsegenerate no edge data or ifTrueuse a dictionary\nrepresentation of edge data or a list tuples specifying dictionary\nkey names and types for edge data."
            },
            "Returns:": {
                "G: NetworkX Graph": "The graph corresponding to lines"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "Edgelist with no data:\nlines=[\"1 2\",\"2 3\",\"3 4\"]\nG=nx.parse_edgelist(lines,nodetype=int)\nlist(G)\n# [1, 2, 3, 4]\nlist(G.edges())\n# [(1, 2), (2, 3), (3, 4)]\nEdgelist with data in Python dictionary representation:\nlines=[\"1 2 {'weight': 3}\",\"2 3 {'weight': 27}\",\"3 4 {'weight': 3.0}\"]\nG=nx.parse_edgelist(lines,nodetype=int)\nlist(G)\n# [1, 2, 3, 4]\nlist(G.edges(data=True))\n# [(1, 2, {'weight': 3}), (2, 3, {'weight': 27}), (3, 4, {'weight': 3.0})]\nEdgelist with data in a list:\nlines=[\"1 2 3\",\"2 3 27\",\"3 4 3.0\"]\nG=nx.parse_edgelist(lines,nodetype=int,data=((\"weight\",float),))\nlist(G)\n# [1, 2, 3, 4]\nlist(G.edges(data=True))\n# [(1, 2, {'weight': 3.0}), (2, 3, {'weight': 27.0}), (3, 4, {'weight': 3.0})]"
        }
    },
    {
        "Section ID": "FilterMultiInner",
        "Description": [
            "A read-only Mapping of Mappings with filtering criteria for nodes and edges.",
            "It is a view into a dict-of-dict-of-dict-of-dict data structure, and it selects nodes\nand edges that meet specific criteria defined by NODE_OK and EDGE_OK ."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "hide_multidiedges",
        "Description": [
            "Returns a filter function that hides specific multi-directed edges."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "random_shell_graph",
        "Description": [
            "Returns a random shell graph for the constructor given."
        ],
        "Field List": {
            "Parameters:": {
                "constructor : list of three-tuples": "Represents the parameters for a shell, starting at the center\nshell.  Each element of the list must be of the form(n,m,d), wherenis the number of nodes in the shell,mis\nthe number of edges in the shell, anddis the ratio of\ninter-shell (next) edges to intra-shell edges. Ifdis zero,\nthere will be no intra-shell edges, and ifdis one there\nwill be all possible intra-shell edges.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "constructor=[(10,20,0.8),(20,40,0.8)]\nG=nx.random_shell_graph(constructor)"
        }
    },
    {
        "Section ID": "joint_degree_graph",
        "Description": [
            "Generates a random simple graph with the given joint degree dictionary."
        ],
        "Field List": {
            "Parameters:": {
                "joint_degrees : dictionary of dictionary of integers": "A joint degree dictionary in which entryjoint_degrees[k][l]is the\nnumber of edges joining nodes of degreekwith nodes of degreel.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "G : Graph": "A graph with the specified joint degree dictionary."
            },
            "Raises:": {
                "NetworkXError": "Ifjoint_degreesdictionary is not realizable."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "In each iteration of the \u201cwhile loop\u201d the algorithm picks two disconnected\nnodes v and w , of degree k and l correspondingly,  for which joint_degrees[k][l] has not reached its target yet. It then adds\nedge ( v , w ) and increases the number of edges in graph G by one. The intelligence of the algorithm lies in the fact that  it is always\npossible to add an edge between such disconnected nodes v and w ,\neven if one or both nodes do not have free stubs. That is made possible by\nexecuting a \u201cneighbor switch\u201d, an edge rewiring move that releases\na free stub while keeping the joint degree of G the same. The algorithm continues for E (number of edges) iterations of\nthe \u201cwhile loop\u201d, at the which point all entries of the given joint_degrees[k][l] have reached their target values and the\nconstruction is complete.",
            "References": "[1]M. Gjoka, B. Tillman, A. Markopoulou, \u201cConstruction of Simple\nGraphs with a Target Joint Degree Matrix and Beyond\u201d, IEEE Infocom, \u201815",
            "Examples": "joint_degrees={\n1:{4:1},\n2:{2:2,3:2,4:2},\n3:{2:2,4:1},\n4:{1:1,2:2,3:1},\n}\nG=nx.joint_degree_graph(joint_degrees)"
        }
    },
    {
        "Section ID": "cumulative_distribution",
        "Description": [
            "Returns normalized cumulative distribution from discrete distribution."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "waxman_graph",
        "Description": [
            "Returns a Waxman random graph.",
            "The Waxman random graph model places n nodes uniformly at random\nin a rectangular domain. Each pair of nodes at distance d is\njoined by an edge with probability",
            "This function implements both Waxman models, using the L keyword\nargument."
        ],
        "Field List": {
            "Parameters:": {
                "n : int or iterable": "Number of nodes or iterable of nodes",
                "beta: float": "Model parameter",
                "alpha: float": "Model parameter",
                "L : float, optional": "Maximum distance between nodes.  If not specified, the actual distance\nis calculated.",
                "domain : four-tuple of numbers, optional": "Domain size, given as a tuple of the form(x_min,y_min,x_max,y_max).",
                "metric : function": "A metric on vectors of numbers (represented as lists or\ntuples). This must be a function that accepts two lists (or\ntuples) as input and yields a number as output. The function\nmust also satisfy the four requirements of ametric.\nSpecifically, if\\(d\\)is the function and\\(x\\),\\(y\\),\nand\\(z\\)are vectors in the graph, then\\(d\\)must satisfy\\(d(x, y) \\ge 0\\),\\(d(x, y) = 0\\)if and only if\\(x = y\\),\\(d(x, y) = d(y, x)\\),\\(d(x, z) \\le d(x, y) + d(y, z)\\).If this argument is not specified, the Euclidean distance metric is\nused.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "pos_name : string, default=\u201dpos\u201d": "The name of the node attribute which represents the position\nin 2D coordinates of the node in the returned graph."
            },
            "Returns:": {
                "Graph": "A random Waxman graph, undirected and without self-loops. Each\nnode has a node attribute'pos'that stores the position of\nthat node in Euclidean space as generated by this function."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Starting in NetworkX 2.0 the parameters alpha and beta align with their\nusual roles in the probability distribution. In earlier versions their\npositions in the expression were reversed. Their position in the calling\nsequence reversed as well to minimize backward incompatibility.",
            "References": "[1]B. M. Waxman,Routing of multipoint connections.\nIEEE J. Select. Areas Commun. 6(9),(1988) 1617\u20131622.",
            "Examples": "Specify an alternate distance metric using themetrickeyword\nargument. For example, to use the \u201ctaxicab metric\u201d instead of the\ndefaultEuclidean metric:\ndist=lambdax,y:sum(abs(a-b)fora,binzip(x,y))\nG=nx.waxman_graph(10,0.5,0.1,metric=dist)"
        }
    },
    {
        "Section ID": "restricted_view",
        "Description": [
            "Returns a view of G with hidden nodes and edges.",
            "The resulting subgraph filters out node nodes and edges edges .\nFiltered out nodes also filter out any of their edges."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "",
                "nodes : iterable": "An iterable of nodes. Nodes not present inGare ignored.",
                "edges : iterable": "An iterable of edges. Edges not present inGare ignored."
            },
            "Returns:": {
                "subgraph : SubGraph View": "A read-only restricted view ofGfiltering out nodes and edges.\nChanges toGare reflected in the view."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "To create a mutable subgraph with its own copies of nodes\nedges and attributes use subgraph.copy() or Graph(subgraph) If you create a subgraph of a subgraph recursively you may end up\nwith a chain of subgraph views. Such chains can get quite slow\nfor lengths near 15. To avoid long chains, try to make your subgraph\nbased on the original graph.  We do not rule out chains programmatically\nso that odd cases like an edge_subgraph of a restricted_view can be created.",
            "Examples": "G=nx.path_graph(5)\nH=nx.restricted_view(G,[0],[(1,2),(3,4)])\nlist(H.nodes)\n# [1, 2, 3, 4]\nlist(H.edges)\n# [(2, 3)]"
        }
    },
    {
        "Section ID": "show_nodes",
        "Description": [
            "Filter class to show specific nodes."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "bfs_layers",
        "Description": [
            "Returns an iterator of all the layers in breadth-first search traversal."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A graph over which to find the layers using breadth-first search.",
                "sources : node inGor list of nodes inG": "Specify starting nodes for single source or multiple sources breadth-first search"
            },
            "Yields:": {
                "layer: list of nodes": "Yields list of nodes at the same distance from sources"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.path_graph(5)\ndict(enumerate(nx.bfs_layers(G,[0,4])))\n# {0: [0, 4], 1: [1, 3], 2: [2]}\nH=nx.Graph()\nH.add_edges_from([(0,1),(0,2),(1,3),(1,4),(2,5),(2,6)])\ndict(enumerate(nx.bfs_layers(H,[1])))\n# {0: [1], 1: [0, 3, 4], 2: [2], 3: [5, 6]}\ndict(enumerate(nx.bfs_layers(H,[1,6])))\n# {0: [1, 6], 1: [0, 3, 4, 2], 2: [5]}"
        }
    },
    {
        "Section ID": "write_dot",
        "Description": [
            "Write NetworkX graph G to Graphviz dot format on path."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph",
                "path : filename": "Filename or file handle to write"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "To use a specific graph layout, call A.layout prior to write_dot .\nNote that some graphviz layouts are not guaranteed to be deterministic,\nsee graphviz/graphviz#1767 for more info."
        }
    },
    {
        "Section ID": "groups",
        "Description": [
            "Converts a many-to-one mapping into a one-to-many mapping.",
            "many_to_one must be a dictionary whose keys and values are all hashable .",
            "The return value is a dictionary mapping values from many_to_one to sets of keys from many_to_one that have that value.",
            "Examples"
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {
            "Examples": "fromnetworkx.utilsimportgroups\nmany_to_one={\"a\":1,\"b\":1,\"c\":2,\"d\":3,\"e\":3}\ngroups(many_to_one)\n# {1: {'a', 'b'}, 2: {'c'}, 3: {'e', 'd'}}"
        }
    },
    {
        "Section ID": "is_pseudographical",
        "Description": [
            "Returns True if some pseudograph can realize the sequence.",
            "Every nonnegative integer sequence with an even sum is pseudographical\n(see [1] )."
        ],
        "Field List": {
            "Parameters:": {
                "sequence : list or iterable container": "A sequence of integer node degrees"
            },
            "Returns:": {
                "valid : bool": "True if the sequence is a pseudographic degree sequence and False if not."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The worst-case run time is \\(O(n)\\) where n is the length of the sequence.",
            "References": "[1]F. Boesch and F. Harary. \u201cLine removal algorithms for graphs\nand their degree lists\u201d, IEEE Trans. Circuits and Systems, CAS-23(12),\npp. 778-782 (1976).",
            "Examples": "G=nx.Graph([(1,2),(1,3),(2,3),(3,4),(4,2),(5,1),(5,4)])\nsequence=(dfor_,dinG.degree())\nnx.is_pseudographical(sequence)\n# True\nTo test a non-pseudographical sequence:\n>>> sequence_list = [d for _, d in G.degree()]\n>>> sequence_list[-1] += 1\n>>> nx.is_pseudographical(sequence_list)\nFalse"
        }
    },
    {
        "Section ID": "adjacency_graph",
        "Description": [
            "Returns graph from adjacency data format."
        ],
        "Field List": {
            "Parameters:": {
                "data : dict": "Adjacency list formatted graph data",
                "directed : bool": "If True, and direction not specified in data, return a directed graph.",
                "multigraph : bool": "If True, and multigraph not specified in data, return a multigraph.",
                "attrs : dict": "A dictionary that contains two keys \u2018id\u2019 and \u2018key\u2019. The corresponding\nvalues provide the attribute names for storing NetworkX-internal graph\ndata. The values should be unique. Default value:dict(id='id',key='key')."
            },
            "Returns:": {
                "G : NetworkX graph": "A NetworkX graph object"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The default value of attrs will be changed in a future release of NetworkX.",
            "Examples": "fromnetworkx.readwriteimportjson_graph\nG=nx.Graph([(1,2)])\ndata=json_graph.adjacency_data(G)\nH=json_graph.adjacency_graph(data)"
        }
    },
    {
        "Section ID": "edge_betweenness_partition",
        "Description": [
            "Partition created by iteratively removing the highest edge betweenness edge.",
            "This algorithm works by calculating the edge betweenness for all\nedges and removing the edge with the highest value. It is then\ndetermined whether the graph has been broken into at least number_of_sets connected components.\nIf not the process is repeated."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph, DiGraph or MultiGraph": "Graph to be partitioned",
                "number_of_sets : int": "Number of sets in the desired partition of the graph",
                "weight : key, optional, default=None": "The key to use if using weights for edge betweenness calculation"
            },
            "Returns:": {
                "C : list of sets": "Partition of the nodes of G"
            },
            "Raises:": {
                "NetworkXError": "If number_of_sets is <= 0 or if number_of_sets > len(G)"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm is fairly slow, as both the calculation of connected\ncomponents and edge betweenness relies on all pairs shortest\npath algorithms. They could potentially be combined to cut down\non overall computation time.",
            "References": "[1]Santo Fortunato \u2018Community Detection in Graphs\u2019 Physical Reports\nVolume 486, Issue 3-5 p. 75-174http://arxiv.org/abs/0906.0612",
            "Examples": "G=nx.karate_club_graph()\npart=nx.community.edge_betweenness_partition(G,2)\n{0,1,3,4,5,6,7,10,11,12,13,16,17,19,21}inpart\n# True\n{2,8,9,14,15,18,20,22,23,24,25,26,27,28,29,30,31,32,33}inpart\n# True"
        }
    },
    {
        "Section ID": "minimum_spanning_edges",
        "Description": [
            "Generate edges in a minimum spanning forest of an undirected\nweighted graph.",
            "A minimum spanning tree is a subgraph of the graph (a tree)\nwith the minimum sum of edge weights.  A spanning forest is a\nunion of the spanning trees for each connected component of the graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : undirected Graph": "An undirected graph. IfGis connected, then the algorithm finds a\nspanning tree. Otherwise, a spanning forest is found.",
                "algorithm : string": "The algorithm to use when finding a minimum spanning tree. Valid\nchoices are \u2018kruskal\u2019, \u2018prim\u2019, or \u2018boruvka\u2019. The default is \u2018kruskal\u2019.",
                "weight : string": "Edge data key to use for weight (default \u2018weight\u2019).",
                "keys : bool": "Whether to yield edge key in multigraphs in addition to the edge.\nIfGis not a multigraph, this is ignored.",
                "data : bool, optional": "If True yield the edge data along with the edge.",
                "ignore_nan : bool (default: False)": "If a NaN is found as an edge weight normally an exception is raised.\nIfignore_nanisTruethen that edge is ignored instead."
            },
            "Returns:": {
                "edges : iterator": "An iterator over edges in a maximum spanning tree ofG.\nEdges connecting nodesuandvare represented as tuples:(u,v,k,d)or(u,v,k)or(u,v,d)or(u,v)IfGis a multigraph,keysindicates whether the edge keykwill\nbe reported in the third position in the edge tuple.dataindicates\nwhether the edge datadictdwill appear at the end of the edge tuple.IfGis not a multigraph, the tuples are(u,v,d)ifdatais True\nor(u,v)ifdatais False."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For Bor\u016fvka\u2019s algorithm, each edge must have a weight attribute, and\neach edge weight must be distinct. For the other algorithms, if the graph edges do not have a weight\nattribute a default weight of 1 will be used. Modified code from David Eppstein, April 2006 http://www.ics.uci.edu/~eppstein/PADS/",
            "Examples": "fromnetworkx.algorithmsimporttree\nFind minimum spanning edges by Kruskal\u2019s algorithm\nG=nx.cycle_graph(4)\nG.add_edge(0,3,weight=2)\nmst=tree.minimum_spanning_edges(G,algorithm=\"kruskal\",data=False)\nedgelist=list(mst)\nsorted(sorted(e)foreinedgelist)\n# [[0, 1], [1, 2], [2, 3]]\nFind minimum spanning edges by Prim\u2019s algorithm\nG=nx.cycle_graph(4)\nG.add_edge(0,3,weight=2)\nmst=tree.minimum_spanning_edges(G,algorithm=\"prim\",data=False)\nedgelist=list(mst)\nsorted(sorted(e)foreinedgelist)\n# [[0, 1], [1, 2], [2, 3]]"
        }
    },
    {
        "Section ID": "generate_pajek",
        "Description": [
            "Generate lines in Pajek graph format."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A Networkx graph"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "See http://vlado.fmf.uni-lj.si/pub/networks/pajek/doc/draweps.htm for format information."
        }
    },
    {
        "Section ID": "write_pajek",
        "Description": [
            "Write graph in Pajek format to path."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A Networkx graph",
                "path : file or string": "File or filename to write.\nFilenames ending in .gz or .bz2 will be compressed."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "See http://vlado.fmf.uni-lj.si/pub/networks/pajek/doc/draweps.htm for format information.",
            "Examples": "G=nx.path_graph(4)\nnx.write_pajek(G,\"test.net\")"
        }
    },
    {
        "Section ID": "AtlasView",
        "Description": [
            "An AtlasView is a Read-only Mapping of Mappings.",
            "It is a View into a dict-of-dict data structure.\nThe inner level of dict is read-write. But the\nouter level is read-only."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "diameter",
        "Description": [
            "Returns a lower bound on the diameter of the graph G.",
            "The function computes a lower bound on the diameter (i.e., the maximum eccentricity)\nof a directed or undirected graph G. The procedure used varies depending on the graph\nbeing directed or not.",
            "If G is an undirected graph, then the function uses the 2-sweep algorithm [1] .\nThe main idea is to pick the farthest node from a random node and return its eccentricity.",
            "Otherwise, if G is a directed graph, the function uses the 2-dSweep algorithm [2] ,\nThe procedure starts by selecting a random source node \\(s\\) from which it performs a\nforward and a backward BFS. Let \\(a_1\\) and \\(a_2\\) be the farthest nodes in the forward and\nbackward cases, respectively. Then, it computes the backward eccentricity of \\(a_1\\) using\na backward BFS and the forward eccentricity of \\(a_2\\) using a forward BFS.\nFinally, it returns the best lower bound between the two.",
            "In both cases, the time complexity is linear with respect to the size of G."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "d : integer": "Lower Bound on the Diameter of G"
            },
            "Raises:": {
                "NetworkXError": "If the graph is empty or\nIf the graph is undirected and not connected or\nIf the graph is directed and not strongly connected."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Magnien, Cl\u00e9mence, Matthieu Latapy, and Michel Habib.Fast computation of empirically tight bounds for the diameter of massive graphs.Journal of Experimental Algorithmics (JEA), 2009.https://arxiv.org/pdf/0904.2728.pdf  [2]Crescenzi, Pierluigi, Roberto Grossi, Leonardo Lanzi, and Andrea Marino.On computing the diameter of real-world directed (weighted) graphs.International Symposium on Experimental Algorithms. Springer, Berlin, Heidelberg, 2012.https://courses.cs.ut.ee/MTAT.03.238/2014_fall/uploads/Main/diameter.pdf",
            "Examples": "G=nx.path_graph(10)# undirected graph\nnx.diameter(G)\n# 9\nG=nx.cycle_graph(3,create_using=nx.DiGraph)# directed graph\nnx.diameter(G)\n# 2"
        }
    },
    {
        "Section ID": "uniform_random_intersection_graph",
        "Description": [
            "Returns a uniform random intersection graph."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes in the first bipartite set (nodes)",
                "m : int": "The number of nodes in the second bipartite set (attributes)",
                "p : float": "Probability of connecting nodes between bipartite sets",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]K.B. Singer-Cohen, Random Intersection Graphs, 1995,\nPhD thesis, Johns Hopkins University  [2]Fill, J. A., Scheinerman, E. R., and Singer-Cohen, K. B.,\nRandom intersection graphs when m = !(n):\nAn equivalence theorem relating the evolution of the g(n, m, p)\nand g(n, p) models. Random Struct. Algorithms 16, 2 (2000), 156\u2013176."
        }
    },
    {
        "Section ID": "SpanningTreeIterator",
        "Description": [
            "Iterate over all spanning trees of a graph in either increasing or\ndecreasing cost.",
            "Notes",
            "This iterator uses the partition scheme from [1] (included edges,\nexcluded edges and open edges) as well as a modified Kruskal\u2019s Algorithm\nto generate minimum spanning trees which respect the partition of edges.\nFor spanning trees with the same weight, ties are broken arbitrarily.",
            "References"
        ],
        "Field List": {
            "Parameters:": {
                "G : nx.Graph": "The directed graph which we need to iterate trees over",
                "weight : String, default = \u201cweight\u201d": "The edge attribute used to store the weight of the edge",
                "minimum : bool, default = True": "Return the trees in increasing order while true and decreasing order\nwhile false.",
                "ignore_nan : bool, default = False": "If a NaN is found as an edge weight normally an exception is raised.\nIfignore_nanisTruethen that edge is ignored instead."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This iterator uses the partition scheme from [1] (included edges,\nexcluded edges and open edges) as well as a modified Kruskal\u2019s Algorithm\nto generate minimum spanning trees which respect the partition of edges.\nFor spanning trees with the same weight, ties are broken arbitrarily.",
            "References": "[1]G.K. Janssens, K. S\u00f6rensen, An algorithm to generate all spanning\ntrees in order of increasing cost, Pesquisa Operacional, 2005-08,\nVol. 25 (2), p. 219-229,https://www.scielo.br/j/pope/a/XHswBwRwJyrfL88dmMwYNWp/?lang=en"
        }
    },
    {
        "Section ID": "estrada_index",
        "Description": [
            "Returns the Estrada index of a the graph G.",
            "The Estrada Index is a topological index of folding or 3D \u201ccompactness\u201d ( [1] )."
        ],
        "Field List": {
            "Parameters:": {
                "G: graph": ""
            },
            "Returns:": {
                "estrada index: float": ""
            },
            "Raises:": {
                "NetworkXError": "If the graph is not undirected and simple."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Let G=(V,E) be a simple undirected graph with n nodes  and let lambda_{1}leqlambda_{2}leqcdotslambda_{n} be a non-increasing ordering of the eigenvalues of its adjacency\nmatrix A . The Estrada index is ( [1] , [2] )",
            "References": "[1](1,2)E. Estrada, \u201cCharacterization of 3D molecular structure\u201d,\nChem. Phys. Lett. 319, 713 (2000).https://doi.org/10.1016/S0009-2614(00)00158-5  [2]Jos\u00e9 Antonio de la Pe\u00f1aa, Ivan Gutman, Juan Rada,\n\u201cEstimating the Estrada index\u201d,\nLinear Algebra and its Applications. 427, 1 (2007).https://doi.org/10.1016/j.laa.2007.06.020",
            "Examples": "G=nx.Graph([(0,1),(1,2),(1,5),(5,4),(2,4),(2,3),(4,3),(3,6)])\nei=nx.estrada_index(G)\nprint(f\"{ei:0.5}\")\n# 20.55"
        }
    },
    {
        "Section ID": "add_cycle",
        "Description": [
            "Add a cycle to the Graph G_to_add_to."
        ],
        "Field List": {
            "Parameters:": {
                "G_to_add_to : graph": "A NetworkX graph",
                "nodes_for_cycle: iterable container": "A container of nodes.  A cycle will be constructed from\nthe nodes (in order) and added to the graph.",
                "attr : keyword arguments, optional (default= no attributes)": "Attributes to add to every edge in cycle."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nnx.add_cycle(G,[0,1,2,3])\nnx.add_cycle(G,[10,11,12],weight=7)"
        }
    },
    {
        "Section ID": "random_degree_sequence_graph",
        "Description": [
            "Returns a simple random graph with the given degree sequence.",
            "If the maximum degree \\(d_m\\) in the sequence is \\(O(m^{1/4})\\) then the\nalgorithm produces almost uniform random graphs in \\(O(m d_m)\\) time\nwhere \\(m\\) is the number of edges."
        ],
        "Field List": {
            "Parameters:": {
                "sequence : list of integers": "Sequence of degrees",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "tries : int, optional": "Maximum number of tries to create a graph"
            },
            "Returns:": {
                "G : Graph": "A graph with the specified degree sequence.\nNodes are labeled starting at 0 with an index\ncorresponding to the position in the sequence."
            },
            "Raises:": {
                "NetworkXUnfeasible": "If the degree sequence is not graphical.",
                "NetworkXError": "If a graph is not produced in specified number of tries"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The generator algorithm [1] is not guaranteed to produce a graph.",
            "References": "[1]Moshen Bayati, Jeong Han Kim, and Amin Saberi,\nA sequential algorithm for generating random graphs.\nAlgorithmica, Volume 58, Number 4, 860-910,\nDOI: 10.1007/s00453-009-9340-1",
            "Examples": "sequence=[1,2,2,3]\nG=nx.random_degree_sequence_graph(sequence,seed=42)\nsorted(dforn,dinG.degree())\n# [1, 2, 2, 3]"
        }
    },
    {
        "Section ID": "all_simple_paths",
        "Description": [
            "Generate all simple paths in the graph G from source to target.",
            "A simple path is a path with no repeated nodes."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node": "Starting node for path",
                "target : nodes": "Single node or iterable of nodes at which to end path",
                "cutoff : integer, optional": "Depth to stop the search. Only paths of length <= cutoff are returned."
            },
            "Returns:": {
                "path_generator: generator": "A generator that produces lists of simple paths.  If there are no paths\nbetween the source and target within the given cutoff the generator\nproduces no output. If it is possible to traverse the same sequence of\nnodes in multiple ways, namely through parallel edges, then it will be\nreturned multiple times (once for each viable edge combination)."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm uses a modified depth-first search to generate the\npaths [1] .  A single path can be found in \\(O(V+E)\\) time but the\nnumber of simple paths in a graph can be very large, e.g. \\(O(n!)\\) in\nthe complete graph of order \\(n\\) . This function does not check that a path exists between source and target . For large graphs, this may result in very long runtimes.\nConsider using has_path to check that a path exists between source and target before calling this function on large graphs.",
            "References": "[1]R. Sedgewick, \u201cAlgorithms in C, Part 5: Graph Algorithms\u201d,\nAddison Wesley Professional, 3rd ed., 2001.",
            "Examples": "This iterator generates lists of nodes:\nG=nx.complete_graph(4)\nforpathinnx.all_simple_paths(G,source=0,target=3):\nprint(path)\n\n# [0, 1, 2, 3]\n# [0, 1, 3]\n# [0, 2, 1, 3]\n# [0, 2, 3]\n# [0, 3]\nYou can generate only those paths that are shorter than a certain\nlength by using thecutoffkeyword argument:\npaths=nx.all_simple_paths(G,source=0,target=3,cutoff=2)\nprint(list(paths))\n# [[0, 1, 3], [0, 2, 3], [0, 3]]\nTo get each path as the corresponding list of edges, you can use thenetworkx.utils.pairwise()helper function:\npaths=nx.all_simple_paths(G,source=0,target=3)\nforpathinmap(nx.utils.pairwise,paths):\nprint(list(path))\n# [(0, 1), (1, 2), (2, 3)]\n# [(0, 1), (1, 3)]\n# [(0, 2), (2, 1), (1, 3)]\n# [(0, 2), (2, 3)]\n# [(0, 3)]\nPass an iterable of nodes as target to generate all paths ending in any of several nodes:\nG=nx.complete_graph(4)\nforpathinnx.all_simple_paths(G,source=0,target=[3,2]):\nprint(path)\n\n# [0, 1, 2]\n# [0, 1, 2, 3]\n# [0, 1, 3]\n# [0, 1, 3, 2]\n# [0, 2]\n# [0, 2, 1, 3]\n# [0, 2, 3]\n# [0, 3]\n# [0, 3, 1, 2]\n# [0, 3, 2]\nThe singleton path fromsourceto itself is considered a simple path and is\nincluded in the results:\nG=nx.empty_graph(5)\nlist(nx.all_simple_paths(G,source=0,target=0))\n# [[0]]\nG=nx.path_graph(3)\nlist(nx.all_simple_paths(G,source=0,target={0,1,2}))\n# [[0], [0, 1], [0, 1, 2]]\nIterate over each path from the root nodes to the leaf nodes in a\ndirected acyclic graph using a functional programming approach:\nfromitertoolsimportchain\nfromitertoolsimportproduct\nfromitertoolsimportstarmap\nfromfunctoolsimportpartial\n\nchaini=chain.from_iterable\n\nG=nx.DiGraph([(0,1),(1,2),(0,3),(3,2)])\nroots=(vforv,dinG.in_degree()ifd==0)\nleaves=(vforv,dinG.out_degree()ifd==0)\nall_paths=partial(nx.all_simple_paths,G)\nlist(chaini(starmap(all_paths,product(roots,leaves))))\n# [[0, 1, 2], [0, 3, 2]]\nThe same list computed using an iterative approach:\nG=nx.DiGraph([(0,1),(1,2),(0,3),(3,2)])\nroots=(vforv,dinG.in_degree()ifd==0)\nleaves=(vforv,dinG.out_degree()ifd==0)\nall_paths=[]\nforrootinroots:\nforleafinleaves:\npaths=nx.all_simple_paths(G,root,leaf)\nall_paths.extend(paths)\nall_paths\n# [[0, 1, 2], [0, 3, 2]]\nIterate over each path from the root nodes to the leaf nodes in a\ndirected acyclic graph passing all leaves together to avoid unnecessary\ncompute:\nG=nx.DiGraph([(0,1),(2,1),(1,3),(1,4)])\nroots=(vforv,dinG.in_degree()ifd==0)\nleaves=[vforv,dinG.out_degree()ifd==0]\nall_paths=[]\nforrootinroots:\npaths=nx.all_simple_paths(G,root,leaves)\nall_paths.extend(paths)\nall_paths\n# [[0, 1, 3], [0, 1, 4], [2, 1, 3], [2, 1, 4]]\nIf parallel edges offer multiple ways to traverse a given sequence of\nnodes, this sequence of nodes will be returned multiple times:\nG=nx.MultiDiGraph([(0,1),(0,1),(1,2)])\nlist(nx.all_simple_paths(G,0,2))\n# [[0, 1, 2], [0, 1, 2]]"
        }
    },
    {
        "Section ID": "overlap_weighted_projected_graph",
        "Description": [
            "Overlap weighted projection of B onto one of its node sets.",
            "The overlap weighted projection is the projection of the bipartite\nnetwork B onto the specified nodes with weights representing\nthe Jaccard index between the neighborhoods of the two nodes in the\noriginal bipartite network [1] :",
            "or if the parameter \u2018jaccard\u2019 is False, the fraction of common\nneighbors by minimum of both nodes degree in the original\nbipartite graph [1] :",
            "The nodes retain their attributes and are connected in the resulting\ngraph if have an edge to a common node in the original bipartite graph."
        ],
        "Field List": {
            "Parameters:": {
                "B : NetworkX graph": "The input graph should be bipartite.",
                "nodes : list or iterable": "Nodes to project onto (the \u201cbottom\u201d nodes).",
                "jaccard: Bool (default=True)": ""
            },
            "Returns:": {
                "Graph : NetworkX graph": "A graph that is the projection onto the given nodes."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "No attempt is made to verify that the input graph B is bipartite.\nThe graph and node properties are (shallow) copied to the projected graph. See bipartitedocumentation for further details on how bipartite graphs are handled in NetworkX.",
            "References": "[1](1,2)Borgatti, S.P. and Halgin, D. In press. Analyzing Affiliation\nNetworks. In Carrington, P. and Scott, J. (eds) The Sage Handbook\nof Social Network Analysis. Sage Publications.",
            "Examples": "fromnetworkx.algorithmsimportbipartite\nB=nx.path_graph(5)\nnodes=[0,2,4]\nG=bipartite.overlap_weighted_projected_graph(B,nodes)\nlist(G)\n# [0, 2, 4]\nlist(G.edges(data=True))\n# [(0, 2, {'weight': 0.5}), (2, 4, {'weight': 0.5})]\nG=bipartite.overlap_weighted_projected_graph(B,nodes,jaccard=False)\nlist(G.edges(data=True))\n# [(0, 2, {'weight': 1.0}), (2, 4, {'weight': 1.0})]"
        }
    },
    {
        "Section ID": "reciprocity",
        "Description": [
            "Compute the reciprocity in a directed graph.",
            "The reciprocity of a directed graph is defined as the ratio\nof the number of edges pointing in both directions to the total\nnumber of edges in the graph.\nFormally, \\(r = |{(u,v) \\in G|(v,u) \\in G}| / |{(u,v) \\in G}|\\) .",
            "The reciprocity of a single node u is defined similarly,\nit is the ratio of the number of edges in both directions to\nthe total number of edges attached to node u."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx directed graph",
                "nodes : container of nodes, optional (default=whole graph)": "Compute reciprocity for nodes in this container."
            },
            "Returns:": {
                "out : dictionary": "Reciprocity keyed by node label."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The reciprocity is not defined for isolated nodes.\nIn such cases this function will return None."
        }
    },
    {
        "Section ID": "articulation_points",
        "Description": [
            "Yield the articulation points, or cut vertices, of a graph.",
            "An articulation point or cut vertex is any node whose removal (along with\nall its incident edges) increases the number of connected components of\na graph.  An undirected connected graph without articulation points is\nbiconnected. Articulation points belong to more than one biconnected\ncomponent of a graph.",
            "Notice that by convention a dyad is considered a biconnected component."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "An undirected graph."
            },
            "Yields:": {
                "node": "An articulation point in the graph."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the input graph is not undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The algorithm to find articulation points and biconnected\ncomponents is implemented using a non-recursive depth-first-search\n(DFS) that keeps track of the highest level that back edges reach\nin the DFS tree.  A node n is an articulation point if, and only\nif, there exists a subtree rooted at n such that there is no\nback edge from any successor of n that links to a predecessor of n in the DFS tree.  By keeping track of all the edges traversed\nby the DFS we can obtain the biconnected components because all\nedges of a bicomponent will be traversed consecutively between\narticulation points.",
            "References": "[1]Hopcroft, J.; Tarjan, R. (1973).\n\u201cEfficient algorithms for graph manipulation\u201d.\nCommunications of the ACM 16: 372\u2013378. doi:10.1145/362248.362272",
            "Examples": "G=nx.barbell_graph(4,2)\nprint(nx.is_biconnected(G))\n# False\nlen(list(nx.articulation_points(G)))\n# 4\nG.add_edge(2,8)\nprint(nx.is_biconnected(G))\n# True\nlen(list(nx.articulation_points(G)))\n# 0"
        }
    },
    {
        "Section ID": "all_neighbors",
        "Description": [
            "Returns all of the neighbors of a node in the graph.",
            "If the graph is directed returns predecessors as well as successors."
        ],
        "Field List": {
            "Parameters:": {
                "graph : NetworkX graph": "Graph to find neighbors.",
                "node : node": "The node whose neighbors will be returned."
            },
            "Returns:": {
                "neighbors : iterator": "Iterator of neighbors"
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "newman_watts_strogatz_graph",
        "Description": [
            "Returns a Newman\u2013Watts\u2013Strogatz small-world graph."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes.",
                "k : int": "Each node is joined with itsknearest neighbors in a ring\ntopology.",
                "p : float": "The probability of adding a new edge for each edge.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "First create a ring over \\(n\\) nodes [1] .  Then each node in the ring is\nconnected with its \\(k\\) nearest neighbors (or \\(k - 1\\) neighbors if \\(k\\) is odd).  Then shortcuts are created by adding new edges as follows: for\neach edge \\((u, v)\\) in the underlying \u201c \\(n\\) -ring with \\(k\\) nearest\nneighbors\u201d with probability \\(p\\) add a new edge \\((u, w)\\) with\nrandomly-chosen existing node \\(w\\) .  In contrast with watts_strogatz_graph() , no edges are removed.",
            "References": "[1]M. E. J. Newman and D. J. Watts,\nRenormalization group analysis of the small-world network model,\nPhysics Letters A, 263, 341, 1999.https://doi.org/10.1016/S0375-9601(99)00757-4"
        }
    },
    {
        "Section ID": "bellman_ford_predecessor_and_distance",
        "Description": [
            "Compute shortest path lengths and predecessors on shortest paths\nin weighted graphs.",
            "The algorithm has a running time of \\(O(mn)\\) where \\(n\\) is the number of\nnodes and \\(m\\) is the number of edges.  It is slower than Dijkstra but\ncan handle negative edge weights.",
            "If a negative cycle is detected, you can use find_negative_cycle() to return the cycle and examine it. Shortest paths are not defined when\na negative cycle exists because once reached, the path can cycle forever\nto build up arbitrarily low weights."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "The algorithm works for all types of graphs, including directed\ngraphs and multigraphs.",
                "source: node label": "Starting node for path",
                "target : node label, optional": "Ending node for path",
                "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number.",
                "heuristic : bool": "Determines whether to use a heuristic to early detect negative\ncycles at a hopefully negligible cost."
            },
            "Returns:": {
                "pred, dist : dictionaries": "Returns two dictionaries keyed by node to predecessor in the\npath and to the distance from the source respectively."
            },
            "Raises:": {
                "NodeNotFound": "Ifsourceis not inG.",
                "NetworkXUnbounded": "If the (di)graph contains a negative (di)cycle, the\nalgorithm raises an exception to indicate the presence of the\nnegative (di)cycle.  Note: any negative weight edge in an\nundirected graph is a negative cycle."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The dictionaries returned only have keys for nodes reachable from\nthe source. In the case where the (di)graph is not connected, if a component\nnot containing the source contains a negative (di)cycle, it\nwill not be detected. In NetworkX v2.1 and prior, the source node had predecessor [None] .\nIn NetworkX v2.2 this changed to the source node having predecessor []",
            "Examples": "G=nx.path_graph(5,create_using=nx.DiGraph())\npred,dist=nx.bellman_ford_predecessor_and_distance(G,0)\nsorted(pred.items())\n# [(0, []), (1, [0]), (2, [1]), (3, [2]), (4, [3])]\nsorted(dist.items())\n# [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]\npred,dist=nx.bellman_ford_predecessor_and_distance(G,0,1)\nsorted(pred.items())\n# [(0, []), (1, [0]), (2, [1]), (3, [2]), (4, [3])]\nsorted(dist.items())\n# [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]\nG=nx.cycle_graph(5,create_using=nx.DiGraph())\nG[1][2][\"weight\"]=-7\nnx.bellman_ford_predecessor_and_distance(G,0)Traceback (most recent call last):    ...networkx.exception.NetworkXUnboundedNegative cycle detected."
        }
    },
    {
        "Section ID": "eccentricity",
        "Description": [
            "Returns the eccentricity of nodes in G.",
            "The eccentricity of a node v is the maximum distance from v to\nall other nodes in G."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A graph",
                "v : node, optional": "Return value of specified node",
                "sp : dict of dicts, optional": "All pairs shortest path lengths as a dictionary of dictionaries",
                "weight : string, function, or None (default=None)": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number.If this is None, every edge has weight/distance/cost 1.Weights stored as floating point values can lead to small round-off\nerrors in distances. Use integer weights to avoid this.Weights should be positive, since they are distances."
            },
            "Returns:": {
                "ecc : dictionary": "A dictionary of eccentricity values keyed by node."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph([(1,2),(1,3),(1,4),(3,4),(3,5),(4,5)])\ndict(nx.eccentricity(G))\n# {1: 2, 2: 3, 3: 2, 4: 2, 5: 3}\ndict(nx.eccentricity(G,v=[1,5]))# This returns the eccentricity of node 1 & 5\n# {1: 2, 5: 3}"
        }
    },
    {
        "Section ID": "UnionMultiInner",
        "Description": [
            "A read-only union of two inner dicts of MultiAdjacencies.",
            "The two input dict-of-dict-of-dicts represent the union of G.succ[node] and G.pred[node] for MultiDiGraphs.\nReturn values are UnionAtlas.\nThe inner level of dict is read-write. But the outer levels are read-only."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "generalized_degree",
        "Description": [
            "Compute the generalized degree for nodes.",
            "For each node, the generalized degree shows how many edges of given\ntriangle multiplicity the node is connected to. The triangle multiplicity\nof an edge is the number of triangles an edge participates in. The\ngeneralized degree of node \\(i\\) can be written as a vector \\(\\mathbf{k}_i=(k_i^{(0)}, \\dotsc, k_i^{(N-2)})\\) where \\(k_i^{(j)}\\) is the number of edges attached to node \\(i\\) that\nparticipate in \\(j\\) triangles."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "",
                "nodes : container of nodes, optional (default=all nodes in G)": "Compute the generalized degree for nodes in this container."
            },
            "Returns:": {
                "out : Counter, or dictionary of Counters": "Generalized degree of specified nodes. The Counter is keyed by edge\ntriangle multiplicity."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Self loops are ignored. In a network of N nodes, the highest triangle multiplicity an edge can have\nis N-2. The return value does not include a zero entry if no edges of a\nparticular triangle multiplicity are present. The number of triangles node \\(i\\) is attached to can be recovered from\nthe generalized degree \\(\\mathbf{k}_i=(k_i^{(0)}, \\dotsc,\nk_i^{(N-2)})\\) by \\((k_i^{(1)}+2k_i^{(2)}+\\dotsc +(N-2)k_i^{(N-2)})/2\\) .",
            "References": "[1]Networks with arbitrary edge multiplicities by V. Zlati\u0107,\nD. Garlaschelli and G. Caldarelli, EPL (Europhysics Letters),\nVolume 97, Number 2 (2012).https://iopscience.iop.org/article/10.1209/0295-5075/97/28005",
            "Examples": "G=nx.complete_graph(5)\nprint(nx.generalized_degree(G,0))\n# Counter({3: 4})\nprint(nx.generalized_degree(G))\n# {0: Counter({3: 4}), 1: Counter({3: 4}), 2: Counter({3: 4}), 3: Counter({3: 4}), 4: Counter({3: 4})}\nTo recover the number of triangles attached to a node:\nk1=nx.generalized_degree(G,0)\nsum([k*vfork,vink1.items()])/2==nx.triangles(G,0)\n# True"
        }
    },
    {
        "Section ID": "number_of_edges",
        "Description": [
            "Returns the number of edges in the graph.",
            "This function wraps the G.number_of_edges function."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "read_graphml",
        "Description": [
            "Read graph in GraphML format from path."
        ],
        "Field List": {
            "Parameters:": {
                "path : file or string": "File or filename to write.\nFilenames ending in .gz or .bz2 will be compressed.",
                "node_type: Python type (default: str)": "Convert node ids to this type",
                "edge_key_type: Python type (default: int)": "Convert graphml edge ids to this type. Multigraphs use id as edge key.\nNon-multigraphs add to edge attribute dict with name \u201cid\u201d.",
                "force_multigraph : bool (default: False)": "If True, return a multigraph with edge keys. If False (the default)\nreturn a multigraph when multiedges are in the graph."
            },
            "Returns:": {
                "graph: NetworkX graph": "If parallel edges are present orforce_multigraph=Truethen\na MultiGraph or MultiDiGraph is returned. Otherwise a Graph/DiGraph.\nThe returned graph is directed if the file indicates it should be."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Default node and edge attributes are not propagated to each node and edge.\nThey can be obtained from G.graph and applied to node and edge attributes\nif desired using something like this:"
        }
    },
    {
        "Section ID": "draw_random",
        "Description": [
            "Draw the graph G with a random layout.",
            "This is a convenience function equivalent to:"
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph",
                "kwargs : optional keywords": "Seedraw_networkxfor a description of optional keywords."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The layout is computed each time this function is called.\nFor repeated drawing it is much more efficient to call random_layout directly and reuse the result:",
            "Examples": "G=nx.lollipop_graph(4,3)\nnx.draw_random(G)"
        }
    },
    {
        "Section ID": "average_clustering",
        "Description": [
            "Compute the average bipartite clustering coefficient.",
            "A clustering coefficient for the whole graph is the average,",
            "where n is the number of nodes in G .",
            "Similar measures for the two bipartite sets can be defined [1]",
            "where X is a bipartite set of G ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "a bipartite graph",
                "nodes : list or iterable, optional": "A container of nodes to use in computing the average.\nThe nodes should be either the entire graph (the default) or one of the\nbipartite sets.",
                "mode : string": "The pairwise bipartite clustering method.\nIt must be \u201cdot\u201d, \u201cmax\u201d, or \u201cmin\u201d"
            },
            "Returns:": {
                "clustering : float": "The average bipartite clustering for the given set of nodes or the\nentire graph if no nodes are specified."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The container of nodes passed to this function must contain all of the nodes\nin one of the bipartite sets (\u201ctop\u201d or \u201cbottom\u201d) in order to compute\nthe correct average bipartite clustering coefficients.\nSee bipartitedocumentation for further details on how bipartite graphs are handled in NetworkX.",
            "References": "[1]Latapy, Matthieu, Cl\u00e9mence Magnien, and Nathalie Del Vecchio (2008).\nBasic notions for the analysis of large two-mode networks.\nSocial Networks 30(1), 31\u201348.",
            "Examples": "fromnetworkx.algorithmsimportbipartite\nG=nx.star_graph(3)# star graphs are bipartite\nbipartite.average_clustering(G)\n# 0.75\nX,Y=bipartite.sets(G)\nbipartite.average_clustering(G,X)\n# 0.0\nbipartite.average_clustering(G,Y)\n# 1.0"
        }
    },
    {
        "Section ID": "astar_path",
        "Description": [
            "Returns a list of nodes in a shortest path between source and target\nusing the A* (\u201cA-star\u201d) algorithm.",
            "There may be more than one shortest path.  This returns only one."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node": "Starting node for path",
                "target : node": "Ending node for path",
                "heuristic : function": "A function to evaluate the estimate of the distance\nfrom the a node to the target.  The function takes\ntwo nodes arguments and must return a number.\nIf the heuristic is inadmissible (if it might\noverestimate the cost of reaching the goal from a node),\nthe result may not be a shortest path.\nThe algorithm does not support updating heuristic\nvalues for the same node due to caching the first\nheuristic calculation per node.",
                "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.\nIf this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge.",
                "cutoff : float, optional": "If this is provided, the search will be bounded to this value. I.e. if\nthe evaluation function surpasses this value for a node n, the node will not\nbe expanded further and will be ignored. More formally, let h\u2019(n) be the\nheuristic function, and g(n) be the cost of reaching n from the source node. Then,\nif g(n) + h\u2019(n) > cutoff, the node will not be explored further.\nNote that if the heuristic is inadmissible, it is possible that paths\nare ignored even though they satisfy the cutoff."
            },
            "Raises:": {
                "NetworkXNoPath": "If no path exists between source and target."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The weight function can be used to hide edges by returning None.\nSo weight=lambdau,v,d:1ifd['color']==\"red\"elseNone will find the shortest red path.",
            "Examples": "G=nx.path_graph(5)\nprint(nx.astar_path(G,0,4))\n# [0, 1, 2, 3, 4]\nG=nx.grid_graph(dim=[3,3])# nodes are two-tuples (x,y)\nnx.set_edge_attributes(G,{e:e[1][0]*2foreinG.edges()},\"cost\")\ndefdist(a,b):\n(x1,y1)=a\n(x2,y2)=b\nreturn((x1-x2)**2+(y1-y2)**2)**0.5\nprint(nx.astar_path(G,(0,0),(2,2),heuristic=dist,weight=\"cost\"))\n# [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)]"
        }
    },
    {
        "Section ID": "eigenvector_centrality",
        "Description": [
            "Compute the eigenvector centrality for the graph G.",
            "Eigenvector centrality computes the centrality for a node by adding\nthe centrality of its predecessors. The centrality for node \\(i\\) is the \\(i\\) -th element of a left eigenvector associated with the eigenvalue \\(\\lambda\\) of maximum modulus that is positive. Such an eigenvector \\(x\\) is\ndefined up to a multiplicative constant by the equation",
            "where \\(A\\) is the adjacency matrix of the graph G. By definition of\nrow-column product, the equation above is equivalent to",
            "That is, adding the eigenvector centralities of the predecessors of \\(i\\) one obtains the eigenvector centrality of \\(i\\) multiplied by \\(\\lambda\\) . In the case of undirected graphs, \\(x\\) also solves the familiar\nright-eigenvector equation \\(Ax = \\lambda x\\) .",
            "By virtue of the Perron\u2013Frobenius theorem [1] , if G is strongly\nconnected there is a unique eigenvector \\(x\\) , and all its entries\nare strictly positive.",
            "If G is not strongly connected there might be several left\neigenvectors associated with \\(\\lambda\\) , and some of their elements\nmight be zero."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph.",
                "max_iter : integer, optional (default=100)": "Maximum number of power iterations.",
                "tol : float, optional (default=1.0e-6)": "Error tolerance (in Euclidean norm) used to check convergence in\npower iteration.",
                "nstart : dictionary, optional (default=None)": "Starting value of power iteration for each node. Must have a nonzero\nprojection on the desired eigenvector for the power method to converge.\nIf None, this implementation uses an all-ones vector, which is a safe\nchoice.",
                "weight : None or string, optional (default=None)": "If None, all edge weights are considered equal. Otherwise holds the\nname of the edge attribute used as weight. In this measure the\nweight is interpreted as the connection strength."
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of nodes with eigenvector centrality as the value. The\nassociated vector has unit Euclidean norm and the values are\nnonegative."
            },
            "Raises:": {
                "NetworkXPointlessConcept": "If the graph G is the null graph.",
                "NetworkXError": "If each value innstartis zero.",
                "PowerIterationFailedConvergence": "If the algorithm fails to converge to the specified tolerance\nwithin the specified number of iterations of the power iteration\nmethod."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Eigenvector centrality was introduced by Landau [2] for chess\ntournaments. It was later rediscovered by Wei [3] and then\npopularized by Kendall [4] in the context of sport ranking. Berge\nintroduced a general definition for graphs based on social connections [5] . Bonacich [6] reintroduced again eigenvector centrality and made\nit popular in link analysis. This function computes the left dominant eigenvector, which corresponds\nto adding the centrality of predecessors: this is the usual approach.\nTo add the centrality of successors first reverse the graph with G.reverse() . The implementation uses power iteration [7] to compute a dominant\neigenvector starting from the provided vector nstart . Convergence is\nguaranteed as long as nstart has a nonzero projection on a dominant\neigenvector, which certainly happens using the default value. The method stops when the change in the computed vector between two\niterations is smaller than an error tolerance of G.number_of_nodes()*tol or after max_iter iterations, but in the second case it\nraises an exception. This implementation uses \\((A + I)\\) rather than the adjacency matrix \\(A\\) because the change preserves eigenvectors, but it shifts the\nspectrum, thus guaranteeing convergence even for networks with\nnegative eigenvalues of maximum modulus.",
            "References": "[1]Abraham Berman and Robert J. Plemmons.\n\u201cNonnegative Matrices in the Mathematical Sciences.\u201d\nClassics in Applied Mathematics. SIAM, 1994.  [2]Edmund Landau.\n\u201cZur relativen Wertbemessung der Turnierresultate.\u201d\nDeutsches Wochenschach, 11:366\u2013369, 1895.  [3]Teh-Hsing Wei.\n\u201cThe Algebraic Foundations of Ranking Theory.\u201d\nPhD thesis, University of Cambridge, 1952.  [4]Maurice G. Kendall.\n\u201cFurther contributions to the theory of paired comparisons.\u201d\nBiometrics, 11(1):43\u201362, 1955.https://www.jstor.org/stable/3001479  [5]Claude Berge\n\u201cTh\u00e9orie des graphes et ses applications.\u201d\nDunod, Paris, France, 1958.  [6]Phillip Bonacich.\n\u201cTechnique for analyzing overlapping memberships.\u201d\nSociological Methodology, 4:176\u2013185, 1972.https://www.jstor.org/stable/270732  [7]Power iteration::https://en.wikipedia.org/wiki/Power_iteration",
            "Examples": "G=nx.path_graph(4)\ncentrality=nx.eigenvector_centrality(G)\nsorted((v,f\"{c:0.2f}\")forv,cincentrality.items())\n# [(0, '0.37'), (1, '0.60'), (2, '0.60'), (3, '0.37')]"
        }
    },
    {
        "Section ID": "diameter",
        "Description": [
            "Returns the diameter of the graph G.",
            "The diameter is the maximum eccentricity."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A graph",
                "e : eccentricity dictionary, optional": "A precomputed dictionary of eccentricities.",
                "weight : string, function, or None": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number.If this is None, every edge has weight/distance/cost 1.Weights stored as floating point values can lead to small round-off\nerrors in distances. Use integer weights to avoid this.Weights should be positive, since they are distances."
            },
            "Returns:": {
                "d : integer": "Diameter of graph"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph([(1,2),(1,3),(1,4),(3,4),(3,5),(4,5)])\nnx.diameter(G)\n# 3"
        }
    },
    {
        "Section ID": "modularity_spectrum",
        "Description": [
            "Returns eigenvalues of the modularity matrix of G."
        ],
        "Field List": {
            "Parameters:": {
                "G : Graph": "A NetworkX Graph or DiGraph"
            },
            "Returns:": {
                "evals : NumPy array": "Eigenvalues"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]M. E. J. Newman, \u201cModularity and community structure in networks\u201d,\nProc. Natl. Acad. Sci. USA, vol. 103, pp. 8577-8582, 2006."
        }
    },
    {
        "Section ID": "induced_subgraph",
        "Description": [
            "Returns a SubGraph view of G showing only nodes in nbunch.",
            "The induced subgraph of a graph on a set of nodes N is the\ngraph with nodes N and edges from G which have both ends in N."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "",
                "nbunch : node, container of nodes or None (for all nodes)": ""
            },
            "Returns:": {
                "subgraph : SubGraph View": "A read-only view of the subgraph inGinduced by the nodes.\nChanges to the graphGwill be reflected in the view."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "To create a mutable subgraph with its own copies of nodes\nedges and attributes use subgraph.copy() or Graph(subgraph) For an inplace reduction of a graph to a subgraph you can remove nodes: G.remove_nodes_from(ninGifnnotinset(nbunch)) If you are going to compute subgraphs of your subgraphs you could\nend up with a chain of views that can be very slow once the chain\nhas about 15 views in it. If they are all induced subgraphs, you\ncan short-cut the chain by making them all subgraphs of the original\ngraph. The graph class method G.subgraph does this when G is\na subgraph. In contrast, this function allows you to choose to build\nchains or not, as you wish. The returned subgraph is a view on G .",
            "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nH=nx.induced_subgraph(G,[0,1,3])\nlist(H.edges)\n# [(0, 1)]\nlist(H.nodes)\n# [0, 1, 3]"
        }
    },
    {
        "Section ID": "sigma",
        "Description": [
            "Returns the small-world coefficient (sigma) of the given graph.",
            "The small-world coefficient is defined as:\nsigma = C/Cr / L/Lr\nwhere C and L are respectively the average clustering coefficient and\naverage shortest path length of G. Cr and Lr are respectively the average\nclustering coefficient and average shortest path length of an equivalent\nrandom graph.",
            "A graph is commonly classified as small-world if sigma>1."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "An undirected graph.",
                "niter : integer (optional, default=100)": "Approximate number of rewiring per edge to compute the equivalent\nrandom graph.",
                "nrand : integer (optional, default=10)": "Number of random graphs generated to compute the average clustering\ncoefficient (Cr) and average shortest path length (Lr).",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "sigma : float": "The small-world coefficient of G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The implementation is adapted from Humphries et al. [1]  [2] .",
            "References": "[1]The brainstem reticular formation is a small-world, not scale-free,\nnetwork M. D. Humphries, K. Gurney and T. J. Prescott,\nProc. Roy. Soc. B 2006 273, 503-511, doi:10.1098/rspb.2005.3354.  [2]Humphries and Gurney (2008).\n\u201cNetwork \u2018Small-World-Ness\u2019: A Quantitative Method for Determining\nCanonical Network Equivalence\u201d.\nPLoS One. 3 (4). PMID 18446219. doi:10.1371/journal.pone.0002051."
        }
    },
    {
        "Section ID": "erdos_renyi_graph",
        "Description": [
            "Returns a \\(G_{n,p}\\) random graph, also known as an Erd\u0151s-R\u00e9nyi graph\nor a binomial graph.",
            "The \\(G_{n,p}\\) model chooses each of the possible edges with probability \\(p\\) ."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes.",
                "p : float": "Probability for edge creation.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "directed : bool, optional (default=False)": "If True, this function returns a directed graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm [2] runs in \\(O(n^2)\\) time.  For sparse graphs (that is, for\nsmall values of \\(p\\) ), fast_gnp_random_graph() is a faster algorithm. binomial_graph() and erdos_renyi_graph() are\naliases for gnp_random_graph() .",
            "References": "[1]Erd\u0151s and A. R\u00e9nyi, On Random Graphs, Publ. Math. 6, 290 (1959).  [2]Gilbert, Random Graphs, Ann. Math. Stat., 30, 1141 (1959)."
        }
    },
    {
        "Section ID": "draw_planar",
        "Description": [
            "Draw a planar networkx graph G with planar layout.",
            "This is a convenience function equivalent to:"
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A planar networkx graph",
                "kwargs : optional keywords": "Seedraw_networkxfor a description of optional keywords."
            },
            "Raises:": {
                "NetworkXException": "WhenGis not planar"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The layout is computed each time this function is called.\nFor repeated drawing it is much more efficient to call planar_layout directly and reuse the result:",
            "Examples": "G=nx.path_graph(4)\nnx.draw_planar(G)"
        }
    },
    {
        "Section ID": "to_directed",
        "Description": [
            "Returns a directed view of the graph graph .",
            "Identical to graph.to_directed(as_view=True)\nNote that graph.to_directed defaults to as_view=False while this function always provides a view."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "node_boundary",
        "Description": [
            "Returns the node boundary of nbunch1 .",
            "The node boundary of a set S with respect to a set T is the\nset of nodes v in T such that for some u in S , there is an\nedge joining u to v . If T is not specified, it is assumed to\nbe the set of all nodes not in S ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "nbunch1 : iterable": "Iterable of nodes in the graph representing the set of nodes\nwhose node boundary will be returned. (This is the setSfrom\nthe definition above.)",
                "nbunch2 : iterable": "Iterable of nodes representing the target (or \u201cexterior\u201d) set of\nnodes. (This is the setTfrom the definition above.) If not\nspecified, this is assumed to be the set of all nodes inGnot innbunch1."
            },
            "Returns:": {
                "set": "The node boundary ofnbunch1with respect tonbunch2."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Any element of nbunch that is not in the graph G will be\nignored. nbunch1 and nbunch2 are usually meant to be disjoint, but in\nthe interest of speed and generality, that is not required here.",
            "Examples": "G=nx.wheel_graph(6)\nWhen nbunch2=None:\nlist(nx.node_boundary(G,(3,4)))\n# [0, 2, 5]\nWhen nbunch2 is given:\nlist(nx.node_boundary(G,(3,4),(0,1,5)))\n# [0, 5]"
        }
    },
    {
        "Section ID": "metric_closure",
        "Description": [
            "Return the metric closure of a graph.",
            "The metric closure of a graph G is the complete graph in which each edge\nis weighted by the shortest path distance between the nodes in G ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": ""
            },
            "Returns:": {
                "NetworkX graph": "Metric closure of the graphG."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "find_negative_cycle",
        "Description": [
            "Returns a cycle with negative total weight if it exists.",
            "Bellman-Ford is used to find shortest_paths. That algorithm\nstops if there exists a negative cycle. This algorithm\npicks up from there and returns the found negative cycle.",
            "The cycle consists of a list of nodes in the cycle order. The last\nnode equals the first to make it a cycle.\nYou can look up the edge weights in the original graph. In the case\nof multigraphs the relevant edge is the minimal weight edge between\nthe nodes in the 2-tuple.",
            "If the graph has no negative cycle, a NetworkXError is raised."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source: node label": "The search for the negative cycle will start from this node.",
                "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number."
            },
            "Returns:": {
                "cycle : list": "A list of nodes in the order of the cycle found. The last node\nequals the first to indicate a cycle."
            },
            "Raises:": {
                "NetworkXError": "If no negative cycle is found."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.DiGraph()\nG.add_weighted_edges_from([(0,1,2),(1,2,2),(2,0,1),(1,4,2),(4,0,-5)])\nnx.find_negative_cycle(G,0)\n# [4, 0, 1, 4]"
        }
    },
    {
        "Section ID": "py_random_state",
        "Description": [
            "Decorator to generate a random.Random instance (or equiv).",
            "This decorator processes random_state_argument using nx.utils.create_py_random_state() .\nThe input value can be a seed (integer), or a random number generator:"
        ],
        "Field List": {
            "Parameters:": {
                "random_state_argument : string or int": "The name of the argument or the index of the argument in args that is\nto be converted to the random.Random instance or numpy.random.RandomState\ninstance that mimics basic methods of random.Random."
            },
            "Returns:": {
                "_random_state : function": "Function whose random_state_argument is converted to a Random instance."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "Decorate functions like this:\n@py_random_state(\"random_state\")defrandom_float(random_state=None):returnrandom_state.rand()@py_random_state(0)defrandom_float(rng=None):returnrng.rand()@py_random_state(1)defrandom_array(dims,seed=12345):returnseed.rand(*dims)"
        }
    },
    {
        "Section ID": "NotATree",
        "Description": [],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "all_pairs_node_connectivity",
        "Description": [
            "Compute node connectivity between all pairs of nodes.",
            "Pairwise or local node connectivity between two distinct and nonadjacent\nnodes is the minimum number of nodes that must be removed (minimum\nseparating cutset) to disconnect them. By Menger\u2019s theorem, this is equal\nto the number of node independent paths (paths that share no nodes other\nthan source and target). Which is what we compute in this function.",
            "This algorithm is a fast approximation that gives an strict lower\nbound on the actual number of node independent paths between two nodes [1] .\nIt works for both directed and undirected graphs."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "nbunch: container": "Container of nodes. If provided node connectivity will be computed\nonly over pairs of nodes in nbunch.",
                "cutoff : integer": "Maximum node connectivity to consider. If None, the minimum degree\nof source or target is used as a cutoff in each pair of nodes.\nDefault value None."
            },
            "Returns:": {
                "K : dictionary": "Dictionary, keyed by source and target, of pairwise node connectivity"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]White, Douglas R., and Mark Newman. 2001 A Fast Algorithm for\nNode-Independent Paths. Santa Fe Institute Working Paper #01-07-035http://eclectic.ss.uci.edu/~drwhite/working.pdf",
            "Examples": "A 3 node cycle with one extra node attached has connectivity 2 between all\nnodes in the cycle and connectivity 1 between the extra node and the rest:\nG=nx.cycle_graph(3)\nG.add_edge(2,3)\nimportpprint# for nice dictionary formatting\npprint.pprint(nx.all_pairs_node_connectivity(G))\n# {0: {1: 2, 2: 2, 3: 1},\n#  1: {0: 2, 2: 2, 3: 1},\n#  2: {0: 2, 1: 2, 3: 1},\n#  3: {0: 1, 1: 1, 2: 1}}"
        }
    },
    {
        "Section ID": "google_matrix",
        "Description": [
            "Returns the Google matrix of the graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.  Undirected graphs will be converted to a directed\ngraph with two directed edges for each undirected edge.",
                "alpha : float": "The damping factor.",
                "personalization: dict, optional": "The \u201cpersonalization vector\u201d consisting of a dictionary with a\nkey some subset of graph nodes and personalization value each of those.\nAt least one personalization value must be non-zero.\nIf not specified, a nodes personalization value will be zero.\nBy default, a uniform distribution is used.",
                "nodelist : list, optional": "The rows and columns are ordered according to the nodes in nodelist.\nIf nodelist is None, then the ordering is produced by G.nodes().",
                "weight : key, optional": "Edge data key to use as weight.  If None weights are set to 1.",
                "dangling: dict, optional": "The outedges to be assigned to any \u201cdangling\u201d nodes, i.e., nodes without\nany outedges. The dict key is the node the outedge points to and the dict\nvalue is the weight of that outedge. By default, dangling nodes are given\noutedges according to the personalization vector (uniform if not\nspecified) This must be selected to result in an irreducible transition\nmatrix (see notes below). It may be common to have the dangling dict to\nbe the same as the personalization dict."
            },
            "Returns:": {
                "A : 2D NumPy ndarray": "Google matrix of the graph"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The array returned represents the transition matrix that describes the\nMarkov chain used in PageRank. For PageRank to converge to a unique\nsolution (i.e., a unique stationary distribution in a Markov chain), the\ntransition matrix must be irreducible. In other words, it must be that\nthere exists a path between every pair of nodes in the graph, or else there\nis the potential of \u201crank sinks.\u201d This implementation works with Multi(Di)Graphs. For multigraphs the\nweight between two nodes is set to be the sum of all edge weights\nbetween those nodes."
        }
    },
    {
        "Section ID": "min_edge_cover",
        "Description": [
            "Returns the min cardinality edge cover of the graph as a set of edges.",
            "A smallest edge cover can be found in polynomial time by finding\na maximum matching and extending it greedily so that all nodes\nare covered. This function follows that process. A maximum matching\nalgorithm can be specified for the first step of the algorithm.\nThe resulting set may return a set with one 2-tuple for each edge,\n(the usual case) or with both 2-tuples (u,v) and (v,u) for\neach edge. The latter is only done when a bipartite matching algorithm\nis specified as matching_algorithm ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "An undirected graph.",
                "matching_algorithm : function": "A function that returns a maximum cardinality matching forG.\nThe function must take one input, the graphG, and return\neither a set of edges (with only one direction for the pair of nodes)\nor a dictionary mapping each node to its mate. If not specified,max_weight_matching()is used.\nCommon bipartite matching functions includehopcroft_karp_matching()oreppstein_matching()."
            },
            "Returns:": {
                "min_cover : set": "A set of the edges in a minimum edge cover in the form of tuples.\nIt contains only one of the equivalent 2-tuples(u,v)and(v,u)for each edge. If a bipartite method is used to compute the matching,\nthe returned set contains both the 2-tuples(u,v)and(v,u)for each edge of a minimum edge cover."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "An edge cover of a graph is a set of edges such that every node of\nthe graph is incident to at least one edge of the set.\nThe minimum edge cover is an edge covering of smallest cardinality. Due to its implementation, the worst-case running time of this algorithm\nis bounded by the worst-case running time of the function matching_algorithm . Minimum edge cover for G can also be found using the min_edge_covering function in networkx.algorithms.bipartite.covering which is\nsimply this function with a default matching algorithm of hopcraft_karp_matching()",
            "Examples": "G=nx.Graph([(0,1),(0,2),(0,3),(1,2),(1,3)])\nsorted(nx.min_edge_cover(G))\n# [(2, 1), (3, 0)]"
        }
    },
    {
        "Section ID": "is_directed",
        "Description": [
            "Return True if graph is directed."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "bfs_successors",
        "Description": [
            "Returns an iterator of successors in breadth-first-search from source."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node": "Specify starting node for breadth-first search",
                "depth_limit : int, optional(default=len(G))": "Specify the maximum search depth",
                "sort_neighbors : function (default=None)": "A function that takes an iterator over nodes as the input, and\nreturns an iterable of the same nodes with a custom ordering.\nFor example,sortedwill sort the nodes in increasing order."
            },
            "Returns:": {
                "succ: iterator": "(node, successors) iterator wheresuccessorsis the non-empty list of\nsuccessors ofnodein a breadth first search fromsource.\nTo appear in the iterator,nodemust have successors."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Based on http://www.ics.uci.edu/~eppstein/PADS/BFS.py by D. Eppstein, July 2004.The modifications\nto allow depth limits based on the Wikipedia article\n\u201c Depth-limited-search \u201d.",
            "Examples": "G=nx.path_graph(3)\ndict(nx.bfs_successors(G,0))\n# {0: [1], 1: [2]}\nH=nx.Graph()\nH.add_edges_from([(0,1),(0,2),(1,3),(1,4),(2,5),(2,6)])\ndict(nx.bfs_successors(H,0))\n# {0: [1, 2], 1: [3, 4], 2: [5, 6]}\nG=nx.Graph()\nnx.add_path(G,[0,1,2,3,4,5,6])\nnx.add_path(G,[2,7,8,9,10])\ndict(nx.bfs_successors(G,source=1,depth_limit=3))\n# {1: [0, 2], 2: [3, 7], 3: [4], 7: [8]}\nG=nx.DiGraph()\nnx.add_path(G,[0,1,2,3,4,5])\ndict(nx.bfs_successors(G,source=3))\n# {3: [4], 4: [5]}"
        }
    },
    {
        "Section ID": "average_node_connectivity",
        "Description": [
            "Returns the average connectivity of a graph G.",
            "The average connectivity bar{kappa} of a graph G is the average\nof local node connectivity over all pairs of nodes of G [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected graph",
                "flow_func : function": "A function for computing the maximum flow among a pair of nodes.\nThe function has to accept at least three parameters: a Digraph,\na source node, and a target node. And return a residual network\nthat follows NetworkX conventions (seemaximum_flow()for\ndetails). If flow_func is None, the default maximum flow function\n(edmonds_karp()) is used. Seelocal_node_connectivity()for details. The choice of the default function may change from\nversion to version and should not be relied on. Default value: None."
            },
            "Returns:": {
                "K : float": "Average node connectivity"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Beineke, L., O. Oellermann, and R. Pippert (2002). The average\nconnectivity of a graph. Discrete mathematics 252(1-3), 31-45.http://www.sciencedirect.com/science/article/pii/S0012365X01001807"
        }
    },
    {
        "Section ID": "hexagonal_lattice_graph",
        "Description": [
            "Returns an m by n hexagonal lattice graph.",
            "The hexagonal lattice graph is a graph whose nodes and edges are\nthe hexagonal tiling of the plane.",
            "The returned graph will have m rows and n columns of hexagons. Odd numbered columns are shifted up relative to even numbered columns.",
            "Positions of nodes are computed by default or with_positionsisTrue .\nNode positions creating the standard embedding in the plane\nwith sidelength 1 and are stored in the node attribute \u2018pos\u2019. pos=nx.get_node_attributes(G,'pos') creates a dict ready for drawing."
        ],
        "Field List": {
            "Parameters:": {
                "m : int": "The number of rows of hexagons in the lattice.",
                "n : int": "The number of columns of hexagons in the lattice.",
                "periodic : bool": "Whether to make a periodic grid by joining the boundary vertices.\nFor this to worknmust be even and bothn>1andm>1.\nThe periodic connections create another row and column of hexagons\nso these graphs have fewer nodes as boundary nodes are identified.",
                "with_positions : bool (default: True)": "Store the coordinates of each node in the graph node attribute \u2018pos\u2019.\nThe coordinates provide a lattice with vertical columns of hexagons\noffset to interleave and cover the plane.\nPeriodic positions shift the nodes vertically in a nonlinear way so\nthe edges don\u2019t overlap so much.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated.\nIf graph is directed, edges will point up or right."
            },
            "Returns:": {
                "NetworkX graph": "Thembynhexagonal lattice graph."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "k_random_intersection_graph",
        "Description": [
            "Returns a intersection graph with randomly chosen attribute sets for\neach node that are of equal size (k)."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes in the first bipartite set (nodes)",
                "m : int": "The number of nodes in the second bipartite set (attributes)",
                "k : float": "Size of attribute set to assign to each node.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Godehardt, E., and Jaworski, J.\nTwo models of random intersection graphs and their applications.\nElectronic Notes in Discrete Mathematics 10 (2001), 129\u2013132."
        }
    },
    {
        "Section ID": "nodes",
        "Description": [
            "Returns a NodeView over the graph nodes.",
            "This function wraps the G.nodes property."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "subgraph_centrality_exp",
        "Description": [
            "Returns the subgraph centrality for each node of G.",
            "Subgraph centrality  of a node n is the sum of weighted closed\nwalks of all lengths starting and ending at node n . The weights\ndecrease with path length. Each closed walk is associated with a\nconnected subgraph ( [1] )."
        ],
        "Field List": {
            "Parameters:": {
                "G: graph": ""
            },
            "Returns:": {
                "nodes:dictionary": "Dictionary of nodes with subgraph centrality as the value."
            },
            "Raises:": {
                "NetworkXError": "If the graph is not undirected and simple."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This version of the algorithm exponentiates the adjacency matrix. The subgraph centrality of a node u in G can be found using\nthe matrix exponential of the adjacency matrix of G [1] ,",
            "References": "[1](1,2,3)Ernesto Estrada, Juan A. Rodriguez-Velazquez,\n\u201cSubgraph centrality in complex networks\u201d,\nPhysical Review E 71, 056103 (2005).https://arxiv.org/abs/cond-mat/0504730",
            "Examples": "(Example from[1])\n>>> G = nx.Graph(\n\u2026     [\n\u2026         (1, 2),\n\u2026         (1, 5),\n\u2026         (1, 8),\n\u2026         (2, 3),\n\u2026         (2, 8),\n\u2026         (3, 4),\n\u2026         (3, 6),\n\u2026         (4, 5),\n\u2026         (4, 7),\n\u2026         (5, 6),\n\u2026         (6, 7),\n\u2026         (7, 8),\n\u2026     ]\n\u2026 )\n>>> sc = nx.subgraph_centrality_exp(G)\n>>> print([f\u201d{node} {sc[node]:0.2f}\u201d for node in sorted(sc)])\n[\u20181 3.90\u2019, \u20182 3.90\u2019, \u20183 3.64\u2019, \u20184 3.71\u2019, \u20185 3.64\u2019, \u20186 3.71\u2019, \u20187 3.64\u2019, \u20188 3.90\u2019]"
        }
    },
    {
        "Section ID": "maximum_spanning_arborescence",
        "Description": [
            "Returns a maximum spanning arborescence from G."
        ],
        "Field List": {
            "Parameters:": {
                "G : (multi)digraph-like": "The graph to be searched.",
                "attr : str": "The edge attribute used to in determining optimality.",
                "default : float": "The value of the edge attribute used if an edge does not have\nthe attributeattr.",
                "preserve_attrs : bool": "If True, preserve the other attributes of the original graph (that are not\npassed toattr)",
                "partition : str": "The key for the edge attribute containing the partition\ndata on the graph. Edges can be included, excluded or open using theEdgePartitionenum."
            },
            "Returns:": {
                "B : (multi)digraph-like": "A maximum spanning arborescence."
            },
            "Raises:": {
                "NetworkXException": "If the graph does not contain a maximum spanning arborescence."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "laplacian_spectrum",
        "Description": [
            "Returns eigenvalues of the Laplacian of G"
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "weight : string or None, optional (default=\u2019weight\u2019)": "The edge data key used to compute each value in the matrix.\nIf None, then each edge has weight 1."
            },
            "Returns:": {
                "evals : NumPy array": "Eigenvalues"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For MultiGraph/MultiDiGraph, the edges weights are summed.\nSee to_numpy_array() for other options.",
            "Examples": "The multiplicity of 0 as an eigenvalue of the laplacian matrix is equal\nto the number of connected components of G.\nG=nx.Graph()# Create a graph with 5 nodes and 3 connected components\nG.add_nodes_from(range(5))\nG.add_edges_from([(0,2),(3,4)])\nnx.laplacian_spectrum(G)\n# array([0., 0., 0., 2., 2.])"
        }
    },
    {
        "Section ID": "edge_expansion",
        "Description": [
            "Returns the edge expansion between two node sets.",
            "The edge expansion is the quotient of the cut size and the smaller\nof the cardinalities of the two sets. [1]"
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "S : collection": "A collection of nodes inG.",
                "T : collection": "A collection of nodes inG.",
                "weight : object": "Edge attribute key to use as weight. If not specified, edges\nhave weight one."
            },
            "Returns:": {
                "number": "The edge expansion between the two setsSandT."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Fan Chung.Spectral Graph Theory.\n(CBMS Regional Conference Series in Mathematics, No. 92),\nAmerican Mathematical Society, 1997, ISBN 0-8218-0315-8\n<http://www.math.ucsd.edu/~fan/research/revised.html>"
        }
    },
    {
        "Section ID": "adjacency_data",
        "Description": [
            "Returns data in adjacency format that is suitable for JSON serialization\nand use in JavaScript documents."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "attrs : dict": "A dictionary that contains two keys \u2018id\u2019 and \u2018key\u2019. The corresponding\nvalues provide the attribute names for storing NetworkX-internal graph\ndata. The values should be unique. Default value:dict(id='id',key='key').If some user-defined graph data use these attribute names as data keys,\nthey may be silently dropped."
            },
            "Returns:": {
                "data : dict": "A dictionary with adjacency formatted data."
            },
            "Raises:": {
                "NetworkXError": "If values in attrs are not unique."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Graph, node, and link attributes will be written when using this format\nbut attribute keys must be strings if you want to serialize the resulting\ndata with JSON. The default value of attrs will be changed in a future release of NetworkX.",
            "Examples": "fromnetworkx.readwriteimportjson_graph\nG=nx.Graph([(1,2)])\ndata=json_graph.adjacency_data(G)\nTo serialize with json\nimportjson\ns=json.dumps(data)"
        }
    },
    {
        "Section ID": "max_flow_min_cost",
        "Description": [
            "Returns a maximum (s, t)-flow of minimum cost.",
            "G is a digraph with edge costs and capacities. There is a source\nnode s and a sink node t. This function finds a maximum flow from\ns to t whose total cost is minimized."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "DiGraph on which a minimum cost flow satisfying all demands is\nto be found.",
                "s: node label": "Source of the flow.",
                "t: node label": "Destination of the flow.",
                "capacity: string": "Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: \u2018capacity\u2019.",
                "weight: string": "Edges of the graph G are expected to have an attribute weight\nthat indicates the cost incurred by sending one unit of flow on\nthat edge. If not present, the weight is considered to be 0.\nDefault value: \u2018weight\u2019."
            },
            "Returns:": {
                "flowDict: dictionary": "Dictionary of dictionaries keyed by nodes such that\nflowDict[u][v] is the flow edge (u, v)."
            },
            "Raises:": {
                "NetworkXError": "This exception is raised if the input graph is not directed or\nnot connected.",
                "NetworkXUnbounded": "This exception is raised if there is an infinite capacity path\nfrom s to t in G. In this case there is no maximum flow. This\nexception is also raised if the digraph G has a cycle of\nnegative cost and infinite capacity. Then, the cost of a flow\nis unbounded below."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm is not guaranteed to work if edge weights or demands\nare floating point numbers (overflows and roundoff errors can\ncause problems). As a workaround you can use integer numbers by\nmultiplying the relevant edge attributes by a convenient\nconstant factor (eg 100).",
            "Examples": "G=nx.DiGraph()\nG.add_edges_from(\n[\n(1,2,{\"capacity\":12,\"weight\":4}),\n(1,3,{\"capacity\":20,\"weight\":6}),\n(2,3,{\"capacity\":6,\"weight\":-3}),\n(2,6,{\"capacity\":14,\"weight\":1}),\n(3,4,{\"weight\":9}),\n(3,5,{\"capacity\":10,\"weight\":5}),\n(4,2,{\"capacity\":19,\"weight\":13}),\n(4,5,{\"capacity\":4,\"weight\":0}),\n(5,7,{\"capacity\":28,\"weight\":2}),\n(6,5,{\"capacity\":11,\"weight\":1}),\n(6,7,{\"weight\":8}),\n(7,4,{\"capacity\":6,\"weight\":6}),\n]\n)\nmincostFlow=nx.max_flow_min_cost(G,1,7)\nmincost=nx.cost_of_flow(G,mincostFlow)\nmincost\n# 373\nfromnetworkx.algorithms.flowimportmaximum_flow\nmaxFlow=maximum_flow(G,1,7)[1]\nnx.cost_of_flow(G,maxFlow)>=mincost\n# True\nmincostFlowValue=sum((mincostFlow[u][7]foruinG.predecessors(7)))-sum(\n(mincostFlow[7][v]forvinG.successors(7))\n)\nmincostFlowValue==nx.maximum_flow_value(G,1,7)\n# True"
        }
    },
    {
        "Section ID": "node_connectivity",
        "Description": [
            "Returns node connectivity for a graph or digraph G.",
            "Node connectivity is equal to the minimum number of nodes that\nmust be removed to disconnect G or render it trivial. If source\nand target nodes are provided, this function returns the local node\nconnectivity: the minimum number of nodes that must be removed to break\nall paths from source to target in G."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected graph",
                "s : node": "Source node. Optional. Default value: None.",
                "t : node": "Target node. Optional. Default value: None.",
                "flow_func : function": "A function for computing the maximum flow among a pair of nodes.\nThe function has to accept at least three parameters: a Digraph,\na source node, and a target node. And return a residual network\nthat follows NetworkX conventions (seemaximum_flow()for\ndetails). If flow_func is None, the default maximum flow function\n(edmonds_karp()) is used. See below for details. The\nchoice of the default function may change from version\nto version and should not be relied on. Default value: None."
            },
            "Returns:": {
                "K : integer": "Node connectivity of G, or local node connectivity if source\nand target are provided."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This is a flow based implementation of node connectivity. The\nalgorithm works by solving \\(O((n-\\delta-1+\\delta(\\delta-1)/2))\\) maximum flow problems on an auxiliary digraph. Where \\(\\delta\\) is the minimum degree of G. For details about the auxiliary\ndigraph and the computation of local node connectivity see local_node_connectivity() . This implementation is based\non algorithm 11 in [1] .",
            "References": "[1]Abdol-Hossein Esfahanian. Connectivity Algorithms.http://www.cse.msu.edu/~cse835/Papers/Graph_connectivity_revised.pdf",
            "Examples": "# Platonic icosahedral graph is 5-node-connected\nG=nx.icosahedral_graph()\nnx.node_connectivity(G)\n# 5\nYou can use alternative flow algorithms for the underlying maximum\nflow computation. In dense networks the algorithmshortest_augmenting_path()will usually perform better\nthan the defaultedmonds_karp(), which is faster for\nsparse networks with highly skewed degree distributions. Alternative\nflow functions have to be explicitly imported from the flow package.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\nnx.node_connectivity(G,flow_func=shortest_augmenting_path)\n# 5\nIf you specify a pair of nodes (source and target) as parameters,\nthis function returns the value of local node connectivity.\nnx.node_connectivity(G,3,7)\n# 5\nIf you need to perform several local computations among different\npairs of nodes on the same graph, it is recommended that you reuse\nthe data structures used in the maximum flow computations. Seelocal_node_connectivity()for details."
        }
    },
    {
        "Section ID": "hide_diedges",
        "Description": [
            "Returns a filter function that hides specific directed edges."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "in_degree_centrality",
        "Description": [
            "Compute the in-degree centrality for nodes.",
            "The in-degree centrality for a node v is the fraction of nodes its\nincoming edges are connected to."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph"
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of nodes with in-degree centrality as values."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The degree centrality values are normalized by dividing by the maximum\npossible degree in a simple graph n-1 where n is the number of nodes in G. For multigraphs or graphs with self loops the maximum degree might\nbe higher than n-1 and values of degree centrality greater than 1\nare possible.",
            "Examples": "G=nx.DiGraph([(0,1),(0,2),(0,3),(1,2),(1,3)])\nnx.in_degree_centrality(G)\n# {0: 0.0, 1: 0.3333333333333333, 2: 0.6666666666666666, 3: 0.6666666666666666}"
        }
    },
    {
        "Section ID": "is_at_free",
        "Description": [
            "Check if a graph is AT-free.",
            "The method uses the find_asteroidal_triple method to recognize\nan AT-free graph. If no asteroidal triple is found the graph is\nAT-free and True is returned. If at least one asteroidal triple is\nfound the graph is not AT-free and False is returned."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "The graph to check whether is AT-free or not."
            },
            "Returns:": {
                "bool": "True if G is AT-free and False otherwise."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph([(0,1),(0,2),(1,2),(1,3),(1,4),(4,5)])\nnx.is_at_free(G)\n# True\nG=nx.cycle_graph(6)\nnx.is_at_free(G)\n# False"
        }
    },
    {
        "Section ID": "strong_product",
        "Description": [
            "Returns the strong product of G and H.",
            "The strong product \\(P\\) of the graphs \\(G\\) and \\(H\\) has a node set that\nis the Cartesian product of the node sets, \\(V(P)=V(G) \\times V(H)\\) . \\(P\\) has an edge \\(((u,v), (x,y))\\) if and only if \\(u==v\\) and \\((x,y)\\) is an edge in \\(H\\) , or \\(x==y\\) and \\((u,v)\\) is an edge in \\(G\\) , or \\((u,v)\\) is an edge in \\(G\\) and \\((x,y)\\) is an edge in \\(H\\) ."
        ],
        "Field List": {
            "Parameters:": {
                "G, H: graphs": "Networkx graphs."
            },
            "Returns:": {
                "P: NetworkX graph": "The Cartesian product of G and H. P will be a multi-graph if either G\nor H is a multi-graph. Will be a directed if G and H are directed,\nand undirected if G and H are undirected."
            },
            "Raises:": {
                "NetworkXError": "If G and H are not both directed or both undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Node attributes in P are two-tuple of the G and H node attributes.\nMissing attributes are assigned None.",
            "Examples": "G=nx.Graph()\nH=nx.Graph()\nG.add_node(0,a1=True)\nH.add_node(\"a\",a2=\"Spam\")\nP=nx.strong_product(G,H)\nlist(P)\n# [(0, 'a')]\nEdge attributes and edge keys (for multigraphs) are also copied to the\nnew product graph"
        }
    },
    {
        "Section ID": "current_flow_betweenness_centrality",
        "Description": [
            "Compute current-flow betweenness centrality for nodes.",
            "Current-flow betweenness centrality uses an electrical current\nmodel for information spreading in contrast to betweenness\ncentrality which uses shortest paths.",
            "Current-flow betweenness centrality is also known as\nrandom-walk betweenness centrality [2] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "normalized : bool, optional (default=True)": "If True the betweenness values are normalized by 2/[(n-1)(n-2)] where\nn is the number of nodes in G.",
                "weight : string or None, optional (default=None)": "Key for edge data used as the edge weight.\nIf None, then use 1 as each edge weight.\nThe weight reflects the capacity or the strength of the\nedge.",
                "dtype : data type (float)": "Default data type for internal matrices.\nSet to np.float32 for lower memory consumption.",
                "solver : string (default=\u2019full\u2019)": "Type of linear solver to use for computing the flow matrix.\nOptions are \u201cfull\u201d (uses most memory), \u201clu\u201d (recommended), and\n\u201ccg\u201d (uses least memory)."
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of nodes with betweenness centrality as the value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Current-flow betweenness can be computed in \\(O(I(n-1)+mn \\log n)\\) time [1] , where \\(I(n-1)\\) is the time needed to compute the\ninverse Laplacian.  For a full matrix this is \\(O(n^3)\\) but using\nsparse methods you can achieve \\(O(nm{\\sqrt k})\\) where \\(k\\) is the\nLaplacian matrix condition number. The space required is \\(O(nw)\\) where \\(w\\) is the width of the sparse\nLaplacian matrix.  Worse case is \\(w=n\\) for \\(O(n^2)\\) . If the edges have a \u2018weight\u2019 attribute they will be used as\nweights in this algorithm.  Unspecified weights are set to 1.",
            "References": "[1]Centrality Measures Based on Current Flow.\nUlrik Brandes and Daniel Fleischer,\nProc. 22nd Symp. Theoretical Aspects of Computer Science (STACS \u201805).\nLNCS 3404, pp. 533-544. Springer-Verlag, 2005.https://doi.org/10.1007/978-3-540-31856-9_44  [2]A measure of betweenness centrality based on random walks,\nM. E. J. Newman, Social Networks 27, 39-54 (2005)."
        }
    },
    {
        "Section ID": "nodes_with_selfloops",
        "Description": [
            "Returns an iterator over nodes with self loops.",
            "A node with a self loop has an edge with both ends adjacent\nto that node."
        ],
        "Field List": {
            "Returns:": {
                "nodelist : iterator": "A iterator over nodes with self loops."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_edge(1,1)\nG.add_edge(1,2)\nlist(nx.nodes_with_selfloops(G))\n# [1]"
        }
    },
    {
        "Section ID": "from_nested_tuple",
        "Description": [
            "Returns the rooted tree corresponding to the given nested tuple.",
            "The nested tuple representation of a tree is defined\nrecursively. The tree with one node and no edges is represented by\nthe empty tuple, () . A tree with k subtrees is represented\nby a tuple of length k in which each element is the nested tuple\nrepresentation of a subtree."
        ],
        "Field List": {
            "Parameters:": {
                "sequence : tuple": "A nested tuple representing a rooted tree.",
                "sensible_relabeling : bool": "Whether to relabel the nodes of the tree so that nodes are\nlabeled in increasing order according to their breadth-first\nsearch order from the root node."
            },
            "Returns:": {
                "NetworkX graph": "The tree corresponding to the given nested tuple, whose root\nnode is node 0. Ifsensible_labelingisTrue, nodes will\nbe labeled in breadth-first search order starting from the root\nnode."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This function is not the inverse of to_nested_tuple() ; the\nonly guarantee is that the rooted trees are isomorphic.",
            "Examples": "Sensible relabeling ensures that the nodes are labeled from the root\nstarting at 0:\nbalanced=(((),()),((),()))\nT=nx.from_nested_tuple(balanced,sensible_relabeling=True)\nedges=[(0,1),(0,2),(1,3),(1,4),(2,5),(2,6)]\nall((u,v)inT.edges()or(v,u)inT.edges()for(u,v)inedges)\n# True"
        }
    },
    {
        "Section ID": "frucht_graph",
        "Description": [
            "Returns the Frucht Graph.",
            "The Frucht Graph is the smallest cubical graph whose\nautomorphism group consists only of the identity element [1] .\nIt has 12 nodes and 18 edges and no nontrivial symmetries.\nIt is planar and Hamiltonian [2] ."
        ],
        "Field List": {
            "Parameters:": {
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : networkx Graph": "Frucht Graph with 12 nodes and 18 edges"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://en.wikipedia.org/wiki/Frucht_graph  [2]https://mathworld.wolfram.com/FruchtGraph.html"
        }
    },
    {
        "Section ID": "from_scipy_sparse_array",
        "Description": [
            "Creates a new graph from an adjacency matrix given as a SciPy sparse\narray."
        ],
        "Field List": {
            "Parameters:": {
                "A: scipy.sparse array": "An adjacency matrix representation of a graph",
                "parallel_edges : Boolean": "If this is True,create_usingis a multigraph, andAis an\ninteger matrix, then entry(i, j)in the matrix is interpreted as the\nnumber of parallel edges joining verticesiandjin the graph.\nIf it is False, then the entries in the matrix are interpreted as\nthe weight of a single edge joining the vertices.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated.",
                "edge_attribute: string": "Name of edge attribute to store matrix numeric value. The data will\nhave the same type as the matrix entry (int, float, (real,imag))."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For directed graphs, explicitly mention create_using=nx.DiGraph,\nand entry i,j of A corresponds to an edge from i to j. If create_using is networkx.MultiGraph or networkx.MultiDiGraph , parallel_edges is True, and the\nentries of A are of type int , then this function returns a\nmultigraph (constructed from create_using ) with parallel edges.\nIn this case, edge_attribute will be ignored. If create_using indicates an undirected multigraph, then only the edges\nindicated by the upper triangle of the matrix A will be added to the\ngraph.",
            "Examples": "importscipyassp\nA=sp.sparse.eye(2,2,1)\nG=nx.from_scipy_sparse_array(A)\nIfcreate_usingindicates a multigraph and the matrix has only integer\nentries andparallel_edgesis False, then the entries will be treated\nas weights for edges joining the nodes (without creating parallel edges):\nA=sp.sparse.csr_array([[1,1],[1,2]])\nG=nx.from_scipy_sparse_array(A,create_using=nx.MultiGraph)\nG[1][1]\n# AtlasView({0: {'weight': 2}})\nIfcreate_usingindicates a multigraph and the matrix has only integer\nentries andparallel_edgesis True, then the entries will be treated\nas the number of parallel edges joining those two vertices:\nA=sp.sparse.csr_array([[1,1],[1,2]])\nG=nx.from_scipy_sparse_array(A,parallel_edges=True,create_using=nx.MultiGraph)\nG[1][1]\n# AtlasView({0: {'weight': 1}, 1: {'weight': 1}})"
        }
    },
    {
        "Section ID": "disjoint_union_all",
        "Description": [
            "Returns the disjoint union of all graphs.",
            "This operation forces distinct integer node labels starting with 0\nfor the first graph in the list and numbering consecutively."
        ],
        "Field List": {
            "Parameters:": {
                "graphs : iterable": "Iterable of NetworkX graphs"
            },
            "Returns:": {
                "U : A graph with the same type as the first graph in list": ""
            },
            "Raises:": {
                "ValueError": "Ifgraphsis an empty list.",
                "NetworkXError": "In case of mixed type graphs, like MultiGraph and Graph, or directed and undirected graphs."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For operating on mixed type graphs, they should be converted to the same type. Graph, edge, and node attributes are propagated to the union graph.\nIf a graph attribute is present in multiple graphs, then the value\nfrom the last graph in the list with that attribute is used.",
            "Examples": "G1=nx.Graph([(1,2),(2,3)])\nG2=nx.Graph([(4,5),(5,6)])\nU=nx.disjoint_union_all([G1,G2])\nlist(U.nodes())\n# [0, 1, 2, 3, 4, 5]\nlist(U.edges())\n# [(0, 1), (1, 2), (3, 4), (4, 5)]"
        }
    },
    {
        "Section ID": "hide_nodes",
        "Description": [
            "Returns a filter function that hides specific nodes."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "cubical_graph",
        "Description": [
            "Returns the 3-regular Platonic Cubical Graph",
            "The skeleton of the cube (the nodes and edges) form a graph, with 8\nnodes, and 12 edges. It is a special case of the hypercube graph.\nIt is one of 5 Platonic graphs, each a skeleton of its\nPlatonic solid [1] .\nSuch graphs arise in parallel processing in computers."
        ],
        "Field List": {
            "Parameters:": {
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : networkx Graph": "A cubical graph with 8 nodes and 12 edges"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://en.wikipedia.org/wiki/Cube#Cubical_graph"
        }
    },
    {
        "Section ID": "k_corona",
        "Description": [
            "Returns the k-corona of G.",
            "The k-corona is the subgraph of nodes in the k-core which have\nexactly k neighbors in the k-core."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A graph or directed graph",
                "k : int": "The order of the corona.",
                "core_number : dictionary, optional": "Precomputed core numbers for the graph G."
            },
            "Returns:": {
                "G : NetworkX graph": "The k-corona subgraph"
            },
            "Raises:": {
                "NetworkXNotImplemented": "The k-corona is not defined for multigraphs or graphs with self loops."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For directed graphs the node degree is defined to be the\nin-degree + out-degree. Graph, node, and edge attributes are copied to the subgraph.",
            "References": "[1]k -core (bootstrap) percolation on complex networks:\nCritical phenomena and nonlocal effects,\nA. V. Goltsev, S. N. Dorogovtsev, and J. F. F. Mendes,\nPhys. Rev. E 73, 056101 (2006)http://link.aps.org/doi/10.1103/PhysRevE.73.056101",
            "Examples": "degrees=[0,1,2,2,2,2,3]\nH=nx.havel_hakimi_graph(degrees)\nH.degree\n# DegreeView({0: 1, 1: 2, 2: 2, 3: 2, 4: 2, 5: 3, 6: 0})\nnx.k_corona(H,k=2).nodes\n# NodeView((1, 2, 3, 5))"
        }
    },
    {
        "Section ID": "all_triads",
        "Description": [
            "A generator of all possible triads in G."
        ],
        "Field List": {
            "Parameters:": {
                "G : digraph": "A NetworkX DiGraph"
            },
            "Returns:": {
                "all_triads : generator of DiGraphs": "Generator of triads (order-3 DiGraphs)"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.DiGraph([(1,2),(2,3),(3,1),(3,4),(4,1),(4,2)])\nfortriadinnx.all_triads(G):\nprint(triad.edges)\n# [(1, 2), (2, 3), (3, 1)]\n# [(1, 2), (4, 1), (4, 2)]\n# [(3, 1), (3, 4), (4, 1)]\n# [(2, 3), (3, 4), (4, 2)]"
        }
    },
    {
        "Section ID": "average_degree_connectivity",
        "Description": [
            "Compute the average degree connectivity of graph.",
            "The average degree connectivity is the average nearest neighbor degree of\nnodes with degree k. For weighted graphs, an analogous measure can\nbe computed using the weighted average neighbors degree defined in [1] , for a node i , as",
            "where s_i is the weighted degree of node i , w_{ij} is the weight of the edge that links i and j ,\nand N(i) are the neighbors of node i ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : \u201cin\u201d|\u201dout\u201d|\u201din+out\u201d (default:\u201din+out\u201d)": "Directed graphs only. Use \u201cin\u201d- or \u201cout\u201d-degree for source node.",
                "target : \u201cin\u201d|\u201dout\u201d|\u201din+out\u201d (default:\u201din+out\u201d": "Directed graphs only. Use \u201cin\u201d- or \u201cout\u201d-degree for target node.",
                "nodes : list or iterable (optional)": "Compute neighbor connectivity for these nodes. The default is all\nnodes.",
                "weight : string or None, optional (default=None)": "The edge attribute that holds the numerical value used as a weight.\nIf None, then each edge has weight 1."
            },
            "Returns:": {
                "d : dict": "A dictionary keyed by degree k with the value of average connectivity."
            },
            "Raises:": {
                "NetworkXError": "If eithersourceortargetare not one of \u2018in\u2019,\n\u2018out\u2019, or \u2018in+out\u2019.\nIf eithersourceortargetis passed for an undirected graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]A. Barrat, M. Barth\u00e9lemy, R. Pastor-Satorras, and A. Vespignani,\n\u201cThe architecture of complex weighted networks\u201d.\nPNAS 101 (11): 3747\u20133752 (2004).",
            "Examples": "G=nx.path_graph(4)\nG.edges[1,2][\"weight\"]=3\nnx.average_degree_connectivity(G)\n# {1: 2.0, 2: 1.5}\nnx.average_degree_connectivity(G,weight=\"weight\")\n# {1: 2.0, 2: 1.75}"
        }
    },
    {
        "Section ID": "reverse",
        "Description": [
            "Returns the reverse directed graph of G."
        ],
        "Field List": {
            "Parameters:": {
                "G : directed graph": "A NetworkX directed graph",
                "copy : bool": "If True, then a new graph is returned. If False, then the graph is\nreversed in place."
            },
            "Returns:": {
                "H : directed graph": "The reversed G."
            },
            "Raises:": {
                "NetworkXError": "If graph is undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.DiGraph([(1,2),(1,3),(2,3),(3,4),(3,5)])\nG_reversed=nx.reverse(G)\nG_reversed.edges()\n# OutEdgeView([(2, 1), (3, 1), (3, 2), (4, 3), (5, 3)])"
        }
    },
    {
        "Section ID": "average_neighbor_degree",
        "Description": [
            "Returns the average degree of the neighborhood of each node.",
            "In an undirected graph, the neighborhood N(i) of node i contains the\nnodes that are connected to i by an edge.",
            "For directed graphs, N(i) is defined according to the parameter source :",
            "The average neighborhood degree of a node i is",
            "where N(i) are the neighbors of node i and k_j is\nthe degree of node j which belongs to N(i) . For weighted\ngraphs, an analogous measure can be defined [1] ,",
            "where s_i is the weighted degree of node i , w_{ij} is the weight of the edge that links i and j and N(i) are the neighbors of node i ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : string (\u201cin\u201d|\u201dout\u201d|\u201din+out\u201d), optional (default=\u201dout\u201d)": "Directed graphs only.\nUse \u201cin\u201d- or \u201cout\u201d-neighbors of source node.",
                "target : string (\u201cin\u201d|\u201dout\u201d|\u201din+out\u201d), optional (default=\u201dout\u201d)": "Directed graphs only.\nUse \u201cin\u201d- or \u201cout\u201d-degree for target node.",
                "nodes : list or iterable, optional (default=G.nodes)": "Compute neighbor degree only for specified nodes.",
                "weight : string or None, optional (default=None)": "The edge attribute that holds the numerical value used as a weight.\nIf None, then each edge has weight 1."
            },
            "Returns:": {
                "d: dict": "A dictionary keyed by node to the average degree of its neighbors."
            },
            "Raises:": {
                "NetworkXError": "If eithersourceortargetare not one of \u2018in\u2019, \u2018out\u2019, or \u2018in+out\u2019.\nIf eithersourceortargetis passed for an undirected graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]A. Barrat, M. Barth\u00e9lemy, R. Pastor-Satorras, and A. Vespignani,\n\u201cThe architecture of complex weighted networks\u201d.\nPNAS 101 (11): 3747\u20133752 (2004).",
            "Examples": "G=nx.path_graph(4)\nG.edges[0,1][\"weight\"]=5\nG.edges[2,3][\"weight\"]=3\nnx.average_neighbor_degree(G)\n# {0: 2.0, 1: 1.5, 2: 1.5, 3: 2.0}\nnx.average_neighbor_degree(G,weight=\"weight\")\n# {0: 2.0, 1: 1.1666666666666667, 2: 1.25, 3: 2.0}\nG=nx.DiGraph()\nnx.add_path(G,[0,1,2,3])\nnx.average_neighbor_degree(G,source=\"in\",target=\"in\")\n# {0: 0.0, 1: 0.0, 2: 1.0, 3: 1.0}\nnx.average_neighbor_degree(G,source=\"out\",target=\"out\")\n# {0: 1.0, 1: 1.0, 2: 0.0, 3: 0.0}"
        }
    },
    {
        "Section ID": "weakly_connected_components",
        "Description": [
            "Generate weakly connected components of G."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A directed graph"
            },
            "Returns:": {
                "comp : generator of sets": "A generator of sets of nodes, one for each weakly connected\ncomponent of G."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For directed graphs only.",
            "Examples": "Generate a sorted list of weakly connected components, largest first.\nG=nx.path_graph(4,create_using=nx.DiGraph())\nnx.add_path(G,[10,11,12])\n[len(c)forcinsorted(nx.weakly_connected_components(G),key=len,reverse=True)]\n# [4, 3]\nIf you only want the largest component, it\u2019s more efficient to\nuse max instead of sort:\nlargest_cc=max(nx.weakly_connected_components(G),key=len)"
        }
    },
    {
        "Section ID": "degree_sequence_tree",
        "Description": [
            "Make a tree for the given degree sequence.",
            "A tree has #nodes-#edges=1 so\nthe degree sequence must have\nlen(deg_sequence)-sum(deg_sequence)/2=1"
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "contracted_nodes",
        "Description": [
            "Returns the graph that results from contracting u and v .",
            "Node contraction identifies the two nodes as a single node incident to any\nedge that was incident to the original two nodes."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "The graph whose nodes will be contracted.",
                "u, v : nodes": "Must be nodes inG.",
                "self_loops : Boolean": "If this is True, any edges joininguandvinGbecome\nself-loops on the new node in the returned graph.",
                "copy : Boolean": "If this is True (default True), make a copy ofGand return that instead of directly changingG."
            },
            "Returns:": {
                "Networkx graph": "If Copy is True,\nA new graph object of the same type asG(leavingGunmodified)\nwithuandvidentified in a single node. The right nodevwill be merged into the nodeu, so onlyuwill appear in the\nreturned graph.\nIf copy is False,\nModifiesGwithuandvidentified in a single node.\nThe right nodevwill be merged into the nodeu, so\nonlyuwill appear in the returned graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For multigraphs, the edge keys for the realigned edges may\nnot be the same as the edge keys for the old edges. This is\nnatural because edge keys are unique only within each pair of nodes. For non-multigraphs where u and v are adjacent to a third node w , the edge ( v , w ) will be contracted into the edge ( u , w ) with its attributes stored into a \u201ccontraction\u201d attribute. This function is also available as identified_nodes .",
            "Examples": "Contracting two nonadjacent nodes of the cycle graph on four nodesC_4yields the path graph (ignoring parallel edges):\nG=nx.cycle_graph(4)\nM=nx.contracted_nodes(G,1,3)\nP3=nx.path_graph(3)\nnx.is_isomorphic(M,P3)\n# True\nG=nx.MultiGraph(P3)\nM=nx.contracted_nodes(G,0,2)\nM.edges\n# MultiEdgeView([(0, 1, 0), (0, 1, 1)])\nG=nx.Graph([(1,2),(2,2)])\nH=nx.contracted_nodes(G,1,2,self_loops=False)\nlist(H.nodes())\n# [1]\nlist(H.edges())\n# [(1, 1)]\nIn aMultiDiGraphwith a self loop, the in and out edges will\nbe treated separately as edges, so while contracting a node which\nhas a self loop the contraction will add multiple edges:\nG=nx.MultiDiGraph([(1,2),(2,2)])\nH=nx.contracted_nodes(G,1,2)\nlist(H.edges())# edge 1->2, 2->2, 2<-2 from the original Graph G\n# [(1, 1), (1, 1), (1, 1)]\nH=nx.contracted_nodes(G,1,2,self_loops=False)\nlist(H.edges())# edge 2->2, 2<-2 from the original Graph G\n# [(1, 1), (1, 1)]"
        }
    },
    {
        "Section ID": "is_isolate",
        "Description": [
            "Determines whether a node is an isolate.",
            "An isolate is a node with no neighbors (that is, with degree\nzero). For directed graphs, this means no in-neighbors and no\nout-neighbors."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "n : node": "A node inG."
            },
            "Returns:": {
                "is_isolate : bool": "True if and only ifnhas no neighbors."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph()\nG.add_edge(1,2)\nG.add_node(3)\nnx.is_isolate(G,2)\n# False\nnx.is_isolate(G,3)\n# True"
        }
    },
    {
        "Section ID": "transitive_reduction",
        "Description": [
            "Returns transitive reduction of a directed graph",
            "The transitive reduction of G = (V,E) is a graph G- = (V,E-) such that\nfor all v,w in V there is an edge (v,w) in E- if and only if (v,w) is\nin E and there is no path from v to w in G with length greater than 1."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX DiGraph": "A directed acyclic graph (DAG)"
            },
            "Returns:": {
                "NetworkX DiGraph": "The transitive reduction ofG"
            },
            "Raises:": {
                "NetworkXError": "IfGis not a directed acyclic graph (DAG) transitive reduction is\nnot uniquely defined and aNetworkXErrorexception is raised."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "https://en.wikipedia.org/wiki/Transitive_reduction",
            "Examples": "To perform transitive reduction on a DiGraph:\nDG=nx.DiGraph([(1,2),(2,3),(1,3)])\nTR=nx.transitive_reduction(DG)\nlist(TR.edges)\n# [(1, 2), (2, 3)]\nTo avoid unnecessary data copies, this implementation does not return a\nDiGraph with node/edge data.\nTo perform transitive reduction on a DiGraph and transfer node/edge data:\nDG=nx.DiGraph()\nDG.add_edges_from([(1,2),(2,3),(1,3)],color=\"red\")\nTR=nx.transitive_reduction(DG)\nTR.add_nodes_from(DG.nodes(data=True))\nTR.add_edges_from((u,v,DG.edges[u,v])foru,vinTR.edges)\nlist(TR.edges(data=True))\n# [(1, 2, {'color': 'red'}), (2, 3, {'color': 'red'})]"
        }
    },
    {
        "Section ID": "write_multiline_adjlist",
        "Description": [
            "Write the graph G in multiline adjacency list format to path"
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "path : string or file": "Filename or file handle to write to.\nFilenames ending in .gz or .bz2 will be compressed.",
                "comments : string, optional": "Marker for comment lines",
                "delimiter : string, optional": "Separator for node labels",
                "encoding : string, optional": "Text encoding."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.path_graph(4)\nnx.write_multiline_adjlist(G,\"test.adjlist\")\nThe path can be a file handle or a string with the name of the file. If a\nfile handle is provided, it has to be opened in \u2018wb\u2019 mode.\nfh=open(\"test.adjlist\",\"wb\")\nnx.write_multiline_adjlist(G,fh)\nFilenames ending in .gz or .bz2 will be compressed.\nnx.write_multiline_adjlist(G,\"test.adjlist.gz\")"
        }
    },
    {
        "Section ID": "optimal_edit_paths",
        "Description": [
            "Returns all minimum-cost edit paths transforming G1 to G2.",
            "Graph edit path is a sequence of node and edge edit operations\ntransforming graph G1 to graph isomorphic to G2.  Edit operations\ninclude substitutions, deletions, and insertions."
        ],
        "Field List": {
            "Parameters:": {
                "G1, G2: graphs": "The two graphs G1 and G2 must be of the same type.",
                "node_match : callable": "A function that returns True if node n1 in G1 and n2 in G2\nshould be considered equal during matching.The function will be called likenode_match(G1.nodes[n1], G2.nodes[n2]).That is, the function will receive the node attribute\ndictionaries for n1 and n2 as inputs.Ignored if node_subst_cost is specified.  If neither\nnode_match nor node_subst_cost are specified then node\nattributes are not considered.",
                "edge_match : callable": "A function that returns True if the edge attribute dictionaries\nfor the pair of nodes (u1, v1) in G1 and (u2, v2) in G2 should\nbe considered equal during matching.The function will be called likeedge_match(G1[u1][v1], G2[u2][v2]).That is, the function will receive the edge attribute\ndictionaries of the edges under consideration.Ignored if edge_subst_cost is specified.  If neither\nedge_match nor edge_subst_cost are specified then edge\nattributes are not considered.",
                "node_subst_cost, node_del_cost, node_ins_cost : callable": "Functions that return the costs of node substitution, node\ndeletion, and node insertion, respectively.The functions will be called likenode_subst_cost(G1.nodes[n1], G2.nodes[n2]),\nnode_del_cost(G1.nodes[n1]),\nnode_ins_cost(G2.nodes[n2]).That is, the functions will receive the node attribute\ndictionaries as inputs.  The functions are expected to return\npositive numeric values.Function node_subst_cost overrides node_match if specified.\nIf neither node_match nor node_subst_cost are specified then\ndefault node substitution cost of 0 is used (node attributes\nare not considered during matching).If node_del_cost is not specified then default node deletion\ncost of 1 is used.  If node_ins_cost is not specified then\ndefault node insertion cost of 1 is used.",
                "edge_subst_cost, edge_del_cost, edge_ins_cost : callable": "Functions that return the costs of edge substitution, edge\ndeletion, and edge insertion, respectively.The functions will be called likeedge_subst_cost(G1[u1][v1], G2[u2][v2]),\nedge_del_cost(G1[u1][v1]),\nedge_ins_cost(G2[u2][v2]).That is, the functions will receive the edge attribute\ndictionaries as inputs.  The functions are expected to return\npositive numeric values.Function edge_subst_cost overrides edge_match if specified.\nIf neither edge_match nor edge_subst_cost are specified then\ndefault edge substitution cost of 0 is used (edge attributes\nare not considered during matching).If edge_del_cost is not specified then default edge deletion\ncost of 1 is used.  If edge_ins_cost is not specified then\ndefault edge insertion cost of 1 is used.",
                "upper_bound : numeric": "Maximum edit distance to consider."
            },
            "Returns:": {
                "edit_paths : list of tuples (node_edit_path, edge_edit_path)": "node_edit_path : list of tuples (u, v)\nedge_edit_path : list of tuples ((u1, v1), (u2, v2))",
                "cost : numeric": "Optimal edit path cost (graph edit distance). When the cost\nis zero, it indicates thatG1andG2are isomorphic."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "To transform G1 into a graph isomorphic to G2 , apply the node\nand edge edits in the returned edit_paths .\nIn the case of isomorphic graphs, the cost is zero, and the paths\nrepresent different isomorphic mappings (isomorphisms). That is, the\nedits involve renaming nodes and edges to match the structure of G2 .",
            "References": "[1]Zeina Abu-Aisheh, Romain Raveaux, Jean-Yves Ramel, Patrick\nMartineau. An Exact Graph Edit Distance Algorithm for Solving\nPattern Recognition Problems. 4th International Conference on\nPattern Recognition Applications and Methods 2015, Jan 2015,\nLisbon, Portugal. 2015,\n<10.5220/0005209202710278>. <hal-01168816>https://hal.archives-ouvertes.fr/hal-01168816",
            "Examples": "G1=nx.cycle_graph(4)\nG2=nx.wheel_graph(5)\npaths,cost=nx.optimal_edit_paths(G1,G2)\nlen(paths)\n# 40\ncost\n# 5.0"
        }
    },
    {
        "Section ID": "bellman_ford_path",
        "Description": [
            "Returns the shortest path from source to target in a weighted graph G."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node": "Starting node",
                "target : node": "Ending node",
                "weight : string or function (default=\u201dweight\u201d)": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number."
            },
            "Returns:": {
                "path : list": "List of nodes in a shortest path."
            },
            "Raises:": {
                "NodeNotFound": "Ifsourceis not inG.",
                "NetworkXNoPath": "If no path exists between source and target."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.",
            "Examples": "G=nx.path_graph(5)\nnx.bellman_ford_path(G,0,4)\n# [0, 1, 2, 3, 4]"
        }
    },
    {
        "Section ID": "dfs_preorder_nodes",
        "Description": [
            "Generate nodes in a depth-first-search pre-ordering starting at source."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node, optional": "Specify starting node for depth-first search and return nodes in\nthe component reachable from source.",
                "depth_limit : int, optional (default=len(G))": "Specify the maximum search depth.",
                "sort_neighbors : function (default=None)": "A function that takes an iterator over nodes as the input, and\nreturns an iterable of the same nodes with a custom ordering.\nFor example,sortedwill sort the nodes in increasing order."
            },
            "Returns:": {
                "nodes: generator": "A generator of nodes in a depth-first-search pre-ordering."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "If a source is not specified then a source is chosen arbitrarily and\nrepeatedly until all components in the graph are searched. The implementation of this function is adapted from David Eppstein\u2019s\ndepth-first search function in PADS , with modifications\nto allow depth limits based on the Wikipedia article\n\u201c Depth-limited search \u201d.",
            "Examples": "G=nx.path_graph(5)\nlist(nx.dfs_preorder_nodes(G,source=0))\n# [0, 1, 2, 3, 4]\nlist(nx.dfs_preorder_nodes(G,source=0,depth_limit=2))\n# [0, 1, 2]"
        }
    },
    {
        "Section ID": "voronoi_cells",
        "Description": [
            "Returns the Voronoi cells centered at center_nodes with respect\nto the shortest-path distance metric.",
            "If \\(C\\) is a set of nodes in the graph and \\(c\\) is an element of \\(C\\) ,\nthe Voronoi cell centered at a node \\(c\\) is the set of all nodes \\(v\\) that are closer to \\(c\\) than to any other center node in \\(C\\) with\nrespect to the shortest-path distance metric. [1]",
            "For directed graphs, this will compute the \u201coutward\u201d Voronoi cells,\nas defined in [1] , in which distance is measured from the center\nnodes to the target node. For the \u201cinward\u201d Voronoi cells, use the DiGraph.reverse() method to reverse the orientation of the\nedges before invoking this function on the directed graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "center_nodes : set": "A nonempty set of nodes in the graphGthat represent the\ncenter of the Voronoi cells.",
                "weight : string or function": "The edge attribute (or an arbitrary function) representing the\nweight of an edge. This keyword argument is as described in the\ndocumentation formulti_source_dijkstra_path(),\nfor example."
            },
            "Returns:": {
                "dictionary": "A mapping from center node to set of all nodes in the graph\ncloser to that center node than to any other center node. The\nkeys of the dictionary are the element ofcenter_nodes, and\nthe values of the dictionary form a partition of the nodes ofG."
            },
            "Raises:": {
                "ValueError": "Ifcenter_nodesis empty."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1](1,2)Erwig, Martin. (2000),\u201dThe graph Voronoi diagram with applications.\u201dNetworks, 36: 156\u2013163.https://doi.org/10.1002/1097-0037(200010)36:3<156::AID-NET2>3.0.CO;2-L",
            "Examples": "To get only the partition of the graph induced by the Voronoi cells,\ntake the collection of all values in the returned dictionary:\nG=nx.path_graph(6)\ncenter_nodes={0,3}\ncells=nx.voronoi_cells(G,center_nodes)\npartition=set(map(frozenset,cells.values()))\nsorted(map(sorted,partition))\n# [[0, 1], [2, 3, 4, 5]]"
        }
    },
    {
        "Section ID": "collaboration_weighted_projected_graph",
        "Description": [
            "Newman\u2019s weighted projection of B onto one of its node sets.",
            "The collaboration weighted projection is the projection of the\nbipartite network B onto the specified nodes with weights assigned\nusing Newman\u2019s collaboration model [1] :",
            "where u and v are nodes from the bottom bipartite node set,\nand k is a node of the top node set.\nThe value d_k is the degree of node k in the bipartite\nnetwork and delta_{u}^{k} is 1 if node u is\nlinked to node k in the original bipartite graph or 0 otherwise.",
            "The nodes retain their attributes and are connected in the resulting\ngraph if have an edge to a common node in the original bipartite\ngraph."
        ],
        "Field List": {
            "Parameters:": {
                "B : NetworkX graph": "The input graph should be bipartite.",
                "nodes : list or iterable": "Nodes to project onto (the \u201cbottom\u201d nodes)."
            },
            "Returns:": {
                "Graph : NetworkX graph": "A graph that is the projection onto the given nodes."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "No attempt is made to verify that the input graph B is bipartite.\nThe graph and node properties are (shallow) copied to the projected graph. See bipartitedocumentation for further details on how bipartite graphs are handled in NetworkX.",
            "References": "[1]Scientific collaboration networks: II.\nShortest paths, weighted networks, and centrality,\nM. E. J. Newman, Phys. Rev. E 64, 016132 (2001).",
            "Examples": "fromnetworkx.algorithmsimportbipartite\nB=nx.path_graph(5)\nB.add_edge(1,5)\nG=bipartite.collaboration_weighted_projected_graph(B,[0,2,4,5])\nlist(G)\n# [0, 2, 4, 5]\nforedgeinsorted(G.edges(data=True)):\nprint(edge)\n# (0, 2, {'weight': 0.5})\n# (0, 5, {'weight': 0.5})\n# (2, 4, {'weight': 1.0})\n# (2, 5, {'weight': 0.5})"
        }
    },
    {
        "Section ID": "information_centrality",
        "Description": [
            "Compute current-flow closeness centrality for nodes.",
            "Current-flow closeness centrality is variant of closeness\ncentrality based on effective resistance between nodes in\na network. This metric is also known as information centrality."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.",
                "weight : None or string, optional (default=None)": "If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight.\nThe weight reflects the capacity or the strength of the\nedge.",
                "dtype: data type (default=float)": "Default data type for internal matrices.\nSet to np.float32 for lower memory consumption.",
                "solver: string (default=\u2019lu\u2019)": "Type of linear solver to use for computing the flow matrix.\nOptions are \u201cfull\u201d (uses most memory), \u201clu\u201d (recommended), and\n\u201ccg\u201d (uses least memory)."
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of nodes with current flow closeness centrality as the value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The algorithm is from Brandes [1] . See also [2] for the original definition of information centrality.",
            "References": "[1]Ulrik Brandes and Daniel Fleischer,\nCentrality Measures Based on Current Flow.\nProc. 22nd Symp. Theoretical Aspects of Computer Science (STACS \u201805).\nLNCS 3404, pp. 533-544. Springer-Verlag, 2005.https://doi.org/10.1007/978-3-540-31856-9_44  [2]Karen Stephenson and Marvin Zelen:\nRethinking centrality: Methods and examples.\nSocial Networks 11(1):1-37, 1989.https://doi.org/10.1016/0378-8733(89)90016-6"
        }
    },
    {
        "Section ID": "minimum_cycle_basis",
        "Description": [
            "Returns a minimum weight cycle basis for G",
            "Minimum weight means a cycle basis for which the total weight\n(length for unweighted graphs) of all the cycles is minimum."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "",
                "weight: string": "name of the edge attribute to use for edge weights"
            },
            "Returns:": {
                "A list of cycle lists.  Each cycle list is a list of nodes": "",
                "which forms a cycle (loop) in G. Note that the nodes are not": "",
                "necessarily returned in a order by which they appear in the cycle": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph()\nnx.add_cycle(G,[0,1,2,3])\nnx.add_cycle(G,[0,3,4,5])\nnx.minimum_cycle_basis(G)\n# [[5, 4, 3, 0], [3, 2, 1, 0]]"
        }
    },
    {
        "Section ID": "k_core",
        "Description": [
            "Returns the k-core of G.",
            "A k-core is a maximal subgraph that contains nodes of degree k or more."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A graph or directed graph",
                "k : int, optional": "The order of the core. If not specified return the main core.",
                "core_number : dictionary, optional": "Precomputed core numbers for the graph G."
            },
            "Returns:": {
                "G : NetworkX graph": "The k-core subgraph"
            },
            "Raises:": {
                "NetworkXNotImplemented": "The k-core is not defined for multigraphs or graphs with self loops."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The main core is the core with k as the largest core_number. For directed graphs the node degree is defined to be the\nin-degree + out-degree. Graph, node, and edge attributes are copied to the subgraph.",
            "References": "[1]An O(m) Algorithm for Cores Decomposition of Networks\nVladimir Batagelj and Matjaz Zaversnik,  2003.https://arxiv.org/abs/cs.DS/0310049",
            "Examples": "degrees=[0,1,2,2,2,2,3]\nH=nx.havel_hakimi_graph(degrees)\nH.degree\n# DegreeView({0: 1, 1: 2, 2: 2, 3: 2, 4: 2, 5: 3, 6: 0})\nnx.k_core(H).nodes\n# NodeView((1, 2, 3, 5))"
        }
    },
    {
        "Section ID": "total_spanning_tree_weight",
        "Description": [
            "Returns the total weight of all spanning trees of G .",
            "Kirchoff\u2019s Tree Matrix Theorem [1] , [2] states that the determinant of any\ncofactor of the Laplacian matrix of a graph is the number of spanning trees\nin the graph. For a weighted Laplacian matrix, it is the sum across all\nspanning trees of the multiplicative weight of each tree. That is, the\nweight of each tree is the product of its edge weights.",
            "For unweighted graphs, the total weight equals the number of spanning trees in G .",
            "For directed graphs, the total weight follows by summing over all directed\nspanning trees in G that start in the root node [3] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "",
                "weight : string or None, optional (default=None)": "The key for the edge attribute holding the edge weight.\nIf None, then each edge has weight 1.",
                "root : node (only required for directed graphs)": "A node in the directed graphG."
            },
            "Returns:": {
                "total_weight : float": "Undirected graphs:The sum of the total multiplicative weights for all spanning trees inG.Directed graphs:The sum of the total multiplicative weights for all spanning trees ofG,\nrooted at noderoot.",
                "Undirected graphs:": "The sum of the total multiplicative weights for all spanning trees inG.",
                "Directed graphs:": "The sum of the total multiplicative weights for all spanning trees ofG,\nrooted at noderoot."
            },
            "Raises:": {
                "NetworkXPointlessConcept": "IfGdoes not contain any nodes.",
                "NetworkXError": "If the graphGis not (weakly) connected,\nor ifGis directed and the root node is not specified or not in G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Self-loops are excluded. Multi-edges are contracted in one edge\nequal to the sum of the weights.",
            "References": "[1]Wikipedia\n\u201cKirchhoff\u2019s theorem.\u201dhttps://en.wikipedia.org/wiki/Kirchhoff%27s_theorem  [2]Kirchhoff, G. R.\n\u00dcber die Aufl\u00f6sung der Gleichungen, auf welche man\nbei der Untersuchung der linearen Vertheilung\nGalvanischer Str\u00f6me gef\u00fchrt wird\nAnnalen der Physik und Chemie, vol. 72, pp. 497-508, 1847.  [3]Margoliash, J.\n\u201cMatrix-Tree Theorem for Directed Graphs\u201dhttps://www.math.uchicago.edu/~may/VIGRE/VIGRE2010/REUPapers/Margoliash.pdf",
            "Examples": "G=nx.complete_graph(5)\nround(nx.total_spanning_tree_weight(G))\n# 125\nG=nx.Graph()\nG.add_edge(1,2,weight=2)\nG.add_edge(1,3,weight=1)\nG.add_edge(2,3,weight=1)\nround(nx.total_spanning_tree_weight(G,\"weight\"))\n# 5"
        }
    },
    {
        "Section ID": "node_redundancy",
        "Description": [
            "Computes the node redundancy coefficients for the nodes in the bipartite\ngraph G .",
            "The redundancy coefficient of a node v is the fraction of pairs of\nneighbors of v that are both linked to other nodes. In a one-mode\nprojection these nodes would be linked together even if v were\nnot there.",
            "More formally, for any vertex v , the redundancy coefficient of `v` is\ndefined by",
            "where N(v) is the set of neighbors of v in G ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A bipartite graph",
                "nodes : list or iterable (optional)": "Compute redundancy for these nodes. The default is all nodes in G."
            },
            "Returns:": {
                "redundancy : dictionary": "A dictionary keyed by node with the node redundancy value."
            },
            "Raises:": {
                "NetworkXError": "If any of the nodes in the graph (or innodes, if specified) has\n(out-)degree less than two (which would result in division by zero,\naccording to the definition of the redundancy coefficient)."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Latapy, Matthieu, Cl\u00e9mence Magnien, and Nathalie Del Vecchio (2008).\nBasic notions for the analysis of large two-mode networks.\nSocial Networks 30(1), 31\u201348.",
            "Examples": "Compute the redundancy coefficient of each node in a graph:\nfromnetworkx.algorithmsimportbipartite\nG=nx.cycle_graph(4)\nrc=bipartite.node_redundancy(G)\nrc[0]\n# 1.0\nCompute the average redundancy for the graph:\nfromnetworkx.algorithmsimportbipartite\nG=nx.cycle_graph(4)\nrc=bipartite.node_redundancy(G)\nsum(rc.values())/len(G)\n# 1.0\nCompute the average redundancy for a set of nodes:\nfromnetworkx.algorithmsimportbipartite\nG=nx.cycle_graph(4)\nrc=bipartite.node_redundancy(G)\nnodes=[0,2]\nsum(rc[n]forninnodes)/len(nodes)\n# 1.0"
        }
    },
    {
        "Section ID": "compose_all",
        "Description": [
            "Returns the composition of all graphs.",
            "Composition is the simple union of the node sets and edge sets.\nThe node sets of the supplied graphs need not be disjoint."
        ],
        "Field List": {
            "Parameters:": {
                "graphs : iterable": "Iterable of NetworkX graphs"
            },
            "Returns:": {
                "C : A graph with the same type as the first graph in list": ""
            },
            "Raises:": {
                "ValueError": "Ifgraphsis an empty list.",
                "NetworkXError": "In case of mixed type graphs, like MultiGraph and Graph, or directed and undirected graphs."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For operating on mixed type graphs, they should be converted to the same type. Graph, edge, and node attributes are propagated to the union graph.\nIf a graph attribute is present in multiple graphs, then the value\nfrom the last graph in the list with that attribute is used.",
            "Examples": "G1=nx.Graph([(1,2),(2,3)])\nG2=nx.Graph([(3,4),(5,6)])\nC=nx.compose_all([G1,G2])\nlist(C.nodes())\n# [1, 2, 3, 4, 5, 6]\nlist(C.edges())\n# [(1, 2), (2, 3), (3, 4), (5, 6)]"
        }
    },
    {
        "Section ID": "maximum_independent_set",
        "Description": [
            "Returns an approximate maximum independent set.",
            "Independent set or stable set is a set of vertices in a graph, no two of\nwhich are adjacent. That is, it is a set I of vertices such that for every\ntwo vertices in I, there is no edge connecting the two. Equivalently, each\nedge in the graph has at most one endpoint in I. The size of an independent\nset is the number of vertices it contains [1] .",
            "A maximum independent set is a largest independent set for a given graph G\nand its size is denoted \\(\\alpha(G)\\) . The problem of finding such a set is called\nthe maximum independent set problem and is an NP-hard optimization problem.\nAs such, it is unlikely that there exists an efficient algorithm for finding\na maximum independent set of a graph.",
            "The Independent Set algorithm is based on [2] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected graph"
            },
            "Returns:": {
                "iset : Set": "The apx-maximum independent set"
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the graph is directed or is a multigraph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Finds the \\(O(|V|/(log|V|)^2)\\) apx of independent set in the worst case.",
            "References": "[1]Wikipedia: Independent set  [2]Boppana, R., & Halld\u00f3rsson, M. M. (1992).\nApproximating maximum independent sets by excluding subgraphs.\nBIT Numerical Mathematics, 32(2), 180\u2013196. Springer.",
            "Examples": "G=nx.path_graph(10)\nnx.approximation.maximum_independent_set(G)\n# {0, 2, 4, 6, 9}"
        }
    },
    {
        "Section ID": "read_dot",
        "Description": [
            "Returns a NetworkX graph from a dot file on path."
        ],
        "Field List": {
            "Parameters:": {
                "path : file or string": "File name or file handle to read."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "read_weighted_edgelist",
        "Description": [
            "Read a graph as list of edges with numeric weights."
        ],
        "Field List": {
            "Parameters:": {
                "path : file or string": "File or filename to read. If a file is provided, it must be\nopened in \u2018rb\u2019 mode.\nFilenames ending in .gz or .bz2 will be uncompressed.",
                "comments : string, optional": "The character used to indicate the start of a comment.",
                "delimiter : string, optional": "The string used to separate values.  The default is whitespace.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated.",
                "nodetype : int, float, str, Python type, optional": "Convert node data from strings to specified type",
                "encoding: string, optional": "Specify which encoding to use when reading file."
            },
            "Returns:": {
                "G : graph": "A networkx Graph or other type specified with create_using"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Since nodes must be hashable, the function nodetype must return hashable\ntypes (e.g. int, float, str, frozenset - or tuples of those, etc.) Example edgelist file format. With numeric edge data:"
        }
    },
    {
        "Section ID": "circular_ladder_graph",
        "Description": [
            "Returns the circular ladder graph \\(CL_n\\) of length n.",
            "\\(CL_n\\) consists of two concentric n-cycles in which\neach of the n pairs of concentric nodes are joined by an edge.",
            "Node labels are the integers 0 to n-1",
            "( Sourcecode , png )"
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "node_attribute_xy",
        "Description": [
            "Returns iterator of node-attribute pairs for all edges in G."
        ],
        "Field List": {
            "Parameters:": {
                "G: NetworkX graph": "",
                "attribute: key": "The node attribute key.",
                "nodes: list or iterable (optional)": "Use only edges that are incident to specified nodes.\nThe default is all nodes."
            },
            "Returns:": {
                "(x, y): 2-tuple": "Generates 2-tuple of (attribute, attribute) values."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For undirected graphs each edge is produced twice, once for each edge\nrepresentation (u, v) and (v, u), with the exception of self-loop edges\nwhich only appear once.",
            "Examples": "G=nx.DiGraph()\nG.add_node(1,color=\"red\")\nG.add_node(2,color=\"blue\")\nG.add_edge(1,2)\nlist(nx.node_attribute_xy(G,\"color\"))\n# [('red', 'blue')]"
        }
    },
    {
        "Section ID": "watts_strogatz_graph",
        "Description": [
            "Returns a Watts\u2013Strogatz small-world graph."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes",
                "k : int": "Each node is joined with itsknearest neighbors in a ring\ntopology.",
                "p : float": "The probability of rewiring each edge",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "First create a ring over \\(n\\) nodes [1] .  Then each node in the ring is joined\nto its \\(k\\) nearest neighbors (or \\(k - 1\\) neighbors if \\(k\\) is odd).\nThen shortcuts are created by replacing some edges as follows: for each\nedge \\((u, v)\\) in the underlying \u201c \\(n\\) -ring with \\(k\\) nearest neighbors\u201d\nwith probability \\(p\\) replace it with a new edge \\((u, w)\\) with uniformly\nrandom choice of existing node \\(w\\) . In contrast with newman_watts_strogatz_graph() , the random rewiring\ndoes not increase the number of edges. The rewired graph is not guaranteed\nto be connected as in connected_watts_strogatz_graph() .",
            "References": "[1]Duncan J. Watts and Steven H. Strogatz,\nCollective dynamics of small-world networks,\nNature, 393, pp. 440\u2013442, 1998."
        }
    },
    {
        "Section ID": "current_flow_betweenness_centrality_subset",
        "Description": [
            "Compute current-flow betweenness centrality for subsets of nodes.",
            "Current-flow betweenness centrality uses an electrical current\nmodel for information spreading in contrast to betweenness\ncentrality which uses shortest paths.",
            "Current-flow betweenness centrality is also known as\nrandom-walk betweenness centrality [2] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "sources: list of nodes": "Nodes to use as sources for current",
                "targets: list of nodes": "Nodes to use as sinks for current",
                "normalized : bool, optional (default=True)": "If True the betweenness values are normalized by b=b/(n-1)(n-2) where\nn is the number of nodes in G.",
                "weight : string or None, optional (default=None)": "Key for edge data used as the edge weight.\nIf None, then use 1 as each edge weight.\nThe weight reflects the capacity or the strength of the\nedge.",
                "dtype: data type (float)": "Default data type for internal matrices.\nSet to np.float32 for lower memory consumption.",
                "solver: string (default=\u2019lu\u2019)": "Type of linear solver to use for computing the flow matrix.\nOptions are \u201cfull\u201d (uses most memory), \u201clu\u201d (recommended), and\n\u201ccg\u201d (uses least memory)."
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of nodes with betweenness centrality as the value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Current-flow betweenness can be computed in \\(O(I(n-1)+mn \\log n)\\) time [1] , where \\(I(n-1)\\) is the time needed to compute the\ninverse Laplacian.  For a full matrix this is \\(O(n^3)\\) but using\nsparse methods you can achieve \\(O(nm{\\sqrt k})\\) where \\(k\\) is the\nLaplacian matrix condition number. The space required is \\(O(nw)\\) where \\(w\\) is the width of the sparse\nLaplacian matrix.  Worse case is \\(w=n\\) for \\(O(n^2)\\) . If the edges have a \u2018weight\u2019 attribute they will be used as\nweights in this algorithm.  Unspecified weights are set to 1.",
            "References": "[1]Centrality Measures Based on Current Flow.\nUlrik Brandes and Daniel Fleischer,\nProc. 22nd Symp. Theoretical Aspects of Computer Science (STACS \u201805).\nLNCS 3404, pp. 533-544. Springer-Verlag, 2005.https://doi.org/10.1007/978-3-540-31856-9_44  [2]A measure of betweenness centrality based on random walks,\nM. E. J. Newman, Social Networks 27, 39-54 (2005)."
        }
    },
    {
        "Section ID": "create_random_state",
        "Description": [
            "Returns a numpy.random.RandomState or numpy.random.Generator instance\ndepending on input."
        ],
        "Field List": {
            "Parameters:": {
                "random_state : int or NumPy RandomState or Generator instance, optional (default=None)": "If int, return a numpy.random.RandomState instance set with seed=int.\nifnumpy.random.RandomStateinstance, return it.\nifnumpy.random.Generatorinstance, return it.\nif None or numpy.random, return the global random number generator used\nby numpy.random."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "bfs_predecessors",
        "Description": [
            "Returns an iterator of predecessors in breadth-first-search from source."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node": "Specify starting node for breadth-first search",
                "depth_limit : int, optional(default=len(G))": "Specify the maximum search depth",
                "sort_neighbors : function (default=None)": "A function that takes an iterator over nodes as the input, and\nreturns an iterable of the same nodes with a custom ordering.\nFor example,sortedwill sort the nodes in increasing order."
            },
            "Returns:": {
                "pred: iterator": "(node, predecessor) iterator wherepredecessoris the predecessor ofnodein a breadth first search starting fromsource."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Based on http://www.ics.uci.edu/~eppstein/PADS/BFS.py by D. Eppstein, July 2004. The modifications\nto allow depth limits based on the Wikipedia article\n\u201c Depth-limited-search \u201d.",
            "Examples": "G=nx.path_graph(3)\ndict(nx.bfs_predecessors(G,0))\n# {1: 0, 2: 1}\nH=nx.Graph()\nH.add_edges_from([(0,1),(0,2),(1,3),(1,4),(2,5),(2,6)])\ndict(nx.bfs_predecessors(H,0))\n# {1: 0, 2: 0, 3: 1, 4: 1, 5: 2, 6: 2}\nM=nx.Graph()\nnx.add_path(M,[0,1,2,3,4,5,6])\nnx.add_path(M,[2,7,8,9,10])\nsorted(nx.bfs_predecessors(M,source=1,depth_limit=3))\n# [(0, 1), (2, 1), (3, 2), (4, 3), (7, 2), (8, 7)]\nN=nx.DiGraph()\nnx.add_path(N,[0,1,2,3,4,7])\nnx.add_path(N,[3,5,6,7])\nsorted(nx.bfs_predecessors(N,source=2))\n# [(3, 2), (4, 3), (5, 3), (6, 5), (7, 4)]"
        }
    },
    {
        "Section ID": "pydot_layout",
        "Description": [
            "Create node positions using pydot and Graphviz."
        ],
        "Field List": {
            "Parameters:": {
                "G : Graph": "NetworkX graph to be laid out.",
                "prog : string  (default: \u2018neato\u2019)": "Name of the GraphViz command to use for layout.\nOptions depend on GraphViz version but may include:\n\u2018dot\u2019, \u2018twopi\u2019, \u2018fdp\u2019, \u2018sfdp\u2019, \u2018circo\u2019",
                "root : Node from G or None (default: None)": "The node of G from which to start some layout algorithms."
            },
            "Returns:": {
                "dict": "Dictionary of positions keyed by node."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "If you use complex node objects, they may have the same string\nrepresentation and GraphViz could treat them as the same node.\nThe layout may assign both nodes a single location. See Issue #1568\nIf this occurs in your case, consider relabeling the nodes just\nfor the layout computation using something similar to:",
            "Examples": "G=nx.complete_graph(4)\npos=nx.nx_pydot.pydot_layout(G)\npos=nx.nx_pydot.pydot_layout(G,prog=\"dot\")"
        }
    },
    {
        "Section ID": "power",
        "Description": [
            "Returns the specified power of a graph.",
            "The \\(k`th power of a simple graph :math:`G\\) , denoted \\(G^k\\) , is a\ngraph on the same set of nodes in which two distinct nodes \\(u\\) and \\(v\\) are adjacent in \\(G^k\\) if and only if the shortest path\ndistance between \\(u\\) and \\(v\\) in \\(G\\) is at most \\(k\\) ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX simple graph object.",
                "k : positive integer": "The power to which to raise the graphG."
            },
            "Returns:": {
                "NetworkX simple graph": "Gto the powerk."
            },
            "Raises:": {
                "ValueError": "If the exponentkis not positive.",
                "NetworkXNotImplemented": "IfGis not a simple graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This definition of \u201cpower graph\u201d comes from Exercise 3.1.6 of Graph Theory by Bondy and Murty [1] .",
            "References": "[1]Bondy, U. S. R. Murty,Graph Theory. Springer, 2008.",
            "Examples": "The number of edges will never decrease when taking successive\npowers:\nG=nx.path_graph(4)\nlist(nx.power(G,2).edges)\n# [(0, 1), (0, 2), (1, 2), (1, 3), (2, 3)]\nlist(nx.power(G,3).edges)\n# [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]\nThekth power of a cycle graph onnnodes is the complete graph\nonnnodes, ifkis at leastn//2:\nG=nx.cycle_graph(5)\nH=nx.complete_graph(5)\nnx.is_isomorphic(nx.power(G,2),H)\n# True\nG=nx.cycle_graph(8)\nH=nx.complete_graph(8)\nnx.is_isomorphic(nx.power(G,4),H)\n# True"
        }
    },
    {
        "Section ID": "cuthill_mckee_ordering",
        "Description": [
            "Generate an ordering (permutation) of the graph nodes to make\na sparse matrix.",
            "Uses the Cuthill-McKee heuristic (based on breadth-first search) [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "heuristic : function, optional": "Function to choose starting node for RCM algorithm.  If None\na node from a pseudo-peripheral pair is used.  A user-defined function\ncan be supplied that takes a graph object and returns a single node."
            },
            "Returns:": {
                "nodes : generator": "Generator of nodes in Cuthill-McKee ordering."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The optimal solution the bandwidth reduction is NP-complete [2] .",
            "References": "[1]E. Cuthill and J. McKee.\nReducing the bandwidth of sparse symmetric matrices,\nIn Proc. 24th Nat. Conf. ACM, pages 157-172, 1969.http://doi.acm.org/10.1145/800195.805928  [2]Steven S. Skiena. 1997. The Algorithm Design Manual.\nSpringer-Verlag New York, Inc., New York, NY, USA.",
            "Examples": "fromnetworkx.utilsimportcuthill_mckee_ordering\nG=nx.path_graph(4)\nrcm=list(cuthill_mckee_ordering(G))\nA=nx.adjacency_matrix(G,nodelist=rcm)\nSmallest degree node as heuristic function:\ndefsmallest_degree(G):\nreturnmin(G,key=G.degree)\nrcm=list(cuthill_mckee_ordering(G,heuristic=smallest_degree))"
        }
    },
    {
        "Section ID": "expected_degree_graph",
        "Description": [
            "Returns a random graph with given expected degrees.",
            "Given a sequence of expected degrees \\(W=(w_0,w_1,\\ldots,w_{n-1})\\) of length \\(n\\) this algorithm assigns an edge between node \\(u\\) and\nnode \\(v\\) with probability"
        ],
        "Field List": {
            "Parameters:": {
                "w : list": "The list of expected degrees.",
                "selfloops: bool (default=True)": "Set to False to remove the possibility of self-loop edges.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "Graph": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The nodes have integer labels corresponding to index of expected degrees\ninput sequence. The complexity of this algorithm is \\(\\mathcal{O}(n+m)\\) where \\(n\\) is the\nnumber of nodes and \\(m\\) is the expected number of edges. The model in [1] includes the possibility of self-loop edges.\nSet selfloops=False to produce a graph without self loops. For finite graphs this model doesn\u2019t produce exactly the given\nexpected degree sequence.  Instead the expected degrees are as\nfollows. For the case without self loops (selfloops=False),",
            "References": "[1]Fan Chung and L. Lu, Connected components in random graphs with\ngiven expected degree sequences, Ann. Combinatorics, 6,\npp. 125-145, 2002.  [2]Joel Miller and Aric Hagberg,\nEfficient generation of networks with given expected degrees,\nin Algorithms and Models for the Web-Graph (WAW 2011),\nAlan Frieze, Paul Horn, and Pawe\u0142 Pra\u0142at (Eds), LNCS 6732,\npp. 115-126, 2011.",
            "Examples": "z=[10foriinrange(100)]\nG=nx.expected_degree_graph(z)"
        }
    },
    {
        "Section ID": "hamiltonian_path",
        "Description": [
            "Returns a Hamiltonian path in the given tournament graph.",
            "Each tournament has a Hamiltonian path. If furthermore, the\ntournament is strongly connected, then the returned Hamiltonian path\nis a Hamiltonian cycle (by joining the endpoints of the path)."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A directed graph representing a tournament."
            },
            "Returns:": {
                "path : list": "A list of nodes which form a Hamiltonian path inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This is a recursive implementation with an asymptotic running time\nof \\(O(n^2)\\) , ignoring multiplicative polylogarithmic factors, where \\(n\\) is the number of nodes in the graph.",
            "Examples": "G=nx.DiGraph([(0,1),(0,2),(0,3),(1,2),(1,3),(2,3)])\nnx.is_tournament(G)\n# True\nnx.tournament.hamiltonian_path(G)\n# [0, 1, 2, 3]"
        }
    },
    {
        "Section ID": "trophic_differences",
        "Description": [
            "Compute the trophic differences of the edges of a directed graph.",
            "The trophic difference \\(x_ij\\) for each edge is defined in Johnson et al. [1] as:",
            "Where \\(s_i\\) is the trophic level of node \\(i\\) ."
        ],
        "Field List": {
            "Parameters:": {
                "G : DiGraph": "A directed networkx graph"
            },
            "Returns:": {
                "diffs : dict": "Dictionary of edges with trophic differences as the value."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Samuel Johnson, Virginia Dominguez-Garcia, Luca Donetti, Miguel A.\nMunoz (2014) PNAS \u201cTrophic coherence determines food-web stability\u201d"
        }
    },
    {
        "Section ID": "tetrahedral_graph",
        "Description": [
            "Returns the 3-regular Platonic Tetrahedral graph.",
            "Tetrahedral graph has 4 nodes and 6 edges. It is a\nspecial case of the complete graph, K4, and wheel graph, W4.\nIt is one of the 5 platonic graphs [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : networkx Graph": "Tetrahedral Graph"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://en.wikipedia.org/wiki/Tetrahedron#Tetrahedral_graph"
        }
    },
    {
        "Section ID": "is_eulerian",
        "Description": [
            "Returns True if and only if G is Eulerian.",
            "A graph is Eulerian if it has an Eulerian circuit. An Eulerian\ncircuit is a closed walk that includes each edge of a graph exactly\nonce.",
            "Graphs with isolated vertices (i.e. vertices with zero degree) are not\nconsidered to have Eulerian circuits. Therefore, if the graph is not\nconnected (or not strongly connected, for directed graphs), this function\nreturns False."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A graph, either directed or undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "nx.is_eulerian(nx.DiGraph({0:[3],1:[2],2:[3],3:[0,1]}))\n# True\nnx.is_eulerian(nx.complete_graph(5))\n# True\nnx.is_eulerian(nx.petersen_graph())\n# False\nIf you prefer to allow graphs with isolated vertices to have Eulerian circuits,\nyou can first remove such vertices and then callis_eulerianas below example shows.\nG=nx.Graph([(0,1),(1,2),(0,2)])\nG.add_node(3)\nnx.is_eulerian(G)\n# False\nG.remove_nodes_from(list(nx.isolates(G)))\nnx.is_eulerian(G)\n# True"
        }
    },
    {
        "Section ID": "triad_graph",
        "Description": [
            "Returns the triad graph with the given name.",
            "Each string in the following tuple is a valid triad name:",
            "Each triad name corresponds to one of the possible valid digraph on\nthree nodes."
        ],
        "Field List": {
            "Parameters:": {
                "triad_name : string": "The name of a triad, as described above."
            },
            "Returns:": {
                "DiGraph": "The digraph on three nodes with the given name. The nodes of the\ngraph are the single-character strings \u2018a\u2019, \u2018b\u2019, and \u2018c\u2019."
            },
            "Raises:": {
                "ValueError": "Iftriad_nameis not the name of a triad."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "minimum_weight_full_matching",
        "Description": [
            "Returns a minimum weight full matching of the bipartite graph G .",
            "Let \\(G = ((U, V), E)\\) be a weighted bipartite graph with real weights \\(w : E \\to \\mathbb{R}\\) . This function then produces a matching \\(M \\subseteq E\\) with cardinality",
            "which minimizes the sum of the weights of the edges included in the\nmatching, \\(\\sum_{e \\in M} w(e)\\) , or raises an error if no such\nmatching exists.",
            "When \\(\\lvert U \\rvert = \\lvert V \\rvert\\) , this is commonly\nreferred to as a perfect matching; here, since we allow \\(\\lvert U \\rvert\\) and \\(\\lvert V \\rvert\\) to differ, we\nfollow Karp [1] and refer to the matching as full ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected bipartite graph",
                "top_nodes : container": "Container with all nodes in one bipartite node set. If not supplied\nit will be computed.",
                "weight : string, optional (default=\u2019weight\u2019)": "The edge data key used to provide each value in the matrix.\nIf None, then each edge has weight 1."
            },
            "Returns:": {
                "matches : dictionary": "The matching is returned as a dictionary,matches, such thatmatches[v]==wif nodevis matched to nodew. Unmatched\nnodes do not occur as a key inmatches."
            },
            "Raises:": {
                "ValueError": "Raised if no full matching exists.",
                "ImportError": "Raised if SciPy is not available."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The problem of determining a minimum weight full matching is also known as\nthe rectangular linear assignment problem. This implementation defers the\ncalculation of the assignment to SciPy.",
            "References": "[1]Richard Manning Karp:\nAn algorithm to Solve the m x n Assignment Problem in Expected Time\nO(mn log n).\nNetworks, 10(2):143\u2013152, 1980."
        }
    },
    {
        "Section ID": "load_centrality",
        "Description": [
            "Compute load centrality for nodes.",
            "The load centrality of a node is the fraction of all shortest\npaths that pass through that node."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph.",
                "normalized : bool, optional (default=True)": "If True the betweenness values are normalized by b=b/(n-1)(n-2) where\nn is the number of nodes in G.",
                "weight : None or string, optional (default=None)": "If None, edge weights are ignored.\nOtherwise holds the name of the edge attribute used as weight.\nThe weight of an edge is treated as the length or distance between the two sides.",
                "cutoff : bool, optional (default=None)": "If specified, only consider paths of length <= cutoff."
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of nodes with centrality as the value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Load centrality is slightly different than betweenness. It was originally\nintroduced by [2] . For this load algorithm see [1] .",
            "References": "[1]Mark E. J. Newman:\nScientific collaboration networks. II.\nShortest paths, weighted networks, and centrality.\nPhysical Review E 64, 016132, 2001.http://journals.aps.org/pre/abstract/10.1103/PhysRevE.64.016132  [2]Kwang-Il Goh, Byungnam Kahng and Doochul Kim\nUniversal behavior of Load Distribution in Scale-Free Networks.\nPhysical Review Letters 87(27):1\u20134, 2001.https://doi.org/10.1103/PhysRevLett.87.278701"
        }
    },
    {
        "Section ID": "girvan_newman",
        "Description": [
            "Finds communities in a graph using the Girvan\u2013Newman method."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "most_valuable_edge : function": "Function that takes a graph as input and outputs an edge. The\nedge returned by this function will be recomputed and removed at\neach iteration of the algorithm.If not specified, the edge with the highestnetworkx.edge_betweenness_centrality()will be used."
            },
            "Returns:": {
                "iterator": "Iterator over tuples of sets of nodes inG. Each set of node\nis a community, each tuple is a sequence of communities at a\nparticular level of the algorithm."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The Girvan\u2013Newman algorithm detects communities by progressively\nremoving edges from the original graph. The algorithm removes the\n\u201cmost valuable\u201d edge, traditionally the edge with the highest\nbetweenness centrality, at each step. As the graph breaks down into\npieces, the tightly knit community structure is exposed and the\nresult can be depicted as a dendrogram.",
            "Examples": "To get the first pair of communities:\nG=nx.path_graph(10)\ncomp=nx.community.girvan_newman(G)\ntuple(sorted(c)forcinnext(comp))\n# ([0, 1, 2, 3, 4], [5, 6, 7, 8, 9])\nTo get only the firstktuples of communities, useitertools.islice():\nimportitertools\nG=nx.path_graph(8)\nk=2\ncomp=nx.community.girvan_newman(G)\nforcommunitiesinitertools.islice(comp,k):\nprint(tuple(sorted(c)forcincommunities))\n\n# ([0, 1, 2, 3], [4, 5, 6, 7])\n# ([0, 1], [2, 3], [4, 5, 6, 7])\nTo stop getting tuples of communities once the number of communities\nis greater thank, useitertools.takewhile():\nimportitertools\nG=nx.path_graph(8)\nk=4\ncomp=nx.community.girvan_newman(G)\nlimited=itertools.takewhile(lambdac:len(c)<=k,comp)\nforcommunitiesinlimited:\nprint(tuple(sorted(c)forcincommunities))\n\n# ([0, 1, 2, 3], [4, 5, 6, 7])\n# ([0, 1], [2, 3], [4, 5, 6, 7])\n# ([0, 1], [2, 3], [4, 5], [6, 7])\nTo just choose an edge to remove based on the weight:\nfromoperatorimportitemgetter\nG=nx.path_graph(10)\nedges=G.edges()\nnx.set_edge_attributes(G,{(u,v):vforu,vinedges},\"weight\")\ndefheaviest(G):\nu,v,w=max(G.edges(data=\"weight\"),key=itemgetter(2))\nreturn(u,v)\n\ncomp=nx.community.girvan_newman(G,most_valuable_edge=heaviest)\ntuple(sorted(c)forcinnext(comp))\n# ([0, 1, 2, 3, 4, 5, 6, 7, 8], [9])\nTo utilize edge weights when choosing an edge with, for example, the\nhighest betweenness centrality:\nfromnetworkximportedge_betweenness_centralityasbetweenness\ndefmost_central_edge(G):\ncentrality=betweenness(G,weight=\"weight\")\nreturnmax(centrality,key=centrality.get)\n\nG=nx.path_graph(10)\ncomp=nx.community.girvan_newman(G,most_valuable_edge=most_central_edge)\ntuple(sorted(c)forcinnext(comp))\n# ([0, 1, 2, 3, 4], [5, 6, 7, 8, 9])\nTo specify a different ranking algorithm for edges, use themost_valuable_edgekeyword argument:\nfromnetworkximportedge_betweenness_centrality\nfromrandomimportrandom\ndefmost_central_edge(G):\ncentrality=edge_betweenness_centrality(G)\nmax_cent=max(centrality.values())\n# Scale the centrality values so they are between 0 and 1,\n# and add some random noise.\ncentrality={e:c/max_centfore,cincentrality.items()}\n# Add some random noise.\ncentrality={e:c+random()fore,cincentrality.items()}\nreturnmax(centrality,key=centrality.get)\n\nG=nx.path_graph(10)\ncomp=nx.community.girvan_newman(G,most_valuable_edge=most_central_edge)"
        }
    },
    {
        "Section ID": "edge_bfs",
        "Description": [
            "A directed, breadth-first-search of edges in G , beginning at source .",
            "Yield the edges of G in a breadth-first-search order continuing until\nall edges are generated."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A directed/undirected graph/multigraph.",
                "source : node, list of nodes": "The node from which the traversal begins. If None, then a source\nis chosen arbitrarily and repeatedly until all edges from each node in\nthe graph are searched.",
                "orientation : None | \u2018original\u2019 | \u2018reverse\u2019 | \u2018ignore\u2019 (default: None)": "For directed graphs and directed multigraphs, edge traversals need not\nrespect the original orientation of the edges.\nWhen set to \u2018reverse\u2019 every edge is traversed in the reverse direction.\nWhen set to \u2018ignore\u2019, every edge is treated as undirected.\nWhen set to \u2018original\u2019, every edge is treated as directed.\nIn all three cases, the yielded edge tuples add a last entry to\nindicate the direction in which that edge was traversed.\nIf orientation is None, the yielded edge has no direction indicated.\nThe direction is respected, but not reported."
            },
            "Yields:": {
                "edge : directed edge": "A directed edge indicating the path taken by the breadth-first-search.\nFor graphs,edgeis of the form(u,v)whereuandvare the tail and head of the edge as determined by the traversal.\nFor multigraphs,edgeis of the form(u,v,key), wherekeyis\nthe key of the edge. When the graph is directed, thenuandvare always in the order of the actual directed edge.\nIf orientation is not None then the edge tuple is extended to include\nthe direction of traversal (\u2018forward\u2019 or \u2018reverse\u2019) on that edge."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The goal of this function is to visit edges. It differs from the more\nfamiliar breadth-first-search of nodes, as provided by networkx.algorithms.traversal.breadth_first_search.bfs_edges() , in\nthat it does not stop once every node has been visited. In a directed graph\nwith edges [(0, 1), (1, 2), (2, 1)], the edge (2, 1) would not be visited\nif not for the functionality provided by this function. The naming of this function is very similar to bfs_edges. The difference\nis that \u2018edge_bfs\u2019 yields edges even if they extend back to an already\nexplored node while \u2018bfs_edges\u2019 yields the edges of the tree that results\nfrom a breadth-first-search (BFS) so no edges are reported if they extend\nto already explored nodes. That means \u2018edge_bfs\u2019 reports all edges while\n\u2018bfs_edges\u2019 only report those traversed by a node-based BFS. Yet another\ndescription is that \u2018bfs_edges\u2019 reports the edges traversed during BFS\nwhile \u2018edge_bfs\u2019 reports all edges in the order they are explored.",
            "Examples": "nodes=[0,1,2,3]\nedges=[(0,1),(1,0),(1,0),(2,0),(2,1),(3,1)]\nlist(nx.edge_bfs(nx.Graph(edges),nodes))\n# [(0, 1), (0, 2), (1, 2), (1, 3)]\nlist(nx.edge_bfs(nx.DiGraph(edges),nodes))\n# [(0, 1), (1, 0), (2, 0), (2, 1), (3, 1)]\nlist(nx.edge_bfs(nx.MultiGraph(edges),nodes))\n# [(0, 1, 0), (0, 1, 1), (0, 1, 2), (0, 2, 0), (1, 2, 0), (1, 3, 0)]\nlist(nx.edge_bfs(nx.MultiDiGraph(edges),nodes))\n# [(0, 1, 0), (1, 0, 0), (1, 0, 1), (2, 0, 0), (2, 1, 0), (3, 1, 0)]\nlist(nx.edge_bfs(nx.DiGraph(edges),nodes,orientation=\"ignore\"))\n# [(0, 1, 'forward'), (1, 0, 'reverse'), (2, 0, 'reverse'), (2, 1, 'reverse'), (3, 1, 'reverse')]\nlist(nx.edge_bfs(nx.MultiDiGraph(edges),nodes,orientation=\"ignore\"))\n# [(0, 1, 0, 'forward'), (1, 0, 0, 'reverse'), (1, 0, 1, 'reverse'), (2, 0, 0, 'reverse'), (2, 1, 0, 'reverse'), (3, 1, 0, 'reverse')]"
        }
    },
    {
        "Section ID": "strategy_random_sequential",
        "Description": [
            "Returns a random permutation of the nodes of G as a list.",
            "G is a NetworkX graph. colors is ignored."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "number_of_nodes",
        "Description": [
            "Returns the number of nodes in the graph.",
            "This function wraps the G.number_of_nodes function."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "strategy_largest_first",
        "Description": [
            "Returns a list of the nodes of G in decreasing order by\ndegree.",
            "G is a NetworkX graph. colors is ignored."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "moral_graph",
        "Description": [
            "Return the Moral Graph",
            "Returns the moralized graph of a given directed graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Directed graph"
            },
            "Returns:": {
                "H : NetworkX graph": "The undirected moralized graph of G"
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "A moral graph is an undirected graph H = (V, E) generated from a\ndirected Graph, where if a node has more than one parent node, edges\nbetween these parent nodes are inserted and all directed edges become\nundirected. https://en.wikipedia.org/wiki/Moral_graph",
            "References": "[1]Wray L. Buntine. 1995. Chain graphs for learning.\nIn Proceedings of the Eleventh conference on Uncertainty\nin artificial intelligence (UAI\u201995)",
            "Examples": "G=nx.DiGraph([(1,2),(2,3),(2,5),(3,4),(4,3)])\nG_moral=nx.moral_graph(G)\nG_moral.edges()\n# EdgeView([(1, 2), (2, 3), (2, 5), (2, 4), (3, 4)])"
        }
    },
    {
        "Section ID": "strategy_smallest_last",
        "Description": [
            "Returns a deque of the nodes of G , \u201csmallest\u201d last.",
            "Specifically, the degrees of each node are tracked in a bucket queue.\nFrom this, the node of minimum degree is repeatedly popped from the\ngraph, updating its neighbors\u2019 degrees.",
            "G is a NetworkX graph. colors is ignored.",
            "This implementation of the strategy runs in \\(O(n + m)\\) time\n(ignoring polylogarithmic factors), where \\(n\\) is the number of nodes\nand \\(m\\) is the number of edges.",
            "This strategy is related to strategy_independent_set() : if we\ninterpret each node removed as an independent set of size one, then\nthis strategy chooses an independent set of size one instead of a\nmaximal independent set."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "minimum_branching",
        "Description": [
            "Returns a minimum branching from G."
        ],
        "Field List": {
            "Parameters:": {
                "G : (multi)digraph-like": "The graph to be searched.",
                "attr : str": "The edge attribute used to in determining optimality.",
                "default : float": "The value of the edge attribute used if an edge does not have\nthe attributeattr.",
                "preserve_attrs : bool": "If True, preserve the other attributes of the original graph (that are not\npassed toattr)",
                "partition : str": "The key for the edge attribute containing the partition\ndata on the graph. Edges can be included, excluded or open using theEdgePartitionenum."
            },
            "Returns:": {
                "B : (multi)digraph-like": "A minimum branching."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "configuration_model",
        "Description": [
            "Returns a random graph with the given degree sequence.",
            "The configuration model generates a random pseudograph (graph with\nparallel edges and self loops) by randomly assigning edges to\nmatch the given degree sequence."
        ],
        "Field List": {
            "Parameters:": {
                "deg_sequence : list of nonnegative integers": "Each list entry corresponds to the degree of a node.",
                "create_using : NetworkX graph constructor, optional (default MultiGraph)": "Graph type to create. If graph instance, then cleared before populated.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "G : MultiGraph": "A graph with the specified degree sequence.\nNodes are labeled starting at 0 with an index\ncorresponding to the position in deg_sequence."
            },
            "Raises:": {
                "NetworkXError": "If the degree sequence does not have an even sum."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "As described by Newman [1] . A non-graphical degree sequence (not realizable by some simple\ngraph) is allowed since this function returns graphs with self\nloops and parallel edges.  An exception is raised if the degree\nsequence does not have an even sum. This configuration model construction process can lead to\nduplicate edges and loops.  You can remove the self-loops and\nparallel edges (see below) which will likely result in a graph\nthat doesn\u2019t have the exact degree sequence specified. The density of self-loops and parallel edges tends to decrease as\nthe number of nodes increases. However, typically the number of\nself-loops will approach a Poisson distribution with a nonzero mean,\nand similarly for the number of parallel edges.  Consider a node\nwith k stubs. The probability of being joined to another stub of\nthe same node is basically ( k - 1 ) / N , where k is the\ndegree and N is the number of nodes. So the probability of a\nself-loop scales like c / N for some constant c . As N grows,\nthis means we expect c self-loops. Similarly for parallel edges.",
            "References": "[1]M.E.J. Newman, \u201cThe structure and function of complex networks\u201d,\nSIAM REVIEW 45-2, pp 167-256, 2003.",
            "Examples": "You can create a degree sequence following a particular distribution\nby using the one of the distribution functions inrandom_sequence(or one of your own). For\nexample, to create an undirected multigraph on one hundred nodes\nwith degree sequence chosen from the power law distribution:\nsequence=nx.random_powerlaw_tree_sequence(100,tries=5000)\nG=nx.configuration_model(sequence)\nlen(G)\n# 100\nactual_degrees=[dforv,dinG.degree()]\nactual_degrees==sequence\n# True\nThe returned graph is a multigraph, which may have parallel\nedges. To remove any parallel edges from the returned graph:\nG=nx.Graph(G)\nSimilarly, to remove self-loops:\nG.remove_edges_from(nx.selfloop_edges(G))"
        }
    },
    {
        "Section ID": "asyn_lpa_communities",
        "Description": [
            "Returns communities in G as detected by asynchronous label\npropagation.",
            "The asynchronous label propagation algorithm is described in [1] . The algorithm is probabilistic and the found communities may\nvary on different executions.",
            "The algorithm proceeds as follows. After initializing each node with\na unique label, the algorithm repeatedly sets the label of a node to\nbe the label that appears most frequently among that nodes\nneighbors. The algorithm halts when each node has the label that\nappears most frequently among its neighbors. The algorithm is\nasynchronous because each node is updated without waiting for\nupdates on the remaining nodes.",
            "This generalized version of the algorithm in [1] accepts edge\nweights."
        ],
        "Field List": {
            "Parameters:": {
                "G : Graph": "",
                "weight : string": "The edge attribute representing the weight of an edge.\nIf None, each edge is assumed to have weight one. In this\nalgorithm, the weight of an edge is used in determining the\nfrequency with which a label appears among the neighbors of a\nnode: a higher weight means the label appears more often.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "communities : iterable": "Iterable of communities given as sets of nodes."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.",
            "References": "[1](1,2)Raghavan, Usha Nandini, R\u00e9ka Albert, and Soundar Kumara. \u201cNear\nlinear time algorithm to detect community structures in large-scale\nnetworks.\u201d Physical Review E 76.3 (2007): 036106."
        }
    },
    {
        "Section ID": "edge_connectivity",
        "Description": [
            "Returns the edge connectivity of the graph or digraph G.",
            "The edge connectivity is equal to the minimum number of edges that\nmust be removed to disconnect G or render it trivial. If source\nand target nodes are provided, this function returns the local edge\nconnectivity: the minimum number of edges that must be removed to\nbreak all paths from source to target in G."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected or directed graph",
                "s : node": "Source node. Optional. Default value: None.",
                "t : node": "Target node. Optional. Default value: None.",
                "flow_func : function": "A function for computing the maximum flow among a pair of nodes.\nThe function has to accept at least three parameters: a Digraph,\na source node, and a target node. And return a residual network\nthat follows NetworkX conventions (seemaximum_flow()for\ndetails). If flow_func is None, the default maximum flow function\n(edmonds_karp()) is used. See below for details. The\nchoice of the default function may change from version\nto version and should not be relied on. Default value: None.",
                "cutoff : integer, float, or None (default: None)": "If specified, the maximum flow algorithm will terminate when the\nflow value reaches or exceeds the cutoff. This only works for flows\nthat support the cutoff parameter (most do) and is ignored otherwise."
            },
            "Returns:": {
                "K : integer": "Edge connectivity for G, or local edge connectivity if source\nand target were provided"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This is a flow based implementation of global edge connectivity.\nFor undirected graphs the algorithm works by finding a \u2018small\u2019\ndominating set of nodes of G (see algorithm 7 in [1] ) and\ncomputing local maximum flow (see local_edge_connectivity() )\nbetween an arbitrary node in the dominating set and the rest of\nnodes in it. This is an implementation of algorithm 6 in [1] .\nFor directed graphs, the algorithm does n calls to the maximum\nflow function. This is an implementation of algorithm 8 in [1] .",
            "References": "[1](1,2,3)Abdol-Hossein Esfahanian. Connectivity Algorithms.http://www.cse.msu.edu/~cse835/Papers/Graph_connectivity_revised.pdf",
            "Examples": "# Platonic icosahedral graph is 5-edge-connected\nG=nx.icosahedral_graph()\nnx.edge_connectivity(G)\n# 5\nYou can use alternative flow algorithms for the underlying\nmaximum flow computation. In dense networks the algorithmshortest_augmenting_path()will usually perform better\nthan the defaultedmonds_karp(), which is faster for\nsparse networks with highly skewed degree distributions.\nAlternative flow functions have to be explicitly imported\nfrom the flow package.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\nnx.edge_connectivity(G,flow_func=shortest_augmenting_path)\n# 5\nIf you specify a pair of nodes (source and target) as parameters,\nthis function returns the value of local edge connectivity.\nnx.edge_connectivity(G,3,7)\n# 5\nIf you need to perform several local computations among different\npairs of nodes on the same graph, it is recommended that you reuse\nthe data structures used in the maximum flow computations. Seelocal_edge_connectivity()for details."
        }
    },
    {
        "Section ID": "latapy_clustering",
        "Description": [
            "Compute a bipartite clustering coefficient for nodes.",
            "The bipartite clustering coefficient is a measure of local density\nof connections defined as [1] :",
            "where N(N(u)) are the second order neighbors of u in G excluding u ,\nand c_{uv} is the pairwise clustering coefficient between nodes u and v .",
            "The mode selects the function for c_{uv} which can be:",
            "dot :",
            "min :",
            "max :"
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A bipartite graph",
                "nodes : list or iterable (optional)": "Compute bipartite clustering for these nodes. The default\nis all nodes in G.",
                "mode : string": "The pairwise bipartite clustering method to be used in the computation.\nIt must be \u201cdot\u201d, \u201cmax\u201d, or \u201cmin\u201d."
            },
            "Returns:": {
                "clustering : dictionary": "A dictionary keyed by node with the clustering coefficient value."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Latapy, Matthieu, Cl\u00e9mence Magnien, and Nathalie Del Vecchio (2008).\nBasic notions for the analysis of large two-mode networks.\nSocial Networks 30(1), 31\u201348.",
            "Examples": "fromnetworkx.algorithmsimportbipartite\nG=nx.path_graph(4)# path graphs are bipartite\nc=bipartite.clustering(G)\nc[0]\n# 0.5\nc=bipartite.clustering(G,mode=\"min\")\nc[0]\n# 1.0"
        }
    },
    {
        "Section ID": "topological_generations",
        "Description": [
            "Stratifies a DAG into generations.",
            "A topological generation is node collection in which ancestors of a node in each\ngeneration are guaranteed to be in a previous generation, and any descendants of\na node are guaranteed to be in a following generation. Nodes are guaranteed to\nbe in the earliest possible generation that they can belong to."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX digraph": "A directed acyclic graph (DAG)"
            },
            "Yields:": {
                "sets of nodes": "Yields sets of nodes representing each generation."
            },
            "Raises:": {
                "NetworkXError": "Generations are defined for directed graphs only. If the graphGis undirected, aNetworkXErroris raised.",
                "NetworkXUnfeasible": "IfGis not a directed acyclic graph (DAG) no topological generations\nexist and aNetworkXUnfeasibleexception is raised.  This can also\nbe raised ifGis changed while the returned iterator is being processed",
                "RuntimeError": "IfGis changed while the returned iterator is being processed."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The generation in which a node resides can also be determined by taking the\nmax-path-distance from the node to the farthest leaf node. That value can\nbe obtained with this function using enumerate(topological_generations(G)) .",
            "Examples": "DG=nx.DiGraph([(2,1),(3,1)])\n[sorted(generation)forgenerationinnx.topological_generations(DG)]\n# [[2, 3], [1]]"
        }
    },
    {
        "Section ID": "FilterAdjacency",
        "Description": [
            "A read-only Mapping of Mappings with filtering criteria for nodes and edges.",
            "It is a view into a dict-of-dict-of-dict data structure, and it selects nodes\nand edges that satisfy specific criteria defined by NODE_OK and EDGE_OK ,\nrespectively."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "attr_sparse_matrix",
        "Description": [
            "Returns a SciPy sparse array using attributes from G.",
            "If only G is passed in, then the adjacency matrix is constructed.",
            "Let A be a discrete set of values for the node attribute node_attr . Then\nthe elements of A represent the rows and columns of the constructed matrix.\nNow, iterate through every edge e=(u,v) in G and consider the value\nof the edge attribute edge_attr .  If ua and va are the values of the\nnode attribute node_attr for u and v, respectively, then the value of\nthe edge attribute is added to the matrix element at (ua, va)."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "The NetworkX graph used to construct the NumPy matrix.",
                "edge_attr : str, optional": "Each element of the matrix represents a running total of the\nspecified edge attribute for edges whose node attributes correspond\nto the rows/cols of the matrix. The attribute must be present for\nall edges in the graph. If no attribute is specified, then we\njust count the number of edges whose node attributes correspond\nto the matrix element.",
                "node_attr : str, optional": "Each row and column in the matrix represents a particular value\nof the node attribute.  The attribute must be present for all nodes\nin the graph. Note, the values of this attribute should be reliably\nhashable. So, float values are not recommended. If no attribute is\nspecified, then the rows and columns will be the nodes of the graph.",
                "normalized : bool, optional": "If True, then each row is normalized by the summation of its values.",
                "rc_order : list, optional": "A list of the node attribute values. This list specifies the ordering\nof rows and columns of the array. If no ordering is provided, then\nthe ordering will be random (and also, a return value)."
            },
            "Returns:": {
                "M : SciPy sparse array": "The attribute matrix.",
                "ordering : list": "Ifrc_orderwas specified, then only the matrix is returned.\nHowever, ifrc_orderwas None, then the ordering used to construct\nthe matrix is returned as well."
            },
            "Other Parameters:": {
                "dtype : NumPy data-type, optional": "A valid NumPy dtype used to initialize the array. Keep in mind certain\ndtypes can yield unexpected results if the array is to be normalized.\nThe parameter is passed to numpy.zeros(). If unspecified, the NumPy\ndefault is used."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "Construct an adjacency matrix:\nG=nx.Graph()\nG.add_edge(0,1,thickness=1,weight=3)\nG.add_edge(0,2,thickness=2)\nG.add_edge(1,2,thickness=3)\nM=nx.attr_sparse_matrix(G,rc_order=[0,1,2])\nM.toarray()\n# array([[0., 1., 1.],\n#        [1., 0., 1.],\n#        [1., 1., 0.]])\nAlternatively, we can obtain the matrix describing edge thickness.\nM=nx.attr_sparse_matrix(G,edge_attr=\"thickness\",rc_order=[0,1,2])\nM.toarray()\n# array([[0., 1., 2.],\n#        [1., 0., 3.],\n#        [2., 3., 0.]])\nWe can also color the nodes and ask for the probability distribution over\nall edges (u,v) describing:"
        }
    },
    {
        "Section ID": "eulerian_circuit",
        "Description": [
            "Returns an iterator over the edges of an Eulerian circuit in G .",
            "An Eulerian circuit is a closed walk that includes each edge of a\ngraph exactly once."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A graph, either directed or undirected.",
                "source : node, optional": "Starting node for circuit.",
                "keys : bool": "If False, edges generated by this function will be of the form(u,v). Otherwise, edges will be of the form(u,v,k).\nThis option is ignored unlessGis a multigraph."
            },
            "Returns:": {
                "edges : iterator": "An iterator over edges in the Eulerian circuit."
            },
            "Raises:": {
                "NetworkXError": "If the graph is not Eulerian."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This is a linear time implementation of an algorithm adapted from [1] . For general information about Euler tours, see [2] .",
            "References": "[1]J. Edmonds, E. L. Johnson.\nMatching, Euler tours and the Chinese postman.\nMathematical programming, Volume 5, Issue 1 (1973), 111-114.  [2]https://en.wikipedia.org/wiki/Eulerian_path",
            "Examples": "To get an Eulerian circuit in an undirected graph:\nG=nx.complete_graph(3)\nlist(nx.eulerian_circuit(G))\n# [(0, 2), (2, 1), (1, 0)]\nlist(nx.eulerian_circuit(G,source=1))\n# [(1, 2), (2, 0), (0, 1)]\nTo get the sequence of vertices in an Eulerian circuit:\n[uforu,vinnx.eulerian_circuit(G)]\n# [0, 2, 1]"
        }
    },
    {
        "Section ID": "is_regular",
        "Description": [
            "Determines whether the graph G is a regular graph.",
            "A regular graph is a graph where each vertex has the same degree. A\nregular digraph is a graph where the indegree and outdegree of each\nvertex are equal."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": ""
            },
            "Returns:": {
                "bool": "Whether the given graph or digraph is regular."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.DiGraph([(1,2),(2,3),(3,4),(4,1)])\nnx.is_regular(G)\n# True"
        }
    },
    {
        "Section ID": "random_lobster",
        "Description": [
            "Returns a random lobster graph.",
            "A lobster is a tree that reduces to a caterpillar when pruning all\nleaf nodes. A caterpillar is a tree that reduces to a path graph\nwhen pruning all leaf nodes; setting p2 to zero produces a caterpillar.",
            "This implementation iterates on the probabilities p1 and p2 to add\nedges at levels 1 and 2, respectively. Graphs are therefore constructed\niteratively with uniform randomness at each level rather than being selected\nuniformly at random from the set of all possible lobsters."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The expected number of nodes in the backbone",
                "p1 : float": "Probability of adding an edge to the backbone",
                "p2 : float": "Probability of adding an edge one level beyond backbone",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Raises:": {
                "NetworkXError": "Ifp1orp2parameters are >= 1 because the while loops would never finish."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "maximal_matching",
        "Description": [
            "Find a maximal matching in the graph.",
            "A matching is a subset of edges in which no node occurs more than once.\nA maximal matching cannot add more edges and still be a matching."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected graph"
            },
            "Returns:": {
                "matching : set": "A maximal matching of the graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The algorithm greedily selects a maximal matching M of the graph G\n(i.e. no superset of M exists). It runs in \\(O(|E|)\\) time.",
            "Examples": "G=nx.Graph([(1,2),(1,3),(2,3),(2,4),(3,5),(4,5)])\nsorted(nx.maximal_matching(G))\n# [(1, 2), (3, 5)]"
        }
    },
    {
        "Section ID": "local_bridges",
        "Description": [
            "Iterate over local bridges of G optionally computing the span",
            "A local bridge is an edge whose endpoints have no common neighbors.\nThat is, the edge is not part of a triangle in the graph.",
            "The span of a local bridge is the shortest path length between\nthe endpoints if the local bridge is removed."
        ],
        "Field List": {
            "Parameters:": {
                "G : undirected graph": "",
                "with_span : bool": "If True, yield a 3-tuple(u,v,span)",
                "weight : function, string or None (default: None)": "If function, used to compute edge weights for the span.\nIf string, the edge data attribute used in calculating span.\nIf None, all edges have weight 1."
            },
            "Yields:": {
                "e : edge": "The local bridges as an edge 2-tuple of nodes(u,v)or\nas a 3-tuple(u,v,span)whenwith_spanisTrue."
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis a directed graph or multigraph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "A cycle graph has every edge a local bridge with span N-1.\nG=nx.cycle_graph(9)\n(0,8,8)inset(nx.local_bridges(G))\n# True"
        }
    },
    {
        "Section ID": "is_strongly_connected",
        "Description": [
            "Decides whether the given tournament is strongly connected.",
            "This function is more theoretically efficient than the is_strongly_connected() function.",
            "The given graph must be a tournament, otherwise this function\u2019s\nbehavior is undefined."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A directed graph representing a tournament."
            },
            "Returns:": {
                "bool": "Whether the tournament is strongly connected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Although this function is more theoretically efficient than the\ngeneric strong connectivity function, a speedup requires the use of\nparallelism. Though it may in the future, the current implementation\ndoes not use parallelism, thus you may not see much of a speedup. This algorithm comes from [1].",
            "References": "[1]Tantau, Till.\n\u201cA note on the complexity of the reachability problem for\ntournaments.\u201dElectronic Colloquium on Computational Complexity. 2001.\n<http://eccc.hpi-web.de/report/2001/092/>",
            "Examples": "G=nx.DiGraph([(0,1),(0,2),(1,2),(1,3),(2,3),(3,0)])\nnx.is_tournament(G)\n# True\nnx.tournament.is_strongly_connected(G)\n# True\nG.remove_edge(3,0)\nG.add_edge(0,3)\nnx.is_tournament(G)\n# True\nnx.tournament.is_strongly_connected(G)\n# False"
        }
    },
    {
        "Section ID": "pairwise",
        "Description": [
            "s -> (s0, s1), (s1, s2), (s2, s3), \u2026"
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "random_regular_expander_graph",
        "Description": [
            "Returns a random regular expander graph on \\(n\\) nodes with degree \\(d\\) .",
            "An expander graph is a sparse graph with strong connectivity properties. [1]",
            "More precisely the returned graph is a \\((n, d, \\lambda)\\) -expander with \\(\\lambda = 2 \\sqrt{d - 1} + \\epsilon\\) , close to the Alon-Boppana bound. [2]",
            "In the case where \\(\\epsilon = 0\\) it returns a Ramanujan graph.\nA Ramanujan graph has spectral gap almost as large as possible,\nwhich makes them excellent expanders. [3]"
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes.",
                "d : int": "The degree of each node.",
                "epsilon : int, float, default=0": "",
                "max_tries : int, (default: 100)": "The number of allowed loops, also used in the maybe_regular_expander utility",
                "seed : (default: None)": "Seed used to set random number generation state. See :ref`Randomness<randomness>`."
            },
            "Raises:": {
                "NetworkXError": "If max_tries is reached"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This loops over maybe_regular_expander and can be slow when \\(n\\) is too big or \\(\\epsilon\\) too small.",
            "References": "[1]Expander graph,https://en.wikipedia.org/wiki/Expander_graph  [2]Alon-Boppana bound,https://en.wikipedia.org/wiki/Alon%E2%80%93Boppana_bound  [3]Ramanujan graphs,https://en.wikipedia.org/wiki/Ramanujan_graph",
            "Examples": "G=nx.random_regular_expander_graph(20,4)\nnx.is_regular_expander(G)\n# True"
        }
    },
    {
        "Section ID": "edge_current_flow_betweenness_partition",
        "Description": [
            "Partition created by removing the highest edge current flow betweenness edge.",
            "This algorithm works by calculating the edge current flow\nbetweenness for all edges and removing the edge with the\nhighest value. It is then determined whether the graph has\nbeen broken into at least number_of_sets connected\ncomponents. If not the process is repeated."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph, DiGraph or MultiGraph": "Graph to be partitioned",
                "number_of_sets : int": "Number of sets in the desired partition of the graph",
                "weight : key, optional (default=None)": "The edge attribute key to use as weights for\nedge current flow betweenness calculations"
            },
            "Returns:": {
                "C : list of sets": "Partition of G"
            },
            "Raises:": {
                "NetworkXError": "If number_of_sets is <= 0 or number_of_sets > len(G)"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm is extremely slow, as the recalculation of the edge\ncurrent flow betweenness is extremely slow.",
            "References": "[1]Santo Fortunato \u2018Community Detection in Graphs\u2019 Physical Reports\nVolume 486, Issue 3-5 p. 75-174http://arxiv.org/abs/0906.0612",
            "Examples": "G=nx.karate_club_graph()\npart=nx.community.edge_current_flow_betweenness_partition(G,2)\n{0,1,2,3,4,5,6,7,9,10,11,12,13,16,17,19,21}inpart\n# True\n{8,14,15,18,20,22,23,24,25,26,27,28,29,30,31,32,33}inpart\n# True"
        }
    },
    {
        "Section ID": "connected_caveman_graph",
        "Description": [
            "Returns a connected caveman graph of l cliques of size k .",
            "The connected caveman graph is formed by creating n cliques of size k , then a single edge in each clique is rewired to a node in an\nadjacent clique."
        ],
        "Field List": {
            "Parameters:": {
                "l : int": "number of cliques",
                "k : int": "size of cliques (k at least 2 or NetworkXError is raised)"
            },
            "Returns:": {
                "G : NetworkX Graph": "connected caveman graph"
            },
            "Raises:": {
                "NetworkXError": "If the size of cliqueskis smaller than 2."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This returns an undirected graph, it can be converted to a directed\ngraph using nx.to_directed() , or a multigraph using nx.MultiGraph(nx.caveman_graph(l,k)) . Only the undirected version is\ndescribed in [1] and it is unclear which of the directed\ngeneralizations is most useful.",
            "References": "[1]Watts, D. J. \u2018Networks, Dynamics, and the Small-World Phenomenon.\u2019\nAmer. J. Soc. 105, 493-527, 1999.",
            "Examples": "G=nx.connected_caveman_graph(3,3)"
        }
    },
    {
        "Section ID": "single_source_shortest_path",
        "Description": [
            "Compute shortest path between source\nand all other nodes reachable from source."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node label": "Starting node for path",
                "cutoff : integer, optional": "Depth to stop the search. Only paths of length <= cutoff are returned."
            },
            "Returns:": {
                "paths : dictionary": "Dictionary, keyed by target, of shortest paths."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The shortest path is not necessarily unique. So there can be multiple\npaths between the source and each target node, all of which have the\nsame \u2018shortest\u2019 length. For each target node, this function returns\nonly one of those paths.",
            "Examples": "G=nx.path_graph(5)\npath=nx.single_source_shortest_path(G,0)\npath[4]\n# [0, 1, 2, 3, 4]"
        }
    },
    {
        "Section ID": "to_numpy_array",
        "Description": [
            "Returns the graph adjacency matrix as a NumPy array."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "The NetworkX graph used to construct the NumPy array.",
                "nodelist : list, optional": "The rows and columns are ordered according to the nodes innodelist.\nIfnodelistisNone, then the ordering is produced byG.nodes().",
                "dtype : NumPy data type, optional": "A NumPy data type used to initialize the array. If None, then the NumPy\ndefault is used. The dtype can be structured ifweight=None, in which\ncase the dtype field names are used to look up edge attributes. The\nresult is a structured array where each named field in the dtype\ncorresponds to the adjacency for that edge attribute. See examples for\ndetails.",
                "order : {\u2018C\u2019, \u2018F\u2019}, optional": "Whether to store multidimensional data in C- or Fortran-contiguous\n(row- or column-wise) order in memory. If None, then the NumPy default\nis used.",
                "multigraph_weight : callable, optional": "An function that determines how weights in multigraphs are handled.\nThe function should accept a sequence of weights and return a single\nvalue. The default is to sum the weights of the multiple edges.",
                "weight : string or None optional (default = \u2018weight\u2019)": "The edge attribute that holds the numerical value used for\nthe edge weight. If an edge does not have that attribute, then the\nvalue 1 is used instead.weightmust beNoneif a structured\ndtype is used.",
                "nonedge : array_like (default = 0.0)": "The value used to represent non-edges in the adjacency matrix.\nThe array values corresponding to nonedges are typically set to zero.\nHowever, this could be undesirable if there are array values\ncorresponding to actual edges that also have the value zero. If so,\none might prefer nonedges to have some other value, such asnan."
            },
            "Returns:": {
                "A : NumPy ndarray": "Graph adjacency matrix"
            },
            "Raises:": {
                "NetworkXError": "Ifdtypeis a structured dtype andGis a multigraph",
                "ValueError": "Ifdtypeis a structured dtype andweightis notNone"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For directed graphs, entry i,j corresponds to an edge from i to j . Entries in the adjacency matrix are given by the weight edge attribute.\nWhen an edge does not have a weight attribute, the value of the entry is\nset to the number 1.  For multiple (parallel) edges, the values of the\nentries are determined by the multigraph_weight parameter. The default is\nto sum the weight attributes for each of the parallel edges. When nodelist does not contain every node in G , the adjacency matrix is\nbuilt from the subgraph of G that is induced by the nodes in nodelist . The convention used for self-loop edges in graphs is to assign the\ndiagonal array entry value to the weight attribute of the edge\n(or the number 1 if the edge has no weight attribute). If the\nalternate convention of doubling the edge weight is desired the\nresulting NumPy array can be modified as follows:",
            "Examples": "G=nx.MultiDiGraph()\nG.add_edge(0,1,weight=2)\n# 0\nG.add_edge(1,0)\n# 0\nG.add_edge(2,2,weight=3)\n# 0\nG.add_edge(2,2)\n# 1\nnx.to_numpy_array(G,nodelist=[0,1,2])\n# array([[0., 2., 0.],\n#        [1., 0., 0.],\n#        [0., 0., 4.]])\nWhennodelistargument is used, nodes ofGwhich do not appear in thenodelistand their edges are not included in the adjacency matrix. Here is an example:\nG=nx.Graph()\nG.add_edge(3,1)\nG.add_edge(2,0)\nG.add_edge(2,1)\nG.add_edge(3,0)\nnx.to_numpy_array(G,nodelist=[1,2,3])\n# array([[0., 1., 1.],\n#        [1., 0., 0.],\n#        [1., 0., 0.]])\nThis function can also be used to create adjacency matrices for multiple\nedge attributes with structured dtypes:\nG=nx.Graph()\nG.add_edge(0,1,weight=10)\nG.add_edge(1,2,cost=5)\nG.add_edge(2,3,weight=3,cost=-4.0)\ndtype=np.dtype([(\"weight\",int),(\"cost\",float)])\nA=nx.to_numpy_array(G,dtype=dtype,weight=None)\nA[\"weight\"]\n# array([[ 0, 10,  0,  0],\n#        [10,  0,  1,  0],\n#        [ 0,  1,  0,  3],\n#        [ 0,  0,  3,  0]])\nA[\"cost\"]\n# array([[ 0.,  1.,  0.,  0.],\n#        [ 1.,  0.,  5.,  0.],\n#        [ 0.,  5.,  0., -4.],\n#        [ 0.,  0., -4.,  0.]])\nAs stated above, the argument \u201cnonedge\u201d is useful especially when there are\nactually edges with weight 0 in the graph. Setting a nonedge value different than 0,\nmakes it much clearer to differentiate such 0-weighted edges and actual nonedge values.\nG=nx.Graph()\nG.add_edge(3,1,weight=2)\nG.add_edge(2,0,weight=0)\nG.add_edge(2,1,weight=0)\nG.add_edge(3,0,weight=1)\nnx.to_numpy_array(G,nonedge=-1.0)\n# array([[-1.,  2., -1.,  1.],\n#        [ 2., -1.,  0., -1.],\n#        [-1.,  0., -1.,  0.],\n#        [ 1., -1.,  0., -1.]])"
        }
    },
    {
        "Section ID": "write_adjlist",
        "Description": [
            "Write graph G in single-line adjacency-list format to path."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "path : string or file": "Filename or file handle for data output.\nFilenames ending in .gz or .bz2 will be compressed.",
                "comments : string, optional": "Marker for comment lines",
                "delimiter : string, optional": "Separator for node labels",
                "encoding : string, optional": "Text encoding."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The default delimiter=\"\" will result in unexpected results if node names contain\nwhitespace characters. To avoid this problem, specify an alternate delimiter when spaces are\nvalid in node names.\nNB: This option is not available for data that isn\u2019t user-generated. This format does not store graph, node, or edge data.",
            "Examples": "G=nx.path_graph(4)\nnx.write_adjlist(G,\"test.adjlist\")\nThe path can be a filehandle or a string with the name of the file. If a\nfilehandle is provided, it has to be opened in \u2018wb\u2019 mode.\nfh=open(\"test.adjlist\",\"wb\")\nnx.write_adjlist(G,fh)"
        }
    },
    {
        "Section ID": "make_list_of_ints",
        "Description": [
            "Return list of ints from sequence of integral numbers.",
            "All elements of the sequence must satisfy int(element) == element\nor a ValueError is raised. Sequence is iterated through once.",
            "If sequence is a list, the non-int values are replaced with ints.\nSo, no new list is created"
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "triangular_lattice_graph",
        "Description": [
            "Returns the \\(m\\) by \\(n\\) triangular lattice graph.",
            "The triangular lattice graph is a two-dimensional grid graph in\nwhich each square unit has a diagonal edge (each grid unit has a chord).",
            "The returned graph has \\(m\\) rows and \\(n\\) columns of triangles. Rows and\ncolumns include both triangles pointing up and down. Rows form a strip\nof constant height. Columns form a series of diamond shapes, staggered\nwith the columns on either side. Another way to state the size is that\nthe nodes form a grid of m+1 rows and (n+1)//2 columns.\nThe odd row nodes are shifted horizontally relative to the even rows.",
            "Directed graph types have edges pointed up or right.",
            "Positions of nodes are computed by default or with_positionsisTrue .\nThe position of each node (embedded in a euclidean plane) is stored in\nthe graph using equilateral triangles with sidelength 1.\nThe height between rows of nodes is thus \\(\\sqrt(3)/2\\) .\nNodes lie in the first quadrant with the node \\((0, 0)\\) at the origin."
        ],
        "Field List": {
            "Parameters:": {
                "m : int": "The number of rows in the lattice.",
                "n : int": "The number of columns in the lattice.",
                "periodic : bool (default: False)": "If True, join the boundary vertices of the grid using periodic\nboundary conditions. The join between boundaries is the final row\nand column of triangles. This means there is one row and one column\nfewer nodes for the periodic lattice. Periodic lattices requirem>=3,n>=5and are allowed but misaligned ifmornare odd",
                "with_positions : bool (default: True)": "Store the coordinates of each node in the graph node attribute \u2018pos\u2019.\nThe coordinates provide a lattice with equilateral triangles.\nPeriodic positions shift the nodes vertically in a nonlinear way so\nthe edges don\u2019t overlap so much.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "NetworkX graph": "Thembyntriangular lattice graph."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "random_partition_graph",
        "Description": [
            "Returns the random partition graph with a partition of sizes.",
            "A partition graph is a graph of communities with sizes defined by\ns in sizes. Nodes in the same group are connected with probability\np_in and nodes of different groups are connected with probability\np_out."
        ],
        "Field List": {
            "Parameters:": {
                "sizes : list of ints": "Sizes of groups",
                "p_in : float": "probability of edges with in groups",
                "p_out : float": "probability of edges between groups",
                "directed : boolean optional, default=False": "Whether to create a directed graph",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "G : NetworkX Graph or DiGraph": "random partition graph of size sum(gs)"
            },
            "Raises:": {
                "NetworkXError": "If p_in or p_out is not in [0,1]"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This is a generalization of the planted-l-partition described in [1] .  It allows for the creation of groups of any size. The partition is store as a graph attribute \u2018partition\u2019.",
            "References": "[1]Santo Fortunato \u2018Community Detection in Graphs\u2019 Physical Reports\nVolume 486, Issue 3-5 p. 75-174.https://arxiv.org/abs/0906.0612",
            "Examples": "G=nx.random_partition_graph([10,10,10],0.25,0.01)\nlen(G)\n# 30\npartition=G.graph[\"partition\"]\nlen(partition)\n# 3"
        }
    },
    {
        "Section ID": "edge_boundary",
        "Description": [
            "Returns the edge boundary of nbunch1 .",
            "The edge boundary of a set S with respect to a set T is the\nset of edges ( u , v ) such that u is in S and v is in T .\nIf T is not specified, it is assumed to be the set of all nodes\nnot in S ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "nbunch1 : iterable": "Iterable of nodes in the graph representing the set of nodes\nwhose edge boundary will be returned. (This is the setSfrom\nthe definition above.)",
                "nbunch2 : iterable": "Iterable of nodes representing the target (or \u201cexterior\u201d) set of\nnodes. (This is the setTfrom the definition above.) If not\nspecified, this is assumed to be the set of all nodes inGnot innbunch1.",
                "keys : bool": "This parameter has the same meaning as inMultiGraph.edges().",
                "data : bool or object": "This parameter has the same meaning as inMultiGraph.edges().",
                "default : object": "This parameter has the same meaning as inMultiGraph.edges()."
            },
            "Returns:": {
                "iterator": "An iterator over the edges in the boundary ofnbunch1with\nrespect tonbunch2. Ifkeys,data, ordefaultare specified andGis a multigraph, then edges are returned\nwith keys and/or data, as inMultiGraph.edges()."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Any element of nbunch that is not in the graph G will be\nignored. nbunch1 and nbunch2 are usually meant to be disjoint, but in\nthe interest of speed and generality, that is not required here.",
            "Examples": "G=nx.wheel_graph(6)\nWhen nbunch2=None:\nlist(nx.edge_boundary(G,(1,3)))\n# [(1, 0), (1, 2), (1, 5), (3, 0), (3, 2), (3, 4)]\nWhen nbunch2 is given:\nlist(nx.edge_boundary(G,(1,3),(2,0)))\n# [(1, 0), (1, 2), (3, 0), (3, 2)]"
        }
    },
    {
        "Section ID": "read_edgelist",
        "Description": [
            "Read a bipartite graph from a list of edges."
        ],
        "Field List": {
            "Parameters:": {
                "path : file or string": "File or filename to read. If a file is provided, it must be\nopened in \u2018rb\u2019 mode.\nFilenames ending in .gz or .bz2 will be uncompressed.",
                "comments : string, optional": "The character used to indicate the start of a comment.",
                "delimiter : string, optional": "The string used to separate values.  The default is whitespace.",
                "create_using : Graph container, optional,": "Use specified container to build graph.  The default is networkx.Graph,\nan undirected graph.",
                "nodetype : int, float, str, Python type, optional": "Convert node data from strings to specified type",
                "data : bool or list of (label,type) tuples": "Tuples specifying dictionary key names and types for edge data",
                "edgetype : int, float, str, Python type, optional OBSOLETE": "Convert edge data from strings to specified type and use as \u2018weight\u2019",
                "encoding: string, optional": "Specify which encoding to use when reading file."
            },
            "Returns:": {
                "G : graph": "A networkx Graph or other type specified with create_using"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Since nodes must be hashable, the function nodetype must return hashable\ntypes (e.g. int, float, str, frozenset - or tuples of those, etc.)",
            "Examples": "fromnetworkx.algorithmsimportbipartite\nG=nx.path_graph(4)\nG.add_nodes_from([0,2],bipartite=0)\nG.add_nodes_from([1,3],bipartite=1)\nbipartite.write_edgelist(G,\"test.edgelist\")\nG=bipartite.read_edgelist(\"test.edgelist\")\nfh=open(\"test.edgelist\",\"rb\")\nG=bipartite.read_edgelist(fh)\nfh.close()\nG=bipartite.read_edgelist(\"test.edgelist\",nodetype=int)\nEdgelist with data in a list:\ntextline=\"1 2 3\"\nfh=open(\"test.edgelist\",\"w\")\nd=fh.write(textline)\nfh.close()\nG=bipartite.read_edgelist(\n\"test.edgelist\",nodetype=int,data=((\"weight\",float),)\n)\nlist(G)\n# [1, 2]\nlist(G.edges(data=True))\n# [(1, 2, {'weight': 3.0})]\nSee parse_edgelist() for more examples of formatting."
        }
    },
    {
        "Section ID": "random_labeled_rooted_forest",
        "Description": [
            "Returns a labeled rooted forest with n nodes.",
            "The returned forest is chosen uniformly at random using a\ngeneralization of Pr\u00fcfer sequences [1] in the form described in [2] ."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes.",
                "seed : random_state": "SeeRandomness."
            },
            "Returns:": {
                "networkx.Graph": "Anetworkx.Graphwith integer nodes 0 <= node <=n- 1.\nThe \u201croots\u201d graph attribute is a set of integers containing the roots."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Knuth, Donald E. \u201cAnother Enumeration of Trees.\u201d\nCanadian Journal of Mathematics, 20 (1968): 1077-1086.https://doi.org/10.4153/CJM-1968-104-8  [2]Rubey, Martin. \u201cCounting Spanning Trees\u201d. Diplomarbeit\nzur Erlangung des akademischen Grades Magister der\nNaturwissenschaften an der Formal- und Naturwissenschaftlichen\nFakult\u00e4t der Universit\u00e4t Wien. Wien, May 2000."
        }
    },
    {
        "Section ID": "omega",
        "Description": [
            "Returns the small-world coefficient (omega) of a graph",
            "The small-world coefficient of a graph G is:",
            "omega = Lr/L - C/Cl",
            "where C and L are respectively the average clustering coefficient and\naverage shortest path length of G. Lr is the average shortest path length\nof an equivalent random graph and Cl is the average clustering coefficient\nof an equivalent lattice graph.",
            "The small-world coefficient (omega) measures how much G is like a lattice\nor a random graph. Negative values mean G is similar to a lattice whereas\npositive values mean G is a random graph.\nValues close to 0 mean that G has small-world characteristics."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "An undirected graph.",
                "niter: integer (optional, default=5)": "Approximate number of rewiring per edge to compute the equivalent\nrandom graph.",
                "nrand: integer (optional, default=10)": "Number of random graphs generated to compute the maximal clustering\ncoefficient (Cr) and average shortest path length (Lr).",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "omega : float": "The small-world coefficient (omega)"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The implementation is adapted from the algorithm by Telesford et al. [1] .",
            "References": "[1]Telesford, Joyce, Hayasaka, Burdette, and Laurienti (2011).\n\u201cThe Ubiquity of Small-World Networks\u201d.\nBrain Connectivity. 1 (0038): 367-75.  PMC 3604768. PMID 22432451.\ndoi:10.1089/brain.2011.0038."
        }
    },
    {
        "Section ID": "minimum_spanning_tree",
        "Description": [
            "Returns a minimum spanning tree or forest on an undirected graph G ."
        ],
        "Field List": {
            "Parameters:": {
                "G : undirected graph": "An undirected graph. IfGis connected, then the algorithm finds a\nspanning tree. Otherwise, a spanning forest is found.",
                "weight : str": "Data key to use for edge weights.",
                "algorithm : string": "The algorithm to use when finding a minimum spanning tree. Valid\nchoices are \u2018kruskal\u2019, \u2018prim\u2019, or \u2018boruvka\u2019. The default is\n\u2018kruskal\u2019.",
                "ignore_nan : bool (default: False)": "If a NaN is found as an edge weight normally an exception is raised.\nIfignore_nanisTruethen that edge is ignored instead."
            },
            "Returns:": {
                "G : NetworkX Graph": "A minimum spanning tree or forest."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For Bor\u016fvka\u2019s algorithm, each edge must have a weight attribute, and\neach edge weight must be distinct. For the other algorithms, if the graph edges do not have a weight\nattribute a default weight of 1 will be used. There may be more than one tree with the same minimum or maximum weight.\nSee networkx.tree.recognition for more detailed definitions. Isolated nodes with self-loops are in the tree as edgeless isolated nodes.",
            "Examples": "G=nx.cycle_graph(4)\nG.add_edge(0,3,weight=2)\nT=nx.minimum_spanning_tree(G)\nsorted(T.edges(data=True))\n# [(0, 1, {}), (1, 2, {}), (2, 3, {})]"
        }
    },
    {
        "Section ID": "is_forest",
        "Description": [
            "Returns True if G is a forest.",
            "A forest is a graph with no undirected cycles.",
            "For directed graphs, G is a forest if the underlying graph is a forest.\nThe underlying graph is obtained by treating each directed edge as a single\nundirected edge in a multigraph."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "The graph to test."
            },
            "Returns:": {
                "b : bool": "A boolean that is True ifGis a forest."
            },
            "Raises:": {
                "NetworkXPointlessConcept": "IfGis empty."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "In another convention, a directed forest is known as a polyforest and\nthen forest corresponds to a branching .",
            "Examples": "G=nx.Graph()\nG.add_edges_from([(1,2),(1,3),(2,4),(2,5)])\nnx.is_forest(G)\n# True\nG.add_edge(4,1)\nnx.is_forest(G)\n# False"
        }
    },
    {
        "Section ID": "group_closeness_centrality",
        "Description": [
            "Compute the group closeness centrality for a group of nodes.",
            "Group closeness centrality of a group of nodes \\(S\\) is a measure\nof how close the group is to the other nodes in the graph.",
            "where \\(V\\) is the set of nodes, \\(d_{S, v}\\) is the distance of\nthe group \\(S\\) from \\(v\\) defined as above. ( \\(V-S\\) is the set of nodes\nin \\(V\\) that are not in \\(S\\) )."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.",
                "S : list or set": "S is a group of nodes which belong to G, for which group closeness\ncentrality is to be calculated.",
                "weight : None or string, optional (default=None)": "If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight.\nThe weight of an edge is treated as the length or distance between the two sides."
            },
            "Returns:": {
                "closeness : float": "Group closeness centrality of the group S."
            },
            "Raises:": {
                "NodeNotFound": "If node(s) in S are not present in G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The measure was introduced in [1] .\nThe formula implemented here is described in [2] . Higher values of closeness indicate greater centrality. It is assumed that 1 / 0 is 0 (required in the case of directed graphs,\nor when a shortest path length is 0). The number of nodes in the group must be a maximum of n - 1 where n is the total number of nodes in the graph. For directed graphs, the incoming distance is utilized here. To use the\noutward distance, act on G.reverse() . For weighted graphs the edge weights must be greater than zero.\nZero edge weights can produce an infinite number of equal length\npaths between pairs of nodes.",
            "References": "[1]M G Everett and S P Borgatti:\nThe Centrality of Groups and Classes.\nJournal of Mathematical Sociology. 23(3): 181-201. 1999.http://www.analytictech.com/borgatti/group_centrality.htm  [2]J. Zhao et. al.:\nMeasuring and Maximizing Group Closeness Centrality over\nDisk Resident Graphs.\nWWWConference Proceedings, 2014. 689-694.https://doi.org/10.1145/2567948.2579356"
        }
    },
    {
        "Section ID": "volume",
        "Description": [
            "Returns the volume of a set of nodes.",
            "The volume of a set S is the sum of the (out-)degrees of nodes\nin S (taking into account parallel edges in multigraphs). [1]"
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "S : collection": "A collection of nodes inG.",
                "weight : object": "Edge attribute key to use as weight. If not specified, edges\nhave weight one."
            },
            "Returns:": {
                "number": "The volume of the set of nodes represented bySin the graphG."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]David Gleich.Hierarchical Directed Spectral Graph Partitioning.\n<https://www.cs.purdue.edu/homes/dgleich/publications/Gleich%202005%20-%20hierarchical%20directed%20spectral.pdf>"
        }
    },
    {
        "Section ID": "harmonic_centrality",
        "Description": [
            "Compute harmonic centrality for nodes.",
            "Harmonic centrality [1] of a node u is the sum of the reciprocal\nof the shortest path distances from all other nodes to u",
            "where d(v,u) is the shortest-path distance between v and u .",
            "If sources is given as an argument, the returned harmonic centrality\nvalues are calculated as the sum of the reciprocals of the shortest\npath distances from the nodes specified in sources to u instead\nof from all nodes to u .",
            "Notice that higher values indicate higher centrality."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "nbunch : container (default: all nodes in G)": "Container of nodes for which harmonic centrality values are calculated.",
                "sources : container (default: all nodes in G)": "Container of nodesvover which reciprocal distances are computed.\nNodes not inGare silently ignored.",
                "distance : edge attribute key, optional (default=None)": "Use the specified edge attribute as the edge distance in shortest\npath calculations.  IfNone, then each edge will have distance equal to 1."
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of nodes with harmonic centrality as the value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "If the \u2018distance\u2019 keyword is set to an edge attribute key then the\nshortest-path length will be computed using Dijkstra\u2019s algorithm with\nthat edge attribute as the edge weight.",
            "References": "[1]Boldi, Paolo, and Sebastiano Vigna. \u201cAxioms for centrality.\u201d\nInternet Mathematics 10.3-4 (2014): 222-262."
        }
    },
    {
        "Section ID": "pygraphviz_layout",
        "Description": [
            "Create node positions for G using Graphviz."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A graph created with NetworkX",
                "prog : string": "Name of Graphviz layout program",
                "root : string, optional": "Root node for twopi layout",
                "args : string, optional": "Extra arguments to Graphviz layout program"
            },
            "Returns:": {
                "node_pos : dict": "Dictionary of x, y, positions keyed by node."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "If you use complex node objects, they may have the same string\nrepresentation and GraphViz could treat them as the same node.\nThe layout may assign both nodes a single location. See Issue #1568\nIf this occurs in your case, consider relabeling the nodes just\nfor the layout computation using something similar to:",
            "Examples": "G=nx.petersen_graph()\npos=nx.nx_agraph.graphviz_layout(G)\npos=nx.nx_agraph.graphviz_layout(G,prog=\"dot\")"
        }
    },
    {
        "Section ID": "average_clustering",
        "Description": [
            "Estimates the average clustering coefficient of G.",
            "The local clustering of each node in G is the fraction of triangles\nthat actually exist over all possible triangles in its neighborhood.\nThe average clustering coefficient of a graph G is the mean of\nlocal clusterings.",
            "This function finds an approximate average clustering coefficient\nfor G by repeating n times (defined in trials ) the following\nexperiment: choose a node at random, choose two of its neighbors\nat random, and check if they are connected. The approximate\ncoefficient is the fraction of triangles found over the number\nof trials [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "trials : integer": "Number of trials to perform (default 1000).",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "c : float": "Approximated average clustering coefficient."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is directed."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Schank, Thomas, and Dorothea Wagner. Approximating clustering\ncoefficient and transitivity. Universit\u00e4t Karlsruhe, Fakult\u00e4t f\u00fcr\nInformatik, 2004.https://doi.org/10.5445/IR/1000001239",
            "Examples": "fromnetworkx.algorithmsimportapproximation\nG=nx.erdos_renyi_graph(10,0.2,seed=10)\napproximation.average_clustering(G,trials=1000,seed=10)\n# 0.214"
        }
    },
    {
        "Section ID": "circulant_graph",
        "Description": [
            "Returns the circulant graph \\(Ci_n(x_1, x_2, ..., x_m)\\) with \\(n\\) nodes.",
            "The circulant graph \\(Ci_n(x_1, ..., x_m)\\) consists of \\(n\\) nodes \\(0, ..., n-1\\) such that node \\(i\\) is connected to nodes \\((i + x) \\mod n\\) and \\((i - x) \\mod n\\) for all \\(x\\) in \\(x_1, ..., x_m\\) . Thus \\(Ci_n(1)\\) is a cycle graph.",
            "( Sourcecode , png )"
        ],
        "Field List": {
            "Parameters:": {
                "n : integer": "The number of nodes in the graph.",
                "offsets : list of integers": "A list of node offsets,\\(x_1\\)up to\\(x_m\\), as described above.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "NetworkX Graph of type create_using": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "Many well-known graph families are subfamilies of the circulant graphs;\nfor example, to create the cycle graph on n points, we connect every\nnode to nodes on either side (with offset plus or minus one). For n = 10,\nG=nx.circulant_graph(10,[1])\nedges=[\n(0,9),\n(0,1),\n(1,2),\n(2,3),\n(3,4),\n(4,5),\n(5,6),\n(6,7),\n(7,8),\n(8,9),\n]\nsorted(edges)==sorted(G.edges())\n# True\nSimilarly, we can create the complete graph\non 5 points with the set of offsets [1, 2]:\nG=nx.circulant_graph(5,[1,2])\nedges=[\n(0,1),\n(0,2),\n(0,3),\n(0,4),\n(1,2),\n(1,3),\n(1,4),\n(2,3),\n(2,4),\n(3,4),\n]\nsorted(edges)==sorted(G.edges())\n# True"
        }
    },
    {
        "Section ID": "strategy_saturation_largest_first",
        "Description": [
            "Iterates over all the nodes of G in \u201csaturation order\u201d (also\nknown as \u201cDSATUR\u201d).",
            "G is a NetworkX graph. colors is a dictionary mapping nodes of G to colors, for those nodes that have already been colored."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "parse_leda",
        "Description": [
            "Read graph in LEDA format from string or iterable."
        ],
        "Field List": {
            "Parameters:": {
                "lines : string or iterable": "Data in LEDA format."
            },
            "Returns:": {
                "G : NetworkX graph": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]http://www.algorithmic-solutions.info/leda_guide/graphs/leda_native_graph_fileformat.html",
            "Examples": "G=nx.parse_leda(string)"
        }
    },
    {
        "Section ID": "draw_networkx_nodes",
        "Description": [
            "Draw the nodes of the graph G.",
            "This draws only the nodes of the graph G."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph",
                "pos : dictionary": "A dictionary with nodes as keys and positions as values.\nPositions should be sequences of length 2.",
                "ax : Matplotlib Axes object, optional": "Draw the graph in the specified Matplotlib axes.",
                "nodelist : list (default list(G))": "Draw only specified nodes",
                "node_size : scalar or array (default=300)": "Size of nodes.  If an array it must be the same length as nodelist.",
                "node_color : color or array of colors (default=\u2019#1f78b4\u2019)": "Node color. Can be a single color or a sequence of colors with the same\nlength as nodelist. Color can be string or rgb (or rgba) tuple of\nfloats from 0-1. If numeric values are specified they will be\nmapped to colors using the cmap and vmin,vmax parameters. See\nmatplotlib.scatter for more details.",
                "node_shape : string (default=\u2019o\u2019)": "The shape of the node.  Specification is as matplotlib.scatter\nmarker, one of \u2018so^>v<dph8\u2019.",
                "alpha : float or array of floats (default=None)": "The node transparency.  This can be a single alpha value,\nin which case it will be applied to all the nodes of color. Otherwise,\nif it is an array, the elements of alpha will be applied to the colors\nin order (cycling through alpha multiple times if necessary).",
                "cmap : Matplotlib colormap (default=None)": "Colormap for mapping intensities of nodes",
                "vmin,vmax : floats or None (default=None)": "Minimum and maximum for node colormap scaling",
                "linewidths : [None | scalar | sequence] (default=1.0)": "Line width of symbol border",
                "edgecolors : [None | scalar | sequence] (default = node_color)": "Colors of node borders. Can be a single color or a sequence of colors with the\nsame length as nodelist. Color can be string or rgb (or rgba) tuple of floats\nfrom 0-1. If numeric values are specified they will be mapped to colors\nusing the cmap and vmin,vmax parameters. Seescatterfor more details.",
                "label : [None | string]": "Label for legend",
                "margins : float or 2-tuple, optional": "Sets the padding for axis autoscaling. Increase margin to prevent\nclipping for nodes that are near the edges of an image. Values should\nbe in the range[0,1]. Seematplotlib.axes.Axes.margins()for details. The default isNone, which uses the Matplotlib default.",
                "hide_ticks : bool, optional": "Hide ticks of axes. WhenTrue(the default), ticks and ticklabels\nare removed from the axes. To set ticks and tick labels to the pyplot default,\nusehide_ticks=False."
            },
            "Returns:": {
                "matplotlib.collections.PathCollection": "PathCollectionof the nodes."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.dodecahedral_graph()\nnodes=nx.draw_networkx_nodes(G,pos=nx.spring_layout(G))\nAlso see the NetworkX drawing examples athttps://networkx.org/documentation/latest/auto_examples/index.html"
        }
    },
    {
        "Section ID": "is_semieulerian",
        "Description": [
            "Return True iff G is semi-Eulerian.",
            "G is semi-Eulerian if it has an Eulerian path but no Eulerian circuit."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "equitable_color",
        "Description": [
            "Provides an equitable coloring for nodes of G .",
            "Attempts to color a graph using num_colors colors, where no neighbors of\na node can have same color as the node itself and the number of nodes with\neach color differ by at most 1. num_colors must be greater than the\nmaximum degree of G . The algorithm is described in [1] and has\ncomplexity O(num_colors * n**2)."
        ],
        "Field List": {
            "Parameters:": {
                "G : networkX graph": "The nodes of this graph will be colored.",
                "num_colors : number of colors to use": "This number must be at least one more than the maximum degree of nodes\nin the graph."
            },
            "Returns:": {
                "A dictionary with keys representing nodes and values representing": "",
                "corresponding coloring.": ""
            },
            "Raises:": {
                "NetworkXAlgorithmError": "Ifnum_colorsis not at least the maximum degree of the graphG"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Kierstead, H. A., Kostochka, A. V., Mydlarz, M., & Szemer\u00e9di, E.\n(2010). A fast algorithm for equitable coloring. Combinatorica, 30(2),\n217-224.",
            "Examples": "G=nx.cycle_graph(4)\nnx.coloring.equitable_color(G,num_colors=3)\n# {0: 2, 1: 1, 2: 2, 3: 0}"
        }
    },
    {
        "Section ID": "parse_adjlist",
        "Description": [
            "Parse lines of a graph adjacency list representation."
        ],
        "Field List": {
            "Parameters:": {
                "lines : list or iterator of strings": "Input data in adjlist format",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated.",
                "nodetype : Python type, optional": "Convert nodes to this type.",
                "comments : string, optional": "Marker for comment lines",
                "delimiter : string, optional": "Separator for node labels.  The default is whitespace."
            },
            "Returns:": {
                "G: NetworkX graph": "The graph corresponding to the lines in adjacency list format."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "lines=[\"1 2 5\",\"2 3 4\",\"3 5\",\"4\",\"5\"]\nG=nx.parse_adjlist(lines,nodetype=int)\nnodes=[1,2,3,4,5]\nall(nodeinGfornodeinnodes)\n# True\nedges=[(1,2),(1,5),(2,3),(2,4),(3,5)]\nall((u,v)inG.edges()or(v,u)inG.edges()for(u,v)inedges)\n# True"
        }
    },
    {
        "Section ID": "connected_watts_strogatz_graph",
        "Description": [
            "Returns a connected Watts\u2013Strogatz small-world graph.",
            "Attempts to generate a connected graph by repeated generation of\nWatts\u2013Strogatz small-world graphs.  An exception is raised if the maximum\nnumber of tries is exceeded."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes",
                "k : int": "Each node is joined with itsknearest neighbors in a ring\ntopology.",
                "p : float": "The probability of rewiring each edge",
                "tries : int": "Number of attempts to generate a connected graph.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "First create a ring over \\(n\\) nodes [1] .  Then each node in the ring is joined\nto its \\(k\\) nearest neighbors (or \\(k - 1\\) neighbors if \\(k\\) is odd).\nThen shortcuts are created by replacing some edges as follows: for each\nedge \\((u, v)\\) in the underlying \u201c \\(n\\) -ring with \\(k\\) nearest neighbors\u201d\nwith probability \\(p\\) replace it with a new edge \\((u, w)\\) with uniformly\nrandom choice of existing node \\(w\\) .\nThe entire process is repeated until a connected graph results.",
            "References": "[1]Duncan J. Watts and Steven H. Strogatz,\nCollective dynamics of small-world networks,\nNature, 393, pp. 440\u2013442, 1998."
        }
    },
    {
        "Section ID": "intersection_all",
        "Description": [
            "Returns a new graph that contains only the nodes and the edges that exist in\nall graphs."
        ],
        "Field List": {
            "Parameters:": {
                "graphs : iterable": "Iterable of NetworkX graphs"
            },
            "Returns:": {
                "R : A new graph with the same type as the first graph in list": ""
            },
            "Raises:": {
                "ValueError": "Ifgraphsis an empty list.",
                "NetworkXError": "In case of mixed type graphs, like MultiGraph and Graph, or directed and undirected graphs."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For operating on mixed type graphs, they should be converted to the same type. Attributes from the graph, nodes, and edges are not copied to the new\ngraph. The resulting graph can be updated with attributes if desired. For example, code which adds the minimum attribute for each node across all graphs could work.\n>>> g = nx.Graph()\n>>> g.add_node(0, capacity=4)\n>>> g.add_node(1, capacity=3)\n>>> g.add_edge(0, 1)",
            "Examples": "G1=nx.Graph([(1,2),(2,3)])\nG2=nx.Graph([(2,3),(3,4)])\nR=nx.intersection_all([G1,G2])\nlist(R.nodes())\n# [2, 3]\nlist(R.edges())\n# [(2, 3)]"
        }
    },
    {
        "Section ID": "conductance",
        "Description": [
            "Returns the conductance of two sets of nodes.",
            "The conductance is the quotient of the cut size and the smaller of\nthe volumes of the two sets. [1]"
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "S : collection": "A collection of nodes inG.",
                "T : collection": "A collection of nodes inG.",
                "weight : object": "Edge attribute key to use as weight. If not specified, edges\nhave weight one."
            },
            "Returns:": {
                "number": "The conductance between the two setsSandT."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]David Gleich.Hierarchical Directed Spectral Graph Partitioning.\n<https://www.cs.purdue.edu/homes/dgleich/publications/Gleich%202005%20-%20hierarchical%20directed%20spectral.pdf>"
        }
    },
    {
        "Section ID": "random_triad",
        "Description": [
            "Returns a random triad from a directed graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : digraph": "A NetworkX DiGraph",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "G2 : subgraph": "A randomly selected triad (order-3 NetworkX DiGraph)"
            },
            "Raises:": {
                "NetworkXError": "If the input Graph has less than 3 nodes."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.DiGraph([(1,2),(1,3),(2,3),(3,1),(5,6),(5,4),(6,7)])\ntriad=nx.random_triad(G,seed=1)\ntriad.edges\n# OutEdgeView([(1, 2)])"
        }
    },
    {
        "Section ID": "local_edge_connectivity",
        "Description": [
            "Returns local edge connectivity for nodes s and t in G.",
            "Local edge connectivity for two nodes s and t is the minimum number\nof edges that must be removed to disconnect them.",
            "This is a flow based implementation of edge connectivity. We compute the\nmaximum flow on an auxiliary digraph build from the original\nnetwork (see below for details). This is equal to the local edge\nconnectivity because the value of a maximum s-t-flow is equal to the\ncapacity of a minimum s-t-cut (Ford and Fulkerson theorem) [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected or directed graph",
                "s : node": "Source node",
                "t : node": "Target node",
                "flow_func : function": "A function for computing the maximum flow among a pair of nodes.\nThe function has to accept at least three parameters: a Digraph,\na source node, and a target node. And return a residual network\nthat follows NetworkX conventions (seemaximum_flow()for\ndetails). If flow_func is None, the default maximum flow function\n(edmonds_karp()) is used. See below for details. The\nchoice of the default function may change from version\nto version and should not be relied on. Default value: None.",
                "auxiliary : NetworkX DiGraph": "Auxiliary digraph for computing flow based edge connectivity. If\nprovided it will be reused instead of recreated. Default value: None.",
                "residual : NetworkX DiGraph": "Residual network to compute maximum flow. If provided it will be\nreused instead of recreated. Default value: None.",
                "cutoff : integer, float, or None (default: None)": "If specified, the maximum flow algorithm will terminate when the\nflow value reaches or exceeds the cutoff. This only works for flows\nthat support the cutoff parameter (most do) and is ignored otherwise."
            },
            "Returns:": {
                "K : integer": "local edge connectivity for nodes s and t."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This is a flow based implementation of edge connectivity. We compute the\nmaximum flow using, by default, the edmonds_karp() algorithm on an\nauxiliary digraph build from the original input graph: If the input graph is undirected, we replace each edge ( u ,`v`) with\ntwo reciprocal arcs ( u , v ) and ( v , u ) and then we set the attribute\n\u2018capacity\u2019 for each arc to 1. If the input graph is directed we simply\nadd the \u2018capacity\u2019 attribute. This is an implementation of algorithm 1\nin [1] . The maximum flow in the auxiliary network is equal to the local edge\nconnectivity because the value of a maximum s-t-flow is equal to the\ncapacity of a minimum s-t-cut (Ford and Fulkerson theorem).",
            "References": "[1](1,2)Abdol-Hossein Esfahanian. Connectivity Algorithms.http://www.cse.msu.edu/~cse835/Papers/Graph_connectivity_revised.pdf",
            "Examples": "This function is not imported in the base NetworkX namespace, so you\nhave to explicitly import it from the connectivity package:\nfromnetworkx.algorithms.connectivityimportlocal_edge_connectivity\nWe use in this example the platonic icosahedral graph, which has edge\nconnectivity 5.\nG=nx.icosahedral_graph()\nlocal_edge_connectivity(G,0,6)\n# 5\nIf you need to compute local connectivity on several pairs of\nnodes in the same graph, it is recommended that you reuse the\ndata structures that NetworkX uses in the computation: the\nauxiliary digraph for edge connectivity, and the residual\nnetwork for the underlying maximum flow computation.\nExample of how to compute local edge connectivity among\nall pairs of nodes of the platonic icosahedral graph reusing\nthe data structures.\nimportitertools\n# You also have to explicitly import the function for\n# building the auxiliary digraph from the connectivity package\nfromnetworkx.algorithms.connectivityimportbuild_auxiliary_edge_connectivity\nH=build_auxiliary_edge_connectivity(G)\n# And the function for building the residual network from the\n# flow package\nfromnetworkx.algorithms.flowimportbuild_residual_network\n# Note that the auxiliary digraph has an edge attribute named capacity\nR=build_residual_network(H,\"capacity\")\nresult=dict.fromkeys(G,dict())\n# Reuse the auxiliary digraph and the residual network by passing them\n# as parameters\nforu,vinitertools.combinations(G,2):\nk=local_edge_connectivity(G,u,v,auxiliary=H,residual=R)\nresult[u][v]=k\nall(result[u][v]==5foru,vinitertools.combinations(G,2))\n# True\nYou can also use alternative flow algorithms for computing edge\nconnectivity. For instance, in dense networks the algorithmshortest_augmenting_path()will usually perform better than\nthe defaultedmonds_karp()which is faster for sparse\nnetworks with highly skewed degree distributions. Alternative flow\nfunctions have to be explicitly imported from the flow package.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\nlocal_edge_connectivity(G,0,6,flow_func=shortest_augmenting_path)\n# 5"
        }
    },
    {
        "Section ID": "snap_aggregation",
        "Description": [
            "Creates a summary graph based on attributes and connectivity.",
            "This function uses the Summarization by Grouping Nodes on Attributes\nand Pairwise edges (SNAP) algorithm for summarizing a given\ngraph by grouping nodes by node attributes and their edge attributes\ninto supernodes in a summary graph.  This name SNAP should not be\nconfused with the Stanford Network Analysis Project (SNAP).",
            "Here is a high-level view of how this algorithm works:",
            "2) Iteratively split groups until all nodes in each group have edges\nto nodes in the same groups. That is, until all the groups are homogeneous\nin their member nodes\u2019 edges to other groups.  For example,\nif all the nodes in group A only have edge to nodes in group B, then the\ngroup is homogeneous and does not need to be split. If all nodes in group B\nhave edges with nodes in groups {A, C}, but some also have edges with other\nnodes in B, then group B is not homogeneous and needs to be split into\ngroups have edges with {A, C} and a group of nodes having\nedges with {A, B, C}.  This way, viewers of the summary graph can\nassume that all nodes in the group have the exact same node attributes and\nthe exact same edges.",
            "3) Build the output summary graph, where the groups are represented by\nsuper-nodes. Edges represent the edges shared between all the nodes in each\nrespective groups.",
            "A SNAP summary graph can be used to visualize graphs that are too large to display\nor visually analyze, or to efficiently identify sets of similar nodes with similar connectivity\npatterns to other sets of similar nodes based on specified node and/or edge attributes in a graph."
        ],
        "Field List": {
            "Parameters:": {
                "G: graph": "Networkx Graph to be summarized",
                "node_attributes: iterable, required": "An iterable of the node attributes used to group nodes in the summarization process. Nodes\nwith the same values for these attributes will be grouped together in the summary graph.",
                "edge_attributes: iterable, optional": "An iterable of the edge attributes considered in the summarization process.  If provided, unique\ncombinations of the attribute values found in the graph are used to\ndetermine the edge types in the graph.  If not provided, all edges\nare considered to be of the same type.",
                "prefix: str": "The prefix used to denote supernodes in the summary graph. Defaults to \u2018Supernode-\u2018.",
                "supernode_attribute: str": "The node attribute for recording the supernode groupings of nodes. Defaults to \u2018group\u2019.",
                "superedge_attribute: str": "The edge attribute for recording the edge types of multiple edges. Defaults to \u2018types\u2019."
            },
            "Returns:": {
                "networkx.Graph: summary graph": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The summary graph produced is called a maximum Attribute-edge\ncompatible (AR-compatible) grouping.  According to [1] , an\nAR-compatible grouping means that all nodes in each group have the same\nexact node attribute values and the same exact edges and\nedge types to one or more nodes in the same groups.  The maximal\nAR-compatible grouping is the grouping with the minimal cardinality. The AR-compatible grouping is the most detailed grouping provided by\nany of the SNAP algorithms.",
            "References": "[1]Y. Tian, R. A. Hankins, and J. M. Patel. Efficient aggregation\nfor graph summarization. In Proc. 2008 ACM-SIGMOD Int. Conf.\nManagement of Data (SIGMOD\u201908), pages 567\u2013580, Vancouver, Canada,\nJune 2008.",
            "Examples": "SNAP aggregation takes a graph and summarizes it in the context of user-provided\nnode and edge attributes such that a viewer can more easily extract and\nanalyze the information represented by the graph\nnodes={\n\"A\":dict(color=\"Red\"),\n\"B\":dict(color=\"Red\"),\n\"C\":dict(color=\"Red\"),\n\"D\":dict(color=\"Red\"),\n\"E\":dict(color=\"Blue\"),\n\"F\":dict(color=\"Blue\"),\n}\nedges=[\n(\"A\",\"E\",\"Strong\"),\n(\"B\",\"F\",\"Strong\"),\n(\"C\",\"E\",\"Weak\"),\n(\"D\",\"F\",\"Weak\"),\n]\nG=nx.Graph()\nfornodeinnodes:\nattributes=nodes[node]\nG.add_node(node,**attributes)\nforsource,target,typeinedges:\nG.add_edge(source,target,type=type)\nnode_attributes=(\"color\",)\nedge_attributes=(\"type\",)\nsummary_graph=nx.snap_aggregation(\nG,node_attributes=node_attributes,edge_attributes=edge_attributes\n)"
        }
    },
    {
        "Section ID": "average_clustering",
        "Description": [
            "Compute the average clustering coefficient for the graph G.",
            "The clustering coefficient for the graph is the average,",
            "where \\(n\\) is the number of nodes in G ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "",
                "nodes : container of nodes, optional (default=all nodes in G)": "Compute average clustering for nodes in this container.",
                "weight : string or None, optional (default=None)": "The edge attribute that holds the numerical value used as a weight.\nIf None, then each edge has weight 1.",
                "count_zeros : bool": "If False include only the nodes with nonzero clustering in the average."
            },
            "Returns:": {
                "avg : float": "Average clustering"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This is a space saving routine; it might be faster\nto use the clustering function to get a list and then take the average. Self loops are ignored.",
            "References": "[1]Generalizations of the clustering coefficient to weighted\ncomplex networks by J. Saram\u00e4ki, M. Kivel\u00e4, J.-P. Onnela,\nK. Kaski, and J. Kert\u00e9sz, Physical Review E, 75 027105 (2007).http://jponnela.com/web_documents/a9.pdf  [2]Marcus Kaiser,  Mean clustering coefficients: the role of isolated\nnodes and leafs on clustering measures for small-world networks.https://arxiv.org/abs/0802.2512",
            "Examples": "G=nx.complete_graph(5)\nprint(nx.average_clustering(G))\n# 1.0"
        }
    },
    {
        "Section ID": "is_connected",
        "Description": [
            "Returns True if the graph is connected, False otherwise."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "An undirected graph."
            },
            "Returns:": {
                "connected : bool": "True if the graph is connected, false otherwise."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is directed."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For undirected graphs only.",
            "Examples": "G=nx.path_graph(4)\nprint(nx.is_connected(G))\n# True"
        }
    },
    {
        "Section ID": "soft_random_geometric_graph",
        "Description": [
            "Returns a soft random geometric graph in the unit cube.",
            "The soft random geometric graph [1] model places n nodes uniformly at\nrandom in the unit cube in dimension dim . Two nodes of distance, dist ,\ncomputed by the p -Minkowski distance metric are joined by an edge with\nprobability p_dist if the computed distance metric value of the nodes\nis at most radius , otherwise they are not joined.",
            "Edges within radius of each other are determined using a KDTree when\nSciPy is available. This reduces the time complexity from \\(O(n^2)\\) to \\(O(n)\\) ."
        ],
        "Field List": {
            "Parameters:": {
                "n : int or iterable": "Number of nodes or iterable of nodes",
                "radius: float": "Distance threshold value",
                "dim : int, optional": "Dimension of graph",
                "pos : dict, optional": "A dictionary keyed by node with node positions as values.",
                "p : float, optional": "Which Minkowski distance metric to use.phas to meet the condition1<=p<=infinity.If this argument is not specified, the\\(L^2\\)metric\n(the Euclidean distance metric), p = 2 is used.This should not be confused with thepof an Erd\u0151s-R\u00e9nyi random\ngraph, which represents probability.",
                "p_dist : function, optional": "A probability density function computing the probability of\nconnecting two nodes that are of distance, dist, computed by the\nMinkowski distance metric. The probability density function,p_dist,\nmust be any function that takes the metric value as input\nand outputs a single probability value between 0-1. The scipy.stats\npackage has many probability distribution functions implemented and\ntools for custom probability distribution definitions [2], and passing\nthe .pdf method of scipy.stats distributions can be used here.  If the\nprobability function,p_dist, is not supplied, the default function\nis an exponential distribution with rate parameter\\(\\lambda=1\\).",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "pos_name : string, default=\u201dpos\u201d": "The name of the node attribute which represents the position\nin 2D coordinates of the node in the returned graph."
            },
            "Returns:": {
                "Graph": "A soft random geometric graph, undirected and without self-loops.\nEach node has a node attribute'pos'that stores the\nposition of that node in Euclidean space as provided by theposkeyword argument or, ifposwas not provided, as\ngenerated by this function."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This uses a k -d tree to build the graph. The pos keyword argument can be used to specify node positions so you\ncan create an arbitrary distribution and domain for positions. For example, to use a 2D Gaussian distribution of node positions with mean\n(0, 0) and standard deviation 2 The scipy.stats package can be used to define the probability distribution\nwith the .pdf method used as p_dist .",
            "References": "[1]Penrose, Mathew D. \u201cConnectivity of soft random geometric graphs.\u201d\nThe Annals of Applied Probability 26.2 (2016): 986-1028.  [2]scipy.stats -https://docs.scipy.org/doc/scipy/reference/tutorial/stats.html",
            "Examples": "Default Graph:\nG = nx.soft_random_geometric_graph(50, 0.2)\nCustom Graph:\nCreate a soft random geometric graph on 100 uniformly distributed nodes\nwhere nodes are joined by an edge with probability computed from an\nexponential distribution with rate parameter\\(\\lambda=1\\)if their\nEuclidean distance is at most 0.2."
        }
    },
    {
        "Section ID": "k_clique_communities",
        "Description": [
            "Find k-clique communities in graph using the percolation method.",
            "A k-clique community is the union of all cliques of size k that\ncan be reached through adjacent (sharing k-1 nodes) k-cliques."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "k : int": "Size of smallest clique",
                "cliques: list or generator": "Precomputed cliques (use networkx.find_cliques(G))"
            },
            "Returns:": {
                "Yields sets of nodes, one for each k-clique community.": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Gergely Palla, Imre Der\u00e9nyi, Ill\u00e9s Farkas1, and Tam\u00e1s Vicsek,\nUncovering the overlapping community structure of complex networks\nin nature and society Nature 435, 814-818, 2005,\ndoi:10.1038/nature03607",
            "Examples": "G=nx.complete_graph(5)\nK5=nx.convert_node_labels_to_integers(G,first_label=2)\nG.add_edges_from(K5.edges())\nc=list(nx.community.k_clique_communities(G,4))\nsorted(list(c[0]))\n# [0, 1, 2, 3, 4, 5, 6]\nlist(nx.community.k_clique_communities(G,6))\n# []"
        }
    },
    {
        "Section ID": "junction_tree",
        "Description": [
            "Returns a junction tree of a given graph.",
            "A junction tree (or clique tree) is constructed from a (un)directed graph G.\nThe tree is constructed based on a moralized and triangulated version of G.\nThe tree\u2019s nodes consist of maximal cliques and sepsets of the revised graph.\nThe sepset of two cliques is the intersection of the nodes of these cliques,\ne.g. the sepset of (A,B,C) and (A,C,E,F) is (A,C). These nodes are often called\n\u201cvariables\u201d in this literature. The tree is bipartite with each sepset\nconnected to its two cliques.",
            "Junction Trees are not unique as the order of clique consideration determines\nwhich sepsets are included.",
            "The junction tree algorithm consists of five steps [1] :"
        ],
        "Field List": {
            "Parameters:": {
                "G : networkx.Graph": "Directed or undirected graph."
            },
            "Returns:": {
                "junction_tree : networkx.Graph": "The corresponding junction tree ofG."
            },
            "Raises:": {
                "NetworkXNotImplemented": "Raised ifGis an instance ofMultiGraphorMultiDiGraph."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Junction tree algorithm:https://en.wikipedia.org/wiki/Junction_tree_algorithm  [2]Finn V. Jensen and Frank Jensen. 1994. Optimal\njunction trees. In Proceedings of the Tenth international\nconference on Uncertainty in artificial intelligence (UAI\u201994).\nMorgan Kaufmann Publishers Inc., San Francisco, CA, USA, 360\u2013366."
        }
    },
    {
        "Section ID": "read_multiline_adjlist",
        "Description": [
            "Read graph in multi-line adjacency list format from path."
        ],
        "Field List": {
            "Parameters:": {
                "path : string or file": "Filename or file handle to read.\nFilenames ending in .gz or .bz2 will be uncompressed.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated.",
                "nodetype : Python type, optional": "Convert nodes to this type.",
                "edgetype : Python type, optional": "Convert edge data to this type.",
                "comments : string, optional": "Marker for comment lines",
                "delimiter : string, optional": "Separator for node labels.  The default is whitespace."
            },
            "Returns:": {
                "G: NetworkX graph": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This format does not store graph, node, or edge data.",
            "Examples": "G=nx.path_graph(4)\nnx.write_multiline_adjlist(G,\"test.adjlist\")\nG=nx.read_multiline_adjlist(\"test.adjlist\")\nThe path can be a file or a string with the name of the file. If a\nfile s provided, it has to be opened in \u2018rb\u2019 mode.\nfh=open(\"test.adjlist\",\"rb\")\nG=nx.read_multiline_adjlist(fh)\nFilenames ending in .gz or .bz2 will be compressed.\nnx.write_multiline_adjlist(G,\"test.adjlist.gz\")\nG=nx.read_multiline_adjlist(\"test.adjlist.gz\")\nThe optional nodetype is a function to convert node strings to nodetype.\nFor example\nG=nx.read_multiline_adjlist(\"test.adjlist\",nodetype=int)\nwill attempt to convert all nodes to integer type.\nThe optional edgetype is a function to convert edge data strings to\nedgetype.\nG=nx.read_multiline_adjlist(\"test.adjlist\")\nThe optional create_using parameter is a NetworkX graph container.\nThe default is Graph(), an undirected graph.  To read the data as\na directed graph use\nG=nx.read_multiline_adjlist(\"test.adjlist\",create_using=nx.DiGraph)"
        }
    },
    {
        "Section ID": "incidence_matrix",
        "Description": [
            "Returns incidence matrix of G.",
            "The incidence matrix assigns each row to a node and each column to an edge.\nFor a standard incidence matrix a 1 appears wherever a row\u2019s node is\nincident on the column\u2019s edge.  For an oriented incidence matrix each\nedge is assigned an orientation (arbitrarily for undirected and aligning to\ndirection for directed).  A -1 appears for the source (tail) of an edge and\n1 for the destination (head) of the edge.  The elements are zero otherwise."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "nodelist : list, optional   (default= all nodes in G)": "The rows are ordered according to the nodes in nodelist.\nIf nodelist is None, then the ordering is produced by G.nodes().",
                "edgelist : list, optional (default= all edges in G)": "The columns are ordered according to the edges in edgelist.\nIf edgelist is None, then the ordering is produced by G.edges().",
                "oriented: bool, optional (default=False)": "If True, matrix elements are +1 or -1 for the head or tail node\nrespectively of each edge.  If False, +1 occurs at both nodes.",
                "weight : string or None, optional (default=None)": "The edge data key used to provide each value in the matrix.\nIf None, then each edge has weight 1.  Edge weights, if used,\nshould be positive so that the orientation can provide the sign.",
                "dtype : a NumPy dtype or None (default=None)": "The dtype of the output sparse array. This type should be a compatible\ntype of the weight argument, eg. if weight would return a float this\nargument should also be a float.\nIf None, then the default for SciPy is used."
            },
            "Returns:": {
                "A : SciPy sparse array": "The incidence matrix of G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For MultiGraph/MultiDiGraph, the edges in edgelist should be\n(u,v,key) 3-tuples. \u201cNetworks are the best discrete model for so many problems in\napplied mathematics\u201d [1] .",
            "References": "[1]Gil Strang, Network applications: A = incidence matrix,http://videolectures.net/mit18085f07_strang_lec03/"
        }
    },
    {
        "Section ID": "build_auxiliary_node_connectivity",
        "Description": [
            "Creates a directed graph D from an undirected graph G to compute flow\nbased node connectivity.",
            "For an undirected graph G having n nodes and m edges we derive a\ndirected graph D with 2n nodes and 2m+n arcs by replacing each\noriginal node v with two nodes vA , vB linked by an (internal)\narc in D. Then for each edge ( u , v ) in G we add two arcs ( uB , vA )\nand ( vB , uA ) in D. Finally we set the attribute capacity = 1 for each\narc in D [1] .",
            "For a directed graph having n nodes and m arcs we derive a\ndirected graph D with 2n nodes and m+n arcs by replacing each\noriginal node v with two nodes vA , vB linked by an (internal)\narc ( vA , vB ) in D. Then for each arc ( u , v ) in G we add one\narc ( uB , vA ) in D. Finally we set the attribute capacity = 1 for\neach arc in D.",
            "A dictionary with a mapping between nodes in the original graph and the\nauxiliary digraph is stored as a graph attribute: D.graph[\u2018mapping\u2019].",
            "References"
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Kammer, Frank and Hanjo Taubig. Graph Connectivity. in Brandes and\nErlebach, \u2018Network Analysis: Methodological Foundations\u2019, Lecture\nNotes in Computer Science, Volume 3418, Springer-Verlag, 2005.https://doi.org/10.1007/978-3-540-31955-9_7"
        }
    },
    {
        "Section ID": "chordal_cycle_graph",
        "Description": [
            "Returns the chordal cycle graph on p nodes.",
            "The returned graph is a cycle graph on p nodes with chords joining each\nvertex x to its inverse modulo p . This graph is a (mildly explicit)\n3-regular expander [1] .",
            "p  must be a prime number."
        ],
        "Field List": {
            "Parameters:": {
                "p : a prime number": "The number of vertices in the graph. This also indicates where the\nchordal edges in the cycle will be created.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : graph": "The constructed undirected multigraph."
            },
            "Raises:": {
                "NetworkXError": "Ifcreate_usingindicates directed or not a multigraph."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Theorem 4.4.2 in A. Lubotzky. \u201cDiscrete groups, expanding graphs and\ninvariant measures\u201d, volume 125 of Progress in Mathematics.\nBirkh\u00e4user Verlag, Basel, 1994."
        }
    },
    {
        "Section ID": "ArborescenceIterator",
        "Description": [
            "Iterate over all spanning arborescences of a graph in either increasing or\ndecreasing cost.",
            "Notes",
            "This iterator uses the partition scheme from [1] (included edges,\nexcluded edges and open edges). It generates minimum spanning\narborescences using a modified Edmonds\u2019 Algorithm which respects the\npartition of edges. For arborescences with the same weight, ties are\nbroken arbitrarily.",
            "References"
        ],
        "Field List": {
            "Parameters:": {
                "G : nx.DiGraph": "The directed graph which we need to iterate trees over",
                "weight : String, default = \u201cweight\u201d": "The edge attribute used to store the weight of the edge",
                "minimum : bool, default = True": "Return the trees in increasing order while true and decreasing order\nwhile false.",
                "init_partition : tuple, default = None": "In the case that certain edges have to be included or excluded from\nthe arborescences,init_partitionshould be in the form(included_edges,excluded_edges)where each edges is a(u,v)-tuple inside an iterable such as a list or set."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This iterator uses the partition scheme from [1] (included edges,\nexcluded edges and open edges). It generates minimum spanning\narborescences using a modified Edmonds\u2019 Algorithm which respects the\npartition of edges. For arborescences with the same weight, ties are\nbroken arbitrarily.",
            "References": "[1]G.K. Janssens, K. S\u00f6rensen, An algorithm to generate all spanning\ntrees in order of increasing cost, Pesquisa Operacional, 2005-08,\nVol. 25 (2), p. 219-229,https://www.scielo.br/j/pope/a/XHswBwRwJyrfL88dmMwYNWp/?lang=en"
        }
    },
    {
        "Section ID": "make_max_clique_graph",
        "Description": [
            "Returns the maximal clique graph of the given graph.",
            "The nodes of the maximal clique graph of G are the cliques of G and an edge joins two cliques if the cliques are not disjoint."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "NetworkX graph": "A graph whose nodes are the cliques ofGand whose edges\njoin two cliques if they are not disjoint."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This function behaves like the following code:"
        }
    },
    {
        "Section ID": "is_valid_directed_joint_degree",
        "Description": [
            "Checks whether the given directed joint degree input is realizable"
        ],
        "Field List": {
            "Parameters:": {
                "in_degrees : list of integers": "in degree sequence contains the in degrees of nodes.",
                "out_degrees : list of integers": "out degree sequence contains the out degrees of nodes.",
                "nkk : dictionary of dictionary of integers": "directed joint degree dictionary. for nodes of out degree k (first\nlevel of dict) and nodes of in degree l (second level of dict)\ndescribes the number of edges."
            },
            "Returns:": {
                "boolean": "returns true if given input is realizable, else returns false."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Here is the list of conditions that the inputs (in/out degree sequences,\nnkk) need to satisfy for simple directed graph realizability:",
            "References": "[1] B. Tillman, A. Markopoulou, C. T. Butts & M. Gjoka, \u201cConstruction of Directed 2K Graphs\u201d. In Proc. of KDD 2017."
        }
    },
    {
        "Section ID": "common_neighbor_centrality",
        "Description": [
            "Return the CCPA score for each pair of nodes.",
            "Compute the Common Neighbor and Centrality based Parameterized Algorithm(CCPA)\nscore of all node pairs in ebunch.",
            "CCPA score of u and v is defined as",
            "where \\(\\Gamma(u)\\) denotes the set of neighbors of \\(u\\) , \\(\\Gamma(v)\\) denotes the\nset of neighbors of \\(v\\) , \\(\\alpha\\) is  parameter varies between [0,1], \\(N\\) denotes\ntotal number of nodes in the Graph and \\({d}_{uv}\\) denotes shortest distance\nbetween \\(u\\) and \\(v\\) .",
            "This algorithm is based on two vital properties of nodes, namely the number\nof common neighbors and their centrality. Common neighbor refers to the common\nnodes between two nodes. Centrality refers to the prestige that a node enjoys\nin a network."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "NetworkX undirected graph.",
                "ebunch : iterable of node pairs, optional (default = None)": "Preferential attachment score will be computed for each pair of\nnodes given in the iterable. The pairs must be given as\n2-tuples (u, v) where u and v are nodes in the graph. If ebunch\nis None then all nonexistent edges in the graph will be used.\nDefault value: None.",
                "alpha : Parameter defined for participation of Common Neighbor": "and Centrality Algorithm share. Values for alpha should\nnormally be between 0 and 1. Default value set to 0.8\nbecause author found better performance at 0.8 for all the\ndataset.\nDefault value: 0.8"
            },
            "Returns:": {
                "piter : iterator": "An iterator of 3-tuples in the form (u, v, p) where (u, v) is a\npair of nodes and p is their Common Neighbor and Centrality based\nParameterized Algorithm(CCPA) score."
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis aDiGraph, aMultigraphor aMultiDiGraph.",
                "NetworkXAlgorithmError": "If self loops exsists inebunchor inG(ifebunchisNone).",
                "NodeNotFound": "Ifebunchhas a node that is not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Ahmad, I., Akhtar, M.U., Noor, S. et al.\nMissing Link Prediction using Common Neighbor and Centrality based Parameterized Algorithm.\nSci Rep 10, 364 (2020).https://doi.org/10.1038/s41598-019-57304-y",
            "Examples": "G=nx.complete_graph(5)\npreds=nx.common_neighbor_centrality(G,[(0,1),(2,3)])\nforu,v,pinpreds:\nprint(f\"({u}, {v}) -> {p}\")\n# (0, 1) -> 3.4000000000000004\n# (2, 3) -> 3.4000000000000004"
        }
    },
    {
        "Section ID": "rescale_layout",
        "Description": [
            "Returns scaled position array to (-scale, scale) in all axes.",
            "The function acts on NumPy arrays which hold position information.\nEach position is one row of the array. The dimension of the space\nequals the number of columns. Each coordinate in one column.",
            "To rescale, the mean (center) is subtracted from each axis separately.\nThen all values are scaled so that the largest magnitude value\nfrom all axes equals scale (thus, the aspect ratio is preserved).\nThe resulting NumPy Array is returned (order of rows unchanged)."
        ],
        "Field List": {
            "Parameters:": {
                "pos : numpy array": "positions to be scaled. Each row is a position.",
                "scale : number (default: 1)": "The size of the resulting extent in all directions."
            },
            "Returns:": {
                "pos : numpy array": "scaled positions. Each row is a position."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "single_source_dijkstra",
        "Description": [
            "Find shortest weighted paths and lengths from a source node.",
            "Compute the shortest path length between source and all other\nreachable nodes for a weighted graph.",
            "Uses Dijkstra\u2019s algorithm to compute shortest paths and lengths\nbetween a source and all other reachable nodes in a weighted graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node label": "Starting node for path",
                "target : node label, optional": "Ending node for path",
                "cutoff : integer or float, optional": "Length (sum of edge weights) at which the search is stopped.\nIf cutoff is provided, only return paths with summed weight <= cutoff.",
                "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge."
            },
            "Returns:": {
                "distance, path : pair of dictionaries, or numeric and list.": "If target is None, paths and lengths to all nodes are computed.\nThe return value is a tuple of two dictionaries keyed by target nodes.\nThe first dictionary stores distance to each target node.\nThe second stores the path to each target node.\nIf target is not None, returns a tuple (distance, path), where\ndistance is the distance from source to target and path is a list\nrepresenting the path from source to target."
            },
            "Raises:": {
                "NodeNotFound": "Ifsourceis not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The weight function can be used to hide edges by returning None.\nSo weight=lambdau,v,d:1ifd['color']==\"red\"elseNone will find the shortest red path. Based on the Python cookbook recipe (119466) at https://code.activestate.com/recipes/119466/ This algorithm is not guaranteed to work if edge weights\nare negative or are floating point numbers\n(overflows and roundoff errors can cause problems).",
            "Examples": "G=nx.path_graph(5)\nlength,path=nx.single_source_dijkstra(G,0)\nlength[4]\n# 4\nfornodein[0,1,2,3,4]:\nprint(f\"{node}: {length[node]}\")\n# 0: 0\n# 1: 1\n# 2: 2\n# 3: 3\n# 4: 4\npath[4]\n# [0, 1, 2, 3, 4]\nlength,path=nx.single_source_dijkstra(G,0,1)\nlength\n# 1\npath\n# [0, 1]"
        }
    },
    {
        "Section ID": "les_miserables_graph",
        "Description": [
            "Returns coappearance network of characters in the novel Les Miserables.",
            "References"
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]D. E. Knuth, 1993.\nThe Stanford GraphBase: a platform for combinatorial computing,\npp. 74-87. New York: AcM Press."
        }
    },
    {
        "Section ID": "visibility_graph",
        "Description": [
            "Return a Visibility Graph of an input Time Series.",
            "A visibility graph converts a time series into a graph. The constructed graph\nuses integer nodes to indicate which event in the series the node represents.\nEdges are formed as follows: consider a bar plot of the series and view that\nas a side view of a landscape with a node at the top of each bar. An edge\nmeans that the nodes can be connected by a straight \u201cline-of-sight\u201d without\nbeing obscured by any bars between the nodes.",
            "The resulting graph inherits several properties of the series in its structure.\nThereby, periodic series convert into regular graphs, random series convert\ninto random graphs, and fractal series convert into scale-free networks [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "series : Sequence[Number]": "A Time Series sequence (iterable and sliceable) of numeric values\nrepresenting times."
            },
            "Returns:": {
                "NetworkX Graph": "The Visibility Graph of the input series"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Lacasa, Lucas, Bartolo Luque, Fernando Ballesteros, Jordi Luque, and Juan Carlos Nuno.\n\u201cFrom time series to complex networks: The visibility graph.\u201d Proceedings of the\nNational Academy of Sciences 105, no. 13 (2008): 4972-4975.https://www.pnas.org/doi/10.1073/pnas.0709247105",
            "Examples": "series_list=[range(10),[2,1,3,2,1,3,2,1,3,2,1,3]]\nforsinseries_list:\ng=nx.visibility_graph(s)\nprint(g)\n# Graph with 10 nodes and 9 edges\n# Graph with 12 nodes and 18 edges"
        }
    },
    {
        "Section ID": "is_maximal_matching",
        "Description": [
            "Return True if matching is a maximal matching of G",
            "A maximal matching in a graph is a matching in which adding any\nedge would cause the set to no longer be a valid matching."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "matching : dict or set": "A dictionary or set representing a matching. If a dictionary, it\nmust havematching[u]==vandmatching[v]==ufor each\nedge(u,v)in the matching. If a set, it must have elements\nof the form(u,v), where(u,v)is an edge in the\nmatching."
            },
            "Returns:": {
                "bool": "Whether the given set or dictionary represents a valid maximal\nmatching in the graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph([(1,2),(1,3),(2,3),(3,4),(3,5)])\nnx.is_maximal_matching(G,{(1,2),(3,4)})\n# True"
        }
    },
    {
        "Section ID": "spectral_bipartivity",
        "Description": [
            "Returns the spectral bipartivity."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "nodes : list or container  optional(default is all nodes)": "Nodes to return value of spectral bipartivity contribution.",
                "weight : string or None  optional (default = \u2018weight\u2019)": "Edge data key to use for edge weights. If None, weights set to 1."
            },
            "Returns:": {
                "sb : float or dict": "A single number if the keyword nodes is not specified, or\na dictionary keyed by node with the spectral bipartivity contribution\nof that node as the value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This implementation uses Numpy (dense) matrices which are not efficient\nfor storing large sparse graphs.",
            "References": "[1]E. Estrada and J. A. Rodr\u00edguez-Vel\u00e1zquez, \u201cSpectral measures of\nbipartivity in complex networks\u201d, PhysRev E 72, 046105 (2005)",
            "Examples": "fromnetworkx.algorithmsimportbipartite\nG=nx.path_graph(4)\nbipartite.spectral_bipartivity(G)\n# 1.0"
        }
    },
    {
        "Section ID": "louvain_partitions",
        "Description": [
            "Yields partitions for each level of the Louvain Community Detection Algorithm",
            "Louvain Community Detection Algorithm is a simple method to extract the community\nstructure of a network. This is a heuristic method based on modularity optimization. [1]",
            "The partitions at each level (step of the algorithm) form a dendrogram of communities.\nA dendrogram is a diagram representing a tree and each level represents\na partition of the G graph. The top level contains the smallest communities\nand as you traverse to the bottom of the tree the communities get bigger\nand the overall modularity increases making the partition better.",
            "Each level is generated by executing the two phases of the Louvain Community\nDetection Algorithm.",
            "Be careful with self-loops in the input graph. These are treated as\npreviously reduced communities \u2013 as if the process had been started\nin the middle of the algorithm. Large self-loop edge weights thus\nrepresent strong communities and in practice may be hard to add\nother nodes to.  If your input graph edge weights for self-loops\ndo not represent already reduced communities you may want to remove\nthe self-loops before inputting that graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "weight : string or None, optional (default=\u201dweight\u201d)": "The name of an edge attribute that holds the numerical value\nused as a weight. If None then each edge has weight 1.",
                "resolution : float, optional (default=1)": "If resolution is less than 1, the algorithm favors larger communities.\nGreater than 1 favors smaller communities",
                "threshold : float, optional (default=0.0000001)": "Modularity gain threshold for each level. If the gain of modularity\nbetween 2 levels of the algorithm is less than the given threshold\nthen the algorithm stops and returns the resulting communities.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Yields:": {
                "list": "A list of sets (partition ofG). Each set represents one community and contains\nall the nodes that constitute it."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Blondel, V.D. et al. Fast unfolding of communities in\nlarge networks. J. Stat. Mech 10008, 1-12(2008)"
        }
    },
    {
        "Section ID": "find_cycle",
        "Description": [
            "Returns a cycle found via depth-first traversal.",
            "The cycle is a list of edges indicating the cyclic path.\nOrientation of directed edges is controlled by orientation ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A directed/undirected graph/multigraph.",
                "source : node, list of nodes": "The node from which the traversal begins. If None, then a source\nis chosen arbitrarily and repeatedly until all edges from each node in\nthe graph are searched.",
                "orientation : None | \u2018original\u2019 | \u2018reverse\u2019 | \u2018ignore\u2019 (default: None)": "For directed graphs and directed multigraphs, edge traversals need not\nrespect the original orientation of the edges.\nWhen set to \u2018reverse\u2019 every edge is traversed in the reverse direction.\nWhen set to \u2018ignore\u2019, every edge is treated as undirected.\nWhen set to \u2018original\u2019, every edge is treated as directed.\nIn all three cases, the yielded edge tuples add a last entry to\nindicate the direction in which that edge was traversed.\nIf orientation is None, the yielded edge has no direction indicated.\nThe direction is respected, but not reported."
            },
            "Returns:": {
                "edges : directed edges": "A list of directed edges indicating the path taken for the loop.\nIf no cycle is found, then an exception is raised.\nFor graphs, an edge is of the form(u,v)whereuandvare the tail and head of the edge as determined by the traversal.\nFor multigraphs, an edge is of the form(u,v,key), wherekeyis\nthe key of the edge. When the graph is directed, thenuandvare always in the order of the actual directed edge.\nIf orientation is not None then the edge tuple is extended to include\nthe direction of traversal (\u2018forward\u2019 or \u2018reverse\u2019) on that edge."
            },
            "Raises:": {
                "NetworkXNoCycle": "If no cycle was found."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "In this example, we construct a DAG and find, in the first call, that there\nare no directed cycles, and so an exception is raised. In the second call,\nwe ignore edge orientations and find that there is an undirected cycle.\nNote that the second call finds a directed cycle while effectively\ntraversing an undirected graph, and so, we found an \u201cundirected cycle\u201d.\nThis means that this DAG structure does not form a directed tree (which\nis also known as a polytree).\nG=nx.DiGraph([(0,1),(0,2),(1,2)])\nnx.find_cycle(G,orientation=\"original\")Traceback (most recent call last):    ...networkx.exception.NetworkXNoCycleNo cycle found.\nlist(nx.find_cycle(G,orientation=\"ignore\"))\n# [(0, 1, 'forward'), (1, 2, 'forward'), (0, 2, 'reverse')]"
        }
    },
    {
        "Section ID": "is_frozen",
        "Description": [
            "Returns True if graph is frozen."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph"
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "ladder_graph",
        "Description": [
            "Returns the Ladder graph of length n.",
            "This is two paths of n nodes, with\neach pair connected by a single edge.",
            "Node labels are the integers 0 to 2*n - 1.",
            "( Sourcecode , png )"
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "within_inter_cluster",
        "Description": [
            "Compute the ratio of within- and inter-cluster common neighbors\nof all node pairs in ebunch.",
            "For two nodes u and v , if a common neighbor w belongs to the\nsame community as them, w is considered as within-cluster common\nneighbor of u and v . Otherwise, it is considered as\ninter-cluster common neighbor of u and v . The ratio between the\nsize of the set of within- and inter-cluster common neighbors is\ndefined as the WIC measure. [1]"
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX undirected graph.",
                "ebunch : iterable of node pairs, optional (default = None)": "The WIC measure will be computed for each pair of nodes given in\nthe iterable. The pairs must be given as 2-tuples (u, v) where\nu and v are nodes in the graph. If ebunch is None then all\nnonexistent edges in the graph will be used.\nDefault value: None.",
                "delta : float, optional (default = 0.001)": "Value to prevent division by zero in case there is no\ninter-cluster common neighbor between two nodes. See[1]for\ndetails. Default value: 0.001.",
                "community : string, optional (default = \u2018community\u2019)": "Nodes attribute name containing the community information.\nG[u][community] identifies which community u belongs to. Each\nnode belongs to at most one community. Default value: \u2018community\u2019."
            },
            "Returns:": {
                "piter : iterator": "An iterator of 3-tuples in the form (u, v, p) where (u, v) is a\npair of nodes and p is their WIC measure."
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis aDiGraph, aMultigraphor aMultiDiGraph.",
                "NetworkXAlgorithmError": "Ifdeltais less than or equal to zero.If no community information is available for a node inebunchor inG(ifebunchisNone).",
                "NodeNotFound": "Ifebunchhas a node that is not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1](1,2)Jorge Carlos Valverde-Rebaza and Alneu de Andrade Lopes.\nLink prediction in complex networks based on cluster information.\nIn Proceedings of the 21st Brazilian conference on Advances in\nArtificial Intelligence (SBIA\u201912)https://doi.org/10.1007/978-3-642-34459-6_10",
            "Examples": "G=nx.Graph()\nG.add_edges_from([(0,1),(0,2),(0,3),(1,4),(2,4),(3,4)])\nG.nodes[0][\"community\"]=0\nG.nodes[1][\"community\"]=1\nG.nodes[2][\"community\"]=0\nG.nodes[3][\"community\"]=0\nG.nodes[4][\"community\"]=0\npreds=nx.within_inter_cluster(G,[(0,4)])\nforu,v,pinpreds:\nprint(f\"({u}, {v}) -> {p:.8f}\")\n# (0, 4) -> 1.99800200\npreds=nx.within_inter_cluster(G,[(0,4)],delta=0.5)\nforu,v,pinpreds:\nprint(f\"({u}, {v}) -> {p:.8f}\")\n# (0, 4) -> 1.33333333"
        }
    },
    {
        "Section ID": "random_k_out_graph",
        "Description": [
            "Returns a random k -out graph with preferential attachment.",
            "A random k -out graph with preferential attachment is a\nmultidigraph generated by the following algorithm.",
            "For more information on this model of random graph, see [1]."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes in the returned graph.",
                "k : int": "The out-degree of each node in the returned graph.",
                "alpha : float": "A positivefloatrepresenting the initial weight of\neach vertex. A higher number means that in step 3 above, nodes\nwill be chosen more like a true uniformly random sample, and a\nlower number means that nodes are more likely to be chosen as\ntheir in-degree increases. If this parameter is not positive, aValueErroris raised.",
                "self_loops : bool": "If True, self-loops are allowed when generating the graph.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "MultiDiGraph": "Ak-out-regular multidigraph generated according to the above\nalgorithm."
            },
            "Raises:": {
                "ValueError": "Ifalphais not positive."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The returned multidigraph may not be strongly connected, or even\nweakly connected.",
            "References": "[1]: Peterson, Nicholas R., and Boris Pittel. \u201cDistance between two randomk-out digraphs, with and without\npreferential attachment.\u201d\narXiv preprint arXiv:1311.5961 (2013).\n<https://arxiv.org/abs/1311.5961>"
        }
    },
    {
        "Section ID": "LCF_graph",
        "Description": [
            "Return the cubic graph specified in LCF notation.",
            "LCF (Lederberg-Coxeter-Fruchte) notation[R8553aaaa836a-1]_ is a compressed\nnotation used in the generation of various cubic Hamiltonian\ngraphs of high symmetry. See, for example, dodecahedral_graph , desargues_graph , heawood_graph and pappus_graph .",
            "Nodes are drawn from range(n) . Each node n_i is connected with\nnode n_i+shift%n where shift is given by cycling through\nthe input shift_list  repeat s times."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The starting graph is then-cycle with nodes0,...,n-1.\nThe null graph is returned ifn< 1.",
                "shift_list : list": "A list of integer shifts modn,[s1,s2,..,sk]",
                "repeats : int": "Integer specifying the number of times that shifts inshift_listare successively applied to each current node in the n-cycle\nto generate an edge betweenn_currentandn_current+shiftmodn."
            },
            "Returns:": {
                "G : Graph": "A graph instance created from the specified LCF notation."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://en.wikipedia.org/wiki/LCF_notation",
            "Examples": "The utility graph\\(K_{3,3}\\)\nG=nx.LCF_graph(6,[3,-3],3)\nG.edges()\n# EdgeView([(0, 1), (0, 5), (0, 3), (1, 2), (1, 4), (2, 3), (2, 5), (3, 4), (4, 5)])\nThe Heawood graph:\nG=nx.LCF_graph(14,[5,-5],7)\nnx.is_isomorphic(G,nx.heawood_graph())\n# True"
        }
    },
    {
        "Section ID": "to_dict_of_dicts",
        "Description": [
            "Returns adjacency representation of graph as a dictionary of dictionaries."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "nodelist : list": "Use only nodes specified in nodelist",
                "edge_data : scalar, optional": "If provided, the value of the dictionary will be set toedge_datafor\nall edges. Usual values could be1orTrue. Ifedge_dataisNone(the default), the edgedata inGis used, resulting in a\ndict-of-dict-of-dicts. IfGis a MultiGraph, the result will be a\ndict-of-dict-of-dict-of-dicts. See Notes for an approach to customize\nhandling edge data.edge_datashouldnotbe a container."
            },
            "Returns:": {
                "dod : dict": "A nested dictionary representation ofG. Note that the level of\nnesting depends on the type ofGand the value ofedge_data(see Examples)."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For a more custom approach to handling edge data, try:",
            "Examples": "G=nx.path_graph(3)\nnx.to_dict_of_dicts(G)\n# {0: {1: {}}, 1: {0: {}, 2: {}}, 2: {1: {}}}\nEdge data is preserved by default (edge_data=None), resulting\nin dict-of-dict-of-dicts where the innermost dictionary contains the\nedge data:\nG=nx.Graph()\nG.add_edges_from(\n[\n(0,1,{\"weight\":1.0}),\n(1,2,{\"weight\":2.0}),\n(2,0,{\"weight\":1.0}),\n]\n)\nd=nx.to_dict_of_dicts(G)\nd\n# {0: {1: {'weight': 1.0}, 2: {'weight': 1.0}},\n#  1: {0: {'weight': 1.0}, 2: {'weight': 2.0}},\n#  2: {1: {'weight': 2.0}, 0: {'weight': 1.0}}}\nd[1][2][\"weight\"]\n# 2.0\nIfedge_datais notNone, edge data in the original graph (if any) is\nreplaced:\nd=nx.to_dict_of_dicts(G,edge_data=1)\nd\n# {0: {1: 1, 2: 1}, 1: {0: 1, 2: 1}, 2: {1: 1, 0: 1}}\nd[1][2]\n# 1\nThis also applies to MultiGraphs: edge data is preserved by default:\nG=nx.MultiGraph()\nG.add_edge(0,1,key=\"a\",weight=1.0)\n# 'a'\nG.add_edge(0,1,key=\"b\",weight=5.0)\n# 'b'\nd=nx.to_dict_of_dicts(G)\nd\n# {0: {1: {'a': {'weight': 1.0}, 'b': {'weight': 5.0}}},\n#  1: {0: {'a': {'weight': 1.0}, 'b': {'weight': 5.0}}}}\nd[0][1][\"b\"][\"weight\"]\n# 5.0\nBut multi edge data is lost ifedge_datais notNone:\nd=nx.to_dict_of_dicts(G,edge_data=10)\nd\n# {0: {1: 10}, 1: {0: 10}}"
        }
    },
    {
        "Section ID": "create_py_random_state",
        "Description": [
            "Returns a random.Random instance depending on input."
        ],
        "Field List": {
            "Parameters:": {
                "random_state : int or random number generator or None (default=None)": "If int, return arandom.Randominstance set with seed=int.Ifrandom.Randominstance, return it.If None or thenp.randompackage, return the global random number\ngenerator used bynp.random.If annp.random.Generatorinstance, or thenp.randompackage, or\nthe global numpy random number generator, then return it.\nwrapped in aPythonRandomViaNumpyBitsclass.If aPythonRandomViaNumpyBitsinstance, return it.If aPythonRandomInterfaceinstance, return it.If anp.random.RandomStateinstance and not the global numpy default,\nreturn it wrapped inPythonRandomInterfacefor backward bit-stream\nmatching with legacy code."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": ""
        }
    },
    {
        "Section ID": "shortest_path_length",
        "Description": [
            "Compute shortest path lengths in the graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node, optional": "Starting node for path.\nIf not specified, compute shortest path lengths using all nodes as\nsource nodes.",
                "target : node, optional": "Ending node for path.\nIf not specified, compute shortest path lengths using all nodes as\ntarget nodes.",
                "weight : None, string or function, optional (default = None)": "If None, every edge has weight/distance/cost 1.\nIf a string, use this edge attribute as the edge weight.\nAny edge attribute not present defaults to 1.\nIf this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly\nthree positional arguments: the two endpoints of an edge and\nthe dictionary of edge attributes for that edge.\nThe function must return a number.",
                "method : string, optional (default = \u2018dijkstra\u2019)": "The algorithm to use to compute the path length.\nSupported options: \u2018dijkstra\u2019, \u2018bellman-ford\u2019.\nOther inputs produce a ValueError.\nIfweightis None, unweighted graph methods are used, and this\nsuggestion is ignored."
            },
            "Returns:": {
                "length: int or iterator": "If the source and target are both specified, return the length of\nthe shortest path from the source to the target.If only the source is specified, return a dict keyed by target\nto the shortest path length from the source to that target.If only the target is specified, return a dict keyed by source\nto the shortest path length from that source to the target.If neither the source nor target are specified, return an iterator\nover (source, dictionary) where dictionary is keyed by target to\nshortest path length from source to that target."
            },
            "Raises:": {
                "NodeNotFound": "Ifsourceis not inG.",
                "NetworkXNoPath": "If no path exists between source and target.",
                "ValueError": "Ifmethodis not among the supported options."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The length of the path is always 1 less than the number of nodes involved\nin the path since the length measures the number of edges followed. For digraphs this returns the shortest directed path length. To find path\nlengths in the reverse direction use G.reverse(copy=False) first to flip\nthe edge orientation.",
            "Examples": "G=nx.path_graph(5)\nnx.shortest_path_length(G,source=0,target=4)\n# 4\np=nx.shortest_path_length(G,source=0)# target not specified\np[4]\n# 4\np=nx.shortest_path_length(G,target=4)# source not specified\np[0]\n# 4\np=dict(nx.shortest_path_length(G))# source,target not specified\np[0][4]\n# 4"
        }
    },
    {
        "Section ID": "mixing_dict",
        "Description": [
            "Returns a dictionary representation of mixing matrix."
        ],
        "Field List": {
            "Parameters:": {
                "xy : list or container of two-tuples": "Pairs of (x,y) items.",
                "attribute : string": "Node attribute key",
                "normalized : bool (default=False)": "Return counts if False or probabilities if True."
            },
            "Returns:": {
                "d: dictionary": "Counts or Joint probability of occurrence of values in xy."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "out_degree_centrality",
        "Description": [
            "Compute the out-degree centrality for nodes.",
            "The out-degree centrality for a node v is the fraction of nodes its\noutgoing edges are connected to."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph"
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of nodes with out-degree centrality as values."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The degree centrality values are normalized by dividing by the maximum\npossible degree in a simple graph n-1 where n is the number of nodes in G. For multigraphs or graphs with self loops the maximum degree might\nbe higher than n-1 and values of degree centrality greater than 1\nare possible.",
            "Examples": "G=nx.DiGraph([(0,1),(0,2),(0,3),(1,2),(1,3)])\nnx.out_degree_centrality(G)\n# {0: 1.0, 1: 0.6666666666666666, 2: 0.0, 3: 0.0}"
        }
    },
    {
        "Section ID": "read_edgelist",
        "Description": [
            "Read a graph from a list of edges."
        ],
        "Field List": {
            "Parameters:": {
                "path : file or string": "File or filename to read. If a file is provided, it must be\nopened in \u2018rb\u2019 mode.\nFilenames ending in .gz or .bz2 will be uncompressed.",
                "comments : string, optional": "The character used to indicate the start of a comment. To specify that\nno character should be treated as a comment, usecomments=None.",
                "delimiter : string, optional": "The string used to separate values.  The default is whitespace.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated.",
                "nodetype : int, float, str, Python type, optional": "Convert node data from strings to specified type",
                "data : bool or list of (label,type) tuples": "Tuples specifying dictionary key names and types for edge data",
                "edgetype : int, float, str, Python type, optional OBSOLETE": "Convert edge data from strings to specified type and use as \u2018weight\u2019",
                "encoding: string, optional": "Specify which encoding to use when reading file."
            },
            "Returns:": {
                "G : graph": "A networkx Graph or other type specified with create_using"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Since nodes must be hashable, the function nodetype must return hashable\ntypes (e.g. int, float, str, frozenset - or tuples of those, etc.)",
            "Examples": "nx.write_edgelist(nx.path_graph(4),\"test.edgelist\")\nG=nx.read_edgelist(\"test.edgelist\")\nfh=open(\"test.edgelist\",\"rb\")\nG=nx.read_edgelist(fh)\nfh.close()\nG=nx.read_edgelist(\"test.edgelist\",nodetype=int)\nG=nx.read_edgelist(\"test.edgelist\",create_using=nx.DiGraph)\nEdgelist with data in a list:\ntextline=\"1 2 3\"\nfh=open(\"test.edgelist\",\"w\")\nd=fh.write(textline)\nfh.close()\nG=nx.read_edgelist(\"test.edgelist\",nodetype=int,data=((\"weight\",float),))\nlist(G)\n# [1, 2]\nlist(G.edges(data=True))\n# [(1, 2, {'weight': 3.0})]\nSee parse_edgelist() for more examples of formatting."
        }
    },
    {
        "Section ID": "tutte_polynomial",
        "Description": [
            "Returns the Tutte polynomial of G",
            "This function computes the Tutte polynomial via an iterative version of\nthe deletion-contraction algorithm.",
            "The Tutte polynomial T_G(x,y) is a fundamental graph polynomial invariant in\ntwo variables. It encodes a wide array of information related to the\nedge-connectivity of a graph; \u201cMany problems about graphs can be reduced to\nproblems of finding and evaluating the Tutte polynomial at certain values\u201d [1] .\nIn fact, every deletion-contraction-expressible feature of a graph is a\nspecialization of the Tutte polynomial [2] (see Notes for examples).",
            "There are several equivalent definitions; here are three:",
            "Def 1 (rank-nullity expansion): For G an undirected graph, n(G) the\nnumber of vertices of G , E the edge set of G , V the vertex set of G , and c(A) the number of connected components of the graph with vertex\nset V and edge set A  [3] :",
            "Def 2 (spanning tree expansion): Let G be an undirected graph, T a spanning\ntree of G , and E the edge set of G . Let E have an arbitrary strict\nlinear order L . Let B_e be the unique minimal nonempty edge cut of \\(E \\setminus T \\cup {e}\\) . An edge e is internally active with respect to T and L if e is the least edge in B_e according to the linear order L . The internal activity of T (denoted i(T) ) is the number of edges\nin \\(E \\setminus T\\) that are internally active with respect to T and L .\nLet P_e be the unique path in \\(T \\cup {e}\\) whose source and target vertex\nare the same. An edge e is externally active with respect to T and L if e is the least edge in P_e according to the linear order L . The\nexternal activity of T (denoted e(T) ) is the number of edges in \\(E \\setminus T\\) that are externally active with respect to T and L .\nThen [4]  [5] :",
            "Def 3 (deletion-contraction recurrence): For G an undirected graph, G-e the graph obtained from G by deleting edge e , G/e the graph obtained\nfrom G by contracting edge e , k(G) the number of cut-edges of G ,\nand l(G) the number of self-loops of G :"
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": ""
            },
            "Returns:": {
                "instance of : sympy.core.add.Add": "A Sympy expression representing the Tutte polynomial forG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Some specializations of the Tutte polynomial:",
            "References": "[1]M. Brandt,\n\u201cThe Tutte Polynomial.\u201d\nTalking About Combinatorial Objects Seminar, 2015https://math.berkeley.edu/~brandtm/talks/tutte.pdf  [2]A. Bj\u00f6rklund, T. Husfeldt, P. Kaski, M. Koivisto,\n\u201cComputing the Tutte polynomial in vertex-exponential time\u201d\n49th Annual IEEE Symposium on Foundations of Computer Science, 2008https://ieeexplore.ieee.org/abstract/document/4691000  [3]Y. Shi, M. Dehmer, X. Li, I. Gutman,\n\u201cGraph Polynomials,\u201d p. 14  [4]Y. Shi, M. Dehmer, X. Li, I. Gutman,\n\u201cGraph Polynomials,\u201d p. 46  [5]A. Ne\u0161etril, J. Goodall,\n\u201cGraph invariants, homomorphisms, and the Tutte polynomial\u201dhttps://iuuk.mff.cuni.cz/~andrew/Tutte.pdf  [6]D. B. West,\n\u201cIntroduction to Graph Theory,\u201d p. 84  [7]G. Coutinho,\n\u201cA brief introduction to the Tutte polynomial\u201d\nStructural Analysis of Complex Networks, 2011https://homepages.dcc.ufmg.br/~gabriel/seminars/coutinho_tuttepolynomial_seminar.pdf  [8]J. A. Ellis-Monaghan, C. Merino,\n\u201cGraph polynomials and their applications I: The Tutte polynomial\u201d\nStructural Analysis of Complex Networks, 2011https://arxiv.org/pdf/0803.3079.pdf",
            "Examples": "C=nx.cycle_graph(5)\nnx.tutte_polynomial(C)\n# x**4 + x**3 + x**2 + x + y\nD=nx.diamond_graph()\nnx.tutte_polynomial(D)\n# x**3 + 2*x**2 + 2*x*y + x + y**2 + y"
        }
    },
    {
        "Section ID": "is_path",
        "Description": [
            "Returns whether or not the specified path exists.",
            "For it to return True, every node on the path must exist and\neach consecutive pair must be connected via one or more edges."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.",
                "path : list": "A list of nodes which defines the path to traverse"
            },
            "Returns:": {
                "bool": "True ifpathis a valid path inG"
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "random_regular_graph",
        "Description": [
            "Returns a random \\(d\\) -regular graph on \\(n\\) nodes.",
            "A regular graph is a graph where each node has the same number of neighbors.",
            "The resulting graph has no self-loops or parallel edges."
        ],
        "Field List": {
            "Parameters:": {
                "d : int": "The degree of each node.",
                "n : integer": "The number of nodes. The value of\\(n \\times d\\)must be even.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Raises:": {
                "NetworkXError": "If\\(n \\times d\\)is odd or\\(d\\)is greater than or equal to\\(n\\)."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The nodes are numbered from \\(0\\) to \\(n - 1\\) . Kim and Vu\u2019s paper [2] shows that this algorithm samples in an\nasymptotically uniform way from the space of random graphs when \\(d = O(n^{1 / 3 - \\epsilon})\\) .",
            "References": "[1]A. Steger and N. Wormald,\nGenerating random regular graphs quickly,\nProbability and Computing 8 (1999), 377-396, 1999.https://doi.org/10.1017/S0963548399003867  [2]Jeong Han Kim and Van H. Vu,\nGenerating random regular graphs,\nProceedings of the thirty-fifth ACM symposium on Theory of computing,\nSan Diego, CA, USA, pp 213\u2013222, 2003.http://portal.acm.org/citation.cfm?id=780542.780576"
        }
    },
    {
        "Section ID": "radius",
        "Description": [
            "Returns the radius of the graph G.",
            "The radius is the minimum eccentricity."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A graph",
                "e : eccentricity dictionary, optional": "A precomputed dictionary of eccentricities.",
                "weight : string, function, or None": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number.If this is None, every edge has weight/distance/cost 1.Weights stored as floating point values can lead to small round-off\nerrors in distances. Use integer weights to avoid this.Weights should be positive, since they are distances."
            },
            "Returns:": {
                "r : integer": "Radius of graph"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph([(1,2),(1,3),(1,4),(3,4),(3,5),(4,5)])\nnx.radius(G)\n# 2"
        }
    },
    {
        "Section ID": "normalized_cut_size",
        "Description": [
            "Returns the normalized size of the cut between two sets of nodes.",
            "The normalized cut size is the cut size times the sum of the\nreciprocal sizes of the volumes of the two sets. [1]"
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "S : collection": "A collection of nodes inG.",
                "T : collection": "A collection of nodes inG.",
                "weight : object": "Edge attribute key to use as weight. If not specified, edges\nhave weight one."
            },
            "Returns:": {
                "number": "The normalized cut size between the two setsSandT."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "In a multigraph, the cut size is the total weight of edges including\nmultiplicity.",
            "References": "[1]David Gleich.Hierarchical Directed Spectral Graph Partitioning.\n<https://www.cs.purdue.edu/homes/dgleich/publications/Gleich%202005%20-%20hierarchical%20directed%20spectral.pdf>"
        }
    },
    {
        "Section ID": "generic_graph_view",
        "Description": [
            "Returns a read-only view of G .",
            "The graph G and its attributes are not copied but viewed through the new graph object\nof the same class as G (or of the class specified in create_using )."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A directed/undirected graph/multigraph.",
                "create_using : NetworkX graph constructor, optional (default=None)": "Graph type to create. If graph instance, then cleared before populated.\nIfNone, then the appropriate Graph type is inferred fromG."
            },
            "Returns:": {
                "newG : graph": "A view of the input graphGand its attributes as viewed through\nthecreate_usingclass."
            },
            "Raises:": {
                "NetworkXError": "IfGis a multigraph (or multidigraph) butcreate_usingis not, or vice versa."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The returned graph view is read-only (cannot modify the graph).\nYet the view reflects any changes in G . The intent is to mimic dict views.",
            "Examples": "G=nx.Graph()\nG.add_edge(1,2,weight=0.3)\nG.add_edge(2,3,weight=0.5)\nG.edges(data=True)\n# EdgeDataView([(1, 2, {'weight': 0.3}), (2, 3, {'weight': 0.5})])\nThe view exposes the attributes from the original graph.\nviewG=nx.graphviews.generic_graph_view(G)\nviewG.edges(data=True)\n# EdgeDataView([(1, 2, {'weight': 0.3}), (2, 3, {'weight': 0.5})])\nChanges toGare reflected inviewG.\nG.remove_edge(2,3)\nG.edges(data=True)\n# EdgeDataView([(1, 2, {'weight': 0.3})])\nviewG.edges(data=True)\n# EdgeDataView([(1, 2, {'weight': 0.3})])\nWe can change the graph type with thecreate_usingparameter.\ntype(G)\n# <class 'networkx.classes.graph.Graph'>\nviewDG=nx.graphviews.generic_graph_view(G,create_using=nx.DiGraph)\ntype(viewDG)\n# <class 'networkx.classes.digraph.DiGraph'>"
        }
    },
    {
        "Section ID": "UnionAdjacency",
        "Description": [
            "A read-only union of dict Adjacencies as a Map of Maps of Maps.",
            "The two input dict-of-dict-of-dicts represent the union of G.succ and G.pred . Return values are UnionAtlas\nThe inner level of dict is read-write. But the\nmiddle and outer levels are read-only.",
            "succ : a dict-of-dict-of-dict {node: nbrdict}\npred : a dict-of-dict-of-dict {node: nbrdict}\nThe keys for the two dicts should be the same"
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "create_empty_copy",
        "Description": [
            "Returns a copy of the graph G with all of the edges removed."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "with_data : bool (default=True)": "Propagate Graph and Nodes data to the new graph."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "dense_gnm_random_graph",
        "Description": [
            "Returns a \\(G_{n,m}\\) random graph.",
            "In the \\(G_{n,m}\\) model, a graph is chosen uniformly at random from the set\nof all graphs with \\(n\\) nodes and \\(m\\) edges.",
            "This algorithm should be faster than gnm_random_graph() for dense\ngraphs."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes.",
                "m : int": "The number of edges.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Algorithm by Keith M. Briggs Mar 31, 2006.\nInspired by Knuth\u2019s Algorithm S (Selection sampling technique),\nin section 3.4.2 of [1] .",
            "References": "[1]Donald E. Knuth, The Art of Computer Programming,\nVolume 2/Seminumerical algorithms, Third Edition, Addison-Wesley, 1997."
        }
    },
    {
        "Section ID": "could_be_isomorphic",
        "Description": [
            "Returns False if graphs are definitely not isomorphic.\nTrue does NOT guarantee isomorphism."
        ],
        "Field List": {
            "Parameters:": {
                "G1, G2 : graphs": "The two graphs G1 and G2 must be the same type."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Checks for matching degree, triangle, and number of cliques sequences.\nThe triangle sequence contains the number of triangles each node is part of.\nThe clique sequence contains for each node the number of maximal cliques\ninvolving that node."
        }
    },
    {
        "Section ID": "average_shortest_path_length",
        "Description": [
            "Returns the average shortest path length.",
            "The average shortest path length is",
            "where V is the set of nodes in G , d(s,t) is the shortest path from s to t ,\nand n is the number of nodes in G ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "weight : None, string or function, optional (default = None)": "If None, every edge has weight/distance/cost 1.\nIf a string, use this edge attribute as the edge weight.\nAny edge attribute not present defaults to 1.\nIf this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly\nthree positional arguments: the two endpoints of an edge and\nthe dictionary of edge attributes for that edge.\nThe function must return a number.",
                "method : string, optional (default = \u2018unweighted\u2019 or \u2018dijkstra\u2019)": "The algorithm to use to compute the path lengths.\nSupported options are \u2018unweighted\u2019, \u2018dijkstra\u2019, \u2018bellman-ford\u2019,\n\u2018floyd-warshall\u2019 and \u2018floyd-warshall-numpy\u2019.\nOther method values produce a ValueError.\nThe default method is \u2018unweighted\u2019 ifweightis None,\notherwise the default method is \u2018dijkstra\u2019."
            },
            "Raises:": {
                "NetworkXPointlessConcept": "IfGis the null graph (that is, the graph on zero nodes).",
                "NetworkXError": "IfGis not connected (or not strongly connected, in the case\nof a directed graph).",
                "ValueError": "Ifmethodis not among the supported options."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.path_graph(5)\nnx.average_shortest_path_length(G)\n# 2.0\nFor disconnected graphs, you can compute the average shortest path\nlength for each component\nG=nx.Graph([(1,2),(3,4)])\nforCin(G.subgraph(c).copy()forcinnx.connected_components(G)):\nprint(nx.average_shortest_path_length(C))\n# 1.0\n# 1.0"
        }
    },
    {
        "Section ID": "number_of_spanning_trees",
        "Description": [
            "Returns the number of spanning trees in G .",
            "A spanning tree for an undirected graph is a tree that connects\nall nodes in the graph. For a directed graph, the analog of a\nspanning tree is called a (spanning) arborescence. The arborescence\nincludes a unique directed path from the root node to each other node.\nThe graph must be weakly connected, and the root must be a node\nthat includes all nodes as successors [3] . Note that to avoid\ndiscussing sink-roots and reverse-arborescences, we have reversed\nthe edge orientation from [3] and use the in-degree laplacian.",
            "This function (when weight is None ) returns the number of\nspanning trees for an undirected graph and the number of\narborescences from a single root node for a directed graph.\nWhen weight is the name of an edge attribute which holds the\nweight value of each edge, the function returns the sum over\nall trees of the multiplicative weight of each tree. That is,\nthe weight of the tree is the product of its edge weights.",
            "Kirchoff\u2019s Tree Matrix Theorem states that any cofactor of the\nLaplacian matrix of a graph is the number of spanning trees in the\ngraph. (Here we use cofactors for a diagonal entry so that the\ncofactor becomes the determinant of the matrix with one row\nand its matching column removed.) For a weighted Laplacian matrix,\nthe cofactor is the sum across all spanning trees of the\nmultiplicative weight of each tree. That is, the weight of each\ntree is the product of its edge weights. The theorem is also\nknown as Kirchhoff\u2019s theorem [1] and the Matrix-Tree theorem [2] .",
            "For directed graphs, a similar theorem (Tutte\u2019s Theorem) holds with\nthe cofactor chosen to be the one with row and column removed that\ncorrespond to the root. The cofactor is the number of arborescences\nwith the specified node as root. And the weighted version gives the\nsum of the arborescence weights with root root . The arborescence\nweight is the product of its edge weights."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "root : node": "A node in the directed graphGthat has all nodes as descendants.\n(This is ignored for undirected graphs.)",
                "weight : string or None, optional (default=None)": "The name of the edge attribute holding the edge weight.\nIfNone, then each edge is assumed to have a weight of 1."
            },
            "Returns:": {
                "Number": "Undirected graphs:The number of spanning trees of the graphG.\nOr the sum of all spanning tree weights of the graphGwhere the weight of a tree is the product of its edge weights.Directed graphs:The number of arborescences ofGrooted at noderoot.\nOr the sum of all arborescence weights of the graphGwith\nspecified root where the weight of an arborescence is the product\nof its edge weights.",
                "Undirected graphs:": "The number of spanning trees of the graphG.\nOr the sum of all spanning tree weights of the graphGwhere the weight of a tree is the product of its edge weights.",
                "Directed graphs:": "The number of arborescences ofGrooted at noderoot.\nOr the sum of all arborescence weights of the graphGwith\nspecified root where the weight of an arborescence is the product\nof its edge weights."
            },
            "Raises:": {
                "NetworkXPointlessConcept": "IfGdoes not contain any nodes.",
                "NetworkXError": "If the graphGis directed and the root node\nis not specified or is not in G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Self-loops are excluded. Multi-edges are contracted in one edge\nequal to the sum of the weights.",
            "References": "[1]Wikipedia\n\u201cKirchhoff\u2019s theorem.\u201dhttps://en.wikipedia.org/wiki/Kirchhoff%27s_theorem  [2]Kirchhoff, G. R.\n\u00dcber die Aufl\u00f6sung der Gleichungen, auf welche man\nbei der Untersuchung der linearen Vertheilung\nGalvanischer Str\u00f6me gef\u00fchrt wird\nAnnalen der Physik und Chemie, vol. 72, pp. 497-508, 1847.  [3](1,2)Margoliash, J.\n\u201cMatrix-Tree Theorem for Directed Graphs\u201dhttps://www.math.uchicago.edu/~may/VIGRE/VIGRE2010/REUPapers/Margoliash.pdf",
            "Examples": "G=nx.complete_graph(5)\nround(nx.number_of_spanning_trees(G))\n# 125\nG=nx.Graph()\nG.add_edge(1,2,weight=2)\nG.add_edge(1,3,weight=1)\nG.add_edge(2,3,weight=1)\nround(nx.number_of_spanning_trees(G,weight=\"weight\"))\n# 5"
        }
    },
    {
        "Section ID": "random_geometric_graph",
        "Description": [
            "Returns a random geometric graph in the unit cube of dimensions dim .",
            "The random geometric graph model places n nodes uniformly at\nrandom in the unit cube. Two nodes are joined by an edge if the\ndistance between the nodes is at most radius .",
            "Edges are determined using a KDTree when SciPy is available.\nThis reduces the time complexity from \\(O(n^2)\\) to \\(O(n)\\) ."
        ],
        "Field List": {
            "Parameters:": {
                "n : int or iterable": "Number of nodes or iterable of nodes",
                "radius: float": "Distance threshold value",
                "dim : int, optional": "Dimension of graph",
                "pos : dict, optional": "A dictionary keyed by node with node positions as values.",
                "p : float, optional": "Which Minkowski distance metric to use.phas to meet the condition1<=p<=infinity.If this argument is not specified, the\\(L^2\\)metric\n(the Euclidean distance metric), p = 2 is used.\nThis should not be confused with thepof an Erd\u0151s-R\u00e9nyi random\ngraph, which represents probability.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "pos_name : string, default=\u201dpos\u201d": "The name of the node attribute which represents the position\nin 2D coordinates of the node in the returned graph."
            },
            "Returns:": {
                "Graph": "A random geometric graph, undirected and without self-loops.\nEach node has a node attribute'pos'that stores the\nposition of that node in Euclidean space as provided by theposkeyword argument or, ifposwas not provided, as\ngenerated by this function."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This uses a k -d tree to build the graph. The pos keyword argument can be used to specify node positions so you\ncan create an arbitrary distribution and domain for positions. For example, to use a 2D Gaussian distribution of node positions with mean\n(0, 0) and standard deviation 2:",
            "References": "[1]Penrose, Mathew,Random Geometric Graphs,\nOxford Studies in Probability, 5, 2003.",
            "Examples": "Create a random geometric graph on twenty nodes where nodes are joined by\nan edge if their distance is at most 0.1:\nG=nx.random_geometric_graph(20,0.1)"
        }
    },
    {
        "Section ID": "wiener_index",
        "Description": [
            "Returns the Wiener index of the given graph.",
            "The Wiener index of a graph is the sum of the shortest-path\n(weighted) distances between each pair of reachable nodes.\nFor pairs of nodes in undirected graphs, only one orientation\nof the pair is counted."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "weight : string or None, optional (default: None)": "If None, every edge has weight 1.\nIf a string, use this edge attribute as the edge weight.\nAny edge attribute not present defaults to 1.\nThe edge weights are used to computing shortest-path distances."
            },
            "Returns:": {
                "number": "The Wiener index of the graphG."
            },
            "Raises:": {
                "NetworkXError": "If the graphGis not connected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "If a pair of nodes is not reachable, the distance is assumed to be\ninfinity. This means that for graphs that are not\nstrongly-connected, this function returns inf . The Wiener index is not usually defined for directed graphs, however\nthis function uses the natural generalization of the Wiener index to\ndirected graphs.",
            "References": "[1]Wikipedia: Wiener Index",
            "Examples": "The Wiener index of the (unweighted) complete graph onnnodes\nequals the number of pairs of thennodes, since each pair of\nnodes is at distance one:\nn=10\nG=nx.complete_graph(n)\nnx.wiener_index(G)==n*(n-1)/2\n# True\nGraphs that are not strongly-connected have infinite Wiener index:\nG=nx.empty_graph(2)\nnx.wiener_index(G)\n# inf"
        }
    },
    {
        "Section ID": "symmetric_difference",
        "Description": [
            "Returns new graph with edges that exist in either G or H but not both.",
            "The node sets of H and G must be the same."
        ],
        "Field List": {
            "Parameters:": {
                "G,H : graph": "A NetworkX graph.  G and H must have the same node sets."
            },
            "Returns:": {
                "D : A new graph with the same type as G.": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Attributes from the graph, nodes, and edges are not copied to the new\ngraph.",
            "Examples": "G=nx.Graph([(0,1),(0,2),(1,2),(1,3)])\nH=nx.Graph([(0,1),(1,2),(0,3)])\nR=nx.symmetric_difference(G,H)\nR.nodes\n# NodeView((0, 1, 2, 3))\nR.edges\n# EdgeView([(0, 2), (0, 3), (1, 3)])"
        }
    },
    {
        "Section ID": "MappedQueue",
        "Description": [
            "The MappedQueue class implements a min-heap with removal and update-priority.",
            "The min heap uses heapq as well as custom written _siftup and _siftdown\nmethods to allow the heap positions to be tracked by an additional dict\nkeyed by element to position. The smallest element can be popped in O(1) time,\nnew elements can be pushed in O(log n) time, and any element can be removed\nor updated in O(log n) time. The queue cannot contain duplicate elements\nand an attempt to push an element already in the queue will have no effect.",
            "MappedQueue complements the heapq package from the python standard\nlibrary. While MappedQueue is designed for maximum compatibility with\nheapq, it adds element removal, lookup, and priority update."
        ],
        "Field List": {
            "Parameters:": {
                "data : dict or iterable": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2001).\nIntroduction to algorithms second edition.  [2]Knuth, D. E. (1997). The art of computer programming (Vol. 3).\nPearson Education.",
            "Examples": "AMappedQueuecan be created empty, or optionally, given a dictionary\nof initial elements and priorities.  The methodspush,pop,remove, andupdateoperate on the queue.\ncolors_nm={\"red\":665,\"blue\":470,\"green\":550}\nq=MappedQueue(colors_nm)\nq.remove(\"red\")\nq.update(\"green\",\"violet\",400)\nq.push(\"indigo\",425)\n# True\n[q.pop().elementforiinrange(len(q.heap))]\n# ['violet', 'indigo', 'blue']\nAMappedQueuecan also be initialized with a list or other iterable. The priority is assumed\nto be the sort order of the items in the list.\nq=MappedQueue([916,50,4609,493,237])\nq.remove(493)\nq.update(237,1117)\n[q.pop()foriinrange(len(q.heap))]\n# [50, 916, 1117, 4609]\nAn exception is raised if the elements are not comparable.\nq=MappedQueue([100,\"a\"])Traceback (most recent call last):...TypeError'<' not supported between instances of 'int' and 'str'\nTo avoid the exception, use a dictionary to assign priorities to the elements.\nq=MappedQueue({100:0,\"a\":1})"
        }
    },
    {
        "Section ID": "spring_layout",
        "Description": [
            "Position nodes using Fruchterman-Reingold force-directed algorithm.",
            "The algorithm simulates a force-directed representation of the network\ntreating edges as springs holding nodes close, while treating nodes\nas repelling objects, sometimes called an anti-gravity force.\nSimulation continues until the positions are close to an equilibrium.",
            "There are some hard-coded values: minimal distance between\nnodes (0.01) and \u201ctemperature\u201d of 0.1 to ensure nodes don\u2019t fly away.\nDuring the simulation, k helps determine the distance between nodes,\nthough scale and center determine the size and place after\nrescaling occurs at the end of the simulation.",
            "Fixing some nodes doesn\u2019t allow them to move in the simulation.\nIt also turns off the rescaling feature at the simulation\u2019s end.\nIn addition, setting scale to None turns off rescaling."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph or list of nodes": "A position will be assigned to every node in G.",
                "k : float (default=None)": "Optimal distance between nodes.  If None the distance is set to\n1/sqrt(n) where n is the number of nodes.  Increase this value\nto move nodes farther apart.",
                "pos : dict or None  optional (default=None)": "Initial positions for nodes as a dictionary with node as keys\nand values as a coordinate list or tuple.  If None, then use\nrandom initial positions.",
                "fixed : list or None  optional (default=None)": "Nodes to keep fixed at initial position.\nNodes not inG.nodesare ignored.\nValueError raised iffixedspecified andposnot.",
                "iterations : int  optional (default=50)": "Maximum number of iterations taken",
                "threshold: float optional (default = 1e-4)": "Threshold for relative error in node position changes.\nThe iteration stops if the error is below this threshold.",
                "weight : string or None   optional (default=\u2019weight\u2019)": "The edge attribute that holds the numerical value used for\nthe edge weight.  Larger means a stronger attractive force.\nIf None, then all edge weights are 1.",
                "scale : number or None (default: 1)": "Scale factor for positions. Not used unlessfixedisNone.\nIf scale is None, no rescaling is performed.",
                "center : array-like or None": "Coordinate pair around which to center the layout.\nNot used unlessfixedisNone.",
                "dim : int": "Dimension of layout.",
                "seed : int, RandomState instance or None  optional (default=None)": "Set the random state for deterministic node layouts.\nIf int,seedis the seed used by the random number generator,\nif numpy.random.RandomState instance,seedis the random\nnumber generator,\nif None, the random number generator is the RandomState instance used\nby numpy.random."
            },
            "Returns:": {
                "pos : dict": "A dictionary of positions keyed by node"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.path_graph(4)\npos=nx.spring_layout(G)\n# The same using longer but equivalent function name\n>>> pos = nx.fruchterman_reingold_layout(G)"
        }
    },
    {
        "Section ID": "number_of_nonisomorphic_trees",
        "Description": [
            "Returns the number of nonisomorphic trees"
        ],
        "Field List": {
            "Parameters:": {
                "order : int": "order of the desired tree(s)"
            },
            "Returns:": {
                "length : Number of nonisomorphic graphs for the given order": ""
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "degree_histogram",
        "Description": [
            "Returns a list of the frequency of each degree value."
        ],
        "Field List": {
            "Parameters:": {
                "G : Networkx graph": "A graph"
            },
            "Returns:": {
                "hist : list": "A list of frequencies of degrees.\nThe degree values are the index in the list."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Note: the bins are width one, hence len(list) can be large\n(Order(number_of_edges))"
        }
    },
    {
        "Section ID": "local_efficiency",
        "Description": [
            "Returns the average local efficiency of the graph.",
            "The efficiency of a pair of nodes in a graph is the multiplicative\ninverse of the shortest path distance between the nodes. The local\nefficiency of a node in the graph is the average global efficiency of the\nsubgraph induced by the neighbors of the node. The average local\nefficiency is the average of the local efficiencies of each node [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : networkx.Graph": "An undirected graph for which to compute the average local efficiency."
            },
            "Returns:": {
                "float": "The average local efficiency of the graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weights are ignored when computing the shortest path distances.",
            "References": "[1]Latora, Vito, and Massimo Marchiori.\n\u201cEfficient behavior of small-world networks.\u201dPhysical Review Letters87.19 (2001): 198701.\n<https://doi.org/10.1103/PhysRevLett.87.198701>",
            "Examples": "G=nx.Graph([(0,1),(0,2),(0,3),(1,2),(1,3)])\nnx.local_efficiency(G)\n# 0.9166666666666667"
        }
    },
    {
        "Section ID": "capacity_scaling",
        "Description": [
            "Find a minimum cost flow satisfying all demands in digraph G.",
            "This is a capacity scaling successive shortest augmenting path algorithm.",
            "G is a digraph with edge costs and capacities and in which nodes\nhave demand, i.e., they want to send or receive some amount of\nflow. A negative demand means that the node wants to send flow, a\npositive demand means that the node want to receive flow. A flow on\nthe digraph G satisfies all demand if the net flow into each node\nis equal to the demand of that node."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "DiGraph or MultiDiGraph on which a minimum cost flow satisfying all\ndemands is to be found.",
                "demand : string": "Nodes of the graph G are expected to have an attribute demand\nthat indicates how much flow a node wants to send (negative\ndemand) or receive (positive demand). Note that the sum of the\ndemands should be 0 otherwise the problem in not feasible. If\nthis attribute is not present, a node is considered to have 0\ndemand. Default value: \u2018demand\u2019.",
                "capacity : string": "Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: \u2018capacity\u2019.",
                "weight : string": "Edges of the graph G are expected to have an attribute weight\nthat indicates the cost incurred by sending one unit of flow on\nthat edge. If not present, the weight is considered to be 0.\nDefault value: \u2018weight\u2019.",
                "heap : class": "Type of heap to be used in the algorithm. It should be a subclass ofMinHeapor implement a compatible interface.If a stock heap implementation is to be used,BinaryHeapis\nrecommended overPairingHeapfor Python implementations without\noptimized attribute accesses (e.g., CPython) despite a slower\nasymptotic running time. For Python implementations with optimized\nattribute accesses (e.g., PyPy),PairingHeapprovides better\nperformance. Default value:BinaryHeap."
            },
            "Returns:": {
                "flowCost : integer": "Cost of a minimum cost flow satisfying all demands.",
                "flowDict : dictionary": "If G is a digraph, a dict-of-dicts keyed by nodes such that\nflowDict[u][v] is the flow on edge (u, v).\nIf G is a MultiDiGraph, a dict-of-dicts-of-dicts keyed by nodes\nso that flowDict[u][v][key] is the flow on edge (u, v, key)."
            },
            "Raises:": {
                "NetworkXError": "This exception is raised if the input graph is not directed,\nnot connected.",
                "NetworkXUnfeasible": "This exception is raised in the following situations:The sum of the demands is not zero. Then, there is no\nflow satisfying all demands.There is no flow satisfying all demand.",
                "NetworkXUnbounded": "This exception is raised if the digraph G has a cycle of\nnegative cost and infinite capacity. Then, the cost of a flow\nsatisfying all demands is unbounded below."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm does not work if edge weights are floating-point numbers.",
            "Examples": "A simple example of a min cost flow problem.\nG=nx.DiGraph()\nG.add_node(\"a\",demand=-5)\nG.add_node(\"d\",demand=5)\nG.add_edge(\"a\",\"b\",weight=3,capacity=4)\nG.add_edge(\"a\",\"c\",weight=6,capacity=10)\nG.add_edge(\"b\",\"d\",weight=1,capacity=9)\nG.add_edge(\"c\",\"d\",weight=2,capacity=5)\nflowCost,flowDict=nx.capacity_scaling(G)\nflowCost\n# 24\nflowDict\n# {'a': {'b': 4, 'c': 1}, 'd': {}, 'b': {'d': 4}, 'c': {'d': 1}}\nIt is possible to change the name of the attributes used for the\nalgorithm.\nG=nx.DiGraph()\nG.add_node(\"p\",spam=-4)\nG.add_node(\"q\",spam=2)\nG.add_node(\"a\",spam=-2)\nG.add_node(\"d\",spam=-1)\nG.add_node(\"t\",spam=2)\nG.add_node(\"w\",spam=3)\nG.add_edge(\"p\",\"q\",cost=7,vacancies=5)\nG.add_edge(\"p\",\"a\",cost=1,vacancies=4)\nG.add_edge(\"q\",\"d\",cost=2,vacancies=3)\nG.add_edge(\"t\",\"q\",cost=1,vacancies=2)\nG.add_edge(\"a\",\"t\",cost=2,vacancies=4)\nG.add_edge(\"d\",\"w\",cost=3,vacancies=4)\nG.add_edge(\"t\",\"w\",cost=4,vacancies=1)\nflowCost,flowDict=nx.capacity_scaling(\nG,demand=\"spam\",capacity=\"vacancies\",weight=\"cost\"\n)\nflowCost\n# 37\nflowDict\n# {'p': {'q': 2, 'a': 2}, 'q': {'d': 1}, 'a': {'t': 4}, 'd': {'w': 2}, 't': {'q': 1, 'w': 1}, 'w': {}}"
        }
    },
    {
        "Section ID": "vf2pp_is_isomorphic",
        "Description": [
            "Examines whether G1 and G2 are isomorphic."
        ],
        "Field List": {
            "Parameters:": {
                "G1, G2 : NetworkX Graph or MultiGraph instances.": "The two graphs to check for isomorphism.",
                "node_label : str, optional": "The name of the node attribute to be used when comparing nodes.\nThe default isNone, meaning node attributes are not considered\nin the comparison. Any node that doesn\u2019t have thenode_labelattribute usesdefault_labelinstead.",
                "default_label : scalar": "Default value to use when a node doesn\u2019t have an attribute\nnamednode_label. Default isNone."
            },
            "Returns:": {
                "bool": "True if the two graphs are isomorphic, False otherwise."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "draw_spectral",
        "Description": [
            "Draw the graph G with a spectral 2D layout.",
            "This is a convenience function equivalent to:",
            "For more information about how node positions are determined, see spectral_layout ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph",
                "kwargs : optional keywords": "Seedraw_networkxfor a description of optional keywords."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The layout is computed each time this function is called.\nFor repeated drawing it is much more efficient to call spectral_layout directly and reuse the result:",
            "Examples": "G=nx.path_graph(5)\nnx.draw_spectral(G)"
        }
    },
    {
        "Section ID": "parse_graphml",
        "Description": [
            "Read graph in GraphML format from string."
        ],
        "Field List": {
            "Parameters:": {
                "graphml_string : string": "String containing graphml information\n(e.g., contents of a graphml file).",
                "node_type: Python type (default: str)": "Convert node ids to this type",
                "edge_key_type: Python type (default: int)": "Convert graphml edge ids to this type. Multigraphs use id as edge key.\nNon-multigraphs add to edge attribute dict with name \u201cid\u201d.",
                "force_multigraph : bool (default: False)": "If True, return a multigraph with edge keys. If False (the default)\nreturn a multigraph when multiedges are in the graph."
            },
            "Returns:": {
                "graph: NetworkX graph": "If no parallel edges are found a Graph or DiGraph is returned.\nOtherwise a MultiGraph or MultiDiGraph is returned."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Default node and edge attributes are not propagated to each node and edge.\nThey can be obtained from G.graph and applied to node and edge attributes\nif desired using something like this:",
            "Examples": "G=nx.path_graph(4)\nlinefeed=chr(10)# linefeed =\ns=linefeed.join(nx.generate_graphml(G))\nH=nx.parse_graphml(s)"
        }
    },
    {
        "Section ID": "bellman_ford_path_length",
        "Description": [
            "Returns the shortest path length from source to target\nin a weighted graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node label": "starting node for path",
                "target : node label": "ending node for path",
                "weight : string or function (default=\u201dweight\u201d)": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number."
            },
            "Returns:": {
                "length : number": "Shortest path length."
            },
            "Raises:": {
                "NodeNotFound": "Ifsourceis not inG.",
                "NetworkXNoPath": "If no path exists between source and target."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.",
            "Examples": "G=nx.path_graph(5)\nnx.bellman_ford_path_length(G,0,4)\n# 4"
        }
    },
    {
        "Section ID": "build_auxiliary_edge_connectivity",
        "Description": [
            "Auxiliary digraph for computing flow based edge connectivity",
            "If the input graph is undirected, we replace each edge ( u ,`v`) with\ntwo reciprocal arcs ( u , v ) and ( v , u ) and then we set the attribute\n\u2018capacity\u2019 for each arc to 1. If the input graph is directed we simply\nadd the \u2018capacity\u2019 attribute. Part of algorithm 1 in [1] .",
            "References"
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Abdol-Hossein Esfahanian. Connectivity Algorithms. (this is a\nchapter, look for the reference of the book).http://www.cse.msu.edu/~cse835/Papers/Graph_connectivity_revised.pdf"
        }
    },
    {
        "Section ID": "show_multidiedges",
        "Description": [
            "Returns a filter function that shows specific multi-directed edges."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "to_scipy_sparse_array",
        "Description": [
            "Returns the graph adjacency matrix as a SciPy sparse array."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "The NetworkX graph used to construct the sparse matrix.",
                "nodelist : list, optional": "The rows and columns are ordered according to the nodes innodelist.\nIfnodelistis None, then the ordering is produced by G.nodes().",
                "dtype : NumPy data-type, optional": "A valid NumPy dtype used to initialize the array. If None, then the\nNumPy default is used.",
                "weight : string or None   optional (default=\u2019weight\u2019)": "The edge attribute that holds the numerical value used for\nthe edge weight.  If None then all edge weights are 1.",
                "format : str in {\u2018bsr\u2019, \u2018csr\u2019, \u2018csc\u2019, \u2018coo\u2019, \u2018lil\u2019, \u2018dia\u2019, \u2018dok\u2019}": "The type of the matrix to be returned (default \u2018csr\u2019).  For\nsome algorithms different implementations of sparse matrices\ncan perform better.  See[1]for details."
            },
            "Returns:": {
                "A : SciPy sparse array": "Graph adjacency matrix."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For directed graphs, matrix entry i,j corresponds to an edge from i to j. The matrix entries are populated using the edge attribute held in\nparameter weight. When an edge does not have that attribute, the\nvalue of the entry is 1. For multiple edges the matrix values are the sums of the edge weights. When nodelist does not contain every node in G , the adjacency matrix\nis built from the subgraph of G that is induced by the nodes in nodelist . The convention used for self-loop edges in graphs is to assign the\ndiagonal matrix entry value to the weight attribute of the edge\n(or the number 1 if the edge has no weight attribute).  If the\nalternate convention of doubling the edge weight is desired the\nresulting SciPy sparse array can be modified as follows:",
            "References": "[1]Scipy Dev. References, \u201cSparse Matrices\u201d,https://docs.scipy.org/doc/scipy/reference/sparse.html",
            "Examples": "G=nx.MultiDiGraph()\nG.add_edge(0,1,weight=2)\n# 0\nG.add_edge(1,0)\n# 0\nG.add_edge(2,2,weight=3)\n# 0\nG.add_edge(2,2)\n# 1\nS=nx.to_scipy_sparse_array(G,nodelist=[0,1,2])\nprint(S.toarray())\n# [[0 2 0]\n#  [1 0 0]\n#  [0 0 4]]"
        }
    },
    {
        "Section ID": "krackhardt_kite_graph",
        "Description": [
            "Returns the Krackhardt Kite Social Network.",
            "A 10 actor social network introduced by David Krackhardt\nto illustrate different centrality measures [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : networkx Graph": "Krackhardt Kite graph with 10 nodes and 18 edges"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The traditional labeling is:\nAndre=1, Beverley=2, Carol=3, Diane=4,\nEd=5, Fernando=6, Garth=7, Heather=8, Ike=9, Jane=10.",
            "References": "[1]Krackhardt, David. \u201cAssessing the Political Landscape: Structure,\nCognition, and Power in Organizations\u201d. Administrative Science Quarterly.\n35 (2): 342\u2013369. doi:10.2307/2393394. JSTOR 2393394. June 1990."
        }
    },
    {
        "Section ID": "bidirectional_shortest_path",
        "Description": [
            "Returns a list of nodes in a shortest path between source and target."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node label": "starting node for path",
                "target : node label": "ending node for path"
            },
            "Returns:": {
                "path: list": "List of nodes in a path from source to target."
            },
            "Raises:": {
                "NetworkXNoPath": "If no path exists between source and target."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm is used by shortest_path(G, source, target).",
            "Examples": "G=nx.Graph()\nnx.add_path(G,[0,1,2,3,0,4,5,6,7,4])\nnx.bidirectional_shortest_path(G,2,6)\n# [2, 1, 0, 4, 5, 6]"
        }
    },
    {
        "Section ID": "geometric_soft_configuration_graph",
        "Description": [
            "Returns a random graph from the geometric soft configuration model.",
            "The \\(\\mathbb{S}^1\\) model [1] is the geometric soft configuration model\nwhich is able to explain many fundamental features of real networks such as\nsmall-world property, heteregenous degree distributions, high level of\nclustering, and self-similarity.",
            "In the geometric soft configuration model, a node \\(i\\) is assigned two hidden\nvariables: a hidden degree \\(\\kappa_i\\) , quantifying its popularity, influence,\nor importance, and an angular position \\(\\theta_i\\) in a circle abstracting the\nsimilarity space, where angular distances between nodes are a proxy for their\nsimilarity. Focusing on the angular position, this model is often called\nthe \\(\\mathbb{S}^1\\) model (a one-dimensional sphere). The circle\u2019s radius is\nadjusted to \\(R = N/2\\pi\\) , where \\(N\\) is the number of nodes, so that the density\nis set to 1 without loss of generality.",
            "The connection probability between any pair of nodes increases with\nthe product of their hidden degrees (i.e., their combined popularities),\nand decreases with the angular distance between the two nodes.\nSpecifically, nodes \\(i\\) and \\(j\\) are connected with the probability",
            "\\(p_{ij} = \\frac{1}{1 + \\frac{d_{ij}^\\beta}{\\left(\\mu \\kappa_i \\kappa_j\\right)^{\\max(1, \\beta)}}}\\)",
            "where \\(d_{ij} = R\\Delta\\theta_{ij}\\) is the arc length of the circle between\nnodes \\(i\\) and \\(j\\) separated by an angular distance \\(\\Delta\\theta_{ij}\\) .\nParameters \\(\\mu\\) and \\(\\beta\\) (also called inverse temperature) control the\naverage degree and the clustering coefficient, respectively.",
            "It can be shown [2] that the model undergoes a structural phase transition\nat \\(\\beta=1\\) so that for \\(\\beta<1\\) networks are unclustered in the thermodynamic\nlimit (when \\(N\\to \\infty\\) ) whereas for \\(\\beta>1\\) the ensemble generates\nnetworks with finite clustering coefficient.",
            "The \\(\\mathbb{S}^1\\) model can be expressed as a purely geometric model \\(\\mathbb{H}^2\\) in the hyperbolic plane [3] by mapping the hidden degree of\neach node into a radial coordinate as",
            "\\(r_i = \\hat{R} - \\frac{2 \\max(1, \\beta)}{\\beta \\zeta} \\ln \\left(\\frac{\\kappa_i}{\\kappa_0}\\right)\\)",
            "where \\(\\hat{R}\\) is the radius of the hyperbolic disk and \\(\\zeta\\) is the curvature,",
            "\\(\\hat{R} = \\frac{2}{\\zeta} \\ln \\left(\\frac{N}{\\pi}\\right)\n- \\frac{2\\max(1, \\beta)}{\\beta \\zeta} \\ln (\\mu \\kappa_0^2)\\)",
            "The connection probability then reads",
            "\\(p_{ij} = \\frac{1}{1 + \\exp\\left({\\frac{\\beta\\zeta}{2} (x_{ij} - \\hat{R})}\\right)}\\)",
            "where",
            "\\(x_{ij} = r_i + r_j + \\frac{2}{\\zeta} \\ln \\frac{\\Delta\\theta_{ij}}{2}\\)",
            "is a good approximation of the hyperbolic distance between two nodes separated\nby an angular distance \\(\\Delta\\theta_{ij}\\) with radial coordinates \\(r_i\\) and \\(r_j\\) .\nFor \\(\\beta > 1\\) , the curvature \\(\\zeta = 1\\) , for \\(\\beta < 1\\) , \\(\\zeta = \\beta^{-1}\\) ."
        ],
        "Field List": {
            "Parameters:": {
                "Either `n`, `gamma`, `mean_degree` are provided or `kappas`. The values of": "",
                "`n`, `gamma`, `mean_degree` (if provided) are used to construct a random": "",
                "kappa-dict keyed by node with values sampled from a power-law distribution.": "",
                "beta : positive number": "Inverse temperature, controlling the clustering coefficient.",
                "n : int (default: None)": "Size of the network (number of nodes).\nIf not provided,kappasmust be provided and holds the nodes.",
                "gamma : float (default: None)": "Exponent of the power-law distribution for hidden degreeskappas.\nIf not provided,kappasmust be provided directly.",
                "mean_degree : float (default: None)": "The mean degree in the network.\nIf not provided,kappasmust be provided directly.",
                "kappas : dict (default: None)": "A dict keyed by node to its hidden degree value.\nIf not provided, random values are computed based on a power-law\ndistribution usingn,gammaandmean_degree.",
                "seed : int, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "Graph": "A random geometric soft configuration graph (undirected with no self-loops).\nEach node has three node-attributes:kappathat represents the hidden degree.thetathe position in the similarity space (\\(\\mathbb{S}^1\\)) which is\nalso the angular position in the hyperbolic plane.radiusthe radial position in the hyperbolic plane\n(based on the hidden degree)."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Serrano, M. \u00c1., Krioukov, D., & Bogu\u00f1\u00e1, M. (2008). Self-similarity\nof complex networks and hidden metric spaces. Physical review letters, 100(7), 078701.  [2]van der Kolk, J., Serrano, M. \u00c1., & Bogu\u00f1\u00e1, M. (2022). An anomalous\ntopological phase transition in spatial random graphs. Communications Physics, 5(1), 245.  [3]Krioukov, D., Papadopoulos, F., Kitsak, M., Vahdat, A., & Bogun\u00e1, M. (2010).\nHyperbolic geometry of complex networks. Physical Review E, 82(3), 036106.",
            "Examples": "Generate a network with specified parameters:\nG=nx.geometric_soft_configuration_graph(beta=1.5,n=100,gamma=2.7,mean_degree=5)\nCreate a geometric soft configuration graph with 100 nodes. The\\(\\beta\\)parameter\nis set to 1.5 and the exponent of the powerlaw distribution of the hidden\ndegrees is 2.7 with mean value of 5.\nGenerate a network with predefined hidden degrees:\nkappas={i:10foriinrange(100)}\nG=nx.geometric_soft_configuration_graph(beta=2.5,kappas=kappas)\nCreate a geometric soft configuration graph with 100 nodes. The\\(\\beta\\)parameter\nis set to 2.5 and all nodes with hidden degree\\(\\kappa=10\\)."
        }
    },
    {
        "Section ID": "min_weighted_dominating_set",
        "Description": [
            "Returns a dominating set that approximates the minimum weight node\ndominating set."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected graph.",
                "weight : string": "The node attribute storing the weight of an node. If provided,\nthe node attribute with this key must be a number for each\nnode. If not provided, each node is assumed to have weight one."
            },
            "Returns:": {
                "min_weight_dominating_set : set": "A set of nodes, the sum of whose weights is no more than(logw(V))w(V^*), wherew(V)denotes the sum of the weights of\neach node in the graph andw(V^*)denotes the sum of the\nweights of each node in the minimum weight dominating set."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is directed."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm computes an approximate minimum weighted dominating\nset for the graph G . The returned solution has weight (logw(V))w(V^*) , where w(V) denotes the sum of the weights of each\nnode in the graph and w(V^*) denotes the sum of the weights of\neach node in the minimum weight dominating set for the graph. This implementation of the algorithm runs in \\(O(m)\\) time, where \\(m\\) is the number of edges in the graph.",
            "References": "[1]Vazirani, Vijay V.Approximation Algorithms.\nSpringer Science & Business Media, 2001.",
            "Examples": "G=nx.Graph([(0,1),(0,4),(1,4),(1,2),(2,3),(3,4),(2,5)])\nnx.approximation.min_weighted_dominating_set(G)\n# {1, 2, 4}"
        }
    },
    {
        "Section ID": "circular_layout",
        "Description": [
            "Position nodes on a circle."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph or list of nodes": "A position will be assigned to every node in G.",
                "scale : number (default: 1)": "Scale factor for positions.",
                "center : array-like or None": "Coordinate pair around which to center the layout.",
                "dim : int": "Dimension of layout.\nIf dim>2, the remaining dimensions are set to zero\nin the returned positions.\nIf dim<2, a ValueError is raised."
            },
            "Returns:": {
                "pos : dict": "A dictionary of positions keyed by node"
            },
            "Raises:": {
                "ValueError": "If dim < 2"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm currently only works in two dimensions and does not\ntry to minimize edge crossings.",
            "Examples": "G=nx.path_graph(4)\npos=nx.circular_layout(G)"
        }
    },
    {
        "Section ID": "EdgeComponentAuxGraph",
        "Description": [
            "A simple algorithm to find all k-edge-connected components in a graph.",
            "Constructing the auxiliary graph (which may take some time) allows for the\nk-edge-ccs to be found in linear time for arbitrary k.",
            "Notes",
            "This implementation is based on [1] . The idea is to construct an auxiliary\ngraph from which the k-edge-ccs can be extracted in linear time. The\nauxiliary graph is constructed in \\(O(|V|\\cdot F)\\) operations, where F is the\ncomplexity of max flow. Querying the components takes an additional \\(O(|V|)\\) operations. This algorithm can be slow for large graphs, but it handles an\narbitrary k and works for both directed and undirected inputs.",
            "The undirected case for k=1 is exactly connected components.\nThe undirected case for k=2 is exactly bridge connected components.\nThe directed case for k=1 is exactly strongly connected components.",
            "References",
            "Examples",
            "The auxiliary graph is primarily used for k-edge-ccs but it\ncan also speed up the queries of k-edge-subgraphs by refining the\nsearch space."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This implementation is based on [1] . The idea is to construct an auxiliary\ngraph from which the k-edge-ccs can be extracted in linear time. The\nauxiliary graph is constructed in \\(O(|V|\\cdot F)\\) operations, where F is the\ncomplexity of max flow. Querying the components takes an additional \\(O(|V|)\\) operations. This algorithm can be slow for large graphs, but it handles an\narbitrary k and works for both directed and undirected inputs. The undirected case for k=1 is exactly connected components.\nThe undirected case for k=2 is exactly bridge connected components.\nThe directed case for k=1 is exactly strongly connected components.",
            "References": "[1]Wang, Tianhao, et al. (2015) A simple algorithm for finding all\nk-edge-connected components.http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0136264",
            "Examples": "importitertoolsasit\nfromnetworkx.utilsimportpairwise\nfromnetworkx.algorithms.connectivityimportEdgeComponentAuxGraph\n# Build an interesting graph with multiple levels of k-edge-ccs\npaths=[\n(1,2,3,4,1,3,4,2),# a 3-edge-cc (a 4 clique)\n(5,6,7,5),# a 2-edge-cc (a 3 clique)\n(1,5),# combine first two ccs into a 1-edge-cc\n(0,),# add an additional disconnected 1-edge-cc\n]\nG=nx.Graph()\nG.add_nodes_from(it.chain(*paths))\nG.add_edges_from(it.chain(*[pairwise(path)forpathinpaths]))\n# Constructing the AuxGraph takes about O(n ** 4)\naux_graph=EdgeComponentAuxGraph.construct(G)\n# Once constructed, querying takes O(n)\nsorted(map(sorted,aux_graph.k_edge_components(k=1)))\n# [[0], [1, 2, 3, 4, 5, 6, 7]]\nsorted(map(sorted,aux_graph.k_edge_components(k=2)))\n# [[0], [1, 2, 3, 4], [5, 6, 7]]\nsorted(map(sorted,aux_graph.k_edge_components(k=3)))\n# [[0], [1, 2, 3, 4], [5], [6], [7]]\nsorted(map(sorted,aux_graph.k_edge_components(k=4)))\n# [[0], [1], [2], [3], [4], [5], [6], [7]]\nThe auxiliary graph is primarily used for k-edge-ccs but it\ncan also speed up the queries of k-edge-subgraphs by refining the\nsearch space.\nimportitertoolsasit\nfromnetworkx.utilsimportpairwise\nfromnetworkx.algorithms.connectivityimportEdgeComponentAuxGraph\npaths=[\n(1,2,4,3,1,4),\n]\nG=nx.Graph()\nG.add_nodes_from(it.chain(*paths))\nG.add_edges_from(it.chain(*[pairwise(path)forpathinpaths]))\naux_graph=EdgeComponentAuxGraph.construct(G)\nsorted(map(sorted,aux_graph.k_edge_subgraphs(k=3)))\n# [[1], [2], [3], [4]]\nsorted(map(sorted,aux_graph.k_edge_components(k=3)))\n# [[1, 4], [2], [3]]"
        }
    },
    {
        "Section ID": "dfs_tree",
        "Description": [
            "Returns oriented tree constructed from a depth-first-search from source."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node, optional": "Specify starting node for depth-first search.",
                "depth_limit : int, optional (default=len(G))": "Specify the maximum search depth.",
                "sort_neighbors : function (default=None)": "A function that takes an iterator over nodes as the input, and\nreturns an iterable of the same nodes with a custom ordering.\nFor example,sortedwill sort the nodes in increasing order."
            },
            "Returns:": {
                "T : NetworkX DiGraph": "An oriented tree"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.path_graph(5)\nT=nx.dfs_tree(G,source=0,depth_limit=2)\nlist(T.edges())\n# [(0, 1), (1, 2)]\nT=nx.dfs_tree(G,source=0)\nlist(T.edges())\n# [(0, 1), (1, 2), (2, 3), (3, 4)]"
        }
    },
    {
        "Section ID": "attr_matrix",
        "Description": [
            "Returns the attribute matrix using attributes from G as a numpy array.",
            "If only G is passed in, then the adjacency matrix is constructed.",
            "Let A be a discrete set of values for the node attribute node_attr . Then\nthe elements of A represent the rows and columns of the constructed matrix.\nNow, iterate through every edge e=(u,v) in G and consider the value\nof the edge attribute edge_attr .  If ua and va are the values of the\nnode attribute node_attr for u and v, respectively, then the value of\nthe edge attribute is added to the matrix element at (ua, va)."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "The NetworkX graph used to construct the attribute matrix.",
                "edge_attr : str, optional": "Each element of the matrix represents a running total of the\nspecified edge attribute for edges whose node attributes correspond\nto the rows/cols of the matrix. The attribute must be present for\nall edges in the graph. If no attribute is specified, then we\njust count the number of edges whose node attributes correspond\nto the matrix element.",
                "node_attr : str, optional": "Each row and column in the matrix represents a particular value\nof the node attribute.  The attribute must be present for all nodes\nin the graph. Note, the values of this attribute should be reliably\nhashable. So, float values are not recommended. If no attribute is\nspecified, then the rows and columns will be the nodes of the graph.",
                "normalized : bool, optional": "If True, then each row is normalized by the summation of its values.",
                "rc_order : list, optional": "A list of the node attribute values. This list specifies the ordering\nof rows and columns of the array. If no ordering is provided, then\nthe ordering will be random (and also, a return value)."
            },
            "Returns:": {
                "M : 2D NumPy ndarray": "The attribute matrix.",
                "ordering : list": "Ifrc_orderwas specified, then only the attribute matrix is returned.\nHowever, ifrc_orderwas None, then the ordering used to construct\nthe matrix is returned as well."
            },
            "Other Parameters:": {
                "dtype : NumPy data-type, optional": "A valid NumPy dtype used to initialize the array. Keep in mind certain\ndtypes can yield unexpected results if the array is to be normalized.\nThe parameter is passed to numpy.zeros(). If unspecified, the NumPy\ndefault is used.",
                "order : {\u2018C\u2019, \u2018F\u2019}, optional": "Whether to store multidimensional data in C- or Fortran-contiguous\n(row- or column-wise) order in memory. This parameter is passed to\nnumpy.zeros(). If unspecified, the NumPy default is used."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "Construct an adjacency matrix:\nG=nx.Graph()\nG.add_edge(0,1,thickness=1,weight=3)\nG.add_edge(0,2,thickness=2)\nG.add_edge(1,2,thickness=3)\nnx.attr_matrix(G,rc_order=[0,1,2])\n# array([[0., 1., 1.],\n#        [1., 0., 1.],\n#        [1., 1., 0.]])\nAlternatively, we can obtain the matrix describing edge thickness.\nnx.attr_matrix(G,edge_attr=\"thickness\",rc_order=[0,1,2])\n# array([[0., 1., 2.],\n#        [1., 0., 3.],\n#        [2., 3., 0.]])\nWe can also color the nodes and ask for the probability distribution over\nall edges (u,v) describing:"
        }
    },
    {
        "Section ID": "is_regular_expander",
        "Description": [
            "Determines whether the graph G is a regular expander. [1]",
            "An expander graph is a sparse graph with strong connectivity properties.",
            "More precisely, this helper checks whether the graph is a\nregular \\((n, d, \\lambda)\\) -expander with \\(\\lambda\\) close to\nthe Alon-Boppana bound and given by \\(\\lambda = 2 \\sqrt{d - 1} + \\epsilon\\) . [2]",
            "In the case where \\(\\epsilon = 0\\) then if the graph successfully passes the test\nit is a Ramanujan graph. [3]",
            "A Ramanujan graph has spectral gap almost as large as possible, which makes them\nexcellent expanders."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "epsilon : int, float, default=0": ""
            },
            "Returns:": {
                "bool": "Whether the given graph is a regular\\((n, d, \\lambda)\\)-expander\nwhere\\(\\lambda = 2 \\sqrt{d - 1} + \\epsilon\\)."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Expander graph,https://en.wikipedia.org/wiki/Expander_graph  [2]Alon-Boppana bound,https://en.wikipedia.org/wiki/Alon%E2%80%93Boppana_bound  [3]Ramanujan graphs,https://en.wikipedia.org/wiki/Ramanujan_graph",
            "Examples": "G=nx.random_regular_expander_graph(20,4)\nnx.is_regular_expander(G)\n# True"
        }
    },
    {
        "Section ID": "barycenter",
        "Description": [
            "Calculate barycenter of a connected graph, optionally with edge weights.",
            "The barycenter a connected graph \\(G\\) is the subgraph induced by the set of its nodes \\(v\\) minimizing the objective function",
            "where \\(d_G\\) is the (possibly weighted) pathlength .\nThe barycenter is also called the median . See [West01] , p. 78."
        ],
        "Field List": {
            "Parameters:": {
                "G : networkx.Graph": "The connected graph\\(G\\).",
                "weight : str, optional": "Passed through toshortest_path_length().",
                "attr : str, optional": "If given, write the value of the objective function to each node\u2019sattrattribute. Otherwise do not store the value.",
                "sp : dict of dicts, optional": "All pairs shortest path lengths as a dictionary of dictionaries"
            },
            "Returns:": {
                "list": "Nodes ofGthat induce the barycenter ofG."
            },
            "Raises:": {
                "NetworkXNoPath": "IfGis disconnected.Gmay appear disconnected tobarycenter()ifspis given but is missing shortest path\nlengths for any pairs.",
                "ValueError": "Ifspandweightare both given."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph([(1,2),(1,3),(1,4),(3,4),(3,5),(4,5)])\nnx.barycenter(G)\n# [1, 3, 4]"
        }
    },
    {
        "Section ID": "k_factor",
        "Description": [
            "Compute a k-factor of G",
            "A k-factor of a graph is a spanning k-regular subgraph.\nA spanning k-regular subgraph of G is a subgraph that contains\neach vertex of G and a subset of the edges of G such that each\nvertex has degree k."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected graph",
                "matching_weight: string, optional (default=\u2019weight\u2019)": "Edge data key corresponding to the edge weight.\nUsed for finding the max-weighted perfect matching.\nIf key not found, uses 1 as weight."
            },
            "Returns:": {
                "G2 : NetworkX graph": "A k-factor of G"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]\u201cAn algorithm for computing simple k-factors.\u201d,\nMeijer, Henk, Yurai N\u00fa\u00f1ez-Rodr\u00edguez, and David Rappaport,\nInformation processing letters, 2009.",
            "Examples": "G=nx.Graph([(1,2),(2,3),(3,4),(4,1)])\nG2=nx.k_factor(G,k=1)\nG2.edges()\n# EdgeView([(1, 2), (3, 4)])"
        }
    },
    {
        "Section ID": "spiral_layout",
        "Description": [
            "Position nodes in a spiral layout."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph or list of nodes": "A position will be assigned to every node in G.",
                "scale : number (default: 1)": "Scale factor for positions.",
                "center : array-like or None": "Coordinate pair around which to center the layout.",
                "dim : int, default=2": "Dimension of layout, currently only dim=2 is supported.\nOther dimension values result in a ValueError.",
                "resolution : float, default=0.35": "The compactness of the spiral layout returned.\nLower values result in more compressed spiral layouts.",
                "equidistant : bool, default=False": "If True, nodes will be positioned equidistant from each other\nby decreasing angle further from center.\nIf False, nodes will be positioned at equal angles\nfrom each other by increasing separation further from center."
            },
            "Returns:": {
                "pos : dict": "A dictionary of positions keyed by node"
            },
            "Raises:": {
                "ValueError": "If dim != 2"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm currently only works in two dimensions.",
            "Examples": "G=nx.path_graph(4)\npos=nx.spiral_layout(G)\nnx.draw(G,pos=pos)"
        }
    },
    {
        "Section ID": "one_exchange",
        "Description": [
            "Compute a partitioning of the graphs nodes and the corresponding cut value.",
            "Use a greedy one exchange strategy to find a locally maximal cut\nand its value, it works by finding the best node (one that gives\nthe highest gain to the cut value) to add to the current cut\nand repeats this process until no improvement can be made."
        ],
        "Field List": {
            "Parameters:": {
                "G : networkx Graph": "Graph to find a maximum cut for.",
                "initial_cut : set": "Cut to use as a starting point. If not supplied the algorithm\nstarts with an empty cut.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "weight : object": "Edge attribute key to use as weight. If not specified, edges\nhave weight one."
            },
            "Returns:": {
                "cut_value : scalar": "Value of the maximum cut.",
                "partition : pair of node sets": "A partitioning of the nodes that defines a maximum cut."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the graph is directed or is a multigraph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.complete_graph(5)\ncurr_cut_size,partition=nx.approximation.one_exchange(G,seed=1)\ncurr_cut_size\n# 6\npartition\n# ({0, 2}, {1, 3, 4})"
        }
    },
    {
        "Section ID": "draw_spring",
        "Description": [
            "Draw the graph G with a spring layout.",
            "This is a convenience function equivalent to:"
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph",
                "kwargs : optional keywords": "Seedraw_networkxfor a description of optional keywords."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "spring_layout is also the default layout for draw , so this function is equivalent to draw . The layout is computed each time this function is called.\nFor repeated drawing it is much more efficient to call spring_layout directly and reuse the result:",
            "Examples": "G=nx.path_graph(20)\nnx.draw_spring(G)"
        }
    },
    {
        "Section ID": "node_connectivity",
        "Description": [
            "Returns an approximation for node connectivity for a graph or digraph G.",
            "Node connectivity is equal to the minimum number of nodes that\nmust be removed to disconnect G or render it trivial. By Menger\u2019s theorem,\nthis is equal to the number of node independent paths (paths that\nshare no nodes other than source and target).",
            "If source and target nodes are provided, this function returns the\nlocal node connectivity: the minimum number of nodes that must be\nremoved to break all paths from source to target in G.",
            "This algorithm is based on a fast approximation that gives an strict lower\nbound on the actual number of node independent paths between two nodes [1] .\nIt works for both directed and undirected graphs."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected graph",
                "s : node": "Source node. Optional. Default value: None.",
                "t : node": "Target node. Optional. Default value: None."
            },
            "Returns:": {
                "K : integer": "Node connectivity of G, or local node connectivity if source\nand target are provided."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm [1] finds node independents paths between two nodes by\ncomputing their shortest path using BFS, marking the nodes of the path\nfound as \u2018used\u2019 and then searching other shortest paths excluding the\nnodes marked as used until no more paths exist. It is not exact because\na shortest path could use nodes that, if the path were longer, may belong\nto two different node independent paths. Thus it only guarantees an\nstrict lower bound on node connectivity.",
            "References": "[1](1,2)White, Douglas R., and Mark Newman. 2001 A Fast Algorithm for\nNode-Independent Paths. Santa Fe Institute Working Paper #01-07-035http://eclectic.ss.uci.edu/~drwhite/working.pdf",
            "Examples": "# Platonic octahedral graph is 4-node-connected\nfromnetworkx.algorithmsimportapproximationasapprox\nG=nx.octahedral_graph()\napprox.node_connectivity(G)\n# 4"
        }
    },
    {
        "Section ID": "local_node_connectivity",
        "Description": [
            "Computes local node connectivity for nodes s and t.",
            "Local node connectivity for two non adjacent nodes s and t is the\nminimum number of nodes that must be removed (along with their incident\nedges) to disconnect them.",
            "This is a flow based implementation of node connectivity. We compute the\nmaximum flow on an auxiliary digraph build from the original input\ngraph (see below for details)."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected graph",
                "s : node": "Source node",
                "t : node": "Target node",
                "flow_func : function": "A function for computing the maximum flow among a pair of nodes.\nThe function has to accept at least three parameters: a Digraph,\na source node, and a target node. And return a residual network\nthat follows NetworkX conventions (seemaximum_flow()for\ndetails). If flow_func is None, the default maximum flow function\n(edmonds_karp()) is used. See below for details. The choice\nof the default function may change from version to version and\nshould not be relied on. Default value: None.",
                "auxiliary : NetworkX DiGraph": "Auxiliary digraph to compute flow based node connectivity. It has\nto have a graph attribute called mapping with a dictionary mapping\nnode names in G and in the auxiliary digraph. If provided\nit will be reused instead of recreated. Default value: None.",
                "residual : NetworkX DiGraph": "Residual network to compute maximum flow. If provided it will be\nreused instead of recreated. Default value: None.",
                "cutoff : integer, float, or None (default: None)": "If specified, the maximum flow algorithm will terminate when the\nflow value reaches or exceeds the cutoff. This only works for flows\nthat support the cutoff parameter (most do) and is ignored otherwise."
            },
            "Returns:": {
                "K : integer": "local node connectivity for nodes s and t"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This is a flow based implementation of node connectivity. We compute the\nmaximum flow using, by default, the edmonds_karp() algorithm (see: maximum_flow() ) on an auxiliary digraph build from the original\ninput graph: For an undirected graph G having n nodes and m edges we derive a\ndirected graph H with 2n nodes and 2m+n arcs by replacing each\noriginal node v with two nodes v_A , v_B linked by an (internal)\narc in H. Then for each edge ( u , v ) in G we add two arcs\n( u_B , v_A ) and ( v_B , u_A ) in H. Finally we set the attribute\ncapacity = 1 for each arc in H [1] . For a directed graph G having n nodes and m arcs we derive a\ndirected graph H with 2n nodes and m+n arcs by replacing each\noriginal node v with two nodes v_A , v_B linked by an (internal)\narc ( v_A , v_B ) in H. Then for each arc ( u , v ) in G we add one arc\n( u_B , v_A ) in H. Finally we set the attribute capacity = 1 for\neach arc in H. This is equal to the local node connectivity because the value of\na maximum s-t-flow is equal to the capacity of a minimum s-t-cut.",
            "References": "[1]Kammer, Frank and Hanjo Taubig. Graph Connectivity. in Brandes and\nErlebach, \u2018Network Analysis: Methodological Foundations\u2019, Lecture\nNotes in Computer Science, Volume 3418, Springer-Verlag, 2005.http://www.informatik.uni-augsburg.de/thi/personen/kammer/Graph_Connectivity.pdf",
            "Examples": "This function is not imported in the base NetworkX namespace, so you\nhave to explicitly import it from the connectivity package:\nfromnetworkx.algorithms.connectivityimportlocal_node_connectivity\nWe use in this example the platonic icosahedral graph, which has node\nconnectivity 5.\nG=nx.icosahedral_graph()\nlocal_node_connectivity(G,0,6)\n# 5\nIf you need to compute local connectivity on several pairs of\nnodes in the same graph, it is recommended that you reuse the\ndata structures that NetworkX uses in the computation: the\nauxiliary digraph for node connectivity, and the residual\nnetwork for the underlying maximum flow computation.\nExample of how to compute local node connectivity among\nall pairs of nodes of the platonic icosahedral graph reusing\nthe data structures.\nimportitertools\n# You also have to explicitly import the function for\n# building the auxiliary digraph from the connectivity package\nfromnetworkx.algorithms.connectivityimportbuild_auxiliary_node_connectivity\nH=build_auxiliary_node_connectivity(G)\n# And the function for building the residual network from the\n# flow package\nfromnetworkx.algorithms.flowimportbuild_residual_network\n# Note that the auxiliary digraph has an edge attribute named capacity\nR=build_residual_network(H,\"capacity\")\nresult=dict.fromkeys(G,dict())\n# Reuse the auxiliary digraph and the residual network by passing them\n# as parameters\nforu,vinitertools.combinations(G,2):\nk=local_node_connectivity(G,u,v,auxiliary=H,residual=R)\nresult[u][v]=k\nall(result[u][v]==5foru,vinitertools.combinations(G,2))\n# True\nYou can also use alternative flow algorithms for computing node\nconnectivity. For instance, in dense networks the algorithmshortest_augmenting_path()will usually perform better than\nthe defaultedmonds_karp()which is faster for sparse\nnetworks with highly skewed degree distributions. Alternative flow\nfunctions have to be explicitly imported from the flow package.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\nlocal_node_connectivity(G,0,6,flow_func=shortest_augmenting_path)\n# 5"
        }
    },
    {
        "Section ID": "davis_southern_women_graph",
        "Description": [
            "Returns Davis Southern women social network.",
            "This is a bipartite graph.",
            "References"
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]A. Davis, Gardner, B. B., Gardner, M. R., 1941. Deep South.\nUniversity of Chicago Press, Chicago, IL."
        }
    },
    {
        "Section ID": "bfs_layout",
        "Description": [
            "Position nodes according to breadth-first search algorithm."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A position will be assigned to every node in G.",
                "start : node inG": "Starting node for bfs",
                "center : array-like or None": "Coordinate pair around which to center the layout."
            },
            "Returns:": {
                "pos : dict": "A dictionary of positions keyed by node."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm currently only works in two dimensions and does not\ntry to minimize edge crossings.",
            "Examples": "G=nx.path_graph(4)\npos=nx.bfs_layout(G,0)"
        }
    },
    {
        "Section ID": "chromatic_polynomial",
        "Description": [
            "Returns the chromatic polynomial of G",
            "This function computes the chromatic polynomial via an iterative version of\nthe deletion-contraction algorithm.",
            "The chromatic polynomial X_G(x) is a fundamental graph polynomial\ninvariant in one variable. Evaluating X_G(k) for an natural number k enumerates the proper k-colorings of G .",
            "There are several equivalent definitions; here are three:",
            "Def 1 (explicit formula):\nFor G an undirected graph, c(G) the number of connected components of G , E the edge set of G , and G(S) the spanning subgraph of G with\nedge set S  [1] :",
            "Def 2 (interpolating polynomial):\nFor G an undirected graph, n(G) the number of vertices of G , k_0=0 ,\nand k_i the number of distinct ways to color the vertices of G with i unique colors (for i a natural number at most n(G) ), X_G(x) is the\nunique Lagrange interpolating polynomial of degree n(G) through the points (0,k_0),(1,k_1),dots,(n(G),k_{n(G)})  [2] .",
            "Def 3 (chromatic recurrence):\nFor G an undirected graph, G-e the graph obtained from G by deleting\nedge e , G/e the graph obtained from G by contracting edge e , n(G) the number of vertices of G , and e(G) the number of edges of G  [3] :",
            "This formulation is also known as the Fundamental Reduction Theorem [4] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": ""
            },
            "Returns:": {
                "instance of : sympy.core.add.Add": "A Sympy expression representing the chromatic polynomial forG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Interpretation of the coefficients is discussed in [5] . Several special\ncases are listed in [2] . The chromatic polynomial is a specialization of the Tutte polynomial; in\nparticular, X_G(x)=T_G(x,0)  [6] . The chromatic polynomial may take negative arguments, though evaluations\nmay not have chromatic interpretations. For instance, X_G(-1) enumerates\nthe acyclic orientations of G  [7] .",
            "References": "[1]D. B. West,\n\u201cIntroduction to Graph Theory,\u201d p. 222  [2](1,2)E. W. Weisstein\n\u201cChromatic Polynomial\u201d\nMathWorld\u2013A Wolfram Web Resourcehttps://mathworld.wolfram.com/ChromaticPolynomial.html  [3]D. B. West,\n\u201cIntroduction to Graph Theory,\u201d p. 221  [4]J. Zhang, J. Goodall,\n\u201cAn Introduction to Chromatic Polynomials\u201dhttps://math.mit.edu/~apost/courses/18.204_2018/Julie_Zhang_paper.pdf  [5]R. C. Read,\n\u201cAn Introduction to Chromatic Polynomials\u201d\nJournal of Combinatorial Theory, 1968https://math.berkeley.edu/~mrklug/ReadChromatic.pdf  [6]W. T. Tutte,\n\u201cGraph-polynomials\u201d\nAdvances in Applied Mathematics, 2004https://www.sciencedirect.com/science/article/pii/S0196885803000411  [7]R. P. Stanley,\n\u201cAcyclic orientations of graphs\u201d\nDiscrete Mathematics, 2006https://math.mit.edu/~rstan/pubs/pubfiles/18.pdf",
            "Examples": "C=nx.cycle_graph(5)\nnx.chromatic_polynomial(C)\n# x**5 - 5*x**4 + 10*x**3 - 10*x**2 + 4*x\nG=nx.complete_graph(4)\nnx.chromatic_polynomial(G)\n# x**4 - 6*x**3 + 11*x**2 - 6*x"
        }
    },
    {
        "Section ID": "parse_gml",
        "Description": [
            "Parse GML graph from a string or iterable."
        ],
        "Field List": {
            "Parameters:": {
                "lines : string or iterable of strings": "Data in GML format.",
                "label : string, optional": "If not None, the parsed nodes will be renamed according to node\nattributes indicated bylabel. Default value: \u2018label\u2019.",
                "destringizer : callable, optional": "Adestringizerthat recovers values stored as strings in GML. If it\ncannot convert a string to a value, aValueErroris raised. Default\nvalue : None."
            },
            "Returns:": {
                "G : NetworkX graph": "The parsed graph."
            },
            "Raises:": {
                "NetworkXError": "If the input cannot be parsed."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This stores nested GML attributes as dictionaries in the NetworkX graph,\nnode, and edge attribute structures. GML files are stored using a 7-bit ASCII encoding with any extended\nASCII characters (iso8859-1) appearing as HTML character entities.\nWithout specifying a stringizer / destringizer , the code is capable of\nwriting int / float / str / dict / list data as required by the GML\nspecification.  For writing other data types, and for reading data other\nthan str you need to explicitly supply a stringizer / destringizer . For additional documentation on the GML file format, please see the GML url . See the module docstring networkx.readwrite.gml for more details."
        }
    },
    {
        "Section ID": "directed_combinatorial_laplacian_matrix",
        "Description": [
            "Return the directed combinatorial Laplacian matrix of G.",
            "The graph directed combinatorial Laplacian is the matrix",
            "where P is the transition matrix of the graph and Phi a matrix\nwith the Perron vector of P in the diagonal and zeros elsewhere [1] .",
            "Depending on the value of walk_type, P can be the transition matrix\ninduced by a random walk, a lazy random walk, or a random walk with\nteleportation (PageRank)."
        ],
        "Field List": {
            "Parameters:": {
                "G : DiGraph": "A NetworkX graph",
                "nodelist : list, optional": "The rows and columns are ordered according to the nodes in nodelist.\nIf nodelist is None, then the ordering is produced by G.nodes().",
                "weight : string or None, optional (default=\u2019weight\u2019)": "The edge data key used to compute each value in the matrix.\nIf None, then each edge has weight 1.",
                "walk_type : string or None, optional (default=None)": "One of\"random\",\"lazy\", or\"pagerank\". Ifwalk_type=None(the default), then a value is selected according to the properties ofG:\n-walk_type=\"random\"ifGis strongly connected and aperiodic\n-walk_type=\"lazy\"ifGis strongly connected but not aperiodic\n-walk_type=\"pagerank\"for all other cases.",
                "alpha : real": "(1 - alpha) is the teleportation probability used with pagerank"
            },
            "Returns:": {
                "L : NumPy matrix": "Combinatorial Laplacian of G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Only implemented for DiGraphs The result is always a symmetric matrix. This calculation uses the out-degree of the graph G . To use the\nin-degree for calculations instead, use G.reverse(copy=False) and\ntake the transpose.",
            "References": "[1]Fan Chung (2005).\nLaplacians and the Cheeger inequality for directed graphs.\nAnnals of Combinatorics, 9(1), 2005"
        }
    },
    {
        "Section ID": "parse_edgelist",
        "Description": [
            "Parse lines of an edge list representation of a bipartite graph."
        ],
        "Field List": {
            "Parameters:": {
                "lines : list or iterator of strings": "Input data in edgelist format",
                "comments : string, optional": "Marker for comment lines",
                "delimiter : string, optional": "Separator for node labels",
                "create_using: NetworkX graph container, optional": "Use given NetworkX graph for holding nodes or edges.",
                "nodetype : Python type, optional": "Convert nodes to this type.",
                "data : bool or list of (label,type) tuples": "If False generate no edge data or if True use a dictionary\nrepresentation of edge data or a list tuples specifying dictionary\nkey names and types for edge data."
            },
            "Returns:": {
                "G: NetworkX Graph": "The bipartite graph corresponding to lines"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "Edgelist with no data:\nfromnetworkx.algorithmsimportbipartite\nlines=[\"1 2\",\"2 3\",\"3 4\"]\nG=bipartite.parse_edgelist(lines,nodetype=int)\nsorted(G.nodes())\n# [1, 2, 3, 4]\nsorted(G.nodes(data=True))\n# [(1, {'bipartite': 0}), (2, {'bipartite': 0}), (3, {'bipartite': 0}), (4, {'bipartite': 1})]\nsorted(G.edges())\n# [(1, 2), (2, 3), (3, 4)]\nEdgelist with data in Python dictionary representation:\nlines=[\"1 2 {'weight':3}\",\"2 3 {'weight':27}\",\"3 4 {'weight':3.0}\"]\nG=bipartite.parse_edgelist(lines,nodetype=int)\nsorted(G.nodes())\n# [1, 2, 3, 4]\nsorted(G.edges(data=True))\n# [(1, 2, {'weight': 3}), (2, 3, {'weight': 27}), (3, 4, {'weight': 3.0})]\nEdgelist with data in a list:\nlines=[\"1 2 3\",\"2 3 27\",\"3 4 3.0\"]\nG=bipartite.parse_edgelist(lines,nodetype=int,data=((\"weight\",float),))\nsorted(G.nodes())\n# [1, 2, 3, 4]\nsorted(G.edges(data=True))\n# [(1, 2, {'weight': 3.0}), (2, 3, {'weight': 27.0}), (3, 4, {'weight': 3.0})]"
        }
    },
    {
        "Section ID": "resistance_distance",
        "Description": [
            "Returns the resistance distance between pairs of nodes in graph G.",
            "The resistance distance between two nodes of a graph is akin to treating\nthe graph as a grid of resistors with a resistance equal to the provided\nweight [1] , [2] .",
            "If weight is not provided, then a weight of 1 is used for all edges.",
            "If two nodes are the same, the resistance distance is zero."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A graph",
                "nodeA : node or None, optional (default=None)": "A node within graph G.\nIf None, compute resistance distance using all nodes as source nodes.",
                "nodeB : node or None, optional (default=None)": "A node within graph G.\nIf None, compute resistance distance using all nodes as target nodes.",
                "weight : string or None, optional (default=None)": "The edge data key used to compute the resistance distance.\nIf None, then each edge has weight 1.",
                "invert_weight : boolean (default=True)": "Proper calculation of resistance distance requires building the\nLaplacian matrix with the reciprocal of the weight. Not required\nif the weight is already inverted. Weight cannot be zero."
            },
            "Returns:": {
                "rd : dict or float": "IfnodeAandnodeBare given, resistance distance betweennodeAandnodeB. IfnodeAornodeBis unspecified (the default), a\ndictionary of nodes with resistance distances as the value."
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis a directed graph.",
                "NetworkXError": "IfGis not connected, or contains no nodes,\nornodeAis not inGornodeBis not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The implementation is based on Theorem A in [2] . Self-loops are ignored.\nMulti-edges are contracted in one edge with weight equal to the harmonic sum of the weights.",
            "References": "[1]Wikipedia\n\u201cResistance distance.\u201dhttps://en.wikipedia.org/wiki/Resistance_distance  [2](1,2)D. J. Klein and M. Randic.\nResistance distance.\nJ. of Math. Chem. 12:81-95, 1993.",
            "Examples": "G=nx.Graph([(1,2),(1,3),(1,4),(3,4),(3,5),(4,5)])\nround(nx.resistance_distance(G,1,3),10)\n# 0.625"
        }
    },
    {
        "Section ID": "inverse_line_graph",
        "Description": [
            "Returns the inverse line graph of graph G.",
            "If H is a graph, and G is the line graph of H, such that G = L(H).\nThen H is the inverse line graph of G.",
            "Not all graphs are line graphs and these do not have an inverse line graph.\nIn these cases this function raises a NetworkXError."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX Graph"
            },
            "Returns:": {
                "H : graph": "The inverse line graph of G."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is directed or a multigraph",
                "NetworkXError": "If G is not a line graph"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This is an implementation of the Roussopoulos algorithm[R90abc5507a69-1]_. If G consists of multiple components, then the algorithm doesn\u2019t work.\nYou should invert every component separately:",
            "References": "[1]Roussopoulos, N.D. , \u201cA max {m, n} algorithm for determining the graph H from\nits line graph G\u201d, Information Processing Letters 2, (1973), 108\u2013112, ISSN 0020-0190,DOI link"
        }
    },
    {
        "Section ID": "dodecahedral_graph",
        "Description": [
            "Returns the Platonic Dodecahedral graph.",
            "The dodecahedral graph has 20 nodes and 30 edges. The skeleton of the\ndodecahedron forms a graph. It is one of 5 Platonic graphs [1] .\nIt can be described in LCF notation as: [10,7,4,-4,-7,10,-4,7,-7,4]^2  [2] ."
        ],
        "Field List": {
            "Parameters:": {
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : networkx Graph": "Dodecahedral Graph with 20 nodes and 30 edges"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://en.wikipedia.org/wiki/Regular_dodecahedron#Dodecahedral_graph  [2]https://mathworld.wolfram.com/DodecahedralGraph.html"
        }
    },
    {
        "Section ID": "to_sparse6_bytes",
        "Description": [
            "Convert an undirected graph to bytes in sparse6 format."
        ],
        "Field List": {
            "Parameters:": {
                "G : Graph (undirected)": "",
                "nodes: list or iterable": "Nodes are labeled 0\u2026n-1 in the order provided.  If None the ordering\ngiven byG.nodes()is used.",
                "header: bool": "If True add \u2018>>sparse6<<\u2019 bytes to head of data."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the graph is directed.",
                "ValueError": "If the graph has at least2**36nodes; the sparse6 format\nis only defined for graphs of order less than2**36."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The returned bytes end with a newline character. The format does not support edge or node labels.",
            "References": "[1]Graph6 specification\n<https://users.cecs.anu.edu.au/~bdm/data/formats.html>",
            "Examples": "nx.to_sparse6_bytes(nx.path_graph(2))\n# b'>>sparse6<<:An\\n'"
        }
    },
    {
        "Section ID": "faster_could_be_isomorphic",
        "Description": [
            "Returns False if graphs are definitely not isomorphic.",
            "True does NOT guarantee isomorphism."
        ],
        "Field List": {
            "Parameters:": {
                "G1, G2 : graphs": "The two graphs G1 and G2 must be the same type."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Checks for matching degree sequences."
        }
    },
    {
        "Section ID": "to_vertex_cover",
        "Description": [
            "Returns the minimum vertex cover corresponding to the given maximum\nmatching of the bipartite graph G ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected bipartite graph",
                "matching : dictionary": "A dictionary whose keys are vertices inGand whose values are the\ndistinct neighbors comprising the maximum matching forG, as returned\nby, for example,maximum_matching(). The dictionarymustrepresent the maximum matching.",
                "top_nodes : container": "Container with all nodes in one bipartite node set. If not supplied\nit will be computed. But if more than one solution exists an exception\nwill be raised."
            },
            "Returns:": {
                "vertex_cover : set": "The minimum vertex cover inG."
            },
            "Raises:": {
                "AmbiguousSolution": "Raised if the input bipartite graph is disconnected and no container\nwith all nodes in one bipartite set is provided. When determining\nthe nodes in each bipartite set more than one valid solution is\npossible if the input graph is disconnected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This function is implemented using the procedure guaranteed by Konig\u2019s\ntheorem ,\nwhich proves an equivalence between a maximum matching and a minimum vertex\ncover in bipartite graphs. Since a minimum vertex cover is the complement of a maximum independent set\nfor any graph, one can compute the maximum independent set of a bipartite\ngraph this way:"
        }
    },
    {
        "Section ID": "prominent_group",
        "Description": [
            "Find the prominent group of size \\(k\\) in graph \\(G\\) . The prominence of the\ngroup is evaluated by the group betweenness centrality.",
            "Group betweenness centrality of a group of nodes \\(C\\) is the sum of the\nfraction of all-pairs shortest paths that pass through any vertex in \\(C\\)",
            "where \\(V\\) is the set of nodes, \\(\\sigma(s, t)\\) is the number of\nshortest \\((s, t)\\) -paths, and \\(\\sigma(s, t|C)\\) is the number of\nthose paths passing through some node in group \\(C\\) . Note that \\((s, t)\\) are not members of the group ( \\(V-C\\) is the set of nodes\nin \\(V\\) that are not in \\(C\\) )."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.",
                "k : int": "The number of nodes in the group.",
                "normalized : bool, optional (default=True)": "If True, group betweenness is normalized by1/((|V|-|C|)(|V|-|C|-1))where|V|is the number of nodes in G and|C|is the number of\nnodes in C.",
                "weight : None or string, optional (default=None)": "If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight.\nThe weight of an edge is treated as the length or distance between the two sides.",
                "endpoints : bool, optional (default=False)": "If True include the endpoints in the shortest path counts.",
                "C : list or set, optional (default=None)": "list of nodes which won\u2019t be candidates of the prominent group.",
                "greedy : bool, optional (default=False)": "Using a naive greedy algorithm in order to find non-optimal prominent\ngroup. For scale free networks the results are negligibly below the optimal\nresults."
            },
            "Returns:": {
                "max_GBC : float": "The group betweenness centrality of the prominent group.",
                "max_group : list": "The list of nodes in the prominent group."
            },
            "Raises:": {
                "NodeNotFound": "If node(s) in C are not present in G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Group betweenness centrality is described in [1] and its importance discussed in [3] .\nThe algorithm is described in [2] and is based on techniques mentioned in [4] . The number of nodes in the group must be a maximum of n-2 where n is the total number of nodes in the graph. For weighted graphs the edge weights must be greater than zero.\nZero edge weights can produce an infinite number of equal length\npaths between pairs of nodes. The total number of paths between source and target is counted\ndifferently for directed and undirected graphs. Directed paths\nbetween \u201cu\u201d and \u201cv\u201d are counted as two possible paths (one each\ndirection) while undirected paths between \u201cu\u201d and \u201cv\u201d are counted\nas one path. Said another way, the sum in the expression above is\nover all s!=t for directed graphs and for s<t for undirected graphs.",
            "References": "[1]M G Everett and S P Borgatti:\nThe Centrality of Groups and Classes.\nJournal of Mathematical Sociology. 23(3): 181-201. 1999.http://www.analytictech.com/borgatti/group_centrality.htm  [2]Rami Puzis, Yuval Elovici, and Shlomi Dolev:\n\u201cFinding the Most Prominent Group in Complex Networks\u201d\nAI communications 20(4): 287-296, 2007.https://www.researchgate.net/profile/Rami_Puzis2/publication/220308855  [3]Sourav Medya et. al.:\nGroup Centrality Maximization via Network Design.\nSIAM International Conference on Data Mining, SDM 2018, 126\u2013134.https://sites.cs.ucsb.edu/~arlei/pubs/sdm18.pdf  [4]Rami Puzis, Yuval Elovici, and Shlomi Dolev.\n\u201cFast algorithm for successive computation of group betweenness centrality.\u201dhttps://journals.aps.org/pre/pdf/10.1103/PhysRevE.76.056709"
        }
    },
    {
        "Section ID": "edge_load_centrality",
        "Description": [
            "Compute edge load.",
            "WARNING: This concept of edge load has not been analysed\nor discussed outside of NetworkX that we know of.\nIt is based loosely on load_centrality in the sense that\nit counts the number of shortest paths which cross each edge.\nThis function is for demonstration and testing purposes."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph",
                "cutoff : bool, optional (default=False)": "If specified, only consider paths of length <= cutoff."
            },
            "Returns:": {
                "A dict keyed by edge 2-tuple to the number of shortest paths": "",
                "which use that edge. Where more than one path is shortest": "",
                "the count is divided equally among paths.": ""
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "intersection_array",
        "Description": [
            "Returns the intersection array of a distance-regular graph.",
            "Given a distance-regular graph G with integers b_i, c_i,i = 0,\u2026.,d\nsuch that for any 2 vertices x,y in G at a distance i=d(x,y), there\nare exactly c_i neighbors of y at a distance of i-1 from x and b_i\nneighbors of y at a distance of i+1 from x.",
            "A distance regular graph\u2019s intersection array is given by,\n[b_0,b_1,\u2026..b_{d-1};c_1,c_2,\u2026..c_d]"
        ],
        "Field List": {
            "Parameters:": {
                "G: Networkx graph (undirected)": ""
            },
            "Returns:": {
                "b,c: tuple of lists": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Weisstein, Eric W. \u201cIntersection Array.\u201d\nFrom MathWorld\u2013A Wolfram Web Resource.http://mathworld.wolfram.com/IntersectionArray.html",
            "Examples": "G=nx.icosahedral_graph()\nnx.intersection_array(G)\n# ([5, 2, 1], [1, 2, 5])"
        }
    },
    {
        "Section ID": "random_layout",
        "Description": [
            "Position nodes uniformly at random in the unit square.",
            "For every node, a position is generated by choosing each of dim\ncoordinates uniformly at random on the interval [0.0, 1.0).",
            "NumPy ( http://scipy.org ) is required for this function."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph or list of nodes": "A position will be assigned to every node in G.",
                "center : array-like or None": "Coordinate pair around which to center the layout.",
                "dim : int": "Dimension of layout.",
                "seed : int, RandomState instance or None  optional (default=None)": "Set the random state for deterministic node layouts.\nIf int,seedis the seed used by the random number generator,\nif numpy.random.RandomState instance,seedis the random\nnumber generator,\nif None, the random number generator is the RandomState instance used\nby numpy.random."
            },
            "Returns:": {
                "pos : dict": "A dictionary of positions keyed by node"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.lollipop_graph(4,3)\npos=nx.random_layout(G)"
        }
    },
    {
        "Section ID": "line_graph",
        "Description": [
            "Returns the line graph of the graph or digraph G .",
            "The line graph of a graph G has a node for each edge in G and an\nedge joining those nodes if the two edges in G share a common node. For\ndirected graphs, nodes are adjacent exactly when the edges they represent\nform a directed path of length two.",
            "The nodes of the line graph are 2-tuples of nodes in the original graph (or\n3-tuples for multigraphs, with the key of the edge as the third element).",
            "For information about self-loops and more discussion, see the Notes section below."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX Graph, DiGraph, MultiGraph, or MultiDigraph.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "L : graph": "The line graph of G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Graph, node, and edge data are not propagated to the new graph. For\nundirected graphs, the nodes in G must be sortable, otherwise the\nconstructed line graph may not be correct. Self-loops in undirected graphs For an undirected graph G without multiple edges, each edge can be\nwritten as a set {u,v} .  Its line graph L has the edges of G as\nits nodes. If x and y are two nodes in L , then {x,y} is an edge\nin L if and only if the intersection of x and y is nonempty. Thus,\nthe set of all edges is determined by the set of all pairwise intersections\nof edges in G . Trivially, every edge in G would have a nonzero intersection with itself,\nand so every node in L should have a self-loop. This is not so\ninteresting, and the original context of line graphs was with simple\ngraphs, which had no self-loops or multiple edges. The line graph was also\nmeant to be a simple graph and thus, self-loops in L are not part of the\nstandard definition of a line graph. In a pairwise intersection matrix,\nthis is analogous to excluding the diagonal entries from the line graph\ndefinition. Self-loops and multiple edges in G add nodes to L in a natural way, and\ndo not require any fundamental changes to the definition. It might be\nargued that the self-loops we excluded before should now be included.\nHowever, the self-loops are still \u201ctrivial\u201d in some sense and thus, are\nusually excluded. Self-loops in directed graphs For a directed graph G without multiple edges, each edge can be written\nas a tuple (u,v) . Its line graph L has the edges of G as its\nnodes. If x and y are two nodes in L , then (x,y) is an edge in L if and only if the tail of x matches the head of y , for example, if x=(a,b) and y=(b,c) for some vertices a , b , and c in G . Due to the directed nature of the edges, it is no longer the case that\nevery edge in G should have a self-loop in L . Now, the only time\nself-loops arise is if a node in G itself has a self-loop.  So such\nself-loops are no longer \u201ctrivial\u201d but instead, represent essential\nfeatures of the topology of G . For this reason, the historical\ndevelopment of line digraphs is such that self-loops are included. When the\ngraph G has multiple edges, once again only superficial changes are\nrequired to the definition.",
            "References": "Harary, Frank, and Norman, Robert Z., \u201cSome properties of line digraphs\u201d,\nRend. Circ. Mat. Palermo, II. Ser. 9 (1960), 161\u2013168.  Hemminger, R. L.; Beineke, L. W. (1978), \u201cLine graphs and line digraphs\u201d,\nin Beineke, L. W.; Wilson, R. J., Selected Topics in Graph Theory,\nAcademic Press Inc., pp. 271\u2013305.",
            "Examples": "G=nx.star_graph(3)\nL=nx.line_graph(G)\nprint(sorted(map(sorted,L.edges())))# makes a 3-clique, K3\n# [[(0, 1), (0, 2)], [(0, 1), (0, 3)], [(0, 2), (0, 3)]]\nEdge attributes fromGare not copied over as node attributes inL, but\nattributes can be copied manually:\nG=nx.path_graph(4)\nG.add_edges_from((u,v,{\"tot\":u+v})foru,vinG.edges)\nG.edges(data=True)\n# EdgeDataView([(0, 1, {'tot': 1}), (1, 2, {'tot': 3}), (2, 3, {'tot': 5})])\nH=nx.line_graph(G)\nH.add_nodes_from((node,G.edges[node])fornodeinH)\nH.nodes(data=True)\n# NodeDataView({(0, 1): {'tot': 1}, (2, 3): {'tot': 5}, (1, 2): {'tot': 3}})"
        }
    },
    {
        "Section ID": "number_weakly_connected_components",
        "Description": [
            "Returns the number of weakly connected components in G."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A directed graph."
            },
            "Returns:": {
                "n : integer": "Number of weakly connected components"
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For directed graphs only.",
            "Examples": "G=nx.DiGraph([(0,1),(2,1),(3,4)])\nnx.number_weakly_connected_components(G)\n# 2"
        }
    },
    {
        "Section ID": "non_randomness",
        "Description": [
            "Compute the non-randomness of graph G.",
            "The first returned value nr is the sum of non-randomness values of all\nedges within the graph (where the non-randomness of an edge tends to be\nsmall when the two nodes linked by that edge are from two different\ncommunities).",
            "The second computed value nr_rd is a relative measure that indicates\nto what extent graph G is different from random graphs in terms\nof probability. When it is close to 0, the graph tends to be more\nlikely generated by an Erdos Renyi model."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Graph must be symmetric, connected, and without self-loops.",
                "k : int": "The number of communities in G.\nIf k is not set, the function will use a default community\ndetection algorithm to set it.",
                "weight : string or None, optional (default=None)": "The name of an edge attribute that holds the numerical value used\nas a weight. If None, then each edge has weight 1, i.e., the graph is\nbinary."
            },
            "Returns:": {
                "non-randomness : (float, float) tuple": "Non-randomness, Relative non-randomness w.r.t.\nErdos Renyi random graphs."
            },
            "Raises:": {
                "NetworkXException": "if the input graph is not connected.",
                "NetworkXError": "if the input graph contains self-loops."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This computes Eq. (4.4) and (4.5) in Ref. [1] . If a weight field is passed, this algorithm will use the eigenvalues\nof the weighted adjacency matrix to compute Eq. (4.4) and (4.5).",
            "References": "[1]Xiaowei Ying and Xintao Wu,\nOn Randomness Measures for Social Networks,\nSIAM International Conference on Data Mining. 2009",
            "Examples": "G=nx.karate_club_graph()\nnr,nr_rd=nx.non_randomness(G,2)\nnr,nr_rd=nx.non_randomness(G,2,\"weight\")"
        }
    },
    {
        "Section ID": "draw_networkx_edges",
        "Description": [
            "Draw the edges of the graph G.",
            "This draws only the edges of the graph G."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph",
                "pos : dictionary": "A dictionary with nodes as keys and positions as values.\nPositions should be sequences of length 2.",
                "edgelist : collection of edge tuples (default=G.edges())": "Draw only specified edges",
                "width : float or array of floats (default=1.0)": "Line width of edges",
                "edge_color : color or array of colors (default=\u2019k\u2019)": "Edge color. Can be a single color or a sequence of colors with the same\nlength as edgelist. Color can be string or rgb (or rgba) tuple of\nfloats from 0-1. If numeric values are specified they will be\nmapped to colors using the edge_cmap and edge_vmin,edge_vmax parameters.",
                "style : string or array of strings (default=\u2019solid\u2019)": "Edge line style e.g.: \u2018-\u2019, \u2018\u2013\u2019, \u2018-.\u2019, \u2018:\u2019\nor words like \u2018solid\u2019 or \u2018dashed\u2019.\nCan be a single style or a sequence of styles with the same\nlength as the edge list.\nIf less styles than edges are given the styles will cycle.\nIf more styles than edges are given the styles will be used sequentially\nand not be exhausted.\nAlso,(offset,onoffseq)tuples can be used as style instead of a strings.\n(Seematplotlib.patches.FancyArrowPatch:linestyle)",
                "alpha : float or array of floats (default=None)": "The edge transparency.  This can be a single alpha value,\nin which case it will be applied to all specified edges. Otherwise,\nif it is an array, the elements of alpha will be applied to the colors\nin order (cycling through alpha multiple times if necessary).",
                "edge_cmap : Matplotlib colormap, optional": "Colormap for mapping intensities of edges",
                "edge_vmin,edge_vmax : floats, optional": "Minimum and maximum for edge colormap scaling",
                "ax : Matplotlib Axes object, optional": "Draw the graph in the specified Matplotlib axes.",
                "arrows : bool or None, optional (default=None)": "IfNone, directed graphs draw arrowheads withFancyArrowPatch, while undirected graphs draw edges\nviaLineCollectionfor speed.\nIfTrue, draw arrowheads with FancyArrowPatches (bendable and stylish).\nIfFalse, draw edges using LineCollection (linear and fast).Note: Arrowheads will be the same color as edges.",
                "arrowstyle : str (default=\u2019-|>\u2019 for directed graphs)": "For directed graphs andarrows==Truedefaults to \u2018-|>\u2019,\nFor undirected graphs default to \u2018-\u2018.Seematplotlib.patches.ArrowStylefor more options.",
                "arrowsize : int (default=10)": "For directed graphs, choose the size of the arrow head\u2019s length and\nwidth. Seematplotlib.patches.FancyArrowPatchfor attributemutation_scalefor more info.",
                "connectionstyle : string or iterable of strings (default=\u201darc3\u201d)": "Pass the connectionstyle parameter to create curved arc of rounding\nradius rad. For example, connectionstyle=\u2019arc3,rad=0.2\u2019.\nSeematplotlib.patches.ConnectionStyleandmatplotlib.patches.FancyArrowPatchfor more info.\nIf Iterable, index indicates i\u2019th edge key of MultiGraph",
                "node_size : scalar or array (default=300)": "Size of nodes. Though the nodes are not drawn with this function, the\nnode size is used in determining edge positioning.",
                "nodelist : list, optional (default=G.nodes())": "This provides the node order for thenode_sizearray (if it is an array).",
                "node_shape : string (default=\u2019o\u2019)": "The marker used for nodes, used in determining edge positioning.\nSpecification is as amatplotlib.markersmarker, e.g. one of \u2018so^>v<dph8\u2019.",
                "label : None or string": "Label for legend",
                "min_source_margin : int (default=0)": "The minimum margin (gap) at the beginning of the edge at the source.",
                "min_target_margin : int (default=0)": "The minimum margin (gap) at the end of the edge at the target.",
                "hide_ticks : bool, optional": "Hide ticks of axes. WhenTrue(the default), ticks and ticklabels\nare removed from the axes. To set ticks and tick labels to the pyplot default,\nusehide_ticks=False."
            },
            "Returns:": {
                "matplotlib.collections.LineCollection or a list of matplotlib.patches.FancyArrowPatch": "Ifarrows=True, a list of FancyArrowPatches is returned.\nIfarrows=False, a LineCollection is returned.\nIfarrows=None(the default), then a LineCollection is returned ifGis undirected, otherwise returns a list of FancyArrowPatches."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For directed graphs, arrows are drawn at the head end.  Arrows can be\nturned off with keyword arrows=False or by passing an arrowstyle without\nan arrow on the end. Be sure to include node_size as a keyword argument; arrows are\ndrawn considering the size of nodes. Self-loops are always drawn with FancyArrowPatch regardless of the value of arrows or whether G is directed.\nWhen arrows=False or arrows=None and G is undirected, the\nFancyArrowPatches corresponding to the self-loops are not explicitly\nreturned. They should instead be accessed via the Axes.patches attribute (see examples).",
            "Examples": "G=nx.dodecahedral_graph()\nedges=nx.draw_networkx_edges(G,pos=nx.spring_layout(G))\nG=nx.DiGraph()\nG.add_edges_from([(1,2),(1,3),(2,3)])\narcs=nx.draw_networkx_edges(G,pos=nx.spring_layout(G))\nalphas=[0.3,0.4,0.5]\nfori,arcinenumerate(arcs):# change alpha values of arcs\narc.set_alpha(alphas[i])\nThe FancyArrowPatches corresponding to self-loops are not always\nreturned, but can always be accessed via thepatchesattribute of thematplotlib.Axesobject.\nimportmatplotlib.pyplotasplt\nfig,ax=plt.subplots()\nG=nx.Graph([(0,1),(0,0)])# Self-loop at node 0\nedge_collection=nx.draw_networkx_edges(G,pos=nx.circular_layout(G),ax=ax)\nself_loop_fap=ax.patches[0]\nAlso see the NetworkX drawing examples athttps://networkx.org/documentation/latest/auto_examples/index.html"
        }
    },
    {
        "Section ID": "all_pairs_shortest_path",
        "Description": [
            "Compute shortest paths between all nodes."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "cutoff : integer, optional": "Depth at which to stop the search. Only paths of length at mostcutoffare returned."
            },
            "Returns:": {
                "paths : iterator": "Dictionary, keyed by source and target, of shortest paths."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "There may be multiple shortest paths with the same length between\ntwo nodes. For each pair, this function returns only one of those paths.",
            "Examples": "G=nx.path_graph(5)\npath=dict(nx.all_pairs_shortest_path(G))\nprint(path[0][4])\n# [0, 1, 2, 3, 4]"
        }
    },
    {
        "Section ID": "strongly_connected_components_recursive",
        "Description": [
            "Generate nodes in strongly connected components of graph.",
            "Recursive version of algorithm."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "A directed graph."
            },
            "Returns:": {
                "comp : generator of sets": "A generator of sets of nodes, one for each strongly connected\ncomponent of G."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Uses Tarjan\u2019s algorithm[Re7cb971df765-1]_ with Nuutila\u2019s modifications[Re7cb971df765-2]_.",
            "References": "[1]Depth-first search and linear graph algorithms, R. Tarjan\nSIAM Journal of Computing 1(2):146-160, (1972).  [2]On finding the strongly connected components in a directed graph.\nE. Nuutila and E. Soisalon-Soinen\nInformation Processing Letters 49(1): 9-14, (1994)..",
            "Examples": "Generate a sorted list of strongly connected components, largest first.\nG=nx.cycle_graph(4,create_using=nx.DiGraph())\nnx.add_cycle(G,[10,11,12])\n[\nlen(c)\nforcinsorted(\nnx.strongly_connected_components_recursive(G),key=len,reverse=True\n)\n]\n# [4, 3]\nIf you only want the largest component, it\u2019s more efficient to\nuse max instead of sort.\nlargest=max(nx.strongly_connected_components_recursive(G),key=len)\nTo create the induced subgraph of the components use:\n>>> S = [G.subgraph(c).copy() for c in nx.weakly_connected_components(G)]"
        }
    },
    {
        "Section ID": "dag_longest_path_length",
        "Description": [
            "Returns the longest path length in a DAG"
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX DiGraph": "A directed acyclic graph (DAG)",
                "weight : string, optional": "Edge data key to use for weight",
                "default_weight : int, optional": "The weight of edges that do not have a weight attribute"
            },
            "Returns:": {
                "int": "Longest path length"
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis not directed"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "DG=nx.DiGraph([(0,1,{\"cost\":1}),(1,2,{\"cost\":1}),(0,2,{\"cost\":42})])\nlist(nx.all_simple_paths(DG,0,2))\n# [[0, 1, 2], [0, 2]]\nnx.dag_longest_path_length(DG)\n# 2\nnx.dag_longest_path_length(DG,weight=\"cost\")\n# 42"
        }
    },
    {
        "Section ID": "is_partition",
        "Description": [
            "Returns True if communities is a partition of the nodes of G .",
            "A partition of a universe set is a family of pairwise disjoint sets\nwhose union is the entire universe set."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph.": "",
                "communities : list or iterable of sets of nodes": "If not a list, the iterable is converted internally to a list.\nIf it is an iterator it is exhausted."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "complete_to_chordal_graph",
        "Description": [
            "Return a copy of G completed to a chordal graph",
            "Adds edges to a copy of G to create a chordal graph. A graph G=(V,E) is\ncalled chordal if for each cycle with length bigger than 3, there exist\ntwo non-adjacent nodes connected by an edge (called a chord)."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected graph"
            },
            "Returns:": {
                "H : NetworkX graph": "The chordal enhancement of G",
                "alpha : Dictionary": "The elimination ordering of nodes of G"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "There are different approaches to calculate the chordal\nenhancement of a graph. The algorithm used here is called\nMCS-M and gives at least minimal (local) triangulation of graph. Note\nthat this triangulation is not necessarily a global minimum. https://en.wikipedia.org/wiki/Chordal_graph",
            "References": "[1]Berry, Anne & Blair, Jean & Heggernes, Pinar & Peyton, Barry. (2004)\nMaximum Cardinality Search for Computing Minimal Triangulations of\nGraphs.  Algorithmica. 39. 287-298. 10.1007/s00453-004-1084-3.",
            "Examples": "fromnetworkx.algorithms.chordalimportcomplete_to_chordal_graph\nG=nx.wheel_graph(10)\nH,alpha=complete_to_chordal_graph(G)"
        }
    },
    {
        "Section ID": "double_edge_swap",
        "Description": [
            "Swap two edges in the graph while keeping the node degrees fixed.",
            "A double-edge swap removes two randomly chosen edges u-v and x-y\nand creates the new edges u-x and v-y:",
            "If either the edge u-x or v-y already exist no swap is performed\nand another attempt is made to find a suitable edge pair."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "An undirected graph",
                "nswap : integer (optional, default=1)": "Number of double-edge swaps to perform",
                "max_tries : integer (optional)": "Maximum number of attempts to swap edges",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "G : graph": "The graph after double edge swaps."
            },
            "Raises:": {
                "NetworkXError": "IfGis directed, or\nIfnswap>max_tries, or\nIf there are fewer than 4 nodes or 2 edges inG.",
                "NetworkXAlgorithmError": "If the number of swap attempts exceedsmax_triesbeforenswapswaps are made"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Does not enforce any connectivity constraints. The graph G is modified in place."
        }
    },
    {
        "Section ID": "gnc_graph",
        "Description": [
            "Returns the growing network with copying (GNC) digraph with n nodes.",
            "The GNC graph is built by adding nodes one at a time with a link to one\npreviously added node (chosen uniformly at random) and to all of that\nnode\u2019s successors."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes for the generated graph.",
                "create_using : NetworkX graph constructor, optional (default DiGraph)": "Graph type to create. If graph instance, then cleared before populated.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]P. L. Krapivsky and S. Redner,\nNetwork Growth by Copying,\nPhys. Rev. E, 71, 036118, 2005k.},"
        }
    },
    {
        "Section ID": "min_weighted_vertex_cover",
        "Description": [
            "Returns an approximate minimum weighted vertex cover.",
            "The set of nodes returned by this function is guaranteed to be a\nvertex cover, and the total weight of the set is guaranteed to be at\nmost twice the total weight of the minimum weight vertex cover. In\nother words,",
            "where \\(S\\) is the vertex cover returned by this function, \\(S^*\\) is the vertex cover of minimum weight out of all vertex\ncovers of the graph, and \\(w\\) is the function that computes the\nsum of the weights of each node in that given set."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "weight : string, optional (default = None)": "If None, every node has weight 1. If a string, use this node\nattribute as the node weight. A node without this attribute is\nassumed to have weight 1."
            },
            "Returns:": {
                "min_weighted_cover : set": "Returns a set of nodes whose weight sum is no more than twice\nthe weight sum of the minimum weight vertex cover."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For a directed graph, a vertex cover has the same definition: a set\nof nodes such that each edge in the graph is incident to at least\none node in the set. Whether the node is the head or tail of the\ndirected edge is ignored. This is the local-ratio algorithm for computing an approximate\nvertex cover. The algorithm greedily reduces the costs over edges,\niteratively building a cover. The worst-case runtime of this\nimplementation is \\(O(m \\log n)\\) , where \\(n\\) is the number\nof nodes and \\(m\\) the number of edges in the graph.",
            "References": "[1]Bar-Yehuda, R., and Even, S. (1985). \u201cA local-ratio theorem for\napproximating the weighted vertex cover problem.\u201dAnnals of Discrete Mathematics, 25, 27\u201346\n<http://www.cs.technion.ac.il/~reuven/PDF/vc_lr.pdf>"
        }
    },
    {
        "Section ID": "edge_disjoint_paths",
        "Description": [
            "Returns the edges disjoint paths between source and target.",
            "Edge disjoint paths are paths that do not share any edge. The\nnumber of edge disjoint paths between source and target is equal\nto their edge connectivity."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "s : node": "Source node for the flow.",
                "t : node": "Sink node for the flow.",
                "flow_func : function": "A function for computing the maximum flow among a pair of nodes.\nThe function has to accept at least three parameters: a Digraph,\na source node, and a target node. And return a residual network\nthat follows NetworkX conventions (seemaximum_flow()for\ndetails). If flow_func is None, the default maximum flow function\n(edmonds_karp()) is used. The choice of the default function\nmay change from version to version and should not be relied on.\nDefault value: None.",
                "cutoff : integer or None (default: None)": "Maximum number of paths to yield. If specified, the maximum flow\nalgorithm will terminate when the flow value reaches or exceeds the\ncutoff. This only works for flows that support the cutoff parameter\n(most do) and is ignored otherwise.",
                "auxiliary : NetworkX DiGraph": "Auxiliary digraph to compute flow based edge connectivity. It has\nto have a graph attribute called mapping with a dictionary mapping\nnode names in G and in the auxiliary digraph. If provided\nit will be reused instead of recreated. Default value: None.",
                "residual : NetworkX DiGraph": "Residual network to compute maximum flow. If provided it will be\nreused instead of recreated. Default value: None."
            },
            "Returns:": {
                "paths : generator": "A generator of edge independent paths."
            },
            "Raises:": {
                "NetworkXNoPath": "If there is no path between source and target.",
                "NetworkXError": "If source or target are not in the graph G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This is a flow based implementation of edge disjoint paths. We compute\nthe maximum flow between source and target on an auxiliary directed\nnetwork. The saturated edges in the residual network after running the\nmaximum flow algorithm correspond to edge disjoint paths between source\nand target in the original network. This function handles both directed\nand undirected graphs, and can use all flow algorithms from NetworkX flow\npackage.",
            "Examples": "We use in this example the platonic icosahedral graph, which has node\nedge connectivity 5, thus there are 5 edge disjoint paths between any\npair of nodes.\nG=nx.icosahedral_graph()\nlen(list(nx.edge_disjoint_paths(G,0,6)))\n# 5\nIf you need to compute edge disjoint paths on several pairs of\nnodes in the same graph, it is recommended that you reuse the\ndata structures that NetworkX uses in the computation: the\nauxiliary digraph for edge connectivity, and the residual\nnetwork for the underlying maximum flow computation.\nExample of how to compute edge disjoint paths among all pairs of\nnodes of the platonic icosahedral graph reusing the data\nstructures.\nimportitertools\n# You also have to explicitly import the function for\n# building the auxiliary digraph from the connectivity package\nfromnetworkx.algorithms.connectivityimportbuild_auxiliary_edge_connectivity\nH=build_auxiliary_edge_connectivity(G)\n# And the function for building the residual network from the\n# flow package\nfromnetworkx.algorithms.flowimportbuild_residual_network\n# Note that the auxiliary digraph has an edge attribute named capacity\nR=build_residual_network(H,\"capacity\")\nresult={n:{}forninG}\n# Reuse the auxiliary digraph and the residual network by passing them\n# as arguments\nforu,vinitertools.combinations(G,2):\nk=len(list(nx.edge_disjoint_paths(G,u,v,auxiliary=H,residual=R)))\nresult[u][v]=k\nall(result[u][v]==5foru,vinitertools.combinations(G,2))\n# True\nYou can also use alternative flow algorithms for computing edge disjoint\npaths. For instance, in dense networks the algorithmshortest_augmenting_path()will usually perform better than\nthe defaultedmonds_karp()which is faster for sparse\nnetworks with highly skewed degree distributions. Alternative flow\nfunctions have to be explicitly imported from the flow package.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\nlen(list(nx.edge_disjoint_paths(G,0,6,flow_func=shortest_augmenting_path)))\n# 5"
        }
    },
    {
        "Section ID": "write_weighted_edgelist",
        "Description": [
            "Write graph G as a list of edges with numeric weights."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "path : file or string": "File or filename to write. If a file is provided, it must be\nopened in \u2018wb\u2019 mode.\nFilenames ending in .gz or .bz2 will be compressed.",
                "comments : string, optional": "The character used to indicate the start of a comment",
                "delimiter : string, optional": "The string used to separate values.  The default is whitespace.",
                "encoding: string, optional": "Specify which encoding to use when writing file."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph()\nG.add_edge(1,2,weight=7)\nnx.write_weighted_edgelist(G,\"test.weighted.edgelist\")"
        }
    },
    {
        "Section ID": "shell_layout",
        "Description": [
            "Position nodes in concentric circles."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph or list of nodes": "A position will be assigned to every node in G.",
                "nlist : list of lists": "List of node lists for each shell.",
                "rotate : angle in radians (default=pi/len(nlist))": "Angle by which to rotate the starting position of each shell\nrelative to the starting position of the previous shell.\nTo recreate behavior before v2.5 use rotate=0.",
                "scale : number (default: 1)": "Scale factor for positions.",
                "center : array-like or None": "Coordinate pair around which to center the layout.",
                "dim : int": "Dimension of layout, currently only dim=2 is supported.\nOther dimension values result in a ValueError."
            },
            "Returns:": {
                "pos : dict": "A dictionary of positions keyed by node"
            },
            "Raises:": {
                "ValueError": "If dim != 2"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm currently only works in two dimensions and does not\ntry to minimize edge crossings.",
            "Examples": "G=nx.path_graph(4)\nshells=[[0],[1,2,3]]\npos=nx.shell_layout(G,shells)"
        }
    },
    {
        "Section ID": "dinitz",
        "Description": [
            "Find a maximum single-commodity flow using Dinitz\u2019 algorithm.",
            "This function returns the residual network resulting after computing\nthe maximum flow. See below for details about the conventions\nNetworkX uses for defining residual networks.",
            "This algorithm has a running time of \\(O(n^2 m)\\) for \\(n\\) nodes and \\(m\\) edges [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Edges of the graph are expected to have an attribute called\n\u2018capacity\u2019. If this attribute is not present, the edge is\nconsidered to have infinite capacity.",
                "s : node": "Source node for the flow.",
                "t : node": "Sink node for the flow.",
                "capacity : string": "Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: \u2018capacity\u2019.",
                "residual : NetworkX graph": "Residual network on which the algorithm is to be executed. If None, a\nnew residual network is created. Default value: None.",
                "value_only : bool": "If True compute only the value of the maximum flow. This parameter\nwill be ignored by this algorithm because it is not applicable.",
                "cutoff : integer, float": "If specified, the algorithm will terminate when the flow value reaches\nor exceeds the cutoff. In this case, it may be unable to immediately\ndetermine a minimum cut. Default value: None."
            },
            "Returns:": {
                "R : NetworkX DiGraph": "Residual network after computing the maximum flow."
            },
            "Raises:": {
                "NetworkXError": "The algorithm does not support MultiGraph and MultiDiGraph. If\nthe input graph is an instance of one of these two classes, a\nNetworkXError is raised.",
                "NetworkXUnbounded": "If the graph has a path of infinite capacity, the value of a\nfeasible flow on the graph is unbounded above and the function\nraises a NetworkXUnbounded."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The residual network R from an input graph G has the\nsame nodes as G . R is a DiGraph that contains a pair\nof edges (u,v) and (v,u) iff (u,v) is not a\nself-loop, and at least one of (u,v) and (v,u) exists\nin G . For each edge (u,v) in R , R[u][v]['capacity'] is equal to the capacity of (u,v) in G if it exists\nin G or zero otherwise. If the capacity is infinite, R[u][v]['capacity'] will have a high arbitrary finite value\nthat does not affect the solution of the problem. This value is stored in R.graph['inf'] . For each edge (u,v) in R , R[u][v]['flow'] represents the flow function of (u,v) and\nsatisfies R[u][v]['flow']==-R[v][u]['flow'] . The flow value, defined as the total flow into t , the sink, is\nstored in R.graph['flow_value'] . If cutoff is not\nspecified, reachability to t using only edges (u,v) such\nthat R[u][v]['flow']<R[u][v]['capacity'] induces a minimum s - t cut.",
            "References": "[1]Dinitz\u2019 Algorithm: The Original Version and Even\u2019s Version.\n2006. Yefim Dinitz. In Theoretical Computer Science. Lecture\nNotes in Computer Science. Volume 3895. pp 218-240.https://doi.org/10.1007/11685654_10",
            "Examples": "fromnetworkx.algorithms.flowimportdinitz\nThe functions that implement flow algorithms and output a residual\nnetwork, such as this one, are not imported to the base NetworkX\nnamespace, so you have to explicitly import them from the flow package.\nG=nx.DiGraph()\nG.add_edge(\"x\",\"a\",capacity=3.0)\nG.add_edge(\"x\",\"b\",capacity=1.0)\nG.add_edge(\"a\",\"c\",capacity=3.0)\nG.add_edge(\"b\",\"c\",capacity=5.0)\nG.add_edge(\"b\",\"d\",capacity=4.0)\nG.add_edge(\"d\",\"e\",capacity=2.0)\nG.add_edge(\"c\",\"y\",capacity=2.0)\nG.add_edge(\"e\",\"y\",capacity=3.0)\nR=dinitz(G,\"x\",\"y\")\nflow_value=nx.maximum_flow_value(G,\"x\",\"y\")\nflow_value\n# 3.0\nflow_value==R.graph[\"flow_value\"]\n# True"
        }
    },
    {
        "Section ID": "is_minimal_d_separator",
        "Description": [
            "Determine if z is a minimal d-separator for x and y .",
            "A d-separator, z , in a DAG is a set of nodes that blocks\nall paths from nodes in set x to nodes in set y .\nA minimal d-separator is a d-separator z such that removing\nany subset of nodes makes it no longer a d-separator.",
            "Note: This function checks whether z is a d-separator AND is\nminimal. One can use the function is_d_separator to only check if z is a d-separator. See examples below."
        ],
        "Field List": {
            "Parameters:": {
                "G : nx.DiGraph": "A NetworkX DAG.",
                "x : node | set": "A node or set of nodes in the graph.",
                "y : node | set": "A node or set of nodes in the graph.",
                "z : node | set": "The node or set of nodes to check if it is a minimal d-separating set.\nThe functionis_d_separator()is called inside this function\nto verify thatzis in fact a d-separator.",
                "included : set | node | None": "A node or set of nodes which must be included in the found separating set,\ndefault isNone, which means the empty set.",
                "restricted : set | node | None": "Restricted node or set of nodes to consider. Only these nodes can be in\nthe found separating set, default isNonemeaning all nodes inG."
            },
            "Returns:": {
                "bool": "Whether or not the setzis a minimal d-separator subject torestrictednodes andincludednode constraints."
            },
            "Raises:": {
                "NetworkXError": "Raises aNetworkXErrorif the input graph is not a DAG.",
                "NodeNotFound": "If any of the input nodes are not found in the graph,\naNodeNotFoundexception is raised."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This function works on verifying that a set is minimal and\nd-separating between two nodes. Uses criterion (a), (b), (c) on\npage 4 of [1] . a) closure( x ) and y are disjoint. b) z contains\nall nodes from included and is contained in the restricted nodes and in the union of ancestors of x , y , and included .\nc) the nodes in z not in included are contained in both\nclosure(x) and closure(y). The closure of a set is the set of nodes\nconnected to the set by a directed path in G. The complexity is \\(O(m)\\) , where \\(m\\) stands for the\nnumber of edges in the subgraph of G consisting of only the\nancestors of x and y . For full details, see [1] .",
            "References": "[1](1,2)van der Zander, Benito, and Maciej Li\u015bkiewicz. \u201cFinding\nminimal d-separators in linear time and applications.\u201d In\nUncertainty in Artificial Intelligence, pp. 637-647. PMLR, 2020.",
            "Examples": "G=nx.path_graph([0,1,2,3],create_using=nx.DiGraph)\nG.add_node(4)\nnx.is_minimal_d_separator(G,0,2,{1})\n# True\n# since {1} is the minimal d-separator, {1, 3, 4} is not minimal\nnx.is_minimal_d_separator(G,0,2,{1,3,4})\n# False\n# alternatively, if we only want to check that {1, 3, 4} is a d-separator\nnx.is_d_separator(G,0,2,{1,3,4})\n# True"
        }
    },
    {
        "Section ID": "quotient_graph",
        "Description": [
            "Returns the quotient graph of G under the specified equivalence\nrelation on nodes."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "The graph for which to return the quotient graph with the\nspecified node relation.",
                "partition : function, or dict or list of lists, tuples or sets": "If a function, this function must represent an equivalence\nrelation on the nodes ofG. It must take two argumentsuandvand return True exactly whenuandvare in the\nsame equivalence class. The equivalence classes form the nodes\nin the returned graph.If a dict of lists/tuples/sets, the keys can be any meaningful\nblock labels, but the values must be the block lists/tuples/sets\n(one list/tuple/set per block), and the blocks must form a valid\npartition of the nodes of the graph. That is, each node must be\nin exactly one block of the partition.If a list of sets, the list must form a valid partition of\nthe nodes of the graph. That is, each node must be in exactly\none block of the partition.",
                "edge_relation : Boolean function with two arguments": "This function must represent an edge relation on theblocksof\nthepartitionofG. It must take two arguments,BandC,\neach one a set of nodes, and return True exactly when there should be\nan edge joining blockBto blockCin the returned graph.Ifedge_relationis not specified, it is assumed to be the\nfollowing relation. BlockBis related to blockCif and\nonly if some node inBis adjacent to some node inC,\naccording to the edge set ofG.",
                "node_data : function": "This function takes one argument,B, a set of nodes inG,\nand must return a dictionary representing the node data\nattributes to set on the node representingBin the quotient graph.\nIf None, the following node attributes will be set:\u2018graph\u2019, the subgraph of the graphGthat this block\nrepresents,\u2018nnodes\u2019, the number of nodes in this block,\u2018nedges\u2019, the number of edges within this block,\u2018density\u2019, the density of the subgraph ofGthat this\nblock represents.",
                "edge_data : function": "This function takes two arguments,BandC, each one a set\nof nodes, and must return a dictionary representing the edge\ndata attributes to set on the edge joiningBandC, should\nthere be an edge joiningBandCin the quotient graph (if\nno such edge occurs in the quotient graph as determined byedge_relation, then the output of this function is ignored).If the quotient graph would be a multigraph, this function is\nnot applied, since the edge data from each edge in the graphGappears in the edges of the quotient graph.",
                "weight : string or None, optional (default=\u201dweight\u201d)": "The name of an edge attribute that holds the numerical value\nused as a weight. If None then each edge has weight 1.",
                "relabel : bool": "If True, relabel the nodes of the quotient graph to be\nnonnegative integers. Otherwise, the nodes are identified withfrozensetinstances representing the blocks given inpartition.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "NetworkX graph": "The quotient graph ofGunder the equivalence relation\nspecified bypartition. If the partition were given as a\nlist ofsetinstances andrelabelis False,\neach node will be afrozensetcorresponding to the sameset."
            },
            "Raises:": {
                "NetworkXException": "If the given partition is not a valid partition of the nodes ofG."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Patrick Doreian, Vladimir Batagelj, and Anuska Ferligoj.Generalized Blockmodeling.\nCambridge University Press, 2004.",
            "Examples": "The quotient graph of the complete bipartite graph under the \u201csame\nneighbors\u201d equivalence relation isK_2. Under this relation, two nodes\nare equivalent if they are not adjacent but have the same neighbor set.\nG=nx.complete_bipartite_graph(2,3)\nsame_neighbors=lambdau,v:(unotinG[v]andvnotinG[u]andG[u]==G[v])\nQ=nx.quotient_graph(G,same_neighbors)\nK2=nx.complete_graph(2)\nnx.is_isomorphic(Q,K2)\n# True\nThe quotient graph of a directed graph under the \u201csame strongly connected\ncomponent\u201d equivalence relation is the condensation of the graph (seecondensation()). This example comes from the Wikipedia article`Strongly connected component`_.\nG=nx.DiGraph()\nedges=[\n\"ab\",\n\"be\",\n\"bf\",\n\"bc\",\n\"cg\",\n\"cd\",\n\"dc\",\n\"dh\",\n\"ea\",\n\"ef\",\n\"fg\",\n\"gf\",\n\"hd\",\n\"hf\",\n]\nG.add_edges_from(tuple(x)forxinedges)\ncomponents=list(nx.strongly_connected_components(G))\nsorted(sorted(component)forcomponentincomponents)\n# [['a', 'b', 'e'], ['c', 'd', 'h'], ['f', 'g']]\n\nC=nx.condensation(G,components)\ncomponent_of=C.graph[\"mapping\"]\nsame_component=lambdau,v:component_of[u]==component_of[v]\nQ=nx.quotient_graph(G,same_component)\nnx.is_isomorphic(C,Q)\n# True\nNode identification can be represented as the quotient of a graph under the\nequivalence relation that places the two nodes in one block and each other\nnode in its own singleton block.\nK24=nx.complete_bipartite_graph(2,4)\nK34=nx.complete_bipartite_graph(3,4)\nC=nx.contracted_nodes(K34,1,2)\nnodes={1,2}\nis_contracted=lambdau,v:uinnodesandvinnodes\nQ=nx.quotient_graph(K34,is_contracted)\nnx.is_isomorphic(Q,C)\n# True\nnx.is_isomorphic(Q,K24)\n# True\nThe blockmodeling technique described in[1]can be implemented as a\nquotient graph.\nG=nx.path_graph(6)\npartition=[{0,1},{2,3},{4,5}]\nM=nx.quotient_graph(G,partition,relabel=True)\nlist(M.edges())\n# [(0, 1), (1, 2)]\nHere is the sample example but using partition as a dict of block sets.\nG=nx.path_graph(6)\npartition={0:{0,1},2:{2,3},4:{4,5}}\nM=nx.quotient_graph(G,partition,relabel=True)\nlist(M.edges())\n# [(0, 1), (1, 2)]\nPartitions can be represented in various ways:"
        }
    },
    {
        "Section ID": "edge_betweenness_centrality",
        "Description": [
            "Compute betweenness centrality for edges.",
            "Betweenness centrality of an edge \\(e\\) is the sum of the\nfraction of all-pairs shortest paths that pass through \\(e\\)",
            "where \\(V\\) is the set of nodes, \\(\\sigma(s, t)\\) is the number of\nshortest \\((s, t)\\) -paths, and \\(\\sigma(s, t|e)\\) is the number of\nthose paths passing through edge \\(e\\)  [2] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.",
                "k : int, optional (default=None)": "If k is not None use k node samples to estimate betweenness.\nThe value of k <= n where n is the number of nodes in the graph.\nHigher values give better approximation.",
                "normalized : bool, optional": "If True the betweenness values are normalized by\\(2/(n(n-1))\\)for graphs, and\\(1/(n(n-1))\\)for directed graphs where\\(n\\)is the number of nodes in G.",
                "weight : None or string, optional (default=None)": "If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight.\nWeights are used to calculate weighted shortest paths, so they are\ninterpreted as distances.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.\nNote that this is only used if k is not None."
            },
            "Returns:": {
                "edges : dictionary": "Dictionary of edges with betweenness centrality as the value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The algorithm is from Ulrik Brandes [1] . For weighted graphs the edge weights must be greater than zero.\nZero edge weights can produce an infinite number of equal length\npaths between pairs of nodes.",
            "References": "[1]A Faster Algorithm for Betweenness Centrality. Ulrik Brandes,\nJournal of Mathematical Sociology 25(2):163-177, 2001.https://doi.org/10.1080/0022250X.2001.9990249  [2]Ulrik Brandes: On Variants of Shortest-Path Betweenness\nCentrality and their Generic Computation.\nSocial Networks 30(2):136-145, 2008.https://doi.org/10.1016/j.socnet.2007.11.001"
        }
    },
    {
        "Section ID": "fast_label_propagation_communities",
        "Description": [
            "Returns communities in G as detected by fast label propagation.",
            "The fast label propagation algorithm is described in [1] . The algorithm is\nprobabilistic and the found communities may vary in different executions.",
            "The algorithm operates as follows. First, the community label of each node is\nset to a unique label. The algorithm then repeatedly updates the labels of\nthe nodes to the most frequent label in their neighborhood. In case of ties,\na random label is chosen from the most frequent labels.",
            "The algorithm maintains a queue of nodes that still need to be processed.\nInitially, all nodes are added to the queue in a random order. Then the nodes\nare removed from the queue one by one and processed. If a node updates its label,\nall its neighbors that have a different label are added to the queue (if not\nalready in the queue). The algorithm stops when the queue is empty."
        ],
        "Field List": {
            "Parameters:": {
                "G : Graph, DiGraph, MultiGraph, or MultiDiGraph": "Any NetworkX graph.",
                "weight : string, or None (default)": "The edge attribute representing a non-negative weight of an edge. If None,\neach edge is assumed to have weight one. The weight of an edge is used in\ndetermining the frequency with which a label appears among the neighbors of\na node (edge with weightwis equivalent towunweighted edges).",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state. SeeRandomness."
            },
            "Returns:": {
                "communities : iterable": "Iterable of communities given as sets of nodes."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge directions are ignored for directed graphs.\nEdge weights must be non-negative numbers.",
            "References": "[1]Vincent A. Traag & Lovro \u0160ubelj. \u201cLarge network community detection by\nfast label propagation.\u201d Scientific Reports 13 (2023): 2701.https://doi.org/10.1038/s41598-023-29610-z"
        }
    },
    {
        "Section ID": "is_semiconnected",
        "Description": [
            "Returns True if the graph is semiconnected, False otherwise.",
            "A graph is semiconnected if and only if for any pair of nodes, either one\nis reachable from the other, or they are mutually reachable.",
            "This function uses a theorem that states that a DAG is semiconnected\nif for any topological sort, for node \\(v_n\\) in that sort, there is an\nedge \\((v_i, v_{i+1})\\) . That allows us to check if a non-DAG G is\nsemiconnected by condensing the graph: i.e. constructing a new graph H with nodes being the strongly connected components of G , and edges\n(scc_1, scc_2) if there is a edge \\((v_1, v_2)\\) in G for some \\(v_1 \\in scc_1\\) and \\(v_2 \\in scc_2\\) . That results in a DAG, so we compute\nthe topological sort of H and check if for every \\(n\\) there is an edge \\((scc_n, scc_{n+1})\\) ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A directed graph."
            },
            "Returns:": {
                "semiconnected : bool": "True if the graph is semiconnected, False otherwise."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the input graph is undirected.",
                "NetworkXPointlessConcept": "If the graph is empty."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.path_graph(4,create_using=nx.DiGraph())\nprint(nx.is_semiconnected(G))\n# True\nG=nx.DiGraph([(1,2),(3,2)])\nprint(nx.is_semiconnected(G))\n# False"
        }
    },
    {
        "Section ID": "dominating_set",
        "Description": [
            "Finds a dominating set for the graph G.",
            "A dominating set for a graph with node set V is a subset D of V such that every node not in D is adjacent to at least one\nmember of D  [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "start_with : node (default=None)": "Node to use as a starting point for the algorithm."
            },
            "Returns:": {
                "D : set": "A dominating set for G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This function is an implementation of algorithm 7 in [2] which\nfinds some dominating set, not necessarily the smallest one.",
            "References": "[1]https://en.wikipedia.org/wiki/Dominating_set  [2]Abdol-Hossein Esfahanian. Connectivity Algorithms.http://www.cse.msu.edu/~cse835/Papers/Graph_connectivity_revised.pdf"
        }
    },
    {
        "Section ID": "caveman_graph",
        "Description": [
            "Returns a caveman graph of l cliques of size k ."
        ],
        "Field List": {
            "Parameters:": {
                "l : int": "Number of cliques",
                "k : int": "Size of cliques"
            },
            "Returns:": {
                "G : NetworkX Graph": "caveman graph"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This returns an undirected graph, it can be converted to a directed\ngraph using nx.to_directed() , or a multigraph using nx.MultiGraph(nx.caveman_graph(l,k)) . Only the undirected version is\ndescribed in [1] and it is unclear which of the directed\ngeneralizations is most useful.",
            "References": "[1]Watts, D. J. \u2018Networks, Dynamics, and the Small-World Phenomenon.\u2019\nAmer. J. Soc. 105, 493-527, 1999.",
            "Examples": "G=nx.caveman_graph(3,3)"
        }
    },
    {
        "Section ID": "random_unlabeled_rooted_tree",
        "Description": [
            "Returns a number of unlabeled rooted trees uniformly at random",
            "Returns one or more (depending on number_of_trees )\nunlabeled rooted trees with n nodes drawn uniformly\nat random."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes",
                "number_of_trees : int or None (default)": "If not None, this number of trees is generated and returned.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "networkx.Graph : or list of : networkx.Graph": "A singlenetworkx.Graph(or a list thereof, ifnumber_of_treesis specified) with nodes in the set {0, \u2026,n- 1}.\nThe \u201croot\u201d graph attribute identifies the root of the tree."
            },
            "Raises:": {
                "NetworkXPointlessConcept": "Ifnis zero (because the null graph is not a tree)."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The trees are generated using the \u201cRANRUT\u201d algorithm from [1] .\nThe algorithm needs to compute some counting functions\nthat are relatively expensive: in case several trees are needed,\nit is advisable to use the number_of_trees optional argument\nto reuse the counting functions.",
            "References": "[1]Nijenhuis, Albert, and Wilf, Herbert S.\n\u201cCombinatorial algorithms: for computers and calculators.\u201d\nAcademic Press, 1978.https://doi.org/10.1016/C2013-0-11243-3"
        }
    },
    {
        "Section ID": "gnr_graph",
        "Description": [
            "Returns the growing network with redirection (GNR) digraph with n nodes and redirection probability p .",
            "The GNR graph is built by adding nodes one at a time with a link to one\npreviously added node.  The previous target node is chosen uniformly at\nrandom.  With probability p the link is instead \u201credirected\u201d to the\nsuccessor node of the target.",
            "The graph is always a (directed) tree."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes for the generated graph.",
                "p : float": "The redirection probability.",
                "create_using : NetworkX graph constructor, optional (default DiGraph)": "Graph type to create. If graph instance, then cleared before populated.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]P. L. Krapivsky and S. Redner,\nOrganization of Growing Random Networks,\nPhys. Rev. E, 63, 066123, 2001.",
            "Examples": "To create the undirected GNR graph, use theto_directed()method:\nD=nx.gnr_graph(10,0.5)# the GNR graph\nG=D.to_undirected()# the undirected version"
        }
    },
    {
        "Section ID": "random_graph",
        "Description": [
            "Returns a bipartite random graph.",
            "This is a bipartite version of the binomial (Erd\u0151s-R\u00e9nyi) graph.\nThe graph is composed of two partitions. Set A has nodes 0 to\n(n - 1) and set B has nodes n to (n + m - 1)."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes in the first bipartite set.",
                "m : int": "The number of nodes in the second bipartite set.",
                "p : float": "Probability for edge creation.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "directed : bool, optional (default=False)": "If True return a directed graph"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The bipartite random graph algorithm chooses each of the n*m (undirected)\nor 2*nm (directed) possible edges with probability p. This algorithm is \\(O(n+m)\\) where \\(m\\) is the expected number of edges. The nodes are assigned the attribute \u2018bipartite\u2019 with the value 0 or 1\nto indicate which bipartite set the node belongs to. This function is not imported in the main namespace.\nTo use it use nx.bipartite.random_graph",
            "References": "[1]Vladimir Batagelj and Ulrik Brandes,\n\u201cEfficient generation of large random networks\u201d,\nPhys. Rev. E, 71, 036113, 2005."
        }
    },
    {
        "Section ID": "multipartite_layout",
        "Description": [
            "Position nodes in layers of straight lines."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph or list of nodes": "A position will be assigned to every node in G.",
                "subset_key : string or dict (default=\u2019subset\u2019)": "If a string, the key of node data in G that holds the node subset.\nIf a dict, keyed by layer number to the nodes in that layer/subset.",
                "align : string (default=\u2019vertical\u2019)": "The alignment of nodes. Vertical or horizontal.",
                "scale : number (default: 1)": "Scale factor for positions.",
                "center : array-like or None": "Coordinate pair around which to center the layout."
            },
            "Returns:": {
                "pos : dict": "A dictionary of positions keyed by node."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm currently only works in two dimensions and does not\ntry to minimize edge crossings. Network does not need to be a complete multipartite graph. As long as nodes\nhave subset_key data, they will be placed in the corresponding layers.",
            "Examples": "G=nx.complete_multipartite_graph(28,16,10)\npos=nx.multipartite_layout(G)\nor use a dict to provide the layers of the layout\nG=nx.Graph([(0,1),(1,2),(1,3),(3,4)])\nlayers={\"a\":[0],\"b\":[1],\"c\":[2,3],\"d\":[4]}\npos=nx.multipartite_layout(G,subset_key=layers)"
        }
    },
    {
        "Section ID": "rescale_layout_dict",
        "Description": [
            "Return a dictionary of scaled positions keyed by node"
        ],
        "Field List": {
            "Parameters:": {
                "pos : A dictionary of positions keyed by node": "",
                "scale : number (default: 1)": "The size of the resulting extent in all directions."
            },
            "Returns:": {
                "pos : A dictionary of positions keyed by node": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "importnumpyasnp\npos={0:np.array((0,0)),1:np.array((1,1)),2:np.array((0.5,0.5))}\nnx.rescale_layout_dict(pos)\n# {0: array([-1., -1.]), 1: array([1., 1.]), 2: array([0., 0.])}\npos={0:np.array((0,0)),1:np.array((-1,1)),2:np.array((-0.5,0.5))}\nnx.rescale_layout_dict(pos,scale=2)\n# {0: array([ 2., -2.]), 1: array([-2.,  2.]), 2: array([0., 0.])}"
        }
    },
    {
        "Section ID": "is_empty",
        "Description": [
            "Returns True if G has no edges."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph."
            },
            "Returns:": {
                "bool": "True ifGhas no edges, and False otherwise."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "An empty graph can have nodes but not edges. The empty graph with zero\nnodes is known as the null graph. This is an \\(O(n)\\) operation where n\nis the number of nodes in the graph."
        }
    },
    {
        "Section ID": "communicability",
        "Description": [
            "Returns communicability between all pairs of nodes in G.",
            "The communicability between pairs of nodes in G is the sum of\nwalks of different lengths starting at node u and ending at node v."
        ],
        "Field List": {
            "Parameters:": {
                "G: graph": ""
            },
            "Returns:": {
                "comm: dictionary of dictionaries": "Dictionary of dictionaries keyed by nodes with communicability\nas the value."
            },
            "Raises:": {
                "NetworkXError": "If the graph is not undirected and simple."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm uses a spectral decomposition of the adjacency matrix.\nLet G=(V,E) be a simple undirected graph.  Using the connection between\nthe powers  of the adjacency matrix and the number of walks in the graph,\nthe communicability  between nodes u and v based on the graph spectrum\nis [1]",
            "References": "[1]Ernesto Estrada, Naomichi Hatano,\n\u201cCommunicability in complex networks\u201d,\nPhys. Rev. E 77, 036111 (2008).https://arxiv.org/abs/0707.0756",
            "Examples": "G=nx.Graph([(0,1),(1,2),(1,5),(5,4),(2,4),(2,3),(4,3),(3,6)])\nc=nx.communicability(G)"
        }
    },
    {
        "Section ID": "generate_network_text",
        "Description": [
            "Generate lines in the \u201cnetwork text\u201d format",
            "This works via a depth-first traversal of the graph and writing a line for\neach unique node encountered. Non-tree edges are written to the right of\neach node, and connection to a non-tree edge is indicated with an ellipsis.\nThis representation works best when the input graph is a forest, but any\ngraph can be represented.",
            "This notation is original to networkx, although it is simple enough that it\nmay be known in existing literature. See #5602 for details. The procedure\nis summarized as follows:",
            "1. Given a set of source nodes (which can be specified, or automatically\ndiscovered via finding the (strongly) connected components and choosing one\nnode with minimum degree from each), we traverse the graph in depth first\norder.",
            "4. The children of each node (wrt the directed DFS tree) are drawn\nunderneath and to the right of it. In the case that a child node has already\nbeen drawn the connection is replaced with an ellipsis (\u201d\u2026\u201d) to indicate\nthat there is one or more connections represented elsewhere.",
            "5. If a maximum depth is specified, an edge to nodes past this maximum\ndepth will be represented by an ellipsis.",
            "6. If a a node has a truthy \u201ccollapse\u201d value, then we do not traverse past\nthat node."
        ],
        "Field List": {
            "Parameters:": {
                "graph : nx.DiGraph | nx.Graph": "Graph to represent",
                "with_labels : bool | str": "If True will use the \u201clabel\u201d attribute of a node to display if it\nexists otherwise it will use the node value itself. If given as a\nstring, then that attribute name will be used instead of \u201clabel\u201d.\nDefaults to True.",
                "sources : List": "Specifies which nodes to start traversal from. Note: nodes that are not\nreachable from one of these sources may not be shown. If unspecified,\nthe minimal set of nodes needed to reach all others will be used.",
                "max_depth : int | None": "The maximum depth to traverse before stopping. Defaults to None.",
                "ascii_only : Boolean": "If True only ASCII characters are used to construct the visualization",
                "vertical_chains : Boolean": "If True, chains of nodes will be drawn vertically when possible."
            },
            "Yields:": {
                "str : a line of generated text": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "graph=nx.path_graph(10)\ngraph.add_node(\"A\")\ngraph.add_node(\"B\")\ngraph.add_node(\"C\")\ngraph.add_node(\"D\")\ngraph.add_edge(9,\"A\")\ngraph.add_edge(9,\"B\")\ngraph.add_edge(9,\"C\")\ngraph.add_edge(\"C\",\"D\")\ngraph.add_edge(\"C\",\"E\")\ngraph.add_edge(\"C\",\"F\")\nnx.write_network_text(graph)\n# \u2559\u2500\u2500 0\n#     \u2514\u2500\u2500 1\n#         \u2514\u2500\u2500 2\n#             \u2514\u2500\u2500 3\n#                 \u2514\u2500\u2500 4\n#                     \u2514\u2500\u2500 5\n#                         \u2514\u2500\u2500 6\n#                             \u2514\u2500\u2500 7\n#                                 \u2514\u2500\u2500 8\n#                                     \u2514\u2500\u2500 9\n#                                         \u251c\u2500\u2500 A\n#                                         \u251c\u2500\u2500 B\n#                                         \u2514\u2500\u2500 C\n#                                             \u251c\u2500\u2500 D\n#                                             \u251c\u2500\u2500 E\n#                                             \u2514\u2500\u2500 F\nnx.write_network_text(graph,vertical_chains=True)\n# \u2559\u2500\u2500 0\n#     \u2502\n#     1\n#     \u2502\n#     2\n#     \u2502\n#     3\n#     \u2502\n#     4\n#     \u2502\n#     5\n#     \u2502\n#     6\n#     \u2502\n#     7\n#     \u2502\n#     8\n#     \u2502\n#     9\n#     \u251c\u2500\u2500 A\n#     \u251c\u2500\u2500 B\n#     \u2514\u2500\u2500 C\n#         \u251c\u2500\u2500 D\n#         \u251c\u2500\u2500 E\n#         \u2514\u2500\u2500 F"
        }
    },
    {
        "Section ID": "dfs_successors",
        "Description": [
            "Returns dictionary of successors in depth-first-search from source."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node, optional": "Specify starting node for depth-first search.\nNote that you will get successors for all nodes in the\ncomponent containingsource. This input only specifies\nwhere the DFS starts.",
                "depth_limit : int, optional (default=len(G))": "Specify the maximum search depth.",
                "sort_neighbors : function (default=None)": "A function that takes an iterator over nodes as the input, and\nreturns an iterable of the same nodes with a custom ordering.\nFor example,sortedwill sort the nodes in increasing order."
            },
            "Returns:": {
                "succ: dict": "A dictionary with nodes as keys and list of successor nodes as values."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "If a source is not specified then a source is chosen arbitrarily and\nrepeatedly until all components in the graph are searched. The implementation of this function is adapted from David Eppstein\u2019s\ndepth-first search function in PADS , with modifications\nto allow depth limits based on the Wikipedia article\n\u201c Depth-limited search \u201d.",
            "Examples": "G=nx.path_graph(5)\nnx.dfs_successors(G,source=0)\n# {0: [1], 1: [2], 2: [3], 3: [4]}\nnx.dfs_successors(G,source=0,depth_limit=2)\n# {0: [1], 1: [2]}"
        }
    },
    {
        "Section ID": "random_kernel_graph",
        "Description": [
            "Returns an random graph based on the specified kernel.",
            "The algorithm chooses each of the \\([n(n-1)]/2\\) possible edges with\nprobability specified by a kernel \\(\\kappa(x,y)\\)  [1] .  The kernel \\(\\kappa(x,y)\\) must be a symmetric (in \\(x,y\\) ), non-negative,\nbounded function."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes",
                "kernel_integral : function": "Function that returns the definite integral of the kernel\\(\\kappa(x,y)\\),\\(F(y,a,b) := \\int_a^b \\kappa(x,y)dx\\)",
                "kernel_root: function (optional)": "Function that returns the root\\(b\\)of the equation\\(F(y,a,b) = r\\).\nIf None, the root is found usingscipy.optimize.brentq()(this requires SciPy).",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The kernel is specified through its definite integral which must be\nprovided as one of the arguments. If the integral and root of the\nkernel integral can be found in \\(O(1)\\) time then this algorithm runs in\ntime \\(O(n+m)\\) where m is the expected number of edges [2] . The nodes are set to integers from \\(0\\) to \\(n-1\\) .",
            "References": "[1]Bollob\u00e1s, B\u00e9la,  Janson, S. and Riordan, O.\n\u201cThe phase transition in inhomogeneous random graphs\u201d,Random Structures Algorithms, 31, 3\u2013122, 2007.  [2]Hagberg A, Lemons N (2015),\n\u201cFast Generation of Sparse Random Kernel Graphs\u201d.\nPLoS ONE 10(9): e0135177, 2015. doi:10.1371/journal.pone.0135177",
            "Examples": "Generate an Erd\u0151s\u2013R\u00e9nyi random graph\\(G(n,c/n)\\), with kernel\\(\\kappa(x,y)=c\\)where\\(c\\)is the mean expected degree.\ndefintegral(u,w,z):\nreturnc*(z-w)\ndefroot(u,w,r):\nreturnr/c+w\nc=1\ngraph=nx.random_kernel_graph(1000,integral,root)"
        }
    },
    {
        "Section ID": "traveling_salesman_problem",
        "Description": [
            "Find the shortest path in G connecting specified nodes",
            "This function allows approximate solution to the traveling salesman\nproblem on networks that are not complete graphs and/or where the\nsalesman does not need to visit all nodes.",
            "This function proceeds in two steps. First, it creates a complete\ngraph using the all-pairs shortest_paths between nodes in nodes .\nEdge weights in the new graph are the lengths of the paths\nbetween each pair of nodes in the original graph.\nSecond, an algorithm (default: christofides for undirected and asadpour_atsp for directed) is used to approximate the minimal Hamiltonian\ncycle on this new graph. The available algorithms are:",
            "Once the Hamiltonian Cycle is found, this function post-processes to\naccommodate the structure of the original graph. If cycle is False ,\nthe biggest weight edge is removed to make a Hamiltonian path.\nThen each edge on the new complete graph used for that analysis is\nreplaced by the shortest_path between those nodes on the original graph.\nIf the input graph G includes edges with weights that do not adhere to\nthe triangle inequality, such as when G is not a complete graph (i.e\nlength of non-existent edges is infinity), then the returned path may\ncontain some repeating nodes (other than the starting node)."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A possibly weighted graph",
                "nodes : collection of nodes (default=G.nodes)": "collection (list, set, etc.) of nodes to visit",
                "weight : string, optional (default=\u201dweight\u201d)": "Edge data key corresponding to the edge weight.\nIf any edge does not have this attribute the weight is set to 1.",
                "cycle : bool (default: True)": "Indicates whether a cycle should be returned, or a path.\nNote: the cycle is the approximate minimal cycle.\nThe path simply removes the biggest edge in that cycle.",
                "method : function (default: None)": "A function that returns a cycle on all nodes and approximates\nthe solution to the traveling salesman problem on a complete\ngraph. The returned cycle is then used to find a corresponding\nsolution onG.methodshould be callable; take inputsG, andweight; and return a list of nodes along the cycle.Provided options includechristofides(),greedy_tsp(),simulated_annealing_tsp()andthreshold_accepting_tsp().IfmethodisNone: usechristofides()for undirectedGandasadpour_atsp()for directedG.",
                "**kwargs : dict": "Other keyword arguments to be passed to themethodfunction passed in."
            },
            "Returns:": {
                "list": "List of nodes inGalong a path with an approximation of the minimal\npath throughnodes."
            },
            "Raises:": {
                "NetworkXError": "IfGis a directed graph it has to be strongly connected or the\ncomplete version cannot be generated."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "tsp=nx.approximation.traveling_salesman_problem\nG=nx.cycle_graph(9)\nG[4][5][\"weight\"]=5# all other weights are 1\ntsp(G,nodes=[3,6])\n# [3, 2, 1, 0, 8, 7, 6, 7, 8, 0, 1, 2, 3]\npath=tsp(G,cycle=False)\npathin([4,3,2,1,0,8,7,6,5],[5,6,7,8,0,1,2,3,4])\n# True\nWhile no longer required, you can still build (curry) your own function\nto provide parameter values to the methods.\nSA_tsp=nx.approximation.simulated_annealing_tsp\nmethod=lambdaG,weight:SA_tsp(G,\"greedy\",weight=weight,temp=500)\npath=tsp(G,cycle=False,method=method)\npathin([4,3,2,1,0,8,7,6,5],[5,6,7,8,0,1,2,3,4])\n# True\nOtherwise, pass other keyword arguments directly into the tsp function.\npath=tsp(\nG,\ncycle=False,\nmethod=nx.approximation.simulated_annealing_tsp,\ninit_cycle=\"greedy\",\ntemp=500,\n)\npathin([4,3,2,1,0,8,7,6,5],[5,6,7,8,0,1,2,3,4])\n# True"
        }
    },
    {
        "Section ID": "k_shell",
        "Description": [
            "Returns the k-shell of G.",
            "The k-shell is the subgraph induced by nodes with core number k.\nThat is, nodes in the k-core that are not in the (k+1)-core."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A graph or directed graph.",
                "k : int, optional": "The order of the shell. If not specified return the outer shell.",
                "core_number : dictionary, optional": "Precomputed core numbers for the graph G."
            },
            "Returns:": {
                "G : NetworkX graph": "The k-shell subgraph"
            },
            "Raises:": {
                "NetworkXNotImplemented": "The k-shell is not implemented for multigraphs or graphs with self loops."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This is similar to k_corona but in that case only neighbors in the\nk-core are considered. For directed graphs the node degree is defined to be the\nin-degree + out-degree. Graph, node, and edge attributes are copied to the subgraph.",
            "References": "[1]A model of Internet topology using k-shell decomposition\nShai Carmi, Shlomo Havlin, Scott Kirkpatrick, Yuval Shavitt,\nand Eran Shir, PNAS  July 3, 2007   vol. 104  no. 27  11150-11154http://www.pnas.org/content/104/27/11150.full",
            "Examples": "degrees=[0,1,2,2,2,2,3]\nH=nx.havel_hakimi_graph(degrees)\nH.degree\n# DegreeView({0: 1, 1: 2, 2: 2, 3: 2, 4: 2, 5: 3, 6: 0})\nnx.k_shell(H,k=1).nodes\n# NodeView((0, 4))"
        }
    },
    {
        "Section ID": "number_strongly_connected_components",
        "Description": [
            "Returns number of strongly connected components in graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A directed graph."
            },
            "Returns:": {
                "n : integer": "Number of strongly connected components"
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For directed graphs only.",
            "Examples": "G=nx.DiGraph(\n[(0,1),(1,2),(2,0),(2,3),(4,5),(3,4),(5,6),(6,3),(6,7)]\n)\nnx.number_strongly_connected_components(G)\n# 3"
        }
    },
    {
        "Section ID": "directed_laplacian_matrix",
        "Description": [
            "Returns the directed Laplacian matrix of G.",
            "The graph directed Laplacian is the matrix",
            "where I is the identity matrix, P is the transition matrix of the\ngraph, and Phi a matrix with the Perron vector of P in the diagonal and\nzeros elsewhere [1] .",
            "Depending on the value of walk_type, P can be the transition matrix\ninduced by a random walk, a lazy random walk, or a random walk with\nteleportation (PageRank)."
        ],
        "Field List": {
            "Parameters:": {
                "G : DiGraph": "A NetworkX graph",
                "nodelist : list, optional": "The rows and columns are ordered according to the nodes in nodelist.\nIf nodelist is None, then the ordering is produced by G.nodes().",
                "weight : string or None, optional (default=\u2019weight\u2019)": "The edge data key used to compute each value in the matrix.\nIf None, then each edge has weight 1.",
                "walk_type : string or None, optional (default=None)": "One of\"random\",\"lazy\", or\"pagerank\". Ifwalk_type=None(the default), then a value is selected according to the properties ofG:\n-walk_type=\"random\"ifGis strongly connected and aperiodic\n-walk_type=\"lazy\"ifGis strongly connected but not aperiodic\n-walk_type=\"pagerank\"for all other cases.",
                "alpha : real": "(1 - alpha) is the teleportation probability used with pagerank"
            },
            "Returns:": {
                "L : NumPy matrix": "Normalized Laplacian of G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Only implemented for DiGraphs The result is always a symmetric matrix. This calculation uses the out-degree of the graph G . To use the\nin-degree for calculations instead, use G.reverse(copy=False) and\ntake the transpose.",
            "References": "[1]Fan Chung (2005).\nLaplacians and the Cheeger inequality for directed graphs.\nAnnals of Combinatorics, 9(1), 2005"
        }
    },
    {
        "Section ID": "shortest_simple_paths",
        "Description": [],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node": "Starting node for path",
                "target : node": "Ending node for path",
                "weight : string or function": "If it is a string, it is the name of the edge attribute to be\nused as a weight.If it is a function, the weight of an edge is the value returned\nby the function. The function must accept exactly three positional\narguments: the two endpoints of an edge and the dictionary of edge\nattributes for that edge. The function must return a number.If None all edges are considered to have unit weight. Default\nvalue None."
            },
            "Returns:": {
                "path_generator: generator": "A generator that produces lists of simple paths, in order from\nshortest to longest."
            },
            "Raises:": {
                "NetworkXNoPath": "If no path exists between source and target.",
                "NetworkXError": "If source or target nodes are not in the input graph.",
                "NetworkXNotImplemented": "If the input graph is a Multi[Di]Graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This procedure is based on algorithm by Jin Y. Yen [1] .  Finding\nthe first \\(K\\) paths requires \\(O(KN^3)\\) operations.",
            "References": "[1]Jin Y. Yen, \u201cFinding the K Shortest Loopless Paths in a\nNetwork\u201d, Management Science, Vol. 17, No. 11, Theory Series\n(Jul., 1971), pp. 712-716.",
            "Examples": "G=nx.cycle_graph(7)\npaths=list(nx.shortest_simple_paths(G,0,3))\nprint(paths)\n# [[0, 1, 2, 3], [0, 6, 5, 4, 3]]\nYou can use this function to efficiently compute the k shortest/best\npaths between two nodes.\nfromitertoolsimportislice\ndefk_shortest_paths(G,source,target,k,weight=None):\nreturnlist(\nislice(nx.shortest_simple_paths(G,source,target,weight=weight),k)\n)\nforpathink_shortest_paths(G,0,3,2):\nprint(path)\n# [0, 1, 2, 3]\n# [0, 6, 5, 4, 3]"
        }
    },
    {
        "Section ID": "christofides",
        "Description": [
            "Approximate a solution of the traveling salesman problem",
            "Compute a 3/2-approximation of the traveling salesman problem\nin a complete undirected graph using Christofides [1] algorithm."
        ],
        "Field List": {
            "Parameters:": {
                "G : Graph": "Gshould be a complete weighted undirected graph.\nThe distance between all pairs of nodes should be included.",
                "weight : string, optional (default=\u201dweight\u201d)": "Edge data key corresponding to the edge weight.\nIf any edge does not have this attribute the weight is set to 1.",
                "tree : NetworkX graph or None (default: None)": "A minimum spanning tree of G. Or, if None, the minimum spanning\ntree is computed usingnetworkx.minimum_spanning_tree()"
            },
            "Returns:": {
                "list": "List of nodes inGalong a cycle with a 3/2-approximation of\nthe minimal Hamiltonian cycle."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Christofides, Nicos. \u201cWorst-case analysis of a new heuristic for\nthe travelling salesman problem.\u201d No. RR-388. Carnegie-Mellon Univ\nPittsburgh Pa Management Sciences Research Group, 1976."
        }
    },
    {
        "Section ID": "icosahedral_graph",
        "Description": [
            "Returns the Platonic Icosahedral graph.",
            "The icosahedral graph has 12 nodes and 30 edges. It is a Platonic graph\nwhose nodes have the connectivity of the icosahedron. It is undirected,\nregular and Hamiltonian [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : networkx Graph": "Icosahedral graph with 12 nodes and 30 edges."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://mathworld.wolfram.com/IcosahedralGraph.html"
        }
    },
    {
        "Section ID": "is_locally_k_edge_connected",
        "Description": [
            "Tests to see if an edge in a graph is locally k-edge-connected.",
            "Is it impossible to disconnect s and t by removing fewer than k edges?\nIf so, then s and t are locally k-edge-connected in G."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "An undirected graph.",
                "s : node": "Source node",
                "t : node": "Target node",
                "k : integer": "local edge connectivity for nodes s and t"
            },
            "Returns:": {
                "boolean": "True if s and t are locally k-edge-connected in G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "fromnetworkx.algorithms.connectivityimportis_locally_k_edge_connected\nG=nx.barbell_graph(10,0)\nis_locally_k_edge_connected(G,5,15,k=1)\n# True\nis_locally_k_edge_connected(G,5,15,k=2)\n# False\nis_locally_k_edge_connected(G,1,5,k=2)\n# True"
        }
    },
    {
        "Section ID": "preflow_push",
        "Description": [
            "Find a maximum single-commodity flow using the highest-label\npreflow-push algorithm.",
            "This function returns the residual network resulting after computing\nthe maximum flow. See below for details about the conventions\nNetworkX uses for defining residual networks.",
            "This algorithm has a running time of \\(O(n^2 \\sqrt{m})\\) for \\(n\\) nodes and \\(m\\) edges."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Edges of the graph are expected to have an attribute called\n\u2018capacity\u2019. If this attribute is not present, the edge is\nconsidered to have infinite capacity.",
                "s : node": "Source node for the flow.",
                "t : node": "Sink node for the flow.",
                "capacity : string": "Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: \u2018capacity\u2019.",
                "residual : NetworkX graph": "Residual network on which the algorithm is to be executed. If None, a\nnew residual network is created. Default value: None.",
                "global_relabel_freq : integer, float": "Relative frequency of applying the global relabeling heuristic to speed\nup the algorithm. If it is None, the heuristic is disabled. Default\nvalue: 1.",
                "value_only : bool": "If False, compute a maximum flow; otherwise, compute a maximum preflow\nwhich is enough for computing the maximum flow value. Default value:\nFalse."
            },
            "Returns:": {
                "R : NetworkX DiGraph": "Residual network after computing the maximum flow."
            },
            "Raises:": {
                "NetworkXError": "The algorithm does not support MultiGraph and MultiDiGraph. If\nthe input graph is an instance of one of these two classes, a\nNetworkXError is raised.",
                "NetworkXUnbounded": "If the graph has a path of infinite capacity, the value of a\nfeasible flow on the graph is unbounded above and the function\nraises a NetworkXUnbounded."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The residual network R from an input graph G has the\nsame nodes as G . R is a DiGraph that contains a pair\nof edges (u,v) and (v,u) iff (u,v) is not a\nself-loop, and at least one of (u,v) and (v,u) exists\nin G . For each node u in R , R.nodes[u]['excess'] represents the difference between flow into u and flow out of u . For each edge (u,v) in R , R[u][v]['capacity'] is equal to the capacity of (u,v) in G if it exists\nin G or zero otherwise. If the capacity is infinite, R[u][v]['capacity'] will have a high arbitrary finite value\nthat does not affect the solution of the problem. This value is stored in R.graph['inf'] . For each edge (u,v) in R , R[u][v]['flow'] represents the flow function of (u,v) and\nsatisfies R[u][v]['flow']==-R[v][u]['flow'] . The flow value, defined as the total flow into t , the sink, is\nstored in R.graph['flow_value'] . Reachability to t using\nonly edges (u,v) such that R[u][v]['flow']<R[u][v]['capacity'] induces a minimum s - t cut.",
            "Examples": "fromnetworkx.algorithms.flowimportpreflow_push\nThe functions that implement flow algorithms and output a residual\nnetwork, such as this one, are not imported to the base NetworkX\nnamespace, so you have to explicitly import them from the flow package.\nG=nx.DiGraph()\nG.add_edge(\"x\",\"a\",capacity=3.0)\nG.add_edge(\"x\",\"b\",capacity=1.0)\nG.add_edge(\"a\",\"c\",capacity=3.0)\nG.add_edge(\"b\",\"c\",capacity=5.0)\nG.add_edge(\"b\",\"d\",capacity=4.0)\nG.add_edge(\"d\",\"e\",capacity=2.0)\nG.add_edge(\"c\",\"y\",capacity=2.0)\nG.add_edge(\"e\",\"y\",capacity=3.0)\nR=preflow_push(G,\"x\",\"y\")\nflow_value=nx.maximum_flow_value(G,\"x\",\"y\")\nflow_value==R.graph[\"flow_value\"]\n# True\n# preflow_push also stores the maximum flow value\n# in the excess attribute of the sink node t\nflow_value==R.nodes[\"y\"][\"excess\"]\n# True\n# For some problems, you might only want to compute a\n# maximum preflow.\nR=preflow_push(G,\"x\",\"y\",value_only=True)\nflow_value==R.graph[\"flow_value\"]\n# True\nflow_value==R.nodes[\"y\"][\"excess\"]\n# True"
        }
    },
    {
        "Section ID": "gnmk_random_graph",
        "Description": [
            "Returns a random bipartite graph G_{n,m,k}.",
            "Produces a bipartite graph chosen randomly out of the set of all graphs\nwith n top nodes, m bottom nodes, and k edges.\nThe graph is composed of two sets of nodes.\nSet A has nodes 0 to (n - 1) and set B has nodes n to (n + m - 1)."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes in the first bipartite set.",
                "m : int": "The number of nodes in the second bipartite set.",
                "k : int": "The number of edges",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "directed : bool, optional (default=False)": "If True return a directed graph"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "If k > m * n then a complete bipartite graph is returned. This graph is a bipartite version of the G_{nm} random graph model. The nodes are assigned the attribute \u2018bipartite\u2019 with the value 0 or 1\nto indicate which bipartite set the node belongs to. This function is not imported in the main namespace.\nTo use it use nx.bipartite.gnmk_random_graph",
            "Examples": "from nx.algorithms import bipartite\nG = bipartite.gnmk_random_graph(10,20,50)"
        }
    },
    {
        "Section ID": "square_clustering",
        "Description": [
            "Compute the squares clustering coefficient for nodes.",
            "For each node return the fraction of possible squares that exist at\nthe node [1]",
            "where \\(q_v(u,w)\\) are the number of common neighbors of \\(u\\) and \\(w\\) other than \\(v\\) (ie squares), and \\(a_v(u,w) = (k_u -\n(1+q_v(u,w)+\\theta_{uv})) + (k_w - (1+q_v(u,w)+\\theta_{uw}))\\) , where \\(\\theta_{uw} = 1\\) if \\(u\\) and \\(w\\) are connected and 0\notherwise. [2]"
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "",
                "nodes : container of nodes, optional (default=all nodes in G)": "Compute clustering for nodes in this container."
            },
            "Returns:": {
                "c4 : dictionary": "A dictionary keyed by node with the square clustering coefficient value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "While \\(C_3(v)\\) (triangle clustering) gives the probability that\ntwo neighbors of node v are connected with each other, \\(C_4(v)\\) is\nthe probability that two neighbors of node v share a common\nneighbor different from v. This algorithm can be applied to both\nbipartite and unipartite networks.",
            "References": "[1]Pedro G. Lind, Marta C. Gonz\u00e1lez, and Hans J. Herrmann. 2005\nCycles and clustering in bipartite networks.\nPhysical Review E (72) 056127.  [2]Zhang, Peng et al. Clustering Coefficient and Community Structure of\nBipartite Networks. Physica A: Statistical Mechanics and its Applications 387.27 (2008): 6869\u20136875.https://arxiv.org/abs/0710.0117v1",
            "Examples": "G=nx.complete_graph(5)\nprint(nx.square_clustering(G,0))\n# 1.0\nprint(nx.square_clustering(G))\n# {0: 1.0, 1: 1.0, 2: 1.0, 3: 1.0, 4: 1.0}"
        }
    },
    {
        "Section ID": "generate_graphml",
        "Description": [
            "Generate GraphML lines for G"
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph",
                "encoding : string (optional)": "Encoding for text data.",
                "prettyprint : bool (optional)": "If True use line breaks and indenting in output XML.",
                "named_key_ids : bool (optional)": "If True use attr.name as value for key elements\u2019 id attribute.",
                "edge_id_from_attribute : dict key (optional)": "If provided, the graphml edge id is set by looking up the corresponding\nedge data attribute keyed by this parameter. IfNoneor the key does not exist in edge data,\nthe edge id is set by the edge key ifGis a MultiGraph, else the edge id is left unset."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This implementation does not support mixed graphs (directed and unidirected\nedges together) hyperedges, nested graphs, or ports.",
            "Examples": "G=nx.path_graph(4)\nlinefeed=chr(10)# linefeed =\ns=linefeed.join(nx.generate_graphml(G))\nforlineinnx.generate_graphml(G):\nprint(line)"
        }
    },
    {
        "Section ID": "is_multigraphical",
        "Description": [
            "Returns True if some multigraph can realize the sequence."
        ],
        "Field List": {
            "Parameters:": {
                "sequence : list": "A list of integers"
            },
            "Returns:": {
                "valid : bool": "True if deg_sequence is a multigraphic degree sequence and False if not."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The worst-case run time is \\(O(n)\\) where \\(n\\) is the length of the sequence.",
            "References": "[1]S. L. Hakimi. \u201cOn the realizability of a set of integers as\ndegrees of the vertices of a linear graph\u201d, J. SIAM, 10, pp. 496-506\n(1962).",
            "Examples": "G=nx.MultiGraph([(1,2),(1,3),(2,3),(3,4),(4,2),(5,1),(5,4)])\nsequence=(dfor_,dinG.degree())\nnx.is_multigraphical(sequence)\n# True\nTo test a non-multigraphical sequence:\n>>> sequence_list = [d for _, d in G.degree()]\n>>> sequence_list[-1] += 1\n>>> nx.is_multigraphical(sequence_list)\nFalse"
        }
    },
    {
        "Section ID": "local_node_connectivity",
        "Description": [
            "Compute node connectivity between source and target.",
            "Pairwise or local node connectivity between two distinct and nonadjacent\nnodes is the minimum number of nodes that must be removed (minimum\nseparating cutset) to disconnect them. By Menger\u2019s theorem, this is equal\nto the number of node independent paths (paths that share no nodes other\nthan source and target). Which is what we compute in this function.",
            "This algorithm is a fast approximation that gives an strict lower\nbound on the actual number of node independent paths between two nodes [1] .\nIt works for both directed and undirected graphs."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node": "Starting node for node connectivity",
                "target : node": "Ending node for node connectivity",
                "cutoff : integer": "Maximum node connectivity to consider. If None, the minimum degree\nof source or target is used as a cutoff. Default value None."
            },
            "Returns:": {
                "k: integer": "pairwise node connectivity"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm [1] finds node independents paths between two nodes by\ncomputing their shortest path using BFS, marking the nodes of the path\nfound as \u2018used\u2019 and then searching other shortest paths excluding the\nnodes marked as used until no more paths exist. It is not exact because\na shortest path could use nodes that, if the path were longer, may belong\nto two different node independent paths. Thus it only guarantees an\nstrict lower bound on node connectivity. Note that the authors propose a further refinement, losing accuracy and\ngaining speed, which is not implemented yet.",
            "References": "[1](1,2)White, Douglas R., and Mark Newman. 2001 A Fast Algorithm for\nNode-Independent Paths. Santa Fe Institute Working Paper #01-07-035http://eclectic.ss.uci.edu/~drwhite/working.pdf",
            "Examples": "# Platonic octahedral graph has node connectivity 4\n# for each non adjacent node pair\nfromnetworkx.algorithmsimportapproximationasapprox\nG=nx.octahedral_graph()\napprox.local_node_connectivity(G,0,5)\n# 4"
        }
    },
    {
        "Section ID": "directed_configuration_model",
        "Description": [
            "Returns a directed_random graph with the given degree sequences.",
            "The configuration model generates a random directed pseudograph\n(graph with parallel edges and self loops) by randomly assigning\nedges to match the given degree sequences."
        ],
        "Field List": {
            "Parameters:": {
                "in_degree_sequence : list of nonnegative integers": "Each list entry corresponds to the in-degree of a node.",
                "out_degree_sequence : list of nonnegative integers": "Each list entry corresponds to the out-degree of a node.",
                "create_using : NetworkX graph constructor, optional (default MultiDiGraph)": "Graph type to create. If graph instance, then cleared before populated.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "G : MultiDiGraph": "A graph with the specified degree sequences.\nNodes are labeled starting at 0 with an index\ncorresponding to the position in deg_sequence."
            },
            "Raises:": {
                "NetworkXError": "If the degree sequences do not have the same sum."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Algorithm as described by Newman [1] . A non-graphical degree sequence (not realizable by some simple\ngraph) is allowed since this function returns graphs with self\nloops and parallel edges.  An exception is raised if the degree\nsequences does not have the same sum. This configuration model construction process can lead to\nduplicate edges and loops.  You can remove the self-loops and\nparallel edges (see below) which will likely result in a graph\nthat doesn\u2019t have the exact degree sequence specified.  This\n\u201cfinite-size effect\u201d decreases as the size of the graph increases.",
            "References": "[1]Newman, M. E. J. and Strogatz, S. H. and Watts, D. J.\nRandom graphs with arbitrary degree distributions and their applications\nPhys. Rev. E, 64, 026118 (2001)",
            "Examples": "One can modify the in- and out-degree sequences from an existing\ndirected graph in order to create a new directed graph. For example,\nhere we modify the directed path graph:\nD=nx.DiGraph([(0,1),(1,2),(2,3)])\ndin=list(dforn,dinD.in_degree())\ndout=list(dforn,dinD.out_degree())\ndin.append(1)\ndout[0]=2\n# We now expect an edge from node 0 to a new node, node 3.\nD=nx.directed_configuration_model(din,dout)\nThe returned graph is a directed multigraph, which may have parallel\nedges. To remove any parallel edges from the returned graph:\nD=nx.DiGraph(D)\nSimilarly, to remove self-loops:\nD.remove_edges_from(nx.selfloop_edges(D))"
        }
    },
    {
        "Section ID": "randomized_partitioning",
        "Description": [
            "Compute a random partitioning of the graph nodes and its cut value.",
            "A partitioning is calculated by observing each node\nand deciding to add it to the partition with probability p ,\nreturning a random cut and its corresponding value (the\nsum of weights of edges connecting different partitions)."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "p : scalar": "Probability for each node to be part of the first partition.\nShould be in [0,1]",
                "weight : object": "Edge attribute key to use as weight. If not specified, edges\nhave weight one."
            },
            "Returns:": {
                "cut_size : scalar": "Value of the minimum cut.",
                "partition : pair of node sets": "A partitioning of the nodes that defines a minimum cut."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the graph is directed or is a multigraph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.complete_graph(5)\ncut_size,partition=nx.approximation.randomized_partitioning(G,seed=1)\ncut_size\n# 6\npartition\n# ({0, 3, 4}, {1, 2})"
        }
    },
    {
        "Section ID": "to_pandas_adjacency",
        "Description": [
            "Returns the graph adjacency matrix as a Pandas DataFrame."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "The NetworkX graph used to construct the Pandas DataFrame.",
                "nodelist : list, optional": "The rows and columns are ordered according to the nodes innodelist.\nIfnodelistis None, then the ordering is produced by G.nodes().",
                "multigraph_weight : {sum, min, max}, optional": "An operator that determines how weights in multigraphs are handled.\nThe default is to sum the weights of the multiple edges.",
                "weight : string or None, optional": "The edge attribute that holds the numerical value used for\nthe edge weight.  If an edge does not have that attribute, then the\nvalue 1 is used instead.",
                "nonedge : float, optional": "The matrix values corresponding to nonedges are typically set to zero.\nHowever, this could be undesirable if there are matrix values\ncorresponding to actual edges that also have the value zero. If so,\none might prefer nonedges to have some other value, such as nan."
            },
            "Returns:": {
                "df : Pandas DataFrame": "Graph adjacency matrix"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For directed graphs, entry i,j corresponds to an edge from i to j. The DataFrame entries are assigned to the weight edge attribute. When\nan edge does not have a weight attribute, the value of the entry is set to\nthe number 1.  For multiple (parallel) edges, the values of the entries\nare determined by the \u2018multigraph_weight\u2019 parameter.  The default is to\nsum the weight attributes for each of the parallel edges. When nodelist does not contain every node in G , the matrix is built\nfrom the subgraph of G that is induced by the nodes in nodelist . The convention used for self-loop edges in graphs is to assign the\ndiagonal matrix entry value to the weight attribute of the edge\n(or the number 1 if the edge has no weight attribute).  If the\nalternate convention of doubling the edge weight is desired the\nresulting Pandas DataFrame can be modified as follows:",
            "Examples": "G=nx.MultiDiGraph()\nG.add_edge(0,1,weight=2)\n# 0\nG.add_edge(1,0)\n# 0\nG.add_edge(2,2,weight=3)\n# 0\nG.add_edge(2,2)\n# 1\nnx.to_pandas_adjacency(G,nodelist=[0,1,2],dtype=int)\n#    0  1  2\n# 0  0  2  0\n# 1  1  0  0\n# 2  0  0  4"
        }
    },
    {
        "Section ID": "has_eulerian_path",
        "Description": [
            "Return True iff G has an Eulerian path.",
            "An Eulerian path is a path in a graph which uses each edge of a graph\nexactly once. If source is specified, then this function checks\nwhether an Eulerian path that starts at node source exists."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "The graph to find an euler path in.",
                "source : node, optional": "Starting node for path."
            },
            "Returns:": {
                "Bool : True if G has an Eulerian path.": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "If you prefer to allow graphs with isolated vertices to have Eulerian path,\nyou can first remove such vertices and then callhas_eulerian_pathas below example shows.\nG=nx.Graph([(0,1),(1,2),(0,2)])\nG.add_node(3)\nnx.has_eulerian_path(G)\n# False\nG.remove_nodes_from(list(nx.isolates(G)))\nnx.has_eulerian_path(G)\n# True"
        }
    },
    {
        "Section ID": "is_branching",
        "Description": [
            "Returns True if G is a branching.",
            "A branching is a directed forest with maximum in-degree equal to 1."
        ],
        "Field List": {
            "Parameters:": {
                "G : directed graph": "The directed graph to test."
            },
            "Returns:": {
                "b : bool": "A boolean that is True ifGis a branching."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "In another convention, a branching is also known as a forest .",
            "Examples": "G=nx.DiGraph([(0,1),(1,2),(2,3),(3,4)])\nnx.is_branching(G)\n# True\nG.remove_edge(2,3)\nG.add_edge(3,1)# maximum in-degree is 2\nnx.is_branching(G)\n# False"
        }
    },
    {
        "Section ID": "gomory_hu_tree",
        "Description": [
            "Returns the Gomory-Hu tree of an undirected graph G.",
            "A Gomory-Hu tree of an undirected graph with capacities is a\nweighted tree that represents the minimum s-t cuts for all s-t\npairs in the graph.",
            "It only requires n-1 minimum cut computations instead of the\nobvious n(n-1)/2 . The tree represents all s-t cuts as the\nminimum cut value among any pair of nodes is the minimum edge\nweight in the shortest path between the two nodes in the\nGomory-Hu tree.",
            "The Gomory-Hu tree also has the property that removing the\nedge with the minimum weight in the shortest path between\nany two nodes leaves two connected components that form\na partition of the nodes in G that defines the minimum s-t\ncut.",
            "See Examples section below for details."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected graph",
                "capacity : string": "Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: \u2018capacity\u2019.",
                "flow_func : function": "Function to perform the underlying flow computations. Default valueedmonds_karp(). This function performs better in sparse graphs\nwith right tailed degree distributions.shortest_augmenting_path()will perform better in denser\ngraphs."
            },
            "Returns:": {
                "Tree : NetworkX graph": "A NetworkX graph representing the Gomory-Hu tree of the input graph."
            },
            "Raises:": {
                "NetworkXNotImplemented": "Raised if the input graph is directed.",
                "NetworkXError": "Raised if the input graph is an empty Graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This implementation is based on Gusfield approach [1] to compute\nGomory-Hu trees, which does not require node contractions and has\nthe same computational complexity than the original method.",
            "References": "[1]Gusfield D: Very simple methods for all pairs network flow analysis.\nSIAM J Comput 19(1):143-155, 1990.",
            "Examples": "G=nx.karate_club_graph()\nnx.set_edge_attributes(G,1,\"capacity\")\nT=nx.gomory_hu_tree(G)\n# The value of the minimum cut between any pair\n# of nodes in G is the minimum edge weight in the\n# shortest path between the two nodes in the\n# Gomory-Hu tree.\ndefminimum_edge_weight_in_shortest_path(T,u,v):\npath=nx.shortest_path(T,u,v,weight=\"weight\")\nreturnmin((T[u][v][\"weight\"],(u,v))for(u,v)inzip(path,path[1:]))\nu,v=0,33\ncut_value,edge=minimum_edge_weight_in_shortest_path(T,u,v)\ncut_value\n# 10\nnx.minimum_cut_value(G,u,v)\n# 10\n# The Gomory-Hu tree also has the property that removing the\n# edge with the minimum weight in the shortest path between\n# any two nodes leaves two connected components that form\n# a partition of the nodes in G that defines the minimum s-t\n# cut.\ncut_value,edge=minimum_edge_weight_in_shortest_path(T,u,v)\nT.remove_edge(*edge)\nU,V=list(nx.connected_components(T))\n# Thus U and V form a partition that defines a minimum cut\n# between u and v in G. You can compute the edge cut set,\n# that is, the set of edges that if removed from G will\n# disconnect u from v in G, with this information:\ncutset=set()\nforx,nbrsin((n,G[n])forninU):\ncutset.update((x,y)foryinnbrsifyinV)\n# Because we have set the capacities of all edges to 1\n# the cutset contains ten edges\nlen(cutset)\n# 10\n# You can use any maximum flow algorithm for the underlying\n# flow computations using the argument flow_func\nfromnetworkx.algorithmsimportflow\nT=nx.gomory_hu_tree(G,flow_func=flow.boykov_kolmogorov)\ncut_value,edge=minimum_edge_weight_in_shortest_path(T,u,v)\ncut_value\n# 10\nnx.minimum_cut_value(G,u,v,flow_func=flow.boykov_kolmogorov)\n# 10"
        }
    },
    {
        "Section ID": "from_biadjacency_matrix",
        "Description": [
            "Creates a new bipartite graph from a biadjacency matrix given as a\nSciPy sparse array."
        ],
        "Field List": {
            "Parameters:": {
                "A: scipy sparse array": "A biadjacency matrix representation of a graph",
                "create_using: NetworkX graph": "Use specified graph for result.  The default is Graph()",
                "edge_attribute: string": "Name of edge attribute to store matrix numeric value. The data will\nhave the same type as the matrix entry (int, float, (real,imag))."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The nodes are labeled with the attribute bipartite set to an integer\n0 or 1 representing membership in part 0 or part 1 of the bipartite graph. If create_using is an instance of networkx.MultiGraph or networkx.MultiDiGraph and the entries of A are of\ntype int , then this function returns a multigraph (of the same\ntype as create_using ) with parallel edges. In this case, edge_attribute will be ignored.",
            "References": "[1] https://en.wikipedia.org/wiki/Adjacency_matrix#Adjacency_matrix_of_a_bipartite_graph"
        }
    },
    {
        "Section ID": "cartesian_product",
        "Description": [
            "Returns the Cartesian product of G and H.",
            "The Cartesian product \\(P\\) of the graphs \\(G\\) and \\(H\\) has a node set that\nis the Cartesian product of the node sets, \\(V(P)=V(G) \\times V(H)\\) . \\(P\\) has an edge \\(((u,v),(x,y))\\) if and only if either \\(u\\) is equal to \\(x\\) and both \\(v\\) and \\(y\\) are adjacent in \\(H\\) or if \\(v\\) is equal to \\(y\\) and\nboth \\(u\\) and \\(x\\) are adjacent in \\(G\\) ."
        ],
        "Field List": {
            "Parameters:": {
                "G, H: graphs": "Networkx graphs."
            },
            "Returns:": {
                "P: NetworkX graph": "The Cartesian product of G and H. P will be a multi-graph if either G\nor H is a multi-graph. Will be a directed if G and H are directed,\nand undirected if G and H are undirected."
            },
            "Raises:": {
                "NetworkXError": "If G and H are not both directed or both undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Node attributes in P are two-tuple of the G and H node attributes.\nMissing attributes are assigned None.",
            "Examples": "G=nx.Graph()\nH=nx.Graph()\nG.add_node(0,a1=True)\nH.add_node(\"a\",a2=\"Spam\")\nP=nx.cartesian_product(G,H)\nlist(P)\n# [(0, 'a')]\nEdge attributes and edge keys (for multigraphs) are also copied to the\nnew product graph"
        }
    },
    {
        "Section ID": "transitivity",
        "Description": [
            "Compute graph transitivity, the fraction of all possible triangles\npresent in G.",
            "Possible triangles are identified by the number of \u201ctriads\u201d\n(two edges with a shared vertex).",
            "The transitivity is"
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": ""
            },
            "Returns:": {
                "out : float": "Transitivity"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Self loops are ignored.",
            "Examples": "G=nx.complete_graph(5)\nprint(nx.transitivity(G))\n# 1.0"
        }
    },
    {
        "Section ID": "number_connected_components",
        "Description": [
            "Returns the number of connected components."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "An undirected graph."
            },
            "Returns:": {
                "n : integer": "Number of connected components"
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is directed."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For undirected graphs only.",
            "Examples": "G=nx.Graph([(0,1),(1,2),(5,6),(3,4)])\nnx.number_connected_components(G)\n# 3"
        }
    },
    {
        "Section ID": "random_reference",
        "Description": [
            "Compute a random graph by swapping edges of a given graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "An undirected graph with 4 or more nodes.",
                "niter : integer (optional, default=1)": "An edge is rewired approximatelynitertimes.",
                "connectivity : boolean (optional, default=True)": "When True, ensure connectivity for the randomized graph.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "G : graph": "The randomized graph."
            },
            "Raises:": {
                "NetworkXError": "If there are fewer than 4 nodes or 2 edges inG"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The implementation is adapted from the algorithm by Maslov and Sneppen\n(2002) [1] .",
            "References": "[1]Maslov, Sergei, and Kim Sneppen.\n\u201cSpecificity and stability in topology of protein networks.\u201d\nScience 296.5569 (2002): 910-913."
        }
    },
    {
        "Section ID": "laplacian_centrality",
        "Description": [
            "Compute the Laplacian centrality for nodes in the graph G .",
            "The Laplacian Centrality of a node i is measured by the drop in the\nLaplacian Energy after deleting node i from the graph. The Laplacian Energy\nis the sum of the squared eigenvalues of a graph\u2019s Laplacian matrix.",
            "Where \\(E_L (G)\\) is the Laplacian energy of graph G ,\nE_L (G_i) is the Laplacian energy of graph G after deleting node i and \\(\\lambda_i\\) are the eigenvalues of G \u2019s Laplacian matrix.\nThis formula shows the normalized value. Without normalization,\nthe numerator on the right side is returned."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph",
                "normalized : bool (default = True)": "If True the centrality score is scaled so the sum over all nodes is 1.\nIf False the centrality score for each node is the drop in Laplacian\nenergy when that node is removed.",
                "nodelist : list, optional (default = None)": "The rows and columns are ordered according to the nodes in nodelist.\nIf nodelist is None, then the ordering is produced by G.nodes().",
                "weight: string or None, optional (default=`weight`)": "Optional parameterweightto compute the Laplacian matrix.\nThe edge data key used to compute each value in the matrix.\nIf None, then each edge has weight 1.",
                "walk_type : string or None, optional (default=None)": "Optional parameterwalk_typeused when callingdirected_laplacian_matrix.\nOne of\"random\",\"lazy\", or\"pagerank\". Ifwalk_type=None(the default), then a value is selected according to the properties ofG:\n-walk_type=\"random\"ifGis strongly connected and aperiodic\n-walk_type=\"lazy\"ifGis strongly connected but not aperiodic\n-walk_type=\"pagerank\"for all other cases.",
                "alpha : real (default = 0.95)": "Optional parameteralphaused when callingdirected_laplacian_matrix.\n(1 - alpha) is the teleportation probability used with pagerank."
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of nodes with Laplacian centrality as the value."
            },
            "Raises:": {
                "NetworkXPointlessConcept": "If the graphGis the null graph.",
                "ZeroDivisionError": "If the graphGhas no edges (is empty) and normalization is requested."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The algorithm is implemented based on [1] with an extension to directed graphs\nusing the directed_laplacian_matrix function.",
            "References": "[1]Qi, X., Fuller, E., Wu, Q., Wu, Y., and Zhang, C.-Q. (2012).\nLaplacian centrality: A new centrality measure for weighted networks.\nInformation Sciences, 194:240-253.https://math.wvu.edu/~cqzhang/Publication-files/my-paper/INS-2012-Laplacian-W.pdf",
            "Examples": "G=nx.Graph()\nedges=[(0,1,4),(0,2,2),(2,1,1),(1,3,2),(1,4,2),(4,5,1)]\nG.add_weighted_edges_from(edges)\nsorted((v,f\"{c:0.2f}\")forv,cinlaplacian_centrality(G).items())\n# [(0, '0.70'), (1, '0.90'), (2, '0.28'), (3, '0.22'), (4, '0.26'), (5, '0.04')]"
        }
    },
    {
        "Section ID": "degree_pearson_correlation_coefficient",
        "Description": [
            "Compute degree assortativity of graph.",
            "Assortativity measures the similarity of connections\nin the graph with respect to the node degree.",
            "This is the same as degree_assortativity_coefficient but uses the\npotentially faster scipy.stats.pearsonr function."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "x: string (\u2018in\u2019,\u2019out\u2019)": "The degree type for source node (directed graphs only).",
                "y: string (\u2018in\u2019,\u2019out\u2019)": "The degree type for target node (directed graphs only).",
                "weight: string or None, optional (default=None)": "The edge attribute that holds the numerical value used\nas a weight.  If None, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node.",
                "nodes: list or iterable (optional)": "Compute pearson correlation of degrees only for specified nodes.\nThe default is all nodes."
            },
            "Returns:": {
                "r : float": "Assortativity of graph by degree."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This calls scipy.stats.pearsonr.",
            "References": "[1]M. E. J. Newman, Mixing patterns in networks\nPhysical Review E, 67 026126, 2003  [2]Foster, J.G., Foster, D.V., Grassberger, P. & Paczuski, M.\nEdge direction and the structure of networks, PNAS 107, 10815-20 (2010).",
            "Examples": "G=nx.path_graph(4)\nr=nx.degree_pearson_correlation_coefficient(G)\nprint(f\"{r:3.1f}\")\n# -0.5"
        }
    },
    {
        "Section ID": "boykov_kolmogorov",
        "Description": [
            "Find a maximum single-commodity flow using Boykov-Kolmogorov algorithm.",
            "This function returns the residual network resulting after computing\nthe maximum flow. See below for details about the conventions\nNetworkX uses for defining residual networks.",
            "This algorithm has worse case complexity \\(O(n^2 m |C|)\\) for \\(n\\) nodes, \\(m\\) edges, and \\(|C|\\) the cost of the minimum cut [1] . This implementation\nuses the marking heuristic defined in [2] which improves its running\ntime in many practical problems."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Edges of the graph are expected to have an attribute called\n\u2018capacity\u2019. If this attribute is not present, the edge is\nconsidered to have infinite capacity.",
                "s : node": "Source node for the flow.",
                "t : node": "Sink node for the flow.",
                "capacity : string": "Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: \u2018capacity\u2019.",
                "residual : NetworkX graph": "Residual network on which the algorithm is to be executed. If None, a\nnew residual network is created. Default value: None.",
                "value_only : bool": "If True compute only the value of the maximum flow. This parameter\nwill be ignored by this algorithm because it is not applicable.",
                "cutoff : integer, float": "If specified, the algorithm will terminate when the flow value reaches\nor exceeds the cutoff. In this case, it may be unable to immediately\ndetermine a minimum cut. Default value: None."
            },
            "Returns:": {
                "R : NetworkX DiGraph": "Residual network after computing the maximum flow."
            },
            "Raises:": {
                "NetworkXError": "The algorithm does not support MultiGraph and MultiDiGraph. If\nthe input graph is an instance of one of these two classes, a\nNetworkXError is raised.",
                "NetworkXUnbounded": "If the graph has a path of infinite capacity, the value of a\nfeasible flow on the graph is unbounded above and the function\nraises a NetworkXUnbounded."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The residual network R from an input graph G has the\nsame nodes as G . R is a DiGraph that contains a pair\nof edges (u,v) and (v,u) iff (u,v) is not a\nself-loop, and at least one of (u,v) and (v,u) exists\nin G . For each edge (u,v) in R , R[u][v]['capacity'] is equal to the capacity of (u,v) in G if it exists\nin G or zero otherwise. If the capacity is infinite, R[u][v]['capacity'] will have a high arbitrary finite value\nthat does not affect the solution of the problem. This value is stored in R.graph['inf'] . For each edge (u,v) in R , R[u][v]['flow'] represents the flow function of (u,v) and\nsatisfies R[u][v]['flow']==-R[v][u]['flow'] . The flow value, defined as the total flow into t , the sink, is\nstored in R.graph['flow_value'] . If cutoff is not\nspecified, reachability to t using only edges (u,v) such\nthat R[u][v]['flow']<R[u][v]['capacity'] induces a minimum s - t cut.",
            "References": "[1]Boykov, Y., & Kolmogorov, V. (2004). An experimental comparison\nof min-cut/max-flow algorithms for energy minimization in vision.\nPattern Analysis and Machine Intelligence, IEEE Transactions on,\n26(9), 1124-1137.https://doi.org/10.1109/TPAMI.2004.60  [2]Vladimir Kolmogorov. Graph-based Algorithms for Multi-camera\nReconstruction Problem. PhD thesis, Cornell University, CS Department,\n2003. pp. 109-114.https://web.archive.org/web/20170809091249/https://pub.ist.ac.at/~vnk/papers/thesis.pdf",
            "Examples": "fromnetworkx.algorithms.flowimportboykov_kolmogorov\nThe functions that implement flow algorithms and output a residual\nnetwork, such as this one, are not imported to the base NetworkX\nnamespace, so you have to explicitly import them from the flow package.\nG=nx.DiGraph()\nG.add_edge(\"x\",\"a\",capacity=3.0)\nG.add_edge(\"x\",\"b\",capacity=1.0)\nG.add_edge(\"a\",\"c\",capacity=3.0)\nG.add_edge(\"b\",\"c\",capacity=5.0)\nG.add_edge(\"b\",\"d\",capacity=4.0)\nG.add_edge(\"d\",\"e\",capacity=2.0)\nG.add_edge(\"c\",\"y\",capacity=2.0)\nG.add_edge(\"e\",\"y\",capacity=3.0)\nR=boykov_kolmogorov(G,\"x\",\"y\")\nflow_value=nx.maximum_flow_value(G,\"x\",\"y\")\nflow_value\n# 3.0\nflow_value==R.graph[\"flow_value\"]\n# True\nA nice feature of the Boykov-Kolmogorov algorithm is that a partition\nof the nodes that defines a minimum cut can be easily computed based\non the search trees used during the algorithm. These trees are stored\nin the graph attributetreesof the residual network.\nsource_tree,target_tree=R.graph[\"trees\"]\npartition=(set(source_tree),set(G)-set(source_tree))\nOr equivalently:\npartition=(set(G)-set(target_tree),set(target_tree))"
        }
    },
    {
        "Section ID": "bfs_beam_edges",
        "Description": [
            "Iterates over edges in a beam search.",
            "The beam search is a generalized breadth-first search in which only\nthe \u201cbest\u201d w neighbors of the current node are enqueued, where w is the beam width and \u201cbest\u201d is an application-specific\nheuristic. In general, a beam search with a small beam width might\nnot visit each node in the graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node": "Starting node for the breadth-first search; this function\niterates over only those edges in the component reachable from\nthis node.",
                "value : function": "A function that takes a node of the graph as input and returns a\nreal number indicating how \u201cgood\u201d it is. A higher value means it\nis more likely to be visited sooner during the search. When\nvisiting a new node, only thewidthneighbors with the highestvalueare enqueued (in decreasing order ofvalue).",
                "width : int (default = None)": "The beam width for the search. This is the number of neighbors\n(ordered byvalue) to enqueue when visiting each new node."
            },
            "Yields:": {
                "edge": "Edges in the beam search starting fromsource, given as a pair\nof nodes."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "To give nodes with, for example, a higher centrality precedence\nduring the search, set thevaluefunction to return the centrality\nvalue of the node:\nG=nx.karate_club_graph()\ncentrality=nx.eigenvector_centrality(G)\nlist(nx.bfs_beam_edges(G,source=0,value=centrality.get,width=3))\n# [(0, 2), (0, 1), (0, 8), (2, 32), (1, 13), (8, 33)]"
        }
    },
    {
        "Section ID": "from_pandas_edgelist",
        "Description": [
            "Returns a graph from Pandas DataFrame containing an edge list.",
            "The Pandas DataFrame should contain at least two columns of node names and\nzero or more columns of edge attributes. Each row will be processed as one\nedge instance.",
            "Note: This function iterates over DataFrame.values, which is not\nguaranteed to retain the data type across columns in the row. This is only\na problem if your row is entirely numeric and a mix of ints and floats. In\nthat case, all values will be returned as floats. See the\nDataFrame.iterrows documentation for an example."
        ],
        "Field List": {
            "Parameters:": {
                "df : Pandas DataFrame": "An edge list representation of a graph",
                "source : str or int": "A valid column name (string or integer) for the source nodes (for the\ndirected case).",
                "target : str or int": "A valid column name (string or integer) for the target nodes (for the\ndirected case).",
                "edge_attr : str or int, iterable, True, or None": "A valid column name (str or int) or iterable of column names that are\nused to retrieve items and add them to the graph as edge attributes.\nIfTrue, all of the remaining columns will be added.\nIfNone, no edge attributes are added to the graph.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated.",
                "edge_key : str or None, optional (default=None)": "A valid column name for the edge keys (for a MultiGraph). The values in\nthis column are used for the edge keys when adding edges if create_using\nis a multigraph.",
                "If you have node attributes stored in a separate dataframe `df_nodes`,": "",
                "you can load those attributes to the graph `G` using the following code:": "",
                "```": "",
                "df_nodes = pd.DataFrame({\u201cnode_id\u201d: [1, 2, 3], \u201cattribute1\u201d: [\u201cA\u201d, \u201cB\u201d, \u201cC\u201d]})": "",
                "G.add_nodes_from((n, dict(d)) for n, d in df_nodes.iterrows())": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "Simple integer weights on edges:\nimportpandasaspd\npd.options.display.max_columns=20\nimportnumpyasnp\nrng=np.random.RandomState(seed=5)\nints=rng.randint(1,11,size=(3,2))\na=[\"A\",\"B\",\"C\"]\nb=[\"D\",\"A\",\"E\"]\ndf=pd.DataFrame(ints,columns=[\"weight\",\"cost\"])\ndf[0]=a\ndf[\"b\"]=b\ndf[[\"weight\",\"cost\",0,\"b\"]]\n#    weight  cost  0  b\n# 0       4     7  A  D\n# 1       7     1  B  A\n# 2      10     9  C  E\nG=nx.from_pandas_edgelist(df,0,\"b\",[\"weight\",\"cost\"])\nG[\"E\"][\"C\"][\"weight\"]\n# 10\nG[\"E\"][\"C\"][\"cost\"]\n# 9\nedges=pd.DataFrame(\n{\n\"source\":[0,1,2],\n\"target\":[2,2,3],\n\"weight\":[3,4,5],\n\"color\":[\"red\",\"blue\",\"blue\"],\n}\n)\nG=nx.from_pandas_edgelist(edges,edge_attr=True)\nG[0][2][\"color\"]\n# 'red'\nBuild multigraph with custom keys:\nedges=pd.DataFrame(\n{\n\"source\":[0,1,2,0],\n\"target\":[2,2,3,2],\n\"my_edge_key\":[\"A\",\"B\",\"C\",\"D\"],\n\"weight\":[3,4,5,6],\n\"color\":[\"red\",\"blue\",\"blue\",\"blue\"],\n}\n)\nG=nx.from_pandas_edgelist(\nedges,\nedge_key=\"my_edge_key\",\nedge_attr=[\"weight\",\"color\"],\ncreate_using=nx.MultiGraph(),\n)\nG[0][2]\n# AtlasView({'A': {'weight': 3, 'color': 'red'}, 'D': {'weight': 6, 'color': 'blue'}})"
        }
    },
    {
        "Section ID": "union",
        "Description": [
            "Combine graphs G and H. The names of nodes must be unique.",
            "A name collision between the graphs will raise an exception.",
            "A renaming facility is provided to avoid name collisions."
        ],
        "Field List": {
            "Parameters:": {
                "G, H : graph": "A NetworkX graph",
                "rename : iterable , optional": "Node names of G and H can be changed by specifying the tuple\nrename=(\u2018G-\u2018,\u2019H-\u2019) (for example).  Node \u201cu\u201d in G is then renamed\n\u201cG-u\u201d and \u201cv\u201d in H is renamed \u201cH-v\u201d."
            },
            "Returns:": {
                "U : A union graph with the same type as G.": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "To combine graphs that have common nodes, consider compose(G, H)\nor the method, Graph.update(). disjoint_union() is similar to union() except that it avoids name clashes\nby relabeling the nodes with sequential integers. Edge and node attributes are propagated from G and H to the union graph.\nGraph attributes are also propagated, but if they are present in both G and H,\nthen the value from H is used.",
            "Examples": "G=nx.Graph([(0,1),(0,2),(1,2)])\nH=nx.Graph([(0,1),(0,3),(1,3),(1,2)])\nU=nx.union(G,H,rename=(\"G\",\"H\"))\nU.nodes\n# NodeView(('G0', 'G1', 'G2', 'H0', 'H1', 'H3', 'H2'))\nU.edges\n# EdgeView([('G0', 'G1'), ('G0', 'G2'), ('G1', 'G2'), ('H0', 'H1'), ('H0', 'H3'), ('H1', 'H3'), ('H1', 'H2')])"
        }
    },
    {
        "Section ID": "write_graphml",
        "Description": [
            "Write G in GraphML XML format to path",
            "This function uses the LXML framework and should be faster than\nthe version using the xml library."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph",
                "path : file or string": "File or filename to write.\nFilenames ending in .gz or .bz2 will be compressed.",
                "encoding : string (optional)": "Encoding for text data.",
                "prettyprint : bool (optional)": "If True use line breaks and indenting in output XML.",
                "infer_numeric_types : boolean": "Determine if numeric types should be generalized.\nFor example, if edges have both int and float \u2018weight\u2019 attributes,\nwe infer in GraphML that both are floats.",
                "named_key_ids : bool (optional)": "If True use attr.name as value for key elements\u2019 id attribute.",
                "edge_id_from_attribute : dict key (optional)": "If provided, the graphml edge id is set by looking up the corresponding\nedge data attribute keyed by this parameter. IfNoneor the key does not exist in edge data,\nthe edge id is set by the edge key ifGis a MultiGraph, else the edge id is left unset."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This implementation does not support mixed graphs (directed\nand unidirected edges together) hyperedges, nested graphs, or ports.",
            "Examples": "G=nx.path_graph(4)\nnx.write_graphml_lxml(G,\"fourpath.graphml\")"
        }
    },
    {
        "Section ID": "minimum_st_node_cut",
        "Description": [
            "Returns a set of nodes of minimum cardinality that disconnect source\nfrom target in G.",
            "This function returns the set of nodes of minimum cardinality that,\nif removed, would destroy all paths among source and target in G."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "s : node": "Source node.",
                "t : node": "Target node.",
                "flow_func : function": "A function for computing the maximum flow among a pair of nodes.\nThe function has to accept at least three parameters: a Digraph,\na source node, and a target node. And return a residual network\nthat follows NetworkX conventions (seemaximum_flow()for\ndetails). If flow_func is None, the default maximum flow function\n(edmonds_karp()) is used. See below for details. The choice\nof the default function may change from version to version and\nshould not be relied on. Default value: None.",
                "auxiliary : NetworkX DiGraph": "Auxiliary digraph to compute flow based node connectivity. It has\nto have a graph attribute called mapping with a dictionary mapping\nnode names in G and in the auxiliary digraph. If provided\nit will be reused instead of recreated. Default value: None.",
                "residual : NetworkX DiGraph": "Residual network to compute maximum flow. If provided it will be\nreused instead of recreated. Default value: None."
            },
            "Returns:": {
                "cutset : set": "Set of nodes that, if removed, would destroy all paths between\nsource and target in G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This is a flow based implementation of minimum node cut. The algorithm\nis based in solving a number of maximum flow computations to determine\nthe capacity of the minimum cut on an auxiliary directed network that\ncorresponds to the minimum node cut of G. It handles both directed\nand undirected graphs. This implementation is based on algorithm 11\nin [1] .",
            "References": "[1]Abdol-Hossein Esfahanian. Connectivity Algorithms.http://www.cse.msu.edu/~cse835/Papers/Graph_connectivity_revised.pdf",
            "Examples": "This function is not imported in the base NetworkX namespace, so you\nhave to explicitly import it from the connectivity package:\nfromnetworkx.algorithms.connectivityimportminimum_st_node_cut\nWe use in this example the platonic icosahedral graph, which has node\nconnectivity 5.\nG=nx.icosahedral_graph()\nlen(minimum_st_node_cut(G,0,6))\n# 5\nIf you need to compute local st cuts between several pairs of\nnodes in the same graph, it is recommended that you reuse the\ndata structures that NetworkX uses in the computation: the\nauxiliary digraph for node connectivity and node cuts, and the\nresidual network for the underlying maximum flow computation.\nExample of how to compute local st node cuts reusing the data\nstructures:\n# You also have to explicitly import the function for\n# building the auxiliary digraph from the connectivity package\nfromnetworkx.algorithms.connectivityimportbuild_auxiliary_node_connectivity\nH=build_auxiliary_node_connectivity(G)\n# And the function for building the residual network from the\n# flow package\nfromnetworkx.algorithms.flowimportbuild_residual_network\n# Note that the auxiliary digraph has an edge attribute named capacity\nR=build_residual_network(H,\"capacity\")\n# Reuse the auxiliary digraph and the residual network by passing them\n# as parameters\nlen(minimum_st_node_cut(G,0,6,auxiliary=H,residual=R))\n# 5\nYou can also use alternative flow algorithms for computing minimum st\nnode cuts. For instance, in dense networks the algorithmshortest_augmenting_path()will usually perform better than\nthe defaultedmonds_karp()which is faster for sparse\nnetworks with highly skewed degree distributions. Alternative flow\nfunctions have to be explicitly imported from the flow package.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\nlen(minimum_st_node_cut(G,0,6,flow_func=shortest_augmenting_path))\n# 5"
        }
    },
    {
        "Section ID": "maximum_flow",
        "Description": [
            "Find a maximum single-commodity flow."
        ],
        "Field List": {
            "Parameters:": {
                "flowG : NetworkX graph": "Edges of the graph are expected to have an attribute called\n\u2018capacity\u2019. If this attribute is not present, the edge is\nconsidered to have infinite capacity.",
                "_s : node": "Source node for the flow.",
                "_t : node": "Sink node for the flow.",
                "capacity : string": "Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: \u2018capacity\u2019.",
                "flow_func : function": "A function for computing the maximum flow among a pair of nodes\nin a capacitated graph. The function has to accept at least three\nparameters: a Graph or Digraph, a source node, and a target node.\nAnd return a residual network that follows NetworkX conventions\n(see Notes). If flow_func is None, the default maximum\nflow function (preflow_push()) is used. See below for\nalternative algorithms. The choice of the default function may change\nfrom version to version and should not be relied on. Default value:\nNone.",
                "kwargs : Any other keyword parameter is passed to the function that": "computes the maximum flow."
            },
            "Returns:": {
                "flow_value : integer, float": "Value of the maximum flow, i.e., net outflow from the source.",
                "flow_dict : dict": "A dictionary containing the value of the flow that went through\neach edge."
            },
            "Raises:": {
                "NetworkXError": "The algorithm does not support MultiGraph and MultiDiGraph. If\nthe input graph is an instance of one of these two classes, a\nNetworkXError is raised.",
                "NetworkXUnbounded": "If the graph has a path of infinite capacity, the value of a\nfeasible flow on the graph is unbounded above and the function\nraises a NetworkXUnbounded."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The function used in the flow_func parameter has to return a residual\nnetwork that follows NetworkX conventions: The residual network R from an input graph G has the\nsame nodes as G . R is a DiGraph that contains a pair\nof edges (u,v) and (v,u) iff (u,v) is not a\nself-loop, and at least one of (u,v) and (v,u) exists\nin G . For each edge (u,v) in R , R[u][v]['capacity'] is equal to the capacity of (u,v) in G if it exists\nin G or zero otherwise. If the capacity is infinite, R[u][v]['capacity'] will have a high arbitrary finite value\nthat does not affect the solution of the problem. This value is stored in R.graph['inf'] . For each edge (u,v) in R , R[u][v]['flow'] represents the flow function of (u,v) and\nsatisfies R[u][v]['flow']==-R[v][u]['flow'] . The flow value, defined as the total flow into t , the sink, is\nstored in R.graph['flow_value'] . Reachability to t using\nonly edges (u,v) such that R[u][v]['flow']<R[u][v]['capacity'] induces a minimum s - t cut. Specific algorithms may store extra data in R . The function should supports an optional boolean parameter value_only. When\nTrue, it can optionally terminate the algorithm as soon as the maximum flow\nvalue and the minimum cut can be determined.",
            "Examples": "G=nx.DiGraph()\nG.add_edge(\"x\",\"a\",capacity=3.0)\nG.add_edge(\"x\",\"b\",capacity=1.0)\nG.add_edge(\"a\",\"c\",capacity=3.0)\nG.add_edge(\"b\",\"c\",capacity=5.0)\nG.add_edge(\"b\",\"d\",capacity=4.0)\nG.add_edge(\"d\",\"e\",capacity=2.0)\nG.add_edge(\"c\",\"y\",capacity=2.0)\nG.add_edge(\"e\",\"y\",capacity=3.0)\nmaximum_flow returns both the value of the maximum flow and a\ndictionary with all flows.\nflow_value,flow_dict=nx.maximum_flow(G,\"x\",\"y\")\nflow_value\n# 3.0\nprint(flow_dict[\"x\"][\"b\"])\n# 1.0\nYou can also use alternative algorithms for computing the\nmaximum flow by using the flow_func parameter.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\nflow_value==nx.maximum_flow(G,\"x\",\"y\",flow_func=shortest_augmenting_path)[0]\n# True"
        }
    },
    {
        "Section ID": "to_prufer_sequence",
        "Description": [
            "Returns the Pr\u00fcfer sequence of the given tree.",
            "A Pr\u00fcfer sequence is a list of n - 2 numbers between 0 and n - 1, inclusive. The tree corresponding to a given Pr\u00fcfer\nsequence can be recovered by repeatedly joining a node in the\nsequence with a node with the smallest potential degree according to\nthe sequence."
        ],
        "Field List": {
            "Parameters:": {
                "T : NetworkX graph": "An undirected graph object representing a tree."
            },
            "Returns:": {
                "list": "The Pr\u00fcfer sequence of the given tree."
            },
            "Raises:": {
                "NetworkXPointlessConcept": "If the number of nodes inTis less than two.",
                "NotATree": "IfTis not a tree.",
                "KeyError": "If the set of nodes inTis not {0, \u2026,n- 1}."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "There is a bijection from labeled trees to Pr\u00fcfer sequences. This\nfunction is the inverse of the from_prufer_sequence() function. Sometimes Pr\u00fcfer sequences use nodes labeled from 1 to n instead\nof from 0 to n - 1. This function requires nodes to be labeled in\nthe latter form. You can use relabel_nodes() to\nrelabel the nodes of your tree to the appropriate format. This implementation is from [1] and has a running time of \\(O(n)\\) .",
            "References": "[1]Wang, Xiaodong, Lei Wang, and Yingjie Wu.\n\u201cAn optimal algorithm for Prufer codes.\u201dJournal of Software Engineering and Applications2.02 (2009): 111.\n<https://doi.org/10.4236/jsea.2009.22016>",
            "Examples": "There is a bijection between Pr\u00fcfer sequences and labeled trees, so\nthis function is the inverse of thefrom_prufer_sequence()function:\nedges=[(0,3),(1,3),(2,3),(3,4),(4,5)]\ntree=nx.Graph(edges)\nsequence=nx.to_prufer_sequence(tree)\nsequence\n# [3, 3, 3, 4]\ntree2=nx.from_prufer_sequence(sequence)\nlist(tree2.edges())==edges\n# True"
        }
    },
    {
        "Section ID": "graphviz_layout",
        "Description": [
            "Create node positions for G using Graphviz."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A graph created with NetworkX",
                "prog : string": "Name of Graphviz layout program",
                "root : string, optional": "Root node for twopi layout",
                "args : string, optional": "Extra arguments to Graphviz layout program"
            },
            "Returns:": {
                "Dictionary of x, y, positions keyed by node.": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This is a wrapper for pygraphviz_layout. Note that some graphviz layouts are not guaranteed to be deterministic,\nsee graphviz/graphviz#1767 for more info.",
            "Examples": "G=nx.petersen_graph()\npos=nx.nx_agraph.graphviz_layout(G)\npos=nx.nx_agraph.graphviz_layout(G,prog=\"dot\")"
        }
    },
    {
        "Section ID": "node_disjoint_paths",
        "Description": [
            "Computes node disjoint paths between source and target.",
            "Node disjoint paths are paths that only share their first and last\nnodes. The number of node independent paths between two nodes is\nequal to their local node connectivity."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "s : node": "Source node.",
                "t : node": "Target node.",
                "flow_func : function": "A function for computing the maximum flow among a pair of nodes.\nThe function has to accept at least three parameters: a Digraph,\na source node, and a target node. And return a residual network\nthat follows NetworkX conventions (seemaximum_flow()for\ndetails). If flow_func is None, the default maximum flow function\n(edmonds_karp()) is used. See below for details. The choice\nof the default function may change from version to version and\nshould not be relied on. Default value: None.",
                "cutoff : integer or None (default: None)": "Maximum number of paths to yield. If specified, the maximum flow\nalgorithm will terminate when the flow value reaches or exceeds the\ncutoff. This only works for flows that support the cutoff parameter\n(most do) and is ignored otherwise.",
                "auxiliary : NetworkX DiGraph": "Auxiliary digraph to compute flow based node connectivity. It has\nto have a graph attribute called mapping with a dictionary mapping\nnode names in G and in the auxiliary digraph. If provided\nit will be reused instead of recreated. Default value: None.",
                "residual : NetworkX DiGraph": "Residual network to compute maximum flow. If provided it will be\nreused instead of recreated. Default value: None."
            },
            "Returns:": {
                "paths : generator": "Generator of node disjoint paths."
            },
            "Raises:": {
                "NetworkXNoPath": "If there is no path between source and target.",
                "NetworkXError": "If source or target are not in the graph G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This is a flow based implementation of node disjoint paths. We compute\nthe maximum flow between source and target on an auxiliary directed\nnetwork. The saturated edges in the residual network after running the\nmaximum flow algorithm correspond to node disjoint paths between source\nand target in the original network. This function handles both directed\nand undirected graphs, and can use all flow algorithms from NetworkX flow\npackage.",
            "Examples": "We use in this example the platonic icosahedral graph, which has node\nconnectivity 5, thus there are 5 node disjoint paths between any pair\nof non neighbor nodes.\nG=nx.icosahedral_graph()\nlen(list(nx.node_disjoint_paths(G,0,6)))\n# 5\nIf you need to compute node disjoint paths between several pairs of\nnodes in the same graph, it is recommended that you reuse the\ndata structures that NetworkX uses in the computation: the\nauxiliary digraph for node connectivity and node cuts, and the\nresidual network for the underlying maximum flow computation.\nExample of how to compute node disjoint paths reusing the data\nstructures:\n# You also have to explicitly import the function for\n# building the auxiliary digraph from the connectivity package\nfromnetworkx.algorithms.connectivityimportbuild_auxiliary_node_connectivity\nH=build_auxiliary_node_connectivity(G)\n# And the function for building the residual network from the\n# flow package\nfromnetworkx.algorithms.flowimportbuild_residual_network\n# Note that the auxiliary digraph has an edge attribute named capacity\nR=build_residual_network(H,\"capacity\")\n# Reuse the auxiliary digraph and the residual network by passing them\n# as arguments\nlen(list(nx.node_disjoint_paths(G,0,6,auxiliary=H,residual=R)))\n# 5\nYou can also use alternative flow algorithms for computing node disjoint\npaths. For instance, in dense networks the algorithmshortest_augmenting_path()will usually perform better than\nthe defaultedmonds_karp()which is faster for sparse\nnetworks with highly skewed degree distributions. Alternative flow\nfunctions have to be explicitly imported from the flow package.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\nlen(list(nx.node_disjoint_paths(G,0,6,flow_func=shortest_augmenting_path)))\n# 5"
        }
    },
    {
        "Section ID": "connected_components",
        "Description": [
            "Generate connected components."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "An undirected graph"
            },
            "Returns:": {
                "comp : generator of sets": "A generator of sets of nodes, one for each component of G."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is directed."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For undirected graphs only.",
            "Examples": "Generate a sorted list of connected components, largest first.\nG=nx.path_graph(4)\nnx.add_path(G,[10,11,12])\n[len(c)forcinsorted(nx.connected_components(G),key=len,reverse=True)]\n# [4, 3]\nIf you only want the largest connected component, it\u2019s more\nefficient to use max instead of sort.\nlargest_cc=max(nx.connected_components(G),key=len)\nTo create the induced subgraph of each component use:\nS=[G.subgraph(c).copy()forcinnx.connected_components(G)]"
        }
    },
    {
        "Section ID": "kneser_graph",
        "Description": [
            "Returns the Kneser Graph with parameters n and k .",
            "The Kneser Graph has nodes that are k-tuples (subsets) of the integers\nbetween 0 and n-1 . Nodes are adjacent if their corresponding sets are disjoint."
        ],
        "Field List": {
            "Parameters:": {
                "n: int": "Number of integers from which to make node subsets.\nSubsets are drawn fromset(range(n)).",
                "k: int": "Size of the subsets."
            },
            "Returns:": {
                "G : NetworkX Graph": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.kneser_graph(5,2)\nG.number_of_nodes()\n# 10\nG.number_of_edges()\n# 15\nnx.is_isomorphic(G,nx.petersen_graph())\n# True"
        }
    },
    {
        "Section ID": "schultz_index",
        "Description": [
            "Returns the Schultz Index (of the first kind) of G",
            "The Schultz Index  [3] of a graph is the sum over all node pairs of\ndistances times the sum of degrees. Consider an undirected graph G .\nFor each node pair (u,v) compute dist(u,v)*(deg(u)+deg(v) where dist is the shortest path length between two nodes and deg is the degree of a node.",
            "The Schultz Index is the sum of these quantities over all (unordered)\npairs of nodes."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "The undirected graph of interest.",
                "weight : string or None, optional (default: None)": "If None, every edge has weight 1.\nIf a string, use this edge attribute as the edge weight.\nAny edge attribute not present defaults to 1.\nThe edge weights are used to computing shortest-path distances."
            },
            "Returns:": {
                "number": "The first kind of Schultz Index of the graphG."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]I. Gutman, Selected properties of the Schultz molecular topological index,\nJ. Chem. Inf. Comput. Sci. 34 (1994), 1087\u20131089.https://doi.org/10.1021/ci00021a009  [2]M.V. Diudeaa and I. Gutman, Wiener-Type Topological Indices,\nCroatica Chemica Acta, 71 (1998), 21-51.https://hrcak.srce.hr/132323  [3]H. P. Schultz, Topological organic chemistry. 1.\nGraph theory and topological indices of alkanes,i\nJ. Chem. Inf. Comput. Sci. 29 (1989), 239\u2013257.",
            "Examples": "The Schultz Index of the (unweighted) complete graph onnnodes\nequals the number of pairs of thennodes times2*(n-1),\nsince each pair of nodes is at distance one and the sum of degree\nof two nodes is2*(n-1).\nn=10\nG=nx.complete_graph(n)\nnx.schultz_index(G)==(n*(n-1)/2)*(2*(n-1))\n# True\nGraph that is disconnected\nnx.schultz_index(nx.empty_graph(2))\n# inf"
        }
    },
    {
        "Section ID": "dfs_labeled_edges",
        "Description": [
            "Iterate over edges in a depth-first-search (DFS) labeled by type."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node, optional": "Specify starting node for depth-first search and return edges in\nthe component reachable from source.",
                "depth_limit : int, optional (default=len(G))": "Specify the maximum search depth.",
                "sort_neighbors : function (default=None)": "A function that takes an iterator over nodes as the input, and\nreturns an iterable of the same nodes with a custom ordering.\nFor example,sortedwill sort the nodes in increasing order."
            },
            "Returns:": {
                "edges: generator": "A generator of triples of the form (u,v,d), where (u,v) is the edge being explored in the depth-first search anddis one of the strings \u2018forward\u2019, \u2018nontree\u2019, \u2018reverse\u2019, or \u2018reverse-depth_limit\u2019.\nA \u2018forward\u2019 edge is one in whichuhas been visited butvhas\nnot. A \u2018nontree\u2019 edge is one in which bothuandvhave been\nvisited but the edge is not in the DFS tree. A \u2018reverse\u2019 edge is\none in which bothuandvhave been visited and the edge is in\nthe DFS tree. When thedepth_limitis reached via a \u2018forward\u2019 edge,\na \u2018reverse\u2019 edge is immediately generated rather than the subtree\nbeing explored. To indicate this flavor of \u2018reverse\u2019 edge, the string\nyielded is \u2018reverse-depth_limit\u2019."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "If a source is not specified then a source is chosen arbitrarily and\nrepeatedly until all components in the graph are searched. The implementation of this function is adapted from David Eppstein\u2019s\ndepth-first search function in PADS , with modifications\nto allow depth limits based on the Wikipedia article\n\u201c Depth-limited search \u201d.",
            "Examples": "The labels reveal the complete transcript of the depth-first search\nalgorithm in more detail than, for example,dfs_edges():\nfrompprintimportpprint\n\nG=nx.DiGraph([(0,1),(1,2),(2,1)])\npprint(list(nx.dfs_labeled_edges(G,source=0)))\n# [(0, 0, 'forward'),\n#  (0, 1, 'forward'),\n#  (1, 2, 'forward'),\n#  (2, 1, 'nontree'),\n#  (1, 2, 'reverse'),\n#  (0, 1, 'reverse'),\n#  (0, 0, 'reverse')]"
        }
    },
    {
        "Section ID": "write_gexf",
        "Description": [
            "Write G in GEXF format to path.",
            "\u201cGEXF (Graph Exchange XML Format) is a language for describing\ncomplex networks structures, their associated data and dynamics\u201d [1] .",
            "Node attributes are checked according to the version of the GEXF\nschemas used for parameters which are not user defined,\ne.g. visualization \u2018viz\u2019 [2] . See example for usage."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "path : file or string": "File or file name to write.\nFile names ending in .gz or .bz2 will be compressed.",
                "encoding : string (optional, default: \u2018utf-8\u2019)": "Encoding for text data.",
                "prettyprint : bool (optional, default: True)": "If True use line breaks and indenting in output XML.",
                "version: string (optional, default: \u20181.2draft\u2019)": "The version of GEXF to be used for nodes attributes checking"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This implementation does not support mixed graphs (directed and undirected\nedges together). The node id attribute is set to be the string of the node label.\nIf you want to specify an id use set it as node data, e.g.\nnode[\u2018a\u2019][\u2018id\u2019]=1 to set the id of node \u2018a\u2019 to 1.",
            "References": "[1]GEXF File Format,http://gexf.net/  [2]GEXF schema,http://gexf.net/schema.html",
            "Examples": "G=nx.path_graph(4)\nnx.write_gexf(G,\"test.gexf\")\n# visualization data\n>>> G.nodes[0][\u201cviz\u201d] = {\u201csize\u201d: 54}\n>>> G.nodes[0][\u201cviz\u201d][\u201cposition\u201d] = {\u201cx\u201d: 0, \u201cy\u201d: 1}\n>>> G.nodes[0][\u201cviz\u201d][\u201ccolor\u201d] = {\u201cr\u201d: 0, \u201cg\u201d: 0, \u201cb\u201d: 256}"
        }
    },
    {
        "Section ID": "write_dot",
        "Description": [
            "Write NetworkX graph G to Graphviz dot format on path."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph",
                "path : filename": "Filename or file handle to write"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "To use a specific graph layout, call A.layout prior to write_dot .\nNote that some graphviz layouts are not guaranteed to be deterministic,\nsee graphviz/graphviz#1767 for more info."
        }
    },
    {
        "Section ID": "windmill_graph",
        "Description": [
            "Generate a windmill graph.\nA windmill graph is a graph of n cliques each of size k that are all\njoined at one node.\nIt can be thought of as taking a disjoint union of n cliques of size k ,\nselecting one point from each, and contracting all of the selected points.\nAlternatively, one could generate n cliques of size k-1 and one node\nthat is connected to all other nodes in the graph."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "Number of cliques",
                "k : int": "Size of cliques"
            },
            "Returns:": {
                "G : NetworkX Graph": "windmill graph with n cliques of size k"
            },
            "Raises:": {
                "NetworkXError": "If the number of cliques is less than two\nIf the size of the cliques are less than two"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The node labeled 0 will be the node connected to all other nodes.\nNote that windmill graphs are usually denoted Wd(k,n) , so the parameters\nare in the opposite order as the parameters of this method.",
            "Examples": "G=nx.windmill_graph(4,5)"
        }
    },
    {
        "Section ID": "antichains",
        "Description": [
            "Generates antichains from a directed acyclic graph (DAG).",
            "An antichain is a subset of a partially ordered set such that any\ntwo elements in the subset are incomparable."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX DiGraph": "A directed acyclic graph (DAG)",
                "topo_order: list or tuple, optional": "A topological order for G (if None, the function will compute one)"
            },
            "Yields:": {
                "antichain : list": "a list of nodes inGrepresenting an antichain"
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis not directed",
                "NetworkXUnfeasible": "IfGcontains a cycle"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This function was originally developed by Peter Jipsen and Franco Saliola\nfor the SAGE project. It\u2019s included in NetworkX with permission from the\nauthors. Original SAGE code at: sagemath/sage",
            "References": "[1]Free Lattices, by R. Freese, J. Jezek and J. B. Nation,\nAMS, Vol 42, 1995, p. 226.",
            "Examples": "DG=nx.DiGraph([(1,2),(1,3)])\nlist(nx.antichains(DG))\n# [[], [3], [2], [2, 3], [1]]"
        }
    },
    {
        "Section ID": "bfs_tree",
        "Description": [
            "Returns an oriented tree constructed from of a breadth-first-search\nstarting at source."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node": "Specify starting node for breadth-first search",
                "reverse : bool, optional": "If True traverse a directed graph in the reverse direction",
                "depth_limit : int, optional(default=len(G))": "Specify the maximum search depth",
                "sort_neighbors : function (default=None)": "A function that takes an iterator over nodes as the input, and\nreturns an iterable of the same nodes with a custom ordering.\nFor example,sortedwill sort the nodes in increasing order."
            },
            "Returns:": {
                "T: NetworkX DiGraph": "An oriented tree"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Based on http://www.ics.uci.edu/~eppstein/PADS/BFS.py by D. Eppstein, July 2004. The modifications\nto allow depth limits based on the Wikipedia article\n\u201c Depth-limited-search \u201d.",
            "Examples": "G=nx.path_graph(3)\nlist(nx.bfs_tree(G,1).edges())\n# [(1, 0), (1, 2)]\nH=nx.Graph()\nnx.add_path(H,[0,1,2,3,4,5,6])\nnx.add_path(H,[2,7,8,9,10])\nsorted(list(nx.bfs_tree(H,source=3,depth_limit=3).edges()))\n# [(1, 0), (2, 1), (2, 7), (3, 2), (3, 4), (4, 5), (5, 6), (7, 8)]"
        }
    },
    {
        "Section ID": "np_random_state",
        "Description": [
            "Decorator to generate a numpy RandomState or Generator instance.",
            "The decorator processes the argument indicated by random_state_argument using nx.utils.create_random_state() .\nThe argument value can be a seed (integer), or a numpy.random.RandomState or numpy.random.RandomState instance or ( None or numpy.random ).\nThe latter two options use the global random number generator for numpy.random .",
            "The returned instance is a numpy.random.RandomState or numpy.random.Generator ."
        ],
        "Field List": {
            "Parameters:": {
                "random_state_argument : string or int": "The name or index of the argument to be converted\nto anumpy.random.RandomStateinstance."
            },
            "Returns:": {
                "_random_state : function": "Function whose random_state keyword argument is a RandomState instance."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "Decorate functions like this:\n@np_random_state(\"seed\")defrandom_float(seed=None):returnseed.rand()@np_random_state(0)defrandom_float(rng=None):returnrng.rand()@np_random_state(1)defrandom_array(dims,random_state=1):returnrandom_state.rand(*dims)"
        }
    },
    {
        "Section ID": "is_weighted",
        "Description": [
            "Returns True if G has weighted edges."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.",
                "edge : tuple, optional": "A 2-tuple specifying the only edge inGthat will be tested. If\nNone, then every edge inGis tested.",
                "weight: string, optional": "The attribute name used to query for edge weights."
            },
            "Returns:": {
                "bool": "A boolean signifying ifG, or the specified edge, is weighted."
            },
            "Raises:": {
                "NetworkXError": "If the specified edge does not exist."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.path_graph(4)\nnx.is_weighted(G)\n# False\nnx.is_weighted(G,(2,3))\n# False\nG=nx.DiGraph()\nG.add_edge(1,2,weight=1)\nnx.is_weighted(G)\n# True"
        }
    },
    {
        "Section ID": "simulated_annealing_tsp",
        "Description": [
            "Returns an approximate solution to the traveling salesman problem.",
            "This function uses simulated annealing to approximate the minimal cost\ncycle through the nodes. Starting from a suboptimal solution, simulated\nannealing perturbs that solution, occasionally accepting changes that make\nthe solution worse to escape from a locally optimal solution. The chance\nof accepting such changes decreases over the iterations to encourage\nan optimal result.  In summary, the function returns a cycle starting\nat source for which the total cost is minimized. It also returns the cost.",
            "The chance of accepting a proposed change is related to a parameter called\nthe temperature (annealing has a physical analogue of steel hardening\nas it cools). As the temperature is reduced, the chance of moves that\nincrease cost goes down."
        ],
        "Field List": {
            "Parameters:": {
                "G : Graph": "Gshould be a complete weighted graph.\nThe distance between all pairs of nodes should be included.",
                "init_cycle : list of all nodes or \u201cgreedy\u201d": "The initial solution (a cycle through all nodes returning to the start).\nThis argument has no default to make you think about it.\nIf \u201cgreedy\u201d, usegreedy_tsp(G,weight).\nOther common starting cycles arelist(G)+[next(iter(G))]or the final\nresult ofsimulated_annealing_tspwhen doingthreshold_accepting_tsp.",
                "weight : string, optional (default=\u201dweight\u201d)": "Edge data key corresponding to the edge weight.\nIf any edge does not have this attribute the weight is set to 1.",
                "source : node, optional (default: first node in list(G))": "Starting node.  If None, defaults tonext(iter(G))",
                "temp : int, optional (default=100)": "The algorithm\u2019s temperature parameter. It represents the initial\nvalue of temperature",
                "move : \u201c1-1\u201d or \u201c1-0\u201d or function, optional (default=\u201d1-1\u201d)": "Indicator of what move to use when finding new trial solutions.\nStrings indicate two special built-in moves:\u201c1-1\u201d: 1-1 exchange which transposes the position\nof two elements of the current solution.\nThe function called isswap_two_nodes().\nFor example if we apply 1-1 exchange in the solutionA=[3,2,1,4,3]we can get the following by the transposition of 1 and 4 elements:A'=[3,2,4,1,3]\u201c1-0\u201d: 1-0 exchange which moves an node in the solution\nto a new position.\nThe function called ismove_one_node().\nFor example if we apply 1-0 exchange in the solutionA=[3,2,1,4,3]we can transfer the fourth element to the second position:A'=[3,4,2,1,3]You may provide your own functions to enact a move from\none solution to a neighbor solution. The function must take\nthe solution as input along with aseedinput to control\nrandom number generation (see theseedinput here).\nYour function should maintain the solution as a cycle with\nequal first and last node and all others appearing once.\nYour function should return the new solution.",
                "max_iterations : int, optional (default=10)": "Declared done when this number of consecutive iterations of\nthe outer loop occurs without any change in the best cost solution.",
                "N_inner : int, optional (default=100)": "The number of iterations of the inner loop.",
                "alpha : float between (0, 1), optional (default=0.01)": "Percentage of temperature decrease in each iteration\nof outer loop",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "cycle : list of nodes": "Returns the cycle (list of nodes) that a salesman\ncan follow to minimize total weight of the trip."
            },
            "Raises:": {
                "NetworkXError": "IfGis not complete the algorithm raises an exception."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Simulated Annealing is a metaheuristic local search algorithm.\nThe main characteristic of this algorithm is that it accepts\neven solutions which lead to the increase of the cost in order\nto escape from low quality local optimal solutions. This algorithm needs an initial solution. If not provided, it is\nconstructed by a simple greedy algorithm. At every iteration, the\nalgorithm selects thoughtfully a neighbor solution.\nConsider \\(c(x)\\) cost of current solution and \\(c(x')\\) cost of a\nneighbor solution.\nIf \\(c(x') - c(x) <= 0\\) then the neighbor solution becomes the current\nsolution for the next iteration. Otherwise, the algorithm accepts\nthe neighbor solution with probability \\(p = exp - ([c(x') - c(x)] / temp)\\) .\nOtherwise the current solution is retained. temp is a parameter of the algorithm and represents temperature. Time complexity:\nFor \\(N_i\\) iterations of the inner loop and \\(N_o\\) iterations of the\nouter loop, this algorithm has running time \\(O(N_i * N_o * |V|)\\) . For more information and how the algorithm is inspired see: http://en.wikipedia.org/wiki/Simulated_annealing",
            "Examples": "fromnetworkx.algorithmsimportapproximationasapprox\nG=nx.DiGraph()\nG.add_weighted_edges_from(\n{\n(\"A\",\"B\",3),\n(\"A\",\"C\",17),\n(\"A\",\"D\",14),\n(\"B\",\"A\",3),\n(\"B\",\"C\",12),\n(\"B\",\"D\",16),\n(\"C\",\"A\",13),\n(\"C\",\"B\",12),\n(\"C\",\"D\",4),\n(\"D\",\"A\",14),\n(\"D\",\"B\",15),\n(\"D\",\"C\",2),\n}\n)\ncycle=approx.simulated_annealing_tsp(G,\"greedy\",source=\"D\")\ncost=sum(G[n][nbr][\"weight\"]forn,nbrinnx.utils.pairwise(cycle))\ncycle\n# ['D', 'C', 'B', 'A', 'D']\ncost\n# 31\nincycle=[\"D\",\"B\",\"A\",\"C\",\"D\"]\ncycle=approx.simulated_annealing_tsp(G,incycle,source=\"D\")\ncost=sum(G[n][nbr][\"weight\"]forn,nbrinnx.utils.pairwise(cycle))\ncycle\n# ['D', 'C', 'B', 'A', 'D']\ncost\n# 31"
        }
    },
    {
        "Section ID": "communicability_exp",
        "Description": [
            "Returns communicability between all pairs of nodes in G.",
            "Communicability between pair of node (u,v) of node in G is the sum of\nwalks of different lengths starting at node u and ending at node v."
        ],
        "Field List": {
            "Parameters:": {
                "G: graph": ""
            },
            "Returns:": {
                "comm: dictionary of dictionaries": "Dictionary of dictionaries keyed by nodes with communicability\nas the value."
            },
            "Raises:": {
                "NetworkXError": "If the graph is not undirected and simple."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm uses matrix exponentiation of the adjacency matrix. Let G=(V,E) be a simple undirected graph.  Using the connection between\nthe powers  of the adjacency matrix and the number of walks in the graph,\nthe communicability between nodes u and v is [1] ,",
            "References": "[1]Ernesto Estrada, Naomichi Hatano,\n\u201cCommunicability in complex networks\u201d,\nPhys. Rev. E 77, 036111 (2008).https://arxiv.org/abs/0707.0756",
            "Examples": "G=nx.Graph([(0,1),(1,2),(1,5),(5,4),(2,4),(2,3),(4,3),(3,6)])\nc=nx.communicability_exp(G)"
        }
    },
    {
        "Section ID": "greedy_branching",
        "Description": [
            "Returns a branching obtained through a greedy algorithm.",
            "This algorithm is wrong, and cannot give a proper optimal branching.\nHowever, we include it for pedagogical reasons, as it can be helpful to\nsee what its outputs are.",
            "The output is a branching, and possibly, a spanning arborescence. However,\nit is not guaranteed to be optimal in either case."
        ],
        "Field List": {
            "Parameters:": {
                "G : DiGraph": "The directed graph to scan.",
                "attr : str": "The attribute to use as weights. If None, then each edge will be\ntreated equally with a weight of 1.",
                "default : float": "Whenattris not None, then if an edge does not have that attribute,defaultspecifies what value it should take.",
                "kind : str": "The type of optimum to search for: \u2018min\u2019 or \u2018max\u2019 greedy branching.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "B : directed graph": "The greedily obtained branching."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "from_edgelist",
        "Description": [
            "Returns a graph from a list of edges."
        ],
        "Field List": {
            "Parameters:": {
                "edgelist : list or iterator": "Edge tuples",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "edgelist=[(0,1)]# single edge (0,1)\nG=nx.from_edgelist(edgelist)\nor\nG=nx.Graph(edgelist)# use Graph constructor"
        }
    },
    {
        "Section ID": "Edmonds",
        "Description": [
            "Edmonds algorithm [1] for finding optimal branchings and spanning\narborescences.",
            "This algorithm can find both minimum and maximum spanning arborescences and\nbranchings.",
            "Notes",
            "While this algorithm can find a minimum branching, since it isn\u2019t required\nto be spanning, the minimum branching is always from the set of negative\nweight edges which is most likely the empty set for most graphs.",
            "References"
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {
            "Notes": "While this algorithm can find a minimum branching, since it isn\u2019t required\nto be spanning, the minimum branching is always from the set of negative\nweight edges which is most likely the empty set for most graphs.",
            "References": "[1]J. Edmonds, Optimum Branchings, Journal of Research of the National\nBureau of Standards, 1967, Vol. 71B, p.233-240,https://archive.org/details/jresv71Bn4p233"
        }
    },
    {
        "Section ID": "havel_hakimi_graph",
        "Description": [
            "Returns a bipartite graph from two given degree sequences using a\nHavel-Hakimi style construction.",
            "The graph is composed of two partitions. Set A has nodes 0 to\n(len(aseq) - 1) and set B has nodes len(aseq) to (len(bseq) - 1).\nNodes from the set A are connected to nodes in the set B by\nconnecting the highest degree nodes in set A to the highest degree\nnodes in set B until all stubs are connected."
        ],
        "Field List": {
            "Parameters:": {
                "aseq : list": "Degree sequence for node set A.",
                "bseq : list": "Degree sequence for node set B.",
                "create_using : NetworkX graph instance, optional": "Return graph of this type."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The sum of the two sequences must be equal: sum(aseq)=sum(bseq)\nIf no graph type is specified use MultiGraph with parallel edges.\nIf you want a graph with no parallel edges use create_using=Graph()\nbut then the resulting degree sequences might not be exact. The nodes are assigned the attribute \u2018bipartite\u2019 with the value 0 or 1\nto indicate which bipartite set the node belongs to. This function is not imported in the main namespace.\nTo use it use nx.bipartite.havel_hakimi_graph"
        }
    },
    {
        "Section ID": "zipf_rv",
        "Description": [
            "Returns a random value chosen from the Zipf distribution.",
            "The return value is an integer drawn from the probability distribution",
            "where \\(\\zeta(\\alpha, x_{\\min})\\) is the Hurwitz zeta function."
        ],
        "Field List": {
            "Parameters:": {
                "alpha : float": "Exponent value of the distribution",
                "xmin : int": "Minimum value",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "x : int": "Random value from Zipf distribution"
            },
            "Raises:": {
                "ValueError:": "If xmin < 1 or\nIf alpha <= 1"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The rejection algorithm generates random values for a the power-law\ndistribution in uniformly bounded expected time dependent on\nparameters.  See [1] for details on its operation.",
            "References": "[1]Luc Devroye, Non-Uniform Random Variate Generation,\nSpringer-Verlag, New York, 1986.",
            "Examples": "nx.utils.zipf_rv(alpha=2,xmin=3,seed=42)\n# 8"
        }
    },
    {
        "Section ID": "random_cograph",
        "Description": [
            "Returns a random cograph with \\(2 ^ n\\) nodes.",
            "A cograph is a graph containing no path on four vertices.\nCographs or \\(P_4\\) -free graphs can be obtained from a single vertex\nby disjoint union and complementation operations.",
            "This generator starts off from a single vertex and performs disjoint\nunion and full join operations on itself.\nThe decision on which operation will take place is random."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The order of the cograph.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "G : A random graph containing no path on four vertices.": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]D.G. Corneil, H. Lerchs, L.Stewart Burlingham,\n\u201cComplement reducible graphs\u201d,\nDiscrete Applied Mathematics, Volume 3, Issue 3, 1981, Pages 163-174,\nISSN 0166-218X."
        }
    },
    {
        "Section ID": "eulerian_path",
        "Description": [
            "Return an iterator over the edges of an Eulerian path in G ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "The graph in which to look for an eulerian path.",
                "source : node or None (default: None)": "The node at which to start the search. None means search over all\nstarting nodes.",
                "keys : Bool (default: False)": "Indicates whether to yield edge 3-tuples (u, v, edge_key).\nThe default yields edge 2-tuples"
            },
            "Yields:": {
                "Edge tuples along the eulerian path.": "",
                "Warning: If : source : provided is not the start node of an Euler path": "",
                "will raise error even if an Euler Path exists.": ""
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "arbitrary_element",
        "Description": [
            "Returns an arbitrary element of iterable without removing it.",
            "This is most useful for \u201cpeeking\u201d at an arbitrary element of a set,\nbut can be used for any list, dictionary, etc., as well."
        ],
        "Field List": {
            "Parameters:": {
                "iterable : abc.collections.Iterableinstance": "Any object that implements__iter__, e.g. set, dict, list, tuple,\netc."
            },
            "Returns:": {
                "The object that results from : next(iter(iterable))": ""
            },
            "Raises:": {
                "ValueError": "Ifiterableis an iterator (because the current implementation of\nthis function would consume an element from the iterator)."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This function does not return a random element. If iterable is\nordered, sequential calls will return the same value:",
            "Examples": "Arbitrary elements from common Iterable objects:\nnx.utils.arbitrary_element([1,2,3])# list\n# 1\nnx.utils.arbitrary_element((1,2,3))# tuple\n# 1\nnx.utils.arbitrary_element({1,2,3})# set\n# 1\nd={k:vfork,vinzip([1,2,3],[3,2,1])}\nnx.utils.arbitrary_element(d)# dict_keys\n# 1\nnx.utils.arbitrary_element(d.values())# dict values\n# 3\nstris also an Iterable:\nnx.utils.arbitrary_element(\"hello\")\n# 'h'\nValueErroris raised ifiterableis an iterator:\niterator=iter([1,2,3])# Iterator, *not* Iterable\nnx.utils.arbitrary_element(iterator)Traceback (most recent call last):    ...ValueErrorcannot return an arbitrary item from an iterator"
        }
    },
    {
        "Section ID": "alternating_havel_hakimi_graph",
        "Description": [
            "Returns a bipartite graph from two given degree sequences using\nan alternating Havel-Hakimi style construction.",
            "The graph is composed of two partitions. Set A has nodes 0 to\n(len(aseq) - 1) and set B has nodes len(aseq) to (len(bseq) - 1).\nNodes from the set A are connected to nodes in the set B by\nconnecting the highest degree nodes in set A to alternatively the\nhighest and the lowest degree nodes in set B until all stubs are\nconnected."
        ],
        "Field List": {
            "Parameters:": {
                "aseq : list": "Degree sequence for node set A.",
                "bseq : list": "Degree sequence for node set B.",
                "create_using : NetworkX graph instance, optional": "Return graph of this type."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The sum of the two sequences must be equal: sum(aseq)=sum(bseq)\nIf no graph type is specified use MultiGraph with parallel edges.\nIf you want a graph with no parallel edges use create_using=Graph()\nbut then the resulting degree sequences might not be exact. The nodes are assigned the attribute \u2018bipartite\u2019 with the value 0 or 1\nto indicate which bipartite set the node belongs to. This function is not imported in the main namespace.\nTo use it use nx.bipartite.alternating_havel_hakimi_graph"
        }
    },
    {
        "Section ID": "geographical_threshold_graph",
        "Description": [
            "Returns a geographical threshold graph.",
            "The geographical threshold graph model places \\(n\\) nodes uniformly at\nrandom in a rectangular domain.  Each node \\(u\\) is assigned a weight \\(w_u\\) . Two nodes \\(u\\) and \\(v\\) are joined by an edge if",
            "where r is the distance between u and v , p_dist is any function of r , and \\(\\theta\\) as the threshold parameter. p_dist is used to\ngive weight to the distance between nodes when deciding whether or not\nthey should be connected. The larger p_dist is, the more prone nodes\nseparated by r are to be connected, and vice versa."
        ],
        "Field List": {
            "Parameters:": {
                "n : int or iterable": "Number of nodes or iterable of nodes",
                "theta: float": "Threshold value",
                "dim : int, optional": "Dimension of graph",
                "pos : dict": "Node positions as a dictionary of tuples keyed by node.",
                "weight : dict": "Node weights as a dictionary of numbers keyed by node.",
                "metric : function": "A metric on vectors of numbers (represented as lists or\ntuples). This must be a function that accepts two lists (or\ntuples) as input and yields a number as output. The function\nmust also satisfy the four requirements of ametric.\nSpecifically, if\\(d\\)is the function and\\(x\\),\\(y\\),\nand\\(z\\)are vectors in the graph, then\\(d\\)must satisfy\\(d(x, y) \\ge 0\\),\\(d(x, y) = 0\\)if and only if\\(x = y\\),\\(d(x, y) = d(y, x)\\),\\(d(x, z) \\le d(x, y) + d(y, z)\\).If this argument is not specified, the Euclidean distance metric is\nused.",
                "p_dist : function, optional": "Any function used to give weight to the distance between nodes when\ndeciding whether or not they should be connected.p_distwas\noriginally conceived as a probability density function giving the\nprobability of connecting two nodes that are of metric distancerapart. The implementation here allows for more arbitrary definitions\nofp_distthat do not need to correspond to valid probability\ndensity functions. Thescipy.statspackage has many\nprobability density functions implemented and tools for custom\nprobability density definitions, and passing the.pdfmethod of\nscipy.stats distributions can be used here. Ifp_dist=None(the default), the exponential function\\(r^{-2}\\)is used.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "pos_name : string, default=\u201dpos\u201d": "The name of the node attribute which represents the position\nin 2D coordinates of the node in the returned graph.",
                "weight_name : string, default=\u201dweight\u201d": "The name of the node attribute which represents the weight\nof the node in the returned graph."
            },
            "Returns:": {
                "Graph": "A random geographic threshold graph, undirected and without\nself-loops.Each node has a node attributeposthat stores the\nposition of that node in Euclidean space as provided by theposkeyword argument or, ifposwas not provided, as\ngenerated by this function. Similarly, each node has a node\nattributeweightthat stores the weight of that node as\nprovided or as generated."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "If weights are not specified they are assigned to nodes by drawing randomly\nfrom the exponential distribution with rate parameter \\(\\lambda=1\\) .\nTo specify weights from a different distribution, use the weight keyword\nargument:",
            "References": "[1]Masuda, N., Miwa, H., Konno, N.:\nGeographical threshold graphs with small-world and scale-free\nproperties.\nPhysical Review E 71, 036108 (2005)  [2]Milan Bradonji\u0107, Aric Hagberg and Allon G. Percus,\nGiant component and connectivity in geographical threshold graphs,\nin Algorithms and Models for the Web-Graph (WAW 2007),\nAntony Bonato and Fan Chung (Eds), pp. 209\u2013216, 2007",
            "Examples": "Specify an alternate distance metric using themetrickeyword\nargument. For example, to use thetaxicab metricinstead of the\ndefaultEuclidean metric:\ndist=lambdax,y:sum(abs(a-b)fora,binzip(x,y))\nG=nx.geographical_threshold_graph(10,0.1,metric=dist)"
        }
    },
    {
        "Section ID": "minimum_edge_cut",
        "Description": [
            "Returns a set of edges of minimum cardinality that disconnects G.",
            "If source and target nodes are provided, this function returns the\nset of edges of minimum cardinality that, if removed, would break\nall paths among source and target in G. If not, it returns a set of\nedges of minimum cardinality that disconnects G."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "s : node": "Source node. Optional. Default value: None.",
                "t : node": "Target node. Optional. Default value: None.",
                "flow_func : function": "A function for computing the maximum flow among a pair of nodes.\nThe function has to accept at least three parameters: a Digraph,\na source node, and a target node. And return a residual network\nthat follows NetworkX conventions (seemaximum_flow()for\ndetails). If flow_func is None, the default maximum flow function\n(edmonds_karp()) is used. See below for details. The\nchoice of the default function may change from version\nto version and should not be relied on. Default value: None."
            },
            "Returns:": {
                "cutset : set": "Set of edges that, if removed, would disconnect G. If source\nand target nodes are provided, the set contains the edges that\nif removed, would destroy all paths between source and target."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This is a flow based implementation of minimum edge cut. For\nundirected graphs the algorithm works by finding a \u2018small\u2019 dominating\nset of nodes of G (see algorithm 7 in [1] ) and computing the maximum\nflow between an arbitrary node in the dominating set and the rest of\nnodes in it. This is an implementation of algorithm 6 in [1] . For\ndirected graphs, the algorithm does n calls to the max flow function.\nThe function raises an error if the directed graph is not weakly\nconnected and returns an empty set if it is weakly connected.\nIt is an implementation of algorithm 8 in [1] .",
            "References": "[1](1,2,3)Abdol-Hossein Esfahanian. Connectivity Algorithms.http://www.cse.msu.edu/~cse835/Papers/Graph_connectivity_revised.pdf",
            "Examples": "# Platonic icosahedral graph has edge connectivity 5\nG=nx.icosahedral_graph()\nlen(nx.minimum_edge_cut(G))\n# 5\nYou can use alternative flow algorithms for the underlying\nmaximum flow computation. In dense networks the algorithmshortest_augmenting_path()will usually perform better\nthan the defaultedmonds_karp(), which is faster for\nsparse networks with highly skewed degree distributions.\nAlternative flow functions have to be explicitly imported\nfrom the flow package.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\nlen(nx.minimum_edge_cut(G,flow_func=shortest_augmenting_path))\n# 5\nIf you specify a pair of nodes (source and target) as parameters,\nthis function returns the value of local edge connectivity.\nnx.edge_connectivity(G,3,7)\n# 5\nIf you need to perform several local computations among different\npairs of nodes on the same graph, it is recommended that you reuse\nthe data structures used in the maximum flow computations. Seelocal_edge_connectivity()for details."
        }
    },
    {
        "Section ID": "is_reachable",
        "Description": [
            "Decides whether there is a path from s to t in the\ntournament.",
            "This function is more theoretically efficient than the reachability\nchecks than the shortest path algorithms in networkx.algorithms.shortest_paths .",
            "The given graph must be a tournament, otherwise this function\u2019s\nbehavior is undefined."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A directed graph representing a tournament.",
                "s : node": "A node in the graph.",
                "t : node": "A node in the graph."
            },
            "Returns:": {
                "bool": "Whether there is a path fromstotinG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Although this function is more theoretically efficient than the\ngeneric shortest path functions, a speedup requires the use of\nparallelism. Though it may in the future, the current implementation\ndoes not use parallelism, thus you may not see much of a speedup. This algorithm comes from [1].",
            "References": "[1]Tantau, Till.\n\u201cA note on the complexity of the reachability problem for\ntournaments.\u201dElectronic Colloquium on Computational Complexity. 2001.\n<http://eccc.hpi-web.de/report/2001/092/>",
            "Examples": "G=nx.DiGraph([(1,0),(1,3),(1,2),(2,3),(2,0),(3,0)])\nnx.is_tournament(G)\n# True\nnx.tournament.is_reachable(G,1,3)\n# True\nnx.tournament.is_reachable(G,3,2)\n# False"
        }
    },
    {
        "Section ID": "paley_graph",
        "Description": [
            "Returns the Paley \\(\\frac{(p-1)}{2}\\) -regular graph on \\(p\\) nodes.",
            "The returned graph is a graph on \\(\\mathbb{Z}/p\\mathbb{Z}\\) with edges between \\(x\\) and \\(y\\) if and only if \\(x-y\\) is a nonzero square in \\(\\mathbb{Z}/p\\mathbb{Z}\\) .",
            "If \\(p \\equiv 1  \\pmod 4\\) , \\(-1\\) is a square in \\(\\mathbb{Z}/p\\mathbb{Z}\\) and therefore \\(x-y\\) is a square if and\nonly if \\(y-x\\) is also a square, i.e the edges in the Paley graph are symmetric.",
            "If \\(p \\equiv 3 \\pmod 4\\) , \\(-1\\) is not a square in \\(\\mathbb{Z}/p\\mathbb{Z}\\) and therefore either \\(x-y\\) or \\(y-x\\) is a square in \\(\\mathbb{Z}/p\\mathbb{Z}\\) but not both.",
            "Note that a more general definition of Paley graphs extends this construction\nto graphs over \\(q=p^n\\) vertices, by using the finite field \\(F_q\\) instead of \\(\\mathbb{Z}/p\\mathbb{Z}\\) .\nThis construction requires to compute squares in general finite fields and is\nnot what is implemented here (i.e paley_graph(25) does not return the true\nPaley graph associated with \\(5^2\\) )."
        ],
        "Field List": {
            "Parameters:": {
                "p : int, an odd prime number.": "",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : graph": "The constructed directed graph."
            },
            "Raises:": {
                "NetworkXError": "If the graph is a multigraph."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "Chapter 13 in B. Bollobas, Random Graphs. Second edition.\nCambridge Studies in Advanced Mathematics, 73.\nCambridge University Press, Cambridge (2001)."
        }
    },
    {
        "Section ID": "s_metric",
        "Description": [
            "Returns the s-metric [1] of graph.",
            "The s-metric is defined as the sum of the products deg(u)*deg(v) for every edge (u,v) in G ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "The graph used to compute the s-metric.",
                "normalized : bool (optional)": "Normalize the value.Deprecated since version 3.2:Thenormalizedkeyword argument is deprecated and will be removed\nin the future"
            },
            "Returns:": {
                "s : float": "The s-metric of the graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Lun Li, David Alderson, John C. Doyle, and Walter Willinger,\nTowards a Theory of Scale-Free Graphs:\nDefinition, Properties, and  Implications (Extended Version), 2005.https://arxiv.org/abs/cond-mat/0501169"
        }
    },
    {
        "Section ID": "dag_to_branching",
        "Description": [
            "Returns a branching representing all (overlapping) paths from\nroot nodes to leaf nodes in the given directed acyclic graph.",
            "As described in networkx.algorithms.tree.recognition , a branching is a directed forest in which each node has at most one\nparent. In other words, a branching is a disjoint union of arborescences . For this function, each node of in-degree zero in G becomes a root of one of the arborescences, and there will be\none leaf node for each distinct path from that root to a leaf node\nin G .",
            "Each node v in G with k parents becomes k distinct nodes in\nthe returned branching, one for each parent, and the sub-DAG rooted\nat v is duplicated for each copy. The algorithm then recurses on\nthe children of each copy of v ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A directed acyclic graph."
            },
            "Returns:": {
                "DiGraph": "The branching in which there is a bijection between root-to-leaf\npaths inG(in which multiple paths may share the same leaf)\nand root-to-leaf paths in the branching (in which there is a\nunique path from a root to a leaf).Each node has an attribute \u2018source\u2019 whose value is the original\nnode to which this node corresponds. No other graph, node, or\nedge attributes are copied into this new graph."
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis not directed, or ifGis a multigraph.",
                "HasACycle": "IfGis not acyclic."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This function is not idempotent in the sense that the node labels in\nthe returned branching may be uniquely generated each time the\nfunction is invoked. In fact, the node labels may not be integers;\nin order to relabel the nodes to be more readable, you can use the networkx.convert_node_labels_to_integers() function. The current implementation of this function uses networkx.prefix_tree() , so it is subject to the limitations of\nthat function.",
            "Examples": "To examine which nodes in the returned branching were produced by\nwhich original node in the directed acyclic graph, we can collect\nthe mapping from source node to new nodes into a dictionary. For\nexample, consider the directed diamond graph:\nfromcollectionsimportdefaultdict\nfromoperatorimportitemgetter\n\nG=nx.DiGraph(nx.utils.pairwise(\"abd\"))\nG.add_edges_from(nx.utils.pairwise(\"acd\"))\nB=nx.dag_to_branching(G)\n\nsources=defaultdict(set)\nforv,sourceinB.nodes(data=\"source\"):\nsources[source].add(v)\nlen(sources[\"a\"])\n# 1\nlen(sources[\"d\"])\n# 2\nTo copy node attributes from the original graph to the new graph,\nyou can use a dictionary like the one constructed in the above\nexample:\nforsource,nodesinsources.items():\nforvinnodes:\nB.nodes[v].update(G.nodes[source])"
        }
    },
    {
        "Section ID": "descendants",
        "Description": [
            "Returns all nodes reachable from source in G ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "",
                "source : node inG": ""
            },
            "Returns:": {
                "set()": "The descendants ofsourceinG"
            },
            "Raises:": {
                "NetworkXError": "If nodesourceis not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "DG=nx.path_graph(5,create_using=nx.DiGraph)\nsorted(nx.descendants(DG,2))\n# [3, 4]\nThesourcenode is not a descendant of itself, but can be included manually:\nsorted(nx.descendants(DG,2)|{2})\n# [2, 3, 4]"
        }
    },
    {
        "Section ID": "spectral_layout",
        "Description": [
            "Position nodes using the eigenvectors of the graph Laplacian.",
            "Using the unnormalized Laplacian, the layout shows possible clusters of\nnodes which are an approximation of the ratio cut. If dim is the number of\ndimensions then the positions are the entries of the dim eigenvectors\ncorresponding to the ascending eigenvalues starting from the second one."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph or list of nodes": "A position will be assigned to every node in G.",
                "weight : string or None   optional (default=\u2019weight\u2019)": "The edge attribute that holds the numerical value used for\nthe edge weight.  If None, then all edge weights are 1.",
                "scale : number (default: 1)": "Scale factor for positions.",
                "center : array-like or None": "Coordinate pair around which to center the layout.",
                "dim : int": "Dimension of layout."
            },
            "Returns:": {
                "pos : dict": "A dictionary of positions keyed by node"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Directed graphs will be considered as undirected graphs when\npositioning the nodes. For larger graphs (>500 nodes) this will use the SciPy sparse\neigenvalue solver (ARPACK).",
            "Examples": "G=nx.path_graph(4)\npos=nx.spectral_layout(G)"
        }
    },
    {
        "Section ID": "find_threshold_graph",
        "Description": [
            "Returns a threshold subgraph that is close to largest in G .",
            "The threshold graph will contain the largest degree node in G."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph instance": "An instance ofGraph, orMultiDiGraph",
                "create_using : NetworkX graph class orNone(default), optional": "Type of graph to use when constructing the threshold graph.\nIfNone, infer the appropriate graph type from the input."
            },
            "Returns:": {
                "graph": "A graph instance representing the threshold graph"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Threshold graphs:https://en.wikipedia.org/wiki/Threshold_graph",
            "Examples": "fromnetworkx.algorithms.thresholdimportfind_threshold_graph\nG=nx.barbell_graph(3,3)\nT=find_threshold_graph(G)\nT.nodes# may vary\n# NodeView((7, 8, 5, 6))"
        }
    },
    {
        "Section ID": "number_of_selfloops",
        "Description": [
            "Returns the number of selfloop edges.",
            "A selfloop edge has the same node at both ends."
        ],
        "Field List": {
            "Returns:": {
                "nloops : int": "The number of selfloops."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_edge(1,1)\nG.add_edge(1,2)\nnx.number_of_selfloops(G)\n# 1"
        }
    },
    {
        "Section ID": "triad_type",
        "Description": [
            "Returns the sociological triad type for a triad."
        ],
        "Field List": {
            "Parameters:": {
                "G : digraph": "A NetworkX DiGraph with 3 nodes"
            },
            "Returns:": {
                "triad_type : str": "A string identifying the triad type"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "There can be 6 unique edges in a triad (order-3 DiGraph) (so 2^^6=64 unique\ntriads given 3 nodes). These 64 triads each display exactly 1 of 16\ntopologies of triads (topologies can be permuted). These topologies are\nidentified by the following notation: {m}{a}{n}{type} (for example: 111D, 210, 102) Here:",
            "References": "[1]Snijders, T. (2012). \u201cTransitivity and triads.\u201d University of\nOxford.https://web.archive.org/web/20170830032057/http://www.stats.ox.ac.uk/~snijders/Trans_Triads_ha.pdf",
            "Examples": "G=nx.DiGraph([(1,2),(2,3),(3,1)])\nnx.triad_type(G)\n# '030C'\nG.add_edge(1,3)\nnx.triad_type(G)\n# '120C'"
        }
    },
    {
        "Section ID": "is_threshold_graph",
        "Description": [
            "Returns True if G is a threshold graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph instance": "An instance ofGraph,DiGraph,MultiGraphorMultiDiGraph"
            },
            "Returns:": {
                "bool": "TrueifGis a threshold graph,Falseotherwise."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Threshold graphs:https://en.wikipedia.org/wiki/Threshold_graph",
            "Examples": "fromnetworkx.algorithms.thresholdimportis_threshold_graph\nG=nx.path_graph(3)\nis_threshold_graph(G)\n# True\nG=nx.barbell_graph(3,3)\nis_threshold_graph(G)\n# False"
        }
    },
    {
        "Section ID": "cn_soundarajan_hopcroft",
        "Description": [],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX undirected graph.",
                "ebunch : iterable of node pairs, optional (default = None)": "The score will be computed for each pair of nodes given in the\niterable. The pairs must be given as 2-tuples (u, v) where u\nand v are nodes in the graph. If ebunch is None then all\nnonexistent edges in the graph will be used.\nDefault value: None.",
                "community : string, optional (default = \u2018community\u2019)": "Nodes attribute name containing the community information.\nG[u][community] identifies which community u belongs to. Each\nnode belongs to at most one community. Default value: \u2018community\u2019."
            },
            "Returns:": {
                "piter : iterator": "An iterator of 3-tuples in the form (u, v, p) where (u, v) is a\npair of nodes and p is their score."
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis aDiGraph, aMultigraphor aMultiDiGraph.",
                "NetworkXAlgorithmError": "If no community information is available for a node inebunchor inG(ifebunchisNone).",
                "NodeNotFound": "Ifebunchhas a node that is not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Sucheta Soundarajan and John Hopcroft.\nUsing community information to improve the precision of link\nprediction methods.\nIn Proceedings of the 21st international conference companion on\nWorld Wide Web (WWW \u201812 Companion). ACM, New York, NY, USA, 607-608.http://doi.acm.org/10.1145/2187980.2188150",
            "Examples": "G=nx.path_graph(3)\nG.nodes[0][\"community\"]=0\nG.nodes[1][\"community\"]=0\nG.nodes[2][\"community\"]=0\npreds=nx.cn_soundarajan_hopcroft(G,[(0,2)])\nforu,v,pinpreds:\nprint(f\"({u}, {v}) -> {p}\")\n# (0, 2) -> 2"
        }
    },
    {
        "Section ID": "minimum_node_cut",
        "Description": [
            "Returns a set of nodes of minimum cardinality that disconnects G.",
            "If source and target nodes are provided, this function returns the\nset of nodes of minimum cardinality that, if removed, would destroy\nall paths among source and target in G. If not, it returns a set\nof nodes of minimum cardinality that disconnects G."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "s : node": "Source node. Optional. Default value: None.",
                "t : node": "Target node. Optional. Default value: None.",
                "flow_func : function": "A function for computing the maximum flow among a pair of nodes.\nThe function has to accept at least three parameters: a Digraph,\na source node, and a target node. And return a residual network\nthat follows NetworkX conventions (seemaximum_flow()for\ndetails). If flow_func is None, the default maximum flow function\n(edmonds_karp()) is used. See below for details. The\nchoice of the default function may change from version\nto version and should not be relied on. Default value: None."
            },
            "Returns:": {
                "cutset : set": "Set of nodes that, if removed, would disconnect G. If source\nand target nodes are provided, the set contains the nodes that\nif removed, would destroy all paths between source and target."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This is a flow based implementation of minimum node cut. The algorithm\nis based in solving a number of maximum flow computations to determine\nthe capacity of the minimum cut on an auxiliary directed network that\ncorresponds to the minimum node cut of G. It handles both directed\nand undirected graphs. This implementation is based on algorithm 11\nin [1] .",
            "References": "[1]Abdol-Hossein Esfahanian. Connectivity Algorithms.http://www.cse.msu.edu/~cse835/Papers/Graph_connectivity_revised.pdf",
            "Examples": "# Platonic icosahedral graph has node connectivity 5\nG=nx.icosahedral_graph()\nnode_cut=nx.minimum_node_cut(G)\nlen(node_cut)\n# 5\nYou can use alternative flow algorithms for the underlying maximum\nflow computation. In dense networks the algorithmshortest_augmenting_path()will usually perform better\nthan the defaultedmonds_karp(), which is faster for\nsparse networks with highly skewed degree distributions. Alternative\nflow functions have to be explicitly imported from the flow package.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\nnode_cut==nx.minimum_node_cut(G,flow_func=shortest_augmenting_path)\n# True\nIf you specify a pair of nodes (source and target) as parameters,\nthis function returns a local st node cut.\nlen(nx.minimum_node_cut(G,3,7))\n# 5\nIf you need to perform several local st cuts among different\npairs of nodes on the same graph, it is recommended that you reuse\nthe data structures used in the maximum flow computations. Seeminimum_st_node_cut()for details."
        }
    },
    {
        "Section ID": "no_filter",
        "Description": [
            "Returns a filter function that always evaluates to True."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "tutte_graph",
        "Description": [
            "Returns the Tutte graph.",
            "The Tutte graph is a cubic polyhedral, non-Hamiltonian graph. It has\n46 nodes and 69 edges.\nIt is a counterexample to Tait\u2019s conjecture that every 3-regular polyhedron\nhas a Hamiltonian cycle.\nIt can be realized geometrically from a tetrahedron by multiply truncating\nthree of its vertices [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : networkx Graph": "Tutte graph"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://en.wikipedia.org/wiki/Tutte_graph"
        }
    },
    {
        "Section ID": "gutman_index",
        "Description": [
            "Returns the Gutman Index for the graph G .",
            "The Gutman Index measures the topology of networks, especially for molecule\nnetworks of atoms connected by bonds [1] . It is also called the Schultz Index\nof the second kind [2] .",
            "Consider an undirected graph G with node set V .\nThe Gutman Index of a graph is the sum over all (unordered) pairs of nodes\nof nodes (u,v) , with distance dist(u,v) and degrees deg(u) and deg(v) , of dist(u,v)*deg(u)*deg(v)"
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "weight : string or None, optional (default: None)": "If None, every edge has weight 1.\nIf a string, use this edge attribute as the edge weight.\nAny edge attribute not present defaults to 1.\nThe edge weights are used to computing shortest-path distances."
            },
            "Returns:": {
                "number": "The Gutman Index of the graphG."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]M.V. Diudeaa and I. Gutman, Wiener-Type Topological Indices,\nCroatica Chemica Acta, 71 (1998), 21-51.https://hrcak.srce.hr/132323  [2]I. Gutman, Selected properties of the Schultz molecular topological index,\nJ. Chem. Inf. Comput. Sci. 34 (1994), 1087\u20131089.https://doi.org/10.1021/ci00021a009",
            "Examples": "The Gutman Index of the (unweighted) complete graph onnnodes\nequals the number of pairs of thennodes times(n-1)*(n-1),\nsince each pair of nodes is at distance one and the product of degree of two\nvertices is(n-1)*(n-1).\nn=10\nG=nx.complete_graph(n)\nnx.gutman_index(G)==(n*(n-1)/2)*((n-1)*(n-1))\n# True\nGraphs that are disconnected\nG=nx.empty_graph(2)\nnx.gutman_index(G)\n# inf"
        }
    },
    {
        "Section ID": "eppstein_matching",
        "Description": [
            "Returns the maximum cardinality matching of the bipartite graph G ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected bipartite graph",
                "top_nodes : container": "Container with all nodes in one bipartite node set. If not supplied\nit will be computed. But if more than one solution exists an exception\nwill be raised."
            },
            "Returns:": {
                "matches : dictionary": "The matching is returned as a dictionary,matching, such thatmatching[v]==wif nodevis matched to nodew. Unmatched\nnodes do not occur as a key inmatching."
            },
            "Raises:": {
                "AmbiguousSolution": "Raised if the input bipartite graph is disconnected and no container\nwith all nodes in one bipartite set is provided. When determining\nthe nodes in each bipartite set more than one valid solution is\npossible if the input graph is disconnected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This function is implemented with David Eppstein\u2019s version of the algorithm\nHopcroft\u2013Karp algorithm (see hopcroft_karp_matching() ), which\noriginally appeared in the Python Algorithms and Data Structures library\n(PADS) . See bipartitedocumentation for further details on how bipartite graphs are handled in NetworkX."
        }
    },
    {
        "Section ID": "min_cost_flow_cost",
        "Description": [
            "Find the cost of a minimum cost flow satisfying all demands in digraph G.",
            "G is a digraph with edge costs and capacities and in which nodes\nhave demand, i.e., they want to send or receive some amount of\nflow. A negative demand means that the node wants to send flow, a\npositive demand means that the node want to receive flow. A flow on\nthe digraph G satisfies all demand if the net flow into each node\nis equal to the demand of that node."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "DiGraph on which a minimum cost flow satisfying all demands is\nto be found.",
                "demand : string": "Nodes of the graph G are expected to have an attribute demand\nthat indicates how much flow a node wants to send (negative\ndemand) or receive (positive demand). Note that the sum of the\ndemands should be 0 otherwise the problem in not feasible. If\nthis attribute is not present, a node is considered to have 0\ndemand. Default value: \u2018demand\u2019.",
                "capacity : string": "Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: \u2018capacity\u2019.",
                "weight : string": "Edges of the graph G are expected to have an attribute weight\nthat indicates the cost incurred by sending one unit of flow on\nthat edge. If not present, the weight is considered to be 0.\nDefault value: \u2018weight\u2019."
            },
            "Returns:": {
                "flowCost : integer, float": "Cost of a minimum cost flow satisfying all demands."
            },
            "Raises:": {
                "NetworkXError": "This exception is raised if the input graph is not directed or\nnot connected.",
                "NetworkXUnfeasible": "This exception is raised in the following situations:The sum of the demands is not zero. Then, there is no\nflow satisfying all demands.There is no flow satisfying all demand.",
                "NetworkXUnbounded": "This exception is raised if the digraph G has a cycle of\nnegative cost and infinite capacity. Then, the cost of a flow\nsatisfying all demands is unbounded below."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm is not guaranteed to work if edge weights or demands\nare floating point numbers (overflows and roundoff errors can\ncause problems). As a workaround you can use integer numbers by\nmultiplying the relevant edge attributes by a convenient\nconstant factor (eg 100).",
            "Examples": "A simple example of a min cost flow problem.\nG=nx.DiGraph()\nG.add_node(\"a\",demand=-5)\nG.add_node(\"d\",demand=5)\nG.add_edge(\"a\",\"b\",weight=3,capacity=4)\nG.add_edge(\"a\",\"c\",weight=6,capacity=10)\nG.add_edge(\"b\",\"d\",weight=1,capacity=9)\nG.add_edge(\"c\",\"d\",weight=2,capacity=5)\nflowCost=nx.min_cost_flow_cost(G)\nflowCost\n# 24"
        }
    },
    {
        "Section ID": "maximum_matching",
        "Description": [
            "Returns the maximum cardinality matching in the given bipartite graph.",
            "This function is simply an alias for hopcroft_karp_matching() ."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "to_networkx_graph",
        "Description": [
            "Make a NetworkX graph from a known data structure.",
            "The preferred way to call this is automatically\nfrom the class constructor",
            "instead of the equivalent"
        ],
        "Field List": {
            "Parameters:": {
                "data : object to be converted": "Current known types are:any NetworkX graph\ndict-of-dicts\ndict-of-lists\ncontainer (e.g. set, list, tuple) of edges\niterator (e.g. itertools.chain) that produces edges\ngenerator of edges\nPandas DataFrame (row per edge)\n2D numpy array\nscipy sparse array\npygraphviz agraph",
                "Current known types are:": "any NetworkX graph\ndict-of-dicts\ndict-of-lists\ncontainer (e.g. set, list, tuple) of edges\niterator (e.g. itertools.chain) that produces edges\ngenerator of edges\nPandas DataFrame (row per edge)\n2D numpy array\nscipy sparse array\npygraphviz agraph",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated.",
                "multigraph_input : bool (default False)": "If True and  data is a dict_of_dicts,\ntry to create a multigraph assuming dict_of_dict_of_lists.\nIf data and create_using are both multigraphs then create\na multigraph from a multigraph."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "heawood_graph",
        "Description": [
            "Returns the Heawood Graph, a (3,6) cage.",
            "The Heawood Graph is an undirected graph with 14 nodes and 21 edges,\nnamed after Percy John Heawood [1] .\nIt is cubic symmetric, nonplanar, Hamiltonian, and can be represented\nin LCF notation as [5,-5]^7  [2] .\nIt is the unique (3,6)-cage: the regular cubic graph of girth 6 with\nminimal number of vertices [3] ."
        ],
        "Field List": {
            "Parameters:": {
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : networkx Graph": "Heawood Graph with 14 nodes and 21 edges"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://en.wikipedia.org/wiki/Heawood_graph  [2]https://mathworld.wolfram.com/HeawoodGraph.html  [3]https://www.win.tue.nl/~aeb/graphs/Heawood.html"
        }
    },
    {
        "Section ID": "rooted_tree_isomorphism",
        "Description": [
            "Given two rooted trees t1 and t2 ,\nwith roots root1 and root2 respectively\nthis routine will determine if they are isomorphic.",
            "These trees may be either directed or undirected,\nbut if they are directed, all edges should flow from the root.",
            "It returns the isomorphism, a mapping of the nodes of t1 onto the nodes\nof t2 , such that two trees are then identical.",
            "Note that two trees may have more than one isomorphism, and this\nroutine just returns one valid mapping."
        ],
        "Field List": {
            "Parameters:": {
                "`t1` : NetworkX graph": "One of the trees being compared",
                "`root1` : a node oft1which is the root of the tree": "",
                "`t2` : undirected NetworkX graph": "The other tree being compared",
                "`root2` : a node oft2which is the root of the tree": "",
                "This is a subroutine used to implement `tree_isomorphism`, but will": "",
                "be somewhat faster if you already have rooted trees.": ""
            },
            "Returns:": {
                "isomorphism : list": "A list of pairs in which the left element is a node int1and the right element is a node int2.  The pairs are in\narbitrary order.  If the nodes in one tree is mapped to the names in\nthe other, then trees will be identical. Note that an isomorphism\nwill not necessarily be unique.Ift1andt2are not isomorphic, then it returns the empty list."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "kosaraju_strongly_connected_components",
        "Description": [
            "Generate nodes in strongly connected components of graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "A directed graph."
            },
            "Returns:": {
                "comp : generator of sets": "A generator of sets of nodes, one for each strongly connected\ncomponent of G."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Uses Kosaraju\u2019s algorithm.",
            "Examples": "Generate a sorted list of strongly connected components, largest first.\nG=nx.cycle_graph(4,create_using=nx.DiGraph())\nnx.add_cycle(G,[10,11,12])\n[\nlen(c)\nforcinsorted(\nnx.kosaraju_strongly_connected_components(G),key=len,reverse=True\n)\n]\n# [4, 3]\nIf you only want the largest component, it\u2019s more efficient to\nuse max instead of sort.\nlargest=max(nx.kosaraju_strongly_connected_components(G),key=len)"
        }
    },
    {
        "Section ID": "partition_quality",
        "Description": [
            "Returns the coverage and performance of a partition of G.",
            "The coverage of a partition is the ratio of the number of\nintra-community edges to the total number of edges in the graph.",
            "The performance of a partition is the number of\nintra-community edges plus inter-community non-edges divided by the total\nnumber of potential edges.",
            "This algorithm has complexity \\(O(C^2 + L)\\) where C is the number of communities and L is the number of links."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "partition : sequence": "Partition of the nodes ofG, represented as a sequence of\nsets of nodes (blocks). Each block of the partition represents a\ncommunity."
            },
            "Returns:": {
                "(float, float)": "The (coverage, performance) tuple of the partition, as defined above."
            },
            "Raises:": {
                "NetworkXError": "Ifpartitionis not a valid partition of the nodes ofG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "",
            "References": "[1]Santo Fortunato.\n\u201cCommunity Detection in Graphs\u201d.Physical Reports, Volume 486, Issue 3\u20135 pp. 75\u2013174\n<https://arxiv.org/abs/0906.0612>"
        }
    },
    {
        "Section ID": "from_dict_of_dicts",
        "Description": [
            "Returns a graph from a dictionary of dictionaries."
        ],
        "Field List": {
            "Parameters:": {
                "d : dictionary of dictionaries": "A dictionary of dictionaries adjacency representation.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated.",
                "multigraph_input : bool (default False)": "When True, the dictdis assumed\nto be a dict-of-dict-of-dict-of-dict structure keyed by\nnode to neighbor to edge keys to edge data for multi-edges.\nOtherwise this routine assumes dict-of-dict-of-dict keyed by\nnode to neighbor to edge data."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "dod={0:{1:{\"weight\":1}}}# single edge (0,1)\nG=nx.from_dict_of_dicts(dod)\nor\nG=nx.Graph(dod)# use Graph constructor"
        }
    },
    {
        "Section ID": "max_weight_matching",
        "Description": [
            "Compute a maximum-weighted matching of G.",
            "A matching is a subset of edges in which no node occurs more than once.\nThe weight of a matching is the sum of the weights of its edges.\nA maximal matching cannot add more edges and still be a matching.\nThe cardinality of a matching is the number of matched edges."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected graph",
                "maxcardinality: bool, optional (default=False)": "If maxcardinality is True, compute the maximum-cardinality matching\nwith maximum weight among all maximum-cardinality matchings.",
                "weight: string, optional (default=\u2019weight\u2019)": "Edge data key corresponding to the edge weight.\nIf key not found, uses 1 as weight."
            },
            "Returns:": {
                "matching : set": "A maximal matching of the graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "If G has edges with weight attributes the edge data are used as\nweight values else the weights are assumed to be 1. This function takes time O(number_of_nodes ** 3). If all edge weights are integers, the algorithm uses only integer\ncomputations.  If floating point weights are used, the algorithm\ncould return a slightly suboptimal matching due to numeric\nprecision errors. This method is based on the \u201cblossom\u201d method for finding augmenting\npaths and the \u201cprimal-dual\u201d method for finding a matching of maximum\nweight, both methods invented by Jack Edmonds [1] . Bipartite graphs can also be matched using the functions present in networkx.algorithms.bipartite.matching .",
            "References": "[1]\u201cEfficient Algorithms for Finding Maximum Matching in Graphs\u201d,\nZvi Galil, ACM Computing Surveys, 1986.",
            "Examples": "G=nx.Graph()\nedges=[(1,2,6),(1,3,2),(2,3,1),(2,4,7),(3,5,9),(4,5,3)]\nG.add_weighted_edges_from(edges)\nsorted(nx.max_weight_matching(G))\n# [(2, 4), (5, 3)]"
        }
    },
    {
        "Section ID": "treewidth_min_fill_in",
        "Description": [
            "Returns a treewidth decomposition using the Minimum Fill-in heuristic.",
            "The heuristic chooses a node from the graph, where the number of edges\nadded turning the neighborhood of the chosen node into clique is as\nsmall as possible."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": ""
            },
            "Returns:": {
                "Treewidth decomposition : (int, Graph) tuple": "2-tuple with treewidth and the corresponding decomposed tree."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "is_tournament",
        "Description": [
            "Returns True if and only if G is a tournament.",
            "A tournament is a directed graph, with neither self-loops nor\nmulti-edges, in which there is exactly one directed edge joining\neach pair of distinct nodes."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A directed graph representing a tournament."
            },
            "Returns:": {
                "bool": "Whether the given graph is a tournament graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Some definitions require a self-loop on each node, but that is not\nthe convention used here.",
            "Examples": "G=nx.DiGraph([(0,1),(1,2),(2,0)])\nnx.is_tournament(G)\n# True"
        }
    },
    {
        "Section ID": "attracting_components",
        "Description": [
            "Generates the attracting components in G .",
            "An attracting component in a directed graph G is a strongly connected\ncomponent with the property that a random walker on the graph will never\nleave the component, once it enters the component.",
            "The nodes in attracting components can also be thought of as recurrent\nnodes.  If a random walker enters the attractor containing the node, then\nthe node will be visited infinitely often.",
            "To obtain induced subgraphs on each component use: (G.subgraph(c).copy()forcinattracting_components(G))"
        ],
        "Field List": {
            "Parameters:": {
                "G : DiGraph, MultiDiGraph": "The graph to be analyzed."
            },
            "Returns:": {
                "attractors : generator of sets": "A generator of sets of nodes, one for each attracting component of G."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the input graph is undirected."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "connected_double_edge_swap",
        "Description": [
            "Attempts the specified number of double-edge swaps in the graph G .",
            "A double-edge swap removes two randomly chosen edges (u,v) and (x,y) and creates the new edges (u,x) and (v,y) :",
            "If either (u,x) or (v,y) already exist, then no swap is performed\nso the actual number of swapped edges is always at most  nswap ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "An undirected graph",
                "nswap : integer (optional, default=1)": "Number of double-edge swaps to perform",
                "_window_threshold : integer": "The window size below which connectedness of the graph will be checked\nafter each swap.The \u201cwindow\u201d in this function is a dynamically updated integer that\nrepresents the number of swap attempts to make before checking if the\ngraph remains connected. It is an optimization used to decrease the\nrunning time of the algorithm in exchange for increased complexity of\nimplementation.If the window size is below this threshold, then the algorithm checks\nafter each swap if the graph remains connected by checking if there is a\npath joining the two nodes whose edge was just removed. If the window\nsize is above this threshold, then the algorithm performs do all the\nswaps in the window and only then check if the graph is still connected.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "int": "The number of successful swaps"
            },
            "Raises:": {
                "NetworkXError": "If the input graph is not connected, or if the graph has fewer than four\nnodes."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The initial graph G must be connected, and the resulting graph is\nconnected. The graph G is modified in place.",
            "References": "[1]C. Gkantsidis and M. Mihail and E. Zegura,\nThe Markov chain simulation method for generating connected\npower law random graphs, 2003.http://citeseer.ist.psu.edu/gkantsidis03markov.html"
        }
    },
    {
        "Section ID": "all_node_cuts",
        "Description": [
            "Returns all minimum k cutsets of an undirected graph G.",
            "This implementation is based on Kanevsky\u2019s algorithm [1] for finding all\nminimum-size node cut-sets of an undirected graph G; ie the set (or sets)\nof nodes of cardinality equal to the node connectivity of G. Thus if\nremoved, would break G into two or more connected components."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected graph",
                "k : Integer": "Node connectivity of the input graph. If k is None, then it is\ncomputed. Default value: None.",
                "flow_func : function": "Function to perform the underlying flow computations. Default value isedmonds_karp(). This function performs\nbetter in sparse graphs with right tailed degree distributions.shortest_augmenting_path()will\nperform better in denser graphs."
            },
            "Returns:": {
                "cuts : a generator of node cutsets": "Each node cutset has cardinality equal to the node connectivity of\nthe input graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This implementation is based on the sequential algorithm for finding all\nminimum-size separating vertex sets in a graph [1] . The main idea is to\ncompute minimum cuts using local maximum flow computations among a set\nof nodes of highest degree and all other non-adjacent nodes in the Graph.\nOnce we find a minimum cut, we add an edge between the high degree\nnode and the target node of the local maximum flow computation to make\nsure that we will not find that minimum cut again.",
            "References": "[1](1,2)Kanevsky, A. (1993). Finding all minimum-size separating vertex\nsets in a graph. Networks 23(6), 533\u2013541.http://onlinelibrary.wiley.com/doi/10.1002/net.3230230604/abstract",
            "Examples": "# A two-dimensional grid graph has 4 cutsets of cardinality 2\nG=nx.grid_2d_graph(5,5)\ncutsets=list(nx.all_node_cuts(G))\nlen(cutsets)\n# 4\nall(2==len(cutset)forcutsetincutsets)\n# True\nnx.node_connectivity(G)\n# 2"
        }
    },
    {
        "Section ID": "karate_club_graph",
        "Description": [
            "Returns Zachary\u2019s Karate Club graph.",
            "Each node in the returned graph has a node attribute \u2018club\u2019 that\nindicates the name of the club to which the member represented by that node\nbelongs, either \u2018Mr. Hi\u2019 or \u2018Officer\u2019. Each edge has a weight based on the\nnumber of contexts in which that edge\u2019s incident node members interacted.",
            "References",
            "Examples",
            "To get the name of the club to which a node belongs:"
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Zachary, Wayne W.\n\u201cAn Information Flow Model for Conflict and Fission in Small Groups.\u201dJournal of Anthropological Research, 33, 452\u2013473, (1977).",
            "Examples": "To get the name of the club to which a node belongs:\nG=nx.karate_club_graph()\nG.nodes[5][\"club\"]\n# 'Mr. Hi'\nG.nodes[9][\"club\"]\n# 'Officer'"
        }
    },
    {
        "Section ID": "is_dominating_set",
        "Description": [
            "Checks if nbunch is a dominating set for G .",
            "A dominating set for a graph with node set V is a subset D of V such that every node not in D is adjacent to at least one\nmember of D  [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "nbunch : iterable": "An iterable of nodes in the graphG."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://en.wikipedia.org/wiki/Dominating_set"
        }
    },
    {
        "Section ID": "girth",
        "Description": [
            "Returns the girth of the graph.",
            "The girth of a graph is the length of its shortest cycle, or infinity if\nthe graph is acyclic. The algorithm follows the description given on the\nWikipedia page [1] , and runs in time O(mn) on a graph with m edges and n\nnodes."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": ""
            },
            "Returns:": {
                "int or math.inf": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Wikipedia: Girth",
            "Examples": "All examples below (except P_5) can easily be checked using Wikipedia,\nwhich has a page for each of these famous graphs.\nnx.girth(nx.chvatal_graph())\n# 4\nnx.girth(nx.tutte_graph())\n# 4\nnx.girth(nx.petersen_graph())\n# 5\nnx.girth(nx.heawood_graph())\n# 6\nnx.girth(nx.pappus_graph())\n# 6\nnx.girth(nx.path_graph(5))\n# inf"
        }
    },
    {
        "Section ID": "subgraph_view",
        "Description": [
            "View of G applying a filter on nodes and edges.",
            "subgraph_view provides a read-only view of the input graph that excludes\nnodes and edges based on the outcome of two filter functions filter_node and filter_edge .",
            "The filter_node function takes one argument \u2014 the node \u2014 and returns True if the node should be included in the subgraph, and False if it\nshould not be included.",
            "The filter_edge function takes two (or three arguments if G is a\nmulti-graph) \u2014 the nodes describing an edge, plus the edge-key if\nparallel edges are possible \u2014 and returns True if the edge should be\nincluded in the subgraph, and False if it should not be included.",
            "Both node and edge filter functions are called on graph elements as they\nare queried, meaning there is no up-front cost to creating the view."
        ],
        "Field List": {
            "Parameters:": {
                "G : networkx.Graph": "A directed/undirected graph/multigraph",
                "filter_node : callable, optional": "A function taking a node as input, which returnsTrueif the node\nshould appear in the view.",
                "filter_edge : callable, optional": "A function taking as input the two nodes describing an edge (plus the\nedge-key ifGis a multi-graph), which returnsTrueif the edge\nshould appear in the view."
            },
            "Returns:": {
                "graph : networkx.Graph": "A read-only graph view of the input graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.path_graph(6)\nFilter functions operate on the node, and returnTrueif the node should\nappear in the view:\ndeffilter_node(n1):\nreturnn1!=5\nview=nx.subgraph_view(G,filter_node=filter_node)\nview.nodes()\n# NodeView((0, 1, 2, 3, 4))\nWe can use a closure pattern to filter graph elements based on additional\ndata \u2014 for example, filtering on edge data attached to the graph:\nG[3][4][\"cross_me\"]=False\ndeffilter_edge(n1,n2):\nreturnG[n1][n2].get(\"cross_me\",True)\nview=nx.subgraph_view(G,filter_edge=filter_edge)\nview.edges()\n# EdgeView([(0, 1), (1, 2), (2, 3), (4, 5)])\nview=nx.subgraph_view(\nG,\nfilter_node=filter_node,\nfilter_edge=filter_edge,\n)\nview.nodes()\n# NodeView((0, 1, 2, 3, 4))\nview.edges()\n# EdgeView([(0, 1), (1, 2), (2, 3)])"
        }
    },
    {
        "Section ID": "is_kl_connected",
        "Description": [
            "Returns True if and only if G is locally (k,l) -connected.",
            "A graph is locally (k,l) -connected if for each edge (u,v) in the\ngraph there are at least l edge-disjoint paths of length at most k joining u to v ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "The graph to test for local(k,l)-connectedness.",
                "k : integer": "The maximum length of paths to consider. A higher number means a looser\nconnectivity requirement.",
                "l : integer": "The number of edge-disjoint paths. A higher number means a stricter\nconnectivity requirement.",
                "low_memory : bool": "If this is True, this function uses an algorithm that uses slightly\nmore time but less memory."
            },
            "Returns:": {
                "bool": "Whether the graph is locally(k,l)-connected subgraph."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Chung, Fan and Linyuan Lu. \u201cThe Small World Phenomenon in Hybrid\nPower Law Graphs.\u201dComplex Networks. Springer Berlin Heidelberg,\n2004. 89\u2013104."
        }
    },
    {
        "Section ID": "pagerank",
        "Description": [
            "Returns the PageRank of the nodes in the graph.",
            "PageRank computes a ranking of the nodes in the graph G based on\nthe structure of the incoming links. It was originally designed as\nan algorithm to rank web pages."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.  Undirected graphs will be converted to a directed\ngraph with two directed edges for each undirected edge.",
                "alpha : float, optional": "Damping parameter for PageRank, default=0.85.",
                "personalization: dict, optional": "The \u201cpersonalization vector\u201d consisting of a dictionary with a\nkey some subset of graph nodes and personalization value each of those.\nAt least one personalization value must be non-zero.\nIf not specified, a nodes personalization value will be zero.\nBy default, a uniform distribution is used.",
                "max_iter : integer, optional": "Maximum number of iterations in power method eigenvalue solver.",
                "tol : float, optional": "Error tolerance used to check convergence in power method solver.\nThe iteration will stop after a tolerance oflen(G)*tolis reached.",
                "nstart : dictionary, optional": "Starting value of PageRank iteration for each node.",
                "weight : key, optional": "Edge data key to use as weight.  If None weights are set to 1.",
                "dangling: dict, optional": "The outedges to be assigned to any \u201cdangling\u201d nodes, i.e., nodes without\nany outedges. The dict key is the node the outedge points to and the dict\nvalue is the weight of that outedge. By default, dangling nodes are given\noutedges according to the personalization vector (uniform if not\nspecified). This must be selected to result in an irreducible transition\nmatrix (see notes under google_matrix). It may be common to have the\ndangling dict to be the same as the personalization dict."
            },
            "Returns:": {
                "pagerank : dictionary": "Dictionary of nodes with PageRank as value"
            },
            "Raises:": {
                "PowerIterationFailedConvergence": "If the algorithm fails to converge to the specified tolerance\nwithin the specified number of iterations of the power iteration\nmethod."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The eigenvector calculation is done by the power iteration method\nand has no guarantee of convergence.  The iteration will stop after\nan error tolerance of len(G)*tol has been reached. If the\nnumber of iterations exceed max_iter , a networkx.exception.PowerIterationFailedConvergence exception\nis raised. The PageRank algorithm was designed for directed graphs but this\nalgorithm does not check if the input graph is directed and will\nexecute on undirected graphs by converting each edge in the\ndirected graph to two edges.",
            "References": "[1]A. Langville and C. Meyer,\n\u201cA survey of eigenvector methods of web information retrieval.\u201dhttp://citeseer.ist.psu.edu/713792.html  [2]Page, Lawrence; Brin, Sergey; Motwani, Rajeev and Winograd, Terry,\nThe PageRank citation ranking: Bringing order to the Web. 1999http://dbpubs.stanford.edu:8090/pub/showDoc.Fulltext?lang=en&doc=1999-66&format=pdf",
            "Examples": "G=nx.DiGraph(nx.path_graph(4))\npr=nx.pagerank(G,alpha=0.9)"
        }
    },
    {
        "Section ID": "node_clique_number",
        "Description": [
            "Returns the size of the largest maximal clique containing each given node.",
            "Returns a single or list depending on input nodes.\nAn optional list of cliques can be input if already computed."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "An undirected graph.",
                "cliques : list, optional (default=None)": "A list of cliques, each of which is itself a list of nodes.\nIf not specified, the list of all cliques will be computed\nusingfind_cliques()."
            },
            "Returns:": {
                "int or dict": "Ifnodesis a single node, returns the size of the\nlargest maximal clique inGcontaining that node.\nOtherwise return a dict keyed by node to the size\nof the largest maximal clique containing that node."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "barabasi_albert_graph",
        "Description": [
            "Returns a random graph using Barab\u00e1si\u2013Albert preferential attachment",
            "A graph of \\(n\\) nodes is grown by attaching new nodes each with \\(m\\) edges that are preferentially attached to existing nodes with high degree."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "Number of nodes",
                "m : int": "Number of edges to attach from a new node to existing nodes",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "initial_graph : Graph or None (default)": "Initial network for Barab\u00e1si\u2013Albert algorithm.\nIt should be a connected graph for most use cases.\nA copy ofinitial_graphis used.\nIf None, starts from a star graph on (m+1) nodes."
            },
            "Returns:": {
                "G : Graph": ""
            },
            "Raises:": {
                "NetworkXError": "Ifmdoes not satisfy1<=m<n, or\nthe initial graph number of nodes m0 does not satisfym<=m0<=n."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]A. L. Barab\u00e1si and R. Albert \u201cEmergence of scaling in\nrandom networks\u201d, Science 286, pp 509-512, 1999."
        }
    },
    {
        "Section ID": "all_pairs_node_connectivity",
        "Description": [
            "Compute node connectivity between all pairs of nodes of G."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected graph",
                "nbunch: container": "Container of nodes. If provided node connectivity will be computed\nonly over pairs of nodes in nbunch.",
                "flow_func : function": "A function for computing the maximum flow among a pair of nodes.\nThe function has to accept at least three parameters: a Digraph,\na source node, and a target node. And return a residual network\nthat follows NetworkX conventions (seemaximum_flow()for\ndetails). If flow_func is None, the default maximum flow function\n(edmonds_karp()) is used. See below for details. The\nchoice of the default function may change from version\nto version and should not be relied on. Default value: None."
            },
            "Returns:": {
                "all_pairs : dict": "A dictionary with node connectivity between all pairs of nodes\nin G, or in nbunch if provided."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "read_gml",
        "Description": [
            "Read graph in GML format from path ."
        ],
        "Field List": {
            "Parameters:": {
                "path : filename or filehandle": "The filename or filehandle to read from.",
                "label : string, optional": "If not None, the parsed nodes will be renamed according to node\nattributes indicated bylabel. Default value: \u2018label\u2019.",
                "destringizer : callable, optional": "Adestringizerthat recovers values stored as strings in GML. If it\ncannot convert a string to a value, aValueErroris raised. Default\nvalue : None."
            },
            "Returns:": {
                "G : NetworkX graph": "The parsed graph."
            },
            "Raises:": {
                "NetworkXError": "If the input cannot be parsed."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "GML files are stored using a 7-bit ASCII encoding with any extended\nASCII characters (iso8859-1) appearing as HTML character entities.\nWithout specifying a stringizer / destringizer , the code is capable of\nwriting int / float / str / dict / list data as required by the GML\nspecification.  For writing other data types, and for reading data other\nthan str you need to explicitly supply a stringizer / destringizer . For additional documentation on the GML file format, please see the GML url . See the module docstring networkx.readwrite.gml for more details.",
            "Examples": "G=nx.path_graph(4)\nnx.write_gml(G,\"test.gml\")\nGML values are interpreted as strings by default:\nH=nx.read_gml(\"test.gml\")\nH.nodes\n# NodeView(('0', '1', '2', '3'))\nWhen adestringizeris provided, GML values are converted to the provided type.\nFor example, integer nodes can be recovered as shown below:\nJ=nx.read_gml(\"test.gml\",destringizer=int)\nJ.nodes\n# NodeView((0, 1, 2, 3))"
        }
    },
    {
        "Section ID": "from_graph6_bytes",
        "Description": [
            "Read a simple undirected graph in graph6 format from bytes."
        ],
        "Field List": {
            "Parameters:": {
                "bytes_in : bytes": "Data in graph6 format, without a trailing newline."
            },
            "Returns:": {
                "G : Graph": ""
            },
            "Raises:": {
                "NetworkXError": "If bytes_in is unable to be parsed in graph6 format",
                "ValueError": "If any charactercin bytes_in does not satisfy63<=ord(c)<127."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Graph6 specification\n<http://users.cecs.anu.edu.au/~bdm/data/formats.html>",
            "Examples": "G=nx.from_graph6_bytes(b\"A_\")\nsorted(G.edges())\n# [(0, 1)]"
        }
    },
    {
        "Section ID": "lowest_common_ancestor",
        "Description": [
            "Compute the lowest common ancestor of the given pair of nodes."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX directed graph": "",
                "node1, node2 : nodes in the graph.": "",
                "default : object": "Returned if no common ancestor betweennode1andnode2"
            },
            "Returns:": {
                "The lowest common ancestor of node1 and node2,": "",
                "or default if they have no common ancestors.": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.DiGraph()\nnx.add_path(G,(0,1,2,3))\nnx.add_path(G,(0,4,3))\nnx.lowest_common_ancestor(G,2,4)\n# 0"
        }
    },
    {
        "Section ID": "triangles",
        "Description": [
            "Compute the number of triangles.",
            "Finds the number of triangles that include a node as one vertex."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph",
                "nodes : node, iterable of nodes, or None (default=None)": "If a singleton node, return the number of triangles for that node.\nIf an iterable, compute the number of triangles for each of those nodes.\nIfNone(the default) compute the number of triangles for all nodes inG."
            },
            "Returns:": {
                "out : dict or int": "Ifnodesis a container of nodes, returns number of triangles keyed by node (dict).\nIfnodesis a specific node, returns number of triangles for the node (int)."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Self loops are ignored.",
            "Examples": "G=nx.complete_graph(5)\nprint(nx.triangles(G,0))\n# 6\nprint(nx.triangles(G))\n# {0: 6, 1: 6, 2: 6, 3: 6, 4: 6}\nprint(list(nx.triangles(G,[0,1]).values()))\n# [6, 6]"
        }
    },
    {
        "Section ID": "directed_modularity_matrix",
        "Description": [
            "Returns the directed modularity matrix of G.",
            "The modularity matrix is the matrix B = A - <A>, where A is the adjacency\nmatrix and <A> is the expected adjacency matrix, assuming that the graph\nis described by the configuration model.",
            "More specifically, the element B_ij of B is defined as",
            "where \\(k_i^{in}\\) is the in degree of node i, and \\(k_j^{out}\\) is the out degree\nof node j, with m the number of edges in the graph. When weight is set\nto a name of an attribute edge, Aij, k_i, k_j and m are computed using\nits value."
        ],
        "Field List": {
            "Parameters:": {
                "G : DiGraph": "A NetworkX DiGraph",
                "nodelist : list, optional": "The rows and columns are ordered according to the nodes in nodelist.\nIf nodelist is None, then the ordering is produced by G.nodes().",
                "weight : string or None, optional (default=None)": "The edge attribute that holds the numerical value used for\nthe edge weight.  If None then all edge weights are 1."
            },
            "Returns:": {
                "B : Numpy array": "The modularity matrix of G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "NetworkX defines the element A_ij of the adjacency matrix as 1 if there\nis a link going from node i to node j. Leicht and Newman use the opposite\ndefinition. This explains the different expression for B_ij.",
            "References": "[1]E. A. Leicht, M. E. J. Newman,\n\u201cCommunity structure in directed networks\u201d,\nPhys. Rev Lett., vol. 100, no. 11, p. 118703, 2008.",
            "Examples": "G=nx.DiGraph()\nG.add_edges_from(\n(\n(1,2),\n(1,3),\n(3,1),\n(3,2),\n(3,5),\n(4,5),\n(4,6),\n(5,4),\n(5,6),\n(6,4),\n)\n)\nB=nx.directed_modularity_matrix(G)"
        }
    },
    {
        "Section ID": "multi_source_dijkstra",
        "Description": [
            "Find shortest weighted paths and lengths from a given set of\nsource nodes.",
            "Uses Dijkstra\u2019s algorithm to compute the shortest paths and lengths\nbetween one of the source nodes and the given target , or all other\nreachable nodes if not specified, for a weighted graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "sources : non-empty set of nodes": "Starting nodes for paths. If this is just a set containing a\nsingle node, then all paths computed by this function will start\nfrom that node. If there are two or more nodes in the set, the\ncomputed paths may begin from any one of the start nodes.",
                "target : node label, optional": "Ending node for path",
                "cutoff : integer or float, optional": "Length (sum of edge weights) at which the search is stopped.\nIf cutoff is provided, only return paths with summed weight <= cutoff.",
                "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge."
            },
            "Returns:": {
                "distance, path : pair of dictionaries, or numeric and list": "If target is None, returns a tuple of two dictionaries keyed by node.\nThe first dictionary stores distance from one of the source nodes.\nThe second stores the path from one of the sources to that node.\nIf target is not None, returns a tuple of (distance, path) where\ndistance is the distance from source to target and path is a list\nrepresenting the path from source to target."
            },
            "Raises:": {
                "ValueError": "Ifsourcesis empty.",
                "NodeNotFound": "If any ofsourcesis not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The weight function can be used to hide edges by returning None.\nSo weight=lambdau,v,d:1ifd['color']==\"red\"elseNone will find the shortest red path. Based on the Python cookbook recipe (119466) at https://code.activestate.com/recipes/119466/ This algorithm is not guaranteed to work if edge weights\nare negative or are floating point numbers\n(overflows and roundoff errors can cause problems).",
            "Examples": "G=nx.path_graph(5)\nlength,path=nx.multi_source_dijkstra(G,{0,4})\nfornodein[0,1,2,3,4]:\nprint(f\"{node}: {length[node]}\")\n# 0: 0\n# 1: 1\n# 2: 2\n# 3: 1\n# 4: 0\npath[1]\n# [0, 1]\npath[3]\n# [4, 3]\nlength,path=nx.multi_source_dijkstra(G,{0,4},1)\nlength\n# 1\npath\n# [0, 1]"
        }
    },
    {
        "Section ID": "full_join",
        "Description": [
            "Returns the full join of graphs G and H.",
            "Full join is the union of G and H in which all edges between\nG and H are added.\nThe node sets of G and H must be disjoint,\notherwise an exception is raised."
        ],
        "Field List": {
            "Parameters:": {
                "G, H : graph": "A NetworkX graph",
                "rename : tuple , default=(None, None)": "Node names of G and H can be changed by specifying the tuple\nrename=(\u2018G-\u2018,\u2019H-\u2019) (for example).  Node \u201cu\u201d in G is then renamed\n\u201cG-u\u201d and \u201cv\u201d in H is renamed \u201cH-v\u201d."
            },
            "Returns:": {
                "U : The full join graph with the same type as G.": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "It is recommended that G and H be either both directed or both undirected. If G is directed, then edges from G to H are added as well as from H to G. Note that full_join() does not produce parallel edges for MultiGraphs. The full join operation of graphs G and H is the same as getting\ntheir complement, performing a disjoint union, and finally getting\nthe complement of the resulting graph. Graph, edge, and node attributes are propagated from G and H\nto the union graph.  If a graph attribute is present in both\nG and H the value from H is used.",
            "Examples": "G=nx.Graph([(0,1),(0,2)])\nH=nx.Graph([(3,4)])\nR=nx.full_join(G,H,rename=(\"G\",\"H\"))\nR.nodes\n# NodeView(('G0', 'G1', 'G2', 'H3', 'H4'))\nR.edges\n# EdgeView([('G0', 'G1'), ('G0', 'G2'), ('G0', 'H3'), ('G0', 'H4'), ('G1', 'H3'), ('G1', 'H4'), ('G2', 'H3'), ('G2', 'H4'), ('H3', 'H4')])"
        }
    },
    {
        "Section ID": "simple_cycles",
        "Description": [
            "Find simple cycles (elementary circuits) of a graph.",
            "A simplecycle , or elementarycircuit , is a closed path where\nno node appears twice.  In a directed graph, two simple cycles are distinct\nif they are not cyclic permutations of each other.  In an undirected graph,\ntwo simple cycles are distinct if they are not cyclic permutations of each\nother nor of the other\u2019s reversal.",
            "Optionally, the cycles are bounded in length.  In the unbounded case, we use\na nonrecursive, iterator/generator version of Johnson\u2019s algorithm [1] .  In\nthe bounded case, we use a version of the algorithm of Gupta and\nSuzumura[R155c03fc9e2e-2]_. There may be better algorithms for some cases [3]  [4]  [5] .",
            "The algorithms of Johnson, and Gupta and Suzumura, are enhanced by some\nwell-known preprocessing techniques.  When G is directed, we restrict our\nattention to strongly connected components of G, generate all simple cycles\ncontaining a certain node, remove that node, and further decompose the\nremainder into strongly connected components.  When G is undirected, we\nrestrict our attention to biconnected components, generate all simple cycles\ncontaining a particular edge, remove that edge, and further decompose the\nremainder into biconnected components.",
            "Note that multigraphs are supported by this function \u2013 and in undirected\nmultigraphs, a pair of parallel edges is considered a cycle of length 2.\nLikewise, self-loops are considered to be cycles of length 1.  We define\ncycles as sequences of nodes; so the presence of loops and parallel edges\ndoes not change the number of simple cycles in a graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX DiGraph": "A directed graph",
                "length_bound : int or None, optional (default=None)": "If length_bound is an int, generate all simple cycles of G with length at\nmost length_bound.  Otherwise, generate all simple cycles of G."
            },
            "Yields:": {
                "list of nodes": "Each cycle is represented by a list of nodes along the cycle."
            },
            "Raises:": {
                "ValueError": "when length_bound < 0."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "When length_bound is None, the time complexity is \\(O((n+e)(c+1))\\) for \\(n\\) nodes, \\(e\\) edges and \\(c\\) simple circuits.  Otherwise, when length_bound > 1,\nthe time complexity is \\(O((c+n)(k-1)d^k)\\) where \\(d\\) is the average degree of\nthe nodes of G and \\(k\\) = length_bound.",
            "References": "[1]Finding all the elementary circuits of a directed graph.\nD. B. Johnson, SIAM Journal on Computing 4, no. 1, 77-84, 1975.https://doi.org/10.1137/0204007  [2]Finding All Bounded-Length Simple Cycles in a Directed Graph\nA. Gupta and T. Suzumurahttps://arxiv.org/abs/2105.10094  [3]Enumerating the cycles of a digraph: a new preprocessing strategy.\nG. Loizou and P. Thanish, Information Sciences, v. 27, 163-182, 1982.  [4]A search strategy for the elementary cycles of a directed graph.\nJ.L. Szwarcfiter and P.E. Lauer, BIT NUMERICAL MATHEMATICS,\nv. 16, no. 2, 192-204, 1976.  [5]Optimal Listing of Cycles and st-Paths in Undirected Graphs\nR. Ferreira and R. Grossi and A. Marino and N. Pisanti and R. Rizzi and\nG. Sacomotohttps://arxiv.org/abs/1205.2766",
            "Examples": "edges=[(0,0),(0,1),(0,2),(1,2),(2,0),(2,1),(2,2)]\nG=nx.DiGraph(edges)\nsorted(nx.simple_cycles(G))\n# [[0], [0, 1, 2], [0, 2], [1, 2], [2]]\nTo filter the cycles so that they don\u2019t include certain nodes or edges,\ncopy your graph and eliminate those nodes or edges before calling.\nFor example, to exclude self-loops from the above example:\nH=G.copy()\nH.remove_edges_from(nx.selfloop_edges(G))\nsorted(nx.simple_cycles(H))\n# [[0, 1, 2], [0, 2], [1, 2]]"
        }
    },
    {
        "Section ID": "compute_v_structures",
        "Description": [
            "Iterate through the graph to compute all v-structures.",
            "V-structures are triples in the directed graph where\ntwo parent nodes point to the same child and the two parent nodes\nare not adjacent."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx DiGraph."
            },
            "Returns:": {
                "vstructs : iterator of tuples": "The v structures within the graph. Each v structure is a 3-tuple with the\nparent, collider, and other parent."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Wikipedia: Collider in causal graphs",
            "Examples": "G=nx.DiGraph()\nG.add_edges_from([(1,2),(0,5),(3,1),(2,4),(3,1),(4,5),(1,5)])\nsorted(nx.compute_v_structures(G))\n# [(0, 5, 1), (0, 5, 4), (1, 5, 4)]"
        }
    },
    {
        "Section ID": "path_weight",
        "Description": [
            "Returns total cost associated with specified path and weight"
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.",
                "path: list": "A list of node labels which defines the path to traverse",
                "weight: string": "A string indicating which edge attribute to use for path cost"
            },
            "Returns:": {
                "cost: int or float": "An integer or a float representing the total cost with respect to the\nspecified weight of the specified path"
            },
            "Raises:": {
                "NetworkXNoPath": "If the specified edge does not exist."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "is_simple_path",
        "Description": [
            "Returns True if and only if nodes form a simple path in G .",
            "A simple path in a graph is a nonempty sequence of nodes in which\nno node appears more than once in the sequence, and each adjacent\npair of nodes in the sequence is adjacent in the graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.",
                "nodes : list": "A list of one or more nodes in the graphG."
            },
            "Returns:": {
                "bool": "Whether the given list of nodes represents a simple path inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "An empty list of nodes is not a path but a list of one node is a\npath. Here\u2019s an explanation why. This function operates on node paths . One could also consider edge paths . There is a bijection between node paths and edge\npaths. The length of a path is the number of edges in the path, so a list\nof nodes of length n corresponds to a path of length n - 1.\nThus the smallest edge path would be a list of zero edges, the empty\npath. This corresponds to a list of one node. To convert between a node path and an edge path, you can use code\nlike the following:",
            "Examples": "G=nx.cycle_graph(4)\nnx.is_simple_path(G,[2,3,0])\n# True\nnx.is_simple_path(G,[0,2])\n# False"
        }
    },
    {
        "Section ID": "is_strongly_connected",
        "Description": [
            "Test directed graph for strong connectivity.",
            "A directed graph is strongly connected if and only if every vertex in\nthe graph is reachable from every other vertex."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "A directed graph."
            },
            "Returns:": {
                "connected : bool": "True if the graph is strongly connected, False otherwise."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For directed graphs only.",
            "Examples": "G=nx.DiGraph([(0,1),(1,2),(2,3),(3,0),(2,4),(4,2)])\nnx.is_strongly_connected(G)\n# True\nG.remove_edge(2,3)\nnx.is_strongly_connected(G)\n# False"
        }
    },
    {
        "Section ID": "multi_source_dijkstra_path",
        "Description": [
            "Find shortest weighted paths in G from a given set of source\nnodes.",
            "Compute shortest path between any of the source nodes and all other\nreachable nodes for a weighted graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "sources : non-empty set of nodes": "Starting nodes for paths. If this is just a set containing a\nsingle node, then all paths computed by this function will start\nfrom that node. If there are two or more nodes in the set, the\ncomputed paths may begin from any one of the start nodes.",
                "cutoff : integer or float, optional": "Length (sum of edge weights) at which the search is stopped.\nIf cutoff is provided, only return paths with summed weight <= cutoff.",
                "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge."
            },
            "Returns:": {
                "paths : dictionary": "Dictionary of shortest paths keyed by target."
            },
            "Raises:": {
                "ValueError": "Ifsourcesis empty.",
                "NodeNotFound": "If any ofsourcesis not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The weight function can be used to hide edges by returning None.\nSo weight=lambdau,v,d:1ifd['color']==\"red\"elseNone will find the shortest red path.",
            "Examples": "G=nx.path_graph(5)\npath=nx.multi_source_dijkstra_path(G,{0,4})\npath[1]\n# [0, 1]\npath[3]\n# [4, 3]"
        }
    },
    {
        "Section ID": "enumerate_all_cliques",
        "Description": [
            "Returns all cliques in an undirected graph.",
            "This function returns an iterator over cliques, each of which is a\nlist of nodes. The iteration is ordered by cardinality of the\ncliques: first all cliques of size one, then all cliques of size\ntwo, etc."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "An undirected graph."
            },
            "Returns:": {
                "iterator": "An iterator over cliques, each of which is a list of nodes inG. The cliques are ordered according to size."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "To obtain a list of all cliques, use list(enumerate_all_cliques(G)) . However, be aware that in the\nworst-case, the length of this list can be exponential in the number\nof nodes in the graph (for example, when the graph is the complete\ngraph). This function avoids storing all cliques in memory by only\nkeeping current candidate node lists in memory during its search. The implementation is adapted from the algorithm by Zhang, et\nal. (2005) [1] to output all cliques discovered. This algorithm ignores self-loops and parallel edges, since cliques\nare not conventionally defined with such edges.",
            "References": "[1]Yun Zhang, Abu-Khzam, F.N., Baldwin, N.E., Chesler, E.J.,\nLangston, M.A., Samatova, N.F.,\n\u201cGenome-Scale Computational Approaches to Memory-Intensive\nApplications in Systems Biology\u201d.Supercomputing, 2005. Proceedings of the ACM/IEEE SC 2005\nConference, pp. 12, 12\u201318 Nov. 2005.\n<https://doi.org/10.1109/SC.2005.29>."
        }
    },
    {
        "Section ID": "weighted_choice",
        "Description": [
            "Returns a single element from a weighted sample.",
            "The input is a dictionary of items with weights as values."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "contracted_edge",
        "Description": [
            "Returns the graph that results from contracting the specified edge.",
            "Edge contraction identifies the two endpoints of the edge as a single node\nincident to any edge that was incident to the original two nodes. A graph\nthat results from edge contraction is called a minor of the original\ngraph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "The graph whose edge will be contracted.",
                "edge : tuple": "Must be a pair of nodes inG.",
                "self_loops : Boolean": "If this is True, any edges (includingedge) joining the\nendpoints ofedgeinGbecome self-loops on the new node in the\nreturned graph.",
                "copy : Boolean (default True)": "If this is True, a the contraction will be performed on a copy ofG,\notherwise the contraction will happen in place."
            },
            "Returns:": {
                "Networkx graph": "A new graph object of the same type asG(leavingGunmodified)\nwith endpoints ofedgeidentified in a single node. The right node\nofedgewill be merged into the left one, so only the left one will\nappear in the returned graph."
            },
            "Raises:": {
                "ValueError": "Ifedgeis not an edge inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "Attempting to contract two nonadjacent nodes yields an error:\nG=nx.cycle_graph(4)\nnx.contracted_edge(G,(1,3))Traceback (most recent call last):  ...ValueErrorEdge (1, 3) does not exist in graph G; cannot contract it\nContracting two adjacent nodes in the cycle graph onnnodes yields the\ncycle graph onn - 1nodes:\nC5=nx.cycle_graph(5)\nC4=nx.cycle_graph(4)\nM=nx.contracted_edge(C5,(0,1),self_loops=False)\nnx.is_isomorphic(M,C4)\n# True"
        }
    },
    {
        "Section ID": "hopcroft_karp_matching",
        "Description": [
            "Returns the maximum cardinality matching of the bipartite graph G .",
            "A matching is a set of edges that do not share any nodes. A maximum\ncardinality matching is a matching with the most edges possible. It\nis not always unique. Finding a matching in a bipartite graph can be\ntreated as a networkx flow problem.",
            "The functions hopcroft_karp_matching and maximum_matching are aliases of the same function."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected bipartite graph",
                "top_nodes : container of nodes": "Container with all nodes in one bipartite node set. If not supplied\nit will be computed. But if more than one solution exists an exception\nwill be raised."
            },
            "Returns:": {
                "matches : dictionary": "The matching is returned as a dictionary,matches, such thatmatches[v]==wif nodevis matched to nodew. Unmatched\nnodes do not occur as a key inmatches."
            },
            "Raises:": {
                "AmbiguousSolution": "Raised if the input bipartite graph is disconnected and no container\nwith all nodes in one bipartite set is provided. When determining\nthe nodes in each bipartite set more than one valid solution is\npossible if the input graph is disconnected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This function is implemented with the Hopcroft\u2013Karp matching algorithm for\nbipartite graphs. See bipartitedocumentation for further details on how bipartite graphs are handled in NetworkX.",
            "References": "[1]John E. Hopcroft and Richard M. Karp. \u201cAn n^{5 / 2} Algorithm for\nMaximum Matchings in Bipartite Graphs\u201d In:SIAM Journal of Computing2.4 (1973), pp. 225\u2013231. <https://doi.org/10.1137/0202019>."
        }
    },
    {
        "Section ID": "lukes_partitioning",
        "Description": [
            "Optimal partitioning of a weighted tree using the Lukes algorithm.",
            "This algorithm partitions a connected, acyclic graph featuring integer\nnode weights and float edge weights. The resulting clusters are such\nthat the total weight of the nodes in each cluster does not exceed\nmax_size and that the weight of the edges that are cut by the partition\nis minimum. The algorithm is based on [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "max_size : int": "Maximum weight a partition can have in terms of sum of\nnode_weight for all nodes in the partition",
                "edge_weight : key": "Edge data key to use as weight. If None, the weights are all\nset to one.",
                "node_weight : key": "Node data key to use as weight. If None, the weights are all\nset to one. The data must be int."
            },
            "Returns:": {
                "partition : list": "A list of sets of nodes representing the clusters of the\npartition."
            },
            "Raises:": {
                "NotATree": "If G is not a tree.",
                "TypeError": "If any of the values of node_weight is not int."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Lukes, J. A. (1974).\n\u201cEfficient Algorithm for the Partitioning of Trees.\u201d\nIBM Journal of Research and Development, 18(3), 217\u2013224."
        }
    },
    {
        "Section ID": "ring_of_cliques",
        "Description": [
            "Defines a \u201cring of cliques\u201d graph.",
            "A ring of cliques graph is consisting of cliques, connected through single\nlinks. Each clique is a complete graph."
        ],
        "Field List": {
            "Parameters:": {
                "num_cliques : int": "Number of cliques",
                "clique_size : int": "Size of cliques"
            },
            "Returns:": {
                "G : NetworkX Graph": "ring of cliques graph"
            },
            "Raises:": {
                "NetworkXError": "If the number of cliques is lower than 2 or\nif the size of cliques is smaller than 2."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The connected_caveman_graph graph removes a link from each clique to\nconnect it with the next clique. Instead, the ring_of_cliques graph\nsimply adds the link without removing any link from the cliques.",
            "Examples": "G=nx.ring_of_cliques(8,4)"
        }
    },
    {
        "Section ID": "all_shortest_paths",
        "Description": [
            "Compute all shortest simple paths in the graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node": "Starting node for path.",
                "target : node": "Ending node for path.",
                "weight : None, string or function, optional (default = None)": "If None, every edge has weight/distance/cost 1.\nIf a string, use this edge attribute as the edge weight.\nAny edge attribute not present defaults to 1.\nIf this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly\nthree positional arguments: the two endpoints of an edge and\nthe dictionary of edge attributes for that edge.\nThe function must return a number.",
                "method : string, optional (default = \u2018dijkstra\u2019)": "The algorithm to use to compute the path lengths.\nSupported options: \u2018dijkstra\u2019, \u2018bellman-ford\u2019.\nOther inputs produce a ValueError.\nIfweightis None, unweighted graph methods are used, and this\nsuggestion is ignored."
            },
            "Returns:": {
                "paths : generator of lists": "A generator of all paths between source and target."
            },
            "Raises:": {
                "ValueError": "Ifmethodis not among the supported options.",
                "NetworkXNoPath": "Iftargetcannot be reached fromsource."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "There may be many shortest paths between the source and target.  If G\ncontains zero-weight cycles, this function will not produce all shortest\npaths because doing so would produce infinitely many paths of unbounded\nlength \u2013 instead, we only produce the shortest simple paths.",
            "Examples": "G=nx.Graph()\nnx.add_path(G,[0,1,2])\nnx.add_path(G,[0,10,2])\nprint([pforpinnx.all_shortest_paths(G,source=0,target=2)])\n# [[0, 1, 2], [0, 10, 2]]"
        }
    },
    {
        "Section ID": "from_pydot",
        "Description": [
            "Returns a NetworkX graph from a Pydot graph."
        ],
        "Field List": {
            "Parameters:": {
                "P : Pydot graph": "A graph created with Pydot"
            },
            "Returns:": {
                "G : NetworkX multigraph": "A MultiGraph or MultiDiGraph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "K5=nx.complete_graph(5)\nA=nx.nx_pydot.to_pydot(K5)\nG=nx.nx_pydot.from_pydot(A)# return MultiGraph\n# make a Graph instead of MultiGraph\n>>> G = nx.Graph(nx.nx_pydot.from_pydot(A))"
        }
    },
    {
        "Section ID": "nodes_or_number",
        "Description": [
            "Decorator to allow number of nodes or container of nodes.",
            "With this decorator, the specified argument can be either a number or a container\nof nodes. If it is a number, the nodes used are range(n) .\nThis allows nx.complete_graph(50) in place of nx.complete_graph(list(range(50))) .\nAnd it also allows nx.complete_graph(any_list_of_nodes) ."
        ],
        "Field List": {
            "Parameters:": {
                "which_args : string or int or sequence of strings or ints": "If string, the name of the argument to be treated.\nIf int, the index of the argument to be treated.\nIf more than one node argument is allowed, can be a list of locations."
            },
            "Returns:": {
                "_nodes_or_numbers : function": "Function which replaces int args with ranges."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "Decorate functions like this:\n@nodes_or_number(\"nodes\")defempty_graph(nodes):# nodes is converted to a list of nodes@nodes_or_number(0)defempty_graph(nodes):# nodes is converted to a list of nodes@nodes_or_number([\"m1\",\"m2\"])defgrid_2d_graph(m1,m2,periodic=False):# m1 and m2 are each converted to a list of nodes@nodes_or_number([0,1])defgrid_2d_graph(m1,m2,periodic=False):# m1 and m2 are each converted to a list of nodes@nodes_or_number(1)deffull_rary_tree(r,n)# presumably r is a number. It is not handled by this decorator.# n is converted to a list of nodes"
        }
    },
    {
        "Section ID": "all_simple_edge_paths",
        "Description": [
            "Generate lists of edges for all simple paths in G from source to target.",
            "A simple path is a path with no repeated nodes."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node": "Starting node for path",
                "target : nodes": "Single node or iterable of nodes at which to end path",
                "cutoff : integer, optional": "Depth to stop the search. Only paths of length <= cutoff are returned."
            },
            "Returns:": {
                "path_generator: generator": "A generator that produces lists of simple paths.  If there are no paths\nbetween the source and target within the given cutoff the generator\nproduces no output.\nFor multigraphs, the list of edges have elements of the form(u,v,k).\nWherekcorresponds to the edge key."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm uses a modified depth-first search to generate the\npaths [1] .  A single path can be found in \\(O(V+E)\\) time but the\nnumber of simple paths in a graph can be very large, e.g. \\(O(n!)\\) in\nthe complete graph of order \\(n\\) .",
            "References": "[1]R. Sedgewick, \u201cAlgorithms in C, Part 5: Graph Algorithms\u201d,\nAddison Wesley Professional, 3rd ed., 2001.",
            "Examples": "Print the simple path edges of a Graph:\ng=nx.Graph([(1,2),(2,4),(1,3),(3,4)])\nforpathinsorted(nx.all_simple_edge_paths(g,1,4)):\nprint(path)\n# [(1, 2), (2, 4)]\n# [(1, 3), (3, 4)]\nPrint the simple path edges of a MultiGraph. Returned edges come with\ntheir associated keys:\nmg=nx.MultiGraph()\nmg.add_edge(1,2,key=\"k0\")\n# 'k0'\nmg.add_edge(1,2,key=\"k1\")\n# 'k1'\nmg.add_edge(2,3,key=\"k0\")\n# 'k0'\nforpathinsorted(nx.all_simple_edge_paths(mg,1,3)):\nprint(path)\n# [(1, 2, 'k0'), (2, 3, 'k0')]\n# [(1, 2, 'k1'), (2, 3, 'k0')]\nWhensourceis one of the targets, the empty path starting and ending atsourcewithout traversing any edge is considered a valid simple edge path\nand is included in the results:\nG=nx.Graph()\nG.add_node(0)\npaths=list(nx.all_simple_edge_paths(G,0,0))\nforpathinpaths:\nprint(path)\n# []\nlen(paths)\n# 1"
        }
    },
    {
        "Section ID": "convert_node_labels_to_integers",
        "Description": [
            "Returns a copy of the graph G with the nodes relabeled using\nconsecutive integers."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "first_label : int, optional (default=0)": "An integer specifying the starting offset in numbering nodes.\nThe new integer labels are numbered first_label, \u2026, n-1+first_label.",
                "ordering : string": "\u201cdefault\u201d : inherit node ordering from G.nodes()\n\u201csorted\u201d  : inherit node ordering from sorted(G.nodes())\n\u201cincreasing degree\u201d : nodes are sorted by increasing degree\n\u201cdecreasing degree\u201d : nodes are sorted by decreasing degree",
                "label_attribute : string, optional (default=None)": "Name of node attribute to store old label.  If None no attribute\nis created."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Node and edge attribute data are copied to the new (relabeled) graph. There is no guarantee that the relabeling of nodes to integers will\ngive the same two integers for two (even identical graphs).\nUse the ordering argument to try to preserve the order."
        }
    },
    {
        "Section ID": "cut_size",
        "Description": [
            "Returns the size of the cut between two sets of nodes.",
            "A cut is a partition of the nodes of a graph into two sets. The cut size is the sum of the weights of the edges \u201cbetween\u201d the two\nsets of nodes."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "S : collection": "A collection of nodes inG.",
                "T : collection": "A collection of nodes inG. If not specified, this is taken to\nbe the set complement ofS.",
                "weight : object": "Edge attribute key to use as weight. If not specified, edges\nhave weight one."
            },
            "Returns:": {
                "number": "Total weight of all edges from nodes in setSto nodes in\nsetT(and, in the case of directed graphs, all edges from\nnodes inTto nodes inS)."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "In a multigraph, the cut size is the total weight of edges including\nmultiplicity.",
            "Examples": "In the graph with two cliques joined by a single edges, the natural\nbipartition of the graph into two blocks, one for each clique,\nyields a cut of weight one:\nG=nx.barbell_graph(3,0)\nS={0,1,2}\nT={3,4,5}\nnx.cut_size(G,S,T)\n# 1\nEach parallel edge in a multigraph is counted when determining the\ncut size:\nG=nx.MultiGraph([\"ab\",\"ab\"])\nS={\"a\"}\nT={\"b\"}\nnx.cut_size(G,S,T)\n# 2"
        }
    },
    {
        "Section ID": "node_degree_xy",
        "Description": [
            "Generate node degree-degree pairs for edges in G."
        ],
        "Field List": {
            "Parameters:": {
                "G: NetworkX graph": "",
                "x: string (\u2018in\u2019,\u2019out\u2019)": "The degree type for source node (directed graphs only).",
                "y: string (\u2018in\u2019,\u2019out\u2019)": "The degree type for target node (directed graphs only).",
                "weight: string or None, optional (default=None)": "The edge attribute that holds the numerical value used\nas a weight.  If None, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node.",
                "nodes: list or iterable (optional)": "Use only edges that are adjacency to specified nodes.\nThe default is all nodes."
            },
            "Returns:": {
                "(x, y): 2-tuple": "Generates 2-tuple of (degree, degree) values."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For undirected graphs each edge is produced twice, once for each edge\nrepresentation (u, v) and (v, u), with the exception of self-loop edges\nwhich only appear once.",
            "Examples": "G=nx.DiGraph()\nG.add_edge(1,2)\nlist(nx.node_degree_xy(G,x=\"out\",y=\"in\"))\n# [(1, 1)]\nlist(nx.node_degree_xy(G,x=\"in\",y=\"out\"))\n# [(0, 0)]"
        }
    },
    {
        "Section ID": "not_implemented_for",
        "Description": [
            "Decorator to mark algorithms as not implemented"
        ],
        "Field List": {
            "Parameters:": {
                "graph_types : container of strings": "Entries must be one of \u201cdirected\u201d, \u201cundirected\u201d, \u201cmultigraph\u201d, or \u201cgraph\u201d."
            },
            "Returns:": {
                "_require : function": "The decorated function."
            },
            "Raises:": {
                "NetworkXNotImplemented": "",
                "If any of the packages cannot be imported": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Multiple types are joined logically with \u201cand\u201d.\nFor \u201cor\u201d use multiple @not_implemented_for() lines.",
            "Examples": "Decorate functions like this:\n@not_implemented_for(\"directed\")defsp_function(G):pass# rule out MultiDiGraph@not_implemented_for(\"directed\",\"multigraph\")defsp_np_function(G):pass# rule out all except DiGraph@not_implemented_for(\"undirected\")@not_implemented_for(\"multigraph\")defsp_np_function(G):pass"
        }
    },
    {
        "Section ID": "single_target_shortest_path_length",
        "Description": [
            "Compute the shortest path lengths to target from all reachable nodes."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "target : node": "Target node for path",
                "cutoff : integer, optional": "Depth to stop the search. Only paths of length <= cutoff are returned."
            },
            "Returns:": {
                "lengths : iterator": "(source, shortest path length) iterator"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.path_graph(5,create_using=nx.DiGraph())\nlength=dict(nx.single_target_shortest_path_length(G,4))\nlength[0]\n# 4\nfornodeinrange(5):\nprint(f\"{node}: {length[node]}\")\n# 0: 4\n# 1: 3\n# 2: 2\n# 3: 1\n# 4: 0"
        }
    },
    {
        "Section ID": "degree_mixing_dict",
        "Description": [
            "Returns dictionary representation of mixing matrix for degree."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "NetworkX graph object.",
                "x: string (\u2018in\u2019,\u2019out\u2019)": "The degree type for source node (directed graphs only).",
                "y: string (\u2018in\u2019,\u2019out\u2019)": "The degree type for target node (directed graphs only).",
                "weight: string or None, optional (default=None)": "The edge attribute that holds the numerical value used\nas a weight.  If None, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node.",
                "normalized : bool (default=False)": "Return counts if False or probabilities if True."
            },
            "Returns:": {
                "d: dictionary": "Counts or joint probability of occurrence of degree pairs."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "join_trees",
        "Description": [
            "Returns a new rooted tree made by joining rooted_trees",
            "Constructs a new tree by joining each tree in rooted_trees .\nA new root node is added and connected to each of the roots\nof the input trees. While copying the nodes from the trees,\nrelabeling to integers occurs. If the label_attribute is provided,\nthe old node labels will be stored in the new tree under this attribute."
        ],
        "Field List": {
            "Parameters:": {
                "rooted_trees : list": "A list of pairs in which each left element is a NetworkX graph\nobject representing a tree and each right element is the root\nnode of that tree. The nodes of these trees will be relabeled to\nintegers.",
                "label_attribute : str": "If provided, the old node labels will be stored in the new tree\nunder this node attribute. If not provided, the original labels\nof the nodes in the input trees are not stored.",
                "first_label : int, optional (default=0)": "Specifies the label for the new root node. If provided, the root node of the joined tree\nwill have this label. If not provided, the root node will default to a label of 0."
            },
            "Returns:": {
                "NetworkX graph": "The rooted tree resulting from joining the providedrooted_trees. The new tree has a root node\nlabeled as specified byfirst_label(defaulting to 0 if not provided). Subtrees from the inputrooted_treesare attached to this new root node. Each non-root node, if thelabel_attributeis provided, has an attribute that indicates the original label of the node in the input tree."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Trees are stored in NetworkX as NetworkX Graphs. There is no specific\nenforcement of the fact that these are trees. Testing for each tree\ncan be done using networkx.is_tree() . Graph, edge, and node attributes are propagated from the given\nrooted trees to the created tree. If there are any overlapping graph\nattributes, those from later trees will overwrite those from earlier\ntrees in the tuple of positional arguments.",
            "Examples": "Join two full balanced binary trees of heighthto get a full\nbalanced binary tree of depthh+ 1:\nh=4\nleft=nx.balanced_tree(2,h)\nright=nx.balanced_tree(2,h)\njoined_tree=nx.join([(left,0),(right,0)])\nnx.is_isomorphic(joined_tree,nx.balanced_tree(2,h+1))\n# True"
        }
    },
    {
        "Section ID": "closeness_centrality",
        "Description": [
            "Compute the closeness centrality for nodes in a bipartite network.",
            "The closeness of a node is the distance to all other nodes in the\ngraph or in the case that the graph is not connected to all other nodes\nin the connected component containing that node."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A bipartite network",
                "nodes : list or container": "Container with all nodes in one bipartite node set.",
                "normalized : bool, optional": "If True (default) normalize by connected component size."
            },
            "Returns:": {
                "closeness : dictionary": "Dictionary keyed by node with bipartite closeness centrality\nas the value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The nodes input parameter must contain all nodes in one bipartite node set,\nbut the dictionary returned contains all nodes from both node sets.\nSee bipartitedocumentation for further details on how bipartite graphs are handled in NetworkX. Closeness centrality is normalized by the minimum distance possible.\nIn the bipartite case the minimum distance for a node in one bipartite\nnode set is 1 from all nodes in the other node set and 2 from all\nother nodes in its own set [1] . Thus the closeness centrality\nfor node v in the two bipartite sets U with n nodes and V with m nodes is",
            "References": "[1]Borgatti, S.P. and Halgin, D. In press. \u201cAnalyzing Affiliation\nNetworks\u201d. In Carrington, P. and Scott, J. (eds) The Sage Handbook\nof Social Network Analysis. Sage Publications.https://dx.doi.org/10.4135/9781446294413.n28",
            "Examples": "G=nx.wheel_graph(5)\ntop_nodes={0,1,2}\nnx.bipartite.closeness_centrality(G,nodes=top_nodes)\n# {0: 1.5, 1: 1.2, 2: 1.2, 3: 1.0, 4: 1.0}"
        }
    },
    {
        "Section ID": "weisfeiler_lehman_subgraph_hashes",
        "Description": [
            "Return a dictionary of subgraph hashes by node.",
            "Dictionary keys are nodes in G , and values are a list of hashes.\nEach hash corresponds to a subgraph rooted at a given node u in G .\nLists of subgraph hashes are sorted in increasing order of depth from\ntheir root node, with the hash at index i corresponding to a subgraph\nof nodes at most i edges distance from u. Thus, each list will contain iterations elements - a hash for a subgraph at each depth. If include_initial_labels is set to True , each list will additionally\nhave contain a hash of the initial node label (or equivalently a\nsubgraph of depth 0) prepended, totalling iterations+1 elements.",
            "The function iteratively aggregates and hashes neighborhoods of each node.\nThis is achieved for each step by replacing for each node its label from\nthe previous iteration with its hashed 1-hop neighborhood aggregate.\nThe new node label is then appended to a list of node labels for each\nnode.",
            "To aggregate neighborhoods for a node \\(u\\) at each step, all labels of\nnodes adjacent to \\(u\\) are concatenated. If the edge_attr parameter is set,\nlabels for each neighboring node are prefixed with the value of this attribute\nalong the connecting edge from this neighbor to node \\(u\\) . The resulting string\nis then hashed to compress this information into a fixed digest size.",
            "Thus, at the \\(i\\) -th iteration, nodes within \\(i\\) hops influence any given\nhashed node label. We can therefore say that at depth \\(i\\) for node \\(u\\) we have a hash for a subgraph induced by the \\(i\\) -hop neighborhood of \\(u\\) .",
            "The output can be used to to create general Weisfeiler-Lehman graph kernels,\nor generate features for graphs or nodes - for example to generate \u2018words\u2019 in\na graph as seen in the \u2018graph2vec\u2019 algorithm.\nSee [1] & [2] respectively for details.",
            "Hashes are identical for isomorphic subgraphs and there exist strong\nguarantees that non-isomorphic graphs will get different hashes.\nSee [1] for details.",
            "If no node or edge attributes are provided, the degree of each node\nis used as its initial label.\nOtherwise, node and/or edge labels are used to compute the hash."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "The graph to be hashed.\nCan have node and/or edge attributes. Can also have no attributes.",
                "edge_attr : string, optional (default=None)": "The key in edge attribute dictionary to be used for hashing.\nIf None, edge labels are ignored.",
                "node_attr : string, optional (default=None)": "The key in node attribute dictionary to be used for hashing.\nIf None, and no edge_attr given, use the degrees of the nodes as labels.\nIf None, and edge_attr is given, each node starts with an identical label.",
                "iterations : int, optional (default=3)": "Number of neighbor aggregations to perform.\nShould be larger for larger graphs.",
                "digest_size : int, optional (default=16)": "Size (in bits) of blake2b hash digest to use for hashing node labels.\nThe default size is 16 bits.",
                "include_initial_labels : bool, optional (default=False)": "If True, include the hashed initial node label as the first subgraph\nhash for each node."
            },
            "Returns:": {
                "node_subgraph_hashes : dict": "A dictionary with each key given by a node in G, and each value given\nby the subgraph hashes in order of depth from the key node."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "To hash the full graph when subgraph hashes are not needed, use weisfeiler_lehman_graph_hash for efficiency. Similarity between hashes does not imply similarity between graphs.",
            "References": "[1](1,2)Shervashidze, Nino, Pascal Schweitzer, Erik Jan Van Leeuwen,\nKurt Mehlhorn, and Karsten M. Borgwardt. Weisfeiler Lehman\nGraph Kernels. Journal of Machine Learning Research. 2011.http://www.jmlr.org/papers/volume12/shervashidze11a/shervashidze11a.pdf  [2]Annamalai Narayanan, Mahinthan Chandramohan, Rajasekar Venkatesan,\nLihui Chen, Yang Liu and Shantanu Jaiswa. graph2vec: Learning\nDistributed Representations of Graphs. arXiv. 2017https://arxiv.org/pdf/1707.05005.pdf",
            "Examples": "Finding similar nodes in different graphs:\nG1=nx.Graph()\nG1.add_edges_from([(1,2),(2,3),(2,4),(3,5),(4,6),(5,7),(6,7)])\nG2=nx.Graph()\nG2.add_edges_from([(1,3),(2,3),(1,6),(1,5),(4,6)])\ng1_hashes=nx.weisfeiler_lehman_subgraph_hashes(G1,iterations=3,digest_size=8)\ng2_hashes=nx.weisfeiler_lehman_subgraph_hashes(G2,iterations=3,digest_size=8)\nEven though G1 and G2 are not isomorphic (they have different numbers of edges),\nthe hash sequence of depth 3 for node 1 in G1 and node 5 in G2 are similar:\ng1_hashes[1]\n# ['a93b64973cfc8897', 'db1b43ae35a1878f', '57872a7d2059c1c0']\ng2_hashes[5]\n# ['a93b64973cfc8897', 'db1b43ae35a1878f', '1716d2a4012fa4bc']\nThe first 2 WL subgraph hashes match. From this we can conclude that it\u2019s very\nlikely the neighborhood of 2 hops around these nodes are isomorphic.\nHowever the 3-hop neighborhoods ofG1andG2are not isomorphic since the\n3rd hashes in the lists above are not equal.\nThese nodes may be candidates to be classified together since their local topology\nis similar."
        }
    },
    {
        "Section ID": "dedensify",
        "Description": [
            "Compresses neighborhoods around high-degree nodes",
            "Reduces the number of edges to high-degree nodes by adding compressor nodes\nthat summarize multiple edges of the same type to high-degree nodes (nodes\nwith a degree greater than a given threshold).  Dedensification also has\nthe added benefit of reducing the number of edges around high-degree nodes.\nThe implementation currently supports graphs with a single edge type."
        ],
        "Field List": {
            "Parameters:": {
                "G: graph": "A networkx graph",
                "threshold: int": "Minimum degree threshold of a node to be considered a high degree node.\nThe threshold must be greater than or equal to 2.",
                "prefix: str or None, optional (default: None)": "An optional prefix for denoting compressor nodes",
                "copy: bool, optional (default: True)": "Indicates if dedensification should be done inplace"
            },
            "Returns:": {
                "dedensified networkx graph : (graph, set)": "2-tuple of the dedensified graph and set of compressor nodes"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "According to the algorithm in [1] , removes edges in a graph by\ncompressing/decompressing the neighborhoods around high degree nodes by\nadding compressor nodes that summarize multiple edges of the same type\nto high-degree nodes.  Dedensification will only add a compressor node when\ndoing so will reduce the total number of edges in the given graph. This\nimplementation currently supports graphs with a single edge type.",
            "References": "[1]Maccioni, A., & Abadi, D. J. (2016, August).\nScalable pattern matching over compressed graphs via dedensification.\nIn Proceedings of the 22nd ACM SIGKDD International Conference on\nKnowledge Discovery and Data Mining (pp. 1755-1764).http://www.cs.umd.edu/~abadi/papers/graph-dedense.pdf",
            "Examples": "Dedensification will only add compressor nodes when doing so would result\nin fewer edges:\noriginal_graph=nx.DiGraph()\noriginal_graph.add_nodes_from(\n[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"A\",\"B\",\"C\"]\n)\noriginal_graph.add_edges_from(\n[\n(\"1\",\"C\"),(\"1\",\"B\"),\n(\"2\",\"C\"),(\"2\",\"B\"),(\"2\",\"A\"),\n(\"3\",\"B\"),(\"3\",\"A\"),(\"3\",\"6\"),\n(\"4\",\"C\"),(\"4\",\"B\"),(\"4\",\"A\"),\n(\"5\",\"B\"),(\"5\",\"A\"),\n(\"6\",\"5\"),\n(\"A\",\"6\")\n]\n)\nc_graph,c_nodes=nx.dedensify(original_graph,threshold=2)\noriginal_graph.number_of_edges()\n# 15\nc_graph.number_of_edges()\n# 14\nA dedensified, directed graph can be \u201cdensified\u201d to reconstruct the\noriginal graph:\noriginal_graph=nx.DiGraph()\noriginal_graph.add_nodes_from(\n[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"A\",\"B\",\"C\"]\n)\noriginal_graph.add_edges_from(\n[\n(\"1\",\"C\"),(\"1\",\"B\"),\n(\"2\",\"C\"),(\"2\",\"B\"),(\"2\",\"A\"),\n(\"3\",\"B\"),(\"3\",\"A\"),(\"3\",\"6\"),\n(\"4\",\"C\"),(\"4\",\"B\"),(\"4\",\"A\"),\n(\"5\",\"B\"),(\"5\",\"A\"),\n(\"6\",\"5\"),\n(\"A\",\"6\")\n]\n)\nc_graph,c_nodes=nx.dedensify(original_graph,threshold=2)\n# re-densifies the compressed graph into the original graph\nforc_nodeinc_nodes:\nall_neighbors=set(nx.all_neighbors(c_graph,c_node))\nout_neighbors=set(c_graph.neighbors(c_node))\nforout_neighborinout_neighbors:\nc_graph.remove_edge(c_node,out_neighbor)\nin_neighbors=all_neighbors-out_neighbors\nforin_neighborinin_neighbors:\nc_graph.remove_edge(in_neighbor,c_node)\nforout_neighborinout_neighbors:\nc_graph.add_edge(in_neighbor,out_neighbor)\nc_graph.remove_node(c_node)\n\nnx.is_isomorphic(original_graph,c_graph)\n# True"
        }
    },
    {
        "Section ID": "non_neighbors",
        "Description": [
            "Returns the non-neighbors of the node in the graph."
        ],
        "Field List": {
            "Parameters:": {
                "graph : NetworkX graph": "Graph to find neighbors.",
                "node : node": "The node whose neighbors will be returned."
            },
            "Returns:": {
                "non_neighbors : set": "Set of nodes in the graph that are not neighbors of the node."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "balanced_tree",
        "Description": [
            "Returns the perfectly balanced r -ary tree of height h .",
            "( Sourcecode , png )"
        ],
        "Field List": {
            "Parameters:": {
                "r : int": "Branching factor of the tree; each node will haverchildren.",
                "h : int": "Height of the tree.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : NetworkX graph": "A balancedr-ary tree of heighth."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This is the rooted tree where all leaves are at distance h from\nthe root. The root has degree r and all other internal nodes\nhave degree r+1 . Node labels are integers, starting from zero. A balanced tree is also known as a complete r-ary tree ."
        }
    },
    {
        "Section ID": "dispersion",
        "Description": [
            "Calculate dispersion between u and v in G .",
            "A link between two actors ( u and v ) has a high dispersion when their\nmutual ties ( s and t ) are not well connected with each other."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.",
                "u : node, optional": "The source for the dispersion score (e.g. ego node of the network).",
                "v : node, optional": "The target of the dispersion score if specified.",
                "normalized : bool": "If True (default) normalize by the embeddedness of the nodes (u and v).",
                "alpha, b, c : float": "Parameters for the normalization procedure. Whennormalizedis True,\nthe dispersion value is normalized by:result=((dispersion+b)**alpha)/(embeddedness+c)as long as the denominator is nonzero."
            },
            "Returns:": {
                "nodes : dictionary": "If u (v) is specified, returns a dictionary of nodes with dispersion\nscore for all \u201ctarget\u201d (\u201csource\u201d) nodes. If neither u nor v is\nspecified, returns a dictionary of dictionaries for all nodes \u2018u\u2019 in the\ngraph with a dispersion score for each node \u2018v\u2019."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This implementation follows Lars Backstrom and Jon Kleinberg [1] . Typical\nusage would be to run dispersion on the ego network \\(G_u\\) if \\(u\\) were\nspecified.  Running dispersion() with neither \\(u\\) nor \\(v\\) specified\ncan take some time to complete.",
            "References": "[1]Romantic Partnerships and the Dispersion of Social Ties:\nA Network Analysis of Relationship Status on Facebook.\nLars Backstrom, Jon Kleinberg.https://arxiv.org/pdf/1310.6753v1.pdf"
        }
    },
    {
        "Section ID": "normalized_laplacian_spectrum",
        "Description": [
            "Return eigenvalues of the normalized Laplacian of G"
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "weight : string or None, optional (default=\u2019weight\u2019)": "The edge data key used to compute each value in the matrix.\nIf None, then each edge has weight 1."
            },
            "Returns:": {
                "evals : NumPy array": "Eigenvalues"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For MultiGraph/MultiDiGraph, the edges weights are summed.\nSee to_numpy_array for other options."
        }
    },
    {
        "Section ID": "single_source_bellman_ford",
        "Description": [
            "Compute shortest paths and lengths in a weighted graph G.",
            "Uses Bellman-Ford algorithm for shortest paths."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node label": "Starting node for path",
                "target : node label, optional": "Ending node for path",
                "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number."
            },
            "Returns:": {
                "distance, path : pair of dictionaries, or numeric and list": "If target is None, returns a tuple of two dictionaries keyed by node.\nThe first dictionary stores distance from one of the source nodes.\nThe second stores the path from one of the sources to that node.\nIf target is not None, returns a tuple of (distance, path) where\ndistance is the distance from source to target and path is a list\nrepresenting the path from source to target."
            },
            "Raises:": {
                "NodeNotFound": "Ifsourceis not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.",
            "Examples": "G=nx.path_graph(5)\nlength,path=nx.single_source_bellman_ford(G,0)\nlength[4]\n# 4\nfornodein[0,1,2,3,4]:\nprint(f\"{node}: {length[node]}\")\n# 0: 0\n# 1: 1\n# 2: 2\n# 3: 3\n# 4: 4\npath[4]\n# [0, 1, 2, 3, 4]\nlength,path=nx.single_source_bellman_ford(G,0,1)\nlength\n# 1\npath\n# [0, 1]"
        }
    },
    {
        "Section ID": "overall_reciprocity",
        "Description": [
            "Compute the reciprocity for the whole graph.",
            "See the doc of reciprocity for the definition."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph"
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "random_powerlaw_tree",
        "Description": [
            "Returns a tree with a power law degree distribution."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes.",
                "gamma : float": "Exponent of the power law.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "tries : int": "Number of attempts to adjust the sequence to make it a tree."
            },
            "Raises:": {
                "NetworkXError": "If no valid sequence is found within the maximum number of\nattempts."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "A trial power law degree sequence is chosen and then elements are\nswapped with new elements from a powerlaw distribution until the\nsequence makes a tree (by checking, for example, that the number of\nedges is one smaller than the number of nodes)."
        }
    },
    {
        "Section ID": "bridge_components",
        "Description": [
            "Finds all bridge-connected components G."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX undirected graph": ""
            },
            "Returns:": {
                "bridge_components : a generator of 2-edge-connected components": ""
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the input graph is directed or a multigraph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Bridge-connected components are also known as 2-edge-connected components.",
            "Examples": "# The barbell graph with parameter zero has a single bridge\nG=nx.barbell_graph(5,0)\nfromnetworkx.algorithms.connectivity.edge_kcomponentsimportbridge_components\nsorted(map(sorted,bridge_components(G)))\n# [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]"
        }
    },
    {
        "Section ID": "path_graph",
        "Description": [
            "Returns the Path graph P_n of linearly connected nodes.",
            "( Sourcecode , png )"
        ],
        "Field List": {
            "Parameters:": {
                "n : int or iterable": "If an integer, nodes are 0 to n - 1.\nIf an iterable of nodes, in the order they appear in the path.\nWarning: n is not checked for duplicates and if present the\nresulting graph may not be as desired. Make sure you have no duplicates.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "complete_multipartite_graph",
        "Description": [
            "Returns the complete multipartite graph with the specified subset sizes.",
            "( Sourcecode , png )"
        ],
        "Field List": {
            "Parameters:": {
                "subset_sizes : tuple of integers or tuple of node iterables": "The arguments can either all be integer number of nodes or they\ncan all be iterables of nodes. If integers, they represent the\nnumber of nodes in each subset of the multipartite graph.\nIf iterables, each is used to create the nodes for that subset.\nThe length of subset_sizes is the number of subsets."
            },
            "Returns:": {
                "G : NetworkX Graph": "Returns the complete multipartite graph with the specified subsets.For each node, the node attribute \u2018subset\u2019 is an integer\nindicating which subset contains the node."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This function generalizes several other graph builder functions.",
            "Examples": "Creating a complete tripartite graph, with subsets of one, two, and three\nnodes, respectively.\nG=nx.complete_multipartite_graph(1,2,3)\n[G.nodes[u][\"subset\"]foruinG]\n# [0, 1, 1, 2, 2, 2]\nlist(G.edges(0))\n# [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5)]\nlist(G.edges(2))\n# [(2, 0), (2, 3), (2, 4), (2, 5)]\nlist(G.edges(4))\n# [(4, 0), (4, 1), (4, 2)]\nG=nx.complete_multipartite_graph(\"a\",\"bc\",\"def\")\n[G.nodes[u][\"subset\"]foruinsorted(G)]\n# [0, 1, 1, 2, 2, 2]"
        }
    },
    {
        "Section ID": "configuration_model",
        "Description": [
            "Returns a random bipartite graph from two given degree sequences."
        ],
        "Field List": {
            "Parameters:": {
                "aseq : list": "Degree sequence for node set A.",
                "bseq : list": "Degree sequence for node set B.",
                "create_using : NetworkX graph instance, optional": "Return graph of this type.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "The graph is composed of two partitions. Set A has nodes 0 to": "",
                "(len(aseq) - 1) and set B has nodes len(aseq) to (len(bseq) - 1).": "",
                "Nodes from set A are connected to nodes in set B by choosing": "",
                "randomly from the possible free stubs, one in A and one in B.": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The sum of the two sequences must be equal: sum(aseq)=sum(bseq)\nIf no graph type is specified use MultiGraph with parallel edges.\nIf you want a graph with no parallel edges use create_using=Graph()\nbut then the resulting degree sequences might not be exact. The nodes are assigned the attribute \u2018bipartite\u2019 with the value 0 or 1\nto indicate which bipartite set the node belongs to. This function is not imported in the main namespace.\nTo use it use nx.bipartite.configuration_model"
        }
    },
    {
        "Section ID": "compose",
        "Description": [
            "Compose graph G with H by combining nodes and edges into a single graph.",
            "The node sets and edges sets do not need to be disjoint.",
            "Composing preserves the attributes of nodes and edges.\nAttribute values from H take precedent over attribute values from G."
        ],
        "Field List": {
            "Parameters:": {
                "G, H : graph": "A NetworkX graph"
            },
            "Returns:": {
                "C: A new graph with the same type as G": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "It is recommended that G and H be either both directed or both undirected. For MultiGraphs, the edges are identified by incident nodes AND edge-key.\nThis can cause surprises (i.e., edge (1,2) may or may not be the same\nin two graphs) if you use MultiGraph without keeping track of edge keys. If combining the attributes of common nodes is not desired, consider union(),\nwhich raises an exception for name collisions.",
            "Examples": "G=nx.Graph([(0,1),(0,2)])\nH=nx.Graph([(0,1),(1,2)])\nR=nx.compose(G,H)\nR.nodes\n# NodeView((0, 1, 2))\nR.edges\n# EdgeView([(0, 1), (0, 2), (1, 2)])\nBy default, the attributes fromHtake precedent over attributes fromG.\nIf you prefer another way of combining attributes, you can update them after the compose operation:\nG=nx.Graph([(0,1,{\"weight\":2.0}),(3,0,{\"weight\":100.0})])\nH=nx.Graph([(0,1,{\"weight\":10.0}),(1,2,{\"weight\":-1.0})])\nnx.set_node_attributes(G,{0:\"dark\",1:\"light\",3:\"black\"},name=\"color\")\nnx.set_node_attributes(H,{0:\"green\",1:\"orange\",2:\"yellow\"},name=\"color\")\nGcomposeH=nx.compose(G,H)\nNormally, color attribute values of nodes of GcomposeH come from H. We can workaround this as follows:\nnode_data={\nn:G.nodes[n][\"color\"]+\" \"+H.nodes[n][\"color\"]forninG.nodes&H.nodes\n}\nnx.set_node_attributes(GcomposeH,node_data,\"color\")\nprint(GcomposeH.nodes[0][\"color\"])\n# dark green\nprint(GcomposeH.nodes[3][\"color\"])\n# black\nSimilarly, we can update edge attributes after the compose operation in a way we prefer:\nedge_data={\ne:G.edges[e][\"weight\"]*H.edges[e][\"weight\"]foreinG.edges&H.edges\n}\nnx.set_edge_attributes(GcomposeH,edge_data,\"weight\")\nprint(GcomposeH.edges[(0,1)][\"weight\"])\n# 20.0\nprint(GcomposeH.edges[(3,0)][\"weight\"])\n# 100.0"
        }
    },
    {
        "Section ID": "combinatorial_embedding_to_pos",
        "Description": [
            "Assigns every node a (x, y) position based on the given embedding",
            "The algorithm iteratively inserts nodes of the input graph in a certain\norder and rearranges previously inserted nodes so that the planar drawing\nstays valid. This is done efficiently by only maintaining relative\npositions during the node placements and calculating the absolute positions\nat the end. For more information see [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "embedding : nx.PlanarEmbedding": "This defines the order of the edges",
                "fully_triangulate : bool": "If set to True the algorithm adds edges to a copy of the input\nembedding and makes it chordal."
            },
            "Returns:": {
                "pos : dict": "Maps each node to a tuple that defines the (x, y) position"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]M. Chrobak and T.H. Payne:\nA Linear-time Algorithm for Drawing a Planar Graph on a Grid 1989http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.51.6677"
        }
    },
    {
        "Section ID": "navigable_small_world_graph",
        "Description": [
            "Returns a navigable small-world graph.",
            "A navigable small-world graph is a directed grid with additional long-range\nconnections that are chosen randomly."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The length of one side of the lattice; the number of nodes in\nthe graph is therefore\\(n^2\\).",
                "p : int": "The diameter of short range connections. Each node is joined with every\nother node within this lattice distance.",
                "q : int": "The number of long-range connections for each node.",
                "r : float": "Exponent for decaying probability of connections.  The probability of\nconnecting to a node at lattice distance\\(d\\)is\\(1/d^r\\).",
                "dim : int": "Dimension of grid",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]J. Kleinberg. The small-world phenomenon: An algorithmic\nperspective. Proc. 32nd ACM Symposium on Theory of Computing, 2000."
        }
    },
    {
        "Section ID": "relaxed_caveman_graph",
        "Description": [
            "Returns a relaxed caveman graph.",
            "A relaxed caveman graph starts with l cliques of size k .  Edges are\nthen randomly rewired with probability p to link different cliques."
        ],
        "Field List": {
            "Parameters:": {
                "l : int": "Number of groups",
                "k : int": "Size of cliques",
                "p : float": "Probability of rewiring each edge.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "G : NetworkX Graph": "Relaxed Caveman Graph"
            },
            "Raises:": {
                "NetworkXError": "If p is not in [0,1]"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Santo Fortunato, Community Detection in Graphs,\nPhysics Reports Volume 486, Issues 3-5, February 2010, Pages 75-174.https://arxiv.org/abs/0906.0612",
            "Examples": "G=nx.relaxed_caveman_graph(2,3,0.1,seed=42)"
        }
    },
    {
        "Section ID": "house_graph",
        "Description": [
            "Returns the House graph (square with triangle on top)",
            "The house graph is a simple undirected graph with\n5 nodes and 6 edges [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : networkx Graph": "House graph in the form of a square with a triangle on top"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://mathworld.wolfram.com/HouseGraph.html"
        }
    },
    {
        "Section ID": "modular_product",
        "Description": [
            "Returns the Modular product of G and H.",
            "The modular product of G and H is the graph \\(M = G \\nabla H\\) ,\nconsisting of the node set \\(V(M) = V(G) \\times V(H)\\) that is the Cartesian\nproduct of the node sets of G and H . Further, M contains an edge ((u, v), (x, y)):",
            "More formally:"
        ],
        "Field List": {
            "Parameters:": {
                "G, H: NetworkX graphs": "The graphs to take the modular product of."
            },
            "Returns:": {
                "M: NetworkX graph": "The Modular product ofGandH."
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis not a simple graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The modular product is defined in [1] and was first\nintroduced as the weak modular product . The modular product reduces the problem of counting isomorphic subgraphs\nin G and H to the problem of counting cliques in M. The subgraphs of G and H that are induced by the nodes of a clique in M are\nisomorphic [2]  [3] .",
            "References": "[1]R. Hammack, W. Imrich, and S. Klav\u017ear,\n\u201cHandbook of Product Graphs\u201d, CRC Press, 2011.  [2]H. G. Barrow and R. M. Burstall,\n\u201cSubgraph isomorphism, matching relational structures and maximal\ncliques\u201d, Information Processing Letters, vol. 4, issue 4, pp. 83-84,\n1976,https://doi.org/10.1016/0020-0190(76)90049-1.  [3]V. G. Vizing, \u201cReduction of the problem of isomorphism and isomorphic\nentrance to the task of finding the nondensity of a graph.\u201d Proc. Third\nAll-Union Conference on Problems of Theoretical Cybernetics. 1974.",
            "Examples": "G=nx.cycle_graph(4)\nH=nx.path_graph(2)\nM=nx.modular_product(G,H)\nlist(M)\n# [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1), (3, 0), (3, 1)]\nprint(M)\n# Graph with 8 nodes and 8 edges"
        }
    },
    {
        "Section ID": "dominance_frontiers",
        "Description": [
            "Returns the dominance frontiers of all nodes of a directed graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : a DiGraph or MultiDiGraph": "The graph where dominance is to be computed.",
                "start : node": "The start node of dominance computation."
            },
            "Returns:": {
                "df : dict keyed by nodes": "A dict containing the dominance frontiers of each node reachable fromstartas lists."
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis undirected.",
                "NetworkXError": "Ifstartis not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]K. D. Cooper, T. J. Harvey, and K. Kennedy.\nA simple, fast dominance algorithm.\nSoftware Practice & Experience, 4:110, 2001.",
            "Examples": "G=nx.DiGraph([(1,2),(1,3),(2,5),(3,4),(4,5)])\nsorted((u,sorted(df))foru,dfinnx.dominance_frontiers(G,1).items())\n# [(1, []), (2, [5]), (3, [5]), (4, [5]), (5, [])]"
        }
    },
    {
        "Section ID": "harmonic_function",
        "Description": [
            "Node classification by Harmonic function",
            "Function for computing Harmonic function algorithm by Zhu et al."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "",
                "max_iter : int": "maximum number of iterations allowed",
                "label_name : string": "name of target labels to predict"
            },
            "Returns:": {
                "predicted : list": "List of lengthlen(G)with the predicted labels for each node."
            },
            "Raises:": {
                "NetworkXError": "If no nodes inGhave attributelabel_name."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "Zhu, X., Ghahramani, Z., & Lafferty, J. (2003, August).\nSemi-supervised learning using gaussian fields and harmonic functions.\nIn ICML (Vol. 3, pp. 912-919).",
            "Examples": "fromnetworkx.algorithmsimportnode_classification\nG=nx.path_graph(4)\nG.nodes[0][\"label\"]=\"A\"\nG.nodes[3][\"label\"]=\"B\"\nG.nodes(data=True)\n# NodeDataView({0: {'label': 'A'}, 1: {}, 2: {}, 3: {'label': 'B'}})\nG.edges()\n# EdgeView([(0, 1), (1, 2), (2, 3)])\npredicted=node_classification.harmonic_function(G)\npredicted\n# ['A', 'A', 'B', 'B']"
        }
    },
    {
        "Section ID": "min_edge_dominating_set",
        "Description": [
            "Returns minimum cardinality edge dominating set."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected graph"
            },
            "Returns:": {
                "min_edge_dominating_set : set": "Returns a set of dominating edges whose size is no more than 2 * OPT."
            },
            "Raises:": {
                "ValueError": "If the input graphGis empty."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The algorithm computes an approximate solution to the edge dominating set\nproblem. The result is no more than 2 * OPT in terms of size of the set.\nRuntime of the algorithm is \\(O(|E|)\\) .",
            "Examples": "G=nx.petersen_graph()\nnx.approximation.min_edge_dominating_set(G)\n# {(0, 1), (4, 9), (6, 8), (5, 7), (2, 3)}"
        }
    },
    {
        "Section ID": "triads_by_type",
        "Description": [
            "Returns a list of all triads for each triad type in a directed graph.\nThere are exactly 16 different types of triads possible. Suppose 1, 2, 3 are three\nnodes, they will be classified as a particular triad type if their connections\nare as follows:",
            "Refer to the example gallery for visual examples of the triad types."
        ],
        "Field List": {
            "Parameters:": {
                "G : digraph": "A NetworkX DiGraph"
            },
            "Returns:": {
                "tri_by_type : dict": "Dictionary with triad types as keys and lists of triads as values."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Snijders, T. (2012). \u201cTransitivity and triads.\u201d University of\nOxford.https://web.archive.org/web/20170830032057/http://www.stats.ox.ac.uk/~snijders/Trans_Triads_ha.pdf",
            "Examples": "G=nx.DiGraph([(1,2),(1,3),(2,3),(3,1),(5,6),(5,4),(6,7)])\ndict=nx.triads_by_type(G)\ndict[\"120C\"][0].edges()\n# OutEdgeView([(1, 2), (1, 3), (2, 3), (3, 1)])\ndict[\"012\"][0].edges()\n# OutEdgeView([(1, 2)])"
        }
    },
    {
        "Section ID": "normalized_laplacian_matrix",
        "Description": [
            "Returns the normalized Laplacian matrix of G.",
            "The normalized graph Laplacian is the matrix",
            "where L is the graph Laplacian and D is the diagonal matrix of\nnode degrees [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "nodelist : list, optional": "The rows and columns are ordered according to the nodes in nodelist.\nIf nodelist is None, then the ordering is produced by G.nodes().",
                "weight : string or None, optional (default=\u2019weight\u2019)": "The edge data key used to compute each value in the matrix.\nIf None, then each edge has weight 1."
            },
            "Returns:": {
                "N : SciPy sparse array": "The normalized Laplacian matrix of G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For MultiGraph, the edges weights are summed.\nSee to_numpy_array() for other options. If the Graph contains selfloops, D is defined as diag(sum(A,1)) , where A is\nthe adjacency matrix [2] . This calculation uses the out-degree of the graph G . To use the\nin-degree for calculations instead, use G.reverse(copy=False) and\ntake the transpose. For an unnormalized output, use laplacian_matrix .",
            "References": "[1]Fan Chung-Graham, Spectral Graph Theory,\nCBMS Regional Conference Series in Mathematics, Number 92, 1997.  [2]Steve Butler, Interlacing For Weighted Graphs Using The Normalized\nLaplacian, Electronic Journal of Linear Algebra, Volume 16, pp. 90-98,\nMarch 2007.  [3]Langville, Amy N., and Carl D. Meyer. Google\u2019s PageRank and Beyond:\nThe Science of Search Engine Rankings. Princeton University Press, 2006.",
            "Examples": "importnumpyasnp\nedges=[\n(1,2),\n(2,1),\n(2,4),\n(4,3),\n(3,4),\n]\nDiG=nx.DiGraph(edges)\nprint(nx.normalized_laplacian_matrix(DiG).toarray())\n# [[ 1.         -0.70710678  0.          0.        ]\n#  [-0.70710678  1.         -0.70710678  0.        ]\n#  [ 0.          0.          1.         -1.        ]\n#  [ 0.          0.         -1.          1.        ]]\nNotice that node 4 is represented by the third column and row. This is because\nby default the row/column order is the order ofG.nodes(i.e. the node added\norder \u2013 in the edgelist, 4 first appears in (2, 4), before node 3 in edge (4, 3).)\nTo control the node order of the matrix, use thenodelistargument.\nprint(nx.normalized_laplacian_matrix(DiG,nodelist=[1,2,3,4]).toarray())\n# [[ 1.         -0.70710678  0.          0.        ]\n#  [-0.70710678  1.          0.         -0.70710678]\n#  [ 0.          0.          1.         -1.        ]\n#  [ 0.          0.         -1.          1.        ]]\nG=nx.Graph(edges)\nprint(nx.normalized_laplacian_matrix(G).toarray())\n# [[ 1.         -0.70710678  0.          0.        ]\n#  [-0.70710678  1.         -0.5         0.        ]\n#  [ 0.         -0.5         1.         -0.70710678]\n#  [ 0.          0.         -0.70710678  1.        ]]"
        }
    },
    {
        "Section ID": "is_negatively_weighted",
        "Description": [
            "Returns True if G has negatively weighted edges."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.",
                "edge : tuple, optional": "A 2-tuple specifying the only edge inGthat will be tested. If\nNone, then every edge inGis tested.",
                "weight: string, optional": "The attribute name used to query for edge weights."
            },
            "Returns:": {
                "bool": "A boolean signifying ifG, or the specified edge, is negatively\nweighted."
            },
            "Raises:": {
                "NetworkXError": "If the specified edge does not exist."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph()\nG.add_edges_from([(1,3),(2,4),(2,6)])\nG.add_edge(1,2,weight=4)\nnx.is_negatively_weighted(G,(1,2))\n# False\nG[2][4][\"weight\"]=-2\nnx.is_negatively_weighted(G)\n# True\nG=nx.DiGraph()\nedges=[(\"0\",\"3\",3),(\"0\",\"1\",-5),(\"1\",\"0\",-2)]\nG.add_weighted_edges_from(edges)\nnx.is_negatively_weighted(G)\n# True"
        }
    },
    {
        "Section ID": "shortest_path",
        "Description": [
            "Compute shortest paths in the graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node, optional": "Starting node for path. If not specified, compute shortest\npaths for each possible starting node.",
                "target : node, optional": "Ending node for path. If not specified, compute shortest\npaths to all possible nodes.",
                "weight : None, string or function, optional (default = None)": "If None, every edge has weight/distance/cost 1.\nIf a string, use this edge attribute as the edge weight.\nAny edge attribute not present defaults to 1.\nIf this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly\nthree positional arguments: the two endpoints of an edge and\nthe dictionary of edge attributes for that edge.\nThe function must return a number.",
                "method : string, optional (default = \u2018dijkstra\u2019)": "The algorithm to use to compute the path.\nSupported options: \u2018dijkstra\u2019, \u2018bellman-ford\u2019.\nOther inputs produce a ValueError.\nIfweightis None, unweighted graph methods are used, and this\nsuggestion is ignored."
            },
            "Returns:": {
                "path: list or dictionary": "All returned paths include both the source and target in the path.If the source and target are both specified, return a single list\nof nodes in a shortest path from the source to the target.If only the source is specified, return a dictionary keyed by\ntargets with a list of nodes in a shortest path from the source\nto one of the targets.If only the target is specified, return a dictionary keyed by\nsources with a list of nodes in a shortest path from one of the\nsources to the target.If neither the source nor target are specified return a dictionary\nof dictionaries with path[source][target]=[list of nodes in path]."
            },
            "Raises:": {
                "NodeNotFound": "Ifsourceis not inG.",
                "ValueError": "Ifmethodis not among the supported options."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "There may be more than one shortest path between a source and target.\nThis returns only one of them.",
            "Examples": "G=nx.path_graph(5)\nprint(nx.shortest_path(G,source=0,target=4))\n# [0, 1, 2, 3, 4]\np=nx.shortest_path(G,source=0)# target not specified\np[3]# shortest path from source=0 to target=3\n# [0, 1, 2, 3]\np=nx.shortest_path(G,target=4)# source not specified\np[1]# shortest path from source=1 to target=4\n# [1, 2, 3, 4]\np=dict(nx.shortest_path(G))# source, target not specified\np[2][4]# shortest path from source=2 to target=4\n# [2, 3, 4]"
        }
    },
    {
        "Section ID": "barbell_graph",
        "Description": [
            "Returns the Barbell Graph: two complete graphs connected by a path.",
            "( Sourcecode , png )"
        ],
        "Field List": {
            "Parameters:": {
                "m1 : int": "Size of the left and right barbells, must be greater than 2.",
                "m2 : int": "Length of the path connecting the barbells.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated.\nOnly undirected Graphs are supported."
            },
            "Returns:": {
                "G : NetworkX graph": "A barbell graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Two identical complete graphs \\(K_{m1}\\) form the left and right bells,\nand are connected by a path \\(P_{m2}\\) ."
        }
    },
    {
        "Section ID": "discrete_sequence",
        "Description": [
            "Return sample sequence of length n from a given discrete distribution\nor discrete cumulative distribution.",
            "One of the following must be specified.",
            "distribution = histogram of values, will be normalized",
            "cdistribution = normalized discrete cumulative distribution"
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "is_weakly_connected",
        "Description": [
            "Test directed graph for weak connectivity.",
            "A directed graph is weakly connected if and only if the graph\nis connected when the direction of the edge between nodes is ignored.",
            "Note that if a graph is strongly connected (i.e. the graph is connected\neven when we account for directionality), it is by definition weakly\nconnected as well."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "A directed graph."
            },
            "Returns:": {
                "connected : bool": "True if the graph is weakly connected, False otherwise."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For directed graphs only.",
            "Examples": "G=nx.DiGraph([(0,1),(2,1)])\nG.add_node(3)\nnx.is_weakly_connected(G)# node 3 is not connected to the graph\n# False\nG.add_edge(2,3)\nnx.is_weakly_connected(G)\n# True"
        }
    },
    {
        "Section ID": "resource_allocation_index",
        "Description": [
            "Compute the resource allocation index of all node pairs in ebunch.",
            "Resource allocation index of u and v is defined as",
            "where \\(\\Gamma(u)\\) denotes the set of neighbors of \\(u\\) ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX undirected graph.",
                "ebunch : iterable of node pairs, optional (default = None)": "Resource allocation index will be computed for each pair of\nnodes given in the iterable. The pairs must be given as\n2-tuples (u, v) where u and v are nodes in the graph. If ebunch\nis None then all nonexistent edges in the graph will be used.\nDefault value: None."
            },
            "Returns:": {
                "piter : iterator": "An iterator of 3-tuples in the form (u, v, p) where (u, v) is a\npair of nodes and p is their resource allocation index."
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis aDiGraph, aMultigraphor aMultiDiGraph.",
                "NodeNotFound": "Ifebunchhas a node that is not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]T. Zhou, L. Lu, Y.-C. Zhang.\nPredicting missing links via local information.\nEur. Phys. J. B 71 (2009) 623.https://arxiv.org/pdf/0901.0553.pdf",
            "Examples": "G=nx.complete_graph(5)\npreds=nx.resource_allocation_index(G,[(0,1),(2,3)])\nforu,v,pinpreds:\nprint(f\"({u}, {v}) -> {p:.8f}\")\n# (0, 1) -> 0.75000000\n# (2, 3) -> 0.75000000"
        }
    },
    {
        "Section ID": "global_reaching_centrality",
        "Description": [
            "Returns the global reaching centrality of a directed graph.",
            "The global reaching centrality of a weighted directed graph is the\naverage over all nodes of the difference between the local reaching\ncentrality of the node and the greatest local reaching centrality of\nany node in the graph [1] . For more information on the local\nreaching centrality, see local_reaching_centrality() .\nInformally, the local reaching centrality is the proportion of the\ngraph that is reachable from the neighbors of the node."
        ],
        "Field List": {
            "Parameters:": {
                "G : DiGraph": "A networkx DiGraph.",
                "weight : None or string, optional (default=None)": "Attribute to use for edge weights. IfNone, each edge weight\nis assumed to be one. A higher weight implies a stronger\nconnection between nodes and ashorterpath length.",
                "normalized : bool, optional (default=True)": "Whether to normalize the edge weights by the total sum of edge\nweights."
            },
            "Returns:": {
                "h : float": "The global reaching centrality of the graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Mones, Enys, Lilla Vicsek, and Tam\u00e1s Vicsek.\n\u201cHierarchy Measure for Complex Networks.\u201dPLoS ONE7.3 (2012): e33799.https://doi.org/10.1371/journal.pone.0033799",
            "Examples": "G=nx.DiGraph()\nG.add_edge(1,2)\nG.add_edge(1,3)\nnx.global_reaching_centrality(G)\n# 1.0\nG.add_edge(3,2)\nnx.global_reaching_centrality(G)\n# 0.75"
        }
    },
    {
        "Section ID": "difference",
        "Description": [
            "Returns a new graph that contains the edges that exist in G but not in H.",
            "The node sets of H and G must be the same."
        ],
        "Field List": {
            "Parameters:": {
                "G,H : graph": "A NetworkX graph. G and H must have the same node sets."
            },
            "Returns:": {
                "D : A new graph with the same type as G.": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Attributes from the graph, nodes, and edges are not copied to the new\ngraph.  If you want a new graph of the difference of G and H with\nthe attributes (including edge data) from G use remove_nodes_from()\nas follows:",
            "Examples": "G=nx.Graph([(0,1),(0,2),(1,2),(1,3)])\nH=nx.Graph([(0,1),(1,2),(0,3)])\nR=nx.difference(G,H)\nR.nodes\n# NodeView((0, 1, 2, 3))\nR.edges\n# EdgeView([(0, 2), (1, 3)])"
        }
    },
    {
        "Section ID": "boundary_expansion",
        "Description": [
            "Returns the boundary expansion of the set S .",
            "The boundary expansion is the quotient of the size\nof the node boundary and the cardinality of S . [1]"
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "S : collection": "A collection of nodes inG."
            },
            "Returns:": {
                "number": "The boundary expansion of the setS."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Vadhan, Salil P.\n\u201cPseudorandomness.\u201dFoundations and Trends in Theoretical Computer Science7.1\u20133 (2011): 1\u2013336.\n<https://doi.org/10.1561/0400000010>"
        }
    },
    {
        "Section ID": "greedy_tsp",
        "Description": [
            "Return a low cost cycle starting at source and its cost.",
            "This approximates a solution to the traveling salesman problem.\nIt finds a cycle of all the nodes that a salesman can visit in order\nto visit many nodes while minimizing total distance.\nIt uses a simple greedy algorithm.\nIn essence, this function returns a large cycle given a source point\nfor which the total cost of the cycle is minimized."
        ],
        "Field List": {
            "Parameters:": {
                "G : Graph": "The Graph should be a complete weighted undirected graph.\nThe distance between all pairs of nodes should be included.",
                "weight : string, optional (default=\u201dweight\u201d)": "Edge data key corresponding to the edge weight.\nIf any edge does not have this attribute the weight is set to 1.",
                "source : node, optional (default: first node in list(G))": "Starting node.  If None, defaults tonext(iter(G))"
            },
            "Returns:": {
                "cycle : list of nodes": "Returns the cycle (list of nodes) that a salesman\ncan follow to minimize total weight of the trip."
            },
            "Raises:": {
                "NetworkXError": "IfGis not complete, the algorithm raises an exception."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This implementation of a greedy algorithm is based on the following:",
            "Examples": "fromnetworkx.algorithmsimportapproximationasapprox\nG=nx.DiGraph()\nG.add_weighted_edges_from(\n{\n(\"A\",\"B\",3),\n(\"A\",\"C\",17),\n(\"A\",\"D\",14),\n(\"B\",\"A\",3),\n(\"B\",\"C\",12),\n(\"B\",\"D\",16),\n(\"C\",\"A\",13),\n(\"C\",\"B\",12),\n(\"C\",\"D\",4),\n(\"D\",\"A\",14),\n(\"D\",\"B\",15),\n(\"D\",\"C\",2),\n}\n)\ncycle=approx.greedy_tsp(G,source=\"D\")\ncost=sum(G[n][nbr][\"weight\"]forn,nbrinnx.utils.pairwise(cycle))\ncycle\n# ['D', 'C', 'B', 'A', 'D']\ncost\n# 31"
        }
    },
    {
        "Section ID": "add_path",
        "Description": [
            "Add a path to the Graph G_to_add_to."
        ],
        "Field List": {
            "Parameters:": {
                "G_to_add_to : graph": "A NetworkX graph",
                "nodes_for_path : iterable container": "A container of nodes.  A path will be constructed from\nthe nodes (in order) and added to the graph.",
                "attr : keyword arguments, optional (default= no attributes)": "Attributes to add to every edge in path."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph()\nnx.add_path(G,[0,1,2,3])\nnx.add_path(G,[10,11,12],weight=7)"
        }
    },
    {
        "Section ID": "draw_kamada_kawai",
        "Description": [
            "Draw the graph G with a Kamada-Kawai force-directed layout.",
            "This is a convenience function equivalent to:"
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph",
                "kwargs : optional keywords": "Seedraw_networkxfor a description of optional keywords."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The layout is computed each time this function is called.\nFor repeated drawing it is much more efficient to call kamada_kawai_layout directly and reuse the\nresult:",
            "Examples": "G=nx.path_graph(5)\nnx.draw_kamada_kawai(G)"
        }
    },
    {
        "Section ID": "dag_longest_path",
        "Description": [
            "Returns the longest path in a directed acyclic graph (DAG).",
            "If G has edges with weight attribute the edge data are used as\nweight values."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX DiGraph": "A directed acyclic graph (DAG)",
                "weight : str, optional": "Edge data key to use for weight",
                "default_weight : int, optional": "The weight of edges that do not have a weight attribute",
                "topo_order: list or tuple, optional": "A topological order forG(if None, the function will compute one)"
            },
            "Returns:": {
                "list": "Longest path"
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis not directed"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "DG=nx.DiGraph([(0,1,{\"cost\":1}),(1,2,{\"cost\":1}),(0,2,{\"cost\":42})])\nlist(nx.all_simple_paths(DG,0,2))\n# [[0, 1, 2], [0, 2]]\nnx.dag_longest_path(DG)\n# [0, 1, 2]\nnx.dag_longest_path(DG,weight=\"cost\")\n# [0, 2]\nIn the case where multiple valid topological orderings exist,topo_ordercan be used to specify a specific ordering:\nDG=nx.DiGraph([(0,1),(0,2)])\nsorted(nx.all_topological_sorts(DG))# Valid topological orderings\n# [[0, 1, 2], [0, 2, 1]]\nnx.dag_longest_path(DG,topo_order=[0,1,2])\n# [0, 1]\nnx.dag_longest_path(DG,topo_order=[0,2,1])\n# [0, 2]"
        }
    },
    {
        "Section ID": "graphviz_layout",
        "Description": [
            "Create node positions using Pydot and Graphviz.",
            "Returns a dictionary of positions keyed by node."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "The graph for which the layout is computed.",
                "prog : string (default: \u2018neato\u2019)": "The name of the GraphViz program to use for layout.\nOptions depend on GraphViz version but may include:\n\u2018dot\u2019, \u2018twopi\u2019, \u2018fdp\u2019, \u2018sfdp\u2019, \u2018circo\u2019",
                "root : Node from G or None (default: None)": "The node of G from which to start some layout algorithms."
            },
            "Returns:": {
                "Dictionary of (x, y) positions keyed by node.": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This is a wrapper for pydot_layout.",
            "Examples": "G=nx.complete_graph(4)\npos=nx.nx_pydot.graphviz_layout(G)\npos=nx.nx_pydot.graphviz_layout(G,prog=\"dot\")"
        }
    },
    {
        "Section ID": "truncated_tetrahedron_graph",
        "Description": [
            "Returns the skeleton of the truncated Platonic tetrahedron.",
            "The truncated tetrahedron is an Archimedean solid with 4 regular hexagonal faces,\n4 equilateral triangle faces, 12 nodes and 18 edges. It can be constructed by truncating\nall 4 vertices of a regular tetrahedron at one third of the original edge length [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : networkx Graph": "Skeleton of the truncated tetrahedron"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://en.wikipedia.org/wiki/Truncated_tetrahedron"
        }
    },
    {
        "Section ID": "union_all",
        "Description": [
            "Returns the union of all graphs.",
            "The graphs must be disjoint, otherwise an exception is raised."
        ],
        "Field List": {
            "Parameters:": {
                "graphs : iterable": "Iterable of NetworkX graphs",
                "rename : iterable , optional": "Node names of graphs can be changed by specifying the tuple\nrename=(\u2018G-\u2018,\u2019H-\u2019) (for example).  Node \u201cu\u201d in G is then renamed\n\u201cG-u\u201d and \u201cv\u201d in H is renamed \u201cH-v\u201d. Infinite generators (like itertools.count)\nare also supported."
            },
            "Returns:": {
                "U : a graph with the same type as the first graph in list": ""
            },
            "Raises:": {
                "ValueError": "Ifgraphsis an empty list.",
                "NetworkXError": "In case of mixed type graphs, like MultiGraph and Graph, or directed and undirected graphs."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For operating on mixed type graphs, they should be converted to the same type.\n>>> G = nx.Graph()\n>>> H = nx.DiGraph()\n>>> GH = union_all([nx.DiGraph(G), H]) To force a disjoint union with node relabeling, use\ndisjoint_union_all(G,H) or convert_node_labels_to integers(). Graph, edge, and node attributes are propagated to the union graph.\nIf a graph attribute is present in multiple graphs, then the value\nfrom the last graph in the list with that attribute is used.",
            "Examples": "G1=nx.Graph([(1,2),(2,3)])\nG2=nx.Graph([(4,5),(5,6)])\nresult_graph=nx.union_all([G1,G2])\nresult_graph.nodes()\n# NodeView((1, 2, 3, 4, 5, 6))\nresult_graph.edges()\n# EdgeView([(1, 2), (2, 3), (4, 5), (5, 6)])"
        }
    },
    {
        "Section ID": "maximum_flow_value",
        "Description": [
            "Find the value of maximum single-commodity flow."
        ],
        "Field List": {
            "Parameters:": {
                "flowG : NetworkX graph": "Edges of the graph are expected to have an attribute called\n\u2018capacity\u2019. If this attribute is not present, the edge is\nconsidered to have infinite capacity.",
                "_s : node": "Source node for the flow.",
                "_t : node": "Sink node for the flow.",
                "capacity : string": "Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: \u2018capacity\u2019.",
                "flow_func : function": "A function for computing the maximum flow among a pair of nodes\nin a capacitated graph. The function has to accept at least three\nparameters: a Graph or Digraph, a source node, and a target node.\nAnd return a residual network that follows NetworkX conventions\n(see Notes). If flow_func is None, the default maximum\nflow function (preflow_push()) is used. See below for\nalternative algorithms. The choice of the default function may change\nfrom version to version and should not be relied on. Default value:\nNone.",
                "kwargs : Any other keyword parameter is passed to the function that": "computes the maximum flow."
            },
            "Returns:": {
                "flow_value : integer, float": "Value of the maximum flow, i.e., net outflow from the source."
            },
            "Raises:": {
                "NetworkXError": "The algorithm does not support MultiGraph and MultiDiGraph. If\nthe input graph is an instance of one of these two classes, a\nNetworkXError is raised.",
                "NetworkXUnbounded": "If the graph has a path of infinite capacity, the value of a\nfeasible flow on the graph is unbounded above and the function\nraises a NetworkXUnbounded."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The function used in the flow_func parameter has to return a residual\nnetwork that follows NetworkX conventions: The residual network R from an input graph G has the\nsame nodes as G . R is a DiGraph that contains a pair\nof edges (u,v) and (v,u) iff (u,v) is not a\nself-loop, and at least one of (u,v) and (v,u) exists\nin G . For each edge (u,v) in R , R[u][v]['capacity'] is equal to the capacity of (u,v) in G if it exists\nin G or zero otherwise. If the capacity is infinite, R[u][v]['capacity'] will have a high arbitrary finite value\nthat does not affect the solution of the problem. This value is stored in R.graph['inf'] . For each edge (u,v) in R , R[u][v]['flow'] represents the flow function of (u,v) and\nsatisfies R[u][v]['flow']==-R[v][u]['flow'] . The flow value, defined as the total flow into t , the sink, is\nstored in R.graph['flow_value'] . Reachability to t using\nonly edges (u,v) such that R[u][v]['flow']<R[u][v]['capacity'] induces a minimum s - t cut. Specific algorithms may store extra data in R . The function should supports an optional boolean parameter value_only. When\nTrue, it can optionally terminate the algorithm as soon as the maximum flow\nvalue and the minimum cut can be determined.",
            "Examples": "G=nx.DiGraph()\nG.add_edge(\"x\",\"a\",capacity=3.0)\nG.add_edge(\"x\",\"b\",capacity=1.0)\nG.add_edge(\"a\",\"c\",capacity=3.0)\nG.add_edge(\"b\",\"c\",capacity=5.0)\nG.add_edge(\"b\",\"d\",capacity=4.0)\nG.add_edge(\"d\",\"e\",capacity=2.0)\nG.add_edge(\"c\",\"y\",capacity=2.0)\nG.add_edge(\"e\",\"y\",capacity=3.0)\nmaximum_flow_value computes only the value of the\nmaximum flow:\nflow_value=nx.maximum_flow_value(G,\"x\",\"y\")\nflow_value\n# 3.0\nYou can also use alternative algorithms for computing the\nmaximum flow by using the flow_func parameter.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\nflow_value==nx.maximum_flow_value(G,\"x\",\"y\",flow_func=shortest_augmenting_path)\n# True"
        }
    },
    {
        "Section ID": "closeness_centrality",
        "Description": [
            "Compute closeness centrality for nodes.",
            "Closeness centrality [1] of a node u is the reciprocal of the\naverage shortest path distance to u over all n-1 reachable nodes.",
            "where d(v,u) is the shortest-path distance between v and u ,\nand n-1 is the number of nodes reachable from u . Notice that the\ncloseness distance function computes the incoming distance to u for directed graphs. To use outward distance, act on G.reverse() .",
            "Notice that higher values of closeness indicate higher centrality.",
            "Wasserman and Faust propose an improved formula for graphs with\nmore than one connected component. The result is \u201ca ratio of the\nfraction of actors in the group who are reachable, to the average\ndistance\u201d from the reachable actors [2] . You might think this\nscale factor is inverted but it is not. As is, nodes from small\ncomponents receive a smaller closeness value. Letting N denote\nthe number of nodes in the graph,"
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "u : node, optional": "Return only the value for node u",
                "distance : edge attribute key, optional (default=None)": "Use the specified edge attribute as the edge distance in shortest\npath calculations.  IfNone(the default) all edges have a distance of 1.\nAbsent edge attributes are assigned a distance of 1. Note that no check\nis performed to ensure that edges have the provided attribute.",
                "wf_improved : bool, optional (default=True)": "If True, scale by the fraction of nodes reachable. This gives the\nWasserman and Faust improved formula. For single component graphs\nit is the same as the original formula."
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of nodes with closeness centrality as the value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The closeness centrality is normalized to (n-1)/(|G|-1) where n is the number of nodes in the connected part of graph\ncontaining the node.  If the graph is not completely connected,\nthis algorithm computes the closeness centrality for each\nconnected part separately scaled by that parts size. If the \u2018distance\u2019 keyword is set to an edge attribute key then the\nshortest-path length will be computed using Dijkstra\u2019s algorithm with\nthat edge attribute as the edge weight. The closeness centrality uses inward distance to a node, not outward.\nIf you want to use outword distances apply the function to G.reverse() In NetworkX 2.2 and earlier a bug caused Dijkstra\u2019s algorithm to use the\noutward distance rather than the inward distance. If you use a \u2018distance\u2019\nkeyword and a DiGraph, your results will change between v2.2 and v2.3.",
            "References": "[1]Linton C. Freeman: Centrality in networks: I.\nConceptual clarification. Social Networks 1:215-239, 1979.https://doi.org/10.1016/0378-8733(78)90021-7  [2]pg. 201 of Wasserman, S. and Faust, K.,\nSocial Network Analysis: Methods and Applications, 1994,\nCambridge University Press.",
            "Examples": "G=nx.Graph([(0,1),(0,2),(0,3),(1,2),(1,3)])\nnx.closeness_centrality(G)\n# {0: 1.0, 1: 1.0, 2: 0.75, 3: 0.75}"
        }
    },
    {
        "Section ID": "naive_greedy_modularity_communities",
        "Description": [
            "Find communities in G using greedy modularity maximization.",
            "This implementation is O(n^4), much slower than alternatives, but it is\nprovided as an easy-to-understand reference implementation.",
            "Greedy modularity maximization begins with each node in its own community\nand joins the pair of communities that most increases modularity until no\nsuch pair exists.",
            "This function maximizes the generalized modularity, where resolution is the resolution parameter, often expressed as \\(\\gamma\\) .\nSee modularity() ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Graph must be simple and undirected.",
                "resolution : float (default=1)": "If resolution is less than 1, modularity favors larger communities.\nGreater than 1 favors smaller communities.",
                "weight : string or None, optional (default=None)": "The name of an edge attribute that holds the numerical value used\nas a weight.  If None, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node."
            },
            "Returns:": {
                "list": "A list of sets of nodes, one for each community.\nSorted by length with largest communities first."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.karate_club_graph()\nc=nx.community.naive_greedy_modularity_communities(G)\nsorted(c[0])\n# [8, 14, 15, 18, 20, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33]"
        }
    },
    {
        "Section ID": "corona_product",
        "Description": [
            "Returns the Corona product of G and H.",
            "The corona product of \\(G\\) and \\(H\\) is the graph \\(C = G \\circ H\\) obtained by\ntaking one copy of \\(G\\) , called the center graph, \\(|V(G)|\\) copies of \\(H\\) ,\ncalled the outer graph, and making the \\(i\\) -th vertex of \\(G\\) adjacent to\nevery vertex of the \\(i\\) -th copy of \\(H\\) , where \\(1 \u2264 i \u2264 |V(G)|\\) ."
        ],
        "Field List": {
            "Parameters:": {
                "G, H: NetworkX graphs": "The graphs to take the carona product of.Gis the center graph andHis the outer graph"
            },
            "Returns:": {
                "C: NetworkX graph": "The Corona product of G and H."
            },
            "Raises:": {
                "NetworkXError": "If G and H are not both directed or both undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1] M. Tavakoli, F. Rahbarnia, and A. R. Ashrafi, \u201cStudying the corona product of graphs under some graph invariants,\u201d\nTransactions on Combinatorics, vol. 3, no. 3, pp. 43\u201349, Sep. 2014,\ndoi: 10.22108/toc.2014.5542.  [2] A. Faraji, \u201cCorona Product in Graph Theory,\u201d Ali Faraji, May 11, 2021. https://blog.alifaraji.ir/math/graph-theory/corona-product.html(accessed Dec. 07, 2021).",
            "Examples": "G=nx.cycle_graph(4)\nH=nx.path_graph(2)\nC=nx.corona_product(G,H)\nlist(C)\n# [0, 1, 2, 3, (0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1), (3, 0), (3, 1)]\nprint(C)\n# Graph with 12 nodes and 16 edges"
        }
    },
    {
        "Section ID": "planted_partition_graph",
        "Description": [
            "Returns the planted l-partition graph.",
            "This model partitions a graph with n=l*k vertices in\nl groups with k vertices each. Vertices of the same\ngroup are linked with a probability p_in, and vertices\nof different groups are linked with probability p_out."
        ],
        "Field List": {
            "Parameters:": {
                "l : int": "Number of groups",
                "k : int": "Number of vertices in each group",
                "p_in : float": "probability of connecting vertices within a group",
                "p_out : float": "probability of connected vertices between groups",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "directed : bool,optional (default=False)": "If True return a directed graph"
            },
            "Returns:": {
                "G : NetworkX Graph or DiGraph": "planted l-partition graph"
            },
            "Raises:": {
                "NetworkXError": "Ifp_in,p_outare not in[0,1]"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]A. Condon, R.M. Karp, Algorithms for graph partitioning\non the planted partition model,\nRandom Struct. Algor. 18 (2001) 116-140.  [2]Santo Fortunato \u2018Community Detection in Graphs\u2019 Physical Reports\nVolume 486, Issue 3-5 p. 75-174.https://arxiv.org/abs/0906.0612",
            "Examples": "G=nx.planted_partition_graph(4,3,0.5,0.1,seed=42)"
        }
    },
    {
        "Section ID": "percolation_centrality",
        "Description": [
            "Compute the percolation centrality for nodes.",
            "Percolation centrality of a node \\(v\\) , at a given time, is defined\nas the proportion of \u2018percolated paths\u2019 that go through that node.",
            "This measure quantifies relative impact of nodes based on their\ntopological connectivity, as well as their percolation states.",
            "Percolation states of nodes are used to depict network percolation\nscenarios (such as during infection transmission in a social network\nof individuals, spreading of computer viruses on computer networks, or\ntransmission of disease over a network of towns) over time. In this\nmeasure usually the percolation state is expressed as a decimal\nbetween 0.0 and 1.0.",
            "When all nodes are in the same percolated state this measure is\nequivalent to betweenness centrality."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.",
                "attribute : None or string, optional (default=\u2019percolation\u2019)": "Name of the node attribute to use for percolation state, used\nifstatesis None. If a node does not set the attribute the\nstate of that node will be set to the default value of 1.\nIf all nodes do not have the attribute all nodes will be set to\n1 and the centrality measure will be equivalent to betweenness centrality.",
                "states : None or dict, optional (default=None)": "Specify percolation states for the nodes, nodes as keys states\nas values.",
                "weight : None or string, optional (default=None)": "If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight.\nThe weight of an edge is treated as the length or distance between the two sides."
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of nodes with percolation centrality as the value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The algorithm is from Mahendra Piraveenan, Mikhail Prokopenko, and\nLiaquat Hossain [1] Pair dependencies are calculated and accumulated using [2] For weighted graphs the edge weights must be greater than zero.\nZero edge weights can produce an infinite number of equal length\npaths between pairs of nodes.",
            "References": "[1]Mahendra Piraveenan, Mikhail Prokopenko, Liaquat Hossain\nPercolation Centrality: Quantifying Graph-Theoretic Impact of Nodes\nduring Percolation in Networkshttp://journals.plos.org/plosone/article?id=10.1371/journal.pone.0053095  [2]Ulrik Brandes:\nA Faster Algorithm for Betweenness Centrality.\nJournal of Mathematical Sociology 25(2):163-177, 2001.https://doi.org/10.1080/0022250X.2001.9990249"
        }
    },
    {
        "Section ID": "cost_of_flow",
        "Description": [
            "Compute the cost of the flow given by flowDict on graph G.",
            "Note that this function does not check for the validity of the\nflow flowDict. This function will fail if the graph G and the\nflow don\u2019t have the same edge set."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "DiGraph on which a minimum cost flow satisfying all demands is\nto be found.",
                "weight : string": "Edges of the graph G are expected to have an attribute weight\nthat indicates the cost incurred by sending one unit of flow on\nthat edge. If not present, the weight is considered to be 0.\nDefault value: \u2018weight\u2019.",
                "flowDict : dictionary": "Dictionary of dictionaries keyed by nodes such that\nflowDict[u][v] is the flow edge (u, v)."
            },
            "Returns:": {
                "cost : Integer, float": "The total cost of the flow. This is given by the sum over all\nedges of the product of the edge\u2019s flow and the edge\u2019s weight."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm is not guaranteed to work if edge weights or demands\nare floating point numbers (overflows and roundoff errors can\ncause problems). As a workaround you can use integer numbers by\nmultiplying the relevant edge attributes by a convenient\nconstant factor (eg 100).",
            "Examples": "G=nx.DiGraph()\nG.add_node(\"a\",demand=-5)\nG.add_node(\"d\",demand=5)\nG.add_edge(\"a\",\"b\",weight=3,capacity=4)\nG.add_edge(\"a\",\"c\",weight=6,capacity=10)\nG.add_edge(\"b\",\"d\",weight=1,capacity=9)\nG.add_edge(\"c\",\"d\",weight=2,capacity=5)\nflowDict=nx.min_cost_flow(G)\nflowDict\n# {'a': {'b': 4, 'c': 1}, 'd': {}, 'b': {'d': 4}, 'c': {'d': 1}}\nnx.cost_of_flow(G,flowDict)\n# 24"
        }
    },
    {
        "Section ID": "bfs_edges",
        "Description": [
            "Iterate over edges in a breadth-first-search starting at source."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node": "Specify starting node for breadth-first search; this function\niterates over only those edges in the component reachable from\nthis node.",
                "reverse : bool, optional": "If True traverse a directed graph in the reverse direction",
                "depth_limit : int, optional(default=len(G))": "Specify the maximum search depth",
                "sort_neighbors : function (default=None)": "A function that takes an iterator over nodes as the input, and\nreturns an iterable of the same nodes with a custom ordering.\nFor example,sortedwill sort the nodes in increasing order."
            },
            "Yields:": {
                "edge: 2-tuple of nodes": "Yields edges resulting from the breadth-first search."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The naming of this function is very similar to edge_bfs() . The difference\nis that edge_bfs yields edges even if they extend back to an already\nexplored node while this generator yields the edges of the tree that results\nfrom a breadth-first-search (BFS) so no edges are reported if they extend\nto already explored nodes. That means edge_bfs reports all edges while bfs_edges only reports those traversed by a node-based BFS. Yet another\ndescription is that bfs_edges reports the edges traversed during BFS\nwhile edge_bfs reports all edges in the order they are explored. Based on the breadth-first search implementation in PADS [1] by D. Eppstein, July 2004; with modifications to allow depth limits\nas described in [2] .",
            "References": "[1]http://www.ics.uci.edu/~eppstein/PADS/BFS.py.  [2]https://en.wikipedia.org/wiki/Depth-limited_search",
            "Examples": "To get the edges in a breadth-first search:\nG=nx.path_graph(3)\nlist(nx.bfs_edges(G,0))\n# [(0, 1), (1, 2)]\nlist(nx.bfs_edges(G,source=0,depth_limit=1))\n# [(0, 1)]\nTo get the nodes in a breadth-first search order:\nG=nx.path_graph(3)\nroot=2\nedges=nx.bfs_edges(G,root)\nnodes=[root]+[vforu,vinedges]\nnodes\n# [2, 1, 0]"
        }
    },
    {
        "Section ID": "katz_centrality_numpy",
        "Description": [
            "Compute the Katz centrality for the graph G.",
            "Katz centrality computes the centrality for a node based on the centrality\nof its neighbors. It is a generalization of the eigenvector centrality. The\nKatz centrality for node \\(i\\) is",
            "where \\(A\\) is the adjacency matrix of graph G with eigenvalues \\(\\lambda\\) .",
            "The parameter \\(\\beta\\) controls the initial centrality and",
            "Katz centrality computes the relative influence of a node within a\nnetwork by measuring the number of the immediate neighbors (first\ndegree nodes) and also all other nodes in the network that connect\nto the node under consideration through these immediate neighbors.",
            "Extra weight can be provided to immediate neighbors through the\nparameter \\(\\beta\\) .  Connections made with distant neighbors\nare, however, penalized by an attenuation factor \\(\\alpha\\) which\nshould be strictly less than the inverse largest eigenvalue of the\nadjacency matrix in order for the Katz centrality to be computed\ncorrectly. More information is provided in [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "alpha : float": "Attenuation factor",
                "beta : scalar or dictionary, optional (default=1.0)": "Weight attributed to the immediate neighborhood. If not a scalar the\ndictionary must have an value for every node.",
                "normalized : bool": "If True normalize the resulting values.",
                "weight : None or string, optional": "If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight.\nIn this measure the weight is interpreted as the connection strength."
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of nodes with Katz centrality as the value."
            },
            "Raises:": {
                "NetworkXError": "If the parameterbetais not a scalar but lacks a value for at least\none node"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Katz centrality was introduced by [2] . This algorithm uses a direct linear solver to solve the above equation.\nThe parameter alpha should be strictly less than the inverse of largest\neigenvalue of the adjacency matrix for there to be a solution.\nYou can use max(nx.adjacency_spectrum(G)) to get \\(\\lambda_{\\max}\\) the largest\neigenvalue of the adjacency matrix. For strongly connected graphs, as \\(\\alpha \\to 1/\\lambda_{\\max}\\) , and \\(\\beta > 0\\) ,\nKatz centrality approaches the results for eigenvector centrality. For directed graphs this finds \u201cleft\u201d eigenvectors which corresponds\nto the in-edges in the graph. For out-edges Katz centrality,\nfirst reverse the graph with G.reverse() .",
            "References": "[1]Mark E. J. Newman:\nNetworks: An Introduction.\nOxford University Press, USA, 2010, p. 173.  [2]Leo Katz:\nA New Status Index Derived from Sociometric Index.\nPsychometrika 18(1):39\u201343, 1953https://link.springer.com/content/pdf/10.1007/BF02289026.pdf",
            "Examples": "importmath\nG=nx.path_graph(4)\nphi=(1+math.sqrt(5))/2.0# largest eigenvalue of adj matrix\ncentrality=nx.katz_centrality_numpy(G,1/phi)\nforn,cinsorted(centrality.items()):\nprint(f\"{n} {c:.2f}\")\n# 0 0.37\n# 1 0.60\n# 2 0.60\n# 3 0.37"
        }
    },
    {
        "Section ID": "complete_graph",
        "Description": [
            "Return the complete graph K_n with n nodes.",
            "A complete graph on n nodes means that all pairs\nof distinct nodes have an edge connecting them.",
            "( Sourcecode , png )"
        ],
        "Field List": {
            "Parameters:": {
                "n : int or iterable container of nodes": "If n is an integer, nodes are from range(n).\nIf n is a container of nodes, those nodes appear in the graph.\nWarning: n is not checked for duplicates and if present the\nresulting graph may not be as desired. Make sure you have no duplicates.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.complete_graph(9)\nlen(G)\n# 9\nG.size()\n# 36\nG=nx.complete_graph(range(11,14))\nlist(G.nodes())\n# [11, 12, 13]\nG=nx.complete_graph(4,nx.DiGraph())\nG.is_directed()\n# True"
        }
    },
    {
        "Section ID": "local_reaching_centrality",
        "Description": [
            "Returns the local reaching centrality of a node in a directed\ngraph.",
            "The local reaching centrality of a node in a directed graph is the\nproportion of other nodes reachable from that node [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : DiGraph": "A NetworkX DiGraph.",
                "v : node": "A node in the directed graphG.",
                "paths : dictionary (default=None)": "If this is notNoneit must be a dictionary representation\nof single-source shortest paths, as computed by, for example,networkx.shortest_path()with source nodev. Use this\nkeyword argument if you intend to invoke this function many\ntimes but don\u2019t want the paths to be recomputed each time.",
                "weight : None or string, optional (default=None)": "Attribute to use for edge weights.  IfNone, each edge weight\nis assumed to be one. A higher weight implies a stronger\nconnection between nodes and ashorterpath length.",
                "normalized : bool, optional (default=True)": "Whether to normalize the edge weights by the total sum of edge\nweights."
            },
            "Returns:": {
                "h : float": "The local reaching centrality of the nodevin the graphG."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Mones, Enys, Lilla Vicsek, and Tam\u00e1s Vicsek.\n\u201cHierarchy Measure for Complex Networks.\u201dPLoS ONE7.3 (2012): e33799.https://doi.org/10.1371/journal.pone.0033799",
            "Examples": "G=nx.DiGraph()\nG.add_edges_from([(1,2),(1,3)])\nnx.local_reaching_centrality(G,3)\n# 0.0\nG.add_edge(3,2)\nnx.local_reaching_centrality(G,3)\n# 0.5"
        }
    },
    {
        "Section ID": "sedgewick_maze_graph",
        "Description": [
            "Return a small maze with a cycle.",
            "This is the maze used in Sedgewick, 3rd Edition, Part 5, Graph\nAlgorithms, Chapter 18, e.g. Figure 18.2 and following [1] .\nNodes are numbered 0,..,7"
        ],
        "Field List": {
            "Parameters:": {
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : networkx Graph": "Small maze with a cycle"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Figure 18.2, Chapter 18, Graph Algorithms (3rd Ed), Sedgewick"
        }
    },
    {
        "Section ID": "random_clustered_graph",
        "Description": [
            "Generate a random graph with the given joint independent edge degree and\ntriangle degree sequence.",
            "This uses a configuration model-like approach to generate a random graph\n(with parallel edges and self-loops) by randomly assigning edges to match\nthe given joint degree sequence.",
            "The joint degree sequence is a list of pairs of integers of the form \\([(d_{1,i}, d_{1,t}), \\dotsc, (d_{n,i}, d_{n,t})]\\) . According to this list,\nvertex \\(u\\) is a member of \\(d_{u,t}\\) triangles and has \\(d_{u, i}\\) other\nedges. The number \\(d_{u,t}\\) is the triangle degree of \\(u\\) and the number \\(d_{u,i}\\) is the independent edge degree ."
        ],
        "Field List": {
            "Parameters:": {
                "joint_degree_sequence : list of integer pairs": "Each list entry corresponds to the independent edge degree and\ntriangle degree of a node.",
                "create_using : NetworkX graph constructor, optional (default MultiGraph)": "Graph type to create. If graph instance, then cleared before populated.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "G : MultiGraph": "A graph with the specified degree sequence. Nodes are labeled\nstarting at 0 with an index corresponding to the position in\ndeg_sequence."
            },
            "Raises:": {
                "NetworkXError": "If the independent edge degree sequence sum is not even\nor the triangle degree sequence sum is not divisible by 3."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "As described by Miller [1] (see also Newman [2] for an equivalent\ndescription). A non-graphical degree sequence (not realizable by some simple\ngraph) is allowed since this function returns graphs with self\nloops and parallel edges.  An exception is raised if the\nindependent degree sequence does not have an even sum or the\ntriangle degree sequence sum is not divisible by 3. This configuration model-like construction process can lead to\nduplicate edges and loops.  You can remove the self-loops and\nparallel edges (see below) which will likely result in a graph\nthat doesn\u2019t have the exact degree sequence specified.  This\n\u201cfinite-size effect\u201d decreases as the size of the graph increases.",
            "References": "[1]Joel C. Miller. \u201cPercolation and epidemics in random clustered\nnetworks\u201d. In: Physical review. E, Statistical, nonlinear, and soft\nmatter physics 80 (2 Part 1 August 2009).  [2]M. E. J. Newman. \u201cRandom Graphs with Clustering\u201d.\nIn: Physical Review Letters 103 (5 July 2009)",
            "Examples": "deg=[(1,0),(1,0),(1,0),(2,0),(1,0),(2,1),(0,1),(0,1)]\nG=nx.random_clustered_graph(deg)\nTo remove parallel edges:\nG=nx.Graph(G)\nTo remove self loops:\nG.remove_edges_from(nx.selfloop_edges(G))"
        }
    },
    {
        "Section ID": "k_components",
        "Description": [
            "Returns the approximate k-component structure of a graph G.",
            "A k -component is a maximal subgraph of a graph G that has, at least,\nnode connectivity k : we need to remove at least k nodes to break it\ninto more components. k -components have an inherent hierarchical\nstructure because they are nested in terms of connectivity: a connected\ngraph can contain several 2-components, each of which can contain\none or more 3-components, and so forth.",
            "This implementation is based on the fast heuristics to approximate\nthe k -component structure of a graph [1] . Which, in turn, it is based on\na fast approximation algorithm for finding good lower bounds of the number\nof node independent paths between two nodes [2] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected graph",
                "min_density : Float": "Density relaxation threshold. Default value 0.95"
            },
            "Returns:": {
                "k_components : dict": "Dictionary with connectivity levelkas key and a list of\nsets of nodes that form a k-component of levelkas values."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is directed."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The logic of the approximation algorithm for computing the k -component\nstructure [1] is based on repeatedly applying simple and fast algorithms\nfor k -cores and biconnected components in order to narrow down the\nnumber of pairs of nodes over which we have to compute White and Newman\u2019s\napproximation algorithm for finding node independent paths [2] . More\nformally, this algorithm is based on Whitney\u2019s theorem, which states\nan inclusion relation among node connectivity, edge connectivity, and\nminimum degree for any graph G. This theorem implies that every k -component is nested inside a k -edge-component, which in turn,\nis contained in a k -core. Thus, this algorithm computes node independent\npaths among pairs of nodes in each biconnected part of each k -core,\nand repeats this procedure for each k from 3 to the maximal core number\nof a node in the input graph. Because, in practice, many nodes of the core of level k inside a\nbicomponent actually are part of a component of level k, the auxiliary\ngraph needed for the algorithm is likely to be very dense. Thus, we use\na complement graph data structure (see AntiGraph ) to save memory.\nAntiGraph only stores information of the edges that are not present\nin the actual auxiliary graph. When applying algorithms to this\ncomplement graph data structure, it behaves as if it were the dense\nversion.",
            "References": "[1](1,2)Torrents, J. and F. Ferraro (2015) Structural Cohesion:\nVisualization and Heuristics for Fast Computation.https://arxiv.org/pdf/1503.04476v1  [2](1,2)White, Douglas R., and Mark Newman (2001) A Fast Algorithm for\nNode-Independent Paths. Santa Fe Institute Working Paper #01-07-035https://www.santafe.edu/research/results/working-papers/fast-approximation-algorithms-for-finding-node-ind  [3]Moody, J. and D. White (2003). Social cohesion and embeddedness:\nA hierarchical conception of social groups.\nAmerican Sociological Review 68(1), 103\u201328.https://doi.org/10.2307/3088904",
            "Examples": "# Petersen graph has 10 nodes and it is triconnected, thus all\n# nodes are in a single component on all three connectivity levels\nfromnetworkx.algorithmsimportapproximationasapxa\nG=nx.petersen_graph()\nk_components=apxa.k_components(G)"
        }
    },
    {
        "Section ID": "label_propagation_communities",
        "Description": [
            "Generates community sets determined by label propagation",
            "Finds communities in G using a semi-synchronous label propagation\nmethod [1] . This method combines the advantages of both the synchronous\nand asynchronous models. Not implemented for directed graphs."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "An undirected NetworkX graph."
            },
            "Returns:": {
                "communities : iterable": "A dict_values object that contains a set of nodes for each community."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the graph is directed"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Cordasco, G., & Gargano, L. (2010, December). Community detection\nvia semi-synchronous label propagation algorithms. In Business\nApplications of Social Network Analysis (BASNA), 2010 IEEE International\nWorkshop on (pp. 1-8). IEEE."
        }
    },
    {
        "Section ID": "dijkstra_path",
        "Description": [
            "Returns the shortest weighted path from source to target in G.",
            "Uses Dijkstra\u2019s Method to compute the shortest weighted path\nbetween two nodes in a graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node": "Starting node",
                "target : node": "Ending node",
                "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge."
            },
            "Returns:": {
                "path : list": "List of nodes in a shortest path."
            },
            "Raises:": {
                "NodeNotFound": "Ifsourceis not inG.",
                "NetworkXNoPath": "If no path exists between source and target."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The weight function can be used to hide edges by returning None.\nSo weight=lambdau,v,d:1ifd['color']==\"red\"elseNone will find the shortest red path. The weight function can be used to include node weights.",
            "Examples": "G=nx.path_graph(5)\nprint(nx.dijkstra_path(G,0,4))\n# [0, 1, 2, 3, 4]\nFind edges of shortest path in Multigraph\nG=nx.MultiDiGraph()\nG.add_weighted_edges_from([(1,2,0.75),(1,2,0.5),(2,3,0.5),(1,3,1.5)])\nnodes=nx.dijkstra_path(G,1,3)\nedges=nx.utils.pairwise(nodes)\nlist(\n(u,v,min(G[u][v],key=lambdak:G[u][v][k].get(\"weight\",1)))\nforu,vinedges\n)\n# [(1, 2, 1), (2, 3, 0)]"
        }
    },
    {
        "Section ID": "biconnected_component_edges",
        "Description": [
            "Returns a generator of lists of edges, one list for each biconnected\ncomponent of the input graph.",
            "Biconnected components are maximal subgraphs such that the removal of a\nnode (and all edges incident on that node) will not disconnect the\nsubgraph.  Note that nodes may be part of more than one biconnected\ncomponent.  Those nodes are articulation points, or cut vertices.\nHowever, each edge belongs to one, and only one, biconnected component.",
            "Notice that by convention a dyad is considered a biconnected component."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "An undirected graph."
            },
            "Returns:": {
                "edges : generator of lists": "Generator of lists of edges, one list for each bicomponent."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the input graph is not undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The algorithm to find articulation points and biconnected\ncomponents is implemented using a non-recursive depth-first-search\n(DFS) that keeps track of the highest level that back edges reach\nin the DFS tree.  A node n is an articulation point if, and only\nif, there exists a subtree rooted at n such that there is no\nback edge from any successor of n that links to a predecessor of n in the DFS tree.  By keeping track of all the edges traversed\nby the DFS we can obtain the biconnected components because all\nedges of a bicomponent will be traversed consecutively between\narticulation points.",
            "References": "[1]Hopcroft, J.; Tarjan, R. (1973).\n\u201cEfficient algorithms for graph manipulation\u201d.\nCommunications of the ACM 16: 372\u2013378. doi:10.1145/362248.362272",
            "Examples": "G=nx.barbell_graph(4,2)\nprint(nx.is_biconnected(G))\n# False\nbicomponents_edges=list(nx.biconnected_component_edges(G))\nlen(bicomponents_edges)\n# 5\nG.add_edge(2,8)\nprint(nx.is_biconnected(G))\n# True\nbicomponents_edges=list(nx.biconnected_component_edges(G))\nlen(bicomponents_edges)\n# 1"
        }
    },
    {
        "Section ID": "asyn_fluidc",
        "Description": [
            "Returns communities in G as detected by Fluid Communities algorithm.",
            "The asynchronous fluid communities algorithm is described in [1] . The algorithm is based on the simple idea of fluids interacting\nin an environment, expanding and pushing each other. Its initialization is\nrandom, so found communities may vary on different executions.",
            "The algorithm proceeds as follows. First each of the initial k communities\nis initialized in a random vertex in the graph. Then the algorithm iterates\nover all vertices in a random order, updating the community of each vertex\nbased on its own community and the communities of its neighbors. This\nprocess is performed several times until convergence.\nAt all times, each community has a total density of 1, which is equally\ndistributed among the vertices it contains. If a vertex changes of\ncommunity, vertex densities of affected communities are adjusted\nimmediately. When a complete iteration over all vertices is done, such that\nno vertex changes the community it belongs to, the algorithm has converged\nand returns.",
            "This is the original version of the algorithm described in [1] .\nUnfortunately, it does not support weighted graphs yet."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Graph must be simple and undirected.",
                "k : integer": "The number of communities to be found.",
                "max_iter : integer": "The number of maximum iterations allowed. By default 100.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "communities : iterable": "Iterable of communities given as sets of nodes."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "k variable is not an optional argument.",
            "References": "[1](1,2)Par\u00e9s F., Garcia-Gasulla D. et al. \u201cFluid Communities: A\nCompetitive and Highly Scalable Community Detection Algorithm\u201d.\n[https://arxiv.org/pdf/1703.09307.pdf]."
        }
    },
    {
        "Section ID": "is_valid_degree_sequence_erdos_gallai",
        "Description": [
            "Returns True if deg_sequence can be realized by a simple graph.",
            "The validation is done using the Erd\u0151s-Gallai theorem [EG1960] ."
        ],
        "Field List": {
            "Parameters:": {
                "deg_sequence : list": "A list of integers"
            },
            "Returns:": {
                "valid : bool": "True if deg_sequence is graphical and False if not."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This implementation uses an equivalent form of the Erd\u0151s-Gallai criterion.\nWorst-case run time is \\(O(n)\\) where \\(n\\) is the length of the sequence. Specifically, a sequence d is graphical if and only if the\nsum of the sequence is even and for all strong indices k in the sequence,",
            "References": "[1]A. Tripathi and S. Vijay. \u201cA note on a theorem of Erd\u0151s & Gallai\u201d,\nDiscrete Mathematics, 265, pp. 417-420 (2003).  [2](1,2)I.E. Zverovich and V.E. Zverovich. \u201cContributions to the theory\nof graphic sequences\u201d, Discrete Mathematics, 105, pp. 292-303 (1992).  [EG1960]Erd\u0151s and Gallai, Mat. Lapok 11 264, 1960.",
            "Examples": "G=nx.Graph([(1,2),(1,3),(2,3),(3,4),(4,2),(5,1),(5,4)])\nsequence=(dfor_,dinG.degree())\nnx.is_valid_degree_sequence_erdos_gallai(sequence)\n# True\nTo test a non-valid sequence:\n>>> sequence_list = [d for _, d in G.degree()]\n>>> sequence_list[-1] += 1\n>>> nx.is_valid_degree_sequence_erdos_gallai(sequence_list)\nFalse"
        }
    },
    {
        "Section ID": "maximal_independent_set",
        "Description": [
            "Returns a random maximal independent set guaranteed to contain\na given set of nodes.",
            "An independent set is a set of nodes such that the subgraph\nof G induced by these nodes contains no edges. A maximal\nindependent set is an independent set such that it is not possible\nto add a new node and still get an independent set."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "nodes : list or iterable": "Nodes that must be part of the independent set. This set of nodes\nmust be independent.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "indep_nodes : list": "List of nodes that are part of a maximal independent set."
            },
            "Raises:": {
                "NetworkXUnfeasible": "If the nodes in the provided list are not part of the graph or\ndo not form an independent set, an exception is raised.",
                "NetworkXNotImplemented": "IfGis directed."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm does not solve the maximum independent set problem.",
            "Examples": "G=nx.path_graph(5)\nnx.maximal_independent_set(G)\n# [4, 0, 2]\nnx.maximal_independent_set(G,[1])\n# [1, 3]"
        }
    },
    {
        "Section ID": "group_out_degree_centrality",
        "Description": [
            "Compute the group out-degree centrality for a group of nodes.",
            "Group out-degree centrality of a group of nodes \\(S\\) is the fraction\nof non-group members connected to group members by outgoing edges."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.",
                "S : list or set": "S is a group of nodes which belong to G, for which group in-degree\ncentrality is to be calculated."
            },
            "Returns:": {
                "centrality : float": "Group out-degree centrality of the group S."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is undirected.",
                "NodeNotFound": "If node(s) in S are not in G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The number of nodes in the group must be a maximum of n - 1 where n is the total number of nodes in the graph. G.neighbors(i) gives nodes with an outward edge from i, in a DiGraph,\nso for group out-degree centrality, the graph itself is used."
        }
    },
    {
        "Section ID": "adjacency_spectrum",
        "Description": [
            "Returns eigenvalues of the adjacency matrix of G."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "weight : string or None, optional (default=\u2019weight\u2019)": "The edge data key used to compute each value in the matrix.\nIf None, then each edge has weight 1."
            },
            "Returns:": {
                "evals : NumPy array": "Eigenvalues"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For MultiGraph/MultiDiGraph, the edges weights are summed.\nSee to_numpy_array for other options."
        }
    },
    {
        "Section ID": "local_and_global_consistency",
        "Description": [
            "Node classification by Local and Global Consistency",
            "Function for computing Local and global consistency algorithm by Zhou et al."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "",
                "alpha : float": "Clamping factor",
                "max_iter : int": "Maximum number of iterations allowed",
                "label_name : string": "Name of target labels to predict"
            },
            "Returns:": {
                "predicted : list": "List of lengthlen(G)with the predicted labels for each node."
            },
            "Raises:": {
                "NetworkXError": "If no nodes inGhave attributelabel_name."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "Zhou, D., Bousquet, O., Lal, T. N., Weston, J., & Sch\u00f6lkopf, B. (2004).\nLearning with local and global consistency.\nAdvances in neural information processing systems, 16(16), 321-328.",
            "Examples": "fromnetworkx.algorithmsimportnode_classification\nG=nx.path_graph(4)\nG.nodes[0][\"label\"]=\"A\"\nG.nodes[3][\"label\"]=\"B\"\nG.nodes(data=True)\n# NodeDataView({0: {'label': 'A'}, 1: {}, 2: {}, 3: {'label': 'B'}})\nG.edges()\n# EdgeView([(0, 1), (1, 2), (2, 3)])\npredicted=node_classification.local_and_global_consistency(G)\npredicted\n# ['A', 'A', 'B', 'B']"
        }
    },
    {
        "Section ID": "read_dot",
        "Description": [
            "Returns a NetworkX graph from a dot file on path."
        ],
        "Field List": {
            "Parameters:": {
                "path : file or string": "File name or file handle to read."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "moebius_kantor_graph",
        "Description": [
            "Returns the Moebius-Kantor graph.",
            "The M\u00f6bius-Kantor graph is the cubic symmetric graph on 16 nodes.\nIts LCF notation is [5,-5]^8, and it is isomorphic to the generalized\nPetersen graph [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : networkx Graph": "Moebius-Kantor graph"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://en.wikipedia.org/wiki/M%C3%B6bius%E2%80%93Kantor_graph"
        }
    },
    {
        "Section ID": "is_arborescence",
        "Description": [
            "Returns True if G is an arborescence.",
            "An arborescence is a directed tree with maximum in-degree equal to 1."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "The graph to test."
            },
            "Returns:": {
                "b : bool": "A boolean that is True ifGis an arborescence."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "In another convention, an arborescence is known as a tree .",
            "Examples": "G=nx.DiGraph([(0,1),(0,2),(2,3),(3,4)])\nnx.is_arborescence(G)\n# True\nG.remove_edge(0,1)\nG.add_edge(1,2)# maximum in-degree is 2\nnx.is_arborescence(G)\n# False"
        }
    },
    {
        "Section ID": "ramsey_R2",
        "Description": [
            "Compute the largest clique and largest independent set in G .",
            "This can be used to estimate bounds for the 2-color\nRamsey number R(2;s,t) for G .",
            "This is a recursive implementation which could run into trouble\nfor large recursions. Note that self-loop edges are ignored."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected graph"
            },
            "Returns:": {
                "max_pair : (set, set) tuple": "Maximum clique, Maximum independent set."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the graph is directed or is a multigraph."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "is_distance_regular",
        "Description": [
            "Returns True if the graph is distance regular, False otherwise.",
            "A connected graph G is distance-regular if for any nodes x,y\nand any integers i,j=0,1,\u2026,d (where d is the graph\ndiameter), the number of vertices at distance i from x and\ndistance j from y depends only on i,j and the graph distance\nbetween x and y, independently of the choice of x and y."
        ],
        "Field List": {
            "Parameters:": {
                "G: Networkx graph (undirected)": ""
            },
            "Returns:": {
                "bool": "True if the graph is Distance Regular, False otherwise"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For undirected and simple graphs only",
            "References": "[1]Brouwer, A. E.; Cohen, A. M.; and Neumaier, A.\nDistance-Regular Graphs. New York: Springer-Verlag, 1989.  [2]Weisstein, Eric W. \u201cDistance-Regular Graph.\u201dhttp://mathworld.wolfram.com/Distance-RegularGraph.html",
            "Examples": "G=nx.hypercube_graph(6)\nnx.is_distance_regular(G)\n# True"
        }
    },
    {
        "Section ID": "write_latex",
        "Description": [
            "Write the latex code to draw the graph(s) onto path .",
            "This convenience function creates the latex drawing code as a string\nand writes that to a file ready to be compiled when as_document is True\nor ready to be import ed or include ed into your main LaTeX document.",
            "The path argument can be a string filename or a file handle to write to."
        ],
        "Field List": {
            "Parameters:": {
                "Gbunch : NetworkX graph or iterable of NetworkX graphs": "If Gbunch is a graph, it is drawn in a figure environment.\nIf Gbunch is an iterable of graphs, each is drawn in a subfigure\nenvironment within a single figure environment.",
                "path : filename": "Filename or file handle to write to",
                "options : dict": "By default, TikZ is used with options: (others are ignored):pos : string or dict or list\n    The name of the node attribute on `G` that holds the position of each node.\n    Positions can be sequences of length 2 with numbers for (x,y) coordinates.\n    They can also be strings to denote positions in TikZ style, such as (x, y)\n    or (angle:radius).\n    If a dict, it should be keyed by node to a position.\n    If an empty dict, a circular layout is computed by TikZ.\n    If you are drawing many graphs in subfigures, use a list of position dicts.\ntikz_options : string\n    The tikzpicture options description defining the options for the picture.\n    Often large scale options like `[scale=2]`.\ndefault_node_options : string\n    The draw options for a path of nodes. Individual node options override these.\nnode_options : string or dict\n    The name of the node attribute on `G` that holds the options for each node.\n    Or a dict keyed by node to a string holding the options for that node.\nnode_label : string or dict\n    The name of the node attribute on `G` that holds the node label (text)\n    displayed for each node. If the attribute is \"\" or not present, the node\n    itself is drawn as a string. LaTeX processing such as ``\"$A_1$\"`` is allowed.\n    Or a dict keyed by node to a string holding the label for that node.\ndefault_edge_options : string\n    The options for the scope drawing all edges. The default is \"[-]\" for\n    undirected graphs and \"[->]\" for directed graphs.\nedge_options : string or dict\n    The name of the edge attribute on `G` that holds the options for each edge.\n    If the edge is a self-loop and ``\"loop\" not in edge_options`` the option\n    \"loop,\" is added to the options for the self-loop edge. Hence you can\n    use \"[loop above]\" explicitly, but the default is \"[loop]\".\n    Or a dict keyed by edge to a string holding the options for that edge.\nedge_label : string or dict\n    The name of the edge attribute on `G` that holds the edge label (text)\n    displayed for each edge. If the attribute is \"\" or not present, no edge\n    label is drawn.\n    Or a dict keyed by edge to a string holding the label for that edge.\nedge_label_options : string or dict\n    The name of the edge attribute on `G` that holds the label options for\n    each edge. For example, \"[sloped,above,blue]\". The default is no options.\n    Or a dict keyed by edge to a string holding the label options for that edge.\ncaption : string\n    The caption string for the figure environment\nlatex_label : string\n    The latex label used for the figure for easy referral from the main text\nsub_captions : list of strings\n    The sub_caption string for each subfigure in the figure\nsub_latex_labels : list of strings\n    The latex label for each subfigure in the figure\nn_rows : int\n    The number of rows of subfigures to arrange for multiple graphs\nas_document : bool\n    Whether to wrap the latex code in a document environment for compiling\ndocument_wrapper : formatted text string with variable ``content``.\n    This text is called to evaluate the content embedded in a document\n    environment with a preamble setting up the TikZ syntax.\nfigure_wrapper : formatted text string\n    This text is evaluated with variables ``content``, ``caption`` and ``label``.\n    It wraps the content and if a caption is provided, adds the latex code for\n    that caption, and if a label is provided, adds the latex code for a label.\nsubfigure_wrapper : formatted text string\n    This text evaluate variables ``size``, ``content``, ``caption`` and ``label``.\n    It wraps the content and if a caption is provided, adds the latex code for\n    that caption, and if a label is provided, adds the latex code for a label.\n    The size is the vertical size of each row of subfigures as a fraction."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "chain_decomposition",
        "Description": [
            "Returns the chain decomposition of a graph.",
            "The chain decomposition of a graph with respect a depth-first\nsearch tree is a set of cycles or paths derived from the set of\nfundamental cycles of the tree in the following manner. Consider\neach fundamental cycle with respect to the given tree, represented\nas a list of edges beginning with the nontree edge oriented away\nfrom the root of the tree. For each fundamental cycle, if it\noverlaps with any previous fundamental cycle, just take the initial\nnon-overlapping segment, which is a path instead of a cycle. Each\ncycle or path is called a chain . For more information, see [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : undirected graph": "",
                "root : node (optional)": "A node in the graphG. If specified, only the chain\ndecomposition for the connected component containing this node\nwill be returned. This node indicates the root of the depth-first\nsearch tree."
            },
            "Yields:": {
                "chain : list": "A list of edges representing a chain. There is no guarantee on\nthe orientation of the edges in each chain (for example, if a\nchain includes the edge joining nodes 1 and 2, the chain may\ninclude either (1, 2) or (2, 1))."
            },
            "Raises:": {
                "NodeNotFound": "Ifrootis not in the graphG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The worst-case running time of this implementation is linear in the\nnumber of nodes and number of edges [1] .",
            "References": "[1](1,2)Jens M. Schmidt (2013). \u201cA simple test on 2-vertex-\nand 2-edge-connectivity.\u201dInformation Processing Letters,\n113, 241\u2013244. Elsevier. <https://doi.org/10.1016/j.ipl.2013.01.016>",
            "Examples": "G=nx.Graph([(0,1),(1,4),(3,4),(3,5),(4,5)])\nlist(nx.chain_decomposition(G))\n# [[(4, 5), (5, 3), (3, 4)]]"
        }
    },
    {
        "Section ID": "strategy_connected_sequential",
        "Description": [
            "Returns an iterable over nodes in G in the order given by a\nbreadth-first or depth-first traversal.",
            "traversal must be one of the strings 'dfs' or 'bfs' ,\nrepresenting depth-first traversal or breadth-first traversal,\nrespectively.",
            "The generated sequence has the property that for each node except\nthe first, at least one neighbor appeared earlier in the sequence.",
            "G is a NetworkX graph. colors is ignored."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "draw",
        "Description": [
            "Draw the graph G with Matplotlib.",
            "Draw the graph as a simple representation with no node\nlabels or edge labels and using the full Matplotlib figure area\nand no axis labels by default.  See draw_networkx() for more\nfull-featured drawing that allows title, axis labels etc."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph",
                "pos : dictionary, optional": "A dictionary with nodes as keys and positions as values.\nIf not specified a spring layout positioning will be computed.\nSeenetworkx.drawing.layoutfor functions that\ncompute node positions.",
                "ax : Matplotlib Axes object, optional": "Draw the graph in specified Matplotlib axes.",
                "kwds : optional keywords": "See networkx.draw_networkx() for a description of optional keywords."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This function has the same name as pylab.draw and pyplot.draw\nso beware when using fromnetworkximport* since you might overwrite the pylab.draw function. With pyplot use",
            "Examples": "G=nx.dodecahedral_graph()\nnx.draw(G)\nnx.draw(G,pos=nx.spring_layout(G))# use spring layout"
        }
    },
    {
        "Section ID": "intersection",
        "Description": [
            "Returns a new graph that contains only the nodes and the edges that exist in\nboth G and H."
        ],
        "Field List": {
            "Parameters:": {
                "G,H : graph": "A NetworkX graph. G and H can have different node sets but must be both graphs or both multigraphs."
            },
            "Returns:": {
                "GH : A new graph with the same type as G.": ""
            },
            "Raises:": {
                "NetworkXError": "If one is a MultiGraph and the other one is a graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Attributes from the graph, nodes, and edges are not copied to the new\ngraph.  If you want a new graph of the intersection of G and H\nwith the attributes (including edge data) from G use remove_nodes_from()\nas follows",
            "Examples": "G=nx.Graph([(0,1),(0,2),(1,2)])\nH=nx.Graph([(0,3),(1,2),(2,3)])\nR=nx.intersection(G,H)\nR.nodes\n# NodeView((0, 1, 2))\nR.edges\n# EdgeView([(1, 2)])"
        }
    },
    {
        "Section ID": "k_edge_augmentation",
        "Description": [
            "Finds set of edges to k-edge-connect G.",
            "Adding edges from the augmentation to G make it impossible to disconnect G\nunless k or more edges are removed. This function uses the most efficient\nfunction available (depending on the value of k and if the problem is\nweighted or unweighted) to search for a minimum weight subset of available\nedges that k-edge-connects G. In general, finding a k-edge-augmentation is\nNP-hard, so solutions are not guaranteed to be minimal. Furthermore, a\nk-edge-augmentation may not exist."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "An undirected graph.",
                "k : integer": "Desired edge connectivity",
                "avail : dict or a set of 2 or 3 tuples": "The available edges that can be used in the augmentation.If unspecified, then all edges in the complement of G are available.\nOtherwise, each item is an available edge (with an optional weight).In the unweighted case, each item is an edge(u,v).In the weighted case, each item is a 3-tuple(u,v,d)or a dict\nwith items(u,v):d.  The third item,d, can be a dictionary\nor a real number.  Ifdis a dictionaryd[weight]correspondings to the weight.",
                "weight : string": "key to use to find weights ifavailis a set of 3-tuples where the\nthird item in each tuple is a dictionary.",
                "partial : boolean": "If partial is True and no feasible k-edge-augmentation exists, then all\na partial k-edge-augmentation is generated. Adding the edges in a\npartial augmentation to G, minimizes the number of k-edge-connected\ncomponents and maximizes the edge connectivity between those\ncomponents. For details, seepartial_k_edge_augmentation()."
            },
            "Yields:": {
                "edge : tuple": "Edges that, once added to G, would cause G to become k-edge-connected.\nIf partial is False, an error is raised if this is not possible.\nOtherwise, generated edges form a partial augmentation, which\nk-edge-connects any part of G where it is possible, and maximally\nconnects the remaining parts."
            },
            "Raises:": {
                "NetworkXUnfeasible": "If partial is False and no k-edge-augmentation exists.",
                "NetworkXNotImplemented": "If the input graph is directed or a multigraph.",
                "ValueError:": "If k is less than 1"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "When k=1 this returns an optimal solution. When k=2 and avail is None, this returns an optimal solution.\nOtherwise when k=2, this returns a 2-approximation of the optimal solution.",
            "Examples": "# Unweighted cases\nG=nx.path_graph((1,2,3,4))\nG.add_node(5)\nsorted(nx.k_edge_augmentation(G,k=1))\n# [(1, 5)]\nsorted(nx.k_edge_augmentation(G,k=2))\n# [(1, 5), (5, 4)]\nsorted(nx.k_edge_augmentation(G,k=3))\n# [(1, 4), (1, 5), (2, 5), (3, 5), (4, 5)]\ncomplement=list(nx.k_edge_augmentation(G,k=5,partial=True))\nG.add_edges_from(complement)\nnx.edge_connectivity(G)\n# 4\n# Weighted cases\nG=nx.path_graph((1,2,3,4))\nG.add_node(5)\n# avail can be a tuple with a dict\navail=[(1,5,{\"weight\":11}),(2,5,{\"weight\":10})]\nsorted(nx.k_edge_augmentation(G,k=1,avail=avail,weight=\"weight\"))\n# [(2, 5)]\n# or avail can be a 3-tuple with a real number\navail=[(1,5,11),(2,5,10),(4,3,1),(4,5,51)]\nsorted(nx.k_edge_augmentation(G,k=2,avail=avail))\n# [(1, 5), (2, 5), (4, 5)]\n# or avail can be a dict\navail={(1,5):11,(2,5):10,(4,3):1,(4,5):51}\nsorted(nx.k_edge_augmentation(G,k=2,avail=avail))\n# [(1, 5), (2, 5), (4, 5)]\n# If augmentation is infeasible, then a partial solution can be found\navail={(1,5):11}\nsorted(nx.k_edge_augmentation(G,k=2,avail=avail,partial=True))\n# [(1, 5)]"
        }
    },
    {
        "Section ID": "petersen_graph",
        "Description": [
            "Returns the Petersen graph.",
            "The Peterson graph is a cubic, undirected graph with 10 nodes and 15 edges [1] .\nJulius Petersen constructed the graph as the smallest counterexample\nagainst the claim that a connected bridgeless cubic graph\nhas an edge colouring with three colours [2] ."
        ],
        "Field List": {
            "Parameters:": {
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : networkx Graph": "Petersen graph"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://en.wikipedia.org/wiki/Petersen_graph  [2]https://www.win.tue.nl/~aeb/drg/graphs/Petersen.html"
        }
    },
    {
        "Section ID": "score_sequence",
        "Description": [
            "Returns the score sequence for the given tournament graph.",
            "The score sequence is the sorted list of the out-degrees of the\nnodes of the graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A directed graph representing a tournament."
            },
            "Returns:": {
                "list": "A sorted list of the out-degrees of the nodes ofG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.DiGraph([(1,0),(1,3),(0,2),(0,3),(2,1),(3,2)])\nnx.is_tournament(G)\n# True\nnx.tournament.score_sequence(G)\n# [1, 1, 2, 2]"
        }
    },
    {
        "Section ID": "clique_removal",
        "Description": [
            "Repeatedly remove cliques from the graph.",
            "Results in a \\(O(|V|/(\\log |V|)^2)\\) approximation of maximum clique\nand independent set. Returns the largest independent set found, along\nwith found maximal cliques."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected graph"
            },
            "Returns:": {
                "max_ind_cliques : (set, list) tuple": "2-tuple of Maximal Independent Set and list of maximal cliques (sets)."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the graph is directed or is a multigraph."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Boppana, R., & Halld\u00f3rsson, M. M. (1992).\nApproximating maximum independent sets by excluding subgraphs.\nBIT Numerical Mathematics, 32(2), 180\u2013196. Springer.",
            "Examples": "G=nx.path_graph(10)\nnx.approximation.clique_removal(G)\n# ({0, 2, 4, 6, 9}, [{0, 1}, {2, 3}, {4, 5}, {6, 7}, {8, 9}])"
        }
    },
    {
        "Section ID": "all_pairs_dijkstra",
        "Description": [
            "Find shortest weighted paths and lengths between all nodes."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "cutoff : integer or float, optional": "Length (sum of edge weights) at which the search is stopped.\nIf cutoff is provided, only return paths with summed weight <= cutoff.",
                "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edge[u][v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge."
            },
            "Yields:": {
                "(node, (distance, path)) : (node obj, (dict, dict))": "Each source node has two associated dicts. The first holds distance\nkeyed by target and the second holds paths keyed by target.\n(See single_source_dijkstra for the source/target node terminology.)\nIf desired you can applydict()to this function to create a dict\nkeyed by source node to the two dicts."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The yielded dicts only have keys for reachable nodes.",
            "Examples": "G=nx.path_graph(5)\nlen_path=dict(nx.all_pairs_dijkstra(G))\nlen_path[3][0][1]\n# 2\nfornodein[0,1,2,3,4]:\nprint(f\"3 - {node}: {len_path[3][0][node]}\")\n# 3 - 0: 3\n# 3 - 1: 2\n# 3 - 2: 1\n# 3 - 3: 0\n# 3 - 4: 1\nlen_path[3][1][1]\n# [3, 2, 1]\nforn,(dist,path)innx.all_pairs_dijkstra(G):\nprint(path[1])\n# [0, 1]\n# [1]\n# [2, 1]\n# [3, 2, 1]\n# [4, 3, 2, 1]"
        }
    },
    {
        "Section ID": "random_labeled_rooted_tree",
        "Description": [
            "Returns a labeled rooted tree with n nodes.",
            "The returned tree is chosen uniformly at random from all labeled rooted trees."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "networkx.Graph": "Anetworkx.Graphwith integer nodes 0 <= node <=n- 1.\nThe root of the tree is selected uniformly from the nodes.\nThe \u201croot\u201d graph attribute identifies the root of the tree."
            },
            "Raises:": {
                "NetworkXPointlessConcept": "Ifnis zero (because the null graph is not a tree)."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This function returns the result of random_labeled_tree() with a randomly selected root."
        }
    },
    {
        "Section ID": "maximum_spanning_tree",
        "Description": [
            "Returns a maximum spanning tree or forest on an undirected graph G ."
        ],
        "Field List": {
            "Parameters:": {
                "G : undirected graph": "An undirected graph. IfGis connected, then the algorithm finds a\nspanning tree. Otherwise, a spanning forest is found.",
                "weight : str": "Data key to use for edge weights.",
                "algorithm : string": "The algorithm to use when finding a maximum spanning tree. Valid\nchoices are \u2018kruskal\u2019, \u2018prim\u2019, or \u2018boruvka\u2019. The default is\n\u2018kruskal\u2019.",
                "ignore_nan : bool (default: False)": "If a NaN is found as an edge weight normally an exception is raised.\nIfignore_nanisTruethen that edge is ignored instead."
            },
            "Returns:": {
                "G : NetworkX Graph": "A maximum spanning tree or forest."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For Bor\u016fvka\u2019s algorithm, each edge must have a weight attribute, and\neach edge weight must be distinct. For the other algorithms, if the graph edges do not have a weight\nattribute a default weight of 1 will be used. There may be more than one tree with the same minimum or maximum weight.\nSee networkx.tree.recognition for more detailed definitions. Isolated nodes with self-loops are in the tree as edgeless isolated nodes.",
            "Examples": "G=nx.cycle_graph(4)\nG.add_edge(0,3,weight=2)\nT=nx.maximum_spanning_tree(G)\nsorted(T.edges(data=True))\n# [(0, 1, {}), (0, 3, {'weight': 2}), (1, 2, {})]"
        }
    },
    {
        "Section ID": "edge_dfs",
        "Description": [
            "A directed, depth-first-search of edges in G , beginning at source .",
            "Yield the edges of G in a depth-first-search order continuing until\nall edges are generated."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A directed/undirected graph/multigraph.",
                "source : node, list of nodes": "The node from which the traversal begins. If None, then a source\nis chosen arbitrarily and repeatedly until all edges from each node in\nthe graph are searched.",
                "orientation : None | \u2018original\u2019 | \u2018reverse\u2019 | \u2018ignore\u2019 (default: None)": "For directed graphs and directed multigraphs, edge traversals need not\nrespect the original orientation of the edges.\nWhen set to \u2018reverse\u2019 every edge is traversed in the reverse direction.\nWhen set to \u2018ignore\u2019, every edge is treated as undirected.\nWhen set to \u2018original\u2019, every edge is treated as directed.\nIn all three cases, the yielded edge tuples add a last entry to\nindicate the direction in which that edge was traversed.\nIf orientation is None, the yielded edge has no direction indicated.\nThe direction is respected, but not reported."
            },
            "Yields:": {
                "edge : directed edge": "A directed edge indicating the path taken by the depth-first traversal.\nFor graphs,edgeis of the form(u,v)whereuandvare the tail and head of the edge as determined by the traversal.\nFor multigraphs,edgeis of the form(u,v,key), wherekeyis\nthe key of the edge. When the graph is directed, thenuandvare always in the order of the actual directed edge.\nIf orientation is not None then the edge tuple is extended to include\nthe direction of traversal (\u2018forward\u2019 or \u2018reverse\u2019) on that edge."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The goal of this function is to visit edges. It differs from the more\nfamiliar depth-first traversal of nodes, as provided by dfs_edges() , in\nthat it does not stop once every node has been visited. In a directed graph\nwith edges [(0, 1), (1, 2), (2, 1)], the edge (2, 1) would not be visited\nif not for the functionality provided by this function.",
            "Examples": "nodes=[0,1,2,3]\nedges=[(0,1),(1,0),(1,0),(2,1),(3,1)]\nlist(nx.edge_dfs(nx.Graph(edges),nodes))\n# [(0, 1), (1, 2), (1, 3)]\nlist(nx.edge_dfs(nx.DiGraph(edges),nodes))\n# [(0, 1), (1, 0), (2, 1), (3, 1)]\nlist(nx.edge_dfs(nx.MultiGraph(edges),nodes))\n# [(0, 1, 0), (1, 0, 1), (0, 1, 2), (1, 2, 0), (1, 3, 0)]\nlist(nx.edge_dfs(nx.MultiDiGraph(edges),nodes))\n# [(0, 1, 0), (1, 0, 0), (1, 0, 1), (2, 1, 0), (3, 1, 0)]\nlist(nx.edge_dfs(nx.DiGraph(edges),nodes,orientation=\"ignore\"))\n# [(0, 1, 'forward'), (1, 0, 'forward'), (2, 1, 'reverse'), (3, 1, 'reverse')]\nlist(nx.edge_dfs(nx.MultiDiGraph(edges),nodes,orientation=\"ignore\"))\n# [(0, 1, 0, 'forward'), (1, 0, 0, 'forward'), (1, 0, 1, 'reverse'), (2, 1, 0, 'reverse'), (3, 1, 0, 'reverse')]"
        }
    },
    {
        "Section ID": "prefix_tree",
        "Description": [
            "Creates a directed prefix tree from a list of paths.",
            "Usually the paths are described as strings or lists of integers.",
            "A \u201cprefix tree\u201d represents the prefix structure of the strings.\nEach node represents a prefix of some string. The root represents\nthe empty prefix with children for the single letter prefixes which\nin turn have children for each double letter prefix starting with\nthe single letter corresponding to the parent node, and so on.",
            "More generally the prefixes do not need to be strings. A prefix refers\nto the start of a sequence. The root has children for each one element\nprefix and they have children for each two element prefix that starts\nwith the one element sequence of the parent, and so on.",
            "Note that this implementation uses integer nodes with an attribute.\nEach node has an attribute \u201csource\u201d whose value is the original element\nof the path to which this node corresponds. For example, suppose paths consists of one path: \u201ccan\u201d. Then the nodes [1,2,3] which represent\nthis path have \u201csource\u201d values \u201cc\u201d, \u201ca\u201d and \u201cn\u201d.",
            "All the descendants of a node have a common prefix in the sequence/path\nassociated with that node. From the returned tree, the prefix for each\nnode can be constructed by traversing the tree up to the root and\naccumulating the \u201csource\u201d values along the way.",
            "The root node is always 0 and has \u201csource\u201d attribute None .\nThe root is the only node with in-degree zero.\nThe nil node is always -1 and has \u201csource\u201d attribute \"NIL\" .\nThe nil node is the only node with out-degree zero."
        ],
        "Field List": {
            "Parameters:": {
                "paths: iterable of paths": "An iterable of paths which are themselves sequences.\nMatching prefixes among these sequences are identified with\nnodes of the prefix tree. One leaf of the tree is associated\nwith each path. (Identical paths are associated with the same\nleaf of the tree.)"
            },
            "Returns:": {
                "tree: DiGraph": "A directed graph representing an arborescence consisting of the\nprefix tree generated bypaths. Nodes are directed \u201cdownward\u201d,\nfrom parent to child. A special \u201csynthetic\u201d root node is added\nto be the parent of the first node in each path. A special\n\u201csynthetic\u201d leaf node, the \u201cnil\u201d node-1, is added to be the child\nof all nodes representing the last element in a path. (The\naddition of this nil node technically makes this not an\narborescence but a directed acyclic graph; removing the nil node\nmakes it an arborescence.)"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The prefix tree is also known as a trie .",
            "Examples": "Create a prefix tree from a list of strings with common prefixes:\npaths=[\"ab\",\"abs\",\"ad\"]\nT=nx.prefix_tree(paths)\nlist(T.edges)\n# [(0, 1), (1, 2), (1, 4), (2, -1), (2, 3), (3, -1), (4, -1)]\nThe leaf nodes can be obtained as predecessors of the nil node:\nroot,NIL=0,-1\nlist(T.predecessors(NIL))\n# [2, 3, 4]\nTo recover the original paths that generated the prefix tree,\ntraverse up the tree from the node-1to the node0:\nrecovered=[]\nforvinT.predecessors(NIL):\nprefix=\"\"\nwhilev!=root:\nprefix=str(T.nodes[v][\"source\"])+prefix\nv=next(T.predecessors(v))# only one predecessor\nrecovered.append(prefix)\nsorted(recovered)\n# ['ab', 'abs', 'ad']"
        }
    },
    {
        "Section ID": "non_edges",
        "Description": [
            "Returns the nonexistent edges in the graph."
        ],
        "Field List": {
            "Parameters:": {
                "graph : NetworkX graph.": "Graph to find nonexistent edges."
            },
            "Returns:": {
                "non_edges : iterator": "Iterator of edges that are not in the graph."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "hoffman_singleton_graph",
        "Description": [
            "Returns the Hoffman-Singleton Graph.",
            "The Hoffman\u2013Singleton graph is a symmetrical undirected graph\nwith 50 nodes and 175 edges.\nAll indices lie in Z%5 : that is, the integers mod 5 [1] .\nIt is the only regular graph of vertex degree 7, diameter 2, and girth 5.\nIt is the unique (7,5)-cage graph and Moore graph, and contains many\ncopies of the Petersen graph [2] ."
        ],
        "Field List": {
            "Returns:": {
                "G : networkx Graph": "Hoffman\u2013Singleton Graph with 50 nodes and 175 edges"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Constructed from pentagon and pentagram as follows: Take five pentagons \\(P_h\\) and five pentagrams \\(Q_i\\) . Join vertex \\(j\\) of \\(P_h\\) to vertex \\(h\u00b7i+j\\) of \\(Q_i\\)  [3] .",
            "References": "[1]https://blogs.ams.org/visualinsight/2016/02/01/hoffman-singleton-graph/  [2]https://mathworld.wolfram.com/Hoffman-SingletonGraph.html  [3]https://en.wikipedia.org/wiki/Hoffman%E2%80%93Singleton_graph"
        }
    },
    {
        "Section ID": "k_truss",
        "Description": [
            "Returns the k-truss of G .",
            "The k-truss is the maximal induced subgraph of G which contains at least\nthree vertices where every edge is incident to at least k-2 triangles."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "An undirected graph",
                "k : int": "The order of the truss"
            },
            "Returns:": {
                "H : NetworkX graph": "The k-truss subgraph"
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis a multigraph or directed graph or if it contains self loops."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "A k-clique is a (k-2)-truss and a k-truss is a (k+1)-core. Graph, node, and edge attributes are copied to the subgraph. K-trusses were originally defined in [2] which states that the k-truss\nis the maximal induced subgraph where each edge belongs to at least k-2 triangles. A more recent paper, [1], uses a slightly different\ndefinition requiring that each edge belong to at least k triangles.\nThis implementation uses the original definition of k-2 triangles.",
            "References": "[1]Bounds and Algorithms for k-truss. Paul Burkhardt, Vance Faber,\nDavid G. Harris, 2018.https://arxiv.org/abs/1806.05523v2  [2]Trusses: Cohesive Subgraphs for Social Network Analysis. Jonathan\nCohen, 2005.",
            "Examples": "degrees=[0,1,2,2,2,2,3]\nH=nx.havel_hakimi_graph(degrees)\nH.degree\n# DegreeView({0: 1, 1: 2, 2: 2, 3: 2, 4: 2, 5: 3, 6: 0})\nnx.k_truss(H,k=2).nodes\n# NodeView((0, 1, 2, 3, 4, 5))"
        }
    },
    {
        "Section ID": "is_k_regular",
        "Description": [
            "Determines whether the graph G is a k-regular graph.",
            "A k-regular graph is a graph where each vertex has degree k."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": ""
            },
            "Returns:": {
                "bool": "Whether the given graph is k-regular."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph([(1,2),(2,3),(3,4),(4,1)])\nnx.is_k_regular(G,k=3)\n# False"
        }
    },
    {
        "Section ID": "node_connected_component",
        "Description": [
            "Returns the set of nodes in the component of graph containing node n."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "An undirected graph.",
                "n : node label": "A node in G"
            },
            "Returns:": {
                "comp : set": "A set of nodes in the component of G containing node n."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is directed."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For undirected graphs only.",
            "Examples": "G=nx.Graph([(0,1),(1,2),(5,6),(3,4)])\nnx.node_connected_component(G,0)# nodes of component that contains node 0\n# {0, 1, 2}"
        }
    },
    {
        "Section ID": "floyd_warshall_predecessor_and_distance",
        "Description": [
            "Find all-pairs shortest path lengths using Floyd\u2019s algorithm."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "weight: string, optional (default= \u2018weight\u2019)": "Edge data key corresponding to the edge weight."
            },
            "Returns:": {
                "predecessor,distance : dictionaries": "Dictionaries, keyed by source and target, of predecessors and distances\nin the shortest path."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Floyd\u2019s algorithm is appropriate for finding shortest paths\nin dense graphs or graphs with negative weights when Dijkstra\u2019s algorithm\nfails.  This algorithm can still fail if there are negative cycles.\nIt has running time \\(O(n^3)\\) with running space of \\(O(n^2)\\) .",
            "Examples": "G=nx.DiGraph()\nG.add_weighted_edges_from(\n[\n(\"s\",\"u\",10),\n(\"s\",\"x\",5),\n(\"u\",\"v\",1),\n(\"u\",\"x\",2),\n(\"v\",\"y\",1),\n(\"x\",\"u\",3),\n(\"x\",\"v\",5),\n(\"x\",\"y\",2),\n(\"y\",\"s\",7),\n(\"y\",\"v\",6),\n]\n)\npredecessors,_=nx.floyd_warshall_predecessor_and_distance(G)\nprint(nx.reconstruct_path(\"s\",\"v\",predecessors))\n# ['s', 'x', 'u', 'v']"
        }
    },
    {
        "Section ID": "read_sparse6",
        "Description": [
            "Read an undirected graph in sparse6 format from path."
        ],
        "Field List": {
            "Parameters:": {
                "path : file or string": "File or filename to write."
            },
            "Returns:": {
                "G : Graph/Multigraph or list of Graphs/MultiGraphs": "If the file contains multiple lines then a list of graphs is returned"
            },
            "Raises:": {
                "NetworkXError": "If the string is unable to be parsed in sparse6 format"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Sparse6 specification\n<https://users.cecs.anu.edu.au/~bdm/data/formats.html>",
            "Examples": "You can read a sparse6 file by giving the path to the file:\nimporttempfile\nwithtempfile.NamedTemporaryFile(delete=False)asf:\n_=f.write(b\">>sparse6<<:An\\n\")\n_=f.seek(0)\nG=nx.read_sparse6(f.name)\nlist(G.edges())\n# [(0, 1)]\nYou can also read a sparse6 file by giving an open file-like object:\nimporttempfile\nwithtempfile.NamedTemporaryFile()asf:\n_=f.write(b\">>sparse6<<:An\\n\")\n_=f.seek(0)\nG=nx.read_sparse6(f)\nlist(G.edges())\n# [(0, 1)]"
        }
    },
    {
        "Section ID": "all_pairs_dijkstra_path_length",
        "Description": [
            "Compute shortest path lengths between all nodes in a weighted graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "cutoff : integer or float, optional": "Length (sum of edge weights) at which the search is stopped.\nIf cutoff is provided, only return paths with summed weight <= cutoff.",
                "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge."
            },
            "Returns:": {
                "distance : iterator": "(source, dictionary) iterator with dictionary keyed by target and\nshortest path length as the key value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The dictionary returned only has keys for reachable node pairs.",
            "Examples": "G=nx.path_graph(5)\nlength=dict(nx.all_pairs_dijkstra_path_length(G))\nfornodein[0,1,2,3,4]:\nprint(f\"1 - {node}: {length[1][node]}\")\n# 1 - 0: 1\n# 1 - 1: 0\n# 1 - 2: 1\n# 1 - 3: 2\n# 1 - 4: 3\nlength[3][2]\n# 1\nlength[2][2]\n# 0"
        }
    },
    {
        "Section ID": "MultiAdjacencyView",
        "Description": [
            "An MultiAdjacencyView is a Read-only Map of Maps of Maps of Maps.",
            "It is a View into a dict-of-dict-of-dict-of-dict data structure.\nThe inner level of dict is read-write. But the\nouter levels are read-only."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "is_matching",
        "Description": [
            "Return True if matching is a valid matching of G",
            "A matching in a graph is a set of edges in which no two distinct\nedges share a common endpoint. Each node is incident to at most one\nedge in the matching. The edges are said to be independent."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "matching : dict or set": "A dictionary or set representing a matching. If a dictionary, it\nmust havematching[u]==vandmatching[v]==ufor each\nedge(u,v)in the matching. If a set, it must have elements\nof the form(u,v), where(u,v)is an edge in the\nmatching."
            },
            "Returns:": {
                "bool": "Whether the given set or dictionary represents a valid matching\nin the graph."
            },
            "Raises:": {
                "NetworkXError": "If the proposed matching has an edge to a node not in G.\nOr if the matching is not a collection of 2-tuple edges."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph([(1,2),(1,3),(2,3),(2,4),(3,5),(4,5)])\nnx.is_maximal_matching(G,{1:3,2:4})# using dict to represent matching\n# True\nnx.is_matching(G,{(1,3),(2,4)})# using set to represent matching\n# True"
        }
    },
    {
        "Section ID": "degree_assortativity_coefficient",
        "Description": [
            "Compute degree assortativity of graph.",
            "Assortativity measures the similarity of connections\nin the graph with respect to the node degree."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "x: string (\u2018in\u2019,\u2019out\u2019)": "The degree type for source node (directed graphs only).",
                "y: string (\u2018in\u2019,\u2019out\u2019)": "The degree type for target node (directed graphs only).",
                "weight: string or None, optional (default=None)": "The edge attribute that holds the numerical value used\nas a weight.  If None, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node.",
                "nodes: list or iterable (optional)": "Compute degree assortativity only for nodes in container.\nThe default is all nodes."
            },
            "Returns:": {
                "r : float": "Assortativity of graph by degree."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This computes Eq. (21) in Ref. [1] , where e is the joint\nprobability distribution (mixing matrix) of the degrees.  If G is\ndirected than the matrix e is the joint probability of the\nuser-specified degree type for the source and target.",
            "References": "[1]M. E. J. Newman, Mixing patterns in networks,\nPhysical Review E, 67 026126, 2003  [2]Foster, J.G., Foster, D.V., Grassberger, P. & Paczuski, M.\nEdge direction and the structure of networks, PNAS 107, 10815-20 (2010).",
            "Examples": "G=nx.path_graph(4)\nr=nx.degree_assortativity_coefficient(G)\nprint(f\"{r:3.1f}\")\n# -0.5"
        }
    },
    {
        "Section ID": "jaccard_coefficient",
        "Description": [
            "Compute the Jaccard coefficient of all node pairs in ebunch.",
            "Jaccard coefficient of nodes u and v is defined as",
            "where \\(\\Gamma(u)\\) denotes the set of neighbors of \\(u\\) ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX undirected graph.",
                "ebunch : iterable of node pairs, optional (default = None)": "Jaccard coefficient will be computed for each pair of nodes\ngiven in the iterable. The pairs must be given as 2-tuples\n(u, v) where u and v are nodes in the graph. If ebunch is None\nthen all nonexistent edges in the graph will be used.\nDefault value: None."
            },
            "Returns:": {
                "piter : iterator": "An iterator of 3-tuples in the form (u, v, p) where (u, v) is a\npair of nodes and p is their Jaccard coefficient."
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis aDiGraph, aMultigraphor aMultiDiGraph.",
                "NodeNotFound": "Ifebunchhas a node that is not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]D. Liben-Nowell, J. Kleinberg.\nThe Link Prediction Problem for Social Networks (2004).http://www.cs.cornell.edu/home/kleinber/link-pred.pdf",
            "Examples": "G=nx.complete_graph(5)\npreds=nx.jaccard_coefficient(G,[(0,1),(2,3)])\nforu,v,pinpreds:\nprint(f\"({u}, {v}) -> {p:.8f}\")\n# (0, 1) -> 0.60000000\n# (2, 3) -> 0.60000000"
        }
    },
    {
        "Section ID": "random_internet_as_graph",
        "Description": [
            "Generates a random undirected graph resembling the Internet AS network"
        ],
        "Field List": {
            "Parameters:": {
                "n: integer in [1000, 10000]": "Number of graph nodes",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "G: Networkx Graph object": "A randomly generated undirected graph"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm returns an undirected graph resembling the Internet\nAutonomous System (AS) network, it uses the approach by Elmokashfi et al. [1] and it grants the properties described in the related paper [1] . Each node models an autonomous system, with an attribute \u2018type\u2019 specifying\nits kind; tier-1 (T), mid-level (M), customer (C) or content-provider (CP).\nEach edge models an ADV communication link (hence, bidirectional) with\nattributes:",
            "References": "[1](1,2)A. Elmokashfi, A. Kvalbein and C. Dovrolis, \u201cOn the Scalability of\nBGP: The Role of Topology Growth,\u201d in IEEE Journal on Selected Areas\nin Communications, vol. 28, no. 8, pp. 1250-1261, October 2010."
        }
    },
    {
        "Section ID": "eulerize",
        "Description": [
            "Transforms a graph into an Eulerian graph.",
            "If G is Eulerian the result is G as a MultiGraph, otherwise the result is a smallest\n(in terms of the number of edges) multigraph whose underlying simple graph is G ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "An undirected graph"
            },
            "Returns:": {
                "G : NetworkX multigraph": ""
            },
            "Raises:": {
                "NetworkXError": "If the graph is not connected."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]J. Edmonds, E. L. Johnson.\nMatching, Euler tours and the Chinese postman.\nMathematical programming, Volume 5, Issue 1 (1973), 111-114.  [2]https://en.wikipedia.org/wiki/Eulerian_path  [3]http://web.math.princeton.edu/math_alive/5/Notes1.pdf",
            "Examples": "G=nx.complete_graph(10)\nH=nx.eulerize(G)\nnx.is_eulerian(H)\n# True"
        }
    },
    {
        "Section ID": "min_maximal_matching",
        "Description": [
            "Returns the minimum maximal matching of G. That is, out of all maximal\nmatchings of the graph G, the smallest is returned."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected graph"
            },
            "Returns:": {
                "min_maximal_matching : set": "Returns a set of edges such that no two edges share a common endpoint\nand every edge not in the set shares some common endpoint in the set.\nCardinality will be 2*OPT in the worst case."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The algorithm computes an approximate solution for the minimum maximal\ncardinality matching problem. The solution is no more than 2 * OPT in size.\nRuntime is \\(O(|E|)\\) .",
            "References": "[1]Vazirani, Vijay Approximation Algorithms (2001)"
        }
    },
    {
        "Section ID": "to_agraph",
        "Description": [
            "Returns a pygraphviz graph from a NetworkX graph N."
        ],
        "Field List": {
            "Parameters:": {
                "N : NetworkX graph": "A graph created with NetworkX"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "If N has an dict N.graph_attr an attempt will be made first\nto copy properties attached to the graph (see from_agraph)\nand then updated with the calling arguments if any.",
            "Examples": "K5=nx.complete_graph(5)\nA=nx.nx_agraph.to_agraph(K5)"
        }
    },
    {
        "Section ID": "generate_gexf",
        "Description": [
            "Generate lines of GEXF format representation of G.",
            "\u201cGEXF (Graph Exchange XML Format) is a language for describing\ncomplex networks structures, their associated data and dynamics\u201d [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "",
                "A NetworkX graph": "",
                "encoding : string (optional, default: \u2018utf-8\u2019)": "",
                "Encoding for text data.": "",
                "prettyprint : bool (optional, default: True)": "",
                "If True use line breaks and indenting in output XML.": "",
                "version : string (default: 1.2draft)": "",
                "Version of GEFX File Format (see http://gexf.net/schema.html)": "",
                "Supported values: \u201c1.1draft\u201d, \u201c1.2draft\u201d": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This implementation does not support mixed graphs (directed and undirected\nedges together). The node id attribute is set to be the string of the node label.\nIf you want to specify an id use set it as node data, e.g.\nnode[\u2018a\u2019][\u2018id\u2019]=1 to set the id of node \u2018a\u2019 to 1.",
            "References": "[1]GEXF File Format,https://gephi.org/gexf/format/",
            "Examples": "G=nx.path_graph(4)\nlinefeed=chr(10)# linefeed=\ns=linefeed.join(nx.generate_gexf(G))\nforlineinnx.generate_gexf(G):\nprint(line)"
        }
    },
    {
        "Section ID": "asadpour_atsp",
        "Description": [
            "Returns an approximate solution to the traveling salesman problem.",
            "This approximate solution is one of the best known approximations for the\nasymmetric traveling salesman problem developed by Asadpour et al, [1] . The algorithm first solves the Held-Karp relaxation to find a lower\nbound for the weight of the cycle. Next, it constructs an exponential\ndistribution of undirected spanning trees where the probability of an\nedge being in the tree corresponds to the weight of that edge using a\nmaximum entropy rounding scheme. Next we sample that distribution \\(2 \\lceil \\ln n \\rceil\\) times and save the minimum sampled tree once the\ndirection of the arcs is added back to the edges. Finally, we augment\nthen short circuit that graph to find the approximate tour for the\nsalesman."
        ],
        "Field List": {
            "Parameters:": {
                "G : nx.DiGraph": "The graph should be a complete weighted directed graph. The\ndistance between all paris of nodes should be included and the triangle\ninequality should hold. That is, the direct edge between any two nodes\nshould be the path of least cost.",
                "weight : string, optional (default=\u201dweight\u201d)": "Edge data key corresponding to the edge weight.\nIf any edge does not have this attribute the weight is set to 1.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "source : node label (default=`None`)": "If given, return the cycle starting and ending at the given node."
            },
            "Returns:": {
                "cycle : list of nodes": "Returns the cycle (list of nodes) that a salesman can follow to minimize\nthe total weight of the trip."
            },
            "Raises:": {
                "NetworkXError": "Ifsourceis notNoneand is not a node inG, the algorithm raises\nan exception.",
                "NetworkXNotImplemented": "IfGis an undirected graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]A. Asadpour, M. X. Goemans, A. Madry, S. O. Gharan, and A. Saberi,\nAn o(log n/log log n)-approximation algorithm for the asymmetric\ntraveling salesman problem, Operations research, 65 (2017),\npp. 1043\u20131061",
            "Examples": "importnetworkxasnx\nimportnetworkx.algorithms.approximationasapprox\nG=nx.complete_graph(3,create_using=nx.DiGraph)\nnx.set_edge_attributes(\nG,{(0,1):2,(1,2):2,(2,0):2,(0,2):1,(2,1):1,(1,0):1},\"weight\"\n)\ntour=approx.asadpour_atsp(G,source=0)\ntour\n# [0, 2, 1, 0]"
        }
    },
    {
        "Section ID": "planar_layout",
        "Description": [
            "Position nodes without edge intersections."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph or list of nodes": "A position will be assigned to every node in G. If G is of type\nnx.PlanarEmbedding, the positions are selected accordingly.",
                "scale : number (default: 1)": "Scale factor for positions.",
                "center : array-like or None": "Coordinate pair around which to center the layout.",
                "dim : int": "Dimension of layout."
            },
            "Returns:": {
                "pos : dict": "A dictionary of positions keyed by node"
            },
            "Raises:": {
                "NetworkXException": "If G is not planar"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.path_graph(4)\npos=nx.planar_layout(G)"
        }
    },
    {
        "Section ID": "show_edges",
        "Description": [
            "Returns a filter function that shows specific undirected edges."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "literal_destringizer",
        "Description": [
            "Convert a Python literal to the value it represents."
        ],
        "Field List": {
            "Parameters:": {
                "rep : string": "A Python literal."
            },
            "Returns:": {
                "value : object": "The value of the Python literal."
            },
            "Raises:": {
                "ValueError": "Ifrepis not a Python literal."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "to_pandas_edgelist",
        "Description": [
            "Returns the graph edge list as a Pandas DataFrame."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "The NetworkX graph used to construct the Pandas DataFrame.",
                "source : str or int, optional": "A valid column name (string or integer) for the source nodes (for the\ndirected case).",
                "target : str or int, optional": "A valid column name (string or integer) for the target nodes (for the\ndirected case).",
                "nodelist : list, optional": "Use only nodes specified in nodelist",
                "dtype : dtype, default None": "Use to create the DataFrame. Data type to force.\nOnly a single dtype is allowed. If None, infer.",
                "edge_key : str or int or None, optional (default=None)": "A valid column name (string or integer) for the edge keys (for the\nmultigraph case). If None, edge keys are not stored in the DataFrame."
            },
            "Returns:": {
                "df : Pandas DataFrame": "Graph edge list"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph(\n[\n(\"A\",\"B\",{\"cost\":1,\"weight\":7}),\n(\"C\",\"E\",{\"cost\":9,\"weight\":10}),\n]\n)\ndf=nx.to_pandas_edgelist(G,nodelist=[\"A\",\"C\"])\ndf[[\"source\",\"target\",\"cost\",\"weight\"]]\n#   source target  cost  weight\n# 0      A      B     1       7\n# 1      C      E     9      10\nG=nx.MultiGraph([(\"A\",\"B\",{\"cost\":1}),(\"A\",\"B\",{\"cost\":9})])\ndf=nx.to_pandas_edgelist(G,nodelist=[\"A\",\"C\"],edge_key=\"ekey\")\ndf[[\"source\",\"target\",\"cost\",\"ekey\"]]\n#   source target  cost  ekey\n# 0      A      B     1     0\n# 1      A      B     9     1"
        }
    },
    {
        "Section ID": "ra_index_soundarajan_hopcroft",
        "Description": [
            "Compute the resource allocation index of all node pairs in\nebunch using community information.",
            "For two nodes \\(u\\) and \\(v\\) , this function computes the resource\nallocation index considering only common neighbors belonging to the\nsame community as \\(u\\) and \\(v\\) . Mathematically,",
            "where \\(f(w)\\) equals 1 if \\(w\\) belongs to the same community as \\(u\\) and \\(v\\) or 0 otherwise and \\(\\Gamma(u)\\) denotes the set of\nneighbors of \\(u\\) ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX undirected graph.",
                "ebunch : iterable of node pairs, optional (default = None)": "The score will be computed for each pair of nodes given in the\niterable. The pairs must be given as 2-tuples (u, v) where u\nand v are nodes in the graph. If ebunch is None then all\nnonexistent edges in the graph will be used.\nDefault value: None.",
                "community : string, optional (default = \u2018community\u2019)": "Nodes attribute name containing the community information.\nG[u][community] identifies which community u belongs to. Each\nnode belongs to at most one community. Default value: \u2018community\u2019."
            },
            "Returns:": {
                "piter : iterator": "An iterator of 3-tuples in the form (u, v, p) where (u, v) is a\npair of nodes and p is their score."
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis aDiGraph, aMultigraphor aMultiDiGraph.",
                "NetworkXAlgorithmError": "If no community information is available for a node inebunchor inG(ifebunchisNone).",
                "NodeNotFound": "Ifebunchhas a node that is not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Sucheta Soundarajan and John Hopcroft.\nUsing community information to improve the precision of link\nprediction methods.\nIn Proceedings of the 21st international conference companion on\nWorld Wide Web (WWW \u201812 Companion). ACM, New York, NY, USA, 607-608.http://doi.acm.org/10.1145/2187980.2188150",
            "Examples": "G=nx.Graph()\nG.add_edges_from([(0,1),(0,2),(1,3),(2,3)])\nG.nodes[0][\"community\"]=0\nG.nodes[1][\"community\"]=0\nG.nodes[2][\"community\"]=1\nG.nodes[3][\"community\"]=0\npreds=nx.ra_index_soundarajan_hopcroft(G,[(0,3)])\nforu,v,pinpreds:\nprint(f\"({u}, {v}) -> {p:.8f}\")\n# (0, 3) -> 0.50000000"
        }
    },
    {
        "Section ID": "cd_index",
        "Description": [
            "Compute the CD index for node within the graph G .",
            "Calculates the CD index for the given node of the graph,\nconsidering only its predecessors who have the time attribute\nsmaller than or equal to the time attribute of the node plus time_delta ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A directed networkx graph whose nodes havetimeattributes and optionallyweightattributes (if a weight is not given, it is considered 1).",
                "node : node": "The node for which the CD index is calculated.",
                "time_delta : numeric or timedelta": "Amount of time after thetimeattribute of thenode. The value oftime_deltamust support comparison with thetimenode attribute. For\nexample, if thetimeattribute of the nodes aredatetime.datetimeobjects, thentime_deltashould be adatetime.timedeltaobject.",
                "time : string (Optional, default is \u201ctime\u201d)": "The name of the node attribute that will be used for the calculations.",
                "weight : string (Optional, default is None)": "The name of the node attribute used as weight."
            },
            "Returns:": {
                "float": "The CD index calculated for the nodenodewithin the graphG."
            },
            "Raises:": {
                "NetworkXError": "If not all nodes have atimeattribute ortime_deltaandtimeattribute types are not compatible ornequals 0.",
                "NetworkXNotImplemented": "IfGis a non-directed graph or a multigraph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This method implements the algorithm for calculating the CD index,\nas described in the paper by Funk and Owen-Smith [1] . The CD index\nis used in order to check how consolidating or destabilizing a patent\nis, hence the nodes of the graph represent patents and the edges show\nthe citations between these patents. The mathematical model is given\nbelow:",
            "References": "[1]Funk, Russell J., and Jason Owen-Smith.\n\u201cA dynamic network measure of technological change.\u201d\nManagement science 63, no. 3 (2017): 791-817.http://russellfunk.org/cdindex/static/papers/funk_ms_2017.pdf",
            "Examples": "fromdatetimeimportdatetime,timedelta\nG=nx.DiGraph()\nnodes={\n1:{\"time\":datetime(2015,1,1)},\n2:{\"time\":datetime(2012,1,1),\"weight\":4},\n3:{\"time\":datetime(2010,1,1)},\n4:{\"time\":datetime(2008,1,1)},\n5:{\"time\":datetime(2014,1,1)},\n}\nG.add_nodes_from([(n,nodes[n])forninnodes])\nedges=[(1,3),(1,4),(2,3),(3,4),(3,5)]\nG.add_edges_from(edges)\ndelta=timedelta(days=5*365)\nnx.cd_index(G,3,time_delta=delta,time=\"time\")\n# 0.5\nnx.cd_index(G,3,time_delta=delta,time=\"time\",weight=\"weight\")\n# 0.12\nIntegers can also be used for the time values:\n>>> node_times = {1: 2015, 2: 2012, 3: 2010, 4: 2008, 5: 2014}\n>>> nx.set_node_attributes(G, node_times, \u201cnew_time\u201d)\n>>> nx.cd_index(G, 3, time_delta=4, time=\u201dnew_time\u201d)\n0.5\n>>> nx.cd_index(G, 3, time_delta=4, time=\u201dnew_time\u201d, weight=\u201dweight\u201d)\n0.12"
        }
    },
    {
        "Section ID": "hnm_harary_graph",
        "Description": [
            "Returns the Harary graph with given numbers of nodes and edges.",
            "The Harary graph \\(H_{n,m}\\) is the graph that maximizes node connectivity\nwith \\(n\\) nodes and \\(m\\) edges.",
            "This maximum node connectivity is known to be floor( \\(2m/n\\) ). [1]"
        ],
        "Field List": {
            "Parameters:": {
                "n: integer": "The number of nodes the generated graph is to contain",
                "m: integer": "The number of edges the generated graph is to contain",
                "create_using : NetworkX graph constructor, optional Graph type": "to create (default=nx.Graph). If graph instance, then cleared\nbefore populated."
            },
            "Returns:": {
                "NetworkX graph": "The Harary graph\\(H_{n,m}\\)."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm runs in \\(O(m)\\) time.\nIt is implemented by following the Reference [2] .",
            "References": "[1]F. T. Boesch, A. Satyanarayana, and C. L. Suffel,\n\u201cA Survey of Some Network Reliability Analysis and Synthesis Results,\u201d\nNetworks, pp. 99-107, 2009.  [2]Harary, F. \u201cThe Maximum Connectivity of a Graph.\u201d\nProc. Nat. Acad. Sci. USA 48, 1142-1146, 1962."
        }
    },
    {
        "Section ID": "draw_shell",
        "Description": [
            "Draw networkx graph G with shell layout.",
            "This is a convenience function equivalent to:"
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph",
                "nlist : list of list of nodes, optional": "A list containing lists of nodes representing the shells.\nDefault isNone, meaning all nodes are in a single shell.\nSeeshell_layoutfor details.",
                "kwargs : optional keywords": "Seedraw_networkxfor a description of optional keywords."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The layout is computed each time this function is called.\nFor repeated drawing it is much more efficient to call shell_layout directly and reuse the result:",
            "Examples": "G=nx.path_graph(4)\nshells=[[0],[1,2,3]]\nnx.draw_shell(G,nlist=shells)"
        }
    },
    {
        "Section ID": "hypercube_graph",
        "Description": [
            "Returns the n -dimensional hypercube graph.",
            "The nodes are the integers between 0 and 2**n-1 , inclusive.",
            "For more information on the hypercube graph, see the Wikipedia\narticle Hypercube graph ."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The dimension of the hypercube.\nThe number of nodes in the graph will be2**n."
            },
            "Returns:": {
                "NetworkX graph": "The hypercube graph of dimensionn."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "dorogovtsev_goltsev_mendes_graph",
        "Description": [
            "Returns the hierarchically constructed Dorogovtsev-Goltsev-Mendes graph.",
            "The Dorogovtsev-Goltsev-Mendes [1] procedure produces a scale-free graph\ndeterministically with the following properties for a given n :\n- Total number of nodes = 3*(3**n+1)/2 - Total number of edges = 3**(n+1)",
            "( Sourcecode , png )"
        ],
        "Field List": {
            "Parameters:": {
                "n : integer": "The generation number.",
                "create_using : NetworkX Graph, optional": "Graph type to be returned. Directed graphs and multi graphs are not\nsupported."
            },
            "Returns:": {
                "G : NetworkX Graph": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]S. N. Dorogovtsev, A. V. Goltsev and J. F. F. Mendes,\n\u201cPseudofractal scale-free web\u201d, Physical Review E 65, 066122, 2002.https://arxiv.org/pdf/cond-mat/0112143.pdf",
            "Examples": "G=nx.dorogovtsev_goltsev_mendes_graph(3)\nG.number_of_nodes()\n# 15\nG.number_of_edges()\n# 27\nnx.is_planar(G)\n# True"
        }
    },
    {
        "Section ID": "stochastic_block_model",
        "Description": [
            "Returns a stochastic block model graph.",
            "This model partitions the nodes in blocks of arbitrary sizes, and places\nedges between pairs of nodes independently, with a probability that depends\non the blocks."
        ],
        "Field List": {
            "Parameters:": {
                "sizes : list of ints": "Sizes of blocks",
                "p : list of list of floats": "Element (r,s) gives the density of edges going from the nodes\nof group r to nodes of group s.\np must match the number of groups (len(sizes) == len(p)),\nand it must be symmetric if the graph is undirected.",
                "nodelist : list, optional": "The block tags are assigned according to the node identifiers\nin nodelist. If nodelist is None, then the ordering is the\nrange [0,sum(sizes)-1].",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "directed : boolean optional, default=False": "Whether to create a directed graph or not.",
                "selfloops : boolean optional, default=False": "Whether to include self-loops or not.",
                "sparse: boolean optional, default=True": "Use the sparse heuristic to speed up the generator."
            },
            "Returns:": {
                "g : NetworkX Graph or DiGraph": "Stochastic block model graph of size sum(sizes)"
            },
            "Raises:": {
                "NetworkXError": "If probabilities are not in [0,1].\nIf the probability matrix is not square (directed case).\nIf the probability matrix is not symmetric (undirected case).\nIf the sizes list does not match nodelist or the probability matrix.\nIf nodelist contains duplicate."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Holland, P. W., Laskey, K. B., & Leinhardt, S.,\n\u201cStochastic blockmodels: First steps\u201d,\nSocial networks, 5(2), 109-137, 1983.",
            "Examples": "sizes=[75,75,300]\nprobs=[[0.25,0.05,0.02],[0.05,0.35,0.07],[0.02,0.07,0.40]]\ng=nx.stochastic_block_model(sizes,probs,seed=0)\nlen(g)\n# 450\nH=nx.quotient_graph(g,g.graph[\"partition\"],relabel=True)\nforvinH.nodes(data=True):\nprint(round(v[1][\"density\"],3))\n# 0.245\n# 0.348\n# 0.405\nforvinH.edges(data=True):\nprint(round(1.0*v[2][\"weight\"]/(sizes[v[0]]*sizes[v[1]]),3))\n# 0.051\n# 0.022\n# 0.07"
        }
    },
    {
        "Section ID": "strategy_connected_sequential_dfs",
        "Description": [
            "Returns an iterable over nodes in G in the order given by a\ndepth-first traversal.",
            "The generated sequence has the property that for each node except\nthe first, at least one neighbor appeared earlier in the sequence.",
            "G is a NetworkX graph. colors is ignored."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "literal_stringizer",
        "Description": [
            "Convert a value to a Python literal in GML representation."
        ],
        "Field List": {
            "Parameters:": {
                "value : object": "Thevalueto be converted to GML representation."
            },
            "Returns:": {
                "rep : string": "A double-quoted Python literal representing value. Unprintable\ncharacters are replaced by XML character references."
            },
            "Raises:": {
                "ValueError": "Ifvaluecannot be converted to GML."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The original value can be recovered using the networkx.readwrite.gml.literal_destringizer() function."
        }
    },
    {
        "Section ID": "single_source_bellman_ford_path",
        "Description": [
            "Compute shortest path between source and all other reachable\nnodes for a weighted graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node": "Starting node for path.",
                "weight : string or function (default=\u201dweight\u201d)": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number."
            },
            "Returns:": {
                "paths : dictionary": "Dictionary of shortest path lengths keyed by target."
            },
            "Raises:": {
                "NodeNotFound": "Ifsourceis not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.",
            "Examples": "G=nx.path_graph(5)\npath=nx.single_source_bellman_ford_path(G,0)\npath[4]\n# [0, 1, 2, 3, 4]"
        }
    },
    {
        "Section ID": "diamond_graph",
        "Description": [
            "Returns the Diamond graph",
            "The Diamond Graph is  planar undirected graph with 4 nodes and 5 edges.\nIt is also sometimes known as the double triangle graph or kite graph [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : networkx Graph": "Diamond Graph with 4 nodes and 5 edges"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://mathworld.wolfram.com/DiamondGraph.html"
        }
    },
    {
        "Section ID": "generate_gml",
        "Description": [
            "Generate a single entry of the graph G in GML format."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "The graph to be converted to GML.",
                "stringizer : callable, optional": "Astringizerwhich converts non-int/non-float/non-dict values into\nstrings. If it cannot convert a value into a string, it should raise aValueErrorto indicate that. Default value: None."
            },
            "Returns:": {
                "lines: generator of strings": "Lines of GML data. Newlines are not appended."
            },
            "Raises:": {
                "NetworkXError": "Ifstringizercannot convert a value into a string, or the value to\nconvert is not a string whilestringizeris None."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Graph attributes named \u2018directed\u2019, \u2018multigraph\u2019, \u2018node\u2019 or\n\u2018edge\u2019, node attributes named \u2018id\u2019 or \u2018label\u2019, edge attributes\nnamed \u2018source\u2019 or \u2018target\u2019 (or \u2018key\u2019 if G is a multigraph)\nare ignored because these attribute names are used to encode the graph\nstructure. GML files are stored using a 7-bit ASCII encoding with any extended\nASCII characters (iso8859-1) appearing as HTML character entities.\nWithout specifying a stringizer / destringizer , the code is capable of\nwriting int / float / str / dict / list data as required by the GML\nspecification.  For writing other data types, and for reading data other\nthan str you need to explicitly supply a stringizer / destringizer . For additional documentation on the GML file format, please see the GML url . See the module docstring networkx.readwrite.gml for more details.",
            "Examples": "G=nx.Graph()\nG.add_node(\"1\")\nprint(\"\\n\".join(nx.generate_gml(G)))\n# graph [\n#   node [\n#     id 0\n#     label \"1\"\n#   ]\n# ]\nG=nx.MultiGraph([(\"a\",\"b\"),(\"a\",\"b\")])\nprint(\"\\n\".join(nx.generate_gml(G)))\n# graph [\n#   multigraph 1\n#   node [\n#     id 0\n#     label \"a\"\n#   ]\n#   node [\n#     id 1\n#     label \"b\"\n#   ]\n#   edge [\n#     source 0\n#     target 1\n#     key 0\n#   ]\n#   edge [\n#     source 0\n#     target 1\n#     key 1\n#   ]\n# ]"
        }
    },
    {
        "Section ID": "is_valid_joint_degree",
        "Description": [
            "Checks whether the given joint degree dictionary is realizable.",
            "A joint degree dictionary is a dictionary of dictionaries, in\nwhich entry joint_degrees[k][l] is an integer representing the\nnumber of edges joining nodes of degree k with nodes of degree l . Such a dictionary is realizable as a simple graph if and only\nif the following conditions are satisfied."
        ],
        "Field List": {
            "Parameters:": {
                "joint_degrees : dictionary of dictionary of integers": "A joint degree dictionary in which entryjoint_degrees[k][l]is the number of edges joining nodes of degreekwith nodes of\ndegreel."
            },
            "Returns:": {
                "bool": "Whether the given joint degree dictionary is realizable as a\nsimple graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]M. Gjoka, M. Kurant, A. Markopoulou, \u201c2.5K Graphs: from Sampling\nto Generation\u201d, IEEE Infocom, 2013.  [2]I. Stanton, A. Pinar, \u201cConstructing and sampling graphs with a\nprescribed joint degree distribution\u201d, Journal of Experimental\nAlgorithmics, 2012."
        }
    },
    {
        "Section ID": "fiedler_vector",
        "Description": [
            "Returns the Fiedler vector of a connected undirected graph.",
            "The Fiedler vector of a connected undirected graph is the eigenvector\ncorresponding to the second smallest eigenvalue of the Laplacian matrix\nof the graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "An undirected graph.",
                "weight : object, optional (default: None)": "The data key used to determine the weight of each edge. If None, then\neach edge has unit weight.",
                "normalized : bool, optional (default: False)": "Whether the normalized Laplacian matrix is used.",
                "tol : float, optional (default: 1e-8)": "Tolerance of relative residual in eigenvalue computation.",
                "method : string, optional (default: \u2018tracemin_pcg\u2019)": "Method of eigenvalue computation. It must be one of the tracemin\noptions shown below (TraceMIN), \u2018lanczos\u2019 (Lanczos iteration)\nor \u2018lobpcg\u2019 (LOBPCG).The TraceMIN algorithm uses a linear system solver. The following\nvalues allow specifying the solver to be used.ValueSolver\u2018tracemin_pcg\u2019Preconditioned conjugate gradient method\u2018tracemin_lu\u2019LU factorization",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "fiedler_vector : NumPy array of floats.": "Fiedler vector."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is directed.",
                "NetworkXError": "If G has less than two nodes or is not connected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weights are interpreted by their absolute values. For MultiGraph\u2019s,\nweights of parallel edges are summed. Zero-weighted edges are ignored.",
            "Examples": "Given a connected graph the signs of the values in the Fiedler vector can be\nused to partition the graph into two components.\nG=nx.barbell_graph(5,0)\nnx.fiedler_vector(G,normalized=True,seed=1)\n# array([-0.32864129, -0.32864129, -0.32864129, -0.32864129, -0.26072899,\n#         0.26072899,  0.32864129,  0.32864129,  0.32864129,  0.32864129])\nThe connected components are the two 5-node cliques of the barbell graph."
        }
    },
    {
        "Section ID": "global_parameters",
        "Description": [
            "Returns global parameters for a given intersection array.",
            "Given a distance-regular graph G with integers b_i, c_i,i = 0,\u2026.,d\nsuch that for any 2 vertices x,y in G at a distance i=d(x,y), there\nare exactly c_i neighbors of y at a distance of i-1 from x and b_i\nneighbors of y at a distance of i+1 from x.",
            "Thus, a distance regular graph has the global parameters,\n[[c_0,a_0,b_0],[c_1,a_1,b_1],\u2026\u2026,[c_d,a_d,b_d]] for the\nintersection array  [b_0,b_1,\u2026..b_{d-1};c_1,c_2,\u2026..c_d]\nwhere a_i+b_i+c_i=k , k= degree of every vertex."
        ],
        "Field List": {
            "Parameters:": {
                "b : list": "",
                "c : list": ""
            },
            "Returns:": {
                "iterable": "An iterable over three tuples."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Weisstein, Eric W. \u201cGlobal Parameters.\u201d\nFrom MathWorld\u2013A Wolfram Web Resource.http://mathworld.wolfram.com/GlobalParameters.html",
            "Examples": "G=nx.dodecahedral_graph()\nb,c=nx.intersection_array(G)\nlist(nx.global_parameters(b,c))\n# [(0, 0, 3), (1, 0, 2), (1, 1, 1), (1, 1, 1), (2, 0, 1), (3, 0, 0)]"
        }
    },
    {
        "Section ID": "from_agraph",
        "Description": [
            "Returns a NetworkX Graph or DiGraph from a PyGraphviz graph."
        ],
        "Field List": {
            "Parameters:": {
                "A : PyGraphviz AGraph": "A graph created with PyGraphviz",
                "create_using : NetworkX graph constructor, optional (default=None)": "Graph type to create. If graph instance, then cleared before populated.\nIfNone, then the appropriate Graph type is inferred fromA."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The Graph G will have a dictionary G.graph_attr containing\nthe default graphviz attributes for graphs, nodes and edges. Default node attributes will be in the dictionary G.node_attr\nwhich is keyed by node. Edge attributes will be returned as edge data in G.  With\nedge_attr=False the edge data will be the Graphviz edge weight\nattribute or the value 1 if no edge weight attribute is found.",
            "Examples": "K5=nx.complete_graph(5)\nA=nx.nx_agraph.to_agraph(K5)\nG=nx.nx_agraph.from_agraph(A)"
        }
    },
    {
        "Section ID": "all_pairs_shortest_path_length",
        "Description": [
            "Computes the shortest path lengths between all nodes in G ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "cutoff : integer, optional": "Depth at which to stop the search. Only paths of length at mostcutoffare returned."
            },
            "Returns:": {
                "lengths : iterator": "(source, dictionary) iterator with dictionary keyed by target and\nshortest path length as the key value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The iterator returned only has reachable node pairs.",
            "Examples": "G=nx.path_graph(5)\nlength=dict(nx.all_pairs_shortest_path_length(G))\nfornodein[0,1,2,3,4]:\nprint(f\"1 - {node}: {length[1][node]}\")\n# 1 - 0: 1\n# 1 - 1: 0\n# 1 - 2: 1\n# 1 - 3: 2\n# 1 - 4: 3\nlength[3][2]\n# 1\nlength[2][2]\n# 0"
        }
    },
    {
        "Section ID": "topological_sort",
        "Description": [
            "Returns a generator of nodes in topologically sorted order.",
            "A topological sort is a nonunique permutation of the nodes of a\ndirected graph such that an edge from u to v implies that u\nappears before v in the topological sort order. This ordering is\nvalid only if the graph has no directed cycles."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX digraph": "A directed acyclic graph (DAG)"
            },
            "Yields:": {
                "nodes": "Yields the nodes in topological sorted order."
            },
            "Raises:": {
                "NetworkXError": "Topological sort is defined for directed graphs only. If the graphGis undirected, aNetworkXErroris raised.",
                "NetworkXUnfeasible": "IfGis not a directed acyclic graph (DAG) no topological sort exists\nand aNetworkXUnfeasibleexception is raised.  This can also be\nraised ifGis changed while the returned iterator is being processed",
                "RuntimeError": "IfGis changed while the returned iterator is being processed."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm is based on a description and proof in\n\u201cIntroduction to Algorithms: A Creative Approach\u201d [1] .",
            "References": "[1]Manber, U. (1989).Introduction to Algorithms - A Creative Approach.Addison-Wesley.",
            "Examples": "To get the reverse order of the topological sort:\nDG=nx.DiGraph([(1,2),(2,3)])\nlist(reversed(list(nx.topological_sort(DG))))\n# [3, 2, 1]\nIf your DiGraph naturally has the edges representing tasks/inputs\nand nodes representing people/processes that initiate tasks, then\ntopological_sort is not quite what you need. You will have to change\nthe tasks to nodes with dependence reflected by edges. The result is\na kind of topological sort of the edges. This can be done\nwithnetworkx.line_graph()as follows:\nlist(nx.topological_sort(nx.line_graph(DG)))\n# [(1, 2), (2, 3)]"
        }
    },
    {
        "Section ID": "hkn_harary_graph",
        "Description": [
            "Returns the Harary graph with given node connectivity and node number.",
            "The Harary graph \\(H_{k,n}\\) is the graph that minimizes the number of\nedges needed with given node connectivity \\(k\\) and node number \\(n\\) .",
            "This smallest number of edges is known to be ceil( \\(kn/2\\) ) [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "k: integer": "The node connectivity of the generated graph",
                "n: integer": "The number of nodes the generated graph is to contain",
                "create_using : NetworkX graph constructor, optional Graph type": "to create (default=nx.Graph). If graph instance, then cleared\nbefore populated."
            },
            "Returns:": {
                "NetworkX graph": "The Harary graph\\(H_{k,n}\\)."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm runs in \\(O(kn)\\) time.\nIt is implemented by following the Reference [2] .",
            "References": "[1]Weisstein, Eric W. \u201cHarary Graph.\u201d From MathWorld\u2013A Wolfram Web\nResource.http://mathworld.wolfram.com/HararyGraph.html.  [2]Harary, F. \u201cThe Maximum Connectivity of a Graph.\u201d\nProc. Nat. Acad. Sci. USA 48, 1142-1146, 1962."
        }
    },
    {
        "Section ID": "s_metric",
        "Description": [
            "Returns the s-metric [1] of graph.",
            "The s-metric is defined as the sum of the products deg(u)*deg(v) for every edge (u,v) in G ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "The graph used to compute the s-metric.",
                "normalized : bool (optional)": "Normalize the value.Deprecated since version 3.2:Thenormalizedkeyword argument is deprecated and will be removed\nin the future"
            },
            "Returns:": {
                "s : float": "The s-metric of the graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Lun Li, David Alderson, John C. Doyle, and Walter Willinger,\nTowards a Theory of Scale-Free Graphs:\nDefinition, Properties, and  Implications (Extended Version), 2005.https://arxiv.org/abs/cond-mat/0501169"
        }
    },
    {
        "Section ID": "vf2pp_isomorphism",
        "Description": [
            "Return an isomorphic mapping between G1 and G2 if it exists."
        ],
        "Field List": {
            "Parameters:": {
                "G1, G2 : NetworkX Graph or MultiGraph instances.": "The two graphs to check for isomorphism.",
                "node_label : str, optional": "The name of the node attribute to be used when comparing nodes.\nThe default isNone, meaning node attributes are not considered\nin the comparison. Any node that doesn\u2019t have thenode_labelattribute usesdefault_labelinstead.",
                "default_label : scalar": "Default value to use when a node doesn\u2019t have an attribute\nnamednode_label. Default isNone."
            },
            "Returns:": {
                "dict or None": "Node mapping if the two graphs are isomorphic. None otherwise."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "katz_centrality",
        "Description": [
            "Compute the Katz centrality for the nodes of the graph G.",
            "Katz centrality computes the centrality for a node based on the centrality\nof its neighbors. It is a generalization of the eigenvector centrality. The\nKatz centrality for node \\(i\\) is",
            "where \\(A\\) is the adjacency matrix of graph G with eigenvalues \\(\\lambda\\) .",
            "The parameter \\(\\beta\\) controls the initial centrality and",
            "Katz centrality computes the relative influence of a node within a\nnetwork by measuring the number of the immediate neighbors (first\ndegree nodes) and also all other nodes in the network that connect\nto the node under consideration through these immediate neighbors.",
            "Extra weight can be provided to immediate neighbors through the\nparameter \\(\\beta\\) .  Connections made with distant neighbors\nare, however, penalized by an attenuation factor \\(\\alpha\\) which\nshould be strictly less than the inverse largest eigenvalue of the\nadjacency matrix in order for the Katz centrality to be computed\ncorrectly. More information is provided in [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.",
                "alpha : float, optional (default=0.1)": "Attenuation factor",
                "beta : scalar or dictionary, optional (default=1.0)": "Weight attributed to the immediate neighborhood. If not a scalar, the\ndictionary must have a value for every node.",
                "max_iter : integer, optional (default=1000)": "Maximum number of iterations in power method.",
                "tol : float, optional (default=1.0e-6)": "Error tolerance used to check convergence in power method iteration.",
                "nstart : dictionary, optional": "Starting value of Katz iteration for each node.",
                "normalized : bool, optional (default=True)": "If True normalize the resulting values.",
                "weight : None or string, optional (default=None)": "If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight.\nIn this measure the weight is interpreted as the connection strength."
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of nodes with Katz centrality as the value."
            },
            "Raises:": {
                "NetworkXError": "If the parameterbetais not a scalar but lacks a value for at least\none node",
                "PowerIterationFailedConvergence": "If the algorithm fails to converge to the specified tolerance\nwithin the specified number of iterations of the power iteration\nmethod."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Katz centrality was introduced by [2] . This algorithm it uses the power method to find the eigenvector\ncorresponding to the largest eigenvalue of the adjacency matrix of G .\nThe parameter alpha should be strictly less than the inverse of largest\neigenvalue of the adjacency matrix for the algorithm to converge.\nYou can use max(nx.adjacency_spectrum(G)) to get \\(\\lambda_{\\max}\\) the largest\neigenvalue of the adjacency matrix.\nThe iteration will stop after max_iter iterations or an error tolerance of number_of_nodes(G)*tol has been reached. For strongly connected graphs, as \\(\\alpha \\to 1/\\lambda_{\\max}\\) , and \\(\\beta > 0\\) ,\nKatz centrality approaches the results for eigenvector centrality. For directed graphs this finds \u201cleft\u201d eigenvectors which corresponds\nto the in-edges in the graph. For out-edges Katz centrality,\nfirst reverse the graph with G.reverse() .",
            "References": "[1]Mark E. J. Newman:\nNetworks: An Introduction.\nOxford University Press, USA, 2010, p. 720.  [2]Leo Katz:\nA New Status Index Derived from Sociometric Index.\nPsychometrika 18(1):39\u201343, 1953https://link.springer.com/content/pdf/10.1007/BF02289026.pdf",
            "Examples": "importmath\nG=nx.path_graph(4)\nphi=(1+math.sqrt(5))/2.0# largest eigenvalue of adj matrix\ncentrality=nx.katz_centrality(G,1/phi-0.01)\nforn,cinsorted(centrality.items()):\nprint(f\"{n} {c:.2f}\")\n# 0 0.37\n# 1 0.60\n# 2 0.60\n# 3 0.37"
        }
    },
    {
        "Section ID": "network_simplex",
        "Description": [
            "Find a minimum cost flow satisfying all demands in digraph G.",
            "This is a primal network simplex algorithm that uses the leaving\narc rule to prevent cycling.",
            "G is a digraph with edge costs and capacities and in which nodes\nhave demand, i.e., they want to send or receive some amount of\nflow. A negative demand means that the node wants to send flow, a\npositive demand means that the node want to receive flow. A flow on\nthe digraph G satisfies all demand if the net flow into each node\nis equal to the demand of that node."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "DiGraph on which a minimum cost flow satisfying all demands is\nto be found.",
                "demand : string": "Nodes of the graph G are expected to have an attribute demand\nthat indicates how much flow a node wants to send (negative\ndemand) or receive (positive demand). Note that the sum of the\ndemands should be 0 otherwise the problem in not feasible. If\nthis attribute is not present, a node is considered to have 0\ndemand. Default value: \u2018demand\u2019.",
                "capacity : string": "Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: \u2018capacity\u2019.",
                "weight : string": "Edges of the graph G are expected to have an attribute weight\nthat indicates the cost incurred by sending one unit of flow on\nthat edge. If not present, the weight is considered to be 0.\nDefault value: \u2018weight\u2019."
            },
            "Returns:": {
                "flowCost : integer, float": "Cost of a minimum cost flow satisfying all demands.",
                "flowDict : dictionary": "Dictionary of dictionaries keyed by nodes such that\nflowDict[u][v] is the flow edge (u, v)."
            },
            "Raises:": {
                "NetworkXError": "This exception is raised if the input graph is not directed or\nnot connected.",
                "NetworkXUnfeasible": "This exception is raised in the following situations:The sum of the demands is not zero. Then, there is no\nflow satisfying all demands.There is no flow satisfying all demand.",
                "NetworkXUnbounded": "This exception is raised if the digraph G has a cycle of\nnegative cost and infinite capacity. Then, the cost of a flow\nsatisfying all demands is unbounded below."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm is not guaranteed to work if edge weights or demands\nare floating point numbers (overflows and roundoff errors can\ncause problems). As a workaround you can use integer numbers by\nmultiplying the relevant edge attributes by a convenient\nconstant factor (eg 100).",
            "References": "[1]Z. Kiraly, P. Kovacs.\nEfficient implementation of minimum-cost flow algorithms.\nActa Universitatis Sapientiae, Informatica 4(1):67\u2013118. 2012.  [2]R. Barr, F. Glover, D. Klingman.\nEnhancement of spanning tree labeling procedures for network\noptimization.\nINFOR 17(1):16\u201334. 1979.",
            "Examples": "A simple example of a min cost flow problem.\nG=nx.DiGraph()\nG.add_node(\"a\",demand=-5)\nG.add_node(\"d\",demand=5)\nG.add_edge(\"a\",\"b\",weight=3,capacity=4)\nG.add_edge(\"a\",\"c\",weight=6,capacity=10)\nG.add_edge(\"b\",\"d\",weight=1,capacity=9)\nG.add_edge(\"c\",\"d\",weight=2,capacity=5)\nflowCost,flowDict=nx.network_simplex(G)\nflowCost\n# 24\nflowDict\n# {'a': {'b': 4, 'c': 1}, 'd': {}, 'b': {'d': 4}, 'c': {'d': 1}}\nThe mincost flow algorithm can also be used to solve shortest path\nproblems. To find the shortest path between two nodes u and v,\ngive all edges an infinite capacity, give node u a demand of -1 and\nnode v a demand a 1. Then run the network simplex. The value of a\nmin cost flow will be the distance between u and v and edges\ncarrying positive flow will indicate the path.\nG=nx.DiGraph()\nG.add_weighted_edges_from(\n[\n(\"s\",\"u\",10),\n(\"s\",\"x\",5),\n(\"u\",\"v\",1),\n(\"u\",\"x\",2),\n(\"v\",\"y\",1),\n(\"x\",\"u\",3),\n(\"x\",\"v\",5),\n(\"x\",\"y\",2),\n(\"y\",\"s\",7),\n(\"y\",\"v\",6),\n]\n)\nG.add_node(\"s\",demand=-1)\nG.add_node(\"v\",demand=1)\nflowCost,flowDict=nx.network_simplex(G)\nflowCost==nx.shortest_path_length(G,\"s\",\"v\",weight=\"weight\")\n# True\nsorted([(u,v)foruinflowDictforvinflowDict[u]ifflowDict[u][v]>0])\n# [('s', 'x'), ('u', 'v'), ('x', 'u')]\nnx.shortest_path(G,\"s\",\"v\",weight=\"weight\")\n# ['s', 'x', 'u', 'v']\nIt is possible to change the name of the attributes used for the\nalgorithm.\nG=nx.DiGraph()\nG.add_node(\"p\",spam=-4)\nG.add_node(\"q\",spam=2)\nG.add_node(\"a\",spam=-2)\nG.add_node(\"d\",spam=-1)\nG.add_node(\"t\",spam=2)\nG.add_node(\"w\",spam=3)\nG.add_edge(\"p\",\"q\",cost=7,vacancies=5)\nG.add_edge(\"p\",\"a\",cost=1,vacancies=4)\nG.add_edge(\"q\",\"d\",cost=2,vacancies=3)\nG.add_edge(\"t\",\"q\",cost=1,vacancies=2)\nG.add_edge(\"a\",\"t\",cost=2,vacancies=4)\nG.add_edge(\"d\",\"w\",cost=3,vacancies=4)\nG.add_edge(\"t\",\"w\",cost=4,vacancies=1)\nflowCost,flowDict=nx.network_simplex(\nG,demand=\"spam\",capacity=\"vacancies\",weight=\"cost\"\n)\nflowCost\n# 37\nflowDict\n# {'p': {'q': 2, 'a': 2}, 'q': {'d': 1}, 'a': {'t': 4}, 'd': {'w': 2}, 't': {'q': 1, 'w': 1}, 'w': {}}"
        }
    },
    {
        "Section ID": "to_dict_of_lists",
        "Description": [
            "Returns adjacency representation of graph as a dictionary of lists."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "nodelist : list": "Use only nodes specified in nodelist"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Completely ignores edge data for MultiGraph and MultiDiGraph."
        }
    },
    {
        "Section ID": "write_graph6",
        "Description": [
            "Write a simple undirected graph to a path in graph6 format."
        ],
        "Field List": {
            "Parameters:": {
                "G : Graph (undirected)": "",
                "path : str": "The path naming the file to which to write the graph.",
                "nodes: list or iterable": "Nodes are labeled 0\u2026n-1 in the order provided.  If None the ordering\ngiven byG.nodes()is used.",
                "header: bool": "If True add \u2018>>graph6<<\u2019 string to head of data"
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the graph is directed or is a multigraph.",
                "ValueError": "If the graph has at least2**36nodes; the graph6 format\nis only defined for graphs of order less than2**36."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The function writes a newline character after writing the encoding\nof the graph. The format does not support edge or node labels, parallel edges or\nself loops.  If self loops are present they are silently ignored.",
            "References": "[1]Graph6 specification\n<http://users.cecs.anu.edu.au/~bdm/data/formats.html>",
            "Examples": "You can write a graph6 file by giving the path to a file:\nimporttempfile\nwithtempfile.NamedTemporaryFile(delete=False)asf:\nnx.write_graph6(nx.path_graph(2),f.name)\n_=f.seek(0)\nprint(f.read())\n# b'>>graph6<<A_\\n'"
        }
    },
    {
        "Section ID": "random_spanning_tree",
        "Description": [
            "Sample a random spanning tree using the edges weights of G .",
            "This function supports two different methods for determining the\nprobability of the graph. If multiplicative=True , the probability\nis based on the product of edge weights, and if multiplicative=False it is based on the sum of the edge weight. However, since it is\neasier to determine the total weight of all spanning trees for the\nmultiplicative version, that is significantly faster and should be used if\npossible. Additionally, setting weight to None will cause a spanning tree\nto be selected with uniform probability.",
            "The function uses algorithm A8 in [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : nx.Graph": "An undirected version of the original graph.",
                "weight : string": "The edge key for the edge attribute holding edge weight.",
                "multiplicative : bool, default=True": "IfTrue, the probability of each tree is the product of its edge weight\nover the sum of the product of all the spanning trees in the graph. IfFalse, the probability is the sum of its edge weight over the sum of\nthe sum of weights for all spanning trees in the graph.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "nx.Graph": "A spanning tree using the distribution defined by the weight of the tree."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]V. Kulkarni, Generating random combinatorial objects, Journal of\nAlgorithms, 11 (1990), pp. 185\u2013207"
        }
    },
    {
        "Section ID": "has_bridges",
        "Description": [
            "Decide whether a graph has any bridges.",
            "A bridge in a graph is an edge whose removal causes the number of\nconnected components of the graph to increase."
        ],
        "Field List": {
            "Parameters:": {
                "G : undirected graph": "",
                "root : node (optional)": "A node in the graphG. If specified, only the bridges in the\nconnected component containing this node will be considered."
            },
            "Returns:": {
                "bool": "Whether the graph (or the connected component containingroot)\nhas any bridges."
            },
            "Raises:": {
                "NodeNotFound": "Ifrootis not in the graphG.",
                "NetworkXNotImplemented": "IfGis a directed graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This implementation uses the networkx.bridges() function, so\nit shares its worst-case time complexity, \\(O(m + n)\\) , ignoring\npolylogarithmic factors, where \\(n\\) is the number of nodes in the\ngraph and \\(m\\) is the number of edges.",
            "Examples": "The barbell graph with parameter zero has a single bridge:\nG=nx.barbell_graph(10,0)\nnx.has_bridges(G)\n# True\nOn the other hand, the cycle graph has no bridges:\nG=nx.cycle_graph(5)\nnx.has_bridges(G)\n# False"
        }
    },
    {
        "Section ID": "rooted_product",
        "Description": [
            "Return the rooted product of graphs G and H rooted at root in H.",
            "A new graph is constructed representing the rooted product of\nthe inputted graphs, G and H, with a root in H.\nA rooted product duplicates H for each nodes in G with the root\nof H corresponding to the node in G. Nodes are renamed as the direct\nproduct of G and H. The result is a subgraph of the cartesian product."
        ],
        "Field List": {
            "Parameters:": {
                "G,H : graph": "A NetworkX graph",
                "root : node": "A node in H"
            },
            "Returns:": {
                "R : The rooted product of G and H with a specified root in H": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The nodes of R are the Cartesian Product of the nodes of G and H.\nThe nodes of G and H are not relabeled."
        }
    },
    {
        "Section ID": "grid_2d_graph",
        "Description": [
            "Returns the two-dimensional grid graph.",
            "The grid graph has each node connected to its four nearest neighbors."
        ],
        "Field List": {
            "Parameters:": {
                "m, n : int or iterable container of nodes": "If an integer, nodes are fromrange(n).\nIf a container, elements become the coordinate of the nodes.",
                "periodic : bool or iterable": "Ifperiodicis True, both dimensions are periodic. If False, none\nare periodic.  Ifperiodicis iterable, it should yield 2 bool\nvalues indicating whether the 1st and 2nd axes, respectively, are\nperiodic.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "NetworkX graph": "The (possibly periodic) grid graph of the specified dimensions."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "is_triad",
        "Description": [
            "Returns True if the graph G is a triad, else False."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX Graph"
            },
            "Returns:": {
                "istriad : boolean": "Whether G is a valid triad"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.DiGraph([(1,2),(2,3),(3,1)])\nnx.is_triad(G)\n# True\nG.add_edge(0,1)\nnx.is_triad(G)\n# False"
        }
    },
    {
        "Section ID": "graph_edit_distance",
        "Description": [
            "Returns GED (graph edit distance) between graphs G1 and G2.",
            "Graph edit distance is a graph similarity measure analogous to\nLevenshtein distance for strings.  It is defined as minimum cost\nof edit path (sequence of node and edge edit operations)\ntransforming graph G1 to graph isomorphic to G2."
        ],
        "Field List": {
            "Parameters:": {
                "G1, G2: graphs": "The two graphs G1 and G2 must be of the same type.",
                "node_match : callable": "A function that returns True if node n1 in G1 and n2 in G2\nshould be considered equal during matching.The function will be called likenode_match(G1.nodes[n1], G2.nodes[n2]).That is, the function will receive the node attribute\ndictionaries for n1 and n2 as inputs.Ignored if node_subst_cost is specified.  If neither\nnode_match nor node_subst_cost are specified then node\nattributes are not considered.",
                "edge_match : callable": "A function that returns True if the edge attribute dictionaries\nfor the pair of nodes (u1, v1) in G1 and (u2, v2) in G2 should\nbe considered equal during matching.The function will be called likeedge_match(G1[u1][v1], G2[u2][v2]).That is, the function will receive the edge attribute\ndictionaries of the edges under consideration.Ignored if edge_subst_cost is specified.  If neither\nedge_match nor edge_subst_cost are specified then edge\nattributes are not considered.",
                "node_subst_cost, node_del_cost, node_ins_cost : callable": "Functions that return the costs of node substitution, node\ndeletion, and node insertion, respectively.The functions will be called likenode_subst_cost(G1.nodes[n1], G2.nodes[n2]),\nnode_del_cost(G1.nodes[n1]),\nnode_ins_cost(G2.nodes[n2]).That is, the functions will receive the node attribute\ndictionaries as inputs.  The functions are expected to return\npositive numeric values.Function node_subst_cost overrides node_match if specified.\nIf neither node_match nor node_subst_cost are specified then\ndefault node substitution cost of 0 is used (node attributes\nare not considered during matching).If node_del_cost is not specified then default node deletion\ncost of 1 is used.  If node_ins_cost is not specified then\ndefault node insertion cost of 1 is used.",
                "edge_subst_cost, edge_del_cost, edge_ins_cost : callable": "Functions that return the costs of edge substitution, edge\ndeletion, and edge insertion, respectively.The functions will be called likeedge_subst_cost(G1[u1][v1], G2[u2][v2]),\nedge_del_cost(G1[u1][v1]),\nedge_ins_cost(G2[u2][v2]).That is, the functions will receive the edge attribute\ndictionaries as inputs.  The functions are expected to return\npositive numeric values.Function edge_subst_cost overrides edge_match if specified.\nIf neither edge_match nor edge_subst_cost are specified then\ndefault edge substitution cost of 0 is used (edge attributes\nare not considered during matching).If edge_del_cost is not specified then default edge deletion\ncost of 1 is used.  If edge_ins_cost is not specified then\ndefault edge insertion cost of 1 is used.",
                "roots : 2-tuple": "Tuple where first element is a node in G1 and the second\nis a node in G2.\nThese nodes are forced to be matched in the comparison to\nallow comparison between rooted graphs.",
                "upper_bound : numeric": "Maximum edit distance to consider.  Return None if no edit\ndistance under or equal to upper_bound exists.",
                "timeout : numeric": "Maximum number of seconds to execute.\nAfter timeout is met, the current best GED is returned."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Zeina Abu-Aisheh, Romain Raveaux, Jean-Yves Ramel, Patrick\nMartineau. An Exact Graph Edit Distance Algorithm for Solving\nPattern Recognition Problems. 4th International Conference on\nPattern Recognition Applications and Methods 2015, Jan 2015,\nLisbon, Portugal. 2015,\n<10.5220/0005209202710278>. <hal-01168816>https://hal.archives-ouvertes.fr/hal-01168816",
            "Examples": "G1=nx.cycle_graph(6)\nG2=nx.wheel_graph(7)\nnx.graph_edit_distance(G1,G2)\n# 7.0\nG1=nx.star_graph(5)\nG2=nx.star_graph(5)\nnx.graph_edit_distance(G1,G2,roots=(0,0))\n# 0.0\nnx.graph_edit_distance(G1,G2,roots=(1,0))\n# 8.0"
        }
    },
    {
        "Section ID": "condensation",
        "Description": [
            "Returns the condensation of G.",
            "The condensation of G is the graph with each of the strongly connected\ncomponents contracted into a single node."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX DiGraph": "A directed graph.",
                "scc:  list or generator (optional, default=None)": "Strongly connected components. If provided, the elements insccmust partition the nodes inG. If not provided, it will be\ncalculated as scc=nx.strongly_connected_components(G)."
            },
            "Returns:": {
                "C : NetworkX DiGraph": "The condensation graph C of G.  The node labels are integers\ncorresponding to the index of the component in the list of\nstrongly connected components of G.  C has a graph attribute named\n\u2018mapping\u2019 with a dictionary mapping the original nodes to the\nnodes in C to which they belong.  Each node in C also has a node\nattribute \u2018members\u2019 with the set of original nodes in G that\nform the SCC that the node in C represents."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "After contracting all strongly connected components to a single node,\nthe resulting graph is a directed acyclic graph.",
            "Examples": "Contracting two sets of strongly connected nodes into two distinct SCC\nusing the barbell graph.\nG=nx.barbell_graph(4,0)\nG.remove_edge(3,4)\nG=nx.DiGraph(G)\nH=nx.condensation(G)\nH.nodes.data()\n# NodeDataView({0: {'members': {0, 1, 2, 3}}, 1: {'members': {4, 5, 6, 7}}})\nH.graph[\"mapping\"]\n# {0: 0, 1: 0, 2: 0, 3: 0, 4: 1, 5: 1, 6: 1, 7: 1}\nContracting a complete graph into one single SCC.\nG=nx.complete_graph(7,create_using=nx.DiGraph)\nH=nx.condensation(G)\nH.nodes\n# NodeView((0,))\nH.nodes.data()\n# NodeDataView({0: {'members': {0, 1, 2, 3, 4, 5, 6}}})"
        }
    },
    {
        "Section ID": "minimum_spanning_arborescence",
        "Description": [
            "Returns a minimum spanning arborescence from G."
        ],
        "Field List": {
            "Parameters:": {
                "G : (multi)digraph-like": "The graph to be searched.",
                "attr : str": "The edge attribute used to in determining optimality.",
                "default : float": "The value of the edge attribute used if an edge does not have\nthe attributeattr.",
                "preserve_attrs : bool": "If True, preserve the other attributes of the original graph (that are not\npassed toattr)",
                "partition : str": "The key for the edge attribute containing the partition\ndata on the graph. Edges can be included, excluded or open using theEdgePartitionenum."
            },
            "Returns:": {
                "B : (multi)digraph-like": "A minimum spanning arborescence."
            },
            "Raises:": {
                "NetworkXException": "If the graph does not contain a minimum spanning arborescence."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "group_in_degree_centrality",
        "Description": [
            "Compute the group in-degree centrality for a group of nodes.",
            "Group in-degree centrality of a group of nodes \\(S\\) is the fraction\nof non-group members connected to group members by incoming edges."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.",
                "S : list or set": "S is a group of nodes which belong to G, for which group in-degree\ncentrality is to be calculated."
            },
            "Returns:": {
                "centrality : float": "Group in-degree centrality of the group S."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If G is undirected.",
                "NodeNotFound": "If node(s) in S are not in G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The number of nodes in the group must be a maximum of n - 1 where n is the total number of nodes in the graph. G.neighbors(i) gives nodes with an outward edge from i, in a DiGraph,\nso for group in-degree centrality, the reverse graph is used."
        }
    },
    {
        "Section ID": "edges",
        "Description": [
            "Returns an edge view of edges incident to nodes in nbunch.",
            "Return all edges if nbunch is unspecified or nbunch=None.",
            "For digraphs, edges=out_edges",
            "This function wraps the G.edges property."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "lexicographic_product",
        "Description": [
            "Returns the lexicographic product of G and H.",
            "The lexicographical product \\(P\\) of the graphs \\(G\\) and \\(H\\) has a node set\nthat is the Cartesian product of the node sets, \\(V(P)=V(G) \\times V(H)\\) . \\(P\\) has an edge \\(((u,v), (x,y))\\) if and only if \\((u,v)\\) is an edge in \\(G\\) or \\(u==v\\) and \\((x,y)\\) is an edge in \\(H\\) ."
        ],
        "Field List": {
            "Parameters:": {
                "G, H: graphs": "Networkx graphs."
            },
            "Returns:": {
                "P: NetworkX graph": "The Cartesian product of G and H. P will be a multi-graph if either G\nor H is a multi-graph. Will be a directed if G and H are directed,\nand undirected if G and H are undirected."
            },
            "Raises:": {
                "NetworkXError": "If G and H are not both directed or both undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Node attributes in P are two-tuple of the G and H node attributes.\nMissing attributes are assigned None.",
            "Examples": "G=nx.Graph()\nH=nx.Graph()\nG.add_node(0,a1=True)\nH.add_node(\"a\",a2=\"Spam\")\nP=nx.lexicographic_product(G,H)\nlist(P)\n# [(0, 'a')]\nEdge attributes and edge keys (for multigraphs) are also copied to the\nnew product graph"
        }
    },
    {
        "Section ID": "show_multiedges",
        "Description": [
            "Returns a filter function that shows specific multi-undirected edges."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "read_leda",
        "Description": [
            "Read graph in LEDA format from path."
        ],
        "Field List": {
            "Parameters:": {
                "path : file or string": "File or filename to read.  Filenames ending in .gz or .bz2  will be\nuncompressed."
            },
            "Returns:": {
                "G : NetworkX graph": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]http://www.algorithmic-solutions.info/leda_guide/graphs/leda_native_graph_fileformat.html",
            "Examples": "G=nx.read_leda(\u2018file.leda\u2019)"
        }
    },
    {
        "Section ID": "negative_edge_cycle",
        "Description": [
            "Returns True if there exists a negative edge cycle anywhere in G."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number.",
                "heuristic : bool": "Determines whether to use a heuristic to early detect negative\ncycles at a negligible cost. In case of graphs with a negative cycle,\nthe performance of detection increases by at least an order of magnitude."
            },
            "Returns:": {
                "negative_cycle : bool": "True if a negative edge cycle exists, otherwise False."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. This algorithm uses bellman_ford_predecessor_and_distance() but finds\nnegative cycles on any component by first adding a new node connected to\nevery node, and starting bellman_ford_predecessor_and_distance on that\nnode.  It then removes that extra node.",
            "Examples": "G=nx.cycle_graph(5,create_using=nx.DiGraph())\nprint(nx.negative_edge_cycle(G))\n# False\nG[1][2][\"weight\"]=-7\nprint(nx.negative_edge_cycle(G))\n# True"
        }
    },
    {
        "Section ID": "bethe_hessian_spectrum",
        "Description": [
            "Returns eigenvalues of the Bethe Hessian matrix of G."
        ],
        "Field List": {
            "Parameters:": {
                "G : Graph": "A NetworkX Graph or DiGraph",
                "r : float": "Regularizer parameter"
            },
            "Returns:": {
                "evals : NumPy array": "Eigenvalues"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]A. Saade, F. Krzakala and L. Zdeborov\u00e1\n\u201cSpectral clustering of graphs with the bethe hessian\u201d,\nAdvances in Neural Information Processing Systems. 2014."
        }
    },
    {
        "Section ID": "find_cliques",
        "Description": [
            "Returns all maximal cliques in an undirected graph.",
            "For each node n , a maximal clique for n is a largest complete\nsubgraph containing n . The largest maximal clique is sometimes\ncalled the maximum clique .",
            "This function returns an iterator over cliques, each of which is a\nlist of nodes. It is an iterative implementation, so should not\nsuffer from recursion depth issues.",
            "This function accepts a list of nodes and only the maximal cliques\ncontaining all of these nodes are returned. It can considerably speed up\nthe running time if some specific cliques are desired."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "An undirected graph.",
                "nodes : list, optional (default=None)": "If provided, only yieldmaximal cliquescontaining all nodes innodes.\nIfnodesisn\u2019t a clique itself, a ValueError is raised."
            },
            "Returns:": {
                "iterator": "An iterator over maximal cliques, each of which is a list of\nnodes inG. Ifnodesis provided, only the maximal cliques\ncontaining all the nodes innodesare returned. The order of\ncliques is arbitrary."
            },
            "Raises:": {
                "ValueError": "Ifnodesis not a clique."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "To obtain a list of all maximal cliques, use list(find_cliques(G)) . However, be aware that in the worst-case,\nthe length of this list can be exponential in the number of nodes in\nthe graph. This function avoids storing all cliques in memory by\nonly keeping current candidate node lists in memory during its search. This implementation is based on the algorithm published by Bron and\nKerbosch (1973) [1] , as adapted by Tomita, Tanaka and Takahashi\n(2006) [2] and discussed in Cazals and Karande (2008) [3] . It\nessentially unrolls the recursion used in the references to avoid\nissues of recursion stack depth (for a recursive implementation, see find_cliques_recursive() ). This algorithm ignores self-loops and parallel edges, since cliques\nare not conventionally defined with such edges.",
            "References": "[1]Bron, C. and Kerbosch, J.\n\u201cAlgorithm 457: finding all cliques of an undirected graph\u201d.Communications of the ACM16, 9 (Sep. 1973), 575\u2013577.\n<http://portal.acm.org/citation.cfm?doid=362342.362367>  [2]Etsuji Tomita, Akira Tanaka, Haruhisa Takahashi,\n\u201cThe worst-case time complexity for generating all maximal\ncliques and computational experiments\u201d,Theoretical Computer Science, Volume 363, Issue 1,\nComputing and Combinatorics,\n10th Annual International Conference on\nComputing and Combinatorics (COCOON 2004), 25 October 2006, Pages 28\u201342\n<https://doi.org/10.1016/j.tcs.2006.06.015>  [3]F. Cazals, C. Karande,\n\u201cA note on the problem of reporting maximal cliques\u201d,Theoretical Computer Science,\nVolume 407, Issues 1\u20133, 6 November 2008, Pages 564\u2013568,\n<https://doi.org/10.1016/j.tcs.2008.05.010>",
            "Examples": "frompprintimportpprint# For nice dict formatting\nG=nx.karate_club_graph()\nsum(1forcinnx.find_cliques(G))# The number of maximal cliques in G\n# 36\nmax(nx.find_cliques(G),key=len)# The largest maximal clique in G\n# [0, 1, 2, 3, 13]\nThe size of the largest maximal clique is known as theclique numberof\nthe graph, which can be found directly with:\nmax(len(c)forcinnx.find_cliques(G))\n# 5\nOne can also compute the number of maximal cliques inGthat contain a given\nnode. The following produces a dictionary keyed by node whose\nvalues are the number of maximal cliques inGthat contain the node:\npprint({n:sum(1forcinnx.find_cliques(G)ifninc)forninG})\n# {0: 13,\n#  1: 6,\n#  2: 7,\n#  3: 3,\n#  4: 2,\n#  5: 3,\n#  6: 3,\n#  7: 1,\n#  8: 3,\n#  9: 2,\n#  10: 2,\n#  11: 1,\n#  12: 1,\n#  13: 2,\n#  14: 1,\n#  15: 1,\n#  16: 1,\n#  17: 1,\n#  18: 1,\n#  19: 2,\n#  20: 1,\n#  21: 1,\n#  22: 1,\n#  23: 3,\n#  24: 2,\n#  25: 2,\n#  26: 1,\n#  27: 3,\n#  28: 2,\n#  29: 2,\n#  30: 2,\n#  31: 4,\n#  32: 9,\n#  33: 14}\nOr, similarly, the maximal cliques inGthat contain a given node.\nFor example, the 4 maximal cliques that contain node 31:\n[cforcinnx.find_cliques(G)if31inc]\n# [[0, 31], [33, 32, 31], [33, 28, 31], [24, 25, 31]]"
        }
    },
    {
        "Section ID": "hide_multiedges",
        "Description": [
            "Returns a filter function that hides specific multi-undirected edges."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "kemeny_constant",
        "Description": [
            "Returns the Kemeny constant of the given graph.",
            "The Kemeny constant (or Kemeny\u2019s constant) of a graph G can be computed by regarding the graph as a Markov chain.\nThe Kemeny constant is then the expected number of time steps\nto transition from a starting state i to a random destination state\nsampled from the Markov chain\u2019s stationary distribution.\nThe Kemeny constant is independent of the chosen initial state [1] .",
            "The Kemeny constant measures the time needed for spreading\nacross a graph. Low values indicate a closely connected graph\nwhereas high values indicate a spread-out graph.",
            "If weight is not provided, then a weight of 1 is used for all edges.",
            "Since G represents a Markov chain, the weights must be positive."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "weight : string or None, optional (default=None)": "The edge data key used to compute the Kemeny constant.\nIf None, then each edge has weight 1."
            },
            "Returns:": {
                "float": "The Kemeny constant of the graphG."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the graphGis directed.",
                "NetworkXError": "If the graphGis not connected, or contains no nodes,\nor has edges with negative weights."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The implementation is based on equation (3.3) in [2] .\nSelf-loops are allowed and indicate a Markov chain where\nthe state can remain the same. Multi-edges are contracted\nin one edge with weight equal to the sum of the weights.",
            "References": "[1]Wikipedia\n\u201cKemeny\u2019s constant.\u201dhttps://en.wikipedia.org/wiki/Kemeny%27s_constant  [2]Lov\u00e1sz L.\nRandom walks on graphs: A survey.\nPaul Erd\u00f6s is Eighty, vol. 2, Bolyai Society,\nMathematical Studies, Keszthely, Hungary (1993), pp. 1-46",
            "Examples": "G=nx.complete_graph(5)\nround(nx.kemeny_constant(G),10)\n# 3.2"
        }
    },
    {
        "Section ID": "selfloop_edges",
        "Description": [
            "Returns an iterator over selfloop edges.",
            "A selfloop edge has the same node at both ends."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.",
                "data : string or bool, optional (default=False)": "Return selfloop edges as two tuples (u, v) (data=False)\nor three-tuples (u, v, datadict) (data=True)\nor three-tuples (u, v, datavalue) (data=\u2019attrname\u2019)",
                "keys : bool, optional (default=False)": "If True, return edge keys with each edge.",
                "default : value, optional (default=None)": "Value used for edges that don\u2019t have the requested attribute.\nOnly relevant if data is not True or False."
            },
            "Returns:": {
                "edgeiter : iterator over edge tuples": "An iterator over all selfloop edges."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.MultiGraph()# or Graph, DiGraph, MultiDiGraph, etc\nekey=G.add_edge(1,1)\nekey=G.add_edge(1,2)\nlist(nx.selfloop_edges(G))\n# [(1, 1)]\nlist(nx.selfloop_edges(G,data=True))\n# [(1, 1, {})]\nlist(nx.selfloop_edges(G,keys=True))\n# [(1, 1, 0)]\nlist(nx.selfloop_edges(G,keys=True,data=True))\n# [(1, 1, 0, {})]"
        }
    },
    {
        "Section ID": "recursive_simple_cycles",
        "Description": [
            "Find simple cycles (elementary circuits) of a directed graph.",
            "A simplecycle , or elementarycircuit , is a closed path where\nno node appears twice. Two elementary circuits are distinct if they\nare not cyclic permutations of each other.",
            "This version uses a recursive algorithm to build a list of cycles.\nYou should probably use the iterator version called simple_cycles().\nWarning: This recursive version uses lots of RAM!\nIt appears in NetworkX for pedagogical value."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX DiGraph": "A directed graph"
            },
            "Returns:": {
                "A list of cycles, where each cycle is represented by a list of nodes": "",
                "along the cycle.": "",
                "Example:": "",
                "[[0], [2], [0, 1, 2], [0, 2], [1, 2]]": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The implementation follows pp. 79-80 in [1] . The time complexity is \\(O((n+e)(c+1))\\) for \\(n\\) nodes, \\(e\\) edges and \\(c\\) elementary circuits.",
            "References": "[1]Finding all the elementary circuits of a directed graph.\nD. B. Johnson, SIAM Journal on Computing 4, no. 1, 77-84, 1975.https://doi.org/10.1137/0204007"
        }
    },
    {
        "Section ID": "chvatal_graph",
        "Description": [
            "Returns the Chv\u00e1tal Graph",
            "The Chv\u00e1tal Graph is an undirected graph with 12 nodes and 24 edges [1] .\nIt has 370 distinct (directed) Hamiltonian cycles, giving a unique generalized\nLCF notation of order 4, two of order 6 , and 43 of order 1 [2] ."
        ],
        "Field List": {
            "Parameters:": {
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : networkx Graph": "The Chv\u00e1tal graph with 12 nodes and 24 edges"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://en.wikipedia.org/wiki/Chv%C3%A1tal_graph  [2]https://mathworld.wolfram.com/ChvatalGraph.html"
        }
    },
    {
        "Section ID": "to_undirected",
        "Description": [
            "Returns an undirected view of the graph graph .",
            "Identical to graph.to_undirected(as_view=True)\nNote that graph.to_undirected defaults to as_view=False while this function always provides a view."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "tree_broadcast_time",
        "Description": [
            "Return the Broadcast Time of the tree G .",
            "The minimum broadcast time of a node is defined as the minimum amount\nof time required to complete broadcasting starting from the\noriginator. The broadcast time of a graph is the maximum over\nall nodes of the minimum broadcast time from that node [1] .\nThis function returns the minimum broadcast time of node .\nIf node is None the broadcast time for the graph is returned."
        ],
        "Field List": {
            "Parameters:": {
                "G : undirected graph": "The graph should be an undirected tree",
                "node: int, optional": "index of starting node. IfNone, the algorithm returns the broadcast\ntime of the tree."
            },
            "Returns:": {
                "BT : int": "Broadcast Time of a node in a tree"
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the graph is directed or is a multigraph."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Harutyunyan, H. A. and Li, Z.\n\u201cA Simple Construction of Broadcast Graphs.\u201d\nIn Computing and Combinatorics. COCOON 2019\n(Ed. D. Z. Du and C. Tian.) Springer, pp. 240-253, 2019."
        }
    },
    {
        "Section ID": "node_expansion",
        "Description": [
            "Returns the node expansion of the set S .",
            "The node expansion is the quotient of the size of the node\nboundary of S and the cardinality of S . [1]"
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "S : collection": "A collection of nodes inG."
            },
            "Returns:": {
                "number": "The node expansion of the setS."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Vadhan, Salil P.\n\u201cPseudorandomness.\u201dFoundations and Trends\nin Theoretical Computer Science7.1\u20133 (2011): 1\u2013336.\n<https://doi.org/10.1561/0400000010>"
        }
    },
    {
        "Section ID": "optimize_graph_edit_distance",
        "Description": [
            "Returns consecutive approximations of GED (graph edit distance)\nbetween graphs G1 and G2.",
            "Graph edit distance is a graph similarity measure analogous to\nLevenshtein distance for strings.  It is defined as minimum cost\nof edit path (sequence of node and edge edit operations)\ntransforming graph G1 to graph isomorphic to G2."
        ],
        "Field List": {
            "Parameters:": {
                "G1, G2: graphs": "The two graphs G1 and G2 must be of the same type.",
                "node_match : callable": "A function that returns True if node n1 in G1 and n2 in G2\nshould be considered equal during matching.The function will be called likenode_match(G1.nodes[n1], G2.nodes[n2]).That is, the function will receive the node attribute\ndictionaries for n1 and n2 as inputs.Ignored if node_subst_cost is specified.  If neither\nnode_match nor node_subst_cost are specified then node\nattributes are not considered.",
                "edge_match : callable": "A function that returns True if the edge attribute dictionaries\nfor the pair of nodes (u1, v1) in G1 and (u2, v2) in G2 should\nbe considered equal during matching.The function will be called likeedge_match(G1[u1][v1], G2[u2][v2]).That is, the function will receive the edge attribute\ndictionaries of the edges under consideration.Ignored if edge_subst_cost is specified.  If neither\nedge_match nor edge_subst_cost are specified then edge\nattributes are not considered.",
                "node_subst_cost, node_del_cost, node_ins_cost : callable": "Functions that return the costs of node substitution, node\ndeletion, and node insertion, respectively.The functions will be called likenode_subst_cost(G1.nodes[n1], G2.nodes[n2]),\nnode_del_cost(G1.nodes[n1]),\nnode_ins_cost(G2.nodes[n2]).That is, the functions will receive the node attribute\ndictionaries as inputs.  The functions are expected to return\npositive numeric values.Function node_subst_cost overrides node_match if specified.\nIf neither node_match nor node_subst_cost are specified then\ndefault node substitution cost of 0 is used (node attributes\nare not considered during matching).If node_del_cost is not specified then default node deletion\ncost of 1 is used.  If node_ins_cost is not specified then\ndefault node insertion cost of 1 is used.",
                "edge_subst_cost, edge_del_cost, edge_ins_cost : callable": "Functions that return the costs of edge substitution, edge\ndeletion, and edge insertion, respectively.The functions will be called likeedge_subst_cost(G1[u1][v1], G2[u2][v2]),\nedge_del_cost(G1[u1][v1]),\nedge_ins_cost(G2[u2][v2]).That is, the functions will receive the edge attribute\ndictionaries as inputs.  The functions are expected to return\npositive numeric values.Function edge_subst_cost overrides edge_match if specified.\nIf neither edge_match nor edge_subst_cost are specified then\ndefault edge substitution cost of 0 is used (edge attributes\nare not considered during matching).If edge_del_cost is not specified then default edge deletion\ncost of 1 is used.  If edge_ins_cost is not specified then\ndefault edge insertion cost of 1 is used.",
                "upper_bound : numeric": "Maximum edit distance to consider."
            },
            "Returns:": {
                "Generator of consecutive approximations of graph edit distance.": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Zeina Abu-Aisheh, Romain Raveaux, Jean-Yves Ramel, Patrick\nMartineau. An Exact Graph Edit Distance Algorithm for Solving\nPattern Recognition Problems. 4th International Conference on\nPattern Recognition Applications and Methods 2015, Jan 2015,\nLisbon, Portugal. 2015,\n<10.5220/0005209202710278>. <hal-01168816>https://hal.archives-ouvertes.fr/hal-01168816",
            "Examples": "G1=nx.cycle_graph(6)\nG2=nx.wheel_graph(7)\nforvinnx.optimize_graph_edit_distance(G1,G2):\nminv=v\nminv\n# 7.0"
        }
    },
    {
        "Section ID": "trophic_levels",
        "Description": [
            "Compute the trophic levels of nodes.",
            "The trophic level of a node \\(i\\) is",
            "where \\(k^{in}_i\\) is the in-degree of i",
            "and nodes with \\(k^{in}_i = 0\\) have \\(s_i = 1\\) by convention.",
            "These are calculated using the method outlined in Levine [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : DiGraph": "A directed networkx graph"
            },
            "Returns:": {
                "nodes : dict": "Dictionary of nodes with trophic level as the value."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Stephen Levine (1980) J. theor. Biol. 83, 195-207"
        }
    },
    {
        "Section ID": "to_edgelist",
        "Description": [
            "Returns a list of edges in the graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "nodelist : list": "Use only nodes specified in nodelist"
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "fast_gnp_random_graph",
        "Description": [
            "Returns a \\(G_{n,p}\\) random graph, also known as an Erd\u0151s-R\u00e9nyi graph or\na binomial graph."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes.",
                "p : float": "Probability for edge creation.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "directed : bool, optional (default=False)": "If True, this function returns a directed graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The \\(G_{n,p}\\) graph algorithm chooses each of the \\([n (n - 1)] / 2\\) (undirected) or \\(n (n - 1)\\) (directed) possible edges with probability \\(p\\) . This algorithm [1] runs in \\(O(n + m)\\) time, where m is the expected number of\nedges, which equals \\(p n (n - 1) / 2\\) . This should be faster than gnp_random_graph() when \\(p\\) is small and the expected number of edges\nis small (that is, the graph is sparse).",
            "References": "[1]Vladimir Batagelj and Ulrik Brandes,\n\u201cEfficient generation of large random networks\u201d,\nPhys. Rev. E, 71, 036113, 2005."
        }
    },
    {
        "Section ID": "gaussian_random_partition_graph",
        "Description": [
            "Generate a Gaussian random partition graph.",
            "A Gaussian random partition graph is created by creating k partitions\neach with a size drawn from a normal distribution with mean s and variance\ns/v. Nodes are connected within clusters with probability p_in and\nbetween clusters with probability p_out[1]"
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "Number of nodes in the graph",
                "s : float": "Mean cluster size",
                "v : float": "Shape parameter. The variance of cluster size distribution is s/v.",
                "p_in : float": "Probability of intra cluster connection.",
                "p_out : float": "Probability of inter cluster connection.",
                "directed : boolean, optional default=False": "Whether to create a directed graph or not",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "G : NetworkX Graph or DiGraph": "gaussian random partition graph"
            },
            "Raises:": {
                "NetworkXError": "If s is > n\nIf p_in or p_out is not in [0,1]"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Note the number of partitions is dependent on s,v and n, and that the\nlast partition may be considerably smaller, as it is sized to simply\nfill out the nodes [1]",
            "References": "[1]Ulrik Brandes, Marco Gaertler, Dorothea Wagner,\nExperiments on Graph Clustering Algorithms,\nIn the proceedings of the 11th Europ. Symp. Algorithms, 2003.",
            "Examples": "G=nx.gaussian_random_partition_graph(100,10,10,0.25,0.1)\nlen(G)\n# 100"
        }
    },
    {
        "Section ID": "weighted_projected_graph",
        "Description": [
            "Returns a weighted projection of B onto one of its node sets.",
            "The weighted projected graph is the projection of the bipartite\nnetwork B onto the specified nodes with weights representing the\nnumber of shared neighbors or the ratio between actual shared\nneighbors and possible shared neighbors if ratioisTrue  [1] .\nThe nodes retain their attributes and are connected in the resulting\ngraph if they have an edge to a common node in the original graph."
        ],
        "Field List": {
            "Parameters:": {
                "B : NetworkX graph": "The input graph should be bipartite.",
                "nodes : list or iterable": "Distinct nodes to project onto (the \u201cbottom\u201d nodes).",
                "ratio: Bool (default=False)": "If True, edge weight is the ratio between actual shared neighbors\nand maximum possible shared neighbors (i.e., the size of the other\nnode set). If False, edges weight is the number of shared neighbors."
            },
            "Returns:": {
                "Graph : NetworkX graph": "A graph that is the projection onto the given nodes."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "No attempt is made to verify that the input graph B is bipartite, or that\nthe input nodes are distinct. However, if the length of the input nodes is\ngreater than or equal to the nodes in the graph B, an exception is raised.\nIf the nodes are not distinct but don\u2019t raise this error, the output weights\nwill be incorrect.\nThe graph and node properties are (shallow) copied to the projected graph. See bipartitedocumentation for further details on how bipartite graphs are handled in NetworkX.",
            "References": "[1]Borgatti, S.P. and Halgin, D. In press. \u201cAnalyzing Affiliation\nNetworks\u201d. In Carrington, P. and Scott, J. (eds) The Sage Handbook\nof Social Network Analysis. Sage Publications.",
            "Examples": "fromnetworkx.algorithmsimportbipartite\nB=nx.path_graph(4)\nG=bipartite.weighted_projected_graph(B,[1,3])\nlist(G)\n# [1, 3]\nlist(G.edges(data=True))\n# [(1, 3, {'weight': 1})]\nG=bipartite.weighted_projected_graph(B,[1,3],ratio=True)\nlist(G.edges(data=True))\n# [(1, 3, {'weight': 0.5})]"
        }
    },
    {
        "Section ID": "is_valid_degree_sequence_havel_hakimi",
        "Description": [
            "Returns True if deg_sequence can be realized by a simple graph.",
            "The validation proceeds using the Havel-Hakimi theorem [havel1955] , [hakimi1962] , [CL1996] .\nWorst-case run time is \\(O(s)\\) where \\(s\\) is the sum of the sequence."
        ],
        "Field List": {
            "Parameters:": {
                "deg_sequence : list": "A list of integers where each element specifies the degree of a node\nin a graph."
            },
            "Returns:": {
                "valid : bool": "True if deg_sequence is graphical and False if not."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The ZZ condition says that for the sequence d if",
            "References": "[1]I.E. Zverovich and V.E. Zverovich. \u201cContributions to the theory\nof graphic sequences\u201d, Discrete Mathematics, 105, pp. 292-303 (1992).  [havel1955]Havel, V. \u201cA Remark on the Existence of Finite Graphs\u201d\nCasopis Pest. Mat. 80, 477-480, 1955.  [hakimi1962]Hakimi, S. \u201cOn the Realizability of a Set of Integers as\nDegrees of the Vertices of a Graph.\u201d SIAM J. Appl. Math. 10, 496-506, 1962.  [CL1996]G. Chartrand and L. Lesniak, \u201cGraphs and Digraphs\u201d,\nChapman and Hall/CRC, 1996.",
            "Examples": "G=nx.Graph([(1,2),(1,3),(2,3),(3,4),(4,2),(5,1),(5,4)])\nsequence=(dfor_,dinG.degree())\nnx.is_valid_degree_sequence_havel_hakimi(sequence)\n# True\nTo test a non-valid sequence:\n>>> sequence_list = [d for _, d in G.degree()]\n>>> sequence_list[-1] += 1\n>>> nx.is_valid_degree_sequence_havel_hakimi(sequence_list)\nFalse"
        }
    },
    {
        "Section ID": "floyd_warshall_numpy",
        "Description": [
            "Find all-pairs shortest path lengths using Floyd\u2019s algorithm.",
            "This algorithm for finding shortest paths takes advantage of\nmatrix representations of a graph and works well for dense\ngraphs where all-pairs shortest path lengths are desired.\nThe results are returned as a NumPy array, distance[i, j],\nwhere i and j are the indexes of two nodes in nodelist.\nThe entry distance[i, j] is the distance along a shortest\npath from i to j. If no path exists the distance is Inf."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "nodelist : list, optional (default=G.nodes)": "The rows and columns are ordered by the nodes in nodelist.\nIf nodelist is None then the ordering is produced by G.nodes.\nNodelist should include all nodes in G.",
                "weight: string, optional (default=\u2019weight\u2019)": "Edge data key corresponding to the edge weight."
            },
            "Returns:": {
                "distance : 2D numpy.ndarray": "A numpy array of shortest path distances between nodes.\nIf there is no path between two nodes the value is Inf."
            },
            "Raises:": {
                "NetworkXError": "If nodelist is not a list of the nodes in G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Floyd\u2019s algorithm is appropriate for finding shortest paths in\ndense graphs or graphs with negative weights when Dijkstra\u2019s\nalgorithm fails. This algorithm can still fail if there are negative\ncycles. It has running time \\(O(n^3)\\) with running space of \\(O(n^2)\\) .",
            "Examples": "G=nx.DiGraph()\nG.add_weighted_edges_from([(0,1,5),(1,2,2),(2,3,-3),(1,3,10),(3,2,8)])\nnx.floyd_warshall_numpy(G)\n# array([[ 0.,  5.,  7.,  4.],\n#        [inf,  0.,  2., -1.],\n#        [inf, inf,  0., -3.],\n#        [inf, inf,  8.,  0.]])"
        }
    },
    {
        "Section ID": "parse_multiline_adjlist",
        "Description": [
            "Parse lines of a multiline adjacency list representation of a graph."
        ],
        "Field List": {
            "Parameters:": {
                "lines : list or iterator of strings": "Input data in multiline adjlist format",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated.",
                "nodetype : Python type, optional": "Convert nodes to this type.",
                "edgetype : Python type, optional": "Convert edges to this type.",
                "comments : string, optional": "Marker for comment lines",
                "delimiter : string, optional": "Separator for node labels.  The default is whitespace."
            },
            "Returns:": {
                "G: NetworkX graph": "The graph corresponding to the lines in multiline adjacency list format."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "lines=[\n\"1 2\",\n\"2 {'weight':3, 'name': 'Frodo'}\",\n\"3 {}\",\n\"2 1\",\n\"5 {'weight':6, 'name': 'Saruman'}\",\n]\nG=nx.parse_multiline_adjlist(iter(lines),nodetype=int)\nlist(G)\n# [1, 2, 3, 5]"
        }
    },
    {
        "Section ID": "is_biconnected",
        "Description": [
            "Returns True if the graph is biconnected, False otherwise.",
            "A graph is biconnected if, and only if, it cannot be disconnected by\nremoving only one node (and all edges incident on that node).  If\nremoving a node increases the number of disconnected components\nin the graph, that node is called an articulation point, or cut\nvertex.  A biconnected graph has no articulation points."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "An undirected graph."
            },
            "Returns:": {
                "biconnected : bool": "True if the graph is biconnected, False otherwise."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the input graph is not undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The algorithm to find articulation points and biconnected\ncomponents is implemented using a non-recursive depth-first-search\n(DFS) that keeps track of the highest level that back edges reach\nin the DFS tree.  A node n is an articulation point if, and only\nif, there exists a subtree rooted at n such that there is no\nback edge from any successor of n that links to a predecessor of n in the DFS tree.  By keeping track of all the edges traversed\nby the DFS we can obtain the biconnected components because all\nedges of a bicomponent will be traversed consecutively between\narticulation points.",
            "References": "[1]Hopcroft, J.; Tarjan, R. (1973).\n\u201cEfficient algorithms for graph manipulation\u201d.\nCommunications of the ACM 16: 372\u2013378. doi:10.1145/362248.362272",
            "Examples": "G=nx.path_graph(4)\nprint(nx.is_biconnected(G))\n# False\nG.add_edge(0,3)\nprint(nx.is_biconnected(G))\n# True"
        }
    },
    {
        "Section ID": "k_edge_subgraphs",
        "Description": [
            "Generates nodes in each maximal k-edge-connected subgraph in G."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "k : Integer": "Desired edge connectivity"
            },
            "Returns:": {
                "k_edge_subgraphs : a generator of k-edge-subgraphs": "Each k-edge-subgraph is a maximal set of nodes that defines a subgraph\nof G that is k-edge-connected."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the input graph is a multigraph.",
                "ValueError:": "If k is less than 1"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Attempts to use the most efficient implementation available based on k.\nIf k=1, or k=2 and the graph is undirected, then this simply calls k_edge_components .  Otherwise the algorithm from _[1] is used.",
            "References": "[1]Zhou, Liu, et al. (2012) Finding maximal k-edge-connected subgraphs\nfrom a large graph.  ACM International Conference on Extending Database\nTechnology 2012 480-\u2013491.https://openproceedings.org/2012/conf/edbt/ZhouLYLCL12.pdf",
            "Examples": "importitertoolsasit\nfromnetworkx.utilsimportpairwise\npaths=[\n(1,2,4,3,1,4),\n(5,6,7,8,5,7,8,6),\n]\nG=nx.Graph()\nG.add_nodes_from(it.chain(*paths))\nG.add_edges_from(it.chain(*[pairwise(path)forpathinpaths]))\n# note this does not return {1, 4} unlike k_edge_components\nsorted(map(sorted,nx.k_edge_subgraphs(G,k=3)))\n# [[1], [2], [3], [4], [5, 6, 7, 8]]"
        }
    },
    {
        "Section ID": "nodes_equal",
        "Description": [
            "Check if nodes are equal.",
            "Equality here means equal as Python objects.\nNode data must match if included.\nThe order of nodes is not relevant."
        ],
        "Field List": {
            "Parameters:": {
                "nodes1, nodes2 : iterables of nodes, or (node, datadict) tuples": ""
            },
            "Returns:": {
                "bool": "True if nodes are equal, False otherwise."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "add_star",
        "Description": [
            "Add a star to Graph G_to_add_to.",
            "The first node in nodes_for_star is the middle of the star.\nIt is connected to all other nodes."
        ],
        "Field List": {
            "Parameters:": {
                "G_to_add_to : graph": "A NetworkX graph",
                "nodes_for_star : iterable container": "A container of nodes.",
                "attr : keyword arguments, optional (default= no attributes)": "Attributes to add to every edge in star."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph()\nnx.add_star(G,[0,1,2,3])\nnx.add_star(G,[10,11,12],weight=2)"
        }
    },
    {
        "Section ID": "octahedral_graph",
        "Description": [
            "Returns the Platonic Octahedral graph.",
            "The octahedral graph is the 6-node 12-edge Platonic graph having the\nconnectivity of the octahedron [1] . If 6 couples go to a party,\nand each person shakes hands with every person except his or her partner,\nthen this graph describes the set of handshakes that take place;\nfor this reason it is also called the cocktail party graph [2] ."
        ],
        "Field List": {
            "Parameters:": {
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : networkx Graph": "Octahedral graph"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://mathworld.wolfram.com/OctahedralGraph.html  [2]https://en.wikipedia.org/wiki/Tur%C3%A1n_graph#Special_cases"
        }
    },
    {
        "Section ID": "full_rary_tree",
        "Description": [
            "Creates a full r-ary tree of n nodes.",
            "Sometimes called a k-ary, n-ary, or m-ary tree.\n\u201c\u2026 all non-leaf nodes have exactly r children and all levels\nare full except for some rightmost position of the bottom level\n(if a leaf at the bottom level is missing, then so are all of the\nleaves to its right.\u201d [1]",
            "( Sourcecode , png )"
        ],
        "Field List": {
            "Parameters:": {
                "r : int": "branching factor of the tree",
                "n : int": "Number of nodes in the tree",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : networkx Graph": "An r-ary tree with n nodes"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]An introduction to data structures and algorithms,\nJames Andrew Storer,  Birkhauser Boston 2001, (page 225)."
        }
    },
    {
        "Section ID": "draw_networkx_edge_labels",
        "Description": [
            "Draw edge labels."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph",
                "pos : dictionary": "A dictionary with nodes as keys and positions as values.\nPositions should be sequences of length 2.",
                "edge_labels : dictionary (default=None)": "Edge labels in a dictionary of labels keyed by edge two-tuple.\nOnly labels for the keys in the dictionary are drawn.",
                "label_pos : float (default=0.5)": "Position of edge label along edge (0=head, 0.5=center, 1=tail)",
                "font_size : int (default=10)": "Font size for text labels",
                "font_color : color (default=\u2019k\u2019 black)": "Font color string. Color can be string or rgb (or rgba) tuple of\nfloats from 0-1.",
                "font_weight : string (default=\u2019normal\u2019)": "Font weight",
                "font_family : string (default=\u2019sans-serif\u2019)": "Font family",
                "alpha : float or None (default=None)": "The text transparency",
                "bbox : Matplotlib bbox, optional": "Specify text box properties (e.g. shape, color etc.) for edge labels.\nDefault is {boxstyle=\u2019round\u2019, ec=(1.0, 1.0, 1.0), fc=(1.0, 1.0, 1.0)}.",
                "horizontalalignment : string (default=\u2019center\u2019)": "Horizontal alignment {\u2018center\u2019, \u2018right\u2019, \u2018left\u2019}",
                "verticalalignment : string (default=\u2019center\u2019)": "Vertical alignment {\u2018center\u2019, \u2018top\u2019, \u2018bottom\u2019, \u2018baseline\u2019, \u2018center_baseline\u2019}",
                "ax : Matplotlib Axes object, optional": "Draw the graph in the specified Matplotlib axes.",
                "rotate : bool (default=True)": "Rotate edge labels to lie parallel to edges",
                "clip_on : bool (default=True)": "Turn on clipping of edge labels at axis boundaries",
                "node_size : scalar or array (default=300)": "Size of nodes.  If an array it must be the same length as nodelist.",
                "nodelist : list, optional (default=G.nodes())": "This provides the node order for thenode_sizearray (if it is an array).",
                "connectionstyle : string or iterable of strings (default=\u201darc3\u201d)": "Pass the connectionstyle parameter to create curved arc of rounding\nradius rad. For example, connectionstyle=\u2019arc3,rad=0.2\u2019.\nSeematplotlib.patches.ConnectionStyleandmatplotlib.patches.FancyArrowPatchfor more info.\nIf Iterable, index indicates i\u2019th edge key of MultiGraph",
                "hide_ticks : bool, optional": "Hide ticks of axes. WhenTrue(the default), ticks and ticklabels\nare removed from the axes. To set ticks and tick labels to the pyplot default,\nusehide_ticks=False."
            },
            "Returns:": {
                "dict": "dictof labels keyed by edge"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.dodecahedral_graph()\nedge_labels=nx.draw_networkx_edge_labels(G,pos=nx.spring_layout(G))\nAlso see the NetworkX drawing examples athttps://networkx.org/documentation/latest/auto_examples/index.html"
        }
    },
    {
        "Section ID": "stochastic_graph",
        "Description": [
            "Returns a right-stochastic representation of directed graph G .",
            "A right-stochastic graph is a weighted digraph in which for each\nnode, the sum of the weights of all the out-edges of that node is\n1. If the graph is already weighted (for example, via a \u2018weight\u2019\nedge attribute), the reweighting takes that into account."
        ],
        "Field List": {
            "Parameters:": {
                "G : directed graph": "ADiGraphorMultiDiGraph.",
                "copy : boolean, optional": "If this is True, then this function returns a new graph with\nthe stochastic reweighting. Otherwise, the original graph is\nmodified in-place (and also returned, for convenience).",
                "weight : edge attribute key (optional, default=\u2019weight\u2019)": "Edge attribute key used for reading the existing weight and\nsetting the new weight.  If no attribute with this key is found\nfor an edge, then the edge weight is assumed to be 1. If an edge\nhas a weight, it must be a positive number."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "grid_graph",
        "Description": [
            "Returns the n -dimensional grid graph.",
            "The dimension n is the length of the list dim and the size in\neach dimension is the value of the corresponding list element."
        ],
        "Field List": {
            "Parameters:": {
                "dim : list or tuple of numbers or iterables of nodes": "\u2018dim\u2019 is a tuple or list with, for each dimension, either a number\nthat is the size of that dimension or an iterable of nodes for\nthat dimension. The dimension of the grid_graph is the length\nofdim.",
                "periodic : bool or iterable": "Ifperiodicis True, all dimensions are periodic. If False all\ndimensions are not periodic. Ifperiodicis iterable, it should\nyielddimbool values each of which indicates whether the\ncorresponding axis is periodic."
            },
            "Returns:": {
                "NetworkX graph": "The (possibly periodic) grid graph of the specified dimensions."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "To produce a 2 by 3 by 4 grid graph, a graph on 24 nodes:\nfromnetworkximportgrid_graph\nG=grid_graph(dim=(2,3,4))\nlen(G)\n# 24\nG=grid_graph(dim=(range(7,9),range(3,6)))\nlen(G)\n# 6"
        }
    },
    {
        "Section ID": "dijkstra_path_length",
        "Description": [
            "Returns the shortest weighted path length in G from source to target.",
            "Uses Dijkstra\u2019s Method to compute the shortest weighted path length\nbetween two nodes in a graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node label": "starting node for path",
                "target : node label": "ending node for path",
                "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge."
            },
            "Returns:": {
                "length : number": "Shortest path length."
            },
            "Raises:": {
                "NodeNotFound": "Ifsourceis not inG.",
                "NetworkXNoPath": "If no path exists between source and target."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The weight function can be used to hide edges by returning None.\nSo weight=lambdau,v,d:1ifd['color']==\"red\"elseNone will find the shortest red path. The function single_source_dijkstra() computes both\npath and length-of-path if you need both, use that.",
            "Examples": "G=nx.path_graph(5)\nnx.dijkstra_path_length(G,0,4)\n# 4"
        }
    },
    {
        "Section ID": "relabel_gexf_graph",
        "Description": [
            "Relabel graph using \u201clabel\u201d node keyword for node label."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph read from GEXF data"
            },
            "Returns:": {
                "H : graph": "A NetworkX graph with relabeled nodes"
            },
            "Raises:": {
                "NetworkXError": "If node labels are missing or not unique while relabel=True."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This function relabels the nodes in a NetworkX graph with the\n\u201clabel\u201d attribute.  It also handles relabeling the specific GEXF\nnode attributes \u201cparents\u201d, and \u201cpid\u201d."
        }
    },
    {
        "Section ID": "voterank",
        "Description": [
            "Select a list of influential nodes in a graph using VoteRank algorithm",
            "VoteRank [1] computes a ranking of the nodes in a graph G based on a\nvoting scheme. With VoteRank, all nodes vote for each of its in-neighbors\nand the node with the highest votes is elected iteratively. The voting\nability of out-neighbors of elected nodes is decreased in subsequent turns."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.",
                "number_of_nodes : integer, optional": "Number of ranked nodes to extract (default all nodes)."
            },
            "Returns:": {
                "voterank : list": "Ordered list of computed seeds.\nOnly nodes with positive number of votes are returned."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Each edge is treated independently in case of multigraphs.",
            "References": "[1]Zhang, J.-X. et al. (2016).\nIdentifying a set of influential spreaders in complex networks.\nSci. Rep. 6, 27823; doi: 10.1038/srep27823.",
            "Examples": "G=nx.Graph([(0,1),(0,2),(0,3),(1,4)])\nnx.voterank(G)\n# [0, 1]\nThe algorithm can be used both for undirected and directed graphs.\nHowever, the directed version is different in two ways:\n(i) nodes only vote for their in-neighbors and\n(ii) only the voting ability of elected node and its out-neighbors are updated:\nG=nx.DiGraph([(0,1),(2,1),(2,3),(3,4)])\nnx.voterank(G)\n# [2, 3]"
        }
    },
    {
        "Section ID": "multi_source_dijkstra_path_length",
        "Description": [
            "Find shortest weighted path lengths in G from a given set of\nsource nodes.",
            "Compute the shortest path length between any of the source nodes and\nall other reachable nodes for a weighted graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "sources : non-empty set of nodes": "Starting nodes for paths. If this is just a set containing a\nsingle node, then all paths computed by this function will start\nfrom that node. If there are two or more nodes in the set, the\ncomputed paths may begin from any one of the start nodes.",
                "cutoff : integer or float, optional": "Length (sum of edge weights) at which the search is stopped.\nIf cutoff is provided, only return paths with summed weight <= cutoff.",
                "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge."
            },
            "Returns:": {
                "length : dict": "Dict keyed by node to shortest path length to nearest source."
            },
            "Raises:": {
                "ValueError": "Ifsourcesis empty.",
                "NodeNotFound": "If any ofsourcesis not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The weight function can be used to hide edges by returning None.\nSo weight=lambdau,v,d:1ifd['color']==\"red\"elseNone will find the shortest red path.",
            "Examples": "G=nx.path_graph(5)\nlength=nx.multi_source_dijkstra_path_length(G,{0,4})\nfornodein[0,1,2,3,4]:\nprint(f\"{node}: {length[node]}\")\n# 0: 0\n# 1: 1\n# 2: 2\n# 3: 1\n# 4: 0"
        }
    },
    {
        "Section ID": "is_tree",
        "Description": [
            "Returns True if G is a tree.",
            "A tree is a connected graph with no undirected cycles.",
            "For directed graphs, G is a tree if the underlying graph is a tree. The\nunderlying graph is obtained by treating each directed edge as a single\nundirected edge in a multigraph."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "The graph to test."
            },
            "Returns:": {
                "b : bool": "A boolean that is True ifGis a tree."
            },
            "Raises:": {
                "NetworkXPointlessConcept": "IfGis empty."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "In another convention, a directed tree is known as a polytree and then tree corresponds to an arborescence .",
            "Examples": "G=nx.Graph()\nG.add_edges_from([(1,2),(1,3),(2,4),(2,5)])\nnx.is_tree(G)# n-1 edges\n# True\nG.add_edge(3,4)\nnx.is_tree(G)# n edges\n# False"
        }
    },
    {
        "Section ID": "UnionAtlas",
        "Description": [
            "A read-only union of two atlases (dict-of-dict).",
            "The two dict-of-dicts represent the inner dict of\nan Adjacency: G.succ[node] and G.pred[node] .\nThe inner level of dict of both hold attribute key:value\npairs and is read-write. But the outer level is read-only."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "chordal_graph_cliques",
        "Description": [
            "Returns all maximal cliques of a chordal graph.",
            "The algorithm breaks the graph in connected components and performs a\nmaximum cardinality search in each component to get the cliques."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph"
            },
            "Yields:": {
                "frozenset of nodes": "Maximal cliques, each of which is a frozenset of\nnodes inG. The order of cliques is arbitrary."
            },
            "Raises:": {
                "NetworkXError": "The algorithm does not support DiGraph, MultiGraph and MultiDiGraph.\nThe algorithm can only be applied to chordal graphs. If the input\ngraph is found to be non-chordal, aNetworkXErroris raised."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "e=[\n(1,2),\n(1,3),\n(2,3),\n(2,4),\n(3,4),\n(3,5),\n(3,6),\n(4,5),\n(4,6),\n(5,6),\n(7,8),\n]\nG=nx.Graph(e)\nG.add_node(9)\ncliques=[cforcinchordal_graph_cliques(G)]\ncliques[0]\n# frozenset({1, 2, 3})"
        }
    },
    {
        "Section ID": "write_edgelist",
        "Description": [
            "Write a bipartite graph as a list of edges."
        ],
        "Field List": {
            "Parameters:": {
                "G : Graph": "A NetworkX bipartite graph",
                "path : file or string": "File or filename to write. If a file is provided, it must be\nopened in \u2018wb\u2019 mode. Filenames ending in .gz or .bz2 will be compressed.",
                "comments : string, optional": "The character used to indicate the start of a comment",
                "delimiter : string, optional": "The string used to separate values.  The default is whitespace.",
                "data : bool or list, optional": "If False write no edge data.\nIf True write a string representation of the edge data dictionary..\nIf a list (or other iterable) is provided, write the  keys specified\nin the list.",
                "encoding: string, optional": "Specify which encoding to use when writing file."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.path_graph(4)\nG.add_nodes_from([0,2],bipartite=0)\nG.add_nodes_from([1,3],bipartite=1)\nnx.write_edgelist(G,\"test.edgelist\")\nfh=open(\"test.edgelist\",\"wb\")\nnx.write_edgelist(G,fh)\nnx.write_edgelist(G,\"test.edgelist.gz\")\nnx.write_edgelist(G,\"test.edgelist.gz\",data=False)\nG=nx.Graph()\nG.add_edge(1,2,weight=7,color=\"red\")\nnx.write_edgelist(G,\"test.edgelist\",data=False)\nnx.write_edgelist(G,\"test.edgelist\",data=[\"color\"])\nnx.write_edgelist(G,\"test.edgelist\",data=[\"color\",\"weight\"])"
        }
    },
    {
        "Section ID": "generic_weighted_projected_graph",
        "Description": [
            "Weighted projection of B with a user-specified weight function.",
            "The bipartite network B is projected on to the specified nodes\nwith weights computed by a user-specified function.  This function\nmust accept as a parameter the neighborhood sets of two nodes and\nreturn an integer or a float.",
            "The nodes retain their attributes and are connected in the resulting graph\nif they have an edge to a common node in the original graph."
        ],
        "Field List": {
            "Parameters:": {
                "B : NetworkX graph": "The input graph should be bipartite.",
                "nodes : list or iterable": "Nodes to project onto (the \u201cbottom\u201d nodes).",
                "weight_function : function": "This function must accept as parameters the same input graph\nthat this function, and two nodes; and return an integer or a float.\nThe default function computes the number of shared neighbors."
            },
            "Returns:": {
                "Graph : NetworkX graph": "A graph that is the projection onto the given nodes."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "No attempt is made to verify that the input graph B is bipartite.\nThe graph and node properties are (shallow) copied to the projected graph. See bipartitedocumentation for further details on how bipartite graphs are handled in NetworkX.",
            "Examples": "fromnetworkx.algorithmsimportbipartite\n# Define some custom weight functions\ndefjaccard(G,u,v):\nunbrs=set(G[u])\nvnbrs=set(G[v])\nreturnfloat(len(unbrs&vnbrs))/len(unbrs|vnbrs)\ndefmy_weight(G,u,v,weight=\"weight\"):\nw=0\nfornbrinset(G[u])&set(G[v]):\nw+=G[u][nbr].get(weight,1)+G[v][nbr].get(weight,1)\nreturnw\n# A complete bipartite graph with 4 nodes and 4 edges\nB=nx.complete_bipartite_graph(2,2)\n# Add some arbitrary weight to the edges\nfori,(u,v)inenumerate(B.edges()):\nB.edges[u,v][\"weight\"]=i+1\nforedgeinB.edges(data=True):\nprint(edge)\n# (0, 2, {'weight': 1})\n# (0, 3, {'weight': 2})\n# (1, 2, {'weight': 3})\n# (1, 3, {'weight': 4})\n# By default, the weight is the number of shared neighbors\nG=bipartite.generic_weighted_projected_graph(B,[0,1])\nprint(list(G.edges(data=True)))\n# [(0, 1, {'weight': 2})]\n# To specify a custom weight function use the weight_function parameter\nG=bipartite.generic_weighted_projected_graph(B,[0,1],weight_function=jaccard)\nprint(list(G.edges(data=True)))\n# [(0, 1, {'weight': 1.0})]\nG=bipartite.generic_weighted_projected_graph(B,[0,1],weight_function=my_weight)\nprint(list(G.edges(data=True)))\n# [(0, 1, {'weight': 10})]"
        }
    },
    {
        "Section ID": "nonisomorphic_trees",
        "Description": [
            "Generates lists of nonisomorphic trees"
        ],
        "Field List": {
            "Parameters:": {
                "order : int": "order of the desired tree(s)",
                "create : one of {\u201cgraph\u201d, \u201cmatrix\u201d} (default=\u201dgraph\u201d)": "If\"graph\"is selected a list ofGraphinstances will be returned,\nif matrix is selected a list of adjacency matrices will be returned.Deprecated since version 3.3:Thecreateargument is deprecated and will be removed in NetworkX\nversion 3.5. In the future,nonisomorphic_treeswill yield graph\ninstances by default. To generate adjacency matrices, callnx.to_numpy_arrayon the output, e.g.:[nx.to_numpy_array(G)forGinnx.nonisomorphic_trees(N)]"
            },
            "Yields:": {
                "list": "A list of nonisomorphic trees, in one of two formats depending on the\nvalue of thecreateparameter:\n-create=\"graph\": yields a list ofnetworkx.Graphinstances\n-create=\"matrix\": yields a list of list-of-lists representing adjacency matrices"
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "center",
        "Description": [
            "Returns the center of the graph G.",
            "The center is the set of nodes with eccentricity equal to radius."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A graph",
                "e : eccentricity dictionary, optional": "A precomputed dictionary of eccentricities.",
                "weight : string, function, or None": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number.If this is None, every edge has weight/distance/cost 1.Weights stored as floating point values can lead to small round-off\nerrors in distances. Use integer weights to avoid this.Weights should be positive, since they are distances."
            },
            "Returns:": {
                "c : list": "List of nodes in center"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph([(1,2),(1,3),(1,4),(3,4),(3,5),(4,5)])\nlist(nx.center(G))\n# [1, 3, 4]"
        }
    },
    {
        "Section ID": "is_perfect_matching",
        "Description": [
            "Return True if matching is a perfect matching for G",
            "A perfect matching in a graph is a matching in which exactly one edge\nis incident upon each vertex."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "matching : dict or set": "A dictionary or set representing a matching. If a dictionary, it\nmust havematching[u]==vandmatching[v]==ufor each\nedge(u,v)in the matching. If a set, it must have elements\nof the form(u,v), where(u,v)is an edge in the\nmatching."
            },
            "Returns:": {
                "bool": "Whether the given set or dictionary represents a valid perfect\nmatching in the graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph([(1,2),(1,3),(2,3),(2,4),(3,5),(4,5),(4,6)])\nmy_match={1:2,3:5,4:6}\nnx.is_perfect_matching(G,my_match)\n# True"
        }
    },
    {
        "Section ID": "all_pairs_dijkstra_path",
        "Description": [
            "Compute shortest paths between all nodes in a weighted graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "cutoff : integer or float, optional": "Length (sum of edge weights) at which the search is stopped.\nIf cutoff is provided, only return paths with summed weight <= cutoff.",
                "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge."
            },
            "Returns:": {
                "paths : iterator": "(source, dictionary) iterator with dictionary keyed by target and\nshortest path as the key value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.",
            "Examples": "G=nx.path_graph(5)\npath=dict(nx.all_pairs_dijkstra_path(G))\npath[0][4]\n# [0, 1, 2, 3, 4]"
        }
    },
    {
        "Section ID": "tensor_product",
        "Description": [
            "Returns the tensor product of G and H.",
            "The tensor product \\(P\\) of the graphs \\(G\\) and \\(H\\) has a node set that\nis the Cartesian product of the node sets, \\(V(P)=V(G) \\times V(H)\\) . \\(P\\) has an edge \\(((u,v), (x,y))\\) if and only if \\((u,x)\\) is an edge in \\(G\\) and \\((v,y)\\) is an edge in \\(H\\) .",
            "Tensor product is sometimes also referred to as the categorical product,\ndirect product, cardinal product or conjunction."
        ],
        "Field List": {
            "Parameters:": {
                "G, H: graphs": "Networkx graphs."
            },
            "Returns:": {
                "P: NetworkX graph": "The tensor product of G and H. P will be a multi-graph if either G\nor H is a multi-graph, will be a directed if G and H are directed,\nand undirected if G and H are undirected."
            },
            "Raises:": {
                "NetworkXError": "If G and H are not both directed or both undirected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Node attributes in P are two-tuple of the G and H node attributes.\nMissing attributes are assigned None.",
            "Examples": "G=nx.Graph()\nH=nx.Graph()\nG.add_node(0,a1=True)\nH.add_node(\"a\",a2=\"Spam\")\nP=nx.tensor_product(G,H)\nlist(P)\n# [(0, 'a')]\nEdge attributes and edge keys (for multigraphs) are also copied to the\nnew product graph"
        }
    },
    {
        "Section ID": "random_tournament",
        "Description": [
            "Returns a random tournament graph on n nodes."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes in the returned graph.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "G : DiGraph": "A tournament onnnodes, with exactly one directed edge joining\neach pair of distinct nodes."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm adds, for each pair of distinct nodes, an edge with\nuniformly random orientation. In other words, binom{n}{2} flips\nof an unbiased coin decide the orientations of the edges in the\ngraph."
        }
    },
    {
        "Section ID": "directed_joint_degree_graph",
        "Description": [
            "Generates a random simple directed graph with the joint degree."
        ],
        "Field List": {
            "Parameters:": {
                "degree_seq : list of tuples (of size 3)": "degree sequence contains tuples of nodes with node id, in degree and\nout degree.",
                "nkk : dictionary of dictionary of integers": "directed joint degree dictionary, for nodes of out degree k (first\nlevel of dict) and nodes of in degree l (second level of dict)\ndescribes the number of edges.",
                "seed : hashable object, optional": "Seed for random number generator."
            },
            "Returns:": {
                "G : Graph": "A directed graph with the specified inputs."
            },
            "Raises:": {
                "NetworkXError": "If degree_seq and nkk are not realizable as a simple directed graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Similarly to the undirected version:\nIn each iteration of the \u201cwhile loop\u201d the algorithm picks two disconnected\nnodes v and w, of degree k and l correspondingly,  for which nkk[k][l] has\nnot reached its target yet i.e. (for given k,l): n_edges_add < nkk[k][l].\nIt then adds edge (v,w) and always increases the number of edges in graph G\nby one. The intelligence of the algorithm lies in the fact that  it is always\npossible to add an edge between disconnected nodes v and w, for which\nnkk[degree(v)][degree(w)] has not reached its target, even if one or both\nnodes do not have free stubs. If either node v or w does not have a free\nstub, we perform a \u201cneighbor switch\u201d, an edge rewiring move that releases a\nfree stub while keeping nkk the same. The difference for the directed version lies in the fact that neighbor\nswitches might not be able to rewire, but in these cases unsaturated nodes\ncan be reassigned to use instead, see [1] for detailed description and\nproofs. The algorithm continues for E (number of edges in the graph) iterations of\nthe \u201cwhile loop\u201d, at which point all entries of the given nkk[k][l] have\nreached their target values and the construction is complete.",
            "References": "[1] B. Tillman, A. Markopoulou, C. T. Butts & M. Gjoka, \u201cConstruction of Directed 2K Graphs\u201d. In Proc. of KDD 2017.",
            "Examples": "in_degrees=[0,1,1,2]\nout_degrees=[1,1,1,1]\nnkk={1:{1:2,2:2}}\nG=nx.directed_joint_degree_graph(in_degrees,out_degrees,nkk)"
        }
    },
    {
        "Section ID": "florentine_families_graph",
        "Description": [
            "Returns Florentine families graph.",
            "References"
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Ronald L. Breiger and Philippa E. Pattison\nCumulated social roles: The duality of persons and their algebras,1\nSocial Networks, Volume 8, Issue 3, September 1986, Pages 215-256"
        }
    },
    {
        "Section ID": "generic_bfs_edges",
        "Description": [
            "Iterate over edges in a breadth-first search.",
            "The breadth-first search begins at source and enqueues the\nneighbors of newly visited nodes specified by the neighbors function."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node": "Starting node for the breadth-first search; this function\niterates over only those edges in the component reachable from\nthis node.",
                "neighbors : function": "A function that takes a newly visited node of the graph as input\nand returns aniterator(not just a list) of nodes that are\nneighbors of that node with custom ordering. If not specified, this is\njust theG.neighborsmethod, but in general it can be any function\nthat returns an iterator over some or all of the neighbors of a\ngiven node, in any order.",
                "depth_limit : int, optional(default=len(G))": "Specify the maximum search depth.",
                "sort_neighbors : Callable (default=None)": "Deprecated since version 3.2:The sort_neighbors parameter is deprecated and will be removed in\nversion 3.4. A custom (e.g. sorted) ordering of neighbors can be\nspecified with theneighborsparameter.A function that takes an iterator over nodes as the input, and\nreturns an iterable of the same nodes with a custom ordering.\nFor example,sortedwill sort the nodes in increasing order."
            },
            "Yields:": {
                "edge": "Edges in the breadth-first search starting fromsource."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This implementation is from PADS , which was in the public domain\nwhen it was first accessed in July, 2004.  The modifications\nto allow depth limits are based on the Wikipedia article\n\u201c Depth-limited-search \u201d.",
            "Examples": "G=nx.path_graph(7)\nlist(nx.generic_bfs_edges(G,source=0))\n# [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]\nlist(nx.generic_bfs_edges(G,source=2))\n# [(2, 1), (2, 3), (1, 0), (3, 4), (4, 5), (5, 6)]\nlist(nx.generic_bfs_edges(G,source=2,depth_limit=2))\n# [(2, 1), (2, 3), (1, 0), (3, 4)]\nTheneighborsparam can be used to specify the visitation order of each\nnode\u2019s neighbors generically. In the following example, we modify the default\nneighbor to returnoddnodes first:\ndefodd_first(n):\nreturnsorted(G.neighbors(n),key=lambdax:x%2,reverse=True)\nG=nx.star_graph(5)\nlist(nx.generic_bfs_edges(G,source=0))# Default neighbor ordering\n# [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5)]\nlist(nx.generic_bfs_edges(G,source=0,neighbors=odd_first))\n# [(0, 1), (0, 3), (0, 5), (0, 2), (0, 4)]"
        }
    },
    {
        "Section ID": "read_pajek",
        "Description": [
            "Read graph in Pajek format from path."
        ],
        "Field List": {
            "Parameters:": {
                "path : file or string": "File or filename to write.\nFilenames ending in .gz or .bz2 will be uncompressed."
            },
            "Returns:": {
                "G : NetworkX MultiGraph or MultiDiGraph.": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "See http://vlado.fmf.uni-lj.si/pub/networks/pajek/doc/draweps.htm for format information.",
            "Examples": "G=nx.path_graph(4)\nnx.write_pajek(G,\"test.net\")\nG=nx.read_pajek(\"test.net\")\nTo create a Graph instead of a MultiGraph use\nG1=nx.Graph(G)"
        }
    },
    {
        "Section ID": "attribute_assortativity_coefficient",
        "Description": [
            "Compute assortativity for node attributes.",
            "Assortativity measures the similarity of connections\nin the graph with respect to the given attribute."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "attribute : string": "Node attribute key",
                "nodes: list or iterable (optional)": "Compute attribute assortativity for nodes in container.\nThe default is all nodes."
            },
            "Returns:": {
                "r: float": "Assortativity of graph for given attribute"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This computes Eq. (2) in Ref. [1] , (trace(M)-sum(M^2))/(1-sum(M^2)),\nwhere M is the joint probability distribution (mixing matrix)\nof the specified attribute.",
            "References": "[1]M. E. J. Newman, Mixing patterns in networks,\nPhysical Review E, 67 026126, 2003",
            "Examples": "G=nx.Graph()\nG.add_nodes_from([0,1],color=\"red\")\nG.add_nodes_from([2,3],color=\"blue\")\nG.add_edges_from([(0,1),(2,3)])\nprint(nx.attribute_assortativity_coefficient(G,\"color\"))\n# 1.0"
        }
    },
    {
        "Section ID": "density",
        "Description": [
            "Returns density of bipartite graph B."
        ],
        "Field List": {
            "Parameters:": {
                "B : NetworkX graph": "",
                "nodes: list or container": "Nodes in one node set of the bipartite graph."
            },
            "Returns:": {
                "d : float": "The bipartite density"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The container of nodes passed as argument must contain all nodes\nin one of the two bipartite node sets to avoid ambiguity in the\ncase of disconnected graphs.\nSee bipartitedocumentation for further details on how bipartite graphs are handled in NetworkX.",
            "Examples": "fromnetworkx.algorithmsimportbipartite\nG=nx.complete_bipartite_graph(3,2)\nX=set([0,1,2])\nbipartite.density(G,X)\n# 1.0\nY=set([3,4])\nbipartite.density(G,Y)\n# 1.0"
        }
    },
    {
        "Section ID": "get_edge_attributes",
        "Description": [
            "Get edge attributes from graph"
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "",
                "name : string": "Attribute name",
                "default: object (default=None)": "Default value of the edge attribute if there is no value set for that\nedge in graph. IfNonethen edges without this attribute are not\nincluded in the returned dict."
            },
            "Returns:": {
                "Dictionary of attributes keyed by edge. For (di)graphs, the keys are": "",
                "2-tuples of the form: (u, v). For multi(di)graphs, the keys are 3-tuples of": "",
                "the form: (u, v, key).": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph()\nnx.add_path(G,[1,2,3],color=\"red\")\ncolor=nx.get_edge_attributes(G,\"color\")\ncolor[(1,2)]\n# 'red'\nG.add_edge(3,4)\ncolor=nx.get_edge_attributes(G,\"color\",default=\"yellow\")\ncolor[(3,4)]\n# 'yellow'"
        }
    },
    {
        "Section ID": "scale_free_graph",
        "Description": [
            "Returns a scale-free directed graph."
        ],
        "Field List": {
            "Parameters:": {
                "n : integer": "Number of nodes in graph",
                "alpha : float": "Probability for adding a new node connected to an existing node\nchosen randomly according to the in-degree distribution.",
                "beta : float": "Probability for adding an edge between two existing nodes.\nOne existing node is chosen randomly according the in-degree\ndistribution and the other chosen randomly according to the out-degree\ndistribution.",
                "gamma : float": "Probability for adding a new node connected to an existing node\nchosen randomly according to the out-degree distribution.",
                "delta_in : float": "Bias for choosing nodes from in-degree distribution.",
                "delta_out : float": "Bias for choosing nodes from out-degree distribution.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "initial_graph : MultiDiGraph instance, optional": "Build the scale-free graph starting from this initial MultiDiGraph,\nif provided."
            },
            "Returns:": {
                "MultiDiGraph": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The sum of alpha , beta , and gamma must be 1.",
            "References": "[1]B. Bollob\u00e1s, C. Borgs, J. Chayes, and O. Riordan,\nDirected scale-free graphs,\nProceedings of the fourteenth annual ACM-SIAM Symposium on\nDiscrete Algorithms, 132\u2013139, 2003.",
            "Examples": "Create a scale-free graph on one hundred nodes:\nG=nx.scale_free_graph(100)"
        }
    },
    {
        "Section ID": "rich_club_coefficient",
        "Description": [
            "Returns the rich-club coefficient of the graph G .",
            "For each degree k , the rich-club coefficient is the ratio of the\nnumber of actual to the number of potential edges for nodes with\ndegree greater than k :",
            "where N_k is the number of nodes with degree larger than k , and E_k is the number of edges among those nodes."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected graph with neither parallel edges nor self-loops.",
                "normalized : bool (optional)": "Normalize using randomized network as in[1]",
                "Q : float (optional, default=100)": "Ifnormalizedis True, performQ*mdouble-edge\nswaps, wheremis the number of edges inG, to use as a\nnull-model for normalization.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "rc : dictionary": "A dictionary, keyed by degree, with rich-club coefficient values."
            },
            "Raises:": {
                "NetworkXError": "IfGhas fewer than four nodes andnormalized=True.\nA randomly sampled graph for normalization cannot be generated in this case."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The rich club definition and algorithm are found in [1] .  This\nalgorithm ignores any edge weights and is not defined for directed\ngraphs or graphs with parallel edges or self loops. Normalization is done by computing the rich club coefficient for a randomly\nsampled graph with the same degree distribution as G by\nrepeatedly swapping the endpoints of existing edges. For graphs with fewer than 4\nnodes, it is not possible to generate a random graph with a prescribed\ndegree distribution, as the degree distribution fully determines the graph\n(hence making the coefficients trivially normalized to 1).\nThis function raises an exception in this case. Estimates for appropriate values of Q are found in [2] .",
            "References": "[1](1,2)Julian J. McAuley, Luciano da Fontoura Costa,\nand Tib\u00e9rio S. Caetano,\n\u201cThe rich-club phenomenon across complex network hierarchies\u201d,\nApplied Physics Letters Vol 91 Issue 8, August 2007.https://arxiv.org/abs/physics/0701290  [2]R. Milo, N. Kashtan, S. Itzkovitz, M. E. J. Newman, U. Alon,\n\u201cUniform generation of random graphs with arbitrary degree\nsequences\u201d, 2006.https://arxiv.org/abs/cond-mat/0312028",
            "Examples": "G=nx.Graph([(0,1),(0,2),(1,2),(1,3),(1,4),(4,5)])\nrc=nx.rich_club_coefficient(G,normalized=False,seed=42)\nrc[0]\n# 0.4"
        }
    },
    {
        "Section ID": "clustering",
        "Description": [
            "Compute the clustering coefficient for nodes.",
            "For unweighted graphs, the clustering of a node \\(u\\) is the fraction of possible triangles through that node that exist,",
            "where \\(T(u)\\) is the number of triangles through node \\(u\\) and \\(deg(u)\\) is the degree of \\(u\\) .",
            "For weighted graphs, there are several ways to define clustering [1] .\nthe one used here is defined\nas the geometric average of the subgraph edge weights [2] ,",
            "The edge weights \\(\\hat{w}_{uv}\\) are normalized by the maximum weight\nin the network \\(\\hat{w}_{uv} = w_{uv}/\\max(w)\\) .",
            "The value of \\(c_u\\) is assigned to 0 if \\(deg(u) < 2\\) .",
            "Additionally, this weighted definition has been generalized to support negative edge weights [3] .",
            "For directed graphs, the clustering is similarly defined as the fraction\nof all possible directed triangles or geometric average of the subgraph\nedge weights for unweighted and weighted directed graph respectively [4] .",
            "where \\(T(u)\\) is the number of directed triangles through node \\(u\\) , \\(deg^{tot}(u)\\) is the sum of in degree and out degree of \\(u\\) and \\(deg^{\\leftrightarrow}(u)\\) is the reciprocal degree of \\(u\\) ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "",
                "nodes : node, iterable of nodes, or None (default=None)": "If a singleton node, return the number of triangles for that node.\nIf an iterable, compute the number of triangles for each of those nodes.\nIfNone(the default) compute the number of triangles for all nodes inG.",
                "weight : string or None, optional (default=None)": "The edge attribute that holds the numerical value used as a weight.\nIf None, then each edge has weight 1."
            },
            "Returns:": {
                "out : float, or dictionary": "Clustering coefficient at specified nodes"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Self loops are ignored.",
            "References": "[1]Generalizations of the clustering coefficient to weighted\ncomplex networks by J. Saram\u00e4ki, M. Kivel\u00e4, J.-P. Onnela,\nK. Kaski, and J. Kert\u00e9sz, Physical Review E, 75 027105 (2007).http://jponnela.com/web_documents/a9.pdf  [2]Intensity and coherence of motifs in weighted complex\nnetworks by J. P. Onnela, J. Saram\u00e4ki, J. Kert\u00e9sz, and K. Kaski,\nPhysical Review E, 71(6), 065103 (2005).  [3]Generalization of Clustering Coefficients to Signed Correlation Networks\nby G. Costantini and M. Perugini, PloS one, 9(2), e88669 (2014).  [4]Clustering in complex directed networks by G. Fagiolo,\nPhysical Review E, 76(2), 026107 (2007).",
            "Examples": "G=nx.complete_graph(5)\nprint(nx.clustering(G,0))\n# 1.0\nprint(nx.clustering(G))\n# {0: 1.0, 1: 1.0, 2: 1.0, 3: 1.0, 4: 1.0}"
        }
    },
    {
        "Section ID": "show_diedges",
        "Description": [
            "Returns a filter function that shows specific directed edges."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "read_graph6",
        "Description": [
            "Read simple undirected graphs in graph6 format from path."
        ],
        "Field List": {
            "Parameters:": {
                "path : file or string": "File or filename to write."
            },
            "Returns:": {
                "G : Graph or list of Graphs": "If the file contains multiple lines then a list of graphs is returned"
            },
            "Raises:": {
                "NetworkXError": "If the string is unable to be parsed in graph6 format"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Graph6 specification\n<http://users.cecs.anu.edu.au/~bdm/data/formats.html>",
            "Examples": "You can read a graph6 file by giving the path to the file:\nimporttempfile\nwithtempfile.NamedTemporaryFile(delete=False)asf:\n_=f.write(b\">>graph6<<A_\\n\")\n_=f.seek(0)\nG=nx.read_graph6(f.name)\nlist(G.edges())\n# [(0, 1)]\nYou can also read a graph6 file by giving an open file-like object:\nimporttempfile\nwithtempfile.NamedTemporaryFile()asf:\n_=f.write(b\">>graph6<<A_\\n\")\n_=f.seek(0)\nG=nx.read_graph6(f)\nlist(G.edges())\n# [(0, 1)]"
        }
    },
    {
        "Section ID": "lattice_reference",
        "Description": [
            "Latticize the given graph by swapping edges."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "An undirected graph.",
                "niter : integer (optional, default=1)": "An edge is rewired approximately niter times.",
                "D : numpy.array (optional, default=None)": "Distance to the diagonal matrix.",
                "connectivity : boolean (optional, default=True)": "Ensure connectivity for the latticized graph when set to True.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "G : graph": "The latticized graph."
            },
            "Raises:": {
                "NetworkXError": "If there are fewer than 4 nodes or 2 edges inG"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The implementation is adapted from the algorithm by Sporns et al. [1] .\nwhich is inspired from the original work by Maslov and Sneppen(2002) [2] .",
            "References": "[1]Sporns, Olaf, and Jonathan D. Zwi.\n\u201cThe small world of the cerebral cortex.\u201d\nNeuroinformatics 2.2 (2004): 145-162.  [2]Maslov, Sergei, and Kim Sneppen.\n\u201cSpecificity and stability in topology of protein networks.\u201d\nScience 296.5569 (2002): 910-913."
        }
    },
    {
        "Section ID": "random_labeled_tree",
        "Description": [
            "Returns a labeled tree on n nodes chosen uniformly at random.",
            "Generating uniformly distributed random Pr\u00fcfer sequences and\nconverting them into the corresponding trees is a straightforward\nmethod of generating uniformly distributed random labeled trees.\nThis function implements this method."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes, greater than zero.",
                "seed : random_state": "Indicator of random number generation state.\nSeeRandomness"
            },
            "Returns:": {
                "networkx.Graph": "Anetworkx.Graphwith nodes in the set {0, \u2026,n- 1}."
            },
            "Raises:": {
                "NetworkXPointlessConcept": "Ifnis zero (because the null graph is not a tree)."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "trivial_graph",
        "Description": [
            "Return the Trivial graph with one node (with label 0) and no edges.",
            "( Sourcecode , png )"
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "general_random_intersection_graph",
        "Description": [
            "Returns a random intersection graph with independent probabilities\nfor connections between node and attribute sets."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes in the first bipartite set (nodes)",
                "m : int": "The number of nodes in the second bipartite set (attributes)",
                "p : list of floats of length m": "Probabilities for connecting nodes to each attribute",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Nikoletseas, S. E., Raptopoulos, C., and Spirakis, P. G.\nThe existence and efficient construction of large independent sets\nin general random intersection graphs. In ICALP (2004), J. D\u00b4\u0131az,\nJ. Karhum\u00a8aki, A. Lepist\u00a8o, and D. Sannella, Eds., vol. 3142\nof Lecture Notes in Computer Science, Springer, pp. 1029\u20131040."
        }
    },
    {
        "Section ID": "wheel_graph",
        "Description": [
            "Return the wheel graph",
            "The wheel graph consists of a hub node connected to a cycle of (n-1) nodes.",
            "( Sourcecode , png )"
        ],
        "Field List": {
            "Parameters:": {
                "n : int or iterable": "If an integer, node labels are 0 to n with center 0.\nIf an iterable of nodes, the center is the first.\nWarning: n is not checked for duplicates and if present the\nresulting graph may not be as desired. Make sure you have no duplicates.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated.",
                "Node labels are the integers 0 to n - 1.": ""
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "is_directed_acyclic_graph",
        "Description": [
            "Returns True if the graph G is a directed acyclic graph (DAG) or\nFalse if not."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": ""
            },
            "Returns:": {
                "bool": "True ifGis a DAG, False otherwise"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "Undirected graph:\nG=nx.Graph([(1,2),(2,3)])\nnx.is_directed_acyclic_graph(G)\n# False\nDirected graph with cycle:\nG=nx.DiGraph([(1,2),(2,3),(3,1)])\nnx.is_directed_acyclic_graph(G)\n# False\nDirected acyclic graph:\nG=nx.DiGraph([(1,2),(2,3)])\nnx.is_directed_acyclic_graph(G)\n# True"
        }
    },
    {
        "Section ID": "AdjacencyView",
        "Description": [
            "An AdjacencyView is a Read-only Map of Maps of Maps.",
            "It is a View into a dict-of-dict-of-dict data structure.\nThe inner level of dict is read-write. But the\nouter levels are read-only."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "graph_atlas",
        "Description": [
            "Returns graph number i from the Graph Atlas.",
            "For more information, see graph_atlas_g() ."
        ],
        "Field List": {
            "Parameters:": {
                "i : int": "The index of the graph from the atlas to get. The graph at index\n0 is assumed to be the null graph."
            },
            "Returns:": {
                "list": "A list ofGraphobjects, the one at indexicorresponding to the graphiin the Graph Atlas."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The time required by this function increases linearly with the\nargument i , since it reads a large file sequentially in order to\ngenerate the graph [1] .",
            "References": "[1]Ronald C. Read and Robin J. Wilson,An Atlas of Graphs.\nOxford University Press, 1998."
        }
    },
    {
        "Section ID": "max_clique",
        "Description": [
            "Find the Maximum Clique",
            "Finds the \\(O(|V|/(log|V|)^2)\\) apx of maximum clique/independent set\nin the worst case."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected graph"
            },
            "Returns:": {
                "clique : set": "The apx-maximum clique of the graph"
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the graph is directed or is a multigraph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "A clique in an undirected graph G = (V, E) is a subset of the vertex set CsubseteqV such that for every two vertices in C there exists an edge\nconnecting the two. This is equivalent to saying that the subgraph\ninduced by C is complete (in some cases, the term clique may also refer\nto the subgraph). A maximum clique is a clique of the largest possible size in a given graph.\nThe clique number omega(G) of a graph G is the number of\nvertices in a maximum clique in G. The intersection number of\nG is the smallest number of cliques that together cover all edges of G. https://en.wikipedia.org/wiki/Maximum_clique",
            "References": "[1]Boppana, R., & Halld\u00f3rsson, M. M. (1992).\nApproximating maximum independent sets by excluding subgraphs.\nBIT Numerical Mathematics, 32(2), 180\u2013196. Springer.\ndoi:10.1007/BF01994876",
            "Examples": "G=nx.path_graph(10)\nnx.approximation.max_clique(G)\n# {8, 9}"
        }
    },
    {
        "Section ID": "strategy_connected_sequential_bfs",
        "Description": [
            "Returns an iterable over nodes in G in the order given by a\nbreadth-first traversal.",
            "The generated sequence has the property that for each node except\nthe first, at least one neighbor appeared earlier in the sequence.",
            "G is a NetworkX graph. colors is ignored."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "bidirectional_dijkstra",
        "Description": [
            "Dijkstra\u2019s algorithm for shortest paths using bidirectional search."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node": "Starting node.",
                "target : node": "Ending node.",
                "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge."
            },
            "Returns:": {
                "length, path : number and list": "length is the distance from source to target.\npath is a list of nodes on a path from source to target."
            },
            "Raises:": {
                "NodeNotFound": "If eithersourceortargetis not inG.",
                "NetworkXNoPath": "If no path exists between source and target."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The weight function can be used to hide edges by returning None.\nSo weight=lambdau,v,d:1ifd['color']==\"red\"elseNone will find the shortest red path. In practice  bidirectional Dijkstra is much more than twice as fast as\nordinary Dijkstra. Ordinary Dijkstra expands nodes in a sphere-like manner from the\nsource. The radius of this sphere will eventually be the length\nof the shortest path. Bidirectional Dijkstra will expand nodes\nfrom both the source and the target, making two spheres of half\nthis radius. Volume of the first sphere is pi*r*r while the\nothers are 2*pi*r/2*r/2 , making up half the volume. This algorithm is not guaranteed to work if edge weights\nare negative or are floating point numbers\n(overflows and roundoff errors can cause problems).",
            "Examples": "G=nx.path_graph(5)\nlength,path=nx.bidirectional_dijkstra(G,0,4)\nprint(length)\n# 4\nprint(path)\n# [0, 1, 2, 3, 4]"
        }
    },
    {
        "Section ID": "effective_size",
        "Description": [
            "Returns the effective size of all nodes in the graph G .",
            "The effective size of a node\u2019s ego network is based on the concept\nof redundancy. A person\u2019s ego network has redundancy to the extent\nthat her contacts are connected to each other as well. The\nnonredundant part of a person\u2019s relationships is the effective\nsize of her ego network [1] .  Formally, the effective size of a\nnode \\(u\\) , denoted \\(e(u)\\) , is defined by",
            "where \\(N(u)\\) is the set of neighbors of \\(u\\) and \\(p_{uw}\\) is the\nnormalized mutual weight of the (directed or undirected) edges\njoining \\(u\\) and \\(v\\) , for each vertex \\(u\\) and \\(v\\)  [1] . And \\(m_{vw}\\) is the mutual weight of \\(v\\) and \\(w\\) divided by \\(v\\) highest mutual\nweight with any of its neighbors. The mutual weight of \\(u\\) and \\(v\\) is the sum of the weights of edges joining them (edge weights are\nassumed to be one if the graph is unweighted).",
            "For the case of unweighted and undirected graphs, Borgatti proposed\na simplified formula to compute effective size [2]",
            "where t is the number of ties in the ego network (not including\nties to ego) and n is the number of nodes (excluding ego)."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "The graph containingv. Directed graphs are treated like\nundirected graphs when computing neighbors ofv.",
                "nodes : container, optional": "Container of nodes in the graphGto compute the effective size.\nIf None, the effective size of every node is computed.",
                "weight : None or string, optional": "If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight."
            },
            "Returns:": {
                "dict": "Dictionary with nodes as keys and the effective size of the node as values."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Burt also defined the related concept of efficiency of a node\u2019s ego\nnetwork, which is its effective size divided by the degree of that\nnode [1] . So you can easily compute efficiency:",
            "References": "[1](1,2,3)Burt, Ronald S.Structural Holes: The Social Structure of Competition.Cambridge: Harvard University Press, 1995.  [2]Borgatti, S.\n\u201cStructural Holes: Unpacking Burt\u2019s Redundancy Measures\u201d\nCONNECTIONS 20(1):35-38.http://www.analytictech.com/connections/v20(1)/holes.htm"
        }
    },
    {
        "Section ID": "read_gexf",
        "Description": [
            "Read graph in GEXF format from path.",
            "\u201cGEXF (Graph Exchange XML Format) is a language for describing\ncomplex networks structures, their associated data and dynamics\u201d [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "path : file or string": "File or file name to read.\nFile names ending in .gz or .bz2 will be decompressed.",
                "node_type: Python type (default: None)": "Convert node ids to this type if not None.",
                "relabel : bool (default: False)": "If True relabel the nodes to use the GEXF node \u201clabel\u201d attribute\ninstead of the node \u201cid\u201d attribute as the NetworkX node label.",
                "version : string (default: 1.2draft)": "",
                "Version of GEFX File Format (see http://gexf.net/schema.html)": "Supported values: \u201c1.1draft\u201d, \u201c1.2draft\u201d"
            },
            "Returns:": {
                "graph: NetworkX graph": "If no parallel edges are found a Graph or DiGraph is returned.\nOtherwise a MultiGraph or MultiDiGraph is returned."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This implementation does not support mixed graphs (directed and undirected\nedges together).",
            "References": "[1]GEXF File Format,http://gexf.net/"
        }
    },
    {
        "Section ID": "isolates",
        "Description": [
            "Iterator over isolates in the graph.",
            "An isolate is a node with no neighbors (that is, with degree\nzero). For directed graphs, this means no in-neighbors and no\nout-neighbors."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": ""
            },
            "Returns:": {
                "iterator": "An iterator over the isolates ofG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "To get a list of all isolates of a graph, use thelistconstructor:\nG=nx.Graph()\nG.add_edge(1,2)\nG.add_node(3)\nlist(nx.isolates(G))\n# [3]\nTo remove all isolates in the graph, first create a list of the\nisolates, then useGraph.remove_nodes_from():\nG.remove_nodes_from(list(nx.isolates(G)))\nlist(G)\n# [1, 2]\nFor digraphs, isolates have zero in-degree and zero out_degre:\nG=nx.DiGraph([(0,1),(1,2)])\nG.add_node(3)\nlist(nx.isolates(G))\n# [3]"
        }
    },
    {
        "Section ID": "degree",
        "Description": [
            "Returns a degree view of single node or of nbunch of nodes.\nIf nbunch is omitted, then return degrees of all nodes.",
            "This function wraps the G.degree property."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "build_residual_network",
        "Description": [
            "Build a residual network and initialize a zero flow.",
            "The residual network R from an input graph G has the\nsame nodes as G . R is a DiGraph that contains a pair\nof edges (u,v) and (v,u) iff (u,v) is not a\nself-loop, and at least one of (u,v) and (v,u) exists\nin G .",
            "For each edge (u,v) in R , R[u][v]['capacity'] is equal to the capacity of (u,v) in G if it exists\nin G or zero otherwise. If the capacity is infinite, R[u][v]['capacity'] will have a high arbitrary finite value\nthat does not affect the solution of the problem. This value is stored in R.graph['inf'] . For each edge (u,v) in R , R[u][v]['flow'] represents the flow function of (u,v) and\nsatisfies R[u][v]['flow']==-R[v][u]['flow'] .",
            "The flow value, defined as the total flow into t , the sink, is\nstored in R.graph['flow_value'] . If cutoff is not\nspecified, reachability to t using only edges (u,v) such\nthat R[u][v]['flow']<R[u][v]['capacity'] induces a minimum s - t cut."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "spanner",
        "Description": [
            "Returns a spanner of the given graph with the given stretch.",
            "A spanner of a graph G = (V, E) with stretch t is a subgraph\nH = (V, E_S) such that E_S is a subset of E and the distance between\nany pair of nodes in H is at most t times the distance between the\nnodes in G."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "An undirected simple graph.",
                "stretch : float": "The stretch of the spanner.",
                "weight : object": "The edge attribute to use as distance.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "NetworkX graph": "A spanner of the given graph with the given stretch."
            },
            "Raises:": {
                "ValueError": "If a stretch less than 1 is given."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This function implements the spanner algorithm by Baswana and Sen,\nsee [1]. This algorithm is a randomized las vegas algorithm: The expected\nrunning time is O(km) where k = (stretch + 1) // 2 and m is the\nnumber of edges in G. The returned graph is always a spanner of the\ngiven graph with the specified stretch. For weighted graphs the\nnumber of edges in the spanner is O(k * n^(1 + 1 / k)) where k is\ndefined as above and n is the number of nodes in G. For unweighted\ngraphs the number of edges is O(n^(1 + 1 / k) + kn).",
            "References": "[1] S. Baswana, S. Sen. A Simple and Linear Time Randomized\nAlgorithm for Computing Sparse Spanners in Weighted Graphs.\nRandom Struct. Algorithms 30(4): 532-563 (2007)."
        }
    },
    {
        "Section ID": "open_file",
        "Description": [
            "Decorator to ensure clean opening and closing of files."
        ],
        "Field List": {
            "Parameters:": {
                "path_arg : string or int": "Name or index of the argument that is a path.",
                "mode : str": "String for opening mode."
            },
            "Returns:": {
                "_open_file : function": "Function which cleanly executes the io."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Note that this decorator solves the problem when a path argument is\nspecified as a string, but it does not handle the situation when the\nfunction wants to accept a default of None (and then handle it). Here is an example of how to handle this case:",
            "Examples": "Decorate functions like this:\n@open_file(0,\"r\")defread_function(pathname):pass@open_file(1,\"w\")defwrite_function(G,pathname):pass@open_file(1,\"w\")defwrite_function(G,pathname=\"graph.dot\"):pass@open_file(\"pathname\",\"w\")defwrite_function(G,pathname=\"graph.dot\"):pass@open_file(\"path\",\"w+\")defanother_function(arg,**kwargs):path=kwargs[\"path\"]pass"
        }
    },
    {
        "Section ID": "draw_circular",
        "Description": [
            "Draw the graph G with a circular layout.",
            "This is a convenience function equivalent to:"
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph",
                "kwargs : optional keywords": "Seedraw_networkxfor a description of optional keywords."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The layout is computed each time this function is called. For\nrepeated drawing it is much more efficient to call circular_layout directly and reuse the result:",
            "Examples": "G=nx.path_graph(5)\nnx.draw_circular(G)"
        }
    },
    {
        "Section ID": "betweenness_centrality_subset",
        "Description": [
            "Compute betweenness centrality for a subset of nodes.",
            "where \\(S\\) is the set of sources, \\(T\\) is the set of targets, \\(\\sigma(s, t)\\) is the number of shortest \\((s, t)\\) -paths,\nand \\(\\sigma(s, t|v)\\) is the number of those paths\npassing through some  node \\(v\\) other than \\(s, t\\) .\nIf \\(s = t\\) , \\(\\sigma(s, t) = 1\\) ,\nand if \\(v \\in {s, t}\\) , \\(\\sigma(s, t|v) = 0\\)  [2] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.",
                "sources: list of nodes": "Nodes to use as sources for shortest paths in betweenness",
                "targets: list of nodes": "Nodes to use as targets for shortest paths in betweenness",
                "normalized : bool, optional": "If True the betweenness values are normalized by\\(2/((n-1)(n-2))\\)for graphs, and\\(1/((n-1)(n-2))\\)for directed graphs where\\(n\\)is the number of nodes in G.",
                "weight : None or string, optional (default=None)": "If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight.\nWeights are used to calculate weighted shortest paths, so they are\ninterpreted as distances."
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of nodes with betweenness centrality as the value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The basic algorithm is from [1] . For weighted graphs the edge weights must be greater than zero.\nZero edge weights can produce an infinite number of equal length\npaths between pairs of nodes. The normalization might seem a little strange but it is\ndesigned to make betweenness_centrality(G) be the same as\nbetweenness_centrality_subset(G,sources=G.nodes(),targets=G.nodes()). The total number of paths between source and target is counted\ndifferently for directed and undirected graphs. Directed paths\nare easy to count. Undirected paths are tricky: should a path\nfrom \u201cu\u201d to \u201cv\u201d count as 1 undirected path or as 2 directed paths? For betweenness_centrality we report the number of undirected\npaths when G is undirected. For betweenness_centrality_subset the reporting is different.\nIf the source and target subsets are the same, then we want\nto count undirected paths. But if the source and target subsets\ndiffer \u2013 for example, if sources is {0} and targets is {1},\nthen we are only counting the paths in one direction. They are\nundirected paths but we are counting them in a directed way.\nTo count them as undirected paths, each should count as half a path.",
            "References": "[1]Ulrik Brandes, A Faster Algorithm for Betweenness Centrality.\nJournal of Mathematical Sociology 25(2):163-177, 2001.https://doi.org/10.1080/0022250X.2001.9990249  [2]Ulrik Brandes: On Variants of Shortest-Path Betweenness\nCentrality and their Generic Computation.\nSocial Networks 30(2):136-145, 2008.https://doi.org/10.1016/j.socnet.2007.11.001"
        }
    },
    {
        "Section ID": "gnp_random_graph",
        "Description": [
            "Returns a \\(G_{n,p}\\) random graph, also known as an Erd\u0151s-R\u00e9nyi graph\nor a binomial graph.",
            "The \\(G_{n,p}\\) model chooses each of the possible edges with probability \\(p\\) ."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes.",
                "p : float": "Probability for edge creation.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "directed : bool, optional (default=False)": "If True, this function returns a directed graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm [2] runs in \\(O(n^2)\\) time.  For sparse graphs (that is, for\nsmall values of \\(p\\) ), fast_gnp_random_graph() is a faster algorithm. binomial_graph() and erdos_renyi_graph() are\naliases for gnp_random_graph() .",
            "References": "[1]Erd\u0151s and A. R\u00e9nyi, On Random Graphs, Publ. Math. 6, 290 (1959).  [2]Gilbert, Random Graphs, Ann. Math. Stat., 30, 1141 (1959)."
        }
    },
    {
        "Section ID": "empty_graph",
        "Description": [
            "Returns the empty graph with n nodes and zero edges.",
            "( Sourcecode , png )"
        ],
        "Field List": {
            "Parameters:": {
                "n : int or iterable container of nodes (default = 0)": "If n is an integer, nodes are fromrange(n).\nIf n is a container of nodes, those nodes appear in the graph.",
                "create_using : Graph Instance, Constructor or None": "Indicator of type of graph to return.\nIf a Graph-type instance, then clear and use it.\nIf None, use thedefaultconstructor.\nIf a constructor, call it to create an empty graph.",
                "default : Graph constructor (optional, default = nx.Graph)": "The constructor to use if create_using is None.\nIf None, then nx.Graph is used.\nThis is used when passing an unknowncreate_usingvalue\nthrough your home-grown function toempty_graphand\nyou want a default constructor other than nx.Graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The variable create_using should be a Graph Constructor or a\n\u201cgraph\u201d-like object. Constructors, e.g. nx.Graph or nx.MultiGraph will be used to create the returned graph. \u201cgraph\u201d-like objects\nwill be cleared (nodes and edges will be removed) and refitted as\nan empty \u201cgraph\u201d with nodes specified in n. This capability\nis useful for specifying the class-nature of the resulting empty\n\u201cgraph\u201d (i.e. Graph, DiGraph, MyWeirdGraphClass, etc.). The variable create_using has three main uses:\nFirstly, the variable create_using can be used to create an\nempty digraph, multigraph, etc.  For example,",
            "Examples": "G=nx.empty_graph(10)\nG.number_of_nodes()\n# 10\nG.number_of_edges()\n# 0\nG=nx.empty_graph(\"ABC\")\nG.number_of_nodes()\n# 3\nsorted(G)\n# ['A', 'B', 'C']"
        }
    },
    {
        "Section ID": "equivalence_classes",
        "Description": [
            "Returns equivalence classes of relation when applied to iterable .",
            "The equivalence classes, or blocks, consist of objects from iterable which are all equivalent. They are defined to be equivalent if the relation function returns True when passed any two objects from that\nclass, and False otherwise. To define an equivalence relation the\nfunction must be reflexive, symmetric and transitive."
        ],
        "Field List": {
            "Parameters:": {
                "iterable : list, tuple, or set": "An iterable of elements/nodes.",
                "relation : function": "A Boolean-valued function that implements an equivalence relation\n(reflexive, symmetric, transitive binary relation) on the elements\nofiterable- it must take two elements and returnTrueif\nthey are related, orFalseif not."
            },
            "Returns:": {
                "set of frozensets": "A set of frozensets representing the partition induced by the equivalence\nrelation functionrelationon the elements ofiterable. Each\nmember set in the return set represents an equivalence class, or\nblock, of the partition.Duplicate elements will be ignored so it makes the most sense foriterableto be aset."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This function does not check that relation represents an equivalence\nrelation. You can check that your equivalence classes provide a partition\nusing is_partition .",
            "Examples": "LetXbe the set of integers from0to9, and consider an equivalence\nrelationRonXof congruence modulo3: this means that two integersxandyinXare equivalent underRif they leave the same\nremainder when divided by3, i.e.(x-y)mod3=0.\nThe equivalence classes of this relation are{0,3,6,9},{1,4,7},{2,5,8}:0,3,6,9are all divisible by3and leave zero\nremainder;1,4,7leave remainder1; while2,5and8leave\nremainder2. We can see this by callingequivalence_classeswithXand a function implementation ofR.\nX=set(range(10))\ndefmod3(x,y):\nreturn(x-y)%3==0\nequivalence_classes(X,mod3)\n# {frozenset({1, 4, 7}), frozenset({8, 2, 5}), frozenset({0, 9, 3, 6})}"
        }
    },
    {
        "Section ID": "set_edge_attributes",
        "Description": [
            "Sets edge attributes from a given value or dictionary of values."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "",
                "values : scalar value, dict-like": "What the edge attribute should be set to.  Ifvaluesis\nnot a dictionary, then it is treated as a single attribute value\nthat is then applied to every edge inG.  This means that if\nyou provide a mutable object, like a list, updates to that object\nwill be reflected in the edge attribute for each edge.  The attribute\nname will bename.Ifvaluesis a dict or a dict of dict, it should be keyed\nby edge tuple to either an attribute value or a dict of attribute\nkey/value pairs used to update the edge\u2019s attributes.\nFor multigraphs, the edge tuples must be of the form(u,v,key),\nwhereuandvare nodes andkeyis the edge key.\nFor non-multigraphs, the keys must be tuples of the form(u,v).",
                "name : string (optional, default=None)": "Name of the edge attribute to set if values is a scalar."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "After computing some property of the edges of a graph, you may want\nto assign a edge attribute to store the value of that property for\neach edge:\nG=nx.path_graph(3)\nbb=nx.edge_betweenness_centrality(G,normalized=False)\nnx.set_edge_attributes(G,bb,\"betweenness\")\nG.edges[1,2][\"betweenness\"]\n# 2.0\nIf you provide a list as the second argument, updates to the list\nwill be reflected in the edge attribute for each edge:\nlabels=[]\nnx.set_edge_attributes(G,labels,\"labels\")\nlabels.append(\"foo\")\nG.edges[0,1][\"labels\"]\n# ['foo']\nG.edges[1,2][\"labels\"]\n# ['foo']\nIf you provide a dictionary of dictionaries as the second argument,\nthe entire dictionary will be used to update edge attributes:\nG=nx.path_graph(3)\nattrs={(0,1):{\"attr1\":20,\"attr2\":\"nothing\"},(1,2):{\"attr2\":3}}\nnx.set_edge_attributes(G,attrs)\nG[0][1][\"attr1\"]\n# 20\nG[0][1][\"attr2\"]\n# 'nothing'\nG[1][2][\"attr2\"]\n# 3\nThe attributes of one Graph can be used to set those of another.\nH=nx.path_graph(3)\nnx.set_edge_attributes(H,G.edges)\nNote that if the dict contains edges that are not inG, they are\nsilently ignored:\nG=nx.Graph([(0,1)])\nnx.set_edge_attributes(G,{(1,2):{\"weight\":2.0}})\n(1,2)inG.edges()\n# False\nFor multigraphs, thevaluesdict is expected to be keyed by 3-tuples\nincluding the edge key:\nMG=nx.MultiGraph()\nedges=[(0,1),(0,1)]\nMG.add_edges_from(edges)# Returns list of edge keys\n# [0, 1]\nattributes={(0,1,0):{\"cost\":21},(0,1,1):{\"cost\":7}}\nnx.set_edge_attributes(MG,attributes)\nMG[0][1][0][\"cost\"]\n# 21\nMG[0][1][1][\"cost\"]\n# 7\nIf MultiGraph attributes are desired for a Graph, you must convert the 3-tuple\nmultiedge to a 2-tuple edge and the last multiedge\u2019s attribute value will\noverwrite the previous values. Continuing from the previous case we get:\nH=nx.path_graph([0,1,2])\nnx.set_edge_attributes(H,{(u,v):edforu,v,edinMG.edges.data()})\nnx.get_edge_attributes(H,\"cost\")\n# {(0, 1): 7}"
        }
    },
    {
        "Section ID": "all_pairs_lowest_common_ancestor",
        "Description": [
            "Return the lowest common ancestor of all pairs or the provided pairs"
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX directed graph": "",
                "pairs : iterable of pairs of nodes, optional (default: all pairs)": "The pairs of nodes of interest.\nIf None, will find the LCA of all pairs of nodes."
            },
            "Yields:": {
                "((node1, node2), lca) : 2-tuple": "Where lca is least common ancestor of node1 and node2.\nNote that for the default case, the order of the node pair is not considered,\ne.g. you will not get both(a,b)and(b,a)"
            },
            "Raises:": {
                "NetworkXPointlessConcept": "IfGis null.",
                "NetworkXError": "IfGis not a DAG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Only defined on non-null directed acyclic graphs.",
            "Examples": "The default behavior is to yield the lowest common ancestor for all\npossible combinations of nodes inG, including self-pairings:\nG=nx.DiGraph([(0,1),(0,3),(1,2)])\ndict(nx.all_pairs_lowest_common_ancestor(G))\n# {(0, 0): 0, (0, 1): 0, (0, 3): 0, (0, 2): 0, (1, 1): 1, (1, 3): 0, (1, 2): 1, (3, 3): 3, (3, 2): 0, (2, 2): 2}\nThe pairs argument can be used to limit the output to only the\nspecified node pairings:\ndict(nx.all_pairs_lowest_common_ancestor(G,pairs=[(1,2),(2,3)]))\n# {(1, 2): 1, (2, 3): 0}"
        }
    },
    {
        "Section ID": "attribute_mixing_matrix",
        "Description": [
            "Returns mixing matrix for attribute."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "NetworkX graph object.",
                "attribute : string": "Node attribute key.",
                "nodes: list or iterable (optional)": "Use only nodes in container to build the matrix. The default is\nall nodes.",
                "mapping : dictionary, optional": "Mapping from node attribute to integer index in matrix.\nIf not specified, an arbitrary ordering will be used.",
                "normalized : bool (default=True)": "Return counts if False or probabilities if True."
            },
            "Returns:": {
                "m: numpy array": "Counts or joint probability of occurrence of attribute pairs."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "If each node has a unique attribute value, the unnormalized mixing matrix\nwill be equal to the adjacency matrix. To get a denser mixing matrix,\nthe rounding can be performed to form groups of nodes with equal values.\nFor example, the exact height of persons in cm (180.79155222, 163.9080892,\n163.30095355, 167.99016217, 168.21590163, \u2026) can be rounded to (180, 163,\n163, 168, 168, \u2026). Definitions of attribute mixing matrix vary on whether the matrix\nshould include rows for attribute values that don\u2019t arise. Here we\ndo not include such empty-rows. But you can force them to appear\nby inputting a mapping that includes those values.",
            "Examples": "G=nx.path_graph(3)\ngender={0:\"male\",1:\"female\",2:\"female\"}\nnx.set_node_attributes(G,gender,\"gender\")\nmapping={\"male\":0,\"female\":1}\nmix_mat=nx.attribute_mixing_matrix(G,\"gender\",mapping=mapping)\nmix_mat\n# array([[0.  , 0.25],\n#        [0.25, 0.5 ]])"
        }
    },
    {
        "Section ID": "join",
        "Description": [
            "A deprecated name for join_trees",
            "Returns a new rooted tree with a root node joined with the roots\nof each of the given rooted trees."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "branching_weight",
        "Description": [
            "Returns the total weight of a branching.",
            "You must access this function through the networkx.algorithms.tree module."
        ],
        "Field List": {
            "Parameters:": {
                "G : DiGraph": "The directed graph.",
                "attr : str": "The attribute to use as weights. If None, then each edge will be\ntreated equally with a weight of 1.",
                "default : float": "Whenattris not None, then if an edge does not have that attribute,defaultspecifies what value it should take."
            },
            "Returns:": {
                "weight: int or float": "The total weight of the branching."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.DiGraph()\nG.add_weighted_edges_from([(0,1,2),(1,2,4),(2,3,3),(3,4,2)])\nnx.tree.branching_weight(G)\n# 11"
        }
    },
    {
        "Section ID": "k_crust",
        "Description": [
            "Returns the k-crust of G.",
            "The k-crust is the graph G with the edges of the k-core removed\nand isolated nodes found after the removal of edges are also removed."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A graph or directed graph.",
                "k : int, optional": "The order of the shell. If not specified return the main crust.",
                "core_number : dictionary, optional": "Precomputed core numbers for the graph G."
            },
            "Returns:": {
                "G : NetworkX graph": "The k-crust subgraph"
            },
            "Raises:": {
                "NetworkXNotImplemented": "The k-crust is not implemented for multigraphs or graphs with self loops."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This definition of k-crust is different than the definition in [1] .\nThe k-crust in [1] is equivalent to the k+1 crust of this algorithm. For directed graphs the node degree is defined to be the\nin-degree + out-degree. Graph, node, and edge attributes are copied to the subgraph.",
            "References": "[1](1,2)A model of Internet topology using k-shell decomposition\nShai Carmi, Shlomo Havlin, Scott Kirkpatrick, Yuval Shavitt,\nand Eran Shir, PNAS  July 3, 2007   vol. 104  no. 27  11150-11154http://www.pnas.org/content/104/27/11150.full",
            "Examples": "degrees=[0,1,2,2,2,2,3]\nH=nx.havel_hakimi_graph(degrees)\nH.degree\n# DegreeView({0: 1, 1: 2, 2: 2, 3: 2, 4: 2, 5: 3, 6: 0})\nnx.k_crust(H,k=1).nodes\n# NodeView((0, 4, 6))"
        }
    },
    {
        "Section ID": "Edmonds",
        "Description": [
            "Edmonds algorithm [1] for finding optimal branchings and spanning\narborescences.",
            "This algorithm can find both minimum and maximum spanning arborescences and\nbranchings.",
            "Notes",
            "While this algorithm can find a minimum branching, since it isn\u2019t required\nto be spanning, the minimum branching is always from the set of negative\nweight edges which is most likely the empty set for most graphs.",
            "References"
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {
            "Notes": "While this algorithm can find a minimum branching, since it isn\u2019t required\nto be spanning, the minimum branching is always from the set of negative\nweight edges which is most likely the empty set for most graphs.",
            "References": "[1]J. Edmonds, Optimum Branchings, Journal of Research of the National\nBureau of Standards, 1967, Vol. 71B, p.233-240,https://archive.org/details/jresv71Bn4p233"
        }
    },
    {
        "Section ID": "tree_data",
        "Description": [
            "Returns data in tree format that is suitable for JSON serialization\nand use in JavaScript documents."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "G must be an oriented tree",
                "root : node": "The root of the tree",
                "ident : string": "Attribute name for storing NetworkX-internal graph data.identmust\nhave a different value thanchildren. The default is \u2018id\u2019.",
                "children : string": "Attribute name for storing NetworkX-internal graph data.childrenmust have a different value thanident. The default is \u2018children\u2019."
            },
            "Returns:": {
                "data : dict": "A dictionary with node-link formatted data."
            },
            "Raises:": {
                "NetworkXError": "Ifchildrenandidentattributes are identical."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Node attributes are stored in this format but keys\nfor attributes must be strings if you want to serialize with JSON. Graph and edge attributes are not stored.",
            "Examples": "fromnetworkx.readwriteimportjson_graph\nG=nx.DiGraph([(1,2)])\ndata=json_graph.tree_data(G,root=1)\nTo serialize with json\nimportjson\ns=json.dumps(data)"
        }
    },
    {
        "Section ID": "all_topological_sorts",
        "Description": [
            "Returns a generator of _all_ topological sorts of the directed graph G.",
            "A topological sort is a nonunique permutation of the nodes such that an\nedge from u to v implies that u appears before v in the topological sort\norder."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX DiGraph": "A directed graph"
            },
            "Yields:": {
                "topological_sort_order : list": "a list of nodes inG, representing one of the topological sort orders"
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis not directed",
                "NetworkXUnfeasible": "IfGis not acyclic"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Implements an iterative version of the algorithm given in [1].",
            "References": "[1]Knuth, Donald E., Szwarcfiter, Jayme L. (1974).\n\u201cA Structured Program to Generate All Topological Sorting Arrangements\u201d\nInformation Processing Letters, Volume 2, Issue 6, 1974, Pages 153-157,\nISSN 0020-0190,https://doi.org/10.1016/0020-0190(74)90001-5.\nElsevier (North-Holland), Amsterdam",
            "Examples": "To enumerate all topological sorts of directed graph:\nDG=nx.DiGraph([(1,2),(2,3),(2,4)])\nlist(nx.all_topological_sorts(DG))\n# [[1, 2, 4, 3], [1, 2, 3, 4]]"
        }
    },
    {
        "Section ID": "communicability_betweenness_centrality",
        "Description": [
            "Returns subgraph communicability for all pairs of nodes in G.",
            "Communicability betweenness measure makes use of the number of walks\nconnecting every pair of nodes as the basis of a betweenness centrality\nmeasure."
        ],
        "Field List": {
            "Parameters:": {
                "G: graph": ""
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of nodes with communicability betweenness as the value."
            },
            "Raises:": {
                "NetworkXError": "If the graph is not undirected and simple."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Let G=(V,E) be a simple undirected graph with n nodes and m edges,\nand A denote the adjacency matrix of G . Let G(r)=(V,E(r)) be the graph resulting from\nremoving all edges connected to node r but not the node itself. The adjacency matrix for G(r) is A+E(r) ,  where E(r) has nonzeros\nonly in row and column r . The subraph betweenness of a node r is [1]",
            "References": "[1]Ernesto Estrada, Desmond J. Higham, Naomichi Hatano,\n\u201cCommunicability Betweenness in Complex Networks\u201d\nPhysica A 388 (2009) 764-774.https://arxiv.org/abs/0905.4102",
            "Examples": "G=nx.Graph([(0,1),(1,2),(1,5),(5,4),(2,4),(2,3),(4,3),(3,6)])\ncbc=nx.communicability_betweenness_centrality(G)\nprint([f\"{node} {cbc[node]:0.2f}\"fornodeinsorted(cbc)])\n# ['0 0.03', '1 0.45', '2 0.51', '3 0.45', '4 0.40', '5 0.19', '6 0.03']"
        }
    },
    {
        "Section ID": "current_flow_closeness_centrality",
        "Description": [
            "Compute current-flow closeness centrality for nodes.",
            "Current-flow closeness centrality is variant of closeness\ncentrality based on effective resistance between nodes in\na network. This metric is also known as information centrality."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.",
                "weight : None or string, optional (default=None)": "If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight.\nThe weight reflects the capacity or the strength of the\nedge.",
                "dtype: data type (default=float)": "Default data type for internal matrices.\nSet to np.float32 for lower memory consumption.",
                "solver: string (default=\u2019lu\u2019)": "Type of linear solver to use for computing the flow matrix.\nOptions are \u201cfull\u201d (uses most memory), \u201clu\u201d (recommended), and\n\u201ccg\u201d (uses least memory)."
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of nodes with current flow closeness centrality as the value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The algorithm is from Brandes [1] . See also [2] for the original definition of information centrality.",
            "References": "[1]Ulrik Brandes and Daniel Fleischer,\nCentrality Measures Based on Current Flow.\nProc. 22nd Symp. Theoretical Aspects of Computer Science (STACS \u201805).\nLNCS 3404, pp. 533-544. Springer-Verlag, 2005.https://doi.org/10.1007/978-3-540-31856-9_44  [2]Karen Stephenson and Marvin Zelen:\nRethinking centrality: Methods and examples.\nSocial Networks 11(1):1-37, 1989.https://doi.org/10.1016/0378-8733(89)90016-6"
        }
    },
    {
        "Section ID": "binomial_graph",
        "Description": [
            "Returns a \\(G_{n,p}\\) random graph, also known as an Erd\u0151s-R\u00e9nyi graph\nor a binomial graph.",
            "The \\(G_{n,p}\\) model chooses each of the possible edges with probability \\(p\\) ."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes.",
                "p : float": "Probability for edge creation.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "directed : bool, optional (default=False)": "If True, this function returns a directed graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm [2] runs in \\(O(n^2)\\) time.  For sparse graphs (that is, for\nsmall values of \\(p\\) ), fast_gnp_random_graph() is a faster algorithm. binomial_graph() and erdos_renyi_graph() are\naliases for gnp_random_graph() .",
            "References": "[1]Erd\u0151s and A. R\u00e9nyi, On Random Graphs, Publ. Math. 6, 290 (1959).  [2]Gilbert, Random Graphs, Ann. Math. Stat., 30, 1141 (1959)."
        }
    },
    {
        "Section ID": "subgraph",
        "Description": [
            "Returns the subgraph induced on nodes in nbunch."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "nbunch : list, iterable": "A container of nodes that will be iterated through once (thus\nit should be an iterator or be iterable).  Each element of the\ncontainer should be a valid node type: any hashable type except\nNone.  If nbunch is None, return all edges data in the graph.\nNodes in nbunch that are not in the graph will be (quietly)\nignored."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "subgraph(G) calls G.subgraph()"
        }
    },
    {
        "Section ID": "is_d_separator",
        "Description": [
            "Return whether node sets x and y are d-separated by z ."
        ],
        "Field List": {
            "Parameters:": {
                "G : nx.DiGraph": "A NetworkX DAG.",
                "x : node or set of nodes": "First node or set of nodes inG.",
                "y : node or set of nodes": "Second node or set of nodes inG.",
                "z : node or set of nodes": "Potential separator (set of conditioning nodes inG). Can be empty set."
            },
            "Returns:": {
                "b : bool": "A boolean that is true ifxis d-separated fromygivenzinG."
            },
            "Raises:": {
                "NetworkXError": "Thed-separationtest is commonly used on disjoint sets of\nnodes in acyclic directed graphs.  Accordingly, the algorithm\nraises aNetworkXErrorif the node sets are not\ndisjoint or if the input graph is not a DAG.",
                "NodeNotFound": "If any of the input nodes are not found in the graph,\naNodeNotFoundexception is raised"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "A d-separating set in a DAG is a set of nodes that\nblocks all paths between the two sets. Nodes in z block a path if they are part of the path and are not a collider,\nor a descendant of a collider. Also colliders that are not in z block a path. A collider structure along a path\nis ...->c<-... where c is the collider node. https://en.wikipedia.org/wiki/Bayesian_network#d-separation"
        }
    },
    {
        "Section ID": "k_components",
        "Description": [
            "Returns the k-component structure of a graph G.",
            "A k -component is a maximal subgraph of a graph G that has, at least,\nnode connectivity k : we need to remove at least k nodes to break it\ninto more components. k -components have an inherent hierarchical\nstructure because they are nested in terms of connectivity: a connected\ngraph can contain several 2-components, each of which can contain\none or more 3-components, and so forth."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "flow_func : function": "Function to perform the underlying flow computations. Default valueedmonds_karp(). This function performs better in sparse graphs with\nright tailed degree distributions.shortest_augmenting_path()will\nperform better in denser graphs."
            },
            "Returns:": {
                "k_components : dict": "Dictionary with all connectivity levelskin the input Graph as keys\nand a list of sets of nodes that form a k-component of levelkas\nvalues."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the input graph is directed."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Moody and White [1] (appendix A) provide an algorithm for identifying\nk-components in a graph, which is based on Kanevsky\u2019s algorithm [2] for finding all minimum-size node cut-sets of a graph (implemented in all_node_cuts() function):",
            "References": "[1]Moody, J. and D. White (2003). Social cohesion and embeddedness:\nA hierarchical conception of social groups.\nAmerican Sociological Review 68(1), 103\u201328.http://www2.asanet.org/journals/ASRFeb03MoodyWhite.pdf  [2]Kanevsky, A. (1993). Finding all minimum-size separating vertex\nsets in a graph. Networks 23(6), 533\u2013541.http://onlinelibrary.wiley.com/doi/10.1002/net.3230230604/abstract  [3]Torrents, J. and F. Ferraro (2015). Structural Cohesion:\nVisualization and Heuristics for Fast Computation.https://arxiv.org/pdf/1503.04476v1",
            "Examples": "# Petersen graph has 10 nodes and it is triconnected, thus all\n# nodes are in a single component on all three connectivity levels\nG=nx.petersen_graph()\nk_components=nx.k_components(G)"
        }
    },
    {
        "Section ID": "number_attracting_components",
        "Description": [
            "Returns the number of attracting components in G ."
        ],
        "Field List": {
            "Parameters:": {
                "G : DiGraph, MultiDiGraph": "The graph to be analyzed."
            },
            "Returns:": {
                "n : int": "The number of attracting components in G."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the input graph is undirected."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "duplication_divergence_graph",
        "Description": [
            "Returns an undirected graph using the duplication-divergence model.",
            "A graph of n nodes is created by duplicating the initial nodes\nand retaining edges incident to the original nodes with a retention\nprobability p ."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The desired number of nodes in the graph.",
                "p : float": "The probability for retaining the edge of the replicated node.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "G : Graph": ""
            },
            "Raises:": {
                "NetworkXError": "Ifpis not a valid probability.\nIfnis less than 2."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm appears in [1]. This implementation disallows the possibility of generating\ndisconnected graphs.",
            "References": "[1]I. Ispolatov, P. L. Krapivsky, A. Yuryev,\n\u201cDuplication-divergence model of protein interaction network\u201d,\nPhys. Rev. E, 71, 061911, 2005."
        }
    },
    {
        "Section ID": "betweenness_centrality",
        "Description": [
            "Compute the shortest-path betweenness centrality for nodes.",
            "Betweenness centrality of a node \\(v\\) is the sum of the\nfraction of all-pairs shortest paths that pass through \\(v\\)",
            "where \\(V\\) is the set of nodes, \\(\\sigma(s, t)\\) is the number of\nshortest \\((s, t)\\) -paths,  and \\(\\sigma(s, t|v)\\) is the number of\nthose paths  passing through some  node \\(v\\) other than \\(s, t\\) .\nIf \\(s = t\\) , \\(\\sigma(s, t) = 1\\) , and if \\(v \\in {s, t}\\) , \\(\\sigma(s, t|v) = 0\\)  [2] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.",
                "k : int, optional (default=None)": "If k is not None use k node samples to estimate betweenness.\nThe value of k <= n where n is the number of nodes in the graph.\nHigher values give better approximation.",
                "normalized : bool, optional": "If True the betweenness values are normalized by2/((n-1)(n-2))for graphs, and1/((n-1)(n-2))for directed graphs wherenis the number of nodes in G.",
                "weight : None or string, optional (default=None)": "If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight.\nWeights are used to calculate weighted shortest paths, so they are\ninterpreted as distances.",
                "endpoints : bool, optional": "If True include the endpoints in the shortest path counts.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.\nNote that this is only used if k is not None."
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of nodes with betweenness centrality as the value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The algorithm is from Ulrik Brandes [1] .\nSee [4] for the original first published version and [2] for details on\nalgorithms for variations and related metrics. For approximate betweenness calculations set k=#samples to use\nk nodes (\u201cpivots\u201d) to estimate the betweenness values. For an estimate\nof the number of pivots needed see [3] . For weighted graphs the edge weights must be greater than zero.\nZero edge weights can produce an infinite number of equal length\npaths between pairs of nodes. The total number of paths between source and target is counted\ndifferently for directed and undirected graphs. Directed paths\nare easy to count. Undirected paths are tricky: should a path\nfrom \u201cu\u201d to \u201cv\u201d count as 1 undirected path or as 2 directed paths? For betweenness_centrality we report the number of undirected\npaths when G is undirected. For betweenness_centrality_subset the reporting is different.\nIf the source and target subsets are the same, then we want\nto count undirected paths. But if the source and target subsets\ndiffer \u2013 for example, if sources is {0} and targets is {1},\nthen we are only counting the paths in one direction. They are\nundirected paths but we are counting them in a directed way.\nTo count them as undirected paths, each should count as half a path. This algorithm is not guaranteed to be correct if edge weights\nare floating point numbers. As a workaround you can use integer\nnumbers by multiplying the relevant edge attributes by a convenient\nconstant factor (eg 100) and converting to integers.",
            "References": "[1]Ulrik Brandes:\nA Faster Algorithm for Betweenness Centrality.\nJournal of Mathematical Sociology 25(2):163-177, 2001.https://doi.org/10.1080/0022250X.2001.9990249  [2](1,2)Ulrik Brandes:\nOn Variants of Shortest-Path Betweenness\nCentrality and their Generic Computation.\nSocial Networks 30(2):136-145, 2008.https://doi.org/10.1016/j.socnet.2007.11.001  [3]Ulrik Brandes and Christian Pich:\nCentrality Estimation in Large Networks.\nInternational Journal of Bifurcation and Chaos 17(7):2303-2318, 2007.https://dx.doi.org/10.1142/S0218127407018403  [4]Linton C. Freeman:\nA set of measures of centrality based on betweenness.\nSociometry 40: 35\u201341, 1977https://doi.org/10.2307/3033543"
        }
    },
    {
        "Section ID": "generate_random_paths",
        "Description": [
            "Randomly generate sample_size paths of length path_length ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A NetworkX graph",
                "sample_size : integer": "The number of paths to generate. This isRin[1].",
                "path_length : integer (default = 5)": "The maximum size of the path to randomly generate.\nThis isTin[1]. According to the paper,T>=5is\nrecommended.",
                "index_map : dictionary, optional": "If provided, this will be populated with the inverted\nindex of nodes mapped to the set of generated random path\nindices withinpaths.",
                "weight : string or None, optional (default=\u201dweight\u201d)": "The name of an edge attribute that holds the numerical value\nused as a weight. If None then each edge has weight 1.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "paths : generator of lists": "Generator ofsample_sizepaths each with lengthpath_length."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1](1,2)Zhang, J., Tang, J., Ma, C., Tong, H., Jing, Y., & Li, J.\nPanther: Fast top-k similarity search on large networks.\nIn Proceedings of the ACM SIGKDD International Conference\non Knowledge Discovery and Data Mining (Vol. 2015-August, pp. 1445\u20131454).\nAssociation for Computing Machinery.https://doi.org/10.1145/2783258.2783267.",
            "Examples": "Note that the return value is the list of paths:\nG=nx.star_graph(3)\nrandom_path=nx.generate_random_paths(G,2)\nBy passing a dictionary intoindex_map, it will build an\ninverted index mapping of nodes to the paths in which that node is present:\nG=nx.star_graph(3)\nindex_map={}\nrandom_path=nx.generate_random_paths(G,3,index_map=index_map)\npaths_containing_node_0=[\nrandom_path[path_idx]forpath_idxinindex_map.get(0,[])\n]"
        }
    },
    {
        "Section ID": "lexicographical_topological_sort",
        "Description": [
            "Generate the nodes in the unique lexicographical topological sort order.",
            "Generates a unique ordering of nodes by first sorting topologically (for which there are often\nmultiple valid orderings) and then additionally by sorting lexicographically.",
            "A topological sort arranges the nodes of a directed graph so that the\nupstream node of each directed edge precedes the downstream node.\nIt is always possible to find a solution for directed graphs that have no cycles.\nThere may be more than one valid solution.",
            "Lexicographical sorting is just sorting alphabetically. It is used here to break ties in the\ntopological sort and to determine a single, unique ordering.  This can be useful in comparing\nsort results.",
            "The lexicographical order can be customized by providing a function to the key= parameter.\nThe definition of the key function is the same as used in python\u2019s built-in sort() .\nThe function takes a single argument and returns a key to use for sorting purposes.",
            "Lexicographical sorting can fail if the node names are un-sortable. See the example below.\nThe solution is to provide a function to the key= argument that returns sortable keys."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX digraph": "A directed acyclic graph (DAG)",
                "key : function, optional": "A function of one argument that converts a node name to a comparison key.\nIt defines and resolves ambiguities in the sort order.  Defaults to the identity function."
            },
            "Yields:": {
                "nodes": "Yields the nodes of G in lexicographical topological sort order."
            },
            "Raises:": {
                "NetworkXError": "Topological sort is defined for directed graphs only. If the graphGis undirected, aNetworkXErroris raised.",
                "NetworkXUnfeasible": "IfGis not a directed acyclic graph (DAG) no topological sort exists\nand aNetworkXUnfeasibleexception is raised.  This can also be\nraised ifGis changed while the returned iterator is being processed",
                "RuntimeError": "IfGis changed while the returned iterator is being processed.",
                "TypeError": "Results from un-sortable node names.\nConsider usingkey=parameter to resolve ambiguities in the sort order."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm is based on a description and proof in\n\u201cIntroduction to Algorithms: A Creative Approach\u201d [1] .",
            "References": "[1]Manber, U. (1989).Introduction to Algorithms - A Creative Approach.Addison-Wesley.",
            "Examples": "DG=nx.DiGraph([(2,1),(2,5),(1,3),(1,4),(5,4)])\nlist(nx.lexicographical_topological_sort(DG))\n# [2, 1, 3, 5, 4]\nlist(nx.lexicographical_topological_sort(DG,key=lambdax:-x))\n# [2, 5, 1, 4, 3]\nThe sort will fail for any graph with integer and string nodes. Comparison of integer to strings\nis not defined in python.  Is 3 greater or less than \u2018red\u2019?\nDG=nx.DiGraph([(1,\"red\"),(3,\"red\"),(1,\"green\"),(2,\"blue\")])\nlist(nx.lexicographical_topological_sort(DG))Traceback (most recent call last):...TypeError'<' not supported between instances of 'str' and 'int'...\nIncomparable nodes can be resolved using akeyfunction. This example function\nallows comparison of integers and strings by returning a tuple where the first\nelement is True forstr, False otherwise. The second element is the node name.\nThis groups the strings and integers separately so they can be compared only among themselves.\nkey=lambdanode:(isinstance(node,str),node)\nlist(nx.lexicographical_topological_sort(DG,key=key))\n# [1, 2, 3, 'blue', 'green', 'red']"
        }
    },
    {
        "Section ID": "graphs_equal",
        "Description": [
            "Check if graphs are equal.",
            "Equality here means equal as Python objects (not isomorphism).\nNode, edge and graph data must match."
        ],
        "Field List": {
            "Parameters:": {
                "graph1, graph2 : graph": ""
            },
            "Returns:": {
                "bool": "True if graphs are equal, False otherwise."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "binomial_tree",
        "Description": [
            "Returns the Binomial Tree of order n.",
            "The binomial tree of order 0 consists of a single node. A binomial tree of order k\nis defined recursively by linking two binomial trees of order k-1: the root of one is\nthe leftmost child of the root of the other.",
            "( Sourcecode , png )"
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "Order of the binomial tree.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : NetworkX graph": "A binomial tree of\\(2^n\\)nodes and\\(2^n - 1\\)edges."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "modularity_matrix",
        "Description": [
            "Returns the modularity matrix of G.",
            "The modularity matrix is the matrix B = A - <A>, where A is the adjacency\nmatrix and <A> is the average adjacency matrix, assuming that the graph\nis described by the configuration model.",
            "More specifically, the element B_ij of B is defined as",
            "where k_i is the degree of node i, and where m is the number of edges\nin the graph. When weight is set to a name of an attribute edge, Aij, k_i,\nk_j and m are computed using its value."
        ],
        "Field List": {
            "Parameters:": {
                "G : Graph": "A NetworkX graph",
                "nodelist : list, optional": "The rows and columns are ordered according to the nodes in nodelist.\nIf nodelist is None, then the ordering is produced by G.nodes().",
                "weight : string or None, optional (default=None)": "The edge attribute that holds the numerical value used for\nthe edge weight.  If None then all edge weights are 1."
            },
            "Returns:": {
                "B : Numpy array": "The modularity matrix of G."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]M. E. J. Newman, \u201cModularity and community structure in networks\u201d,\nProc. Natl. Acad. Sci. USA, vol. 103, pp. 8577-8582, 2006.",
            "Examples": "k=[3,2,2,1,0]\nG=nx.havel_hakimi_graph(k)\nB=nx.modularity_matrix(G)"
        }
    },
    {
        "Section ID": "tree_graph",
        "Description": [
            "Returns graph from tree data format."
        ],
        "Field List": {
            "Parameters:": {
                "data : dict": "Tree formatted graph data",
                "ident : string": "Attribute name for storing NetworkX-internal graph data.identmust\nhave a different value thanchildren. The default is \u2018id\u2019.",
                "children : string": "Attribute name for storing NetworkX-internal graph data.childrenmust have a different value thanident. The default is \u2018children\u2019."
            },
            "Returns:": {
                "G : NetworkX DiGraph": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "fromnetworkx.readwriteimportjson_graph\nG=nx.DiGraph([(1,2)])\ndata=json_graph.tree_data(G,root=1)\nH=json_graph.tree_graph(data)"
        }
    },
    {
        "Section ID": "reverse_view",
        "Description": [
            "View of G with edge directions reversed",
            "reverse_view returns a read-only view of the input graph where\nedge directions are reversed.",
            "Identical to digraph.reverse(copy=False)"
        ],
        "Field List": {
            "Parameters:": {
                "G : networkx.DiGraph": ""
            },
            "Returns:": {
                "graph : networkx.DiGraph": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.DiGraph()\nG.add_edge(1,2)\nG.add_edge(2,3)\nG.edges()\n# OutEdgeView([(1, 2), (2, 3)])\nview=nx.reverse_view(G)\nview.edges()\n# OutEdgeView([(2, 1), (3, 2)])"
        }
    },
    {
        "Section ID": "preferential_attachment_graph",
        "Description": [
            "Create a bipartite graph with a preferential attachment model from\na given single degree sequence.",
            "The graph is composed of two partitions. Set A has nodes 0 to\n(len(aseq) - 1) and set B has nodes starting with node len(aseq).\nThe number of nodes in set B is random."
        ],
        "Field List": {
            "Parameters:": {
                "aseq : list": "Degree sequence for node set A.",
                "p : float": "Probability that a new bottom node is added.",
                "create_using : NetworkX graph instance, optional": "Return graph of this type.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The nodes are assigned the attribute \u2018bipartite\u2019 with the value 0 or 1\nto indicate which bipartite set the node belongs to. This function is not imported in the main namespace.\nTo use it use nx.bipartite.preferential_attachment_graph",
            "References": "[1]Guillaume, J.L. and Latapy, M.,\nBipartite graphs as models of complex networks.\nPhysica A: Statistical Mechanics and its Applications,\n2006, 371(2), pp.795-813.  [2]Jean-Loup Guillaume and Matthieu Latapy,\nBipartite structure of all complex networks,\nInf. Process. Lett. 90, 2004, pg. 215-221https://doi.org/10.1016/j.ipl.2004.03.007"
        }
    },
    {
        "Section ID": "generate_multiline_adjlist",
        "Description": [
            "Generate a single line of the graph G in multiline adjacency list format."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "delimiter : string, optional": "Separator for node labels"
            },
            "Returns:": {
                "lines : string": "Lines of data in multiline adjlist format."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.lollipop_graph(4,3)\nforlineinnx.generate_multiline_adjlist(G):\nprint(line)\n# 0 3\n# 1 {}\n# 2 {}\n# 3 {}\n# 1 2\n# 2 {}\n# 3 {}\n# 2 1\n# 3 {}\n# 3 1\n# 4 {}\n# 4 1\n# 5 {}\n# 5 1\n# 6 {}\n# 6 0"
        }
    },
    {
        "Section ID": "find_minimal_d_separator",
        "Description": [
            "Returns a minimal d-separating set between x and y if possible",
            "A d-separating set in a DAG is a set of nodes that blocks all\npaths between the two sets of nodes, x and y . This function\nconstructs a d-separating set that is \u201cminimal\u201d, meaning no nodes can\nbe removed without it losing the d-separating property for x and y .\nIf no d-separating sets exist for x and y , this returns None .",
            "In a DAG there may be more than one minimal d-separator between two\nsets of nodes. Minimal d-separators are not always unique. This function\nreturns one minimal d-separator, or None if no d-separator exists.",
            "Uses the algorithm presented in [1] . The complexity of the algorithm\nis \\(O(m)\\) , where \\(m\\) stands for the number of edges in\nthe subgraph of G consisting of only the ancestors of x and y .\nFor full details, see [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx DAG.",
                "x : set | node": "A node or set of nodes in the graph.",
                "y : set | node": "A node or set of nodes in the graph.",
                "included : set | node | None": "A node or set of nodes which must be included in the found separating set,\ndefault is None, which means the empty set.",
                "restricted : set | node | None": "Restricted node or set of nodes to consider. Only these nodes can be in\nthe found separating set, default is None meaning all nodes inG."
            },
            "Returns:": {
                "z : set | None": "The minimal d-separating set, if at least one d-separating set exists,\notherwise None."
            },
            "Raises:": {
                "NetworkXError": "Raises aNetworkXErrorif the input graph is not a DAG\nor if node setsx,y, andincludedare not disjoint.",
                "NodeNotFound": "If any of the input nodes are not found in the graph,\naNodeNotFoundexception is raised."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1](1,2)van der Zander, Benito, and Maciej Li\u015bkiewicz. \u201cFinding\nminimal d-separators in linear time and applications.\u201d In\nUncertainty in Artificial Intelligence, pp. 637-647. PMLR, 2020."
        }
    },
    {
        "Section ID": "powerlaw_cluster_graph",
        "Description": [
            "Holme and Kim algorithm for growing graphs with powerlaw\ndegree distribution and approximate average clustering."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "the number of nodes",
                "m : int": "the number of random edges to add for each new node",
                "p : float,": "Probability of adding a triangle after adding a random edge",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Raises:": {
                "NetworkXError": "Ifmdoes not satisfy1<=m<=norpdoes not\nsatisfy0<=p<=1."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The average clustering has a hard time getting above a certain\ncutoff that depends on m .  This cutoff is often quite low.  The\ntransitivity (fraction of triangles to possible triangles) seems to\ndecrease with network size. It is essentially the Barab\u00e1si\u2013Albert (BA) growth model with an\nextra step that each random edge is followed by a chance of\nmaking an edge to one of its neighbors too (and thus a triangle). This algorithm improves on BA in the sense that it enables a\nhigher average clustering to be attained if desired. It seems possible to have a disconnected graph with this algorithm\nsince the initial m nodes may not be all linked to a new node\non the first iteration like the BA model.",
            "References": "[1]P. Holme and B. J. Kim,\n\u201cGrowing scale-free networks with tunable clustering\u201d,\nPhys. Rev. E, 65, 026107, 2002."
        }
    },
    {
        "Section ID": "is_edge_cover",
        "Description": [
            "Decides whether a set of edges is a valid edge cover of the graph.",
            "Given a set of edges, whether it is an edge covering can\nbe decided if we just check whether all nodes of the graph\nhas an edge from the set, incident on it."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "An undirected bipartite graph.",
                "cover : set": "Set of edges to be checked."
            },
            "Returns:": {
                "bool": "Whether the set of edges is a valid edge cover of the graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "An edge cover of a graph is a set of edges such that every node of\nthe graph is incident to at least one edge of the set.",
            "Examples": "G=nx.Graph([(0,1),(0,2),(0,3),(1,2),(1,3)])\ncover={(2,1),(3,0)}\nnx.is_edge_cover(G,cover)\n# True"
        }
    },
    {
        "Section ID": "maximum_spanning_edges",
        "Description": [
            "Generate edges in a maximum spanning forest of an undirected\nweighted graph.",
            "A maximum spanning tree is a subgraph of the graph (a tree)\nwith the maximum possible sum of edge weights.  A spanning forest is a\nunion of the spanning trees for each connected component of the graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : undirected Graph": "An undirected graph. IfGis connected, then the algorithm finds a\nspanning tree. Otherwise, a spanning forest is found.",
                "algorithm : string": "The algorithm to use when finding a maximum spanning tree. Valid\nchoices are \u2018kruskal\u2019, \u2018prim\u2019, or \u2018boruvka\u2019. The default is \u2018kruskal\u2019.",
                "weight : string": "Edge data key to use for weight (default \u2018weight\u2019).",
                "keys : bool": "Whether to yield edge key in multigraphs in addition to the edge.\nIfGis not a multigraph, this is ignored.",
                "data : bool, optional": "If True yield the edge data along with the edge.",
                "ignore_nan : bool (default: False)": "If a NaN is found as an edge weight normally an exception is raised.\nIfignore_nanisTruethen that edge is ignored instead."
            },
            "Returns:": {
                "edges : iterator": "An iterator over edges in a maximum spanning tree ofG.\nEdges connecting nodesuandvare represented as tuples:(u,v,k,d)or(u,v,k)or(u,v,d)or(u,v)IfGis a multigraph,keysindicates whether the edge keykwill\nbe reported in the third position in the edge tuple.dataindicates\nwhether the edge datadictdwill appear at the end of the edge tuple.IfGis not a multigraph, the tuples are(u,v,d)ifdatais True\nor(u,v)ifdatais False."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For Bor\u016fvka\u2019s algorithm, each edge must have a weight attribute, and\neach edge weight must be distinct. For the other algorithms, if the graph edges do not have a weight\nattribute a default weight of 1 will be used. Modified code from David Eppstein, April 2006 http://www.ics.uci.edu/~eppstein/PADS/",
            "Examples": "fromnetworkx.algorithmsimporttree\nFind maximum spanning edges by Kruskal\u2019s algorithm\nG=nx.cycle_graph(4)\nG.add_edge(0,3,weight=2)\nmst=tree.maximum_spanning_edges(G,algorithm=\"kruskal\",data=False)\nedgelist=list(mst)\nsorted(sorted(e)foreinedgelist)\n# [[0, 1], [0, 3], [1, 2]]\nFind maximum spanning edges by Prim\u2019s algorithm\nG=nx.cycle_graph(4)\nG.add_edge(0,3,weight=2)# assign weight 2 to edge 0-3\nmst=tree.maximum_spanning_edges(G,algorithm=\"prim\",data=False)\nedgelist=list(mst)\nsorted(sorted(e)foreinedgelist)\n# [[0, 1], [0, 3], [2, 3]]"
        }
    },
    {
        "Section ID": "find_cliques_recursive",
        "Description": [
            "Returns all maximal cliques in a graph.",
            "For each node v , a maximal clique for v is a largest complete\nsubgraph containing v . The largest maximal clique is sometimes\ncalled the maximum clique .",
            "This function returns an iterator over cliques, each of which is a\nlist of nodes. It is a recursive implementation, so may suffer from\nrecursion depth issues, but is included for pedagogical reasons.\nFor a non-recursive implementation, see find_cliques() .",
            "This function accepts a list of nodes and only the maximal cliques\ncontaining all of these nodes are returned. It can considerably speed up\nthe running time if some specific cliques are desired."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "nodes : list, optional (default=None)": "If provided, only yieldmaximal cliquescontaining all nodes innodes.\nIfnodesisn\u2019t a clique itself, a ValueError is raised."
            },
            "Returns:": {
                "iterator": "An iterator over maximal cliques, each of which is a list of\nnodes inG. Ifnodesis provided, only the maximal cliques\ncontaining all the nodes innodesare yielded. The order of\ncliques is arbitrary."
            },
            "Raises:": {
                "ValueError": "Ifnodesis not a clique."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "To obtain a list of all maximal cliques, use list(find_cliques_recursive(G)) . However, be aware that in the\nworst-case, the length of this list can be exponential in the number\nof nodes in the graph. This function avoids storing all cliques in memory\nby only keeping current candidate node lists in memory during its search. This implementation is based on the algorithm published by Bron and\nKerbosch (1973) [1] , as adapted by Tomita, Tanaka and Takahashi\n(2006) [2] and discussed in Cazals and Karande (2008) [3] . For a\nnon-recursive implementation, see find_cliques() . This algorithm ignores self-loops and parallel edges, since cliques\nare not conventionally defined with such edges.",
            "References": "[1]Bron, C. and Kerbosch, J.\n\u201cAlgorithm 457: finding all cliques of an undirected graph\u201d.Communications of the ACM16, 9 (Sep. 1973), 575\u2013577.\n<http://portal.acm.org/citation.cfm?doid=362342.362367>  [2]Etsuji Tomita, Akira Tanaka, Haruhisa Takahashi,\n\u201cThe worst-case time complexity for generating all maximal\ncliques and computational experiments\u201d,Theoretical Computer Science, Volume 363, Issue 1,\nComputing and Combinatorics,\n10th Annual International Conference on\nComputing and Combinatorics (COCOON 2004), 25 October 2006, Pages 28\u201342\n<https://doi.org/10.1016/j.tcs.2006.06.015>  [3]F. Cazals, C. Karande,\n\u201cA note on the problem of reporting maximal cliques\u201d,Theoretical Computer Science,\nVolume 407, Issues 1\u20133, 6 November 2008, Pages 564\u2013568,\n<https://doi.org/10.1016/j.tcs.2008.05.010>"
        }
    },
    {
        "Section ID": "generate_edgelist",
        "Description": [
            "Generate a single line of the graph G in edge list format."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "delimiter : string, optional": "Separator for node labels",
                "data : bool or list of keys": "If False generate no edge data.  If True use a dictionary\nrepresentation of edge data.  If a list of keys use a list of data\nvalues corresponding to the keys."
            },
            "Returns:": {
                "lines : string": "Lines of data in adjlist format."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.lollipop_graph(4,3)\nG[1][2][\"weight\"]=3\nG[3][4][\"capacity\"]=12\nforlineinnx.generate_edgelist(G,data=False):\nprint(line)\n# 0 1\n# 0 2\n# 0 3\n# 1 2\n# 1 3\n# 2 3\n# 3 4\n# 4 5\n# 5 6\nforlineinnx.generate_edgelist(G):\nprint(line)\n# 0 1 {}\n# 0 2 {}\n# 0 3 {}\n# 1 2 {'weight': 3}\n# 1 3 {}\n# 2 3 {}\n# 3 4 {'capacity': 12}\n# 4 5 {}\n# 5 6 {}\nforlineinnx.generate_edgelist(G,data=[\"weight\"]):\nprint(line)\n# 0 1\n# 0 2\n# 0 3\n# 1 2 3\n# 1 3\n# 2 3\n# 3 4\n# 4 5\n# 5 6"
        }
    },
    {
        "Section ID": "get_node_attributes",
        "Description": [
            "Get node attributes from graph"
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "",
                "name : string": "Attribute name",
                "default: object (default=None)": "Default value of the node attribute if there is no value set for that\nnode in graph. IfNonethen nodes without this attribute are not\nincluded in the returned dict."
            },
            "Returns:": {
                "Dictionary of attributes keyed by node.": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph()\nG.add_nodes_from([1,2,3],color=\"red\")\ncolor=nx.get_node_attributes(G,\"color\")\ncolor[1]\n# 'red'\nG.add_node(4)\ncolor=nx.get_node_attributes(G,\"color\",default=\"yellow\")\ncolor[4]\n# 'yellow'"
        }
    },
    {
        "Section ID": "chordal_graph_treewidth",
        "Description": [
            "Returns the treewidth of the chordal graph G."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph"
            },
            "Returns:": {
                "treewidth : int": "The size of the largest clique in the graph minus one."
            },
            "Raises:": {
                "NetworkXError": "The algorithm does not support DiGraph, MultiGraph and MultiDiGraph.\nThe algorithm can only be applied to chordal graphs. If the input\ngraph is found to be non-chordal, aNetworkXErroris raised."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://en.wikipedia.org/wiki/Tree_decomposition#Treewidth",
            "Examples": "e=[\n(1,2),\n(1,3),\n(2,3),\n(2,4),\n(3,4),\n(3,5),\n(3,6),\n(4,5),\n(4,6),\n(5,6),\n(7,8),\n]\nG=nx.Graph(e)\nG.add_node(9)\nnx.chordal_graph_treewidth(G)\n# 3"
        }
    },
    {
        "Section ID": "vf2pp_all_isomorphisms",
        "Description": [
            "Yields all the possible mappings between G1 and G2."
        ],
        "Field List": {
            "Parameters:": {
                "G1, G2 : NetworkX Graph or MultiGraph instances.": "The two graphs to check for isomorphism.",
                "node_label : str, optional": "The name of the node attribute to be used when comparing nodes.\nThe default isNone, meaning node attributes are not considered\nin the comparison. Any node that doesn\u2019t have thenode_labelattribute usesdefault_labelinstead.",
                "default_label : scalar": "Default value to use when a node doesn\u2019t have an attribute\nnamednode_label. Default isNone."
            },
            "Yields:": {
                "dict": "Isomorphic mapping between the nodes inG1andG2."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "desargues_graph",
        "Description": [
            "Returns the Desargues Graph",
            "The Desargues Graph is a non-planar, distance-transitive cubic graph\nwith 20 nodes and 30 edges [1] .\nIt is a symmetric graph. It can be represented in LCF notation\nas [5,-5,9,-9]^5 [2] ."
        ],
        "Field List": {
            "Parameters:": {
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : networkx Graph": "Desargues Graph with 20 nodes and 30 edges"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://en.wikipedia.org/wiki/Desargues_graph  [2]https://mathworld.wolfram.com/DesarguesGraph.html"
        }
    },
    {
        "Section ID": "common_neighbors",
        "Description": [
            "Returns the common neighbors of two nodes in a graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX undirected graph.",
                "u, v : nodes": "Nodes in the graph."
            },
            "Returns:": {
                "cnbors : set": "Set of common neighbors of u and v in the graph."
            },
            "Raises:": {
                "NetworkXError": "If u or v is not a node in the graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.complete_graph(5)\nsorted(nx.common_neighbors(G,0,1))\n# [2, 3, 4]"
        }
    },
    {
        "Section ID": "kernighan_lin_bisection",
        "Description": [
            "Partition a graph into two blocks using the Kernighan\u2013Lin\nalgorithm.",
            "This algorithm partitions a network into two sets by iteratively\nswapping pairs of nodes to reduce the edge cut between the two sets.  The\npairs are chosen according to a modified form of Kernighan-Lin [1] , which\nmoves node individually, alternating between sides to keep the bisection\nbalanced."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Graph must be undirected.",
                "partition : tuple": "Pair of iterables containing an initial partition. If not\nspecified, a random balanced partition is used.",
                "max_iter : int": "Maximum number of times to attempt swaps to find an\nimprovement before giving up.",
                "weight : key": "Edge data key to use as weight. If None, the weights are all\nset to one.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.\nOnly used if partition is None"
            },
            "Returns:": {
                "partition : tuple": "A pair of sets of nodes representing the bipartition."
            },
            "Raises:": {
                "NetworkXError": "If partition is not a valid partition of the nodes of the graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Kernighan, B. W.; Lin, Shen (1970).\n\u201cAn efficient heuristic procedure for partitioning graphs.\u201dBell Systems Technical Journal49: 291\u2013307.\nOxford University Press 2011."
        }
    },
    {
        "Section ID": "star_graph",
        "Description": [
            "Return the star graph",
            "The star graph consists of one center node connected to n outer nodes.",
            "( Sourcecode , png )"
        ],
        "Field List": {
            "Parameters:": {
                "n : int or iterable": "If an integer, node labels are 0 to n with center 0.\nIf an iterable of nodes, the center is the first.\nWarning: n is not checked for duplicates and if present the\nresulting graph may not be as desired. Make sure you have no duplicates.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The graph has n+1 nodes for integer n.\nSo star_graph(3) is the same as star_graph(range(4))."
        }
    },
    {
        "Section ID": "thresholded_random_geometric_graph",
        "Description": [
            "Returns a thresholded random geometric graph in the unit cube.",
            "The thresholded random geometric graph [1] model places n nodes\nuniformly at random in the unit cube of dimensions dim . Each node u is assigned a weight \\(w_u\\) . Two nodes u and v are\njoined by an edge if they are within the maximum connection distance, radius computed by the p -Minkowski distance and the summation of\nweights \\(w_u\\) + \\(w_v\\) is greater than or equal\nto the threshold parameter theta .",
            "Edges within radius of each other are determined using a KDTree when\nSciPy is available. This reduces the time complexity from \\(O(n^2)\\) to \\(O(n)\\) ."
        ],
        "Field List": {
            "Parameters:": {
                "n : int or iterable": "Number of nodes or iterable of nodes",
                "radius: float": "Distance threshold value",
                "theta: float": "Threshold value",
                "dim : int, optional": "Dimension of graph",
                "pos : dict, optional": "A dictionary keyed by node with node positions as values.",
                "weight : dict, optional": "Node weights as a dictionary of numbers keyed by node.",
                "p : float, optional (default 2)": "Which Minkowski distance metric to use.phas to meet the condition1<=p<=infinity.If this argument is not specified, the\\(L^2\\)metric\n(the Euclidean distance metric), p = 2 is used.This should not be confused with thepof an Erd\u0151s-R\u00e9nyi random\ngraph, which represents probability.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "pos_name : string, default=\u201dpos\u201d": "The name of the node attribute which represents the position\nin 2D coordinates of the node in the returned graph.",
                "weight_name : string, default=\u201dweight\u201d": "The name of the node attribute which represents the weight\nof the node in the returned graph."
            },
            "Returns:": {
                "Graph": "A thresholded random geographic graph, undirected and without\nself-loops.Each node has a node attribute'pos'that stores the\nposition of that node in Euclidean space as provided by theposkeyword argument or, ifposwas not provided, as\ngenerated by this function. Similarly, each node has a nodethre\nattribute'weight'that stores the weight of that node as\nprovided or as generated."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This uses a k -d tree to build the graph. The pos keyword argument can be used to specify node positions so you\ncan create an arbitrary distribution and domain for positions. For example, to use a 2D Gaussian distribution of node positions with mean\n(0, 0) and standard deviation 2 If weights are not specified they are assigned to nodes by drawing randomly\nfrom the exponential distribution with rate parameter \\(\\lambda=1\\) .\nTo specify weights from a different distribution, use the weight keyword\nargument:",
            "References": "[1]http://cole-maclean.github.io/blog/files/thesis.pdf",
            "Examples": "Default Graph:\nG = nx.thresholded_random_geometric_graph(50, 0.2, 0.1)\nCustom Graph:\nCreate a thresholded random geometric graph on 50 uniformly distributed\nnodes where nodes are joined by an edge if their sum weights drawn from\na exponential distribution with rate = 5 are >= theta = 0.1 and their\nEuclidean distance is at most 0.2."
        }
    },
    {
        "Section ID": "threshold_accepting_tsp",
        "Description": [
            "Returns an approximate solution to the traveling salesman problem.",
            "This function uses threshold accepting methods to approximate the minimal cost\ncycle through the nodes. Starting from a suboptimal solution, threshold\naccepting methods perturb that solution, accepting any changes that make\nthe solution no worse than increasing by a threshold amount. Improvements\nin cost are accepted, but so are changes leading to small increases in cost.\nThis allows the solution to leave suboptimal local minima in solution space.\nThe threshold is decreased slowly as iterations proceed helping to ensure\nan optimum. In summary, the function returns a cycle starting at source for which the total cost is minimized."
        ],
        "Field List": {
            "Parameters:": {
                "G : Graph": "Gshould be a complete weighted graph.\nThe distance between all pairs of nodes should be included.",
                "init_cycle : list or \u201cgreedy\u201d": "The initial solution (a cycle through all nodes returning to the start).\nThis argument has no default to make you think about it.\nIf \u201cgreedy\u201d, usegreedy_tsp(G,weight).\nOther common starting cycles arelist(G)+[next(iter(G))]or the final\nresult ofsimulated_annealing_tspwhen doingthreshold_accepting_tsp.",
                "weight : string, optional (default=\u201dweight\u201d)": "Edge data key corresponding to the edge weight.\nIf any edge does not have this attribute the weight is set to 1.",
                "source : node, optional (default: first node in list(G))": "Starting node.  If None, defaults tonext(iter(G))",
                "threshold : int, optional (default=1)": "The algorithm\u2019s threshold parameter. It represents the initial\nthreshold\u2019s value",
                "move : \u201c1-1\u201d or \u201c1-0\u201d or function, optional (default=\u201d1-1\u201d)": "Indicator of what move to use when finding new trial solutions.\nStrings indicate two special built-in moves:\u201c1-1\u201d: 1-1 exchange which transposes the position\nof two elements of the current solution.\nThe function called isswap_two_nodes().\nFor example if we apply 1-1 exchange in the solutionA=[3,2,1,4,3]we can get the following by the transposition of 1 and 4 elements:A'=[3,2,4,1,3]\u201c1-0\u201d: 1-0 exchange which moves an node in the solution\nto a new position.\nThe function called ismove_one_node().\nFor example if we apply 1-0 exchange in the solutionA=[3,2,1,4,3]we can transfer the fourth element to the second position:A'=[3,4,2,1,3]You may provide your own functions to enact a move from\none solution to a neighbor solution. The function must take\nthe solution as input along with aseedinput to control\nrandom number generation (see theseedinput here).\nYour function should maintain the solution as a cycle with\nequal first and last node and all others appearing once.\nYour function should return the new solution.",
                "max_iterations : int, optional (default=10)": "Declared done when this number of consecutive iterations of\nthe outer loop occurs without any change in the best cost solution.",
                "N_inner : int, optional (default=100)": "The number of iterations of the inner loop.",
                "alpha : float between (0, 1), optional (default=0.1)": "Percentage of threshold decrease when there is at\nleast one acceptance of a neighbor solution.\nIf no inner loop moves are accepted the threshold remains unchanged.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "cycle : list of nodes": "Returns the cycle (list of nodes) that a salesman\ncan follow to minimize total weight of the trip."
            },
            "Raises:": {
                "NetworkXError": "IfGis not complete the algorithm raises an exception."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Threshold Accepting is a metaheuristic local search algorithm.\nThe main characteristic of this algorithm is that it accepts\neven solutions which lead to the increase of the cost in order\nto escape from low quality local optimal solutions. This algorithm needs an initial solution. This solution can be\nconstructed by a simple greedy algorithm. At every iteration, it\nselects thoughtfully a neighbor solution.\nConsider \\(c(x)\\) cost of current solution and \\(c(x')\\) cost of\nneighbor solution.\nIf \\(c(x') - c(x) <= threshold\\) then the neighbor solution becomes the current\nsolution for the next iteration, where the threshold is named threshold. In comparison to the Simulated Annealing algorithm, the Threshold\nAccepting algorithm does not accept very low quality solutions\n(due to the presence of the threshold value). In the case of\nSimulated Annealing, even a very low quality solution can\nbe accepted with probability \\(p\\) . Time complexity:\nIt has a running time \\(O(m * n * |V|)\\) where \\(m\\) and \\(n\\) are the number\nof times the outer and inner loop run respectively. For more information and how algorithm is inspired see: https://doi.org/10.1016/0021-9991(90)90201-B",
            "Examples": "fromnetworkx.algorithmsimportapproximationasapprox\nG=nx.DiGraph()\nG.add_weighted_edges_from(\n{\n(\"A\",\"B\",3),\n(\"A\",\"C\",17),\n(\"A\",\"D\",14),\n(\"B\",\"A\",3),\n(\"B\",\"C\",12),\n(\"B\",\"D\",16),\n(\"C\",\"A\",13),\n(\"C\",\"B\",12),\n(\"C\",\"D\",4),\n(\"D\",\"A\",14),\n(\"D\",\"B\",15),\n(\"D\",\"C\",2),\n}\n)\ncycle=approx.threshold_accepting_tsp(G,\"greedy\",source=\"D\")\ncost=sum(G[n][nbr][\"weight\"]forn,nbrinnx.utils.pairwise(cycle))\ncycle\n# ['D', 'C', 'B', 'A', 'D']\ncost\n# 31\nincycle=[\"D\",\"B\",\"A\",\"C\",\"D\"]\ncycle=approx.threshold_accepting_tsp(G,incycle,source=\"D\")\ncost=sum(G[n][nbr][\"weight\"]forn,nbrinnx.utils.pairwise(cycle))\ncycle\n# ['D', 'C', 'B', 'A', 'D']\ncost\n# 31"
        }
    },
    {
        "Section ID": "random_unlabeled_rooted_forest",
        "Description": [
            "Returns a forest or list of forests selected at random.",
            "Returns one or more (depending on number_of_forests )\nunlabeled rooted forests with n nodes, and with no more than q nodes per tree, drawn uniformly at random.\nThe \u201croots\u201d graph attribute identifies the roots of the forest."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes",
                "q : int or None (default)": "The maximum number of nodes per tree.",
                "number_of_forests : int or None (default)": "If not None, this number of forests is generated and returned.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "networkx.Graph : or list of : networkx.Graph": "A singlenetworkx.Graph(or a list thereof, ifnumber_of_forestsis specified) with nodes in the set {0, \u2026,n- 1}.\nThe \u201croots\u201d graph attribute is a set containing the roots\nof the trees in the forest."
            },
            "Raises:": {
                "ValueError": "Ifnis non-zero butqis zero."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This function implements the algorithm \u201cForest\u201d of [1] .\nThe algorithm needs to compute some counting functions\nthat are relatively expensive: in case several trees are needed,\nit is advisable to use the number_of_forests optional argument\nto reuse the counting functions.",
            "References": "[1]Wilf, Herbert S. \u201cThe uniform selection of free trees.\u201d\nJournal of Algorithms 2.2 (1981): 204-207.https://doi.org/10.1016/0196-6774(81)90021-3"
        }
    },
    {
        "Section ID": "turan_graph",
        "Description": [
            "Return the Turan Graph",
            "The Turan Graph is a complete multipartite graph on \\(n\\) nodes\nwith \\(r\\) disjoint subsets. That is, edges connect each node to\nevery node not in its subset.",
            "Given \\(n\\) and \\(r\\) , we create a complete multipartite graph with \\(r-(n \\mod r)\\) partitions of size \\(n/r\\) , rounded down, and \\(n \\mod r\\) partitions of size \\(n/r+1\\) , rounded down.",
            "( Sourcecode , png )"
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes.",
                "r : int": "The number of partitions.\nMust be less than or equal to n."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Must satisfy \\(1 <= r <= n\\) .\nThe graph has \\((r-1)(n^2)/(2r)\\) edges, rounded down."
        }
    },
    {
        "Section ID": "cytoscape_data",
        "Description": [
            "Returns data in Cytoscape JSON format (cyjs)."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "The graph to convert to cytoscape format",
                "name : string": "A string which is mapped to the \u2018name\u2019 node element in cyjs format.\nMust not have the same value asident.",
                "ident : string": "A string which is mapped to the \u2018id\u2019 node element in cyjs format.\nMust not have the same value asname."
            },
            "Returns:": {
                "data: dict": "A dictionary with cyjs formatted data."
            },
            "Raises:": {
                "NetworkXError": "If the values fornameandidentare identical."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Cytoscape user\u2019s manual:http://manual.cytoscape.org/en/stable/index.html",
            "Examples": "G=nx.path_graph(2)\nnx.cytoscape_data(G)\n# {'data': [],\n#  'directed': False,\n#  'multigraph': False,\n#  'elements': {'nodes': [{'data': {'id': '0', 'value': 0, 'name': '0'}},\n#    {'data': {'id': '1', 'value': 1, 'name': '1'}}],\n#   'edges': [{'data': {'source': 0, 'target': 1}}]}}"
        }
    },
    {
        "Section ID": "extended_barabasi_albert_graph",
        "Description": [
            "Returns an extended Barab\u00e1si\u2013Albert model graph.",
            "An extended Barab\u00e1si\u2013Albert model graph is a random graph constructed\nusing preferential attachment. The extended model allows new edges,\nrewired edges or new nodes. Based on the probabilities \\(p\\) and \\(q\\) with \\(p + q < 1\\) , the growing behavior of the graph is determined as:",
            "1) With \\(p\\) probability, \\(m\\) new edges are added to the graph,\nstarting from randomly chosen existing nodes and attached preferentially at the other end.",
            "2) With \\(q\\) probability, \\(m\\) existing edges are rewired\nby randomly choosing an edge and rewiring one end to a preferentially chosen node.",
            "3) With \\((1 - p - q)\\) probability, \\(m\\) new nodes are added to the graph\nwith edges attached preferentially.",
            "When \\(p = q = 0\\) , the model behaves just like the Barab\u00e1si\u2013Alber model."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "Number of nodes",
                "m : int": "Number of edges with which a new node attaches to existing nodes",
                "p : float": "Probability value for adding an edge between existing nodes. p + q < 1",
                "q : float": "Probability value of rewiring of existing edges. p + q < 1",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "G : Graph": ""
            },
            "Raises:": {
                "NetworkXError": "Ifmdoes not satisfy1<=m<nor1>=p+q"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Albert, R., & Barab\u00e1si, A. L. (2000)\nTopology of evolving networks: local events and universality\nPhysical review letters, 85(24), 5234."
        }
    },
    {
        "Section ID": "write_edgelist",
        "Description": [
            "Write graph as a list of edges."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "path : file or string": "File or filename to write. If a file is provided, it must be\nopened in \u2018wb\u2019 mode. Filenames ending in .gz or .bz2 will be compressed.",
                "comments : string, optional": "The character used to indicate the start of a comment",
                "delimiter : string, optional": "The string used to separate values.  The default is whitespace.",
                "data : bool or list, optional": "If False write no edge data.\nIf True write a string representation of the edge data dictionary..\nIf a list (or other iterable) is provided, write the  keys specified\nin the list.",
                "encoding: string, optional": "Specify which encoding to use when writing file."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.path_graph(4)\nnx.write_edgelist(G,\"test.edgelist\")\nG=nx.path_graph(4)\nfh=open(\"test.edgelist\",\"wb\")\nnx.write_edgelist(G,fh)\nnx.write_edgelist(G,\"test.edgelist.gz\")\nnx.write_edgelist(G,\"test.edgelist.gz\",data=False)\nG=nx.Graph()\nG.add_edge(1,2,weight=7,color=\"red\")\nnx.write_edgelist(G,\"test.edgelist\",data=False)\nnx.write_edgelist(G,\"test.edgelist\",data=[\"color\"])\nnx.write_edgelist(G,\"test.edgelist\",data=[\"color\",\"weight\"])"
        }
    },
    {
        "Section ID": "immediate_dominators",
        "Description": [
            "Returns the immediate dominators of all nodes of a directed graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : a DiGraph or MultiDiGraph": "The graph where dominance is to be computed.",
                "start : node": "The start node of dominance computation."
            },
            "Returns:": {
                "idom : dict keyed by nodes": "A dict containing the immediate dominators of each node reachable fromstart."
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis undirected.",
                "NetworkXError": "Ifstartis not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Except for start , the immediate dominators are the parents of their\ncorresponding nodes in the dominator tree.",
            "References": "[1]K. D. Cooper, T. J. Harvey, and K. Kennedy.\nA simple, fast dominance algorithm.\nSoftware Practice & Experience, 4:110, 2001.",
            "Examples": "G=nx.DiGraph([(1,2),(1,3),(2,5),(3,4),(4,5)])\nsorted(nx.immediate_dominators(G,1).items())\n# [(1, 1), (2, 1), (3, 1), (4, 3), (5, 1)]"
        }
    },
    {
        "Section ID": "biadjacency_matrix",
        "Description": [
            "Returns the biadjacency matrix of the bipartite graph G.",
            "Let G=(U,V,E) be a bipartite graph with node sets U=u_{1},...,u_{r} and V=v_{1},...,v_{s} . The biadjacency\nmatrix [1] is the r x s matrix B in which b_{i,j}=1 if, and only if, (u_i,v_j)inE . If the parameter weight is\nnot None and matches the name of an edge attribute, its value is\nused instead of 1."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "row_order : list of nodes": "The rows of the matrix are ordered according to the list of nodes.",
                "column_order : list, optional": "The columns of the matrix are ordered according to the list of nodes.\nIf column_order is None, then the ordering of columns is arbitrary.",
                "dtype : NumPy data-type, optional": "A valid NumPy dtype used to initialize the array. If None, then the\nNumPy default is used.",
                "weight : string or None, optional (default=\u2019weight\u2019)": "The edge data key used to provide each value in the matrix.\nIf None, then each edge has weight 1.",
                "format : str in {\u2018bsr\u2019, \u2018csr\u2019, \u2018csc\u2019, \u2018coo\u2019, \u2018lil\u2019, \u2018dia\u2019, \u2018dok\u2019}": "The type of the matrix to be returned (default \u2018csr\u2019).  For\nsome algorithms different implementations of sparse matrices\ncan perform better.  See[2]for details."
            },
            "Returns:": {
                "M : SciPy sparse array": "Biadjacency matrix representation of the bipartite graph G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "No attempt is made to check that the input graph is bipartite. For directed bipartite graphs only successors are considered as neighbors.\nTo obtain an adjacency matrix with ones (or weight values) for both\npredecessors and successors you have to generate two biadjacency matrices\nwhere the rows of one of them are the columns of the other, and then add\none to the transpose of the other.",
            "References": "[1]https://en.wikipedia.org/wiki/Adjacency_matrix#Adjacency_matrix_of_a_bipartite_graph  [2]Scipy Dev. References, \u201cSparse Matrices\u201d,https://docs.scipy.org/doc/scipy/reference/sparse.html"
        }
    },
    {
        "Section ID": "transitive_closure",
        "Description": [
            "Returns transitive closure of a graph",
            "The transitive closure of G = (V,E) is a graph G+ = (V,E+) such that\nfor all v, w in V there is an edge (v, w) in E+ if and only if there\nis a path from v to w in G.",
            "Handling of paths from v to v has some flexibility within this definition.\nA reflexive transitive closure creates a self-loop for the path\nfrom v to v of length 0. The usual transitive closure creates a\nself-loop only if a cycle exists (a path from v to v with length > 0).\nWe also allow an option for no self-loops."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "A directed/undirected graph/multigraph.",
                "reflexive : Bool or None, optional (default: False)": "Determines when cycles create self-loops in the Transitive Closure.\nIf True, trivial cycles (length 0) create self-loops. The result\nis a reflexive transitive closure of G.\nIf False (the default) non-trivial cycles create self-loops.\nIf None, self-loops are not created."
            },
            "Returns:": {
                "NetworkX graph": "The transitive closure ofG"
            },
            "Raises:": {
                "NetworkXError": "Ifreflexivenot in{None,True,False}"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://www.ics.uci.edu/~eppstein/PADS/PartialOrder.py",
            "Examples": "The treatment of trivial (i.e. length 0) cycles is controlled by thereflexiveparameter.\nTrivial (i.e. length 0) cycles do not create self-loops whenreflexive=False(the default):\nDG=nx.DiGraph([(1,2),(2,3)])\nTC=nx.transitive_closure(DG,reflexive=False)\nTC.edges()\n# OutEdgeView([(1, 2), (1, 3), (2, 3)])\nHowever, nontrivial (i.e. length greater than 0) cycles create self-loops\nwhenreflexive=False(the default):\nDG=nx.DiGraph([(1,2),(2,3),(3,1)])\nTC=nx.transitive_closure(DG,reflexive=False)\nTC.edges()\n# OutEdgeView([(1, 2), (1, 3), (1, 1), (2, 3), (2, 1), (2, 2), (3, 1), (3, 2), (3, 3)])\nTrivial cycles (length 0) create self-loops whenreflexive=True:\nDG=nx.DiGraph([(1,2),(2,3)])\nTC=nx.transitive_closure(DG,reflexive=True)\nTC.edges()\n# OutEdgeView([(1, 2), (1, 1), (1, 3), (2, 3), (2, 2), (3, 3)])\nAnd the third option is not to create self-loops at all whenreflexive=None:\nDG=nx.DiGraph([(1,2),(2,3),(3,1)])\nTC=nx.transitive_closure(DG,reflexive=None)\nTC.edges()\n# OutEdgeView([(1, 2), (1, 3), (2, 3), (2, 1), (3, 1), (3, 2)])"
        }
    },
    {
        "Section ID": "large_clique_size",
        "Description": [
            "Find the size of a large clique in a graph.",
            "A clique is a subset of nodes in which each pair of nodes is\nadjacent. This function is a heuristic for finding the size of a\nlarge clique in the graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": ""
            },
            "Returns:": {
                "k: integer": "The size of a large clique in the graph."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the graph is directed or is a multigraph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This implementation is from [1] . Its worst case time complexity is \\(O(n d^2)\\) , where n is the number of nodes in the graph and d is the maximum degree. This function is a heuristic, which means it may work well in\npractice, but there is no rigorous mathematical guarantee on the\nratio between the returned number and the actual largest clique size\nin the graph.",
            "References": "[1]Pattabiraman, Bharath, et al.\n\u201cFast Algorithms for the Maximum Clique Problem on Massive Graphs\nwith Applications to Overlapping Community Detection.\u201dInternet Mathematics11.4-5 (2015): 421\u2013448.\n<https://doi.org/10.1080/15427951.2014.986778>",
            "Examples": "G=nx.path_graph(10)\nnx.approximation.large_clique_size(G)\n# 2"
        }
    },
    {
        "Section ID": "relabel_nodes",
        "Description": [
            "Relabel the nodes of the graph G according to a given mapping.",
            "The original node ordering may not be preserved if copy is False and the\nmapping includes overlap between old and new labels."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "mapping : dictionary": "A dictionary with the old labels as keys and new labels as values.\nA partial mapping is allowed. Mapping 2 nodes to a single node is allowed.\nAny non-node keys in the mapping are ignored.",
                "copy : bool (optional, default=True)": "If True return a copy, or if False relabel the nodes in place."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Only the nodes specified in the mapping will be relabeled.\nAny non-node keys in the mapping are ignored. The keyword setting copy=False modifies the graph in place.\nRelabel_nodes avoids naming collisions by building a\ndirected graph from mapping which specifies the order of\nrelabelings. Naming collisions, such as a->b, b->c, are ordered\nsuch that \u201cb\u201d gets renamed to \u201cc\u201d before \u201ca\u201d gets renamed \u201cb\u201d.\nIn cases of circular mappings (e.g. a->b, b->a), modifying the\ngraph is not possible in-place and an exception is raised.\nIn that case, use copy=True. If a relabel operation on a multigraph would cause two or more\nedges to have the same source, target and key, the second edge must\nbe assigned a new key to retain all edges. The new key is set\nto the lowest non-negative integer not already used as a key\nfor edges between these two nodes. Note that this means non-numeric\nkeys may be replaced by numeric keys.",
            "Examples": "To create a new graph with nodes relabeled according to a given\ndictionary:\nG=nx.path_graph(3)\nsorted(G)\n# [0, 1, 2]\nmapping={0:\"a\",1:\"b\",2:\"c\"}\nH=nx.relabel_nodes(G,mapping)\nsorted(H)\n# ['a', 'b', 'c']\nNodes can be relabeled with any hashable object, including numbers\nand strings:\nimportstring\nG=nx.path_graph(26)# nodes are integers 0 through 25\nsorted(G)[:3]\n# [0, 1, 2]\nmapping=dict(zip(G,string.ascii_lowercase))\nG=nx.relabel_nodes(G,mapping)# nodes are characters a through z\nsorted(G)[:3]\n# ['a', 'b', 'c']\nmapping=dict(zip(G,range(1,27)))\nG=nx.relabel_nodes(G,mapping)# nodes are integers 1 through 26\nsorted(G)[:3]\n# [1, 2, 3]\nTo perform a partial in-place relabeling, provide a dictionary\nmapping only a subset of the nodes, and set thecopykeyword\nargument to False:\nG=nx.path_graph(3)# nodes 0-1-2\nmapping={0:\"a\",1:\"b\"}# 0->'a' and 1->'b'\nG=nx.relabel_nodes(G,mapping,copy=False)\nsorted(G,key=str)\n# [2, 'a', 'b']\nA mapping can also be given as a function:\nG=nx.path_graph(3)\nH=nx.relabel_nodes(G,lambdax:x**2)\nlist(H)\n# [0, 1, 4]\nIn a multigraph, relabeling two or more nodes to the same new node\nwill retain all edges, but may change the edge keys in the process:\nG=nx.MultiGraph()\nG.add_edge(0,1,value=\"a\")# returns the key for this edge\n# 0\nG.add_edge(0,2,value=\"b\")\n# 0\nG.add_edge(0,3,value=\"c\")\n# 0\nmapping={1:4,2:4,3:4}\nH=nx.relabel_nodes(G,mapping,copy=True)\nprint(H[0])\n# {4: {0: {'value': 'a'}, 1: {'value': 'b'}, 2: {'value': 'c'}}}\nThis works for in-place relabeling too:\nG=nx.relabel_nodes(G,mapping,copy=False)\nprint(G[0])\n# {4: {0: {'value': 'a'}, 1: {'value': 'b'}, 2: {'value': 'c'}}}"
        }
    },
    {
        "Section ID": "all_triplets",
        "Description": [
            "Returns a generator of all possible sets of 3 nodes in a DiGraph."
        ],
        "Field List": {
            "Parameters:": {
                "G : digraph": "A NetworkX DiGraph"
            },
            "Returns:": {
                "triplets : generator of 3-tuples": "Generator of tuples of 3 nodes"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.DiGraph([(1,2),(2,3),(3,4)])\nlist(nx.all_triplets(G))\n# [(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)]"
        }
    },
    {
        "Section ID": "minimum_st_edge_cut",
        "Description": [
            "Returns the edges of the cut-set of a minimum (s, t)-cut.",
            "This function returns the set of edges of minimum cardinality that,\nif removed, would destroy all paths among source and target in G.\nEdge weights are not considered. See minimum_cut() for\ncomputing minimum cuts considering edge weights."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "s : node": "Source node for the flow.",
                "t : node": "Sink node for the flow.",
                "auxiliary : NetworkX DiGraph": "Auxiliary digraph to compute flow based node connectivity. It has\nto have a graph attribute called mapping with a dictionary mapping\nnode names in G and in the auxiliary digraph. If provided\nit will be reused instead of recreated. Default value: None.",
                "flow_func : function": "A function for computing the maximum flow among a pair of nodes.\nThe function has to accept at least three parameters: a Digraph,\na source node, and a target node. And return a residual network\nthat follows NetworkX conventions (seemaximum_flow()for\ndetails). If flow_func is None, the default maximum flow function\n(edmonds_karp()) is used. Seenode_connectivity()for\ndetails. The choice of the default function may change from version\nto version and should not be relied on. Default value: None.",
                "residual : NetworkX DiGraph": "Residual network to compute maximum flow. If provided it will be\nreused instead of recreated. Default value: None."
            },
            "Returns:": {
                "cutset : set": "Set of edges that, if removed from the graph, will disconnect it."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "This function is not imported in the base NetworkX namespace, so you\nhave to explicitly import it from the connectivity package:\nfromnetworkx.algorithms.connectivityimportminimum_st_edge_cut\nWe use in this example the platonic icosahedral graph, which has edge\nconnectivity 5.\nG=nx.icosahedral_graph()\nlen(minimum_st_edge_cut(G,0,6))\n# 5\nIf you need to compute local edge cuts on several pairs of\nnodes in the same graph, it is recommended that you reuse the\ndata structures that NetworkX uses in the computation: the\nauxiliary digraph for edge connectivity, and the residual\nnetwork for the underlying maximum flow computation.\nExample of how to compute local edge cuts among all pairs of\nnodes of the platonic icosahedral graph reusing the data\nstructures.\nimportitertools\n# You also have to explicitly import the function for\n# building the auxiliary digraph from the connectivity package\nfromnetworkx.algorithms.connectivityimportbuild_auxiliary_edge_connectivity\nH=build_auxiliary_edge_connectivity(G)\n# And the function for building the residual network from the\n# flow package\nfromnetworkx.algorithms.flowimportbuild_residual_network\n# Note that the auxiliary digraph has an edge attribute named capacity\nR=build_residual_network(H,\"capacity\")\nresult=dict.fromkeys(G,dict())\n# Reuse the auxiliary digraph and the residual network by passing them\n# as parameters\nforu,vinitertools.combinations(G,2):\nk=len(minimum_st_edge_cut(G,u,v,auxiliary=H,residual=R))\nresult[u][v]=k\nall(result[u][v]==5foru,vinitertools.combinations(G,2))\n# True\nYou can also use alternative flow algorithms for computing edge\ncuts. For instance, in dense networks the algorithmshortest_augmenting_path()will usually perform better than\nthe defaultedmonds_karp()which is faster for sparse\nnetworks with highly skewed degree distributions. Alternative flow\nfunctions have to be explicitly imported from the flow package.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\nlen(minimum_st_edge_cut(G,0,6,flow_func=shortest_augmenting_path))\n# 5"
        }
    },
    {
        "Section ID": "periphery",
        "Description": [
            "Returns the periphery of the graph G.",
            "The periphery is the set of nodes with eccentricity equal to the diameter."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A graph",
                "e : eccentricity dictionary, optional": "A precomputed dictionary of eccentricities.",
                "weight : string, function, or None": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number.If this is None, every edge has weight/distance/cost 1.Weights stored as floating point values can lead to small round-off\nerrors in distances. Use integer weights to avoid this.Weights should be positive, since they are distances."
            },
            "Returns:": {
                "p : list": "List of nodes in periphery"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph([(1,2),(1,3),(1,4),(3,4),(3,5),(4,5)])\nnx.periphery(G)\n# [2, 5]"
        }
    },
    {
        "Section ID": "is_bipartite_node_set",
        "Description": [
            "Returns True if nodes and G/nodes are a bipartition of G."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "nodes: list or container": "Check if nodes are a one of a bipartite set."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "An exception is raised if the input nodes are not distinct, because in this\ncase some bipartite algorithms will yield incorrect results.\nFor connected graphs the bipartite sets are unique.  This function handles\ndisconnected graphs.",
            "Examples": "fromnetworkx.algorithmsimportbipartite\nG=nx.path_graph(4)\nX=set([1,3])\nbipartite.is_bipartite_node_set(G,X)\n# True"
        }
    },
    {
        "Section ID": "from_numpy_array",
        "Description": [
            "Returns a graph from a 2D NumPy array.",
            "The 2D NumPy array is interpreted as an adjacency matrix for the graph."
        ],
        "Field List": {
            "Parameters:": {
                "A : a 2D numpy.ndarray": "An adjacency matrix representation of a graph",
                "parallel_edges : Boolean": "If this is True,create_usingis a multigraph, andAis an\ninteger array, then entry(i, j)in the array is interpreted as the\nnumber of parallel edges joining verticesiandjin the graph.\nIf it is False, then the entries in the array are interpreted as\nthe weight of a single edge joining the vertices.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated.",
                "edge_attr : String, optional (default=\u201dweight\u201d)": "The attribute to which the array values are assigned on each edge. If\nit is None, edge attributes will not be assigned."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For directed graphs, explicitly mention create_using=nx.DiGraph,\nand entry i,j of A corresponds to an edge from i to j. If create_using is networkx.MultiGraph or networkx.MultiDiGraph , parallel_edges is True, and the\nentries of A are of type int , then this function returns a\nmultigraph (of the same type as create_using ) with parallel edges. If create_using indicates an undirected multigraph, then only the edges\nindicated by the upper triangle of the array A will be added to the\ngraph. If edge_attr is Falsy (False or None), edge attributes will not be\nassigned, and the array data will be treated like a binary mask of\nedge presence or absence. Otherwise, the attributes will be assigned\nas follows: If the NumPy array has a single data type for each array entry it\nwill be converted to an appropriate Python data type. If the NumPy array has a user-specified compound data type the names\nof the data fields will be used as attribute keys in the resulting\nNetworkX graph.",
            "Examples": "Simple integer weights on edges:\nimportnumpyasnp\nA=np.array([[1,1],[2,1]])\nG=nx.from_numpy_array(A)\nG.edges(data=True)\n# EdgeDataView([(0, 0, {'weight': 1}), (0, 1, {'weight': 2}), (1, 1, {'weight': 1})])\nIfcreate_usingindicates a multigraph and the array has only integer\nentries andparallel_edgesis False, then the entries will be treated\nas weights for edges joining the nodes (without creating parallel edges):\nA=np.array([[1,1],[1,2]])\nG=nx.from_numpy_array(A,create_using=nx.MultiGraph)\nG[1][1]\n# AtlasView({0: {'weight': 2}})\nIfcreate_usingindicates a multigraph and the array has only integer\nentries andparallel_edgesis True, then the entries will be treated\nas the number of parallel edges joining those two vertices:\nA=np.array([[1,1],[1,2]])\ntemp=nx.MultiGraph()\nG=nx.from_numpy_array(A,parallel_edges=True,create_using=temp)\nG[1][1]\n# AtlasView({0: {'weight': 1}, 1: {'weight': 1}})\nUser defined compound data type on edges:\ndt=[(\"weight\",float),(\"cost\",int)]\nA=np.array([[(1.0,2)]],dtype=dt)\nG=nx.from_numpy_array(A)\nG.edges()\n# EdgeView([(0, 0)])\nG[0][0][\"cost\"]\n# 2\nG[0][0][\"weight\"]\n# 1.0"
        }
    },
    {
        "Section ID": "number_of_isolates",
        "Description": [
            "Returns the number of isolates in the graph.",
            "An isolate is a node with no neighbors (that is, with degree\nzero). For directed graphs, this means no in-neighbors and no\nout-neighbors."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": ""
            },
            "Returns:": {
                "int": "The number of degree zero nodes in the graphG."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "cycle_basis",
        "Description": [
            "Returns a list of cycles which form a basis for cycles of G.",
            "A basis for cycles of a network is a minimal collection of\ncycles such that any cycle in the network can be written\nas a sum of cycles in the basis.  Here summation of cycles\nis defined as \u201cexclusive or\u201d of the edges. Cycle bases are\nuseful, e.g. when deriving equations for electric circuits\nusing Kirchhoff\u2019s Laws."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "",
                "root : node, optional": "Specify starting node for basis."
            },
            "Returns:": {
                "A list of cycle lists.  Each cycle list is a list of nodes": "",
                "which forms a cycle (loop) in G.": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This is adapted from algorithm CACM 491 [1] .",
            "References": "[1]Paton, K. An algorithm for finding a fundamental set of\ncycles of a graph. Comm. ACM 12, 9 (Sept 1969), 514-518.",
            "Examples": "G=nx.Graph()\nnx.add_cycle(G,[0,1,2,3])\nnx.add_cycle(G,[0,3,4,5])\nnx.cycle_basis(G,0)\n# [[3, 4, 5, 0], [1, 2, 3, 0]]"
        }
    },
    {
        "Section ID": "johnson",
        "Description": [
            "Uses Johnson\u2019s Algorithm to compute shortest paths.",
            "Johnson\u2019s Algorithm finds a shortest path between each pair of\nnodes in a weighted graph even if negative weights are present."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number."
            },
            "Returns:": {
                "distance : dictionary": "Dictionary, keyed by source and target, of shortest paths."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Johnson\u2019s algorithm is suitable even for graphs with negative weights. It\nworks by using the Bellman\u2013Ford algorithm to compute a transformation of\nthe input graph that removes all negative weights, allowing Dijkstra\u2019s\nalgorithm to be used on the transformed graph. The time complexity of this algorithm is \\(O(n^2 \\log n + n m)\\) ,\nwhere \\(n\\) is the number of nodes and \\(m\\) the number of edges in the\ngraph. For dense graphs, this may be faster than the Floyd\u2013Warshall\nalgorithm.",
            "Examples": "graph=nx.DiGraph()\ngraph.add_weighted_edges_from(\n[(\"0\",\"3\",3),(\"0\",\"1\",-5),(\"0\",\"2\",2),(\"1\",\"2\",4),(\"2\",\"3\",1)]\n)\npaths=nx.johnson(graph,weight=\"weight\")\npaths[\"0\"][\"2\"]\n# ['0', '1', '2']"
        }
    },
    {
        "Section ID": "second_order_centrality",
        "Description": [
            "Compute the second order centrality for nodes of G.",
            "The second order centrality of a given node is the standard deviation of\nthe return times to that node of a perpetual random walk on G:"
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX connected and undirected graph.",
                "weight : string or None, optional (default=\u201dweight\u201d)": "The name of an edge attribute that holds the numerical value\nused as a weight. If None then each edge has weight 1."
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary keyed by node with second order centrality as the value."
            },
            "Raises:": {
                "NetworkXException": "If the graph G is empty, non connected or has negative weights."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Lower values of second order centrality indicate higher centrality. The algorithm is from Kermarrec, Le Merrer, Sericola and Tr\u00e9dan [1] . This code implements the analytical version of the algorithm, i.e.,\nthere is no simulation of a random walk process involved. The random walk\nis here unbiased (corresponding to eq 6 of the paper [1] ), thus the\ncentrality values are the standard deviations for random walk return times\non the transformed input graph G (equal in-degree at each nodes by adding\nself-loops). Complexity of this implementation, made to run locally on a single machine,\nis O(n^3), with n the size of G, which makes it viable only for small\ngraphs.",
            "References": "[1](1,2)Anne-Marie Kermarrec, Erwan Le Merrer, Bruno Sericola, Gilles Tr\u00e9dan\n\u201cSecond order centrality: Distributed assessment of nodes criticity in\ncomplex networks\u201d, Elsevier Computer Communications 34(5):619-628, 2011.",
            "Examples": "G=nx.star_graph(10)\nsoc=nx.second_order_centrality(G)\nprint(sorted(soc.items(),key=lambdax:x[1])[0][0])# pick first id\n# 0"
        }
    },
    {
        "Section ID": "is_attracting_component",
        "Description": [
            "Returns True if G consists of a single attracting component."
        ],
        "Field List": {
            "Parameters:": {
                "G : DiGraph, MultiDiGraph": "The graph to be analyzed."
            },
            "Returns:": {
                "attracting : bool": "True ifGhas a single attracting component. Otherwise, False."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the input graph is undirected."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "partial_duplication_graph",
        "Description": [
            "Returns a random graph using the partial duplication model."
        ],
        "Field List": {
            "Parameters:": {
                "N : int": "The total number of nodes in the final graph.",
                "n : int": "The number of nodes in the initial clique.",
                "p : float": "The probability of joining each neighbor of a node to the\nduplicate node. Must be a number in the between zero and one,\ninclusive.",
                "q : float": "The probability of joining the source node to the duplicate\nnode. Must be a number in the between zero and one, inclusive.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "A graph of nodes is grown by creating a fully connected graph\nof size n . The following procedure is then repeated until\na total of N nodes have been reached.",
            "References": "[1]Knudsen Michael, and Carsten Wiuf. \u201cA Markov chain approach to\nrandomly grown graphs.\u201d Journal of Applied Mathematics 2008.\n<https://doi.org/10.1155/2008/190836>"
        }
    },
    {
        "Section ID": "simrank_similarity",
        "Description": [
            "Returns the SimRank similarity of nodes in the graph G .",
            "SimRank is a similarity metric that says \u201ctwo objects are considered\nto be similar if they are referenced by similar objects.\u201d [1] .",
            "The pseudo-code definition from the paper is:",
            "where G is the graph, u is the source, v is the target,\nand C is a float decay or importance factor between 0 and 1.",
            "The SimRank algorithm for determining node similarity is defined in [2] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A NetworkX graph",
                "source : node": "If this is specified, the returned dictionary maps each nodevin the graph to the similarity betweensourceandv.",
                "target : node": "If bothsourceandtargetare specified, the similarity\nvalue betweensourceandtargetis returned. Iftargetis specified butsourceis not, this argument is\nignored.",
                "importance_factor : float": "The relative importance of indirect neighbors with respect to\ndirect neighbors.",
                "max_iterations : integer": "Maximum number of iterations.",
                "tolerance : float": "Error tolerance used to check convergence. When an iteration of\nthe algorithm finds that no similarity value changes more than\nthis amount, the algorithm halts."
            },
            "Returns:": {
                "similarity : dictionary or float": "Ifsourceandtargetare bothNone, this returns a\ndictionary of dictionaries, where keys are node pairs and value\nare similarity of the pair of nodes.Ifsourceis notNonebuttargetis, this returns a\ndictionary mapping node to the similarity ofsourceand that\nnode.If neithersourcenortargetisNone, this returns\nthe similarity value for the given pair of nodes."
            },
            "Raises:": {
                "ExceededMaxIterations": "If the algorithm does not converge withinmax_iterations.",
                "NodeNotFound": "If eithersourceortargetis not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://en.wikipedia.org/wiki/SimRank  [2]G. Jeh and J. Widom.\n\u201cSimRank: a measure of structural-context similarity\u201d,\nIn KDD\u201902: Proceedings of the Eighth ACM SIGKDD\nInternational Conference on Knowledge Discovery and Data Mining,\npp. 538\u2013543. ACM Press, 2002.",
            "Examples": "G=nx.cycle_graph(2)\nnx.simrank_similarity(G)\n# {0: {0: 1.0, 1: 0.0}, 1: {0: 0.0, 1: 1.0}}\nnx.simrank_similarity(G,source=0)\n# {0: 1.0, 1: 0.0}\nnx.simrank_similarity(G,source=0,target=0)\n# 1.0\nThe result of this function can be converted to a numpy array\nrepresenting the SimRank matrix by using the node order of the\ngraph to determine which row and column represent each node.\nOther ordering of nodes is also possible.\nimportnumpyasnp\nsim=nx.simrank_similarity(G)\nnp.array([[sim[u][v]forvinG]foruinG])\n# array([[1., 0.],\n#        [0., 1.]])\nsim_1d=nx.simrank_similarity(G,source=0)\nnp.array([sim[0][v]forvinG])\n# array([1., 0.])"
        }
    },
    {
        "Section ID": "node_link_graph",
        "Description": [
            "Returns graph from node-link data format.\nUseful for de-serialization from JSON."
        ],
        "Field List": {
            "Parameters:": {
                "data : dict": "node-link formatted graph data",
                "directed : bool": "If True, and direction not specified in data, return a directed graph.",
                "multigraph : bool": "If True, and multigraph not specified in data, return a multigraph.",
                "source : string": "A string that provides the \u2018source\u2019 attribute name for storing NetworkX-internal graph data.",
                "target : string": "A string that provides the \u2018target\u2019 attribute name for storing NetworkX-internal graph data.",
                "name : string": "A string that provides the \u2018name\u2019 attribute name for storing NetworkX-internal graph data.",
                "key : string": "A string that provides the \u2018key\u2019 attribute name for storing NetworkX-internal graph data.",
                "link : string": "A string that provides the \u2018link\u2019 attribute name for storing NetworkX-internal graph data."
            },
            "Returns:": {
                "G : NetworkX graph": "A NetworkX graph object"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Attribute \u2018key\u2019 is only used for multigraphs. To use node_link_data in conjunction with node_link_graph ,\nthe keyword names for the attributes must match.",
            "Examples": "Create data in node-link format by converting a graph.\nG=nx.Graph([(\"A\",\"B\")])\ndata=nx.node_link_data(G)\ndata\n# {'directed': False, 'multigraph': False, 'graph': {}, 'nodes': [{'id': 'A'}, {'id': 'B'}], 'links': [{'source': 'A', 'target': 'B'}]}\nRevert data in node-link format to a graph.\nH=nx.node_link_graph(data)\nprint(H.edges)\n# [('A', 'B')]\nTo serialize and deserialize a graph with JSON,\nimportjson\nd=json.dumps(node_link_data(G))\nH=node_link_graph(json.loads(d))\nprint(G.edges,H.edges)\n# [('A', 'B')] [('A', 'B')]"
        }
    },
    {
        "Section ID": "k_edge_components",
        "Description": [
            "Generates nodes in each maximal k-edge-connected component in G."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "k : Integer": "Desired edge connectivity"
            },
            "Returns:": {
                "k_edge_components : a generator of k-edge-ccs. Each set of returned nodes": "will have k-edge-connectivity in the graph G."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the input graph is a multigraph.",
                "ValueError:": "If k is less than 1"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Attempts to use the most efficient implementation available based on k.\nIf k=1, this is simply connected components for directed graphs and\nconnected components for undirected graphs.\nIf k=2 on an efficient bridge connected component algorithm from _[1] is\nrun based on the chain decomposition.\nOtherwise, the algorithm from _[2] is used.",
            "References": "[1]https://en.wikipedia.org/wiki/Bridge_%28graph_theory%29  [2]Wang, Tianhao, et al. (2015) A simple algorithm for finding all\nk-edge-connected components.http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0136264",
            "Examples": "importitertoolsasit\nfromnetworkx.utilsimportpairwise\npaths=[\n(1,2,4,3,1,4),\n(5,6,7,8,5,7,8,6),\n]\nG=nx.Graph()\nG.add_nodes_from(it.chain(*paths))\nG.add_edges_from(it.chain(*[pairwise(path)forpathinpaths]))\n# note this returns {1, 4} unlike k_edge_subgraphs\nsorted(map(sorted,nx.k_edge_components(G,k=3)))\n# [[1, 4], [2], [3], [5, 6, 7, 8]]"
        }
    },
    {
        "Section ID": "laplacian_matrix",
        "Description": [
            "Returns the Laplacian matrix of G.",
            "The graph Laplacian is the matrix L = D - A, where\nA is the adjacency matrix and D is the diagonal matrix of node degrees."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "nodelist : list, optional": "The rows and columns are ordered according to the nodes in nodelist.\nIf nodelist is None, then the ordering is produced by G.nodes().",
                "weight : string or None, optional (default=\u2019weight\u2019)": "The edge data key used to compute each value in the matrix.\nIf None, then each edge has weight 1."
            },
            "Returns:": {
                "L : SciPy sparse array": "The Laplacian matrix of G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For MultiGraph, the edges weights are summed. This returns an unnormalized matrix. For a normalized output,\nuse normalized_laplacian_matrix , directed_laplacian_matrix ,\nor directed_combinatorial_laplacian_matrix . This calculation uses the out-degree of the graph G . To use the\nin-degree for calculations instead, use G.reverse(copy=False) and\ntake the transpose.",
            "References": "[1]Langville, Amy N., and Carl D. Meyer. Google\u2019s PageRank and Beyond:\nThe Science of Search Engine Rankings. Princeton University Press, 2006.",
            "Examples": "For graphs with multiple connected components, L is permutation-similar\nto a block diagonal matrix where each block is the respective Laplacian\nmatrix for each component.\nG=nx.Graph([(1,2),(2,3),(4,5)])\nprint(nx.laplacian_matrix(G).toarray())\n# [[ 1 -1  0  0  0]\n#  [-1  2 -1  0  0]\n#  [ 0 -1  1  0  0]\n#  [ 0  0  0  1 -1]\n#  [ 0  0  0 -1  1]]\nedges=[\n(1,2),\n(2,1),\n(2,4),\n(4,3),\n(3,4),\n]\nDiG=nx.DiGraph(edges)\nprint(nx.laplacian_matrix(DiG).toarray())\n# [[ 1 -1  0  0]\n#  [-1  2 -1  0]\n#  [ 0  0  1 -1]\n#  [ 0  0 -1  1]]\nNotice that node 4 is represented by the third column and row. This is because\nby default the row/column order is the order ofG.nodes(i.e. the node added\norder \u2013 in the edgelist, 4 first appears in (2, 4), before node 3 in edge (4, 3).)\nTo control the node order of the matrix, use thenodelistargument.\nprint(nx.laplacian_matrix(DiG,nodelist=[1,2,3,4]).toarray())\n# [[ 1 -1  0  0]\n#  [-1  2  0 -1]\n#  [ 0  0  1 -1]\n#  [ 0  0 -1  1]]\nThis calculation uses the out-degree of the graphG. To use the\nin-degree for calculations instead, useG.reverse(copy=False)and\ntake the transpose.\nprint(nx.laplacian_matrix(DiG.reverse(copy=False)).toarray().T)\n# [[ 1 -1  0  0]\n#  [-1  1 -1  0]\n#  [ 0  0  2 -1]\n#  [ 0  0 -1  1]]"
        }
    },
    {
        "Section ID": "flow_hierarchy",
        "Description": [
            "Returns the flow hierarchy of a directed network.",
            "Flow hierarchy is defined as the fraction of edges not participating\nin cycles in a directed graph [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : DiGraph or MultiDiGraph": "A directed graph",
                "weight : string, optional (default=None)": "Attribute to use for edge weights. If None the weight defaults to 1."
            },
            "Returns:": {
                "h : float": "Flow hierarchy value"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The algorithm described in [1] computes the flow hierarchy through\nexponentiation of the adjacency matrix.  This function implements an\nalternative approach that finds strongly connected components.\nAn edge is in a cycle if and only if it is in a strongly connected\ncomponent, which can be found in \\(O(m)\\) time using Tarjan\u2019s algorithm.",
            "References": "[1](1,2)Luo, J.; Magee, C.L. (2011),\nDetecting evolving patterns of self-organizing networks by flow\nhierarchy measurement, Complexity, Volume 16 Issue 6 53-61.\nDOI: 10.1002/cplx.20368http://web.mit.edu/~cmagee/www/documents/28-DetectingEvolvingPatterns_FlowHierarchy.pdf"
        }
    },
    {
        "Section ID": "edge_current_flow_betweenness_centrality_subset",
        "Description": [
            "Compute current-flow betweenness centrality for edges using subsets\nof nodes.",
            "Current-flow betweenness centrality uses an electrical current\nmodel for information spreading in contrast to betweenness\ncentrality which uses shortest paths.",
            "Current-flow betweenness centrality is also known as\nrandom-walk betweenness centrality [2] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "sources: list of nodes": "Nodes to use as sources for current",
                "targets: list of nodes": "Nodes to use as sinks for current",
                "normalized : bool, optional (default=True)": "If True the betweenness values are normalized by b=b/(n-1)(n-2) where\nn is the number of nodes in G.",
                "weight : string or None, optional (default=None)": "Key for edge data used as the edge weight.\nIf None, then use 1 as each edge weight.\nThe weight reflects the capacity or the strength of the\nedge.",
                "dtype: data type (float)": "Default data type for internal matrices.\nSet to np.float32 for lower memory consumption.",
                "solver: string (default=\u2019lu\u2019)": "Type of linear solver to use for computing the flow matrix.\nOptions are \u201cfull\u201d (uses most memory), \u201clu\u201d (recommended), and\n\u201ccg\u201d (uses least memory)."
            },
            "Returns:": {
                "nodes : dict": "Dictionary of edge tuples with betweenness centrality as the value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Current-flow betweenness can be computed in \\(O(I(n-1)+mn \\log n)\\) time [1] , where \\(I(n-1)\\) is the time needed to compute the\ninverse Laplacian.  For a full matrix this is \\(O(n^3)\\) but using\nsparse methods you can achieve \\(O(nm{\\sqrt k})\\) where \\(k\\) is the\nLaplacian matrix condition number. The space required is \\(O(nw)\\) where \\(w\\) is the width of the sparse\nLaplacian matrix.  Worse case is \\(w=n\\) for \\(O(n^2)\\) . If the edges have a \u2018weight\u2019 attribute they will be used as\nweights in this algorithm.  Unspecified weights are set to 1.",
            "References": "[1]Centrality Measures Based on Current Flow.\nUlrik Brandes and Daniel Fleischer,\nProc. 22nd Symp. Theoretical Aspects of Computer Science (STACS \u201805).\nLNCS 3404, pp. 533-544. Springer-Verlag, 2005.https://doi.org/10.1007/978-3-540-31856-9_44  [2]A measure of betweenness centrality based on random walks,\nM. E. J. Newman, Social Networks 27, 39-54 (2005)."
        }
    },
    {
        "Section ID": "max_weight_clique",
        "Description": [
            "Find a maximum weight clique in G.",
            "A clique in a graph is a set of nodes such that every two distinct nodes\nare adjacent.  The weight of a clique is the sum of the weights of its\nnodes.  A maximum weight clique of graph G is a clique C in G such that\nno clique in G has weight greater than the weight of C."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected graph",
                "weight : string or None, optional (default=\u2019weight\u2019)": "The node attribute that holds the integer value used as a weight.\nIf None, then each node has weight 1."
            },
            "Returns:": {
                "clique : list": "the nodes of a maximum weight clique",
                "weight : int": "the weight of a maximum weight clique"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The implementation is recursive, and therefore it may run into recursion\ndepth issues if G contains a clique whose number of nodes is close to the\nrecursion depth limit. At each search node, the algorithm greedily constructs a weighted\nindependent set cover of part of the graph in order to find a small set of\nnodes on which to branch.  The algorithm is very similar to the algorithm\nof Tavares et al. [1] , other than the fact that the NetworkX version does\nnot use bitsets.  This style of algorithm for maximum weight clique (and\nmaximum weight independent set, which is the same problem but on the\ncomplement graph) has a decades-long history.  See Algorithm B of Warren\nand Hicks [2] and the references in that paper.",
            "References": "[1]Tavares, W.A., Neto, M.B.C., Rodrigues, C.D., Michelon, P.: Um\nalgoritmo de branch and bound para o problema da clique m\u00e1xima\nponderada.  Proceedings of XLVII SBPO 1 (2015).  [2]Warren, Jeffrey S, Hicks, Illya V.: Combinatorial Branch-and-Bound\nfor the Maximum Weight Independent Set Problem.  Technical Report,\nTexas A&M University (2016)."
        }
    },
    {
        "Section ID": "cycle_graph",
        "Description": [
            "Returns the cycle graph \\(C_n\\) of cyclically connected nodes.",
            "\\(C_n\\) is a path with its two end-nodes connected.",
            "( Sourcecode , png )"
        ],
        "Field List": {
            "Parameters:": {
                "n : int or iterable container of nodes": "If n is an integer, nodes are fromrange(n).\nIf n is a container of nodes, those nodes appear in the graph.\nWarning: n is not checked for duplicates and if present the\nresulting graph may not be as desired. Make sure you have no duplicates.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "If create_using is directed, the direction is in increasing order."
        }
    },
    {
        "Section ID": "stoer_wagner",
        "Description": [
            "Returns the weighted minimum edge cut using the Stoer-Wagner algorithm.",
            "Determine the minimum edge cut of a connected graph using the\nStoer-Wagner algorithm. In weighted cases, all weights must be\nnonnegative.",
            "The running time of the algorithm depends on the type of heaps used:"
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Edges of the graph are expected to have an attribute named by the\nweight parameter below. If this attribute is not present, the edge is\nconsidered to have unit weight.",
                "weight : string": "Name of the weight attribute of the edges. If the attribute is not\npresent, unit weight is assumed. Default value: \u2018weight\u2019.",
                "heap : class": "Type of heap to be used in the algorithm. It should be a subclass ofMinHeapor implement a compatible interface.If a stock heap implementation is to be used,BinaryHeapis\nrecommended overPairingHeapfor Python implementations without\noptimized attribute accesses (e.g., CPython) despite a slower\nasymptotic running time. For Python implementations with optimized\nattribute accesses (e.g., PyPy),PairingHeapprovides better\nperformance. Default value:BinaryHeap."
            },
            "Returns:": {
                "cut_value : integer or float": "The sum of weights of edges in a minimum cut.",
                "partition : pair of node lists": "A partitioning of the nodes that defines a minimum cut."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the graph is directed or a multigraph.",
                "NetworkXError": "If the graph has less than two nodes, is not connected or has a\nnegative-weighted edge."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph()\nG.add_edge(\"x\",\"a\",weight=3)\nG.add_edge(\"x\",\"b\",weight=1)\nG.add_edge(\"a\",\"c\",weight=3)\nG.add_edge(\"b\",\"c\",weight=5)\nG.add_edge(\"b\",\"d\",weight=4)\nG.add_edge(\"d\",\"e\",weight=2)\nG.add_edge(\"c\",\"y\",weight=2)\nG.add_edge(\"e\",\"y\",weight=3)\ncut_value,partition=nx.stoer_wagner(G)\ncut_value\n# 4"
        }
    },
    {
        "Section ID": "from_pandas_adjacency",
        "Description": [
            "Returns a graph from Pandas DataFrame.",
            "The Pandas DataFrame is interpreted as an adjacency matrix for the graph."
        ],
        "Field List": {
            "Parameters:": {
                "df : Pandas DataFrame": "An adjacency matrix representation of a graph",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For directed graphs, explicitly mention create_using=nx.DiGraph,\nand entry i,j of df corresponds to an edge from i to j. If df has a single data type for each entry it will be converted to an\nappropriate Python data type. If you have node attributes stored in a separate dataframe df_nodes ,\nyou can load those attributes to the graph G using the following code: `df_nodes=pd.DataFrame({\"node_id\":[1,2,3],\"attribute1\":[\"A\",\"B\",\"C\"]})G.add_nodes_from((n,dict(d))forn,dindf_nodes.iterrows())` If df has a user-specified compound data type the names\nof the data fields will be used as attribute keys in the resulting\nNetworkX graph.",
            "Examples": "Simple integer weights on edges:\nimportpandasaspd\npd.options.display.max_columns=20\ndf=pd.DataFrame([[1,1],[2,1]])\ndf\n#    0  1\n# 0  1  1\n# 1  2  1\nG=nx.from_pandas_adjacency(df)\nG.name=\"Graph from pandas adjacency matrix\"\nprint(G)\n# Graph named 'Graph from pandas adjacency matrix' with 2 nodes and 3 edges"
        }
    },
    {
        "Section ID": "spectral_ordering",
        "Description": [
            "Compute the spectral_ordering of a graph.",
            "The spectral ordering of a graph is an ordering of its nodes where nodes\nin the same weakly connected components appear contiguous and ordered by\ntheir corresponding elements in the Fiedler vector of the component."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A graph.",
                "weight : object, optional (default: None)": "The data key used to determine the weight of each edge. If None, then\neach edge has unit weight.",
                "normalized : bool, optional (default: False)": "Whether the normalized Laplacian matrix is used.",
                "tol : float, optional (default: 1e-8)": "Tolerance of relative residual in eigenvalue computation.",
                "method : string, optional (default: \u2018tracemin_pcg\u2019)": "Method of eigenvalue computation. It must be one of the tracemin\noptions shown below (TraceMIN), \u2018lanczos\u2019 (Lanczos iteration)\nor \u2018lobpcg\u2019 (LOBPCG).The TraceMIN algorithm uses a linear system solver. The following\nvalues allow specifying the solver to be used.ValueSolver\u2018tracemin_pcg\u2019Preconditioned conjugate gradient method\u2018tracemin_lu\u2019LU factorization",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "spectral_ordering : NumPy array of floats.": "Spectral ordering of nodes."
            },
            "Raises:": {
                "NetworkXError": "If G is empty."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weights are interpreted by their absolute values. For MultiGraph\u2019s,\nweights of parallel edges are summed. Zero-weighted edges are ignored."
        }
    },
    {
        "Section ID": "numeric_assortativity_coefficient",
        "Description": [
            "Compute assortativity for numerical node attributes.",
            "Assortativity measures the similarity of connections\nin the graph with respect to the given numeric attribute."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "attribute : string": "Node attribute key.",
                "nodes: list or iterable (optional)": "Compute numeric assortativity only for attributes of nodes in\ncontainer. The default is all nodes."
            },
            "Returns:": {
                "r: float": "Assortativity of graph for given attribute"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This computes Eq. (21) in Ref. [1] , which is the Pearson correlation\ncoefficient of the specified (scalar valued) attribute across edges.",
            "References": "[1]M. E. J. Newman, Mixing patterns in networks\nPhysical Review E, 67 026126, 2003",
            "Examples": "G=nx.Graph()\nG.add_nodes_from([0,1],size=2)\nG.add_nodes_from([2,3],size=3)\nG.add_edges_from([(0,1),(2,3)])\nprint(nx.numeric_assortativity_coefficient(G,\"size\"))\n# 1.0"
        }
    },
    {
        "Section ID": "degrees",
        "Description": [
            "Returns the degrees of the two node sets in the bipartite graph B."
        ],
        "Field List": {
            "Parameters:": {
                "B : NetworkX graph": "",
                "nodes: list or container": "Nodes in one node set of the bipartite graph.",
                "weight : string or None, optional (default=None)": "The edge attribute that holds the numerical value used as a weight.\nIf None, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node."
            },
            "Returns:": {
                "(degX,degY) : tuple of dictionaries": "The degrees of the two bipartite sets as dictionaries keyed by node."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The container of nodes passed as argument must contain all nodes\nin one of the two bipartite node sets to avoid ambiguity in the\ncase of disconnected graphs.\nSee bipartitedocumentation for further details on how bipartite graphs are handled in NetworkX.",
            "Examples": "fromnetworkx.algorithmsimportbipartite\nG=nx.complete_bipartite_graph(3,2)\nY=set([3,4])\ndegX,degY=bipartite.degrees(G,Y)\ndict(degX)\n# {0: 2, 1: 2, 2: 2}"
        }
    },
    {
        "Section ID": "treewidth_min_degree",
        "Description": [
            "Returns a treewidth decomposition using the Minimum Degree heuristic.",
            "The heuristic chooses the nodes according to their degree, i.e., first\nthe node with the lowest degree is chosen, then the graph is updated\nand the corresponding node is removed. Next, a new node with the lowest\ndegree is chosen, and so on."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": ""
            },
            "Returns:": {
                "Treewidth decomposition : (int, Graph) tuple": "2-tuple with treewidth and the corresponding decomposed tree."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "argmap",
        "Description": [
            "A decorator to apply a map to arguments before calling the function",
            "This class provides a decorator that maps (transforms) arguments of the function\nbefore the function is called. Thus for example, we have similar code\nin many functions to determine whether an argument is the number of nodes\nto be created, or a list of nodes to be handled. The decorator provides\nthe code to accept either \u2013 transforming the indicated argument into a\nlist of nodes before the actual function is called.",
            "This decorator class allows us to process single or multiple arguments.\nThe arguments to be processed can be specified by string, naming the argument,\nor by index, specifying the item in the args list."
        ],
        "Field List": {
            "Parameters:": {
                "func : callable": "The function to apply to arguments",
                "*args : iterable of (int, str or tuple)": "A list of parameters, specified either as strings (their names), ints\n(numerical indices) or tuples, which may contain ints, strings, and\n(recursively) tuples. Each indicates which parameters the decorator\nshould map. Tuples indicate that the map function takes (and returns)\nmultiple parameters in the same order and nested structure as indicated\nhere.",
                "try_finally : bool (default: False)": "When True, wrap the function call in a try-finally block with code\nfor the finally block created byfunc. This is used when the map\nfunction constructs an object (like a file handle) that requires\npost-processing (like closing).Note: try_finally decorators cannot be used to decorate generator\nfunctions."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "An object of this class is callable and intended to be used when\ndefining a decorator. Generally, a decorator takes a function as input\nand constructs a function as output. Specifically, an argmap object\nreturns the input function decorated/wrapped so that specified arguments\nare mapped (transformed) to new values before the decorated function is called. As an overview, the argmap object returns a new function with all the\ndunder values of the original function (like __doc__ , __name__ , etc).\nCode for this decorated function is built based on the original function\u2019s\nsignature. It starts by mapping the input arguments to potentially new\nvalues. Then it calls the decorated function with these new values in place\nof the indicated arguments that have been mapped. The return value of the\noriginal function is then returned. This new function is the function that\nis actually called by the user.",
            "Examples": "Most of these examples use@argmap(...)to apply the decorator to\nthe function defined on the next line.\nIn the NetworkX codebase however,argmapis used within a function to\nconstruct a decorator. That is, the decorator defines a mapping function\nand then usesargmapto build and return a decorated function.\nA simple example is a decorator that specifies which currency to report money.\nThe decorator (namedconvert_to) would be used like:\n@convert_to(\"US_Dollars\",\"income\")defshow_me_the_money(name,income):print(f\"{name} : {income}\")\nAnd the code to create the decorator might be:\ndefconvert_to(currency,which_arg):def_convert(amount):ifamount.currency!=currency:amount=amount.to_currency(currency)returnamountreturnargmap(_convert,which_arg)\nDespite this common idiom for argmap, most of the following examples\nuse the@argmap(...)idiom to save space.\nHere\u2019s an example use of argmap to sum the elements of two of the functions\narguments. The decorated function:\n@argmap(sum,\"xlist\",\"zlist\")deffoo(xlist,y,zlist):returnxlist-y+zlist\nis syntactic sugar for:\ndeffoo(xlist,y,zlist):x=sum(xlist)z=sum(zlist)returnx-y+z\nand is equivalent to (using argument indexes):\n@argmap(sum,\"xlist\",2)deffoo(xlist,y,zlist):returnxlist-y+zlist\nor:\n@argmap(sum,\"zlist\",0)deffoo(xlist,y,zlist):returnxlist-y+zlist\nTransforming functions can be applied to multiple arguments, such as:\ndefswap(x,y):returny,x# the 2-tuple tells argmap that the map `swap` has 2 inputs/outputs.@argmap(swap,(\"a\",\"b\")):deffoo(a,b,c):returna/b*c\nis equivalent to:\ndeffoo(a,b,c):a,b=swap(a,b)returna/b*c\nMore generally, the applied arguments can be nested tuples of strings or ints.\nThe syntax@argmap(some_func,(\"a\",(\"b\",\"c\")))would expectsome_functo\naccept 2 inputs with the second expected to be a 2-tuple. It should then return\n2 outputs with the second a 2-tuple. The returns values would replace input \u201ca\u201d\n\u201cb\u201d and \u201cc\u201d respectively. Similarly for@argmap(some_func,(0,(\"b\",2))).\nAlso, note that an index larger than the number of named parameters is allowed\nfor variadic functions. For example:\ndefdouble(a):return2*a@argmap(double,3)defoverflow(a,*args):returna,argsprint(overflow(1,2,3,4,5,6))# output is 1, (2, 3, 8, 5, 6)\nTry Finally\nAdditionally, thisargmapclass can be used to create a decorator that\ninitiates a try\u2026finally block. The decorator must be written to return\nboth the transformed argument and a closing function.\nThis feature was included to enable theopen_filedecorator which might\nneed to close the file or not depending on whether it had to open that file.\nThis feature uses the keyword-onlytry_finallyargument to@argmap.\nFor example this map opens a file and then makes sure it is closed:\ndefopen_file(fn):f=open(fn)returnf,lambda:f.close()\nThe decorator applies that to the functionfoo:\n@argmap(open_file,\"file\",try_finally=True)deffoo(file):print(file.read())\nis syntactic sugar for:\ndeffoo(file):file,close_file=open_file(file)try:print(file.read())finally:close_file()\nand is equivalent to (using indexes):\n@argmap(open_file,0,try_finally=True)deffoo(file):print(file.read())\nHere\u2019s an example of the try_finally feature used to create a decorator:\ndefmy_closing_decorator(which_arg):def_opener(path):ifpathisNone:path=open(path)fclose=path.closeelse:# assume `path` handles the closingfclose=lambda:Nonereturnpath,fclosereturnargmap(_opener,which_arg,try_finally=True)\nwhich can then be used as:\n@my_closing_decorator(\"file\")deffancy_reader(file=None):# this code doesn't need to worry about closing the fileprint(file.read())\nDecorators with try_finally = True cannot be used with generator functions,\nbecause thefinallyblock is evaluated before the generator is exhausted:\n@argmap(open_file,\"file\",try_finally=True)deffile_to_lines(file):forlineinfile.readlines():yieldline\nis equivalent to:\ndeffile_to_lines_wrapped(file):forlineinfile.readlines():yieldlinedeffile_to_lines_wrapper(file):try:file=open_file(file)returnfile_to_lines_wrapped(file)finally:file.close()\nwhich behaves similarly to:\ndeffile_to_lines_whoops(file):file=open_file(file)file.close()forlineinfile.readlines():yieldline\nbecause thefinallyblock offile_to_lines_wrapperis executed before\nthe caller has a chance to exhaust the iterator."
        }
    },
    {
        "Section ID": "reverse_cuthill_mckee_ordering",
        "Description": [
            "Generate an ordering (permutation) of the graph nodes to make\na sparse matrix.",
            "Uses the reverse Cuthill-McKee heuristic (based on breadth-first search) [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "heuristic : function, optional": "Function to choose starting node for RCM algorithm.  If None\na node from a pseudo-peripheral pair is used.  A user-defined function\ncan be supplied that takes a graph object and returns a single node."
            },
            "Returns:": {
                "nodes : generator": "Generator of nodes in reverse Cuthill-McKee ordering."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The optimal solution the bandwidth reduction is NP-complete [2] .",
            "References": "[1]E. Cuthill and J. McKee.\nReducing the bandwidth of sparse symmetric matrices,\nIn Proc. 24th Nat. Conf. ACM, pages 157-72, 1969.http://doi.acm.org/10.1145/800195.805928  [2]Steven S. Skiena. 1997. The Algorithm Design Manual.\nSpringer-Verlag New York, Inc., New York, NY, USA.",
            "Examples": "fromnetworkx.utilsimportreverse_cuthill_mckee_ordering\nG=nx.path_graph(4)\nrcm=list(reverse_cuthill_mckee_ordering(G))\nA=nx.adjacency_matrix(G,nodelist=rcm)\nSmallest degree node as heuristic function:\ndefsmallest_degree(G):\nreturnmin(G,key=G.degree)\nrcm=list(reverse_cuthill_mckee_ordering(G,heuristic=smallest_degree))"
        }
    },
    {
        "Section ID": "maximal_extendability",
        "Description": [
            "Computes the extendability of a graph.",
            "The extendability of a graph is defined as the maximum \\(k\\) for which G is \\(k\\) -extendable. Graph G is \\(k\\) -extendable if and only if G has a\nperfect matching and every set of \\(k\\) independent edges can be extended\nto a perfect matching in G ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "A fully-connected bipartite graph without self-loops"
            },
            "Returns:": {
                "extendability : int": ""
            },
            "Raises:": {
                "NetworkXError": "If the graphGis disconnected.\nIf the graphGis not bipartite.\nIf the graphGdoes not contain a perfect matching.\nIf the residual graph ofGis not strongly connected."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Definition:\nLet G be a simple, connected, undirected and bipartite graph with a perfect\nmatching M and bipartition (U,V). The residual graph of G , denoted by \\(G_M\\) ,\nis the graph obtained from G by directing the edges of M from V to U and the\nedges that do not belong to M from U to V. Lemma [1] :\nLet M be a perfect matching of G . G is \\(k\\) -extendable if and only if its residual\ngraph \\(G_M\\) is strongly connected and there are \\(k\\) vertex-disjoint directed\npaths between every vertex of U and every vertex of V. Assuming that input graph G is undirected, simple, connected, bipartite and contains\na perfect matching M, this function constructs the residual graph \\(G_M\\) of G and\nreturns the minimum value among the maximum vertex-disjoint directed paths between\nevery vertex of U and every vertex of V in \\(G_M\\) . By combining the definitions\nand the lemma, this value represents the extendability of the graph G . Time complexity O( \\(n^3\\)  \\(m^2\\) )) where \\(n\\) is the number of vertices\nand \\(m\\) is the number of edges.",
            "References": "[1]\u201cA polynomial algorithm for the extendability problem in bipartite graphs\u201d,\nJ. Lakhal, L. Litzler, Information Processing Letters, 1998.  [2]\u201cOn n-extendible graphs\u201d, M. D. Plummer, Discrete Mathematics, 31:201\u2013210, 1980https://doi.org/10.1016/0012-365X(80)90037-0"
        }
    },
    {
        "Section ID": "dfs_predecessors",
        "Description": [
            "Returns dictionary of predecessors in depth-first-search from source."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node, optional": "Specify starting node for depth-first search.\nNote that you will get predecessors for all nodes in the\ncomponent containingsource. This input only specifies\nwhere the DFS starts.",
                "depth_limit : int, optional (default=len(G))": "Specify the maximum search depth.",
                "sort_neighbors : function (default=None)": "A function that takes an iterator over nodes as the input, and\nreturns an iterable of the same nodes with a custom ordering.\nFor example,sortedwill sort the nodes in increasing order."
            },
            "Returns:": {
                "pred: dict": "A dictionary with nodes as keys and predecessor nodes as values."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "If a source is not specified then a source is chosen arbitrarily and\nrepeatedly until all components in the graph are searched. The implementation of this function is adapted from David Eppstein\u2019s\ndepth-first search function in PADS , with modifications\nto allow depth limits based on the Wikipedia article\n\u201c Depth-limited search \u201d.",
            "Examples": "G=nx.path_graph(4)\nnx.dfs_predecessors(G,source=0)\n# {1: 0, 2: 1, 3: 2}\nnx.dfs_predecessors(G,source=0,depth_limit=2)\n# {1: 0, 2: 1}"
        }
    },
    {
        "Section ID": "number_of_walks",
        "Description": [
            "Returns the number of walks connecting each pair of nodes in G",
            "A walk is a sequence of nodes in which each adjacent pair of nodes\nin the sequence is adjacent in the graph. A walk can repeat the same\nedge and go in the opposite direction just as people can walk on a\nset of paths, but standing still is not counted as part of the walk.",
            "This function only counts the walks with walk_length edges. Note that\nthe number of nodes in the walk sequence is one more than walk_length .\nThe number of walks can grow very quickly on a larger graph\nand with a larger walk length."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "walk_length : int": "A nonnegative integer representing the length of a walk."
            },
            "Returns:": {
                "dict": "A dictionary of dictionaries in which outer keys are source\nnodes, inner keys are target nodes, and inner values are the\nnumber of walks of lengthwalk_lengthconnecting those nodes."
            },
            "Raises:": {
                "ValueError": "Ifwalk_lengthis negative"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph([(0,1),(1,2)])\nwalks=nx.number_of_walks(G,2)\nwalks\n# {0: {0: 1, 1: 0, 2: 1}, 1: {0: 0, 1: 2, 2: 0}, 2: {0: 1, 1: 0, 2: 1}}\ntotal_walks=sum(sum(tgts.values())for_,tgtsinwalks.items())\nYou can also get the number of walks from a specific source node using the\nreturned dictionary. For example, number of walks of length 1 from node 0\ncan be found as follows:\nwalks=nx.number_of_walks(G,1)\nwalks[0]\n# {0: 0, 1: 1, 2: 0}\nsum(walks[0].values())# walks from 0 of length 1\n# 1\nSimilarly, a target node can also be specified:\nwalks[0][1]\n# 1"
        }
    },
    {
        "Section ID": "to_graph6_bytes",
        "Description": [
            "Convert a simple undirected graph to bytes in graph6 format."
        ],
        "Field List": {
            "Parameters:": {
                "G : Graph (undirected)": "",
                "nodes: list or iterable": "Nodes are labeled 0\u2026n-1 in the order provided.  If None the ordering\ngiven byG.nodes()is used.",
                "header: bool": "If True add \u2018>>graph6<<\u2019 bytes to head of data."
            },
            "Raises:": {
                "NetworkXNotImplemented": "If the graph is directed or is a multigraph.",
                "ValueError": "If the graph has at least2**36nodes; the graph6 format\nis only defined for graphs of order less than2**36."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The returned bytes end with a newline character. The format does not support edge or node labels, parallel edges or\nself loops. If self loops are present they are silently ignored.",
            "References": "[1]Graph6 specification\n<http://users.cecs.anu.edu.au/~bdm/data/formats.html>",
            "Examples": "nx.to_graph6_bytes(nx.path_graph(2))\n# b'>>graph6<<A_\\n'"
        }
    },
    {
        "Section ID": "dual_barabasi_albert_graph",
        "Description": [
            "Returns a random graph using dual Barab\u00e1si\u2013Albert preferential attachment",
            "A graph of \\(n\\) nodes is grown by attaching new nodes each with either \\(m_1\\) edges (with probability \\(p\\) ) or \\(m_2\\) edges (with probability \\(1-p\\) ) that\nare preferentially attached to existing nodes with high degree."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "Number of nodes",
                "m1 : int": "Number of edges to link each new node to existing nodes with probability\\(p\\)",
                "m2 : int": "Number of edges to link each new node to existing nodes with probability\\(1-p\\)",
                "p : float": "The probability of attaching\\(m_1\\)edges (as opposed to\\(m_2\\)edges)",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "initial_graph : Graph or None (default)": "Initial network for Barab\u00e1si\u2013Albert algorithm.\nA copy ofinitial_graphis used.\nIt should be connected for most use cases.\nIf None, starts from an star graph on max(m1, m2) + 1 nodes."
            },
            "Returns:": {
                "G : Graph": ""
            },
            "Raises:": {
                "NetworkXError": "Ifm1andm2do not satisfy1<=m1,m2<n, orpdoes not satisfy0<=p<=1, or\nthe initial graph number of nodes m0 does not satisfy m1, m2 <= m0 <= n."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Moshiri \u201cThe dual-Barabasi-Albert model\u201d, arXiv:1810.10538."
        }
    },
    {
        "Section ID": "margulis_gabber_galil_graph",
        "Description": [
            "Returns the Margulis-Gabber-Galil undirected MultiGraph on n^2 nodes.",
            "The undirected MultiGraph is regular with degree 8 . Nodes are integer\npairs. The second-largest eigenvalue of the adjacency matrix of the graph\nis at most 5sqrt{2} , regardless of n ."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "Determines the number of nodes in the graph:n^2.",
                "create_using : NetworkX graph constructor, optional (default MultiGraph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : graph": "The constructed undirected multigraph."
            },
            "Raises:": {
                "NetworkXError": "If the graph is directed or not a multigraph."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "single_source_shortest_path_length",
        "Description": [
            "Compute the shortest path lengths from source to all reachable nodes."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node": "Starting node for path",
                "cutoff : integer, optional": "Depth to stop the search. Only paths of length <= cutoff are returned."
            },
            "Returns:": {
                "lengths : dict": "Dict keyed by node to shortest path length to source."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.path_graph(5)\nlength=nx.single_source_shortest_path_length(G,0)\nlength[4]\n# 4\nfornodeinlength:\nprint(f\"{node}: {length[node]}\")\n# 0: 0\n# 1: 1\n# 2: 2\n# 3: 3\n# 4: 4"
        }
    },
    {
        "Section ID": "ancestors",
        "Description": [
            "Returns all nodes having a path to source in G ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "",
                "source : node inG": ""
            },
            "Returns:": {
                "set()": "The ancestors ofsourceinG"
            },
            "Raises:": {
                "NetworkXError": "If nodesourceis not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "DG=nx.path_graph(5,create_using=nx.DiGraph)\nsorted(nx.ancestors(DG,2))\n# [0, 1]\nThesourcenode is not an ancestor of itself, but can be included manually:\nsorted(nx.ancestors(DG,2)|{2})\n# [0, 1, 2]"
        }
    },
    {
        "Section ID": "union",
        "Description": [],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "edge_subgraph",
        "Description": [
            "Returns a view of the subgraph induced by the specified edges.",
            "The induced subgraph contains each edge in edges and each\nnode incident to any of those edges."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "",
                "edges : iterable": "An iterable of edges. Edges not present inGare ignored."
            },
            "Returns:": {
                "subgraph : SubGraph View": "A read-only edge-induced subgraph ofG.\nChanges toGare reflected in the view."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "To create a mutable subgraph with its own copies of nodes\nedges and attributes use subgraph.copy() or Graph(subgraph) If you create a subgraph of a subgraph recursively you can end up\nwith a chain of subgraphs that becomes very slow with about 15\nnested subgraph views. Luckily the edge_subgraph filter nests\nnicely so you can use the original graph as G in this function\nto avoid chains. We do not rule out chains programmatically so\nthat odd cases like an edge_subgraph of a restricted_view can be created.",
            "Examples": "G=nx.path_graph(5)\nH=G.edge_subgraph([(0,1),(3,4)])\nlist(H.nodes)\n# [0, 1, 3, 4]\nlist(H.edges)\n# [(0, 1), (3, 4)]"
        }
    },
    {
        "Section ID": "single_target_shortest_path",
        "Description": [
            "Compute shortest path to target from all nodes that reach target."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "target : node label": "Target node for path",
                "cutoff : integer, optional": "Depth to stop the search. Only paths of length <= cutoff are returned."
            },
            "Returns:": {
                "paths : dictionary": "Dictionary, keyed by target, of shortest paths."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The shortest path is not necessarily unique. So there can be multiple\npaths between the source and each target node, all of which have the\nsame \u2018shortest\u2019 length. For each target node, this function returns\nonly one of those paths.",
            "Examples": "G=nx.path_graph(5,create_using=nx.DiGraph())\npath=nx.single_target_shortest_path(G,4)\npath[0]\n# [0, 1, 2, 3, 4]"
        }
    },
    {
        "Section ID": "find_asteroidal_triple",
        "Description": [
            "Find an asteroidal triple in the given graph.",
            "An asteroidal triple is a triple of non-adjacent vertices such that\nthere exists a path between any two of them which avoids the closed\nneighborhood of the third. It checks all independent triples of vertices\nand whether they are an asteroidal triple or not. This is done with the\nhelp of a data structure called a component structure.\nA component structure encodes information about which vertices belongs to\nthe same connected component when the closed neighborhood of a given vertex\nis removed from the graph. The algorithm used to check is the trivial\none, outlined in [1] , which has a runtime of \\(O(|V||\\overline{E} + |V||E|)\\) , where the second term is the\ncreation of the component structure."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "The graph to check whether is AT-free or not"
            },
            "Returns:": {
                "list or None": "An asteroidal triple is returned as a list of nodes. If no asteroidal\ntriple exists, i.e. the graph is AT-free, then None is returned.\nThe returned value depends on the certificate parameter. The default\noption is a bool which is True if the graph is AT-free, i.e. the\ngiven graph contains no asteroidal triples, and False otherwise, i.e.\nif the graph contains at least one asteroidal triple."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The component structure and the algorithm is described in [1] . The current\nimplementation implements the trivial algorithm for simple graphs.",
            "References": "[1](1,2)Ekkehard K\u00f6hler,\n\u201cRecognizing Graphs without asteroidal triples\u201d,\nJournal of Discrete Algorithms 2, pages 439-452, 2004.https://www.sciencedirect.com/science/article/pii/S157086670400019X"
        }
    },
    {
        "Section ID": "color",
        "Description": [
            "Returns a two-coloring of the graph.",
            "Raises an exception if the graph is not bipartite."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": ""
            },
            "Returns:": {
                "color : dictionary": "A dictionary keyed by node with a 1 or 0 as data for each node color."
            },
            "Raises:": {
                "NetworkXError": "If the graph is not two-colorable."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "fromnetworkx.algorithmsimportbipartite\nG=nx.path_graph(4)\nc=bipartite.color(G)\nprint(c)\n# {0: 1, 1: 0, 2: 1, 3: 0}\nYou can use this to set a node attribute indicating the bipartite set:\nnx.set_node_attributes(G,c,\"bipartite\")\nprint(G.nodes[0][\"bipartite\"])\n# 1\nprint(G.nodes[1][\"bipartite\"])\n# 0"
        }
    },
    {
        "Section ID": "single_source_bellman_ford_path_length",
        "Description": [
            "Compute the shortest path length between source and all other\nreachable nodes for a weighted graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node label": "Starting node for path",
                "weight : string or function (default=\u201dweight\u201d)": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number."
            },
            "Returns:": {
                "length : dictionary": "Dictionary of shortest path length keyed by target"
            },
            "Raises:": {
                "NodeNotFound": "Ifsourceis not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.",
            "Examples": "G=nx.path_graph(5)\nlength=nx.single_source_bellman_ford_path_length(G,0)\nlength[4]\n# 4\nfornodein[0,1,2,3,4]:\nprint(f\"{node}: {length[node]}\")\n# 0: 0\n# 1: 1\n# 2: 2\n# 3: 3\n# 4: 4"
        }
    },
    {
        "Section ID": "reconstruct_path",
        "Description": [
            "Reconstruct a path from source to target using the predecessors\ndict as returned by floyd_warshall_predecessor_and_distance"
        ],
        "Field List": {
            "Parameters:": {
                "source : node": "Starting node for path",
                "target : node": "Ending node for path",
                "predecessors: dictionary": "Dictionary, keyed by source and target, of predecessors in the\nshortest path, as returned by floyd_warshall_predecessor_and_distance"
            },
            "Returns:": {
                "path : list": "A list of nodes containing the shortest path from source to targetIf source and target are the same, an empty list is returned"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This function is meant to give more applicability to the\nfloyd_warshall_predecessor_and_distance function"
        }
    },
    {
        "Section ID": "minimum_cut_value",
        "Description": [
            "Compute the value of a minimum (s, t)-cut.",
            "Use the max-flow min-cut theorem, i.e., the capacity of a minimum\ncapacity cut is equal to the flow value of a maximum flow."
        ],
        "Field List": {
            "Parameters:": {
                "flowG : NetworkX graph": "Edges of the graph are expected to have an attribute called\n\u2018capacity\u2019. If this attribute is not present, the edge is\nconsidered to have infinite capacity.",
                "_s : node": "Source node for the flow.",
                "_t : node": "Sink node for the flow.",
                "capacity : string": "Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: \u2018capacity\u2019.",
                "flow_func : function": "A function for computing the maximum flow among a pair of nodes\nin a capacitated graph. The function has to accept at least three\nparameters: a Graph or Digraph, a source node, and a target node.\nAnd return a residual network that follows NetworkX conventions\n(see Notes). If flow_func is None, the default maximum\nflow function (preflow_push()) is used. See below for\nalternative algorithms. The choice of the default function may change\nfrom version to version and should not be relied on. Default value:\nNone.",
                "kwargs : Any other keyword parameter is passed to the function that": "computes the maximum flow."
            },
            "Returns:": {
                "cut_value : integer, float": "Value of the minimum cut."
            },
            "Raises:": {
                "NetworkXUnbounded": "If the graph has a path of infinite capacity, all cuts have\ninfinite capacity and the function raises a NetworkXError."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The function used in the flow_func parameter has to return a residual\nnetwork that follows NetworkX conventions: The residual network R from an input graph G has the\nsame nodes as G . R is a DiGraph that contains a pair\nof edges (u,v) and (v,u) iff (u,v) is not a\nself-loop, and at least one of (u,v) and (v,u) exists\nin G . For each edge (u,v) in R , R[u][v]['capacity'] is equal to the capacity of (u,v) in G if it exists\nin G or zero otherwise. If the capacity is infinite, R[u][v]['capacity'] will have a high arbitrary finite value\nthat does not affect the solution of the problem. This value is stored in R.graph['inf'] . For each edge (u,v) in R , R[u][v]['flow'] represents the flow function of (u,v) and\nsatisfies R[u][v]['flow']==-R[v][u]['flow'] . The flow value, defined as the total flow into t , the sink, is\nstored in R.graph['flow_value'] . Reachability to t using\nonly edges (u,v) such that R[u][v]['flow']<R[u][v]['capacity'] induces a minimum s - t cut. Specific algorithms may store extra data in R . The function should supports an optional boolean parameter value_only. When\nTrue, it can optionally terminate the algorithm as soon as the maximum flow\nvalue and the minimum cut can be determined.",
            "Examples": "G=nx.DiGraph()\nG.add_edge(\"x\",\"a\",capacity=3.0)\nG.add_edge(\"x\",\"b\",capacity=1.0)\nG.add_edge(\"a\",\"c\",capacity=3.0)\nG.add_edge(\"b\",\"c\",capacity=5.0)\nG.add_edge(\"b\",\"d\",capacity=4.0)\nG.add_edge(\"d\",\"e\",capacity=2.0)\nG.add_edge(\"c\",\"y\",capacity=2.0)\nG.add_edge(\"e\",\"y\",capacity=3.0)\nminimum_cut_value computes only the value of the\nminimum cut:\ncut_value=nx.minimum_cut_value(G,\"x\",\"y\")\ncut_value\n# 3.0\nYou can also use alternative algorithms for computing the\nminimum cut by using the flow_func parameter.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\ncut_value==nx.minimum_cut_value(G,\"x\",\"y\",flow_func=shortest_augmenting_path)\n# True"
        }
    },
    {
        "Section ID": "interval_graph",
        "Description": [
            "Generates an interval graph for a list of intervals given.",
            "In graph theory, an interval graph is an undirected graph formed from a set\nof closed intervals on the real line, with a vertex for each interval\nand an edge between vertices whose intervals intersect.\nIt is the intersection graph of the intervals.",
            "More information can be found at: https://en.wikipedia.org/wiki/Interval_graph"
        ],
        "Field List": {
            "Parameters:": {
                "intervals : a sequence of intervals, say (l, r) where l is the left end,": "",
                "and r is the right end of the closed interval.": ""
            },
            "Returns:": {
                "G : networkx graph": ""
            },
            "Raises:": {
                "TypeError": "ifintervalscontains None or an element which is not\ncollections.abc.Sequence or not a length of 2.",
                "ValueError": "ifintervalscontains an interval such that min1 > max1\nwhere min1,max1 = interval"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "intervals=[(-2,3),[1,4],(2,3),(4,6)]\nG=nx.interval_graph(intervals)\nsorted(G.edges)\n# [((-2, 3), (1, 4)), ((-2, 3), (2, 3)), ((1, 4), (2, 3)), ((1, 4), (4, 6))]"
        }
    },
    {
        "Section ID": "clustering",
        "Description": [
            "Compute a bipartite clustering coefficient for nodes.",
            "The bipartite clustering coefficient is a measure of local density\nof connections defined as [1] :",
            "where N(N(u)) are the second order neighbors of u in G excluding u ,\nand c_{uv} is the pairwise clustering coefficient between nodes u and v .",
            "The mode selects the function for c_{uv} which can be:",
            "dot :",
            "min :",
            "max :"
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A bipartite graph",
                "nodes : list or iterable (optional)": "Compute bipartite clustering for these nodes. The default\nis all nodes in G.",
                "mode : string": "The pairwise bipartite clustering method to be used in the computation.\nIt must be \u201cdot\u201d, \u201cmax\u201d, or \u201cmin\u201d."
            },
            "Returns:": {
                "clustering : dictionary": "A dictionary keyed by node with the clustering coefficient value."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Latapy, Matthieu, Cl\u00e9mence Magnien, and Nathalie Del Vecchio (2008).\nBasic notions for the analysis of large two-mode networks.\nSocial Networks 30(1), 31\u201348.",
            "Examples": "fromnetworkx.algorithmsimportbipartite\nG=nx.path_graph(4)# path graphs are bipartite\nc=bipartite.clustering(G)\nc[0]\n# 0.5\nc=bipartite.clustering(G,mode=\"min\")\nc[0]\n# 1.0"
        }
    },
    {
        "Section ID": "trophic_incoherence_parameter",
        "Description": [
            "Compute the trophic incoherence parameter of a graph.",
            "Trophic coherence is defined as the homogeneity of the distribution of\ntrophic distances: the more similar, the more coherent. This is measured by\nthe standard deviation of the trophic differences and referred to as the\ntrophic incoherence parameter \\(q\\) by [1]."
        ],
        "Field List": {
            "Parameters:": {
                "G : DiGraph": "A directed networkx graph",
                "cannibalism: Boolean": "If set to False, self edges are not considered in the calculation"
            },
            "Returns:": {
                "trophic_incoherence_parameter : float": "The trophic coherence of a graph"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Samuel Johnson, Virginia Dominguez-Garcia, Luca Donetti, Miguel A.\nMunoz (2014) PNAS \u201cTrophic coherence determines food-web stability\u201d"
        }
    },
    {
        "Section ID": "is_strongly_regular",
        "Description": [
            "Returns True if and only if the given graph is strongly\nregular.",
            "An undirected graph is strongly regular if",
            "Each strongly regular graph is a distance-regular graph.\nConversely, if a distance-regular graph has diameter two, then it is\na strongly regular graph. For more information on distance-regular\ngraphs, see is_distance_regular() ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "An undirected graph."
            },
            "Returns:": {
                "bool": "WhetherGis strongly regular."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "The cycle graph on five vertices is strongly regular. It is\ntwo-regular, each pair of adjacent vertices has no shared neighbors,\nand each pair of nonadjacent vertices has one shared neighbor:\nG=nx.cycle_graph(5)\nnx.is_strongly_regular(G)\n# True"
        }
    },
    {
        "Section ID": "weisfeiler_lehman_graph_hash",
        "Description": [
            "Return Weisfeiler Lehman (WL) graph hash.",
            "The function iteratively aggregates and hashes neighborhoods of each node.\nAfter each node\u2019s neighbors are hashed to obtain updated node labels,\na hashed histogram of resulting labels is returned as the final hash.",
            "Hashes are identical for isomorphic graphs and strong guarantees that\nnon-isomorphic graphs will get different hashes. See [1] for details.",
            "If no node or edge attributes are provided, the degree of each node\nis used as its initial label.\nOtherwise, node and/or edge labels are used to compute the hash."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "The graph to be hashed.\nCan have node and/or edge attributes. Can also have no attributes.",
                "edge_attr : string, optional (default=None)": "The key in edge attribute dictionary to be used for hashing.\nIf None, edge labels are ignored.",
                "node_attr: string, optional (default=None)": "The key in node attribute dictionary to be used for hashing.\nIf None, and no edge_attr given, use the degrees of the nodes as labels.",
                "iterations: int, optional (default=3)": "Number of neighbor aggregations to perform.\nShould be larger for larger graphs.",
                "digest_size: int, optional (default=16)": "Size (in bits) of blake2b hash digest to use for hashing node labels."
            },
            "Returns:": {
                "h : string": "Hexadecimal string corresponding to hash of the input graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "To return the WL hashes of each subgraph of a graph, use weisfeiler_lehman_subgraph_hashes Similarity between hashes does not imply similarity between graphs.",
            "References": "[1]Shervashidze, Nino, Pascal Schweitzer, Erik Jan Van Leeuwen,\nKurt Mehlhorn, and Karsten M. Borgwardt. Weisfeiler Lehman\nGraph Kernels. Journal of Machine Learning Research. 2011.http://www.jmlr.org/papers/volume12/shervashidze11a/shervashidze11a.pdf",
            "Examples": "Two graphs with edge attributes that are isomorphic, except for\ndifferences in the edge labels.\nG1=nx.Graph()\nG1.add_edges_from(\n[\n(1,2,{\"label\":\"A\"}),\n(2,3,{\"label\":\"A\"}),\n(3,1,{\"label\":\"A\"}),\n(1,4,{\"label\":\"B\"}),\n]\n)\nG2=nx.Graph()\nG2.add_edges_from(\n[\n(5,6,{\"label\":\"B\"}),\n(6,7,{\"label\":\"A\"}),\n(7,5,{\"label\":\"A\"}),\n(7,8,{\"label\":\"A\"}),\n]\n)\nOmitting theedge_attroption, results in identical hashes.\nnx.weisfeiler_lehman_graph_hash(G1)\n# '7bc4dde9a09d0b94c5097b219891d81a'\nnx.weisfeiler_lehman_graph_hash(G2)\n# '7bc4dde9a09d0b94c5097b219891d81a'\nWith edge labels, the graphs are no longer assigned\nthe same hash digest.\nnx.weisfeiler_lehman_graph_hash(G1,edge_attr=\"label\")\n# 'c653d85538bcf041d88c011f4f905f10'\nnx.weisfeiler_lehman_graph_hash(G2,edge_attr=\"label\")\n# '3dcd84af1ca855d0eff3c978d88e7ec7'"
        }
    },
    {
        "Section ID": "hide_edges",
        "Description": [
            "Returns a filter function that hides specific undirected edges."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "to_latex",
        "Description": [
            "Return latex code to draw the graph(s) in Gbunch",
            "The TikZ drawing utility in LaTeX is used to draw the graph(s).\nIf Gbunch is a graph, it is drawn in a figure environment.\nIf Gbunch is an iterable of graphs, each is drawn in a subfigure environment\nwithin a single figure environment.",
            "If as_document is True, the figure is wrapped inside a document environment\nso that the resulting string is ready to be compiled by LaTeX. Otherwise,\nthe string is ready for inclusion in a larger tex document using \\include or \\input statements."
        ],
        "Field List": {
            "Parameters:": {
                "Gbunch : NetworkX graph or iterable of NetworkX graphs": "The NetworkX graph to be drawn or an iterable of graphs\nto be drawn inside subfigures of a single figure.",
                "pos : string or list of strings": "The name of the node attribute onGthat holds the position of each node.\nPositions can be sequences of length 2 with numbers for (x,y) coordinates.\nThey can also be strings to denote positions in TikZ style, such as (x, y)\nor (angle:radius).\nIf a dict, it should be keyed by node to a position.\nIf an empty dict, a circular layout is computed by TikZ.\nIf you are drawing many graphs in subfigures, use a list of position dicts.",
                "tikz_options : string": "The tikzpicture options description defining the options for the picture.\nOften large scale options like[scale=2].",
                "default_node_options : string": "The draw options for a path of nodes. Individual node options override these.",
                "node_options : string or dict": "The name of the node attribute onGthat holds the options for each node.\nOr a dict keyed by node to a string holding the options for that node.",
                "node_label : string or dict": "The name of the node attribute onGthat holds the node label (text)\ndisplayed for each node. If the attribute is \u201c\u201d or not present, the node\nitself is drawn as a string. LaTeX processing such as\"$A_1$\"is allowed.\nOr a dict keyed by node to a string holding the label for that node.",
                "default_edge_options : string": "The options for the scope drawing all edges. The default is \u201c[-]\u201d for\nundirected graphs and \u201c[->]\u201d for directed graphs.",
                "edge_options : string or dict": "The name of the edge attribute onGthat holds the options for each edge.\nIf the edge is a self-loop and\"loop\"notinedge_optionsthe option\n\u201cloop,\u201d is added to the options for the self-loop edge. Hence you can\nuse \u201c[loop above]\u201d explicitly, but the default is \u201c[loop]\u201d.\nOr a dict keyed by edge to a string holding the options for that edge.",
                "edge_label : string or dict": "The name of the edge attribute onGthat holds the edge label (text)\ndisplayed for each edge. If the attribute is \u201c\u201d or not present, no edge\nlabel is drawn.\nOr a dict keyed by edge to a string holding the label for that edge.",
                "edge_label_options : string or dict": "The name of the edge attribute onGthat holds the label options for\neach edge. For example, \u201c[sloped,above,blue]\u201d. The default is no options.\nOr a dict keyed by edge to a string holding the label options for that edge.",
                "caption : string": "The caption string for the figure environment",
                "latex_label : string": "The latex label used for the figure for easy referral from the main text",
                "sub_captions : list of strings": "The sub_caption string for each subfigure in the figure",
                "sub_latex_labels : list of strings": "The latex label for each subfigure in the figure",
                "n_rows : int": "The number of rows of subfigures to arrange for multiple graphs",
                "as_document : bool": "Whether to wrap the latex code in a document environment for compiling",
                "document_wrapper : formatted text string with variablecontent.": "This text is called to evaluate the content embedded in a document\nenvironment with a preamble setting up TikZ.",
                "figure_wrapper : formatted text string": "This text is evaluated with variablescontent,captionandlabel.\nIt wraps the content and if a caption is provided, adds the latex code for\nthat caption, and if a label is provided, adds the latex code for a label.",
                "subfigure_wrapper : formatted text string": "This text evaluate variablessize,content,captionandlabel.\nIt wraps the content and if a caption is provided, adds the latex code for\nthat caption, and if a label is provided, adds the latex code for a label.\nThe size is the vertical size of each row of subfigures as a fraction."
            },
            "Returns:": {
                "latex_code : string": "The text string which draws the desired graph(s) when compiled by LaTeX."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "pappus_graph",
        "Description": [
            "Returns the Pappus graph.",
            "The Pappus graph is a cubic symmetric distance-regular graph with 18 nodes\nand 27 edges. It is Hamiltonian and can be represented in LCF notation as\n[5,7,-7,7,-7,-5]^3 [1] ."
        ],
        "Field List": {
            "Returns:": {
                "G : networkx Graph": "Pappus graph"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://en.wikipedia.org/wiki/Pappus_graph"
        }
    },
    {
        "Section ID": "robins_alexander_clustering",
        "Description": [
            "Compute the bipartite clustering of G.",
            "Robins and Alexander [1] defined bipartite clustering coefficient as\nfour times the number of four cycles C_4 divided by the number of\nthree paths L_3 in a bipartite graph:"
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "a bipartite graph"
            },
            "Returns:": {
                "clustering : float": "The Robins and Alexander bipartite clustering for the input graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Robins, G. and M. Alexander (2004). Small worlds among interlocking\ndirectors: Network structure and distance in bipartite graphs.\nComputational & Mathematical Organization Theory 10(1), 69\u201394.",
            "Examples": "fromnetworkx.algorithmsimportbipartite\nG=nx.davis_southern_women_graph()\nprint(round(bipartite.robins_alexander_clustering(G),3))\n# 0.468"
        }
    },
    {
        "Section ID": "geometric_edges",
        "Description": [
            "Returns edge list of node pairs within radius of each other."
        ],
        "Field List": {
            "Parameters:": {
                "G : networkx graph": "The graph from which to generate the edge list. The nodes inGshould\nhave an attributeposcorresponding to the node position, which is\nused to compute the distance to other nodes.",
                "radius : scalar": "The distance threshold. Edges are included in the edge list if the\ndistance between the two nodes is less thanradius.",
                "pos_name : string, default=\u201dpos\u201d": "The name of the node attribute which represents the position of each\nnode in 2D coordinates. Every node in the Graph must have this attribute.",
                "p : scalar, default=2": "TheMinkowski distance metricused to compute\ndistances. The default value is 2, i.e. Euclidean distance."
            },
            "Returns:": {
                "edges : list": "List of edges whose distances are less thanradius"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Radius uses Minkowski distance metric p .\nIf scipy is available, scipy.spatial.cKDTree is used to speed computation.",
            "Examples": "Create a graph with nodes that have a \u201cpos\u201d attribute representing 2D\ncoordinates.\nG=nx.Graph()\nG.add_nodes_from(\n[\n(0,{\"pos\":(0,0)}),\n(1,{\"pos\":(3,0)}),\n(2,{\"pos\":(8,0)}),\n]\n)\nnx.geometric_edges(G,radius=1)\n# []\nnx.geometric_edges(G,radius=4)\n# [(0, 1)]\nnx.geometric_edges(G,radius=6)\n# [(0, 1), (1, 2)]\nnx.geometric_edges(G,radius=9)\n# [(0, 1), (0, 2), (1, 2)]"
        }
    },
    {
        "Section ID": "make_clique_bipartite",
        "Description": [
            "Returns the bipartite clique graph corresponding to G .",
            "In the returned bipartite graph, the \u201cbottom\u201d nodes are the nodes of G and the \u201ctop\u201d nodes represent the maximal cliques of G .\nThere is an edge from node v to clique C in the returned graph\nif and only if v is an element of C ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "An undirected graph.",
                "fpos : bool": "If True or not None, the returned graph will have an\nadditional attribute,pos, a dictionary mapping node to\nposition in the Euclidean plane.",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "NetworkX graph": "A bipartite graph whose \u201cbottom\u201d set is the nodes of the graphG, whose \u201ctop\u201d set is the cliques ofG, and whose edges\njoin nodes ofGto the cliques that contain them.The nodes of the graphGhave the node attribute\n\u2018bipartite\u2019 set to 1 and the nodes representing cliques\nhave the node attribute \u2018bipartite\u2019 set to 0, as is the\nconvention for bipartite graphs in NetworkX."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "dict_to_numpy_array",
        "Description": [
            "Convert a dictionary of dictionaries to a numpy array\nwith optional mapping."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "astar_path_length",
        "Description": [
            "Returns the length of the shortest path between source and target using\nthe A* (\u201cA-star\u201d) algorithm."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : node": "Starting node for path",
                "target : node": "Ending node for path",
                "heuristic : function": "A function to evaluate the estimate of the distance\nfrom the a node to the target.  The function takes\ntwo nodes arguments and must return a number.\nIf the heuristic is inadmissible (if it might\noverestimate the cost of reaching the goal from a node),\nthe result may not be a shortest path.\nThe algorithm does not support updating heuristic\nvalues for the same node due to caching the first\nheuristic calculation per node.",
                "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.\nIf this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge.",
                "cutoff : float, optional": "If this is provided, the search will be bounded to this value. I.e. if\nthe evaluation function surpasses this value for a node n, the node will not\nbe expanded further and will be ignored. More formally, let h\u2019(n) be the\nheuristic function, and g(n) be the cost of reaching n from the source node. Then,\nif g(n) + h\u2019(n) > cutoff, the node will not be explored further.\nNote that if the heuristic is inadmissible, it is possible that paths\nare ignored even though they satisfy the cutoff."
            },
            "Raises:": {
                "NetworkXNoPath": "If no path exists between source and target."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "all_pairs_bellman_ford_path",
        "Description": [
            "Compute shortest paths between all nodes in a weighted graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "weight : string or function (default=\u201dweight\u201d)": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number."
            },
            "Returns:": {
                "paths : iterator": "(source, dictionary) iterator with dictionary keyed by target and\nshortest path as the key value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed.",
            "Examples": "G=nx.path_graph(5)\npath=dict(nx.all_pairs_bellman_ford_path(G))\npath[0][4]\n# [0, 1, 2, 3, 4]"
        }
    },
    {
        "Section ID": "find_induced_nodes",
        "Description": [
            "Returns the set of induced nodes in the path from s to t."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A chordal NetworkX graph",
                "s : node": "Source node to look for induced nodes",
                "t : node": "Destination node to look for induced nodes",
                "treewidth_bound: float": "Maximum treewidth acceptable for the graph H. The search\nfor induced nodes will end as soon as the treewidth_bound is exceeded."
            },
            "Returns:": {
                "induced_nodes : Set of nodes": "The set of induced nodes in the path from s to t in G"
            },
            "Raises:": {
                "NetworkXError": "The algorithm does not support DiGraph, MultiGraph and MultiDiGraph.\nIf the input graph is an instance of one of these classes, aNetworkXErroris raised.\nThe algorithm can only be applied to chordal graphs. If the input\ngraph is found to be non-chordal, aNetworkXErroris raised."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "G must be a chordal graph and (s,t) an edge that is not in G. If a treewidth_bound is provided, the search for induced nodes will end\nas soon as the treewidth_bound is exceeded. The algorithm is inspired by Algorithm 4 in [1] .\nA formal definition of induced node can also be found on that reference. Self Loops are ignored",
            "References": "[1]Learning Bounded Treewidth Bayesian Networks.\nGal Elidan, Stephen Gould; JMLR, 9(Dec):2699\u20132731, 2008.http://jmlr.csail.mit.edu/papers/volume9/elidan08a/elidan08a.pdf",
            "Examples": "G=nx.Graph()\nG=nx.generators.classic.path_graph(10)\ninduced_nodes=nx.find_induced_nodes(G,1,9,2)\nsorted(induced_nodes)\n# [1, 2, 3, 4, 5, 6, 7, 8, 9]"
        }
    },
    {
        "Section ID": "efficiency",
        "Description": [
            "Returns the efficiency of a pair of nodes in a graph.",
            "The efficiency of a pair of nodes is the multiplicative inverse of the\nshortest path distance between the nodes [1] . Returns 0 if no path\nbetween nodes."
        ],
        "Field List": {
            "Parameters:": {
                "G : networkx.Graph": "An undirected graph for which to compute the average local efficiency.",
                "u, v : node": "Nodes in the graphG."
            },
            "Returns:": {
                "float": "Multiplicative inverse of the shortest path distance between the nodes."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weights are ignored when computing the shortest path distances.",
            "References": "[1]Latora, Vito, and Massimo Marchiori.\n\u201cEfficient behavior of small-world networks.\u201dPhysical Review Letters87.19 (2001): 198701.\n<https://doi.org/10.1103/PhysRevLett.87.198701>",
            "Examples": "G=nx.Graph([(0,1),(0,2),(0,3),(1,2),(1,3)])\nnx.efficiency(G,2,3)# this gives efficiency for node 2 and 3\n# 0.5"
        }
    },
    {
        "Section ID": "sudoku_graph",
        "Description": [
            "Returns the n-Sudoku graph. The default value of n is 3.",
            "The n-Sudoku graph is a graph with n^4 vertices, corresponding to the\ncells of an n^2 by n^2 grid. Two distinct vertices are adjacent if and\nonly if they belong to the same row, column, or n-by-n box."
        ],
        "Field List": {
            "Parameters:": {
                "n: integer": "The order of the Sudoku graph, equal to the square root of the\nnumber of rows. The default is 3."
            },
            "Returns:": {
                "NetworkX graph": "The n-Sudoku graph Sud(n)."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Herzberg, A. M., & Murty, M. R. (2007). Sudoku squares and chromatic\npolynomials. Notices of the AMS, 54(6), 708-717.  [2]Sander, Torsten (2009), \u201cSudoku graphs are integral\u201d,\nElectronic Journal of Combinatorics, 16 (1): Note 25, 7pp, MR 2529816  [3]Wikipedia contributors. \u201cGlossary of Sudoku.\u201d Wikipedia, The Free\nEncyclopedia, 3 Dec. 2019. Web. 22 Dec. 2019.",
            "Examples": "G=nx.sudoku_graph()\nG.number_of_nodes()\n# 81\nG.number_of_edges()\n# 810\nsorted(G.neighbors(42))\n# [6, 15, 24, 33, 34, 35, 36, 37, 38, 39, 40, 41, 43, 44, 51, 52, 53, 60, 69, 78]\nG=nx.sudoku_graph(2)\nG.number_of_nodes()\n# 16\nG.number_of_edges()\n# 56"
        }
    },
    {
        "Section ID": "write_network_text",
        "Description": [
            "Creates a nice text representation of a graph",
            "This works via a depth-first traversal of the graph and writing a line for\neach unique node encountered. Non-tree edges are written to the right of\neach node, and connection to a non-tree edge is indicated with an ellipsis.\nThis representation works best when the input graph is a forest, but any\ngraph can be represented."
        ],
        "Field List": {
            "Parameters:": {
                "graph : nx.DiGraph | nx.Graph": "Graph to represent",
                "path : string or file or callable or None": "Filename or file handle for data output.\nif a function, then it will be called for each generated line.\nif None, this will default to \u201csys.stdout.write\u201d",
                "with_labels : bool | str": "If True will use the \u201clabel\u201d attribute of a node to display if it\nexists otherwise it will use the node value itself. If given as a\nstring, then that attribute name will be used instead of \u201clabel\u201d.\nDefaults to True.",
                "sources : List": "Specifies which nodes to start traversal from. Note: nodes that are not\nreachable from one of these sources may not be shown. If unspecified,\nthe minimal set of nodes needed to reach all others will be used.",
                "max_depth : int | None": "The maximum depth to traverse before stopping. Defaults to None.",
                "ascii_only : Boolean": "If True only ASCII characters are used to construct the visualization",
                "end : string": "The line ending character",
                "vertical_chains : Boolean": "If True, chains of nodes will be drawn vertically when possible."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "graph=nx.balanced_tree(r=2,h=2,create_using=nx.DiGraph)\nnx.write_network_text(graph)\n# \u2559\u2500\u2500 0\n#     \u251c\u2500\u257c 1\n#     \u2502   \u251c\u2500\u257c 3\n#     \u2502   \u2514\u2500\u257c 4\n#     \u2514\u2500\u257c 2\n#         \u251c\u2500\u257c 5\n#         \u2514\u2500\u257c 6\n# A near tree with one non-tree edge\ngraph.add_edge(5,1)\nnx.write_network_text(graph)\n# \u2559\u2500\u2500 0\n#     \u251c\u2500\u257c 1 \u257e 5\n#     \u2502   \u251c\u2500\u257c 3\n#     \u2502   \u2514\u2500\u257c 4\n#     \u2514\u2500\u257c 2\n#         \u251c\u2500\u257c 5\n#         \u2502   \u2514\u2500\u257c  ...\n#         \u2514\u2500\u257c 6\ngraph=nx.cycle_graph(5)\nnx.write_network_text(graph)\n# \u2559\u2500\u2500 0\n#     \u251c\u2500\u2500 1\n#     \u2502   \u2514\u2500\u2500 2\n#     \u2502       \u2514\u2500\u2500 3\n#     \u2502           \u2514\u2500\u2500 4 \u2500 0\n#     \u2514\u2500\u2500  ...\ngraph=nx.cycle_graph(5,nx.DiGraph)\nnx.write_network_text(graph,vertical_chains=True)\n# \u2559\u2500\u2500 0 \u257e 4\n#     \u257d\n#     1\n#     \u257d\n#     2\n#     \u257d\n#     3\n#     \u257d\n#     4\n#     \u2514\u2500\u257c  ...\nnx.write_network_text(graph,vertical_chains=True,ascii_only=True)\n# +-- 0 <- 4\n#     !\n#     1\n#     !\n#     2\n#     !\n#     3\n#     !\n#     4\n#     L->  ...\ngraph=nx.generators.barbell_graph(4,2)\nnx.write_network_text(graph,vertical_chains=False)\n# \u2559\u2500\u2500 4\n#     \u251c\u2500\u2500 5\n#     \u2502   \u2514\u2500\u2500 6\n#     \u2502       \u251c\u2500\u2500 7\n#     \u2502       \u2502   \u251c\u2500\u2500 8 \u2500 6\n#     \u2502       \u2502   \u2502   \u2514\u2500\u2500 9 \u2500 6, 7\n#     \u2502       \u2502   \u2514\u2500\u2500  ...\n#     \u2502       \u2514\u2500\u2500  ...\n#     \u2514\u2500\u2500 3\n#         \u251c\u2500\u2500 0\n#         \u2502   \u251c\u2500\u2500 1 \u2500 3\n#         \u2502   \u2502   \u2514\u2500\u2500 2 \u2500 0, 3\n#         \u2502   \u2514\u2500\u2500  ...\n#         \u2514\u2500\u2500  ...\nnx.write_network_text(graph,vertical_chains=True)\n# \u2559\u2500\u2500 4\n#     \u251c\u2500\u2500 5\n#     \u2502   \u2502\n#     \u2502   6\n#     \u2502   \u251c\u2500\u2500 7\n#     \u2502   \u2502   \u251c\u2500\u2500 8 \u2500 6\n#     \u2502   \u2502   \u2502   \u2502\n#     \u2502   \u2502   \u2502   9 \u2500 6, 7\n#     \u2502   \u2502   \u2514\u2500\u2500  ...\n#     \u2502   \u2514\u2500\u2500  ...\n#     \u2514\u2500\u2500 3\n#         \u251c\u2500\u2500 0\n#         \u2502   \u251c\u2500\u2500 1 \u2500 3\n#         \u2502   \u2502   \u2502\n#         \u2502   \u2502   2 \u2500 0, 3\n#         \u2502   \u2514\u2500\u2500  ...\n#         \u2514\u2500\u2500  ...\ngraph=nx.complete_graph(5,create_using=nx.Graph)\nnx.write_network_text(graph)\n# \u2559\u2500\u2500 0\n#     \u251c\u2500\u2500 1\n#     \u2502   \u251c\u2500\u2500 2 \u2500 0\n#     \u2502   \u2502   \u251c\u2500\u2500 3 \u2500 0, 1\n#     \u2502   \u2502   \u2502   \u2514\u2500\u2500 4 \u2500 0, 1, 2\n#     \u2502   \u2502   \u2514\u2500\u2500  ...\n#     \u2502   \u2514\u2500\u2500  ...\n#     \u2514\u2500\u2500  ...\ngraph=nx.complete_graph(3,create_using=nx.DiGraph)\nnx.write_network_text(graph)\n# \u2559\u2500\u2500 0 \u257e 1, 2\n#     \u251c\u2500\u257c 1 \u257e 2\n#     \u2502   \u251c\u2500\u257c 2 \u257e 0\n#     \u2502   \u2502   \u2514\u2500\u257c  ...\n#     \u2502   \u2514\u2500\u257c  ...\n#     \u2514\u2500\u257c  ..."
        }
    },
    {
        "Section ID": "group_degree_centrality",
        "Description": [
            "Compute the group degree centrality for a group of nodes.",
            "Group degree centrality of a group of nodes \\(S\\) is the fraction\nof non-group members connected to group members."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph.",
                "S : list or set": "S is a group of nodes which belong to G, for which group degree\ncentrality is to be calculated."
            },
            "Returns:": {
                "centrality : float": "Group degree centrality of the group S."
            },
            "Raises:": {
                "NetworkXError": "If node(s) in S are not in G."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The measure was introduced in [1] . The number of nodes in the group must be a maximum of n - 1 where n is the total number of nodes in the graph.",
            "References": "[1]M G Everett and S P Borgatti:\nThe Centrality of Groups and Classes.\nJournal of Mathematical Sociology. 23(3): 181-201. 1999.http://www.analytictech.com/borgatti/group_centrality.htm"
        }
    },
    {
        "Section ID": "disjoint_union",
        "Description": [
            "Combine graphs G and H. The nodes are assumed to be unique (disjoint).",
            "This algorithm automatically relabels nodes to avoid name collisions."
        ],
        "Field List": {
            "Parameters:": {
                "G,H : graph": "A NetworkX graph"
            },
            "Returns:": {
                "U : A union graph with the same type as G.": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "A new graph is created, of the same class as G.  It is recommended\nthat G and H be either both directed or both undirected. The nodes of G are relabeled 0 to len(G)-1, and the nodes of H are\nrelabeled len(G) to len(G)+len(H)-1. Renumbering forces G and H to be disjoint, so no exception is ever raised for a name collision.\nTo preserve the check for common nodes, use union(). Edge and node attributes are propagated from G and H to the union graph.\nGraph attributes are also propagated, but if they are present in both G and H,\nthen the value from H is used. To combine graphs that have common nodes, consider compose(G, H)\nor the method, Graph.update().",
            "Examples": "G=nx.Graph([(0,1),(0,2),(1,2)])\nH=nx.Graph([(0,3),(1,2),(2,3)])\nG.nodes[0][\"key1\"]=5\nH.nodes[0][\"key2\"]=10\nU=nx.disjoint_union(G,H)\nU.nodes(data=True)\n# NodeDataView({0: {'key1': 5}, 1: {}, 2: {}, 3: {'key2': 10}, 4: {}, 5: {}, 6: {}})\nU.edges\n# EdgeView([(0, 1), (0, 2), (1, 2), (3, 4), (4, 6), (5, 6)])"
        }
    },
    {
        "Section ID": "descendants_at_distance",
        "Description": [
            "Returns all nodes at a fixed distance from source in G ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A graph",
                "source : node inG": "",
                "distance : the distance of the wanted nodes fromsource": ""
            },
            "Returns:": {
                "set()": "The descendants ofsourceinGat the givendistancefromsource"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.path_graph(5)\nnx.descendants_at_distance(G,2,2)\n# {0, 4}\nH=nx.DiGraph()\nH.add_edges_from([(0,1),(0,2),(1,3),(1,4),(2,5),(2,6)])\nnx.descendants_at_distance(H,0,2)\n# {3, 4, 5, 6}\nnx.descendants_at_distance(H,5,0)\n# {5}\nnx.descendants_at_distance(H,5,1)\n# set()"
        }
    },
    {
        "Section ID": "write_sparse6",
        "Description": [
            "Write graph G to given path in sparse6 format."
        ],
        "Field List": {
            "Parameters:": {
                "G : Graph (undirected)": "",
                "path : file or string": "File or filename to write",
                "nodes: list or iterable": "Nodes are labeled 0\u2026n-1 in the order provided.  If None the ordering\ngiven by G.nodes() is used.",
                "header: bool": "If True add \u2018>>sparse6<<\u2019 string to head of data"
            },
            "Raises:": {
                "NetworkXError": "If the graph is directed"
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The format does not support edge or node labels.",
            "References": "[1]Sparse6 specification\n<https://users.cecs.anu.edu.au/~bdm/data/formats.html>",
            "Examples": "You can write a sparse6 file by giving the path to the file:\nimporttempfile\nwithtempfile.NamedTemporaryFile(delete=False)asf:\nnx.write_sparse6(nx.path_graph(2),f.name)\nprint(f.read())\n# b'>>sparse6<<:An\\n'\nYou can also write a sparse6 file by giving an open file-like object:\nwithtempfile.NamedTemporaryFile()asf:\nnx.write_sparse6(nx.path_graph(2),f)\n_=f.seek(0)\nprint(f.read())\n# b'>>sparse6<<:An\\n'"
        }
    },
    {
        "Section ID": "preferential_attachment",
        "Description": [
            "Compute the preferential attachment score of all node pairs in ebunch.",
            "Preferential attachment score of u and v is defined as",
            "where \\(\\Gamma(u)\\) denotes the set of neighbors of \\(u\\) ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "NetworkX undirected graph.",
                "ebunch : iterable of node pairs, optional (default = None)": "Preferential attachment score will be computed for each pair of\nnodes given in the iterable. The pairs must be given as\n2-tuples (u, v) where u and v are nodes in the graph. If ebunch\nis None then all nonexistent edges in the graph will be used.\nDefault value: None."
            },
            "Returns:": {
                "piter : iterator": "An iterator of 3-tuples in the form (u, v, p) where (u, v) is a\npair of nodes and p is their preferential attachment score."
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis aDiGraph, aMultigraphor aMultiDiGraph.",
                "NodeNotFound": "Ifebunchhas a node that is not inG."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]D. Liben-Nowell, J. Kleinberg.\nThe Link Prediction Problem for Social Networks (2004).http://www.cs.cornell.edu/home/kleinber/link-pred.pdf",
            "Examples": "G=nx.complete_graph(5)\npreds=nx.preferential_attachment(G,[(0,1),(2,3)])\nforu,v,pinpreds:\nprint(f\"({u}, {v}) -> {p}\")\n# (0, 1) -> 16\n# (2, 3) -> 16"
        }
    },
    {
        "Section ID": "truncated_cube_graph",
        "Description": [
            "Returns the skeleton of the truncated cube.",
            "The truncated cube is an Archimedean solid with 14 regular\nfaces (6 octagonal and 8 triangular), 36 edges and 24 nodes [1] .\nThe truncated cube is created by truncating (cutting off) the tips\nof the cube one third of the way into each edge [2] ."
        ],
        "Field List": {
            "Parameters:": {
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : networkx Graph": "Skeleton of the truncated cube"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://en.wikipedia.org/wiki/Truncated_cube  [2]https://www.coolmath.com/reference/polyhedra-truncated-cube"
        }
    },
    {
        "Section ID": "cytoscape_graph",
        "Description": [
            "Create a NetworkX graph from a dictionary in cytoscape JSON format."
        ],
        "Field List": {
            "Parameters:": {
                "data : dict": "A dictionary of data conforming to cytoscape JSON format.",
                "name : string": "A string which is mapped to the \u2018name\u2019 node element in cyjs format.\nMust not have the same value asident.",
                "ident : string": "A string which is mapped to the \u2018id\u2019 node element in cyjs format.\nMust not have the same value asname."
            },
            "Returns:": {
                "graph : a NetworkX graph instance": "Thegraphcan be an instance ofGraph,DiGraph,MultiGraph, orMultiDiGraphdepending on the input data."
            },
            "Raises:": {
                "NetworkXError": "If thenameandidentattributes are identical."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Cytoscape user\u2019s manual:http://manual.cytoscape.org/en/stable/index.html",
            "Examples": "data_dict={\n\"data\":[],\n\"directed\":False,\n\"multigraph\":False,\n\"elements\":{\n\"nodes\":[\n{\"data\":{\"id\":\"0\",\"value\":0,\"name\":\"0\"}},\n{\"data\":{\"id\":\"1\",\"value\":1,\"name\":\"1\"}},\n],\n\"edges\":[{\"data\":{\"source\":0,\"target\":1}}],\n},\n}\nG=nx.cytoscape_graph(data_dict)\nG.name\n# ''\nG.nodes()\n# NodeView((0, 1))\nG.nodes(data=True)[0]\n# {'id': '0', 'value': 0, 'name': '0'}\nG.edges(data=True)\n# EdgeDataView([(0, 1, {'source': 0, 'target': 1})])"
        }
    },
    {
        "Section ID": "attribute_mixing_dict",
        "Description": [
            "Returns dictionary representation of mixing matrix for attribute."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "NetworkX graph object.",
                "attribute : string": "Node attribute key.",
                "nodes: list or iterable (optional)": "Unse nodes in container to build the dict. The default is all nodes.",
                "normalized : bool (default=False)": "Return counts if False or probabilities if True."
            },
            "Returns:": {
                "d : dictionary": "Counts or joint probability of occurrence of attribute pairs."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph()\nG.add_nodes_from([0,1],color=\"red\")\nG.add_nodes_from([2,3],color=\"blue\")\nG.add_edge(1,3)\nd=nx.attribute_mixing_dict(G,\"color\")\nprint(d[\"red\"][\"blue\"])\n# 1\nprint(d[\"blue\"][\"red\"])# d symmetric for undirected graphs\n# 1"
        }
    },
    {
        "Section ID": "to_nested_tuple",
        "Description": [
            "Returns a nested tuple representation of the given tree.",
            "The nested tuple representation of a tree is defined\nrecursively. The tree with one node and no edges is represented by\nthe empty tuple, () . A tree with k subtrees is represented\nby a tuple of length k in which each element is the nested tuple\nrepresentation of a subtree."
        ],
        "Field List": {
            "Parameters:": {
                "T : NetworkX graph": "An undirected graph object representing a tree.",
                "root : node": "The node inTto interpret as the root of the tree.",
                "canonical_form : bool": "IfTrue, each tuple is sorted so that the function returns\na canonical form for rooted trees. This means \u201clighter\u201d subtrees\nwill appear as nested tuples before \u201cheavier\u201d subtrees. In this\nway, each isomorphic rooted tree has the same nested tuple\nrepresentation."
            },
            "Returns:": {
                "tuple": "A nested tuple representation of the tree."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This function is not the inverse of from_nested_tuple() ; the\nonly guarantee is that the rooted trees are isomorphic.",
            "Examples": "The tree need not be a balanced binary tree:\nT=nx.Graph()\nT.add_edges_from([(0,1),(0,2),(0,3)])\nT.add_edges_from([(1,4),(1,5)])\nT.add_edges_from([(3,6),(3,7)])\nroot=0\nnx.to_nested_tuple(T,root)\n# (((), ()), (), ((), ()))\nContinuing the above example, ifcanonical_formisTrue, the\nnested tuples will be sorted:\nnx.to_nested_tuple(T,root,canonical_form=True)\n# ((), ((), ()), ((), ()))\nEven the path graph can be interpreted as a tree:\nT=nx.path_graph(4)\nroot=0\nnx.to_nested_tuple(T,root)\n# ((((),),),)"
        }
    },
    {
        "Section ID": "havel_hakimi_graph",
        "Description": [
            "Returns a simple graph with given degree sequence constructed\nusing the Havel-Hakimi algorithm."
        ],
        "Field List": {
            "Parameters:": {
                "deg_sequence: list of integers": "Each integer corresponds to the degree of a node (need not be sorted).",
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated.\nDirected graphs are not allowed."
            },
            "Raises:": {
                "NetworkXException": "For a non-graphical degree sequence (i.e. one\nnot realizable by some simple graph)."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The Havel-Hakimi algorithm constructs a simple graph by\nsuccessively connecting the node of highest degree to other nodes\nof highest degree, resorting remaining nodes by degree, and\nrepeating the process. The resulting graph has a high\ndegree-associativity.  Nodes are labeled 1,.., len(deg_sequence),\ncorresponding to their position in deg_sequence. The basic algorithm is from Hakimi [1] and was generalized by\nKleitman and Wang [2] .",
            "References": "[1]Hakimi S., On Realizability of a Set of Integers as\nDegrees of the Vertices of a Linear Graph. I,\nJournal of SIAM, 10(3), pp. 496-506 (1962)  [2]Kleitman D.J. and Wang D.L.\nAlgorithms for Constructing Graphs and Digraphs with Given Valences\nand Factors  Discrete Mathematics, 6(1), pp. 79-88 (1973)"
        }
    },
    {
        "Section ID": "draw_networkx_labels",
        "Description": [
            "Draw node labels on the graph G."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph",
                "pos : dictionary": "A dictionary with nodes as keys and positions as values.\nPositions should be sequences of length 2.",
                "labels : dictionary (default={n: n for n in G})": "Node labels in a dictionary of text labels keyed by node.\nNode-keys in labels should appear as keys inpos.\nIf needed use:{n:labforn,labinlabels.items()ifninpos}",
                "font_size : int (default=12)": "Font size for text labels",
                "font_color : color (default=\u2019k\u2019 black)": "Font color string. Color can be string or rgb (or rgba) tuple of\nfloats from 0-1.",
                "font_weight : string (default=\u2019normal\u2019)": "Font weight",
                "font_family : string (default=\u2019sans-serif\u2019)": "Font family",
                "alpha : float or None (default=None)": "The text transparency",
                "bbox : Matplotlib bbox, (default is Matplotlib\u2019s ax.text default)": "Specify text box properties (e.g. shape, color etc.) for node labels.",
                "horizontalalignment : string (default=\u2019center\u2019)": "Horizontal alignment {\u2018center\u2019, \u2018right\u2019, \u2018left\u2019}",
                "verticalalignment : string (default=\u2019center\u2019)": "Vertical alignment {\u2018center\u2019, \u2018top\u2019, \u2018bottom\u2019, \u2018baseline\u2019, \u2018center_baseline\u2019}",
                "ax : Matplotlib Axes object, optional": "Draw the graph in the specified Matplotlib axes.",
                "clip_on : bool (default=True)": "Turn on clipping of node labels at axis boundaries",
                "hide_ticks : bool, optional": "Hide ticks of axes. WhenTrue(the default), ticks and ticklabels\nare removed from the axes. To set ticks and tick labels to the pyplot default,\nusehide_ticks=False."
            },
            "Returns:": {
                "dict": "dictof labels keyed on the nodes"
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.dodecahedral_graph()\nlabels=nx.draw_networkx_labels(G,pos=nx.spring_layout(G))\nAlso see the NetworkX drawing examples athttps://networkx.org/documentation/latest/auto_examples/index.html"
        }
    },
    {
        "Section ID": "onion_layers",
        "Description": [
            "Returns the layer of each vertex in an onion decomposition of the graph.",
            "The onion decomposition refines the k-core decomposition by providing\ninformation on the internal organization of each k-shell. It is usually\nused alongside the corenumbers ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "An undirected graph without self loops."
            },
            "Returns:": {
                "od_layers : dictionary": "A dictionary keyed by node to the onion layer. The layers are\ncontiguous integers starting at 1."
            },
            "Raises:": {
                "NetworkXNotImplemented": "IfGis a multigraph or directed graph or if it contains self loops."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Multi-scale structure and topological anomaly detection via a new\nnetwork statistic: The onion decomposition\nL. H\u00e9bert-Dufresne, J. A. Grochow, and A. Allard\nScientific Reports 6, 31708 (2016)http://doi.org/10.1038/srep31708  [2]Percolation and the effective structure of complex networks\nA. Allard and L. H\u00e9bert-Dufresne\nPhysical Review X 9, 011023 (2019)http://doi.org/10.1103/PhysRevX.9.011023",
            "Examples": "degrees=[0,1,2,2,2,2,3]\nH=nx.havel_hakimi_graph(degrees)\nH.degree\n# DegreeView({0: 1, 1: 2, 2: 2, 3: 2, 4: 2, 5: 3, 6: 0})\nnx.onion_layers(H)\n# {6: 1, 0: 2, 4: 3, 1: 4, 2: 4, 3: 4, 5: 4}"
        }
    },
    {
        "Section ID": "check_planarity",
        "Description": [
            "Check if a graph is planar and return a counterexample or an embedding.",
            "A graph is planar iff it can be drawn in a plane without\nany edge intersections."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "counterexample : bool": "A Kuratowski subgraph (to proof non planarity) is only returned if set\nto true."
            },
            "Returns:": {
                "(is_planar, certificate) : (bool, NetworkX graph) tuple": "is_planar is true if the graph is planar.\nIf the graph is planarcertificateis a PlanarEmbedding\notherwise it is a Kuratowski subgraph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "A (combinatorial) embedding consists of cyclic orderings of the incident\nedges at each vertex. Given such an embedding there are multiple approaches\ndiscussed in literature to drawing the graph (subject to various\nconstraints, e.g. integer coordinates), see e.g. [2]. The planarity check algorithm and extraction of the combinatorial embedding\nis based on the Left-Right Planarity Test [1]. A counterexample is only generated if the corresponding parameter is set,\nbecause the complexity of the counterexample generation is higher.",
            "References": "[1]Ulrik Brandes:\nThe Left-Right Planarity Test\n2009http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.217.9208  [2]Takao Nishizeki, Md Saidur Rahman:\nPlanar graph drawing\nLecture Notes Series on Computing: Volume 12\n2004",
            "Examples": "G=nx.Graph([(0,1),(0,2)])\nis_planar,P=nx.check_planarity(G)\nprint(is_planar)\n# True\nWhenGis planar, aPlanarEmbeddinginstance is returned:\nP.get_data()\n# {0: [1, 2], 1: [0], 2: [0]}"
        }
    },
    {
        "Section ID": "complete_bipartite_graph",
        "Description": [
            "Returns the complete bipartite graph K_{n_1,n_2} .",
            "The graph is composed of two partitions with nodes 0 to (n1 - 1)\nin the first and nodes n1 to (n1 + n2 - 1) in the second.\nEach node in the first is connected to each node in the second."
        ],
        "Field List": {
            "Parameters:": {
                "n1, n2 : integer or iterable container of nodes": "If integers, nodes are fromrange(n1)andrange(n1,n1+n2).\nIf a container, the elements are the nodes.",
                "create_using : NetworkX graph instance, (default: nx.Graph)": "Return graph of this type."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Nodes are the integers 0 to n1+n2-1 unless either n1 or n2 are\ncontainers of nodes. If only one of n1 or n2 are integers, that\ninteger is replaced by range of that integer. The nodes are assigned the attribute \u2018bipartite\u2019 with the value 0 or 1\nto indicate which bipartite set the node belongs to. This function is not imported in the main namespace.\nTo use it use nx.bipartite.complete_bipartite_graph"
        }
    },
    {
        "Section ID": "identified_nodes",
        "Description": [
            "Returns the graph that results from contracting u and v .",
            "Node contraction identifies the two nodes as a single node incident to any\nedge that was incident to the original two nodes."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "The graph whose nodes will be contracted.",
                "u, v : nodes": "Must be nodes inG.",
                "self_loops : Boolean": "If this is True, any edges joininguandvinGbecome\nself-loops on the new node in the returned graph.",
                "copy : Boolean": "If this is True (default True), make a copy ofGand return that instead of directly changingG."
            },
            "Returns:": {
                "Networkx graph": "If Copy is True,\nA new graph object of the same type asG(leavingGunmodified)\nwithuandvidentified in a single node. The right nodevwill be merged into the nodeu, so onlyuwill appear in the\nreturned graph.\nIf copy is False,\nModifiesGwithuandvidentified in a single node.\nThe right nodevwill be merged into the nodeu, so\nonlyuwill appear in the returned graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For multigraphs, the edge keys for the realigned edges may\nnot be the same as the edge keys for the old edges. This is\nnatural because edge keys are unique only within each pair of nodes. For non-multigraphs where u and v are adjacent to a third node w , the edge ( v , w ) will be contracted into the edge ( u , w ) with its attributes stored into a \u201ccontraction\u201d attribute. This function is also available as identified_nodes .",
            "Examples": "Contracting two nonadjacent nodes of the cycle graph on four nodesC_4yields the path graph (ignoring parallel edges):\nG=nx.cycle_graph(4)\nM=nx.contracted_nodes(G,1,3)\nP3=nx.path_graph(3)\nnx.is_isomorphic(M,P3)\n# True\nG=nx.MultiGraph(P3)\nM=nx.contracted_nodes(G,0,2)\nM.edges\n# MultiEdgeView([(0, 1, 0), (0, 1, 1)])\nG=nx.Graph([(1,2),(2,2)])\nH=nx.contracted_nodes(G,1,2,self_loops=False)\nlist(H.nodes())\n# [1]\nlist(H.edges())\n# [(1, 1)]\nIn aMultiDiGraphwith a self loop, the in and out edges will\nbe treated separately as edges, so while contracting a node which\nhas a self loop the contraction will add multiple edges:\nG=nx.MultiDiGraph([(1,2),(2,2)])\nH=nx.contracted_nodes(G,1,2)\nlist(H.edges())# edge 1->2, 2->2, 2<-2 from the original Graph G\n# [(1, 1), (1, 1), (1, 1)]\nH=nx.contracted_nodes(G,1,2,self_loops=False)\nlist(H.edges())# edge 2->2, 2<-2 from the original Graph G\n# [(1, 1), (1, 1)]"
        }
    },
    {
        "Section ID": "from_sparse6_bytes",
        "Description": [
            "Read an undirected graph in sparse6 format from string."
        ],
        "Field List": {
            "Parameters:": {
                "string : string": "Data in sparse6 format"
            },
            "Returns:": {
                "G : Graph": ""
            },
            "Raises:": {
                "NetworkXError": "If the string is unable to be parsed in sparse6 format"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Sparse6 specification\n<https://users.cecs.anu.edu.au/~bdm/data/formats.html>",
            "Examples": "G=nx.from_sparse6_bytes(b\":A_\")\nsorted(G.edges())\n# [(0, 1), (0, 1), (0, 1)]"
        }
    },
    {
        "Section ID": "is_planar",
        "Description": [
            "Returns True if and only if G is planar.",
            "A graph is planar iff it can be drawn in a plane without\nany edge intersections."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": ""
            },
            "Returns:": {
                "bool": "Whether the graph is planar."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "G=nx.Graph([(0,1),(0,2)])\nnx.is_planar(G)\n# True\nnx.is_planar(nx.complete_graph(5))\n# False"
        }
    },
    {
        "Section ID": "random_powerlaw_tree_sequence",
        "Description": [
            "Returns a degree sequence for a tree with a power law distribution."
        ],
        "Field List": {
            "Parameters:": {
                "n : int,": "The number of nodes.",
                "gamma : float": "Exponent of the power law.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "tries : int": "Number of attempts to adjust the sequence to make it a tree."
            },
            "Raises:": {
                "NetworkXError": "If no valid sequence is found within the maximum number of\nattempts."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "A trial power law degree sequence is chosen and then elements are\nswapped with new elements from a power law distribution until\nthe sequence makes a tree (by checking, for example, that the number of\nedges is one smaller than the number of nodes)."
        }
    },
    {
        "Section ID": "constraint",
        "Description": [
            "Returns the constraint on all nodes in the graph G .",
            "The constraint is a measure of the extent to which a node v is\ninvested in those nodes that are themselves invested in the\nneighbors of v . Formally, the constraint on v , denoted c(v) ,\nis defined by",
            "where \\(N(v)\\) is the subset of the neighbors of v that are either\npredecessors or successors of v and \\(\\ell(v, w)\\) is the local\nconstraint on v with respect to w  [1] . For the definition of local\nconstraint, see local_constraint() ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "The graph containingv. This can be either directed or undirected.",
                "nodes : container, optional": "Container of nodes in the graphGto compute the constraint. If\nNone, the constraint of every node is computed.",
                "weight : None or string, optional": "If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight."
            },
            "Returns:": {
                "dict": "Dictionary with nodes as keys and the constraint on the node as values."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Burt, Ronald S.\n\u201cStructural holes and good ideas\u201d.\nAmerican Journal of Sociology (110): 349\u2013399."
        }
    },
    {
        "Section ID": "node_link_data",
        "Description": [
            "Returns data in node-link format that is suitable for JSON serialization\nand use in JavaScript documents."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "source : string": "A string that provides the \u2018source\u2019 attribute name for storing NetworkX-internal graph data.",
                "target : string": "A string that provides the \u2018target\u2019 attribute name for storing NetworkX-internal graph data.",
                "name : string": "A string that provides the \u2018name\u2019 attribute name for storing NetworkX-internal graph data.",
                "key : string": "A string that provides the \u2018key\u2019 attribute name for storing NetworkX-internal graph data.",
                "link : string": "A string that provides the \u2018link\u2019 attribute name for storing NetworkX-internal graph data."
            },
            "Returns:": {
                "data : dict": "A dictionary with node-link formatted data."
            },
            "Raises:": {
                "NetworkXError": "If the values of \u2018source\u2019, \u2018target\u2019 and \u2018key\u2019 are not unique."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Graph, node, and link attributes are stored in this format.  Note that\nattribute keys will be converted to strings in order to comply with JSON. Attribute \u2018key\u2019 is only used for multigraphs. To use node_link_data in conjunction with node_link_graph ,\nthe keyword names for the attributes must match.",
            "Examples": "G=nx.Graph([(\"A\",\"B\")])\ndata1=nx.node_link_data(G)\ndata1\n# {'directed': False, 'multigraph': False, 'graph': {}, 'nodes': [{'id': 'A'}, {'id': 'B'}], 'links': [{'source': 'A', 'target': 'B'}]}\nTo serialize with JSON\nimportjson\ns1=json.dumps(data1)\ns1\n# '{\"directed\": false, \"multigraph\": false, \"graph\": {}, \"nodes\": [{\"id\": \"A\"}, {\"id\": \"B\"}], \"links\": [{\"source\": \"A\", \"target\": \"B\"}]}'\nA graph can also be serialized by passingnode_link_dataas an encoder function. The two methods are equivalent.\ns1=json.dumps(G,default=nx.node_link_data)\ns1\n# '{\"directed\": false, \"multigraph\": false, \"graph\": {}, \"nodes\": [{\"id\": \"A\"}, {\"id\": \"B\"}], \"links\": [{\"source\": \"A\", \"target\": \"B\"}]}'\nThe attribute names for storing NetworkX-internal graph data can\nbe specified as keyword options.\nH=nx.gn_graph(2)\ndata2=nx.node_link_data(H,link=\"edges\",source=\"from\",target=\"to\")\ndata2\n# {'directed': True, 'multigraph': False, 'graph': {}, 'nodes': [{'id': 0}, {'id': 1}], 'edges': [{'from': 1, 'to': 0}]}"
        }
    },
    {
        "Section ID": "degree_centrality",
        "Description": [
            "Compute the degree centrality for nodes.",
            "The degree centrality for a node v is the fraction of nodes it\nis connected to."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph"
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of nodes with degree centrality as the value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The degree centrality values are normalized by dividing by the maximum\npossible degree in a simple graph n-1 where n is the number of nodes in G. For multigraphs or graphs with self loops the maximum degree might\nbe higher than n-1 and values of degree centrality greater than 1\nare possible.",
            "Examples": "G=nx.Graph([(0,1),(0,2),(0,3),(1,2),(1,3)])\nnx.degree_centrality(G)\n# {0: 1.0, 1: 1.0, 2: 0.6666666666666666, 3: 0.6666666666666666}"
        }
    },
    {
        "Section ID": "all_pairs_bellman_ford_path_length",
        "Description": [
            "Compute shortest path lengths between all nodes in a weighted graph."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "weight : string or function (default=\u201dweight\u201d)": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number."
            },
            "Returns:": {
                "distance : iterator": "(source, dictionary) iterator with dictionary keyed by target and\nshortest path length as the key value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The dictionary returned only has keys for reachable node pairs.",
            "Examples": "G=nx.path_graph(5)\nlength=dict(nx.all_pairs_bellman_ford_path_length(G))\nfornodein[0,1,2,3,4]:\nprint(f\"1 - {node}: {length[1][node]}\")\n# 1 - 0: 1\n# 1 - 1: 0\n# 1 - 2: 1\n# 1 - 3: 2\n# 1 - 4: 3\nlength[3][2]\n# 1\nlength[2][2]\n# 0"
        }
    },
    {
        "Section ID": "is_graphical",
        "Description": [
            "Returns True if sequence is a valid degree sequence.",
            "A degree sequence is valid if some graph can realize it."
        ],
        "Field List": {
            "Parameters:": {
                "sequence : list or iterable container": "A sequence of integer node degrees",
                "method : \u201ceg\u201d | \u201chh\u201d  (default: \u2018eg\u2019)": "The method used to validate the degree sequence.\n\u201ceg\u201d corresponds to the Erd\u0151s-Gallai algorithm[EG1960],[choudum1986], and\n\u201chh\u201d to the Havel-Hakimi algorithm[havel1955],[hakimi1962],[CL1996]."
            },
            "Returns:": {
                "valid : bool": "True if the sequence is a valid degree sequence and False if not."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[EG1960]Erd\u0151s and Gallai, Mat. Lapok 11 264, 1960.  [choudum1986]S.A. Choudum. \u201cA simple proof of the Erd\u0151s-Gallai theorem on\ngraph sequences.\u201d Bulletin of the Australian Mathematical Society, 33,\npp 67-70, 1986.https://doi.org/10.1017/S0004972700002872  [havel1955]Havel, V. \u201cA Remark on the Existence of Finite Graphs\u201d\nCasopis Pest. Mat. 80, 477-480, 1955.  [hakimi1962]Hakimi, S. \u201cOn the Realizability of a Set of Integers as\nDegrees of the Vertices of a Graph.\u201d SIAM J. Appl. Math. 10, 496-506, 1962.  [CL1996]G. Chartrand and L. Lesniak, \u201cGraphs and Digraphs\u201d,\nChapman and Hall/CRC, 1996.",
            "Examples": "G=nx.path_graph(4)\nsequence=(dforn,dinG.degree())\nnx.is_graphical(sequence)\n# True\nTo test a non-graphical sequence:\n>>> sequence_list = [d for n, d in G.degree()]\n>>> sequence_list[-1] += 1\n>>> nx.is_graphical(sequence_list)\nFalse"
        }
    },
    {
        "Section ID": "powerlaw_sequence",
        "Description": [
            "Return sample sequence of length n from a power law distribution."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "edge_current_flow_betweenness_centrality",
        "Description": [
            "Compute current-flow betweenness centrality for edges.",
            "Current-flow betweenness centrality uses an electrical current\nmodel for information spreading in contrast to betweenness\ncentrality which uses shortest paths.",
            "Current-flow betweenness centrality is also known as\nrandom-walk betweenness centrality [2] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "normalized : bool, optional (default=True)": "If True the betweenness values are normalized by 2/[(n-1)(n-2)] where\nn is the number of nodes in G.",
                "weight : string or None, optional (default=None)": "Key for edge data used as the edge weight.\nIf None, then use 1 as each edge weight.\nThe weight reflects the capacity or the strength of the\nedge.",
                "dtype : data type (default=float)": "Default data type for internal matrices.\nSet to np.float32 for lower memory consumption.",
                "solver : string (default=\u2019full\u2019)": "Type of linear solver to use for computing the flow matrix.\nOptions are \u201cfull\u201d (uses most memory), \u201clu\u201d (recommended), and\n\u201ccg\u201d (uses least memory)."
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of edge tuples with betweenness centrality as the value."
            },
            "Raises:": {
                "NetworkXError": "The algorithm does not support DiGraphs.\nIf the input graph is an instance of DiGraph class, NetworkXError\nis raised."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Current-flow betweenness can be computed in \\(O(I(n-1)+mn \\log n)\\) time [1] , where \\(I(n-1)\\) is the time needed to compute the\ninverse Laplacian.  For a full matrix this is \\(O(n^3)\\) but using\nsparse methods you can achieve \\(O(nm{\\sqrt k})\\) where \\(k\\) is the\nLaplacian matrix condition number. The space required is \\(O(nw)\\) where \\(w\\) is the width of the sparse\nLaplacian matrix.  Worse case is \\(w=n\\) for \\(O(n^2)\\) . If the edges have a \u2018weight\u2019 attribute they will be used as\nweights in this algorithm.  Unspecified weights are set to 1.",
            "References": "[1]Centrality Measures Based on Current Flow.\nUlrik Brandes and Daniel Fleischer,\nProc. 22nd Symp. Theoretical Aspects of Computer Science (STACS \u201805).\nLNCS 3404, pp. 533-544. Springer-Verlag, 2005.https://doi.org/10.1007/978-3-540-31856-9_44  [2]A measure of betweenness centrality based on random walks,\nM. E. J. Newman, Social Networks 27, 39-54 (2005)."
        }
    },
    {
        "Section ID": "bull_graph",
        "Description": [
            "Returns the Bull Graph",
            "The Bull Graph has 5 nodes and 5 edges. It is a planar undirected\ngraph in the form of a triangle with two disjoint pendant edges [1] The name comes from the triangle and pendant edges representing\nrespectively the body and legs of a bull."
        ],
        "Field List": {
            "Parameters:": {
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : networkx Graph": "A bull graph with 5 nodes"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://en.wikipedia.org/wiki/Bull_graph."
        }
    },
    {
        "Section ID": "LFR_benchmark_graph",
        "Description": [
            "Returns the LFR benchmark graph.",
            "This algorithm proceeds as follows:"
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "Number of nodes in the created graph.",
                "tau1 : float": "Power law exponent for the degree distribution of the created\ngraph. This value must be strictly greater than one.",
                "tau2 : float": "Power law exponent for the community size distribution in the\ncreated graph. This value must be strictly greater than one.",
                "mu : float": "Fraction of inter-community edges incident to each node. This\nvalue must be in the interval [0, 1].",
                "average_degree : float": "Desired average degree of nodes in the created graph. This value\nmust be in the interval [0,n]. Exactly one of this andmin_degreemust be specified, otherwise aNetworkXErroris raised.",
                "min_degree : int": "Minimum degree of nodes in the created graph. This value must be\nin the interval [0,n]. Exactly one of this andaverage_degreemust be specified, otherwise aNetworkXErroris raised.",
                "max_degree : int": "Maximum degree of nodes in the created graph. If not specified,\nthis is set ton, the total number of nodes in the graph.",
                "min_community : int": "Minimum size of communities in the graph. If not specified, this\nis set tomin_degree.",
                "max_community : int": "Maximum size of communities in the graph. If not specified, this\nis set ton, the total number of nodes in the graph.",
                "tol : float": "Tolerance when comparing floats, specifically when comparing\naverage degree values.",
                "max_iters : int": "Maximum number of iterations to try to create the community sizes,\ndegree distribution, and community affiliations.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "G : NetworkX graph": "The LFR benchmark graph generated according to the specified\nparameters.Each node in the graph has a node attribute'community'that\nstores the community (that is, the set of nodes) that includes\nit."
            },
            "Raises:": {
                "NetworkXError": "If any of the parameters do not meet their upper and lower bounds:tau1andtau2must be strictly greater than 1.mumust be in [0, 1].max_degreemust be in {1, \u2026,n}.min_communityandmax_communitymust be in {0, \u2026,n}.If not exactly one ofaverage_degreeandmin_degreeis\nspecified.Ifmin_degreeis not specified and a suitablemin_degreecannot be found.",
                "ExceededMaxIterations": "If a valid degree sequence cannot be created withinmax_itersnumber of iterations.If a valid set of community sizes cannot be created withinmax_itersnumber of iterations.If a valid community assignment cannot be created within10*n*max_itersnumber of iterations."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm differs slightly from the original way it was\npresented in [1].",
            "References": "[1]\u201cBenchmark graphs for testing community detection algorithms\u201d,\nAndrea Lancichinetti, Santo Fortunato, and Filippo Radicchi,\nPhys. Rev. E 78, 046110 2008  [2]https://www.santofortunato.net/resources",
            "Examples": "Basic usage:\nfromnetworkx.generators.communityimportLFR_benchmark_graph\nn=250\ntau1=3\ntau2=1.5\nmu=0.1\nG=LFR_benchmark_graph(\nn,tau1,tau2,mu,average_degree=5,min_community=20,seed=10\n)\nContinuing the example above, you can get the communities from the\nnode attributes of the graph:\ncommunities={frozenset(G.nodes[v][\"community\"])forvinG}"
        }
    },
    {
        "Section ID": "subgraph_centrality",
        "Description": [
            "Returns subgraph centrality for each node in G.",
            "Subgraph centrality  of a node n is the sum of weighted closed\nwalks of all lengths starting and ending at node n . The weights\ndecrease with path length. Each closed walk is associated with a\nconnected subgraph ( [1] )."
        ],
        "Field List": {
            "Parameters:": {
                "G: graph": ""
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of nodes with subgraph centrality as the value."
            },
            "Raises:": {
                "NetworkXError": "If the graph is not undirected and simple."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This version of the algorithm computes eigenvalues and eigenvectors\nof the adjacency matrix. Subgraph centrality of a node u in G can be found using\na spectral decomposition of the adjacency matrix [1] ,",
            "References": "[1](1,2,3)Ernesto Estrada, Juan A. Rodriguez-Velazquez,\n\u201cSubgraph centrality in complex networks\u201d,\nPhysical Review E 71, 056103 (2005).https://arxiv.org/abs/cond-mat/0504730",
            "Examples": "(Example from[1])\n>>> G = nx.Graph(\n\u2026     [\n\u2026         (1, 2),\n\u2026         (1, 5),\n\u2026         (1, 8),\n\u2026         (2, 3),\n\u2026         (2, 8),\n\u2026         (3, 4),\n\u2026         (3, 6),\n\u2026         (4, 5),\n\u2026         (4, 7),\n\u2026         (5, 6),\n\u2026         (6, 7),\n\u2026         (7, 8),\n\u2026     ]\n\u2026 )\n>>> sc = nx.subgraph_centrality(G)\n>>> print([f\u201d{node} {sc[node]:0.2f}\u201d for node in sorted(sc)])\n[\u20181 3.90\u2019, \u20182 3.90\u2019, \u20183 3.64\u2019, \u20184 3.71\u2019, \u20185 3.64\u2019, \u20186 3.71\u2019, \u20187 3.64\u2019, \u20188 3.90\u2019]"
        }
    },
    {
        "Section ID": "mixing_expansion",
        "Description": [
            "Returns the mixing expansion between two node sets.",
            "The mixing expansion is the quotient of the cut size and twice the\nnumber of edges in the graph. [1]"
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "S : collection": "A collection of nodes inG.",
                "T : collection": "A collection of nodes inG.",
                "weight : object": "Edge attribute key to use as weight. If not specified, edges\nhave weight one."
            },
            "Returns:": {
                "number": "The mixing expansion between the two setsSandT."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Vadhan, Salil P.\n\u201cPseudorandomness.\u201dFoundations and Trends\nin Theoretical Computer Science7.1\u20133 (2011): 1\u2013336.\n<https://doi.org/10.1561/0400000010>"
        }
    },
    {
        "Section ID": "number_of_cliques",
        "Description": [
            "Returns the number of maximal cliques for each node.",
            "Returns a single or list depending on input nodes.\nOptional list of cliques can be input if already computed."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "is_isomorphic",
        "Description": [
            "Returns True if the graphs G1 and G2 are isomorphic and False otherwise."
        ],
        "Field List": {
            "Parameters:": {
                "G1, G2: graphs": "The two graphs G1 and G2 must be the same type.",
                "node_match : callable": "A function that returns True if node n1 in G1 and n2 in G2 should\nbe considered equal during the isomorphism test.\nIf node_match is not specified then node attributes are not considered.The function will be called likenode_match(G1.nodes[n1], G2.nodes[n2]).That is, the function will receive the node attribute dictionaries\nfor n1 and n2 as inputs.",
                "edge_match : callable": "A function that returns True if the edge attribute dictionary\nfor the pair of nodes (u1, v1) in G1 and (u2, v2) in G2 should\nbe considered equal during the isomorphism test.  If edge_match is\nnot specified then edge attributes are not considered.The function will be called likeedge_match(G1[u1][v1], G2[u2][v2]).That is, the function will receive the edge attribute dictionaries\nof the edges under consideration."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Uses the vf2 algorithm [1] .",
            "References": "[1]L. P. Cordella, P. Foggia, C. Sansone, M. Vento,\n\u201cAn Improved Algorithm for Matching Large Graphs\u201d,\n3rd IAPR-TC15 Workshop  on Graph-based Representations in\nPattern Recognition, Cuen, pp. 149-159, 2001.https://www.researchgate.net/publication/200034365_An_Improved_Algorithm_for_Matching_Large_Graphs",
            "Examples": "importnetworkx.algorithms.isomorphismasiso\nFor digraphs G1 and G2, using \u2018weight\u2019 edge attribute (default: 1)\nG1=nx.DiGraph()\nG2=nx.DiGraph()\nnx.add_path(G1,[1,2,3,4],weight=1)\nnx.add_path(G2,[10,20,30,40],weight=2)\nem=iso.numerical_edge_match(\"weight\",1)\nnx.is_isomorphic(G1,G2)# no weights considered\n# True\nnx.is_isomorphic(G1,G2,edge_match=em)# match weights\n# False\nFor multidigraphs G1 and G2, using \u2018fill\u2019 node attribute (default: \u2018\u2019)\nG1=nx.MultiDiGraph()\nG2=nx.MultiDiGraph()\nG1.add_nodes_from([1,2,3],fill=\"red\")\nG2.add_nodes_from([10,20,30,40],fill=\"red\")\nnx.add_path(G1,[1,2,3,4],weight=3,linewidth=2.5)\nnx.add_path(G2,[10,20,30,40],weight=3)\nnm=iso.categorical_node_match(\"fill\",\"red\")\nnx.is_isomorphic(G1,G2,node_match=nm)\n# True\nFor multidigraphs G1 and G2, using \u2018weight\u2019 edge attribute (default: 7)\nG1.add_edge(1,2,weight=7)\n# 1\nG2.add_edge(10,20)\n# 1\nem=iso.numerical_multiedge_match(\"weight\",7,rtol=1e-6)\nnx.is_isomorphic(G1,G2,edge_match=em)\n# True\nFor multigraphs G1 and G2, using \u2018weight\u2019 and \u2018linewidth\u2019 edge attributes\nwith default values 7 and 2.5. Also using \u2018fill\u2019 node attribute with\ndefault value \u2018red\u2019.\nem=iso.numerical_multiedge_match([\"weight\",\"linewidth\"],[7,2.5])\nnm=iso.categorical_node_match(\"fill\",\"red\")\nnx.is_isomorphic(G1,G2,edge_match=em,node_match=nm)\n# True"
        }
    },
    {
        "Section ID": "ego_graph",
        "Description": [
            "Returns induced subgraph of neighbors centered at node n within\na given radius."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX Graph or DiGraph",
                "n : node": "A single node",
                "radius : number, optional": "Include all neighbors of distance<=radius from n.",
                "center : bool, optional": "If False, do not include center node in graph",
                "undirected : bool, optional": "If True use both in- and out-neighbors of directed graphs.",
                "distance : key, optional": "Use specified edge data key as distance.  For example, setting\ndistance=\u2019weight\u2019 will use the edge weight to measure the\ndistance from the node n."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "For directed graphs D this produces the \u201cout\u201d neighborhood\nor successors.  If you want the neighborhood of predecessors\nfirst reverse the graph with D.reverse().  If you want both\ndirections use the keyword argument undirected=True. Node, edge, and graph attributes are copied to the returned subgraph."
        }
    },
    {
        "Section ID": "greedy_modularity_communities",
        "Description": [
            "Find communities in G using greedy modularity maximization.",
            "This function uses Clauset-Newman-Moore greedy modularity maximization [2] to find the community partition with the largest modularity.",
            "Greedy modularity maximization begins with each node in its own community\nand repeatedly joins the pair of communities that lead to the largest\nmodularity until no further increase in modularity is possible (a maximum).\nTwo keyword arguments adjust the stopping condition. cutoff is a lower\nlimit on the number of communities so you can stop the process before\nreaching a maximum (used to save computation time). best_n is an upper\nlimit on the number of communities so you can make the process continue\nuntil at most n communities remain even if the maximum modularity occurs\nfor more. To obtain exactly n communities, set both cutoff and best_n to n.",
            "This function maximizes the generalized modularity, where resolution is the resolution parameter, often expressed as \\(\\gamma\\) .\nSee modularity() ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "weight : string or None, optional (default=None)": "The name of an edge attribute that holds the numerical value used\nas a weight.  If None, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node.",
                "resolution : float, optional (default=1)": "If resolution is less than 1, modularity favors larger communities.\nGreater than 1 favors smaller communities.",
                "cutoff : int, optional (default=1)": "A minimum number of communities below which the merging process stops.\nThe process stops at this number of communities even if modularity\nis not maximized. The goal is to let the user stop the process early.\nThe process stops before the cutoff if it finds a maximum of modularity.",
                "best_n : int or None, optional (default=None)": "A maximum number of communities above which the merging process will\nnot stop. This forces community merging to continue after modularity\nstarts to decrease untilbest_ncommunities remain.\nIfNone, don\u2019t force it to continue beyond a maximum."
            },
            "Returns:": {
                "communities: list": "A list of frozensets of nodes, one for each community.\nSorted by length with largest communities first."
            },
            "Raises:": {
                "ValueError : If thecutofforbest_nvalue is not in the range": "[1,G.number_of_nodes()], or ifbest_n<cutoff."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Newman, M. E. J. \u201cNetworks: An Introduction\u201d, page 224\nOxford University Press 2011.  [2]Clauset, A., Newman, M. E., & Moore, C.\n\u201cFinding community structure in very large networks.\u201d\nPhysical Review E 70(6), 2004.  [3]Reichardt and Bornholdt \u201cStatistical Mechanics of Community\nDetection\u201d Phys. Rev. E74, 2006.  [4]Newman, M. E. J.\u201dAnalysis of weighted networks\u201d\nPhysical Review E 70(5 Pt 2):056131, 2004.",
            "Examples": "G=nx.karate_club_graph()\nc=nx.community.greedy_modularity_communities(G)\nsorted(c[0])\n# [8, 14, 15, 18, 20, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33]"
        }
    },
    {
        "Section ID": "neighbors",
        "Description": [
            "Returns an iterator over all neighbors of node n.",
            "This function wraps the G.neighbors function."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "random_weighted_sample",
        "Description": [
            "Returns k items without replacement from a weighted sample.",
            "The input is a dictionary of items with weights as values."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "strategy_independent_set",
        "Description": [
            "Uses a greedy independent set removal strategy to determine the\ncolors.",
            "This function updates colors  in-place and return None ,\nunlike the other strategy functions in this module.",
            "This algorithm repeatedly finds and removes a maximal independent\nset, assigning each node in the set an unused color.",
            "G is a NetworkX graph.",
            "This strategy is related to strategy_smallest_last() : in that\nstrategy, an independent set of size one is chosen at each step\ninstead of a maximal independent set."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "is_chordal",
        "Description": [
            "Checks whether G is a chordal graph.",
            "A graph is chordal if every cycle of length at least 4 has a chord\n(an edge joining two nodes not adjacent in the cycle)."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph."
            },
            "Returns:": {
                "chordal : bool": "True if G is a chordal graph and False otherwise."
            },
            "Raises:": {
                "NetworkXNotImplemented": "The algorithm does not support DiGraph, MultiGraph and MultiDiGraph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The routine tries to go through every node following maximum cardinality\nsearch. It returns False when it finds that the separator for any node\nis not a clique.  Based on the algorithms in [1] . Self loops are ignored.",
            "References": "[1]R. E. Tarjan and M. Yannakakis, Simple linear-time algorithms\nto test chordality of graphs, test acyclicity of hypergraphs, and\nselectively reduce acyclic hypergraphs, SIAM J. Comput., 13 (1984),\npp. 566\u2013579.",
            "Examples": "e=[\n(1,2),\n(1,3),\n(2,3),\n(2,4),\n(3,4),\n(3,5),\n(3,6),\n(4,5),\n(4,6),\n(5,6),\n]\nG=nx.Graph(e)\nnx.is_chordal(G)\n# True"
        }
    },
    {
        "Section ID": "approximate_current_flow_betweenness_centrality",
        "Description": [
            "Compute the approximate current-flow betweenness centrality for nodes.",
            "Approximates the current-flow betweenness centrality within absolute\nerror of epsilon with high probability [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A NetworkX graph",
                "normalized : bool, optional (default=True)": "If True the betweenness values are normalized by 2/[(n-1)(n-2)] where\nn is the number of nodes in G.",
                "weight : string or None, optional (default=None)": "Key for edge data used as the edge weight.\nIf None, then use 1 as each edge weight.\nThe weight reflects the capacity or the strength of the\nedge.",
                "dtype : data type (float)": "Default data type for internal matrices.\nSet to np.float32 for lower memory consumption.",
                "solver : string (default=\u2019full\u2019)": "Type of linear solver to use for computing the flow matrix.\nOptions are \u201cfull\u201d (uses most memory), \u201clu\u201d (recommended), and\n\u201ccg\u201d (uses least memory).",
                "epsilon: float": "Absolute error tolerance.",
                "kmax: int": "Maximum number of sample node pairs to use for approximation.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
            },
            "Returns:": {
                "nodes : dictionary": "Dictionary of nodes with betweenness centrality as the value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The running time is \\(O((1/\\epsilon^2)m{\\sqrt k} \\log n)\\) and the space required is \\(O(m)\\) for \\(n\\) nodes and \\(m\\) edges. If the edges have a \u2018weight\u2019 attribute they will be used as\nweights in this algorithm.  Unspecified weights are set to 1.",
            "References": "[1]Ulrik Brandes and Daniel Fleischer:\nCentrality Measures Based on Current Flow.\nProc. 22nd Symp. Theoretical Aspects of Computer Science (STACS \u201805).\nLNCS 3404, pp. 533-544. Springer-Verlag, 2005.https://doi.org/10.1007/978-3-540-31856-9_44"
        }
    },
    {
        "Section ID": "is_bipartite",
        "Description": [
            "Returns True if graph G is bipartite, False if not."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": ""
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "fromnetworkx.algorithmsimportbipartite\nG=nx.path_graph(4)\nprint(bipartite.is_bipartite(G))\n# True"
        }
    },
    {
        "Section ID": "kl_connected_subgraph",
        "Description": [
            "Returns the maximum locally (k,l) -connected subgraph of G .",
            "A graph is locally (k,l) -connected if for each edge (u,v) in the\ngraph there are at least l edge-disjoint paths of length at most k joining u to v ."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "The graph in which to find a maximum locally(k,l)-connected\nsubgraph.",
                "k : integer": "The maximum length of paths to consider. A higher number means a looser\nconnectivity requirement.",
                "l : integer": "The number of edge-disjoint paths. A higher number means a stricter\nconnectivity requirement.",
                "low_memory : bool": "If this is True, this function uses an algorithm that uses slightly\nmore time but less memory.",
                "same_as_graph : bool": "If True then return a tuple of the form(H,is_same),\nwhereHis the maximum locally(k,l)-connected subgraph andis_sameis a Boolean representing whetherGis locally(k,l)-connected (and hence, whetherHis simply a copy of the input\ngraphG)."
            },
            "Returns:": {
                "NetworkX graph or two-tuple": "Ifsame_as_graphis True, then this function returns a\ntwo-tuple as described above. Otherwise, it returns only the maximum\nlocally(k,l)-connected subgraph."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Chung, Fan and Linyuan Lu. \u201cThe Small World Phenomenon in Hybrid\nPower Law Graphs.\u201dComplex Networks. Springer Berlin Heidelberg,\n2004. 89\u2013104."
        }
    },
    {
        "Section ID": "house_x_graph",
        "Description": [
            "Returns the House graph with a cross inside the house square.",
            "The House X-graph is the House graph plus the two edges connecting diagonally\nopposite vertices of the square base. It is also one of the two graphs\nobtained by removing two edges from the pentatope graph [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
            },
            "Returns:": {
                "G : networkx Graph": "House graph with diagonal vertices connected"
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]https://mathworld.wolfram.com/HouseGraph.html"
        }
    },
    {
        "Section ID": "edge_betweenness_centrality_subset",
        "Description": [
            "Compute betweenness centrality for edges for a subset of nodes.",
            "where \\(S\\) is the set of sources, \\(T\\) is the set of targets, \\(\\sigma(s, t)\\) is the number of shortest \\((s, t)\\) -paths,\nand \\(\\sigma(s, t|e)\\) is the number of those paths\npassing through edge \\(e\\)  [2] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : graph": "A networkx graph.",
                "sources: list of nodes": "Nodes to use as sources for shortest paths in betweenness",
                "targets: list of nodes": "Nodes to use as targets for shortest paths in betweenness",
                "normalized : bool, optional": "If True the betweenness values are normalized by2/(n(n-1))for graphs, and1/(n(n-1))for directed graphs wherenis the number of nodes in G.",
                "weight : None or string, optional (default=None)": "If None, all edge weights are considered equal.\nOtherwise holds the name of the edge attribute used as weight.\nWeights are used to calculate weighted shortest paths, so they are\ninterpreted as distances."
            },
            "Returns:": {
                "edges : dictionary": "Dictionary of edges with Betweenness centrality as the value."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The basic algorithm is from [1] . For weighted graphs the edge weights must be greater than zero.\nZero edge weights can produce an infinite number of equal length\npaths between pairs of nodes. The normalization might seem a little strange but it is the same\nas in edge_betweenness_centrality() and is designed to make\nedge_betweenness_centrality(G) be the same as\nedge_betweenness_centrality_subset(G,sources=G.nodes(),targets=G.nodes()).",
            "References": "[1]Ulrik Brandes, A Faster Algorithm for Betweenness Centrality.\nJournal of Mathematical Sociology 25(2):163-177, 2001.https://doi.org/10.1080/0022250X.2001.9990249  [2]Ulrik Brandes: On Variants of Shortest-Path Betweenness\nCentrality and their Generic Computation.\nSocial Networks 30(2):136-145, 2008.https://doi.org/10.1016/j.socnet.2007.11.001"
        }
    },
    {
        "Section ID": "read_dot",
        "Description": [
            "Returns a NetworkX MultiGraph or MultiDiGraph from the\ndot file with the passed path.",
            "If this file contains multiple graphs, only the first such graph is\nreturned. All graphs _except_ the first are silently ignored."
        ],
        "Field List": {
            "Parameters:": {
                "path : str or file": "Filename or file handle."
            },
            "Returns:": {
                "G : MultiGraph or MultiDiGraph": "AMultiGraphorMultiDiGraph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Use G=nx.Graph(nx.nx_pydot.read_dot(path)) to return a Graph instead of a MultiGraph ."
        }
    },
    {
        "Section ID": "global_efficiency",
        "Description": [
            "Returns the average global efficiency of the graph.",
            "The efficiency of a pair of nodes in a graph is the multiplicative\ninverse of the shortest path distance between the nodes. The average\nglobal efficiency of a graph is the average efficiency of all pairs of\nnodes [1] ."
        ],
        "Field List": {
            "Parameters:": {
                "G : networkx.Graph": "An undirected graph for which to compute the average global efficiency."
            },
            "Returns:": {
                "float": "The average global efficiency of the graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Edge weights are ignored when computing the shortest path distances.",
            "References": "[1]Latora, Vito, and Massimo Marchiori.\n\u201cEfficient behavior of small-world networks.\u201dPhysical Review Letters87.19 (2001): 198701.\n<https://doi.org/10.1103/PhysRevLett.87.198701>",
            "Examples": "G=nx.Graph([(0,1),(0,2),(0,3),(1,2),(1,3)])\nround(nx.global_efficiency(G),12)\n# 0.916666666667"
        }
    },
    {
        "Section ID": "edmonds_karp",
        "Description": [
            "Find a maximum single-commodity flow using the Edmonds-Karp algorithm.",
            "This function returns the residual network resulting after computing\nthe maximum flow. See below for details about the conventions\nNetworkX uses for defining residual networks.",
            "This algorithm has a running time of \\(O(n m^2)\\) for \\(n\\) nodes and \\(m\\) edges."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Edges of the graph are expected to have an attribute called\n\u2018capacity\u2019. If this attribute is not present, the edge is\nconsidered to have infinite capacity.",
                "s : node": "Source node for the flow.",
                "t : node": "Sink node for the flow.",
                "capacity : string": "Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: \u2018capacity\u2019.",
                "residual : NetworkX graph": "Residual network on which the algorithm is to be executed. If None, a\nnew residual network is created. Default value: None.",
                "value_only : bool": "If True compute only the value of the maximum flow. This parameter\nwill be ignored by this algorithm because it is not applicable.",
                "cutoff : integer, float": "If specified, the algorithm will terminate when the flow value reaches\nor exceeds the cutoff. In this case, it may be unable to immediately\ndetermine a minimum cut. Default value: None."
            },
            "Returns:": {
                "R : NetworkX DiGraph": "Residual network after computing the maximum flow."
            },
            "Raises:": {
                "NetworkXError": "The algorithm does not support MultiGraph and MultiDiGraph. If\nthe input graph is an instance of one of these two classes, a\nNetworkXError is raised.",
                "NetworkXUnbounded": "If the graph has a path of infinite capacity, the value of a\nfeasible flow on the graph is unbounded above and the function\nraises a NetworkXUnbounded."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The residual network R from an input graph G has the\nsame nodes as G . R is a DiGraph that contains a pair\nof edges (u,v) and (v,u) iff (u,v) is not a\nself-loop, and at least one of (u,v) and (v,u) exists\nin G . For each edge (u,v) in R , R[u][v]['capacity'] is equal to the capacity of (u,v) in G if it exists\nin G or zero otherwise. If the capacity is infinite, R[u][v]['capacity'] will have a high arbitrary finite value\nthat does not affect the solution of the problem. This value is stored in R.graph['inf'] . For each edge (u,v) in R , R[u][v]['flow'] represents the flow function of (u,v) and\nsatisfies R[u][v]['flow']==-R[v][u]['flow'] . The flow value, defined as the total flow into t , the sink, is\nstored in R.graph['flow_value'] . If cutoff is not\nspecified, reachability to t using only edges (u,v) such\nthat R[u][v]['flow']<R[u][v]['capacity'] induces a minimum s - t cut.",
            "Examples": "fromnetworkx.algorithms.flowimportedmonds_karp\nThe functions that implement flow algorithms and output a residual\nnetwork, such as this one, are not imported to the base NetworkX\nnamespace, so you have to explicitly import them from the flow package.\nG=nx.DiGraph()\nG.add_edge(\"x\",\"a\",capacity=3.0)\nG.add_edge(\"x\",\"b\",capacity=1.0)\nG.add_edge(\"a\",\"c\",capacity=3.0)\nG.add_edge(\"b\",\"c\",capacity=5.0)\nG.add_edge(\"b\",\"d\",capacity=4.0)\nG.add_edge(\"d\",\"e\",capacity=2.0)\nG.add_edge(\"c\",\"y\",capacity=2.0)\nG.add_edge(\"e\",\"y\",capacity=3.0)\nR=edmonds_karp(G,\"x\",\"y\")\nflow_value=nx.maximum_flow_value(G,\"x\",\"y\")\nflow_value\n# 3.0\nflow_value==R.graph[\"flow_value\"]\n# True"
        }
    },
    {
        "Section ID": "gnm_random_graph",
        "Description": [
            "Returns a \\(G_{n,m}\\) random graph.",
            "In the \\(G_{n,m}\\) model, a graph is chosen uniformly at random from the set\nof all graphs with \\(n\\) nodes and \\(m\\) edges.",
            "This algorithm should be faster than dense_gnm_random_graph() for\nsparse graphs."
        ],
        "Field List": {
            "Parameters:": {
                "n : int": "The number of nodes.",
                "m : int": "The number of edges.",
                "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness.",
                "directed : bool, optional (default=False)": "If True return a directed graph"
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "bridges",
        "Description": [
            "Generate all bridges in a graph.",
            "A bridge in a graph is an edge whose removal causes the number of\nconnected components of the graph to increase.  Equivalently, a bridge is an\nedge that does not belong to any cycle. Bridges are also known as cut-edges,\nisthmuses, or cut arcs."
        ],
        "Field List": {
            "Parameters:": {
                "G : undirected graph": "",
                "root : node (optional)": "A node in the graphG. If specified, only the bridges in the\nconnected component containing this node will be returned."
            },
            "Yields:": {
                "e : edge": "An edge in the graph whose removal disconnects the graph (or\ncauses the number of connected components to increase)."
            },
            "Raises:": {
                "NodeNotFound": "Ifrootis not in the graphG.",
                "NetworkXNotImplemented": "IfGis a directed graph."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This is an implementation of the algorithm described in [1] .  An edge is a\nbridge if and only if it is not contained in any chain. Chains are found\nusing the networkx.chain_decomposition() function. The algorithm described in [1] requires a simple graph. If the provided\ngraph is a multigraph, we convert it to a simple graph and verify that any\nbridges discovered by the chain decomposition algorithm are not multi-edges. Ignoring polylogarithmic factors, the worst-case time complexity is the\nsame as the networkx.chain_decomposition() function, \\(O(m + n)\\) , where \\(n\\) is the number of nodes in the graph and \\(m\\) is\nthe number of edges.",
            "References": "[1](1,2)https://en.wikipedia.org/wiki/Bridge_%28graph_theory%29#Bridge-Finding_with_Chain_Decompositions",
            "Examples": "The barbell graph with parameter zero has a single bridge:\nG=nx.barbell_graph(10,0)\nlist(nx.bridges(G))\n# [(9, 10)]"
        }
    },
    {
        "Section ID": "edges_equal",
        "Description": [
            "Check if edges are equal.",
            "Equality here means equal as Python objects.\nEdge data must match if included.\nThe order of the edges is not relevant."
        ],
        "Field List": {
            "Parameters:": {
                "edges1, edges2 : iterables of with u, v nodes as": "edge tuples (u, v), or\nedge tuples with data dicts (u, v, d), or\nedge tuples with keys and data dicts (u, v, k, d)"
            },
            "Returns:": {
                "bool": "True if edges are equal, False otherwise."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "closeness_vitality",
        "Description": [
            "Returns the closeness vitality for nodes in the graph.",
            "The closeness vitality of a node, defined in Section 3.6.2 of [1],\nis the change in the sum of distances between all node pairs when\nexcluding that node."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "A strongly-connected graph.",
                "weight : string": "The name of the edge attribute used as weight. This is passed\ndirectly to thewiener_index()function.",
                "node : object": "If specified, only the closeness vitality for this node will be\nreturned. Otherwise, a dictionary mapping each node to its\ncloseness vitality will be returned."
            },
            "Returns:": {
                "dictionary or float": "Ifnodeis None, this function returns a dictionary\nwith nodes as keys and closeness vitality as the\nvalue. Otherwise, it returns only the closeness vitality for the\nspecifiednode.The closeness vitality of a node may be negative infinity if\nremoving that node would disconnect the graph."
            },
            "Other Parameters:": {
                "wiener_index : number": "If you have already computed the Wiener index of the graphG, you can provide that value here. Otherwise, it will be\ncomputed for you."
            },
            "Methods": []
        },
        "Rubrics": {
            "References": "[1]Ulrik Brandes, Thomas Erlebach (eds.).Network Analysis: Methodological Foundations.\nSpringer, 2005.\n<http://books.google.com/books?id=TTNhSm7HYrIC>",
            "Examples": "G=nx.cycle_graph(3)\nnx.closeness_vitality(G)\n# {0: 2.0, 1: 2.0, 2: 2.0}"
        }
    },
    {
        "Section ID": "floyd_warshall",
        "Description": [
            "Find all-pairs shortest path lengths using Floyd\u2019s algorithm."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "",
                "weight: string, optional (default= \u2018weight\u2019)": "Edge data key corresponding to the edge weight."
            },
            "Returns:": {
                "distance : dict": "A dictionary,  keyed by source and target, of shortest paths distances\nbetween nodes."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "Floyd\u2019s algorithm is appropriate for finding shortest paths\nin dense graphs or graphs with negative weights when Dijkstra\u2019s algorithm\nfails.  This algorithm can still fail if there are negative cycles.\nIt has running time \\(O(n^3)\\) with running space of \\(O(n^2)\\) .",
            "Examples": "G=nx.DiGraph()\nG.add_weighted_edges_from([(0,1,5),(1,2,2),(2,3,-3),(1,3,10),(3,2,8)])\nfw=nx.floyd_warshall(G,weight=\"weight\")\nresults={a:dict(b)fora,binfw.items()}\nprint(results)\n# {0: {0: 0, 1: 5, 2: 7, 3: 4}, 1: {1: 0, 2: 2, 3: -1, 0: inf}, 2: {2: 0, 3: -3, 0: inf, 1: inf}, 3: {3: 0, 2: 8, 0: inf, 1: inf}}"
        }
    },
    {
        "Section ID": "reverse_havel_hakimi_graph",
        "Description": [
            "Returns a bipartite graph from two given degree sequences using a\nHavel-Hakimi style construction.",
            "The graph is composed of two partitions. Set A has nodes 0 to\n(len(aseq) - 1) and set B has nodes len(aseq) to (len(bseq) - 1).\nNodes from set A are connected to nodes in the set B by connecting\nthe highest degree nodes in set A to the lowest degree nodes in\nset B until all stubs are connected."
        ],
        "Field List": {
            "Parameters:": {
                "aseq : list": "Degree sequence for node set A.",
                "bseq : list": "Degree sequence for node set B.",
                "create_using : NetworkX graph instance, optional": "Return graph of this type."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The sum of the two sequences must be equal: sum(aseq)=sum(bseq)\nIf no graph type is specified use MultiGraph with parallel edges.\nIf you want a graph with no parallel edges use create_using=Graph()\nbut then the resulting degree sequences might not be exact. The nodes are assigned the attribute \u2018bipartite\u2019 with the value 0 or 1\nto indicate which bipartite set the node belongs to. This function is not imported in the main namespace.\nTo use it use nx.bipartite.reverse_havel_hakimi_graph"
        }
    },
    {
        "Section ID": "FilterAtlas",
        "Description": [
            "A read-only Mapping of Mappings with filtering criteria for nodes.",
            "It is a view into a dict-of-dict data structure, and it selects only\nnodes that meet the criteria defined by NODE_OK ."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "graph_atlas_g",
        "Description": [
            "Returns the list of all graphs with up to seven nodes named in the\nGraph Atlas.",
            "The graphs are listed in increasing order by",
            "in that order, with three exceptions as described in the Notes section below. This causes the list to correspond with the index of\nthe graphs in the Graph Atlas [atlas] , with the first graph, G[0] , being the null graph."
        ],
        "Field List": {
            "Returns:": {
                "list": "A list ofGraphobjects, the one at indexicorresponding to the graphiin the Graph Atlas."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This function may be expensive in both time and space, since it\nreads a large file sequentially in order to populate the list. Although the NetworkX atlas functions match the order of graphs\ngiven in the \u201cAtlas of Graphs\u201d book, there are (at least) three\nerrors in the ordering described in the book. The following three\npairs of nodes violate the lexicographically nondecreasing sorted\ndegree sequence rule:",
            "References": "[atlas]Ronald C. Read and Robin J. Wilson,An Atlas of Graphs.\nOxford University Press, 1998."
        }
    },
    {
        "Section ID": "set_node_attributes",
        "Description": [
            "Sets node attributes from a given value or dictionary of values."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX Graph": "",
                "values : scalar value, dict-like": "What the node attribute should be set to.  Ifvaluesis\nnot a dictionary, then it is treated as a single attribute value\nthat is then applied to every node inG.  This means that if\nyou provide a mutable object, like a list, updates to that object\nwill be reflected in the node attribute for every node.\nThe attribute name will bename.Ifvaluesis a dict or a dict of dict, it should be keyed\nby node to either an attribute value or a dict of attribute key/value\npairs used to update the node\u2019s attributes.",
                "name : string (optional, default=None)": "Name of the node attribute to set if values is a scalar."
            },
            "Methods": []
        },
        "Rubrics": {
            "Examples": "After computing some property of the nodes of a graph, you may want\nto assign a node attribute to store the value of that property for\neach node:\nG=nx.path_graph(3)\nbb=nx.betweenness_centrality(G)\nisinstance(bb,dict)\n# True\nnx.set_node_attributes(G,bb,\"betweenness\")\nG.nodes[1][\"betweenness\"]\n# 1.0\nIf you provide a list as the second argument, updates to the list\nwill be reflected in the node attribute for each node:\nG=nx.path_graph(3)\nlabels=[]\nnx.set_node_attributes(G,labels,\"labels\")\nlabels.append(\"foo\")\nG.nodes[0][\"labels\"]\n# ['foo']\nG.nodes[1][\"labels\"]\n# ['foo']\nG.nodes[2][\"labels\"]\n# ['foo']\nIf you provide a dictionary of dictionaries as the second argument,\nthe outer dictionary is assumed to be keyed by node to an inner\ndictionary of node attributes for that node:\nG=nx.path_graph(3)\nattrs={0:{\"attr1\":20,\"attr2\":\"nothing\"},1:{\"attr2\":3}}\nnx.set_node_attributes(G,attrs)\nG.nodes[0][\"attr1\"]\n# 20\nG.nodes[0][\"attr2\"]\n# 'nothing'\nG.nodes[1][\"attr2\"]\n# 3\nG.nodes[2]\n# {}\nNote that if the dictionary contains nodes that are not inG, the\nvalues are silently ignored:\nG=nx.Graph()\nG.add_node(0)\nnx.set_node_attributes(G,{0:\"red\",1:\"blue\"},name=\"color\")\nG.nodes[0][\"color\"]\n# 'red'\n1inG.nodes\n# False"
        }
    },
    {
        "Section ID": "min_cost_flow",
        "Description": [
            "Returns a minimum cost flow satisfying all demands in digraph G.",
            "G is a digraph with edge costs and capacities and in which nodes\nhave demand, i.e., they want to send or receive some amount of\nflow. A negative demand means that the node wants to send flow, a\npositive demand means that the node want to receive flow. A flow on\nthe digraph G satisfies all demand if the net flow into each node\nis equal to the demand of that node."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "DiGraph on which a minimum cost flow satisfying all demands is\nto be found.",
                "demand : string": "Nodes of the graph G are expected to have an attribute demand\nthat indicates how much flow a node wants to send (negative\ndemand) or receive (positive demand). Note that the sum of the\ndemands should be 0 otherwise the problem in not feasible. If\nthis attribute is not present, a node is considered to have 0\ndemand. Default value: \u2018demand\u2019.",
                "capacity : string": "Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: \u2018capacity\u2019.",
                "weight : string": "Edges of the graph G are expected to have an attribute weight\nthat indicates the cost incurred by sending one unit of flow on\nthat edge. If not present, the weight is considered to be 0.\nDefault value: \u2018weight\u2019."
            },
            "Returns:": {
                "flowDict : dictionary": "Dictionary of dictionaries keyed by nodes such that\nflowDict[u][v] is the flow edge (u, v)."
            },
            "Raises:": {
                "NetworkXError": "This exception is raised if the input graph is not directed or\nnot connected.",
                "NetworkXUnfeasible": "This exception is raised in the following situations:The sum of the demands is not zero. Then, there is no\nflow satisfying all demands.There is no flow satisfying all demand.",
                "NetworkXUnbounded": "This exception is raised if the digraph G has a cycle of\nnegative cost and infinite capacity. Then, the cost of a flow\nsatisfying all demands is unbounded below."
            },
            "Methods": []
        },
        "Rubrics": {
            "Notes": "This algorithm is not guaranteed to work if edge weights or demands\nare floating point numbers (overflows and roundoff errors can\ncause problems). As a workaround you can use integer numbers by\nmultiplying the relevant edge attributes by a convenient\nconstant factor (eg 100).",
            "Examples": "A simple example of a min cost flow problem.\nG=nx.DiGraph()\nG.add_node(\"a\",demand=-5)\nG.add_node(\"d\",demand=5)\nG.add_edge(\"a\",\"b\",weight=3,capacity=4)\nG.add_edge(\"a\",\"c\",weight=6,capacity=10)\nG.add_edge(\"b\",\"d\",weight=1,capacity=9)\nG.add_edge(\"c\",\"d\",weight=2,capacity=5)\nflowDict=nx.min_cost_flow(G)\nflowDict\n# {'a': {'b': 4, 'c': 1}, 'd': {}, 'b': {'d': 4}, 'c': {'d': 1}}"
        }
    },
    {
        "Section ID": "min_weight_matching",
        "Description": [
            "Computing a minimum-weight maximal matching of G.",
            "Use the maximum-weight algorithm with edge weights subtracted\nfrom the maximum weight of all edges.",
            "A matching is a subset of edges in which no node occurs more than once.\nThe weight of a matching is the sum of the weights of its edges.\nA maximal matching cannot add more edges and still be a matching.\nThe cardinality of a matching is the number of matched edges.",
            "This method replaces the edge weights with 1 plus the maximum edge weight\nminus the original edge weight.",
            "new_weight = (max_weight + 1) - edge_weight",
            "then runs max_weight_matching() with the new weights.\nThe max weight matching with these new weights corresponds\nto the min weight matching using the original weights.\nAdding 1 to the max edge weight keeps all edge weights positive\nand as integers if they started as integers.",
            "You might worry that adding 1 to each weight would make the algorithm\nfavor matchings with more edges. But we use the parameter maxcardinality=True in max_weight_matching to ensure that the\nnumber of edges in the competing matchings are the same and thus\nthe optimum does not change due to changes in the number of edges.",
            "Read the documentation of max_weight_matching for more information."
        ],
        "Field List": {
            "Parameters:": {
                "G : NetworkX graph": "Undirected graph",
                "weight: string, optional (default=\u2019weight\u2019)": "Edge data key corresponding to the edge weight.\nIf key not found, uses 1 as weight."
            },
            "Returns:": {
                "matching : set": "A minimal weight matching of the graph."
            },
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "density",
        "Description": [
            "Returns the density of a graph.",
            "The density for undirected graphs is",
            "and for directed graphs is",
            "where n is the number of nodes and m is the number of edges in G .",
            "Notes",
            "The density is 0 for a graph without edges and 1 for a complete graph.\nThe density of multigraphs can be higher than 1.",
            "Self loops are counted in the total number of edges so graphs with self\nloops can have density higher than 1."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {
            "Notes": "The density is 0 for a graph without edges and 1 for a complete graph.\nThe density of multigraphs can be higher than 1. Self loops are counted in the total number of edges so graphs with self\nloops can have density higher than 1."
        }
    },
    {
        "Section ID": "write_dot",
        "Description": [
            "Write NetworkX graph G to Graphviz dot format on path.",
            "Path can be a string or a file handle."
        ],
        "Field List": {
            "Methods": []
        },
        "Rubrics": {}
    },
    {
        "Section ID": "Graph",
        "Description": [
            "Base class for undirected graphs.",
            "A Graph stores nodes and edges with optional data, or attributes.",
            "Graphs hold undirected edges.  Self loops are allowed but multiple\n(parallel) edges are not.",
            "Nodes can be arbitrary (hashable) Python objects with optional\nkey/value attributes, except that None is not allowed as a node.",
            "Edges are represented as links between nodes with optional\nkey/value attributes."
        ],
        "Field List": {
            "Parameters:": {
                "incoming_graph_data : input graph (optional, default: None)": "Data to initialize graph. If None (default) an empty\ngraph is created.  The data can be any format that is supported\nby the to_networkx_graph() function, currently including edge list,\ndict of dicts, dict of lists, NetworkX graph, 2D NumPy array, SciPy\nsparse matrix, or PyGraphviz graph.",
                "attr : keyword arguments, optional (default= no attributes)": "Attributes to add to graph as key=value pairs."
            },
            "Methods": [
                {
                    "Section ID": "__init__",
                    "Path": "networkx.Graph",
                    "Description": [
                        "Initialize a graph with edges, name, or graph attributes."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "incoming_graph_data : input graph (optional, default: None)": "Data to initialize graph. If None (default) an empty\ngraph is created.  The data can be an edge list, or any\nNetworkX graph object.  If the corresponding optional Python\npackages are installed the data can also be a 2D NumPy array, a\nSciPy sparse array, or a PyGraphviz graph.",
                            "attr : keyword arguments, optional (default= no attributes)": "Attributes to add to graph as key=value pairs."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG=nx.Graph(name=\"my graph\")\ne=[(1,2),(2,3),(3,4)]# list of edges\nG=nx.Graph(e)\nArbitrary graph attribute pairs (key=value) may be assigned\nG=nx.Graph(e,day=\"Friday\")\nG.graph\n# {'day': 'Friday'}"
                    }
                },
                {
                    "Section ID": "add_node",
                    "Path": "networkx.Graph",
                    "Description": [
                        "Add a single node node_for_adding and update node attributes."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "node_for_adding : node": "A node can be any hashable Python object except None.",
                            "attr : keyword arguments, optional": "Set or change node attributes using key=value."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "A hashable object is one that can be used as a key in a Python\ndictionary. This includes strings, numbers, tuples of strings\nand numbers, etc. On many platforms hashable items also include mutables such as\nNetworkX Graphs, though one should be careful that the hash\ndoesn\u2019t change on mutables.",
                        "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_node(1)\nG.add_node(\"Hello\")\nK3=nx.Graph([(0,1),(1,2),(2,0)])\nG.add_node(K3)\nG.number_of_nodes()\n# 3\nUse keywords set/change node attributes:\nG.add_node(1,size=10)\nG.add_node(3,weight=0.4,UTM=(\"13S\",382871,3972649))"
                    }
                },
                {
                    "Section ID": "add_nodes_from",
                    "Path": "networkx.Graph",
                    "Description": [
                        "Add multiple nodes."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "nodes_for_adding : iterable container": "A container of nodes (list, dict, set, etc.).\nOR\nA container of (node, attribute dict) tuples.\nNode attributes are updated using the attribute dict.",
                            "attr : keyword arguments, optional (default= no attributes)": "Update attributes for all nodes in nodes.\nNode attributes specified in nodes as a tuple take\nprecedence over attributes specified via keyword arguments."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "When adding nodes from an iterator over the graph you are changing,\na RuntimeError can be raised with message: RuntimeError:dictionarychangedsizeduringiteration . This\nhappens when the graph\u2019s underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using list(iterator_of_nodes) , and pass this\nobject to G.add_nodes_from .",
                        "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_nodes_from(\"Hello\")\nK3=nx.Graph([(0,1),(1,2),(2,0)])\nG.add_nodes_from(K3)\nsorted(G.nodes(),key=str)\n# [0, 1, 2, 'H', 'e', 'l', 'o']\nUse keywords to update specific node attributes for every node.\nG.add_nodes_from([1,2],size=10)\nG.add_nodes_from([3,4],weight=0.4)\nUse (node, attrdict) tuples to update attributes for specific nodes.\nG.add_nodes_from([(1,dict(size=11)),(2,{\"color\":\"blue\"})])\nG.nodes[1][\"size\"]\n# 11\nH=nx.Graph()\nH.add_nodes_from(G.nodes(data=True))\nH.nodes[1][\"size\"]\n# 11\nEvaluate an iterator over a graph if using it to modify the same graph\nG=nx.Graph([(0,1),(1,2),(3,4)])\n# wrong way - will raise RuntimeError\n# G.add_nodes_from(n + 1 for n in G.nodes)\n# correct way\nG.add_nodes_from(list(n+1forninG.nodes))"
                    }
                },
                {
                    "Section ID": "remove_node",
                    "Path": "networkx.Graph",
                    "Description": [
                        "Remove node n.",
                        "Removes the node n and all adjacent edges.\nAttempting to remove a nonexistent node will raise an exception."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "n : node": "A node in the graph"
                        },
                        "Raises:": {
                            "NetworkXError": "If n is not in the graph."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(3)# or DiGraph, MultiGraph, MultiDiGraph, etc\nlist(G.edges)\n# [(0, 1), (1, 2)]\nG.remove_node(1)\nlist(G.edges)\n# []"
                    }
                },
                {
                    "Section ID": "remove_nodes_from",
                    "Path": "networkx.Graph",
                    "Description": [
                        "Remove multiple nodes."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "nodes : iterable container": "A container of nodes (list, dict, set, etc.).  If a node\nin the container is not in the graph it is silently\nignored."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "When removing nodes from an iterator over the graph you are changing,\na RuntimeError will be raised with message: RuntimeError:dictionarychangedsizeduringiteration . This\nhappens when the graph\u2019s underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using list(iterator_of_nodes) , and pass this\nobject to G.remove_nodes_from .",
                        "Examples": "G=nx.path_graph(3)# or DiGraph, MultiGraph, MultiDiGraph, etc\ne=list(G.nodes)\ne\n# [0, 1, 2]\nG.remove_nodes_from(e)\nlist(G.nodes)\n# []\nEvaluate an iterator over a graph if using it to modify the same graph\nG=nx.Graph([(0,1),(1,2),(3,4)])\n# this command will fail, as the graph's dict is modified during iteration\n# G.remove_nodes_from(n for n in G.nodes if n < 2)\n# this command will work, since the dictionary underlying graph is not modified\nG.remove_nodes_from(list(nforninG.nodesifn<2))"
                    }
                },
                {
                    "Section ID": "add_edge",
                    "Path": "networkx.Graph",
                    "Description": [
                        "Add an edge between u and v.",
                        "The nodes u and v will be automatically added if they are\nnot already in the graph.",
                        "Edge attributes can be specified with keywords or by directly\naccessing the edge\u2019s attribute dictionary. See examples below."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "u_of_edge, v_of_edge : nodes": "Nodes can be, for example, strings or numbers.\nNodes must be hashable (and not None) Python objects.",
                            "attr : keyword arguments, optional": "Edge data (or labels or objects) can be assigned using\nkeyword arguments."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "Adding an edge that already exists updates the edge data. Many NetworkX algorithms designed for weighted graphs use\nan edge attribute (by default weight ) to hold a numerical value.",
                        "Examples": "The following all add the edge e=(1, 2) to graph G:\nG=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\ne=(1,2)\nG.add_edge(1,2)# explicit two-node form\nG.add_edge(*e)# single edge as tuple of two nodes\nG.add_edges_from([(1,2)])# add edges from iterable container\nAssociate data to edges using keywords:\nG.add_edge(1,2,weight=3)\nG.add_edge(1,3,weight=7,capacity=15,length=342.7)\nFor non-string attribute keys, use subscript notation.\nG.add_edge(1,2)\nG[1][2].update({0:5})\nG.edges[1,2].update({0:5})"
                    }
                },
                {
                    "Section ID": "add_edges_from",
                    "Path": "networkx.Graph",
                    "Description": [
                        "Add all the edges in ebunch_to_add."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "ebunch_to_add : container of edges": "Each edge given in the container will be added to the\ngraph. The edges must be given as 2-tuples (u, v) or\n3-tuples (u, v, d) where d is a dictionary containing edge data.",
                            "attr : keyword arguments, optional": "Edge data (or labels or objects) can be assigned using\nkeyword arguments."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "Adding the same edge twice has no effect but any edge data\nwill be updated when each duplicate edge is added. Edge attributes specified in an ebunch take precedence over\nattributes specified via keyword arguments. When adding edges from an iterator over the graph you are changing,\na RuntimeError can be raised with message: RuntimeError:dictionarychangedsizeduringiteration . This\nhappens when the graph\u2019s underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using list(iterator_of_edges) , and pass this\nobject to G.add_edges_from .",
                        "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_edges_from([(0,1),(1,2)])# using a list of edge tuples\ne=zip(range(0,3),range(1,4))\nG.add_edges_from(e)# Add the path graph 0-1-2-3\nAssociate data to edges\nG.add_edges_from([(1,2),(2,3)],weight=3)\nG.add_edges_from([(3,4),(1,4)],label=\"WN2898\")\nEvaluate an iterator over a graph if using it to modify the same graph\nG=nx.Graph([(1,2),(2,3),(3,4)])\n# Grow graph by one new node, adding edges to all existing nodes.\n# wrong way - will raise RuntimeError\n# G.add_edges_from(((5, n) for n in G.nodes))\n# correct way - note that there will be no self-edge for node 5\nG.add_edges_from(list((5,n)forninG.nodes))"
                    }
                },
                {
                    "Section ID": "add_weighted_edges_from",
                    "Path": "networkx.Graph",
                    "Description": [
                        "Add weighted edges in ebunch_to_add with specified weight attr"
                    ],
                    "Field List": {
                        "Parameters:": {
                            "ebunch_to_add : container of edges": "Each edge given in the list or container will be added\nto the graph. The edges must be given as 3-tuples (u, v, w)\nwhere w is a number.",
                            "weight : string, optional (default= \u2018weight\u2019)": "The attribute name for the edge weights to be added.",
                            "attr : keyword arguments, optional (default= no attributes)": "Edge attributes to add/update for all edges."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "Adding the same edge twice for Graph/DiGraph simply updates\nthe edge data. For MultiGraph/MultiDiGraph, duplicate edges\nare stored. When adding edges from an iterator over the graph you are changing,\na RuntimeError can be raised with message: RuntimeError:dictionarychangedsizeduringiteration . This\nhappens when the graph\u2019s underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using list(iterator_of_edges) , and pass this\nobject to G.add_weighted_edges_from .",
                        "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_weighted_edges_from([(0,1,3.0),(1,2,7.5)])\nEvaluate an iterator over edges before passing it\nG=nx.Graph([(1,2),(2,3),(3,4)])\nweight=0.1\n# Grow graph by one new node, adding edges to all existing nodes.\n# wrong way - will raise RuntimeError\n# G.add_weighted_edges_from(((5, n, weight) for n in G.nodes))\n# correct way - note that there will be no self-edge for node 5\nG.add_weighted_edges_from(list((5,n,weight)forninG.nodes))"
                    }
                },
                {
                    "Section ID": "remove_edge",
                    "Path": "networkx.Graph",
                    "Description": [
                        "Remove the edge between u and v."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "u, v : nodes": "Remove the edge between nodes u and v."
                        },
                        "Raises:": {
                            "NetworkXError": "If there is not an edge between u and v."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(4)# or DiGraph, etc\nG.remove_edge(0,1)\ne=(1,2)\nG.remove_edge(*e)# unpacks e from an edge tuple\ne=(2,3,{\"weight\":7})# an edge with attribute data\nG.remove_edge(*e[:2])# select first part of edge tuple"
                    }
                },
                {
                    "Section ID": "remove_edges_from",
                    "Path": "networkx.Graph",
                    "Description": [
                        "Remove all edges specified in ebunch."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "ebunch: list or container of edge tuples": "Each edge given in the list or container will be removed\nfrom the graph. The edges can be:2-tuples (u, v) edge between u and v.3-tuples (u, v, k) where k is ignored."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "Will fail silently if an edge in ebunch is not in the graph.",
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nebunch=[(1,2),(2,3)]\nG.remove_edges_from(ebunch)"
                    }
                },
                {
                    "Section ID": "update",
                    "Path": "networkx.Graph",
                    "Description": [
                        "Update the graph using nodes/edges/graphs as input.",
                        "Like dict.update, this method takes a graph as input, adding the\ngraph\u2019s nodes and edges to this graph. It can also take two inputs:\nedges and nodes. Finally it can take either edges or nodes.\nTo specify only nodes the keyword nodes must be used.",
                        "The collections of edges and nodes are treated similarly to\nthe add_edges_from/add_nodes_from methods. When iterated, they\nshould yield 2-tuples (u, v) or 3-tuples (u, v, datadict)."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "edges : Graph object, collection of edges, or None": "The first parameter can be a graph or some edges. If it has\nattributesnodesandedges, then it is taken to be a\nGraph-like object and those attributes are used as collections\nof nodes and edges to be added to the graph.\nIf the first parameter does not have those attributes, it is\ntreated as a collection of edges and added to the graph.\nIf the first argument is None, no edges are added.",
                            "nodes : collection of nodes, or None": "The second parameter is treated as a collection of nodes\nto be added to the graph unless it is None.\nIfedgesisNoneandnodesisNonean exception is raised.\nIf the first parameter is a Graph, thennodesis ignored."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "It you want to update the graph using an adjacency structure\nit is straightforward to obtain the edges/nodes from adjacency.\nThe following examples provide common cases, your adjacency may\nbe slightly different and require tweaks of these examples:",
                        "Examples": "G=nx.path_graph(5)\nG.update(nx.complete_graph(range(4,10)))\nfromitertoolsimportcombinations\nedges=(\n(u,v,{\"power\":u*v})\nforu,vincombinations(range(10,20),2)\nifu*v<225\n)\nnodes=[1000]# for singleton, use a container\nG.update(edges,nodes)"
                    }
                },
                {
                    "Section ID": "clear",
                    "Path": "networkx.Graph",
                    "Description": [
                        "Remove all nodes and edges from the graph.",
                        "This also removes the name, and all graph, node, and edge attributes.",
                        "Examples"
                    ],
                    "Field List": {
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.clear()\nlist(G.nodes)\n# []\nlist(G.edges)\n# []"
                    }
                },
                {
                    "Section ID": "clear_edges",
                    "Path": "networkx.Graph",
                    "Description": [
                        "Remove all edges from the graph without altering nodes.",
                        "Examples"
                    ],
                    "Field List": {
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.clear_edges()\nlist(G.nodes)\n# [0, 1, 2, 3]\nlist(G.edges)\n# []"
                    }
                },
                {
                    "Section ID": "nodes",
                    "Path": "networkx.Graph",
                    "Description": [],
                    "Field List": {
                        "Parameters:": {
                            "data : string or bool, optional (default=False)": "The node attribute returned in 2-tuple (n, ddict[data]).\nIf True, return entire node attribute dict as (n, ddict).\nIf False, return just the nodes n.",
                            "default : value, optional (default=None)": "Value used for nodes that don\u2019t have the requested attribute.\nOnly relevant if data is not True or False."
                        },
                        "Returns:": {
                            "NodeView": "Allows set-like operations over the nodes as well as node\nattribute dict lookup and calling to get a NodeDataView.\nA NodeDataView iterates over(n,data)and has no set operations.\nA NodeView iterates overnand includes set operations.When called, if data is False, an iterator over nodes.\nOtherwise an iterator of 2-tuples (node, attribute value)\nwhere the attribute is specified indata.\nIf data is True then the attribute becomes the\nentire data dictionary."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "If your node data is not needed, it is simpler and equivalent\nto use the expression forninG , or list(G) .",
                        "Examples": "There are two simple ways of getting a list of all nodes in the graph:\nG=nx.path_graph(3)\nlist(G.nodes)\n# [0, 1, 2]\nlist(G)\n# [0, 1, 2]\nTo get the node data along with the nodes:\nG.add_node(1,time=\"5pm\")\nG.nodes[0][\"foo\"]=\"bar\"\nlist(G.nodes(data=True))\n# [(0, {'foo': 'bar'}), (1, {'time': '5pm'}), (2, {})]\nlist(G.nodes.data())\n# [(0, {'foo': 'bar'}), (1, {'time': '5pm'}), (2, {})]\nlist(G.nodes(data=\"foo\"))\n# [(0, 'bar'), (1, None), (2, None)]\nlist(G.nodes.data(\"foo\"))\n# [(0, 'bar'), (1, None), (2, None)]\nlist(G.nodes(data=\"time\"))\n# [(0, None), (1, '5pm'), (2, None)]\nlist(G.nodes.data(\"time\"))\n# [(0, None), (1, '5pm'), (2, None)]\nlist(G.nodes(data=\"time\",default=\"Not Available\"))\n# [(0, 'Not Available'), (1, '5pm'), (2, 'Not Available')]\nlist(G.nodes.data(\"time\",default=\"Not Available\"))\n# [(0, 'Not Available'), (1, '5pm'), (2, 'Not Available')]\nIf some of your nodes have an attribute and the rest are assumed\nto have a default attribute value you can create a dictionary\nfrom node/attribute pairs using thedefaultkeyword argument\nto guarantee the value is never None:\nG=nx.Graph()\nG.add_node(0)\nG.add_node(1,weight=2)\nG.add_node(2,weight=3)\ndict(G.nodes(data=\"weight\",default=1))\n# {0: 1, 1: 2, 2: 3}"
                    }
                },
                {
                    "Section ID": "__iter__",
                    "Path": "networkx.Graph",
                    "Description": [
                        "Iterate over the nodes. Use: \u2018for n in G\u2019."
                    ],
                    "Field List": {
                        "Returns:": {
                            "niter : iterator": "An iterator over all nodes in the graph."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\n[nforninG]\n# [0, 1, 2, 3]\nlist(G)\n# [0, 1, 2, 3]"
                    }
                },
                {
                    "Section ID": "has_node",
                    "Path": "networkx.Graph",
                    "Description": [
                        "Returns True if the graph contains the node n.",
                        "Identical to ninG"
                    ],
                    "Field List": {
                        "Parameters:": {
                            "n : node": ""
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(3)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.has_node(0)\n# True\nIt is more readable and simpler to use\n0inG\n# True"
                    }
                },
                {
                    "Section ID": "__contains__",
                    "Path": "networkx.Graph",
                    "Description": [
                        "Returns True if n is a node, False otherwise. Use: \u2018n in G\u2019.",
                        "Examples"
                    ],
                    "Field List": {
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\n1inG\n# True"
                    }
                },
                {
                    "Section ID": "edges",
                    "Path": "networkx.Graph",
                    "Description": [],
                    "Field List": {
                        "Parameters:": {
                            "nbunch : single node, container, or all nodes (default= all nodes)": "The view will only report edges from these nodes.",
                            "data : string or bool, optional (default=False)": "The edge attribute returned in 3-tuple (u, v, ddict[data]).\nIf True, return edge attribute dict in 3-tuple (u, v, ddict).\nIf False, return 2-tuple (u, v).",
                            "default : value, optional (default=None)": "Value used for edges that don\u2019t have the requested attribute.\nOnly relevant if data is not True or False."
                        },
                        "Returns:": {
                            "edges : EdgeView": "A view of edge attributes, usually it iterates over (u, v)\nor (u, v, d) tuples of edges, but can also be used for\nattribute lookup asedges[u,v]['foo']."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "Nodes in nbunch that are not in the graph will be (quietly) ignored.\nFor directed graphs this returns the out-edges.",
                        "Examples": "G=nx.path_graph(3)# or MultiGraph, etc\nG.add_edge(2,3,weight=5)\n[eforeinG.edges]\n# [(0, 1), (1, 2), (2, 3)]\nG.edges.data()# default data is {} (empty dict)\n# EdgeDataView([(0, 1, {}), (1, 2, {}), (2, 3, {'weight': 5})])\nG.edges.data(\"weight\",default=1)\n# EdgeDataView([(0, 1, 1), (1, 2, 1), (2, 3, 5)])\nG.edges([0,3])# only edges from these nodes\n# EdgeDataView([(0, 1), (3, 2)])\nG.edges(0)# only edges from node 0\n# EdgeDataView([(0, 1)])"
                    }
                },
                {
                    "Section ID": "has_edge",
                    "Path": "networkx.Graph",
                    "Description": [
                        "Returns True if the edge (u, v) is in the graph.",
                        "This is the same as vinG[u] without KeyError exceptions."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "u, v : nodes": "Nodes can be, for example, strings or numbers.\nNodes must be hashable (and not None) Python objects."
                        },
                        "Returns:": {
                            "edge_ind : bool": "True if edge is in the graph, False otherwise."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.has_edge(0,1)# using two nodes\n# True\ne=(0,1)\nG.has_edge(*e)#  e is a 2-tuple (u, v)\n# True\ne=(0,1,{\"weight\":7})\nG.has_edge(*e[:2])# e is a 3-tuple (u, v, data_dictionary)\n# True\nThe following syntax are equivalent:\nG.has_edge(0,1)\n# True\n1inG[0]# though this gives KeyError if 0 not in G\n# True"
                    }
                },
                {
                    "Section ID": "get_edge_data",
                    "Path": "networkx.Graph",
                    "Description": [
                        "Returns the attribute dictionary associated with edge (u, v).",
                        "This is identical to G[u][v] except the default is returned\ninstead of an exception if the edge doesn\u2019t exist."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "u, v : nodes": "",
                            "default:  any Python object (default=None)": "Value to return if the edge (u, v) is not found."
                        },
                        "Returns:": {
                            "edge_dict : dictionary": "The edge attribute dictionary."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG[0][1]\n# {}\nWarning: Assigning toG[u][v]is not permitted.\nBut it is safe to assign attributesG[u][v]['foo']\nG[0][1][\"weight\"]=7\nG[0][1][\"weight\"]\n# 7\nG[1][0][\"weight\"]\n# 7\nG=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.get_edge_data(0,1)# default edge data is {}\n# {}\ne=(0,1)\nG.get_edge_data(*e)# tuple form\n# {}\nG.get_edge_data(\"a\",\"b\",default=0)# edge not in graph, return 0\n# 0"
                    }
                },
                {
                    "Section ID": "neighbors",
                    "Path": "networkx.Graph",
                    "Description": [
                        "Returns an iterator over all neighbors of node n.",
                        "This is identical to iter(G[n])"
                    ],
                    "Field List": {
                        "Parameters:": {
                            "n : node": "A node in the graph"
                        },
                        "Returns:": {
                            "neighbors : iterator": "An iterator over all neighbors of node n"
                        },
                        "Raises:": {
                            "NetworkXError": "If the node n is not in the graph."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "Alternate ways to access the neighbors are G.adj[n] or G[n] :",
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\n[nforninG.neighbors(0)]\n# [1]"
                    }
                },
                {
                    "Section ID": "adj",
                    "Path": "networkx.Graph",
                    "Description": [],
                    "Field List": {
                        "Methods": []
                    },
                    "Rubrics": {}
                },
                {
                    "Section ID": "__getitem__",
                    "Path": "networkx.Graph",
                    "Description": [
                        "Returns a dict of neighbors of node n.  Use: \u2018G[n]\u2019."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "n : node": "A node in the graph."
                        },
                        "Returns:": {
                            "adj_dict : dictionary": "The adjacency dictionary for nodes connected to n."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "G[n] is the same as G.adj[n] and similar to G.neighbors(n)\n(which is an iterator over G.adj[n])",
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG[0]\n# AtlasView({1: {}})"
                    }
                },
                {
                    "Section ID": "adjacency",
                    "Path": "networkx.Graph",
                    "Description": [
                        "Returns an iterator over (node, adjacency dict) tuples for all nodes.",
                        "For directed graphs, only outgoing neighbors/adjacencies are included."
                    ],
                    "Field List": {
                        "Returns:": {
                            "adj_iter : iterator": "An iterator over (node, adjacency dictionary) for all nodes in\nthe graph."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\n[(n,nbrdict)forn,nbrdictinG.adjacency()]\n# [(0, {1: {}}), (1, {0: {}, 2: {}}), (2, {1: {}, 3: {}}), (3, {2: {}})]"
                    }
                },
                {
                    "Section ID": "nbunch_iter",
                    "Path": "networkx.Graph",
                    "Description": [
                        "Returns an iterator over nodes contained in nbunch that are\nalso in the graph.",
                        "The nodes in nbunch are checked for membership in the graph\nand if not are silently ignored."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "nbunch : single node, container, or all nodes (default= all nodes)": "The view will only report edges incident to these nodes."
                        },
                        "Returns:": {
                            "niter : iterator": "An iterator over nodes in nbunch that are also in the graph.\nIf nbunch is None, iterate over all nodes in the graph."
                        },
                        "Raises:": {
                            "NetworkXError": "If nbunch is not a node or sequence of nodes.\nIf a node in nbunch is not hashable."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "When nbunch is an iterator, the returned iterator yields values\ndirectly from nbunch, becoming exhausted when nbunch is exhausted. To test whether nbunch is a single node, one can use\n\u201cif nbunch in self:\u201d, even after processing with this routine. If nbunch is not a node or a (possibly empty) sequence/iterator\nor None, a NetworkXError is raised.  Also, if any object in\nnbunch is not hashable, a NetworkXError is raised."
                    }
                },
                {
                    "Section ID": "order",
                    "Path": "networkx.Graph",
                    "Description": [
                        "Returns the number of nodes in the graph."
                    ],
                    "Field List": {
                        "Returns:": {
                            "nnodes : int": "The number of nodes in the graph."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(3)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.order()\n# 3"
                    }
                },
                {
                    "Section ID": "number_of_nodes",
                    "Path": "networkx.Graph",
                    "Description": [
                        "Returns the number of nodes in the graph."
                    ],
                    "Field List": {
                        "Returns:": {
                            "nnodes : int": "The number of nodes in the graph."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(3)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.number_of_nodes()\n# 3"
                    }
                },
                {
                    "Section ID": "__len__",
                    "Path": "networkx.Graph",
                    "Description": [
                        "Returns the number of nodes in the graph. Use: \u2018len(G)\u2019."
                    ],
                    "Field List": {
                        "Returns:": {
                            "nnodes : int": "The number of nodes in the graph."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nlen(G)\n# 4"
                    }
                },
                {
                    "Section ID": "degree",
                    "Path": "networkx.Graph",
                    "Description": [],
                    "Field List": {
                        "Parameters:": {
                            "nbunch : single node, container, or all nodes (default= all nodes)": "The view will only report edges incident to these nodes.",
                            "weight : string or None, optional (default=None)": "The name of an edge attribute that holds the numerical value used\nas a weight.  If None, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node."
                        },
                        "Returns:": {
                            "DegreeView or int": "If multiple nodes are requested (the default), returns aDegreeViewmapping nodes to their degree.\nIf a single node is requested, returns the degree of the node as an integer."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.degree[0]# node 0 has degree 1\n# 1\nlist(G.degree([0,1,2]))\n# [(0, 1), (1, 2), (2, 2)]"
                    }
                },
                {
                    "Section ID": "size",
                    "Path": "networkx.Graph",
                    "Description": [
                        "Returns the number of edges or total of all edge weights."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "weight : string or None, optional (default=None)": "The edge attribute that holds the numerical value used\nas a weight. If None, then each edge has weight 1."
                        },
                        "Returns:": {
                            "size : numeric": "The number of edges or\n(if weight keyword is provided) the total weight sum.If weight is None, returns an int. Otherwise a float\n(or more general numeric if the weights are more general)."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.size()\n# 3\nG=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_edge(\"a\",\"b\",weight=2)\nG.add_edge(\"b\",\"c\",weight=4)\nG.size()\n# 2\nG.size(weight=\"weight\")\n# 6.0"
                    }
                },
                {
                    "Section ID": "number_of_edges",
                    "Path": "networkx.Graph",
                    "Description": [
                        "Returns the number of edges between two nodes."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "u, v : nodes, optional (default=all edges)": "If u and v are specified, return the number of edges between\nu and v. Otherwise return the total number of all edges."
                        },
                        "Returns:": {
                            "nedges : int": "The number of edges in the graph.  If nodesuandvare\nspecified return the number of edges between those nodes. If\nthe graph is directed, this only returns the number of edges\nfromutov."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "For undirected graphs, this method counts the total number of\nedges in the graph:\nG=nx.path_graph(4)\nG.number_of_edges()\n# 3\nIf you specify two nodes, this counts the total number of edges\njoining the two nodes:\nG.number_of_edges(0,1)\n# 1\nFor directed graphs, this method can count the total number of\ndirected edges fromutov:\nG=nx.DiGraph()\nG.add_edge(0,1)\nG.add_edge(1,0)\nG.number_of_edges(0,1)\n# 1"
                    }
                },
                {
                    "Section ID": "copy",
                    "Path": "networkx.Graph",
                    "Description": [
                        "Returns a copy of the graph.",
                        "The copy method by default returns an independent shallow copy\nof the graph and attributes. That is, if an attribute is a\ncontainer, that container is shared by the original an the copy.\nUse Python\u2019s copy.deepcopy for new containers.",
                        "If as_view is True then a view is returned instead of a copy."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "as_view : bool, optional (default=False)": "If True, the returned graph-view provides a read-only view\nof the original graph without actually copying any data."
                        },
                        "Returns:": {
                            "G : Graph": "A copy of the graph."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "All copies reproduce the graph structure, but data attributes\nmay be handled in different ways. There are four types of copies\nof a graph that people might want. Deepcopy \u2013 A \u201cdeepcopy\u201d copies the graph structure as well as\nall data attributes and any objects they might contain.\nThe entire graph object is new so that changes in the copy\ndo not affect the original object. (see Python\u2019s copy.deepcopy) Data Reference (Shallow) \u2013 For a shallow copy the graph structure\nis copied but the edge, node and graph attribute dicts are\nreferences to those in the original graph. This saves\ntime and memory but could cause confusion if you change an attribute\nin one graph and it changes the attribute in the other.\nNetworkX does not provide this level of shallow copy. Independent Shallow \u2013 This copy creates new independent attribute\ndicts and then does a shallow copy of the attributes. That is, any\nattributes that are containers are shared between the new graph\nand the original. This is exactly what dict.copy() provides.\nYou can obtain this style copy using:",
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nH=G.copy()"
                    }
                },
                {
                    "Section ID": "to_undirected",
                    "Path": "networkx.Graph",
                    "Description": [
                        "Returns an undirected copy of the graph."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "as_view : bool (optional, default=False)": "If True return a view of the original undirected graph."
                        },
                        "Returns:": {
                            "G : Graph/MultiGraph": "A deepcopy of the graph."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "This returns a \u201cdeepcopy\u201d of the edge, node, and\ngraph attributes which attempts to completely copy\nall of the data and references. This is in contrast to the similar G=nx.DiGraph(D) which returns a\nshallow copy of the data. See the Python copy module for more information on shallow\nand deep copies, https://docs.python.org/3/library/copy.html . Warning: If you have subclassed DiGraph to use dict-like objects\nin the data structure, those changes do not transfer to the\nGraph created by this method.",
                        "Examples": "G=nx.path_graph(2)# or MultiGraph, etc\nH=G.to_directed()\nlist(H.edges)\n# [(0, 1), (1, 0)]\nG2=H.to_undirected()\nlist(G2.edges)\n# [(0, 1)]"
                    }
                },
                {
                    "Section ID": "to_directed",
                    "Path": "networkx.Graph",
                    "Description": [
                        "Returns a directed representation of the graph."
                    ],
                    "Field List": {
                        "Returns:": {
                            "G : DiGraph": "A directed graph with the same name, same nodes, and with\neach edge (u, v, data) replaced by two directed edges\n(u, v, data) and (v, u, data)."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "This returns a \u201cdeepcopy\u201d of the edge, node, and\ngraph attributes which attempts to completely copy\nall of the data and references. This is in contrast to the similar D=DiGraph(G) which returns a\nshallow copy of the data. See the Python copy module for more information on shallow\nand deep copies, https://docs.python.org/3/library/copy.html . Warning: If you have subclassed Graph to use dict-like objects\nin the data structure, those changes do not transfer to the\nDiGraph created by this method.",
                        "Examples": "G=nx.Graph()# or MultiGraph, etc\nG.add_edge(0,1)\nH=G.to_directed()\nlist(H.edges)\n# [(0, 1), (1, 0)]\nIf already directed, return a (deep) copy\nG=nx.DiGraph()# or MultiDiGraph, etc\nG.add_edge(0,1)\nH=G.to_directed()\nlist(H.edges)\n# [(0, 1)]"
                    }
                },
                {
                    "Section ID": "subgraph",
                    "Path": "networkx.Graph",
                    "Description": [
                        "Returns a SubGraph view of the subgraph induced on nodes .",
                        "The induced subgraph of the graph contains the nodes in nodes and the edges between those nodes."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "nodes : list, iterable": "A container of nodes which will be iterated through once."
                        },
                        "Returns:": {
                            "G : SubGraph View": "A subgraph view of the graph. The graph structure cannot be\nchanged but node/edge attributes can and are shared with the\noriginal graph."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "The graph, edge and node attributes are shared with the original graph.\nChanges to the graph structure is ruled out by the view, but changes\nto attributes are reflected in the original graph. To create a subgraph with its own copy of the edge/node attributes use:\nG.subgraph(nodes).copy() For an inplace reduction of a graph to a subgraph you can remove nodes:\nG.remove_nodes_from([n for n in G if n not in set(nodes)]) Subgraph views are sometimes NOT what you want. In most cases where\nyou want to do more than simply look at the induced edges, it makes\nmore sense to just create the subgraph as its own graph with code like:",
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nH=G.subgraph([0,1,2])\nlist(H.edges)\n# [(0, 1), (1, 2)]"
                    }
                },
                {
                    "Section ID": "edge_subgraph",
                    "Path": "networkx.Graph",
                    "Description": [
                        "Returns the subgraph induced by the specified edges.",
                        "The induced subgraph contains each edge in edges and each\nnode incident to any one of those edges."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "edges : iterable": "An iterable of edges in this graph."
                        },
                        "Returns:": {
                            "G : Graph": "An edge-induced subgraph of this graph with the same edge\nattributes."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "The graph, edge, and node attributes in the returned subgraph\nview are references to the corresponding attributes in the original\ngraph. The view is read-only. To create a full graph version of the subgraph with its own copy\nof the edge or node attributes, use:",
                        "Examples": "G=nx.path_graph(5)\nH=G.edge_subgraph([(0,1),(3,4)])\nlist(H.nodes)\n# [0, 1, 3, 4]\nlist(H.edges)\n# [(0, 1), (3, 4)]"
                    }
                }
            ]
        },
        "Rubrics": {
            "Examples": "Create an empty graph structure (a \u201cnull graph\u201d) with no nodes and\nno edges.\nG=nx.Graph()\nG can be grown in several ways.\nNodes:\nAdd one node at a time:\nG.add_node(1)\nAdd the nodes from any container (a list, dict, set or\neven the lines from a file or the nodes from another graph).\nG.add_nodes_from([2,3])\nG.add_nodes_from(range(100,110))\nH=nx.path_graph(10)\nG.add_nodes_from(H)\nIn addition to strings and integers any hashable Python object\n(except None) can represent a node, e.g. a customized node object,\nor even another Graph.\nG.add_node(H)\nEdges:\nG can also be grown by adding edges.\nAdd one edge,\nG.add_edge(1,2)\na list of edges,\nG.add_edges_from([(1,2),(1,3)])\nor a collection of edges,\nG.add_edges_from(H.edges)\nIf some edges connect nodes not yet in the graph, the nodes\nare added automatically.  There are no errors when adding\nnodes or edges that already exist.\nAttributes:\nEach graph, node, and edge can hold key/value attribute pairs\nin an associated attribute dictionary (the keys must be hashable).\nBy default these are empty, but can be added or changed using\nadd_edge, add_node or direct manipulation of the attribute\ndictionaries named graph, node and edge respectively.\nG=nx.Graph(day=\"Friday\")\nG.graph\n# {'day': 'Friday'}\nAdd node attributes using add_node(), add_nodes_from() or G.nodes\nG.add_node(1,time=\"5pm\")\nG.add_nodes_from([3],time=\"2pm\")\nG.nodes[1]\n# {'time': '5pm'}\nG.nodes[1][\"room\"]=714# node must exist already to use G.nodes\ndelG.nodes[1][\"room\"]# remove attribute\nlist(G.nodes(data=True))\n# [(1, {'time': '5pm'}), (3, {'time': '2pm'})]\nAdd edge attributes using add_edge(), add_edges_from(), subscript\nnotation, or G.edges.\nG.add_edge(1,2,weight=4.7)\nG.add_edges_from([(3,4),(4,5)],color=\"red\")\nG.add_edges_from([(1,2,{\"color\":\"blue\"}),(2,3,{\"weight\":8})])\nG[1][2][\"weight\"]=4.7\nG.edges[1,2][\"weight\"]=4\nWarning: we protect the graph data structure by makingG.edgesa\nread-only dict-like structure. However, you can assign to attributes\nin e.g.G.edges[1,2]. Thus, use 2 sets of brackets to add/change\ndata attributes:G.edges[1,2]['weight']=4(For multigraphs:MG.edges[u,v,key][name]=value).\nShortcuts:\nMany common graph features allow python syntax to speed reporting.\n1inG# check if node in graph\n# True\n[nforninGifn<3]# iterate through nodes\n# [1, 2]\nlen(G)# number of nodes in graph\n# 5\nOften the best way to traverse all edges of a graph is via the neighbors.\nThe neighbors are reported as an adjacency-dictG.adjorG.adjacency()\nforn,nbrsdictinG.adjacency():\nfornbr,eattrinnbrsdict.items():\nif\"weight\"ineattr:\n# Do something useful with the edges\npass\nBut the edges() method is often more convenient:\nforu,v,weightinG.edges.data(\"weight\"):\nifweightisnotNone:\n# Do something useful with the edges\npass\nReporting:\nSimple graph information is obtained using object-attributes and methods.\nReporting typically provides views instead of containers to reduce memory\nusage. The views update as the graph is updated similarly to dict-views.\nThe objectsnodes,edgesandadjprovide access to data attributes\nvia lookup (e.g.nodes[n],edges[u,v],adj[u][v]) and iteration\n(e.g.nodes.items(),nodes.data('color'),nodes.data('color',default='blue')and similarly foredges)\nViews exist fornodes,edges,neighbors()/adjanddegree.\nFor details on these and other miscellaneous methods, see below.\nSubclasses (Advanced):\nThe Graph class uses a dict-of-dict-of-dict data structure.\nThe outer dict (node_dict) holds adjacency information keyed by node.\nThe next dict (adjlist_dict) represents the adjacency information and holds\nedge data keyed by neighbor.  The inner dict (edge_attr_dict) represents\nthe edge data and holds edge attribute values keyed by attribute names.\nEach of these three dicts can be replaced in a subclass by a user defined\ndict-like object. In general, the dict-like features should be\nmaintained but extra features can be added. To replace one of the\ndicts create a new graph class by changing the class(!) variable\nholding the factory for that dict-like structure."
        }
    },
    {
        "Section ID": "DiGraph",
        "Description": [
            "Base class for directed graphs.",
            "A DiGraph stores nodes and edges with optional data, or attributes.",
            "DiGraphs hold directed edges.  Self loops are allowed but multiple\n(parallel) edges are not.",
            "Nodes can be arbitrary (hashable) Python objects with optional\nkey/value attributes. By convention None is not used as a node.",
            "Edges are represented as links between nodes with optional\nkey/value attributes."
        ],
        "Field List": {
            "Parameters:": {
                "incoming_graph_data : input graph (optional, default: None)": "Data to initialize graph. If None (default) an empty\ngraph is created.  The data can be any format that is supported\nby the to_networkx_graph() function, currently including edge list,\ndict of dicts, dict of lists, NetworkX graph, 2D NumPy array, SciPy\nsparse matrix, or PyGraphviz graph.",
                "attr : keyword arguments, optional (default= no attributes)": "Attributes to add to graph as key=value pairs."
            },
            "Methods": [
                {
                    "Section ID": "__init__",
                    "Path": "networkx.DiGraph",
                    "Description": [
                        "Initialize a graph with edges, name, or graph attributes."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "incoming_graph_data : input graph (optional, default: None)": "Data to initialize graph.  If None (default) an empty\ngraph is created.  The data can be an edge list, or any\nNetworkX graph object.  If the corresponding optional Python\npackages are installed the data can also be a 2D NumPy array, a\nSciPy sparse array, or a PyGraphviz graph.",
                            "attr : keyword arguments, optional (default= no attributes)": "Attributes to add to graph as key=value pairs."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG=nx.Graph(name=\"my graph\")\ne=[(1,2),(2,3),(3,4)]# list of edges\nG=nx.Graph(e)\nArbitrary graph attribute pairs (key=value) may be assigned\nG=nx.Graph(e,day=\"Friday\")\nG.graph\n# {'day': 'Friday'}"
                    }
                },
                {
                    "Section ID": "add_node",
                    "Path": "networkx.DiGraph",
                    "Description": [
                        "Add a single node node_for_adding and update node attributes."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "node_for_adding : node": "A node can be any hashable Python object except None.",
                            "attr : keyword arguments, optional": "Set or change node attributes using key=value."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "A hashable object is one that can be used as a key in a Python\ndictionary. This includes strings, numbers, tuples of strings\nand numbers, etc. On many platforms hashable items also include mutables such as\nNetworkX Graphs, though one should be careful that the hash\ndoesn\u2019t change on mutables.",
                        "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_node(1)\nG.add_node(\"Hello\")\nK3=nx.Graph([(0,1),(1,2),(2,0)])\nG.add_node(K3)\nG.number_of_nodes()\n# 3\nUse keywords set/change node attributes:\nG.add_node(1,size=10)\nG.add_node(3,weight=0.4,UTM=(\"13S\",382871,3972649))"
                    }
                },
                {
                    "Section ID": "add_nodes_from",
                    "Path": "networkx.DiGraph",
                    "Description": [
                        "Add multiple nodes."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "nodes_for_adding : iterable container": "A container of nodes (list, dict, set, etc.).\nOR\nA container of (node, attribute dict) tuples.\nNode attributes are updated using the attribute dict.",
                            "attr : keyword arguments, optional (default= no attributes)": "Update attributes for all nodes in nodes.\nNode attributes specified in nodes as a tuple take\nprecedence over attributes specified via keyword arguments."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "When adding nodes from an iterator over the graph you are changing,\na RuntimeError can be raised with message: RuntimeError:dictionarychangedsizeduringiteration . This\nhappens when the graph\u2019s underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using list(iterator_of_nodes) , and pass this\nobject to G.add_nodes_from .",
                        "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_nodes_from(\"Hello\")\nK3=nx.Graph([(0,1),(1,2),(2,0)])\nG.add_nodes_from(K3)\nsorted(G.nodes(),key=str)\n# [0, 1, 2, 'H', 'e', 'l', 'o']\nUse keywords to update specific node attributes for every node.\nG.add_nodes_from([1,2],size=10)\nG.add_nodes_from([3,4],weight=0.4)\nUse (node, attrdict) tuples to update attributes for specific nodes.\nG.add_nodes_from([(1,dict(size=11)),(2,{\"color\":\"blue\"})])\nG.nodes[1][\"size\"]\n# 11\nH=nx.Graph()\nH.add_nodes_from(G.nodes(data=True))\nH.nodes[1][\"size\"]\n# 11\nEvaluate an iterator over a graph if using it to modify the same graph\nG=nx.DiGraph([(0,1),(1,2),(3,4)])\n# wrong way - will raise RuntimeError\n# G.add_nodes_from(n + 1 for n in G.nodes)\n# correct way\nG.add_nodes_from(list(n+1forninG.nodes))"
                    }
                },
                {
                    "Section ID": "remove_node",
                    "Path": "networkx.DiGraph",
                    "Description": [
                        "Remove node n.",
                        "Removes the node n and all adjacent edges.\nAttempting to remove a nonexistent node will raise an exception."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "n : node": "A node in the graph"
                        },
                        "Raises:": {
                            "NetworkXError": "If n is not in the graph."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(3)# or DiGraph, MultiGraph, MultiDiGraph, etc\nlist(G.edges)\n# [(0, 1), (1, 2)]\nG.remove_node(1)\nlist(G.edges)\n# []"
                    }
                },
                {
                    "Section ID": "remove_nodes_from",
                    "Path": "networkx.DiGraph",
                    "Description": [
                        "Remove multiple nodes."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "nodes : iterable container": "A container of nodes (list, dict, set, etc.).  If a node\nin the container is not in the graph it is silently ignored."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "When removing nodes from an iterator over the graph you are changing,\na RuntimeError will be raised with message: RuntimeError:dictionarychangedsizeduringiteration . This\nhappens when the graph\u2019s underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using list(iterator_of_nodes) , and pass this\nobject to G.remove_nodes_from .",
                        "Examples": "G=nx.path_graph(3)# or DiGraph, MultiGraph, MultiDiGraph, etc\ne=list(G.nodes)\ne\n# [0, 1, 2]\nG.remove_nodes_from(e)\nlist(G.nodes)\n# []\nEvaluate an iterator over a graph if using it to modify the same graph\nG=nx.DiGraph([(0,1),(1,2),(3,4)])\n# this command will fail, as the graph's dict is modified during iteration\n# G.remove_nodes_from(n for n in G.nodes if n < 2)\n# this command will work, since the dictionary underlying graph is not modified\nG.remove_nodes_from(list(nforninG.nodesifn<2))"
                    }
                },
                {
                    "Section ID": "add_edge",
                    "Path": "networkx.DiGraph",
                    "Description": [
                        "Add an edge between u and v.",
                        "The nodes u and v will be automatically added if they are\nnot already in the graph.",
                        "Edge attributes can be specified with keywords or by directly\naccessing the edge\u2019s attribute dictionary. See examples below."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "u_of_edge, v_of_edge : nodes": "Nodes can be, for example, strings or numbers.\nNodes must be hashable (and not None) Python objects.",
                            "attr : keyword arguments, optional": "Edge data (or labels or objects) can be assigned using\nkeyword arguments."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "Adding an edge that already exists updates the edge data. Many NetworkX algorithms designed for weighted graphs use\nan edge attribute (by default weight ) to hold a numerical value.",
                        "Examples": "The following all add the edge e=(1, 2) to graph G:\nG=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\ne=(1,2)\nG.add_edge(1,2)# explicit two-node form\nG.add_edge(*e)# single edge as tuple of two nodes\nG.add_edges_from([(1,2)])# add edges from iterable container\nAssociate data to edges using keywords:\nG.add_edge(1,2,weight=3)\nG.add_edge(1,3,weight=7,capacity=15,length=342.7)\nFor non-string attribute keys, use subscript notation.\nG.add_edge(1,2)\nG[1][2].update({0:5})\nG.edges[1,2].update({0:5})"
                    }
                },
                {
                    "Section ID": "add_edges_from",
                    "Path": "networkx.DiGraph",
                    "Description": [
                        "Add all the edges in ebunch_to_add."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "ebunch_to_add : container of edges": "Each edge given in the container will be added to the\ngraph. The edges must be given as 2-tuples (u, v) or\n3-tuples (u, v, d) where d is a dictionary containing edge data.",
                            "attr : keyword arguments, optional": "Edge data (or labels or objects) can be assigned using\nkeyword arguments."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "Adding the same edge twice has no effect but any edge data\nwill be updated when each duplicate edge is added. Edge attributes specified in an ebunch take precedence over\nattributes specified via keyword arguments. When adding edges from an iterator over the graph you are changing,\na RuntimeError can be raised with message: RuntimeError:dictionarychangedsizeduringiteration . This\nhappens when the graph\u2019s underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using list(iterator_of_edges) , and pass this\nobject to G.add_edges_from .",
                        "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_edges_from([(0,1),(1,2)])# using a list of edge tuples\ne=zip(range(0,3),range(1,4))\nG.add_edges_from(e)# Add the path graph 0-1-2-3\nAssociate data to edges\nG.add_edges_from([(1,2),(2,3)],weight=3)\nG.add_edges_from([(3,4),(1,4)],label=\"WN2898\")\nEvaluate an iterator over a graph if using it to modify the same graph\nG=nx.DiGraph([(1,2),(2,3),(3,4)])\n# Grow graph by one new node, adding edges to all existing nodes.\n# wrong way - will raise RuntimeError\n# G.add_edges_from(((5, n) for n in G.nodes))\n# right way - note that there will be no self-edge for node 5\nG.add_edges_from(list((5,n)forninG.nodes))"
                    }
                },
                {
                    "Section ID": "add_weighted_edges_from",
                    "Path": "networkx.DiGraph",
                    "Description": [
                        "Add weighted edges in ebunch_to_add with specified weight attr"
                    ],
                    "Field List": {
                        "Parameters:": {
                            "ebunch_to_add : container of edges": "Each edge given in the list or container will be added\nto the graph. The edges must be given as 3-tuples (u, v, w)\nwhere w is a number.",
                            "weight : string, optional (default= \u2018weight\u2019)": "The attribute name for the edge weights to be added.",
                            "attr : keyword arguments, optional (default= no attributes)": "Edge attributes to add/update for all edges."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "Adding the same edge twice for Graph/DiGraph simply updates\nthe edge data. For MultiGraph/MultiDiGraph, duplicate edges\nare stored. When adding edges from an iterator over the graph you are changing,\na RuntimeError can be raised with message: RuntimeError:dictionarychangedsizeduringiteration . This\nhappens when the graph\u2019s underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using list(iterator_of_edges) , and pass this\nobject to G.add_weighted_edges_from .",
                        "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_weighted_edges_from([(0,1,3.0),(1,2,7.5)])\nEvaluate an iterator over edges before passing it\nG=nx.Graph([(1,2),(2,3),(3,4)])\nweight=0.1\n# Grow graph by one new node, adding edges to all existing nodes.\n# wrong way - will raise RuntimeError\n# G.add_weighted_edges_from(((5, n, weight) for n in G.nodes))\n# correct way - note that there will be no self-edge for node 5\nG.add_weighted_edges_from(list((5,n,weight)forninG.nodes))"
                    }
                },
                {
                    "Section ID": "remove_edge",
                    "Path": "networkx.DiGraph",
                    "Description": [
                        "Remove the edge between u and v."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "u, v : nodes": "Remove the edge between nodes u and v."
                        },
                        "Raises:": {
                            "NetworkXError": "If there is not an edge between u and v."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.Graph()# or DiGraph, etc\nnx.add_path(G,[0,1,2,3])\nG.remove_edge(0,1)\ne=(1,2)\nG.remove_edge(*e)# unpacks e from an edge tuple\ne=(2,3,{\"weight\":7})# an edge with attribute data\nG.remove_edge(*e[:2])# select first part of edge tuple"
                    }
                },
                {
                    "Section ID": "remove_edges_from",
                    "Path": "networkx.DiGraph",
                    "Description": [
                        "Remove all edges specified in ebunch."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "ebunch: list or container of edge tuples": "Each edge given in the list or container will be removed\nfrom the graph. The edges can be:2-tuples (u, v) edge between u and v.3-tuples (u, v, k) where k is ignored."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "Will fail silently if an edge in ebunch is not in the graph.",
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nebunch=[(1,2),(2,3)]\nG.remove_edges_from(ebunch)"
                    }
                },
                {
                    "Section ID": "update",
                    "Path": "networkx.DiGraph",
                    "Description": [
                        "Update the graph using nodes/edges/graphs as input.",
                        "Like dict.update, this method takes a graph as input, adding the\ngraph\u2019s nodes and edges to this graph. It can also take two inputs:\nedges and nodes. Finally it can take either edges or nodes.\nTo specify only nodes the keyword nodes must be used.",
                        "The collections of edges and nodes are treated similarly to\nthe add_edges_from/add_nodes_from methods. When iterated, they\nshould yield 2-tuples (u, v) or 3-tuples (u, v, datadict)."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "edges : Graph object, collection of edges, or None": "The first parameter can be a graph or some edges. If it has\nattributesnodesandedges, then it is taken to be a\nGraph-like object and those attributes are used as collections\nof nodes and edges to be added to the graph.\nIf the first parameter does not have those attributes, it is\ntreated as a collection of edges and added to the graph.\nIf the first argument is None, no edges are added.",
                            "nodes : collection of nodes, or None": "The second parameter is treated as a collection of nodes\nto be added to the graph unless it is None.\nIfedgesisNoneandnodesisNonean exception is raised.\nIf the first parameter is a Graph, thennodesis ignored."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "It you want to update the graph using an adjacency structure\nit is straightforward to obtain the edges/nodes from adjacency.\nThe following examples provide common cases, your adjacency may\nbe slightly different and require tweaks of these examples:",
                        "Examples": "G=nx.path_graph(5)\nG.update(nx.complete_graph(range(4,10)))\nfromitertoolsimportcombinations\nedges=(\n(u,v,{\"power\":u*v})\nforu,vincombinations(range(10,20),2)\nifu*v<225\n)\nnodes=[1000]# for singleton, use a container\nG.update(edges,nodes)"
                    }
                },
                {
                    "Section ID": "clear",
                    "Path": "networkx.DiGraph",
                    "Description": [
                        "Remove all nodes and edges from the graph.",
                        "This also removes the name, and all graph, node, and edge attributes.",
                        "Examples"
                    ],
                    "Field List": {
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.clear()\nlist(G.nodes)\n# []\nlist(G.edges)\n# []"
                    }
                },
                {
                    "Section ID": "clear_edges",
                    "Path": "networkx.DiGraph",
                    "Description": [
                        "Remove all edges from the graph without altering nodes.",
                        "Examples"
                    ],
                    "Field List": {
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.clear_edges()\nlist(G.nodes)\n# [0, 1, 2, 3]\nlist(G.edges)\n# []"
                    }
                },
                {
                    "Section ID": "nodes",
                    "Path": "networkx.DiGraph",
                    "Description": [],
                    "Field List": {
                        "Parameters:": {
                            "data : string or bool, optional (default=False)": "The node attribute returned in 2-tuple (n, ddict[data]).\nIf True, return entire node attribute dict as (n, ddict).\nIf False, return just the nodes n.",
                            "default : value, optional (default=None)": "Value used for nodes that don\u2019t have the requested attribute.\nOnly relevant if data is not True or False."
                        },
                        "Returns:": {
                            "NodeView": "Allows set-like operations over the nodes as well as node\nattribute dict lookup and calling to get a NodeDataView.\nA NodeDataView iterates over(n,data)and has no set operations.\nA NodeView iterates overnand includes set operations.When called, if data is False, an iterator over nodes.\nOtherwise an iterator of 2-tuples (node, attribute value)\nwhere the attribute is specified indata.\nIf data is True then the attribute becomes the\nentire data dictionary."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "If your node data is not needed, it is simpler and equivalent\nto use the expression forninG , or list(G) .",
                        "Examples": "There are two simple ways of getting a list of all nodes in the graph:\nG=nx.path_graph(3)\nlist(G.nodes)\n# [0, 1, 2]\nlist(G)\n# [0, 1, 2]\nTo get the node data along with the nodes:\nG.add_node(1,time=\"5pm\")\nG.nodes[0][\"foo\"]=\"bar\"\nlist(G.nodes(data=True))\n# [(0, {'foo': 'bar'}), (1, {'time': '5pm'}), (2, {})]\nlist(G.nodes.data())\n# [(0, {'foo': 'bar'}), (1, {'time': '5pm'}), (2, {})]\nlist(G.nodes(data=\"foo\"))\n# [(0, 'bar'), (1, None), (2, None)]\nlist(G.nodes.data(\"foo\"))\n# [(0, 'bar'), (1, None), (2, None)]\nlist(G.nodes(data=\"time\"))\n# [(0, None), (1, '5pm'), (2, None)]\nlist(G.nodes.data(\"time\"))\n# [(0, None), (1, '5pm'), (2, None)]\nlist(G.nodes(data=\"time\",default=\"Not Available\"))\n# [(0, 'Not Available'), (1, '5pm'), (2, 'Not Available')]\nlist(G.nodes.data(\"time\",default=\"Not Available\"))\n# [(0, 'Not Available'), (1, '5pm'), (2, 'Not Available')]\nIf some of your nodes have an attribute and the rest are assumed\nto have a default attribute value you can create a dictionary\nfrom node/attribute pairs using thedefaultkeyword argument\nto guarantee the value is never None:\nG=nx.Graph()\nG.add_node(0)\nG.add_node(1,weight=2)\nG.add_node(2,weight=3)\ndict(G.nodes(data=\"weight\",default=1))\n# {0: 1, 1: 2, 2: 3}"
                    }
                },
                {
                    "Section ID": "__iter__",
                    "Path": "networkx.DiGraph",
                    "Description": [
                        "Iterate over the nodes. Use: \u2018for n in G\u2019."
                    ],
                    "Field List": {
                        "Returns:": {
                            "niter : iterator": "An iterator over all nodes in the graph."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\n[nforninG]\n# [0, 1, 2, 3]\nlist(G)\n# [0, 1, 2, 3]"
                    }
                },
                {
                    "Section ID": "has_node",
                    "Path": "networkx.DiGraph",
                    "Description": [
                        "Returns True if the graph contains the node n.",
                        "Identical to ninG"
                    ],
                    "Field List": {
                        "Parameters:": {
                            "n : node": ""
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(3)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.has_node(0)\n# True\nIt is more readable and simpler to use\n0inG\n# True"
                    }
                },
                {
                    "Section ID": "__contains__",
                    "Path": "networkx.DiGraph",
                    "Description": [
                        "Returns True if n is a node, False otherwise. Use: \u2018n in G\u2019.",
                        "Examples"
                    ],
                    "Field List": {
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\n1inG\n# True"
                    }
                },
                {
                    "Section ID": "edges",
                    "Path": "networkx.DiGraph",
                    "Description": [],
                    "Field List": {
                        "Parameters:": {
                            "nbunch : single node, container, or all nodes (default= all nodes)": "The view will only report edges from these nodes.",
                            "data : string or bool, optional (default=False)": "The edge attribute returned in 3-tuple (u, v, ddict[data]).\nIf True, return edge attribute dict in 3-tuple (u, v, ddict).\nIf False, return 2-tuple (u, v).",
                            "default : value, optional (default=None)": "Value used for edges that don\u2019t have the requested attribute.\nOnly relevant if data is not True or False."
                        },
                        "Returns:": {
                            "edges : OutEdgeView": "A view of edge attributes, usually it iterates over (u, v)\nor (u, v, d) tuples of edges, but can also be used for\nattribute lookup asedges[u,v]['foo']."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "Nodes in nbunch that are not in the graph will be (quietly) ignored.\nFor directed graphs this returns the out-edges.",
                        "Examples": "G=nx.DiGraph()# or MultiDiGraph, etc\nnx.add_path(G,[0,1,2])\nG.add_edge(2,3,weight=5)\n[eforeinG.edges]\n# [(0, 1), (1, 2), (2, 3)]\nG.edges.data()# default data is {} (empty dict)\n# OutEdgeDataView([(0, 1, {}), (1, 2, {}), (2, 3, {'weight': 5})])\nG.edges.data(\"weight\",default=1)\n# OutEdgeDataView([(0, 1, 1), (1, 2, 1), (2, 3, 5)])\nG.edges([0,2])# only edges originating from these nodes\n# OutEdgeDataView([(0, 1), (2, 3)])\nG.edges(0)# only edges from node 0\n# OutEdgeDataView([(0, 1)])"
                    }
                },
                {
                    "Section ID": "out_edges",
                    "Path": "networkx.DiGraph",
                    "Description": [],
                    "Field List": {
                        "Parameters:": {
                            "nbunch : single node, container, or all nodes (default= all nodes)": "The view will only report edges from these nodes.",
                            "data : string or bool, optional (default=False)": "The edge attribute returned in 3-tuple (u, v, ddict[data]).\nIf True, return edge attribute dict in 3-tuple (u, v, ddict).\nIf False, return 2-tuple (u, v).",
                            "default : value, optional (default=None)": "Value used for edges that don\u2019t have the requested attribute.\nOnly relevant if data is not True or False."
                        },
                        "Returns:": {
                            "edges : OutEdgeView": "A view of edge attributes, usually it iterates over (u, v)\nor (u, v, d) tuples of edges, but can also be used for\nattribute lookup asedges[u,v]['foo']."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "Nodes in nbunch that are not in the graph will be (quietly) ignored.\nFor directed graphs this returns the out-edges.",
                        "Examples": "G=nx.DiGraph()# or MultiDiGraph, etc\nnx.add_path(G,[0,1,2])\nG.add_edge(2,3,weight=5)\n[eforeinG.edges]\n# [(0, 1), (1, 2), (2, 3)]\nG.edges.data()# default data is {} (empty dict)\n# OutEdgeDataView([(0, 1, {}), (1, 2, {}), (2, 3, {'weight': 5})])\nG.edges.data(\"weight\",default=1)\n# OutEdgeDataView([(0, 1, 1), (1, 2, 1), (2, 3, 5)])\nG.edges([0,2])# only edges originating from these nodes\n# OutEdgeDataView([(0, 1), (2, 3)])\nG.edges(0)# only edges from node 0\n# OutEdgeDataView([(0, 1)])"
                    }
                },
                {
                    "Section ID": "in_edges",
                    "Path": "networkx.DiGraph",
                    "Description": [],
                    "Field List": {
                        "Parameters:": {
                            "nbunch : single node, container, or all nodes (default= all nodes)": "The view will only report edges incident to these nodes.",
                            "data : string or bool, optional (default=False)": "The edge attribute returned in 3-tuple (u, v, ddict[data]).\nIf True, return edge attribute dict in 3-tuple (u, v, ddict).\nIf False, return 2-tuple (u, v).",
                            "default : value, optional (default=None)": "Value used for edges that don\u2019t have the requested attribute.\nOnly relevant if data is not True or False."
                        },
                        "Returns:": {
                            "in_edges : InEdgeView or InEdgeDataView": "A view of edge attributes, usually it iterates over (u, v)\nor (u, v, d) tuples of edges, but can also be used for\nattribute lookup asedges[u,v]['foo']."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.DiGraph()\nG.add_edge(1,2,color=\"blue\")\nG.in_edges()\n# InEdgeView([(1, 2)])\nG.in_edges(nbunch=2)\n# InEdgeDataView([(1, 2)])"
                    }
                },
                {
                    "Section ID": "has_edge",
                    "Path": "networkx.DiGraph",
                    "Description": [
                        "Returns True if the edge (u, v) is in the graph.",
                        "This is the same as vinG[u] without KeyError exceptions."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "u, v : nodes": "Nodes can be, for example, strings or numbers.\nNodes must be hashable (and not None) Python objects."
                        },
                        "Returns:": {
                            "edge_ind : bool": "True if edge is in the graph, False otherwise."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.has_edge(0,1)# using two nodes\n# True\ne=(0,1)\nG.has_edge(*e)#  e is a 2-tuple (u, v)\n# True\ne=(0,1,{\"weight\":7})\nG.has_edge(*e[:2])# e is a 3-tuple (u, v, data_dictionary)\n# True\nThe following syntax are equivalent:\nG.has_edge(0,1)\n# True\n1inG[0]# though this gives KeyError if 0 not in G\n# True"
                    }
                },
                {
                    "Section ID": "get_edge_data",
                    "Path": "networkx.DiGraph",
                    "Description": [
                        "Returns the attribute dictionary associated with edge (u, v).",
                        "This is identical to G[u][v] except the default is returned\ninstead of an exception if the edge doesn\u2019t exist."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "u, v : nodes": "",
                            "default:  any Python object (default=None)": "Value to return if the edge (u, v) is not found."
                        },
                        "Returns:": {
                            "edge_dict : dictionary": "The edge attribute dictionary."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG[0][1]\n# {}\nWarning: Assigning toG[u][v]is not permitted.\nBut it is safe to assign attributesG[u][v]['foo']\nG[0][1][\"weight\"]=7\nG[0][1][\"weight\"]\n# 7\nG[1][0][\"weight\"]\n# 7\nG=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.get_edge_data(0,1)# default edge data is {}\n# {}\ne=(0,1)\nG.get_edge_data(*e)# tuple form\n# {}\nG.get_edge_data(\"a\",\"b\",default=0)# edge not in graph, return 0\n# 0"
                    }
                },
                {
                    "Section ID": "neighbors",
                    "Path": "networkx.DiGraph",
                    "Description": [
                        "Returns an iterator over successor nodes of n.",
                        "A successor of n is a node m such that there exists a directed\nedge from n to m."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "n : node": "A node in the graph"
                        },
                        "Raises:": {
                            "NetworkXError": "If n is not in the graph."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "neighbors() and successors() are the same."
                    }
                },
                {
                    "Section ID": "adj",
                    "Path": "networkx.DiGraph",
                    "Description": [],
                    "Field List": {
                        "Methods": []
                    },
                    "Rubrics": {}
                },
                {
                    "Section ID": "__getitem__",
                    "Path": "networkx.DiGraph",
                    "Description": [
                        "Returns a dict of neighbors of node n.  Use: \u2018G[n]\u2019."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "n : node": "A node in the graph."
                        },
                        "Returns:": {
                            "adj_dict : dictionary": "The adjacency dictionary for nodes connected to n."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "G[n] is the same as G.adj[n] and similar to G.neighbors(n)\n(which is an iterator over G.adj[n])",
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG[0]\n# AtlasView({1: {}})"
                    }
                },
                {
                    "Section ID": "successors",
                    "Path": "networkx.DiGraph",
                    "Description": [
                        "Returns an iterator over successor nodes of n.",
                        "A successor of n is a node m such that there exists a directed\nedge from n to m."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "n : node": "A node in the graph"
                        },
                        "Raises:": {
                            "NetworkXError": "If n is not in the graph."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "neighbors() and successors() are the same."
                    }
                },
                {
                    "Section ID": "succ",
                    "Path": "networkx.DiGraph",
                    "Description": [],
                    "Field List": {
                        "Methods": []
                    },
                    "Rubrics": {}
                },
                {
                    "Section ID": "predecessors",
                    "Path": "networkx.DiGraph",
                    "Description": [
                        "Returns an iterator over predecessor nodes of n.",
                        "A predecessor of n is a node m such that there exists a directed\nedge from m to n."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "n : node": "A node in the graph"
                        },
                        "Raises:": {
                            "NetworkXError": "If n is not in the graph."
                        },
                        "Methods": []
                    },
                    "Rubrics": {}
                },
                {
                    "Section ID": "pred",
                    "Path": "networkx.DiGraph",
                    "Description": [],
                    "Field List": {
                        "Methods": []
                    },
                    "Rubrics": {}
                },
                {
                    "Section ID": "adjacency",
                    "Path": "networkx.DiGraph",
                    "Description": [
                        "Returns an iterator over (node, adjacency dict) tuples for all nodes.",
                        "For directed graphs, only outgoing neighbors/adjacencies are included."
                    ],
                    "Field List": {
                        "Returns:": {
                            "adj_iter : iterator": "An iterator over (node, adjacency dictionary) for all nodes in\nthe graph."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\n[(n,nbrdict)forn,nbrdictinG.adjacency()]\n# [(0, {1: {}}), (1, {0: {}, 2: {}}), (2, {1: {}, 3: {}}), (3, {2: {}})]"
                    }
                },
                {
                    "Section ID": "nbunch_iter",
                    "Path": "networkx.DiGraph",
                    "Description": [
                        "Returns an iterator over nodes contained in nbunch that are\nalso in the graph.",
                        "The nodes in nbunch are checked for membership in the graph\nand if not are silently ignored."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "nbunch : single node, container, or all nodes (default= all nodes)": "The view will only report edges incident to these nodes."
                        },
                        "Returns:": {
                            "niter : iterator": "An iterator over nodes in nbunch that are also in the graph.\nIf nbunch is None, iterate over all nodes in the graph."
                        },
                        "Raises:": {
                            "NetworkXError": "If nbunch is not a node or sequence of nodes.\nIf a node in nbunch is not hashable."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "When nbunch is an iterator, the returned iterator yields values\ndirectly from nbunch, becoming exhausted when nbunch is exhausted. To test whether nbunch is a single node, one can use\n\u201cif nbunch in self:\u201d, even after processing with this routine. If nbunch is not a node or a (possibly empty) sequence/iterator\nor None, a NetworkXError is raised.  Also, if any object in\nnbunch is not hashable, a NetworkXError is raised."
                    }
                },
                {
                    "Section ID": "order",
                    "Path": "networkx.DiGraph",
                    "Description": [
                        "Returns the number of nodes in the graph."
                    ],
                    "Field List": {
                        "Returns:": {
                            "nnodes : int": "The number of nodes in the graph."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(3)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.order()\n# 3"
                    }
                },
                {
                    "Section ID": "number_of_nodes",
                    "Path": "networkx.DiGraph",
                    "Description": [
                        "Returns the number of nodes in the graph."
                    ],
                    "Field List": {
                        "Returns:": {
                            "nnodes : int": "The number of nodes in the graph."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(3)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.number_of_nodes()\n# 3"
                    }
                },
                {
                    "Section ID": "__len__",
                    "Path": "networkx.DiGraph",
                    "Description": [
                        "Returns the number of nodes in the graph. Use: \u2018len(G)\u2019."
                    ],
                    "Field List": {
                        "Returns:": {
                            "nnodes : int": "The number of nodes in the graph."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nlen(G)\n# 4"
                    }
                },
                {
                    "Section ID": "degree",
                    "Path": "networkx.DiGraph",
                    "Description": [],
                    "Field List": {
                        "Parameters:": {
                            "nbunch : single node, container, or all nodes (default= all nodes)": "The view will only report edges incident to these nodes.",
                            "weight : string or None, optional (default=None)": "The name of an edge attribute that holds the numerical value used\nas a weight.  If None, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node."
                        },
                        "Returns:": {
                            "DiDegreeView or int": "If multiple nodes are requested (the default), returns aDiDegreeViewmapping nodes to their degree.\nIf a single node is requested, returns the degree of the node as an integer."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.DiGraph()# or MultiDiGraph\nnx.add_path(G,[0,1,2,3])\nG.degree(0)# node 0 with degree 1\n# 1\nlist(G.degree([0,1,2]))\n# [(0, 1), (1, 2), (2, 2)]"
                    }
                },
                {
                    "Section ID": "in_degree",
                    "Path": "networkx.DiGraph",
                    "Description": [],
                    "Field List": {
                        "Parameters:": {
                            "nbunch : single node, container, or all nodes (default= all nodes)": "The view will only report edges incident to these nodes.",
                            "weight : string or None, optional (default=None)": "The name of an edge attribute that holds the numerical value used\nas a weight.  If None, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node."
                        },
                        "Returns:": {
                            "If a single node is requested": "",
                            "deg : int": "In-degree of the node",
                            "OR if multiple nodes are requested": "",
                            "nd_iter : iterator": "The iterator returns two-tuples of (node, in-degree)."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.DiGraph()\nnx.add_path(G,[0,1,2,3])\nG.in_degree(0)# node 0 with degree 0\n# 0\nlist(G.in_degree([0,1,2]))\n# [(0, 0), (1, 1), (2, 1)]"
                    }
                },
                {
                    "Section ID": "out_degree",
                    "Path": "networkx.DiGraph",
                    "Description": [],
                    "Field List": {
                        "Parameters:": {
                            "nbunch : single node, container, or all nodes (default= all nodes)": "The view will only report edges incident to these nodes.",
                            "weight : string or None, optional (default=None)": "The name of an edge attribute that holds the numerical value used\nas a weight.  If None, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node."
                        },
                        "Returns:": {
                            "If a single node is requested": "",
                            "deg : int": "Out-degree of the node",
                            "OR if multiple nodes are requested": "",
                            "nd_iter : iterator": "The iterator returns two-tuples of (node, out-degree)."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.DiGraph()\nnx.add_path(G,[0,1,2,3])\nG.out_degree(0)# node 0 with degree 1\n# 1\nlist(G.out_degree([0,1,2]))\n# [(0, 1), (1, 1), (2, 1)]"
                    }
                },
                {
                    "Section ID": "size",
                    "Path": "networkx.DiGraph",
                    "Description": [
                        "Returns the number of edges or total of all edge weights."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "weight : string or None, optional (default=None)": "The edge attribute that holds the numerical value used\nas a weight. If None, then each edge has weight 1."
                        },
                        "Returns:": {
                            "size : numeric": "The number of edges or\n(if weight keyword is provided) the total weight sum.If weight is None, returns an int. Otherwise a float\n(or more general numeric if the weights are more general)."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.size()\n# 3\nG=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_edge(\"a\",\"b\",weight=2)\nG.add_edge(\"b\",\"c\",weight=4)\nG.size()\n# 2\nG.size(weight=\"weight\")\n# 6.0"
                    }
                },
                {
                    "Section ID": "number_of_edges",
                    "Path": "networkx.DiGraph",
                    "Description": [
                        "Returns the number of edges between two nodes."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "u, v : nodes, optional (default=all edges)": "If u and v are specified, return the number of edges between\nu and v. Otherwise return the total number of all edges."
                        },
                        "Returns:": {
                            "nedges : int": "The number of edges in the graph.  If nodesuandvare\nspecified return the number of edges between those nodes. If\nthe graph is directed, this only returns the number of edges\nfromutov."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "For undirected graphs, this method counts the total number of\nedges in the graph:\nG=nx.path_graph(4)\nG.number_of_edges()\n# 3\nIf you specify two nodes, this counts the total number of edges\njoining the two nodes:\nG.number_of_edges(0,1)\n# 1\nFor directed graphs, this method can count the total number of\ndirected edges fromutov:\nG=nx.DiGraph()\nG.add_edge(0,1)\nG.add_edge(1,0)\nG.number_of_edges(0,1)\n# 1"
                    }
                },
                {
                    "Section ID": "copy",
                    "Path": "networkx.DiGraph",
                    "Description": [
                        "Returns a copy of the graph.",
                        "The copy method by default returns an independent shallow copy\nof the graph and attributes. That is, if an attribute is a\ncontainer, that container is shared by the original an the copy.\nUse Python\u2019s copy.deepcopy for new containers.",
                        "If as_view is True then a view is returned instead of a copy."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "as_view : bool, optional (default=False)": "If True, the returned graph-view provides a read-only view\nof the original graph without actually copying any data."
                        },
                        "Returns:": {
                            "G : Graph": "A copy of the graph."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "All copies reproduce the graph structure, but data attributes\nmay be handled in different ways. There are four types of copies\nof a graph that people might want. Deepcopy \u2013 A \u201cdeepcopy\u201d copies the graph structure as well as\nall data attributes and any objects they might contain.\nThe entire graph object is new so that changes in the copy\ndo not affect the original object. (see Python\u2019s copy.deepcopy) Data Reference (Shallow) \u2013 For a shallow copy the graph structure\nis copied but the edge, node and graph attribute dicts are\nreferences to those in the original graph. This saves\ntime and memory but could cause confusion if you change an attribute\nin one graph and it changes the attribute in the other.\nNetworkX does not provide this level of shallow copy. Independent Shallow \u2013 This copy creates new independent attribute\ndicts and then does a shallow copy of the attributes. That is, any\nattributes that are containers are shared between the new graph\nand the original. This is exactly what dict.copy() provides.\nYou can obtain this style copy using:",
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nH=G.copy()"
                    }
                },
                {
                    "Section ID": "to_undirected",
                    "Path": "networkx.DiGraph",
                    "Description": [
                        "Returns an undirected representation of the digraph."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "reciprocal : bool (optional)": "If True only keep edges that appear in both directions\nin the original digraph.",
                            "as_view : bool (optional, default=False)": "If True return an undirected view of the original directed graph."
                        },
                        "Returns:": {
                            "G : Graph": "An undirected graph with the same name and nodes and\nwith edge (u, v, data) if either (u, v, data) or (v, u, data)\nis in the digraph.  If both edges exist in digraph and\ntheir edge data is different, only one edge is created\nwith an arbitrary choice of which edge data to use.\nYou must check and correct for this manually if desired."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "If edges in both directions (u, v) and (v, u) exist in the\ngraph, attributes for the new undirected edge will be a combination of\nthe attributes of the directed edges.  The edge data is updated\nin the (arbitrary) order that the edges are encountered.  For\nmore customized control of the edge attributes use add_edge(). This returns a \u201cdeepcopy\u201d of the edge, node, and\ngraph attributes which attempts to completely copy\nall of the data and references. This is in contrast to the similar G=DiGraph(D) which returns a\nshallow copy of the data. See the Python copy module for more information on shallow\nand deep copies, https://docs.python.org/3/library/copy.html . Warning: If you have subclassed DiGraph to use dict-like objects\nin the data structure, those changes do not transfer to the\nGraph created by this method.",
                        "Examples": "G=nx.path_graph(2)# or MultiGraph, etc\nH=G.to_directed()\nlist(H.edges)\n# [(0, 1), (1, 0)]\nG2=H.to_undirected()\nlist(G2.edges)\n# [(0, 1)]"
                    }
                },
                {
                    "Section ID": "to_directed",
                    "Path": "networkx.DiGraph",
                    "Description": [
                        "Returns a directed representation of the graph."
                    ],
                    "Field List": {
                        "Returns:": {
                            "G : DiGraph": "A directed graph with the same name, same nodes, and with\neach edge (u, v, data) replaced by two directed edges\n(u, v, data) and (v, u, data)."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "This returns a \u201cdeepcopy\u201d of the edge, node, and\ngraph attributes which attempts to completely copy\nall of the data and references. This is in contrast to the similar D=DiGraph(G) which returns a\nshallow copy of the data. See the Python copy module for more information on shallow\nand deep copies, https://docs.python.org/3/library/copy.html . Warning: If you have subclassed Graph to use dict-like objects\nin the data structure, those changes do not transfer to the\nDiGraph created by this method.",
                        "Examples": "G=nx.Graph()# or MultiGraph, etc\nG.add_edge(0,1)\nH=G.to_directed()\nlist(H.edges)\n# [(0, 1), (1, 0)]\nIf already directed, return a (deep) copy\nG=nx.DiGraph()# or MultiDiGraph, etc\nG.add_edge(0,1)\nH=G.to_directed()\nlist(H.edges)\n# [(0, 1)]"
                    }
                },
                {
                    "Section ID": "subgraph",
                    "Path": "networkx.DiGraph",
                    "Description": [
                        "Returns a SubGraph view of the subgraph induced on nodes .",
                        "The induced subgraph of the graph contains the nodes in nodes and the edges between those nodes."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "nodes : list, iterable": "A container of nodes which will be iterated through once."
                        },
                        "Returns:": {
                            "G : SubGraph View": "A subgraph view of the graph. The graph structure cannot be\nchanged but node/edge attributes can and are shared with the\noriginal graph."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "The graph, edge and node attributes are shared with the original graph.\nChanges to the graph structure is ruled out by the view, but changes\nto attributes are reflected in the original graph. To create a subgraph with its own copy of the edge/node attributes use:\nG.subgraph(nodes).copy() For an inplace reduction of a graph to a subgraph you can remove nodes:\nG.remove_nodes_from([n for n in G if n not in set(nodes)]) Subgraph views are sometimes NOT what you want. In most cases where\nyou want to do more than simply look at the induced edges, it makes\nmore sense to just create the subgraph as its own graph with code like:",
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nH=G.subgraph([0,1,2])\nlist(H.edges)\n# [(0, 1), (1, 2)]"
                    }
                },
                {
                    "Section ID": "edge_subgraph",
                    "Path": "networkx.DiGraph",
                    "Description": [
                        "Returns the subgraph induced by the specified edges.",
                        "The induced subgraph contains each edge in edges and each\nnode incident to any one of those edges."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "edges : iterable": "An iterable of edges in this graph."
                        },
                        "Returns:": {
                            "G : Graph": "An edge-induced subgraph of this graph with the same edge\nattributes."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "The graph, edge, and node attributes in the returned subgraph\nview are references to the corresponding attributes in the original\ngraph. The view is read-only. To create a full graph version of the subgraph with its own copy\nof the edge or node attributes, use:",
                        "Examples": "G=nx.path_graph(5)\nH=G.edge_subgraph([(0,1),(3,4)])\nlist(H.nodes)\n# [0, 1, 3, 4]\nlist(H.edges)\n# [(0, 1), (3, 4)]"
                    }
                },
                {
                    "Section ID": "reverse",
                    "Path": "networkx.DiGraph",
                    "Description": [
                        "Returns the reverse of the graph.",
                        "The reverse is a graph with the same nodes and edges\nbut with the directions of the edges reversed."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "copy : bool optional (default=True)": "If True, return a new DiGraph holding the reversed edges.\nIf False, the reverse graph is created using a view of\nthe original graph."
                        },
                        "Methods": []
                    },
                    "Rubrics": {}
                }
            ]
        },
        "Rubrics": {
            "Examples": "Create an empty graph structure (a \u201cnull graph\u201d) with no nodes and\nno edges.\nG=nx.DiGraph()\nG can be grown in several ways.\nNodes:\nAdd one node at a time:\nG.add_node(1)\nAdd the nodes from any container (a list, dict, set or\neven the lines from a file or the nodes from another graph).\nG.add_nodes_from([2,3])\nG.add_nodes_from(range(100,110))\nH=nx.path_graph(10)\nG.add_nodes_from(H)\nIn addition to strings and integers any hashable Python object\n(except None) can represent a node, e.g. a customized node object,\nor even another Graph.\nG.add_node(H)\nEdges:\nG can also be grown by adding edges.\nAdd one edge,\nG.add_edge(1,2)\na list of edges,\nG.add_edges_from([(1,2),(1,3)])\nor a collection of edges,\nG.add_edges_from(H.edges)\nIf some edges connect nodes not yet in the graph, the nodes\nare added automatically.  There are no errors when adding\nnodes or edges that already exist.\nAttributes:\nEach graph, node, and edge can hold key/value attribute pairs\nin an associated attribute dictionary (the keys must be hashable).\nBy default these are empty, but can be added or changed using\nadd_edge, add_node or direct manipulation of the attribute\ndictionaries named graph, node and edge respectively.\nG=nx.DiGraph(day=\"Friday\")\nG.graph\n# {'day': 'Friday'}\nAdd node attributes using add_node(), add_nodes_from() or G.nodes\nG.add_node(1,time=\"5pm\")\nG.add_nodes_from([3],time=\"2pm\")\nG.nodes[1]\n# {'time': '5pm'}\nG.nodes[1][\"room\"]=714\ndelG.nodes[1][\"room\"]# remove attribute\nlist(G.nodes(data=True))\n# [(1, {'time': '5pm'}), (3, {'time': '2pm'})]\nAdd edge attributes using add_edge(), add_edges_from(), subscript\nnotation, or G.edges.\nG.add_edge(1,2,weight=4.7)\nG.add_edges_from([(3,4),(4,5)],color=\"red\")\nG.add_edges_from([(1,2,{\"color\":\"blue\"}),(2,3,{\"weight\":8})])\nG[1][2][\"weight\"]=4.7\nG.edges[1,2][\"weight\"]=4\nWarning: we protect the graph data structure by makingG.edges[1,2]a\nread-only dict-like structure. However, you can assign to attributes\nin e.g.G.edges[1,2]. Thus, use 2 sets of brackets to add/change\ndata attributes:G.edges[1,2]['weight']=4(For multigraphs:MG.edges[u,v,key][name]=value).\nShortcuts:\nMany common graph features allow python syntax to speed reporting.\n1inG# check if node in graph\n# True\n[nforninGifn<3]# iterate through nodes\n# [1, 2]\nlen(G)# number of nodes in graph\n# 5\nOften the best way to traverse all edges of a graph is via the neighbors.\nThe neighbors are reported as an adjacency-dictG.adjorG.adjacency()\nforn,nbrsdictinG.adjacency():\nfornbr,eattrinnbrsdict.items():\nif\"weight\"ineattr:\n# Do something useful with the edges\npass\nBut the edges reporting object is often more convenient:\nforu,v,weightinG.edges(data=\"weight\"):\nifweightisnotNone:\n# Do something useful with the edges\npass\nReporting:\nSimple graph information is obtained using object-attributes and methods.\nReporting usually provides views instead of containers to reduce memory\nusage. The views update as the graph is updated similarly to dict-views.\nThe objectsnodes,edgesandadjprovide access to data attributes\nvia lookup (e.g.nodes[n],edges[u,v],adj[u][v]) and iteration\n(e.g.nodes.items(),nodes.data('color'),nodes.data('color',default='blue')and similarly foredges)\nViews exist fornodes,edges,neighbors()/adjanddegree.\nFor details on these and other miscellaneous methods, see below.\nSubclasses (Advanced):\nThe Graph class uses a dict-of-dict-of-dict data structure.\nThe outer dict (node_dict) holds adjacency information keyed by node.\nThe next dict (adjlist_dict) represents the adjacency information and holds\nedge data keyed by neighbor.  The inner dict (edge_attr_dict) represents\nthe edge data and holds edge attribute values keyed by attribute names.\nEach of these three dicts can be replaced in a subclass by a user defined\ndict-like object. In general, the dict-like features should be\nmaintained but extra features can be added. To replace one of the\ndicts create a new graph class by changing the class(!) variable\nholding the factory for that dict-like structure. The variable names are\nnode_dict_factory, node_attr_dict_factory, adjlist_inner_dict_factory,\nadjlist_outer_dict_factory, edge_attr_dict_factory and graph_attr_dict_factory."
        }
    },
    {
        "Section ID": "MultiGraph",
        "Description": [
            "An undirected graph class that can store multiedges.",
            "Multiedges are multiple edges between two nodes.  Each edge\ncan hold optional data or attributes.",
            "A MultiGraph holds undirected edges.  Self loops are allowed.",
            "Nodes can be arbitrary (hashable) Python objects with optional\nkey/value attributes. By convention None is not used as a node.",
            "Edges are represented as links between nodes with optional\nkey/value attributes, in a MultiGraph each edge has a key to\ndistinguish between multiple edges that have the same source and\ndestination nodes."
        ],
        "Field List": {
            "Parameters:": {
                "incoming_graph_data : input graph (optional, default: None)": "Data to initialize graph. If None (default) an empty\ngraph is created.  The data can be any format that is supported\nby the to_networkx_graph() function, currently including edge list,\ndict of dicts, dict of lists, NetworkX graph, 2D NumPy array,\nSciPy sparse array, or PyGraphviz graph.",
                "multigraph_input : bool or None (default None)": "Note: Only used whenincoming_graph_datais a dict.\nIf True,incoming_graph_datais assumed to be a\ndict-of-dict-of-dict-of-dict structure keyed by\nnode to neighbor to edge keys to edge data for multi-edges.\nA NetworkXError is raised if this is not the case.\nIf False,to_networkx_graph()is used to try to determine\nthe dict\u2019s graph data structure as either a dict-of-dict-of-dict\nkeyed by node to neighbor to edge data, or a dict-of-iterable\nkeyed by node to neighbors.\nIf None, the treatment for True is tried, but if it fails,\nthe treatment for False is tried.",
                "attr : keyword arguments, optional (default= no attributes)": "Attributes to add to graph as key=value pairs."
            },
            "Methods": [
                {
                    "Section ID": "__init__",
                    "Path": "networkx.MultiGraph",
                    "Description": [
                        "Initialize a graph with edges, name, or graph attributes."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "incoming_graph_data : input graph": "Data to initialize graph.  If incoming_graph_data=None (default)\nan empty graph is created.  The data can be an edge list, or any\nNetworkX graph object.  If the corresponding optional Python\npackages are installed the data can also be a 2D NumPy array, a\nSciPy sparse array, or a PyGraphviz graph.",
                            "multigraph_input : bool or None (default None)": "Note: Only used whenincoming_graph_datais a dict.\nIf True,incoming_graph_datais assumed to be a\ndict-of-dict-of-dict-of-dict structure keyed by\nnode to neighbor to edge keys to edge data for multi-edges.\nA NetworkXError is raised if this is not the case.\nIf False,to_networkx_graph()is used to try to determine\nthe dict\u2019s graph data structure as either a dict-of-dict-of-dict\nkeyed by node to neighbor to edge data, or a dict-of-iterable\nkeyed by node to neighbors.\nIf None, the treatment for True is tried, but if it fails,\nthe treatment for False is tried.",
                            "attr : keyword arguments, optional (default= no attributes)": "Attributes to add to graph as key=value pairs."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.MultiGraph()\nG=nx.MultiGraph(name=\"my graph\")\ne=[(1,2),(1,2),(2,3),(3,4)]# list of edges\nG=nx.MultiGraph(e)\nArbitrary graph attribute pairs (key=value) may be assigned\nG=nx.MultiGraph(e,day=\"Friday\")\nG.graph\n# {'day': 'Friday'}"
                    }
                },
                {
                    "Section ID": "add_node",
                    "Path": "networkx.MultiGraph",
                    "Description": [
                        "Add a single node node_for_adding and update node attributes."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "node_for_adding : node": "A node can be any hashable Python object except None.",
                            "attr : keyword arguments, optional": "Set or change node attributes using key=value."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "A hashable object is one that can be used as a key in a Python\ndictionary. This includes strings, numbers, tuples of strings\nand numbers, etc. On many platforms hashable items also include mutables such as\nNetworkX Graphs, though one should be careful that the hash\ndoesn\u2019t change on mutables.",
                        "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_node(1)\nG.add_node(\"Hello\")\nK3=nx.Graph([(0,1),(1,2),(2,0)])\nG.add_node(K3)\nG.number_of_nodes()\n# 3\nUse keywords set/change node attributes:\nG.add_node(1,size=10)\nG.add_node(3,weight=0.4,UTM=(\"13S\",382871,3972649))"
                    }
                },
                {
                    "Section ID": "add_nodes_from",
                    "Path": "networkx.MultiGraph",
                    "Description": [
                        "Add multiple nodes."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "nodes_for_adding : iterable container": "A container of nodes (list, dict, set, etc.).\nOR\nA container of (node, attribute dict) tuples.\nNode attributes are updated using the attribute dict.",
                            "attr : keyword arguments, optional (default= no attributes)": "Update attributes for all nodes in nodes.\nNode attributes specified in nodes as a tuple take\nprecedence over attributes specified via keyword arguments."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "When adding nodes from an iterator over the graph you are changing,\na RuntimeError can be raised with message: RuntimeError:dictionarychangedsizeduringiteration . This\nhappens when the graph\u2019s underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using list(iterator_of_nodes) , and pass this\nobject to G.add_nodes_from .",
                        "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_nodes_from(\"Hello\")\nK3=nx.Graph([(0,1),(1,2),(2,0)])\nG.add_nodes_from(K3)\nsorted(G.nodes(),key=str)\n# [0, 1, 2, 'H', 'e', 'l', 'o']\nUse keywords to update specific node attributes for every node.\nG.add_nodes_from([1,2],size=10)\nG.add_nodes_from([3,4],weight=0.4)\nUse (node, attrdict) tuples to update attributes for specific nodes.\nG.add_nodes_from([(1,dict(size=11)),(2,{\"color\":\"blue\"})])\nG.nodes[1][\"size\"]\n# 11\nH=nx.Graph()\nH.add_nodes_from(G.nodes(data=True))\nH.nodes[1][\"size\"]\n# 11\nEvaluate an iterator over a graph if using it to modify the same graph\nG=nx.Graph([(0,1),(1,2),(3,4)])\n# wrong way - will raise RuntimeError\n# G.add_nodes_from(n + 1 for n in G.nodes)\n# correct way\nG.add_nodes_from(list(n+1forninG.nodes))"
                    }
                },
                {
                    "Section ID": "remove_node",
                    "Path": "networkx.MultiGraph",
                    "Description": [
                        "Remove node n.",
                        "Removes the node n and all adjacent edges.\nAttempting to remove a nonexistent node will raise an exception."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "n : node": "A node in the graph"
                        },
                        "Raises:": {
                            "NetworkXError": "If n is not in the graph."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(3)# or DiGraph, MultiGraph, MultiDiGraph, etc\nlist(G.edges)\n# [(0, 1), (1, 2)]\nG.remove_node(1)\nlist(G.edges)\n# []"
                    }
                },
                {
                    "Section ID": "remove_nodes_from",
                    "Path": "networkx.MultiGraph",
                    "Description": [
                        "Remove multiple nodes."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "nodes : iterable container": "A container of nodes (list, dict, set, etc.).  If a node\nin the container is not in the graph it is silently\nignored."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "When removing nodes from an iterator over the graph you are changing,\na RuntimeError will be raised with message: RuntimeError:dictionarychangedsizeduringiteration . This\nhappens when the graph\u2019s underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using list(iterator_of_nodes) , and pass this\nobject to G.remove_nodes_from .",
                        "Examples": "G=nx.path_graph(3)# or DiGraph, MultiGraph, MultiDiGraph, etc\ne=list(G.nodes)\ne\n# [0, 1, 2]\nG.remove_nodes_from(e)\nlist(G.nodes)\n# []\nEvaluate an iterator over a graph if using it to modify the same graph\nG=nx.Graph([(0,1),(1,2),(3,4)])\n# this command will fail, as the graph's dict is modified during iteration\n# G.remove_nodes_from(n for n in G.nodes if n < 2)\n# this command will work, since the dictionary underlying graph is not modified\nG.remove_nodes_from(list(nforninG.nodesifn<2))"
                    }
                },
                {
                    "Section ID": "add_edge",
                    "Path": "networkx.MultiGraph",
                    "Description": [
                        "Add an edge between u and v.",
                        "The nodes u and v will be automatically added if they are\nnot already in the graph.",
                        "Edge attributes can be specified with keywords or by directly\naccessing the edge\u2019s attribute dictionary. See examples below."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "u_for_edge, v_for_edge : nodes": "Nodes can be, for example, strings or numbers.\nNodes must be hashable (and not None) Python objects.",
                            "key : hashable identifier, optional (default=lowest unused integer)": "Used to distinguish multiedges between a pair of nodes.",
                            "attr : keyword arguments, optional": "Edge data (or labels or objects) can be assigned using\nkeyword arguments."
                        },
                        "Returns:": {
                            "The edge key assigned to the edge.": ""
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "To replace/update edge data, use the optional key argument\nto identify a unique edge.  Otherwise a new edge will be created. NetworkX algorithms designed for weighted graphs cannot use\nmultigraphs directly because it is not clear how to handle\nmultiedge weights.  Convert to Graph using edge attribute\n\u2018weight\u2019 to enable weighted graph algorithms. Default keys are generated using the method new_edge_key() .\nThis method can be overridden by subclassing the base class and\nproviding a custom new_edge_key() method.",
                        "Examples": "The following each add an additional edge e=(1, 2) to graph G:\nG=nx.MultiGraph()\ne=(1,2)\nekey=G.add_edge(1,2)# explicit two-node form\nG.add_edge(*e)# single edge as tuple of two nodes\n# 1\nG.add_edges_from([(1,2)])# add edges from iterable container\n# [2]\nAssociate data to edges using keywords:\nekey=G.add_edge(1,2,weight=3)\nekey=G.add_edge(1,2,key=0,weight=4)# update data for key=0\nekey=G.add_edge(1,3,weight=7,capacity=15,length=342.7)\nFor non-string attribute keys, use subscript notation.\nekey=G.add_edge(1,2)\nG[1][2][0].update({0:5})\nG.edges[1,2,0].update({0:5})"
                    }
                },
                {
                    "Section ID": "add_edges_from",
                    "Path": "networkx.MultiGraph",
                    "Description": [
                        "Add all the edges in ebunch_to_add."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "ebunch_to_add : container of edges": "Each edge given in the container will be added to the\ngraph. The edges can be:2-tuples (u, v) or3-tuples (u, v, d) for an edge data dict d, or3-tuples (u, v, k) for not iterable key k, or4-tuples (u, v, k, d) for an edge with data and key k",
                            "attr : keyword arguments, optional": "Edge data (or labels or objects) can be assigned using\nkeyword arguments."
                        },
                        "Returns:": {
                            "A list of edge keys assigned to the edges in : ebunch : .": ""
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "Adding the same edge twice has no effect but any edge data\nwill be updated when each duplicate edge is added. Edge attributes specified in an ebunch take precedence over\nattributes specified via keyword arguments. Default keys are generated using the method new_edge_key() .\nThis method can be overridden by subclassing the base class and\nproviding a custom new_edge_key() method. When adding edges from an iterator over the graph you are changing,\na RuntimeError can be raised with message: RuntimeError:dictionarychangedsizeduringiteration . This\nhappens when the graph\u2019s underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using list(iterator_of_edges) , and pass this\nobject to G.add_edges_from .",
                        "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_edges_from([(0,1),(1,2)])# using a list of edge tuples\ne=zip(range(0,3),range(1,4))\nG.add_edges_from(e)# Add the path graph 0-1-2-3\nAssociate data to edges\nG.add_edges_from([(1,2),(2,3)],weight=3)\nG.add_edges_from([(3,4),(1,4)],label=\"WN2898\")\nEvaluate an iterator over a graph if using it to modify the same graph\nG=nx.MultiGraph([(1,2),(2,3),(3,4)])\n# Grow graph by one new node, adding edges to all existing nodes.\n# wrong way - will raise RuntimeError\n# G.add_edges_from(((5, n) for n in G.nodes))\n# right way - note that there will be no self-edge for node 5\nassigned_keys=G.add_edges_from(list((5,n)forninG.nodes))"
                    }
                },
                {
                    "Section ID": "add_weighted_edges_from",
                    "Path": "networkx.MultiGraph",
                    "Description": [
                        "Add weighted edges in ebunch_to_add with specified weight attr"
                    ],
                    "Field List": {
                        "Parameters:": {
                            "ebunch_to_add : container of edges": "Each edge given in the list or container will be added\nto the graph. The edges must be given as 3-tuples (u, v, w)\nwhere w is a number.",
                            "weight : string, optional (default= \u2018weight\u2019)": "The attribute name for the edge weights to be added.",
                            "attr : keyword arguments, optional (default= no attributes)": "Edge attributes to add/update for all edges."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "Adding the same edge twice for Graph/DiGraph simply updates\nthe edge data. For MultiGraph/MultiDiGraph, duplicate edges\nare stored. When adding edges from an iterator over the graph you are changing,\na RuntimeError can be raised with message: RuntimeError:dictionarychangedsizeduringiteration . This\nhappens when the graph\u2019s underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using list(iterator_of_edges) , and pass this\nobject to G.add_weighted_edges_from .",
                        "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_weighted_edges_from([(0,1,3.0),(1,2,7.5)])\nEvaluate an iterator over edges before passing it\nG=nx.Graph([(1,2),(2,3),(3,4)])\nweight=0.1\n# Grow graph by one new node, adding edges to all existing nodes.\n# wrong way - will raise RuntimeError\n# G.add_weighted_edges_from(((5, n, weight) for n in G.nodes))\n# correct way - note that there will be no self-edge for node 5\nG.add_weighted_edges_from(list((5,n,weight)forninG.nodes))"
                    }
                },
                {
                    "Section ID": "new_edge_key",
                    "Path": "networkx.MultiGraph",
                    "Description": [
                        "Returns an unused key for edges between nodes u and v .",
                        "The nodes u and v do not need to be already in the graph."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "u, v : nodes": ""
                        },
                        "Returns:": {
                            "key : int": ""
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "In the standard MultiGraph class the new key is the number of existing\nedges between u and v (increased if necessary to ensure unused).\nThe first edge will have key 0, then 1, etc. If an edge is removed\nfurther new_edge_keys may not be in this order."
                    }
                },
                {
                    "Section ID": "remove_edge",
                    "Path": "networkx.MultiGraph",
                    "Description": [
                        "Remove an edge between u and v."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "u, v : nodes": "Remove an edge between nodes u and v.",
                            "key : hashable identifier, optional (default=None)": "Used to distinguish multiple edges between a pair of nodes.\nIf None, remove a single edge between u and v. If there are\nmultiple edges, removes the last edge added in terms of\ninsertion order."
                        },
                        "Raises:": {
                            "NetworkXError": "If there is not an edge between u and v, or\nif there is no edge with the specified key."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.MultiGraph()\nnx.add_path(G,[0,1,2,3])\nG.remove_edge(0,1)\ne=(1,2)\nG.remove_edge(*e)# unpacks e from an edge tuple\nFor multiple edges\nG=nx.MultiGraph()# or MultiDiGraph, etc\nG.add_edges_from([(1,2),(1,2),(1,2)])# key_list returned\n# [0, 1, 2]\nWhenkey=None(the default), edges are removed in the opposite\norder that they were added:\nG.remove_edge(1,2)\nG.edges(keys=True)\n# MultiEdgeView([(1, 2, 0), (1, 2, 1)])\nG.remove_edge(2,1)# edges are not directed\nG.edges(keys=True)\n# MultiEdgeView([(1, 2, 0)])\nFor edges with keys\nG=nx.MultiGraph()\nG.add_edge(1,2,key=\"first\")\n# 'first'\nG.add_edge(1,2,key=\"second\")\n# 'second'\nG.remove_edge(1,2,key=\"first\")\nG.edges(keys=True)\n# MultiEdgeView([(1, 2, 'second')])"
                    }
                },
                {
                    "Section ID": "remove_edges_from",
                    "Path": "networkx.MultiGraph",
                    "Description": [
                        "Remove all edges specified in ebunch."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "ebunch: list or container of edge tuples": "Each edge given in the list or container will be removed\nfrom the graph. The edges can be:2-tuples (u, v) A single edge between u and v is removed.3-tuples (u, v, key) The edge identified by key is removed.4-tuples (u, v, key, data) where data is ignored."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "Will fail silently if an edge in ebunch is not in the graph.",
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nebunch=[(1,2),(2,3)]\nG.remove_edges_from(ebunch)\nRemoving multiple copies of edges\nG=nx.MultiGraph()\nkeys=G.add_edges_from([(1,2),(1,2),(1,2)])\nG.remove_edges_from([(1,2),(2,1)])# edges aren't directed\nlist(G.edges())\n# [(1, 2)]\nG.remove_edges_from([(1,2),(1,2)])# silently ignore extra copy\nlist(G.edges)# now empty graph\n# []\nWhen the edge is a 2-tuple(u,v)but there are multiple edges between\nu and v in the graph, the most recent edge (in terms of insertion\norder) is removed.\nG=nx.MultiGraph()\nforkeyin(\"x\",\"y\",\"a\"):\nk=G.add_edge(0,1,key=key)\nG.edges(keys=True)\n# MultiEdgeView([(0, 1, 'x'), (0, 1, 'y'), (0, 1, 'a')])\nG.remove_edges_from([(0,1)])\nG.edges(keys=True)\n# MultiEdgeView([(0, 1, 'x'), (0, 1, 'y')])"
                    }
                },
                {
                    "Section ID": "update",
                    "Path": "networkx.MultiGraph",
                    "Description": [
                        "Update the graph using nodes/edges/graphs as input.",
                        "Like dict.update, this method takes a graph as input, adding the\ngraph\u2019s nodes and edges to this graph. It can also take two inputs:\nedges and nodes. Finally it can take either edges or nodes.\nTo specify only nodes the keyword nodes must be used.",
                        "The collections of edges and nodes are treated similarly to\nthe add_edges_from/add_nodes_from methods. When iterated, they\nshould yield 2-tuples (u, v) or 3-tuples (u, v, datadict)."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "edges : Graph object, collection of edges, or None": "The first parameter can be a graph or some edges. If it has\nattributesnodesandedges, then it is taken to be a\nGraph-like object and those attributes are used as collections\nof nodes and edges to be added to the graph.\nIf the first parameter does not have those attributes, it is\ntreated as a collection of edges and added to the graph.\nIf the first argument is None, no edges are added.",
                            "nodes : collection of nodes, or None": "The second parameter is treated as a collection of nodes\nto be added to the graph unless it is None.\nIfedgesisNoneandnodesisNonean exception is raised.\nIf the first parameter is a Graph, thennodesis ignored."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "It you want to update the graph using an adjacency structure\nit is straightforward to obtain the edges/nodes from adjacency.\nThe following examples provide common cases, your adjacency may\nbe slightly different and require tweaks of these examples:",
                        "Examples": "G=nx.path_graph(5)\nG.update(nx.complete_graph(range(4,10)))\nfromitertoolsimportcombinations\nedges=(\n(u,v,{\"power\":u*v})\nforu,vincombinations(range(10,20),2)\nifu*v<225\n)\nnodes=[1000]# for singleton, use a container\nG.update(edges,nodes)"
                    }
                },
                {
                    "Section ID": "clear",
                    "Path": "networkx.MultiGraph",
                    "Description": [
                        "Remove all nodes and edges from the graph.",
                        "This also removes the name, and all graph, node, and edge attributes.",
                        "Examples"
                    ],
                    "Field List": {
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.clear()\nlist(G.nodes)\n# []\nlist(G.edges)\n# []"
                    }
                },
                {
                    "Section ID": "clear_edges",
                    "Path": "networkx.MultiGraph",
                    "Description": [
                        "Remove all edges from the graph without altering nodes.",
                        "Examples"
                    ],
                    "Field List": {
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.clear_edges()\nlist(G.nodes)\n# [0, 1, 2, 3]\nlist(G.edges)\n# []"
                    }
                },
                {
                    "Section ID": "nodes",
                    "Path": "networkx.MultiGraph",
                    "Description": [],
                    "Field List": {
                        "Parameters:": {
                            "data : string or bool, optional (default=False)": "The node attribute returned in 2-tuple (n, ddict[data]).\nIf True, return entire node attribute dict as (n, ddict).\nIf False, return just the nodes n.",
                            "default : value, optional (default=None)": "Value used for nodes that don\u2019t have the requested attribute.\nOnly relevant if data is not True or False."
                        },
                        "Returns:": {
                            "NodeView": "Allows set-like operations over the nodes as well as node\nattribute dict lookup and calling to get a NodeDataView.\nA NodeDataView iterates over(n,data)and has no set operations.\nA NodeView iterates overnand includes set operations.When called, if data is False, an iterator over nodes.\nOtherwise an iterator of 2-tuples (node, attribute value)\nwhere the attribute is specified indata.\nIf data is True then the attribute becomes the\nentire data dictionary."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "If your node data is not needed, it is simpler and equivalent\nto use the expression forninG , or list(G) .",
                        "Examples": "There are two simple ways of getting a list of all nodes in the graph:\nG=nx.path_graph(3)\nlist(G.nodes)\n# [0, 1, 2]\nlist(G)\n# [0, 1, 2]\nTo get the node data along with the nodes:\nG.add_node(1,time=\"5pm\")\nG.nodes[0][\"foo\"]=\"bar\"\nlist(G.nodes(data=True))\n# [(0, {'foo': 'bar'}), (1, {'time': '5pm'}), (2, {})]\nlist(G.nodes.data())\n# [(0, {'foo': 'bar'}), (1, {'time': '5pm'}), (2, {})]\nlist(G.nodes(data=\"foo\"))\n# [(0, 'bar'), (1, None), (2, None)]\nlist(G.nodes.data(\"foo\"))\n# [(0, 'bar'), (1, None), (2, None)]\nlist(G.nodes(data=\"time\"))\n# [(0, None), (1, '5pm'), (2, None)]\nlist(G.nodes.data(\"time\"))\n# [(0, None), (1, '5pm'), (2, None)]\nlist(G.nodes(data=\"time\",default=\"Not Available\"))\n# [(0, 'Not Available'), (1, '5pm'), (2, 'Not Available')]\nlist(G.nodes.data(\"time\",default=\"Not Available\"))\n# [(0, 'Not Available'), (1, '5pm'), (2, 'Not Available')]\nIf some of your nodes have an attribute and the rest are assumed\nto have a default attribute value you can create a dictionary\nfrom node/attribute pairs using thedefaultkeyword argument\nto guarantee the value is never None:\nG=nx.Graph()\nG.add_node(0)\nG.add_node(1,weight=2)\nG.add_node(2,weight=3)\ndict(G.nodes(data=\"weight\",default=1))\n# {0: 1, 1: 2, 2: 3}"
                    }
                },
                {
                    "Section ID": "__iter__",
                    "Path": "networkx.MultiGraph",
                    "Description": [
                        "Iterate over the nodes. Use: \u2018for n in G\u2019."
                    ],
                    "Field List": {
                        "Returns:": {
                            "niter : iterator": "An iterator over all nodes in the graph."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\n[nforninG]\n# [0, 1, 2, 3]\nlist(G)\n# [0, 1, 2, 3]"
                    }
                },
                {
                    "Section ID": "has_node",
                    "Path": "networkx.MultiGraph",
                    "Description": [
                        "Returns True if the graph contains the node n.",
                        "Identical to ninG"
                    ],
                    "Field List": {
                        "Parameters:": {
                            "n : node": ""
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(3)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.has_node(0)\n# True\nIt is more readable and simpler to use\n0inG\n# True"
                    }
                },
                {
                    "Section ID": "__contains__",
                    "Path": "networkx.MultiGraph",
                    "Description": [
                        "Returns True if n is a node, False otherwise. Use: \u2018n in G\u2019.",
                        "Examples"
                    ],
                    "Field List": {
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\n1inG\n# True"
                    }
                },
                {
                    "Section ID": "edges",
                    "Path": "networkx.MultiGraph",
                    "Description": [],
                    "Field List": {
                        "Parameters:": {
                            "nbunch : single node, container, or all nodes (default= all nodes)": "The view will only report edges from these nodes.",
                            "data : string or bool, optional (default=False)": "The edge attribute returned in 3-tuple (u, v, ddict[data]).\nIf True, return edge attribute dict in 3-tuple (u, v, ddict).\nIf False, return 2-tuple (u, v).",
                            "keys : bool, optional (default=False)": "If True, return edge keys with each edge, creating (u, v, k)\ntuples or (u, v, k, d) tuples if data is also requested.",
                            "default : value, optional (default=None)": "Value used for edges that don\u2019t have the requested attribute.\nOnly relevant if data is not True or False."
                        },
                        "Returns:": {
                            "edges : MultiEdgeView": "A view of edge attributes, usually it iterates over (u, v)\n(u, v, k) or (u, v, k, d) tuples of edges, but can also be\nused for attribute lookup asedges[u,v,k]['foo']."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "Nodes in nbunch that are not in the graph will be (quietly) ignored.\nFor directed graphs this returns the out-edges.",
                        "Examples": "G=nx.MultiGraph()\nnx.add_path(G,[0,1,2])\nkey=G.add_edge(2,3,weight=5)\nkey2=G.add_edge(2,1,weight=2)# multi-edge\n[eforeinG.edges()]\n# [(0, 1), (1, 2), (1, 2), (2, 3)]\nG.edges.data()# default data is {} (empty dict)\n# MultiEdgeDataView([(0, 1, {}), (1, 2, {}), (1, 2, {'weight': 2}), (2, 3, {'weight': 5})])\nG.edges.data(\"weight\",default=1)\n# MultiEdgeDataView([(0, 1, 1), (1, 2, 1), (1, 2, 2), (2, 3, 5)])\nG.edges(keys=True)# default keys are integers\n# MultiEdgeView([(0, 1, 0), (1, 2, 0), (1, 2, 1), (2, 3, 0)])\nG.edges.data(keys=True)\n# MultiEdgeDataView([(0, 1, 0, {}), (1, 2, 0, {}), (1, 2, 1, {'weight': 2}), (2, 3, 0, {'weight': 5})])\nG.edges.data(\"weight\",default=1,keys=True)\n# MultiEdgeDataView([(0, 1, 0, 1), (1, 2, 0, 1), (1, 2, 1, 2), (2, 3, 0, 5)])\nG.edges([0,3])# Note ordering of tuples from listed sources\n# MultiEdgeDataView([(0, 1), (3, 2)])\nG.edges([0,3,2,1])# Note ordering of tuples\n# MultiEdgeDataView([(0, 1), (3, 2), (2, 1), (2, 1)])\nG.edges(0)\n# MultiEdgeDataView([(0, 1)])"
                    }
                },
                {
                    "Section ID": "has_edge",
                    "Path": "networkx.MultiGraph",
                    "Description": [
                        "Returns True if the graph has an edge between nodes u and v.",
                        "This is the same as vinG[u]orkeyinG[u][v] without KeyError exceptions."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "u, v : nodes": "Nodes can be, for example, strings or numbers.",
                            "key : hashable identifier, optional (default=None)": "If specified return True only if the edge with\nkey is found."
                        },
                        "Returns:": {
                            "edge_ind : bool": "True if edge is in the graph, False otherwise."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "Can be called either using two nodes u, v, an edge tuple (u, v),\nor an edge tuple (u, v, key).\nG=nx.MultiGraph()# or MultiDiGraph\nnx.add_path(G,[0,1,2,3])\nG.has_edge(0,1)# using two nodes\n# True\ne=(0,1)\nG.has_edge(*e)#  e is a 2-tuple (u, v)\n# True\nG.add_edge(0,1,key=\"a\")\n# 'a'\nG.has_edge(0,1,key=\"a\")# specify key\n# True\nG.has_edge(1,0,key=\"a\")# edges aren't directed\n# True\ne=(0,1,\"a\")\nG.has_edge(*e)# e is a 3-tuple (u, v, 'a')\n# True\nThe following syntax are equivalent:\nG.has_edge(0,1)\n# True\n1inG[0]# though this gives :exc:`KeyError` if 0 not in G\n# True\n0inG[1]# other order; also gives :exc:`KeyError` if 0 not in G\n# True"
                    }
                },
                {
                    "Section ID": "get_edge_data",
                    "Path": "networkx.MultiGraph",
                    "Description": [
                        "Returns the attribute dictionary associated with edge (u, v,\nkey).",
                        "If a key is not provided, returns a dictionary mapping edge keys\nto attribute dictionaries for each edge between u and v.",
                        "This is identical to G[u][v][key] except the default is returned\ninstead of an exception is the edge doesn\u2019t exist."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "u, v : nodes": "",
                            "default : any Python object (default=None)": "Value to return if the specific edge (u, v, key) is not\nfound, OR if there are no edges between u and v and no key\nis specified.",
                            "key : hashable identifier, optional (default=None)": "Return data only for the edge with specified key, as an\nattribute dictionary (rather than a dictionary mapping keys\nto attribute dictionaries)."
                        },
                        "Returns:": {
                            "edge_dict : dictionary": "The edge attribute dictionary, OR a dictionary mapping edge\nkeys to attribute dictionaries for each of those edges if no\nspecific key is provided (even if there\u2019s only one edge\nbetween u and v)."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.MultiGraph()# or MultiDiGraph\nkey=G.add_edge(0,1,key=\"a\",weight=7)\nG[0][1][\"a\"]# key='a'\n# {'weight': 7}\nG.edges[0,1,\"a\"]# key='a'\n# {'weight': 7}\nWarning: we protect the graph data structure by makingG.edgesandG[1][2]read-only dict-like structures.\nHowever, you can assign values to attributes in e.g.G.edges[1,2,'a']orG[1][2]['a']using an additional\nbracket as shown next. You need to specify all edge info\nto assign to the edge data associated with an edge.\nG[0][1][\"a\"][\"weight\"]=10\nG.edges[0,1,\"a\"][\"weight\"]=10\nG[0][1][\"a\"][\"weight\"]\n# 10\nG.edges[1,0,\"a\"][\"weight\"]\n# 10\nG=nx.MultiGraph()# or MultiDiGraph\nnx.add_path(G,[0,1,2,3])\nG.edges[0,1,0][\"weight\"]=5\nG.get_edge_data(0,1)\n# {0: {'weight': 5}}\ne=(0,1)\nG.get_edge_data(*e)# tuple form\n# {0: {'weight': 5}}\nG.get_edge_data(3,0)# edge not in graph, returns None\nG.get_edge_data(3,0,default=0)# edge not in graph, return default\n# 0\nG.get_edge_data(1,0,0)# specific key gives back\n# {'weight': 5}"
                    }
                },
                {
                    "Section ID": "neighbors",
                    "Path": "networkx.MultiGraph",
                    "Description": [
                        "Returns an iterator over all neighbors of node n.",
                        "This is identical to iter(G[n])"
                    ],
                    "Field List": {
                        "Parameters:": {
                            "n : node": "A node in the graph"
                        },
                        "Returns:": {
                            "neighbors : iterator": "An iterator over all neighbors of node n"
                        },
                        "Raises:": {
                            "NetworkXError": "If the node n is not in the graph."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "Alternate ways to access the neighbors are G.adj[n] or G[n] :",
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\n[nforninG.neighbors(0)]\n# [1]"
                    }
                },
                {
                    "Section ID": "adj",
                    "Path": "networkx.MultiGraph",
                    "Description": [],
                    "Field List": {
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "e=[(1,2),(1,2),(1,3),(3,4)]# list of edges\nG=nx.MultiGraph(e)\nG.edges[1,2,0][\"weight\"]=3\nresult=set()\nforedgekey,datainG[1][2].items():\nresult.add(data.get(\"weight\",1))\nresult\n# {1, 3}\nFor directed graphs,G.adjholds outgoing (successor) info."
                    }
                },
                {
                    "Section ID": "__getitem__",
                    "Path": "networkx.MultiGraph",
                    "Description": [
                        "Returns a dict of neighbors of node n.  Use: \u2018G[n]\u2019."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "n : node": "A node in the graph."
                        },
                        "Returns:": {
                            "adj_dict : dictionary": "The adjacency dictionary for nodes connected to n."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "G[n] is the same as G.adj[n] and similar to G.neighbors(n)\n(which is an iterator over G.adj[n])",
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG[0]\n# AtlasView({1: {}})"
                    }
                },
                {
                    "Section ID": "adjacency",
                    "Path": "networkx.MultiGraph",
                    "Description": [
                        "Returns an iterator over (node, adjacency dict) tuples for all nodes.",
                        "For directed graphs, only outgoing neighbors/adjacencies are included."
                    ],
                    "Field List": {
                        "Returns:": {
                            "adj_iter : iterator": "An iterator over (node, adjacency dictionary) for all nodes in\nthe graph."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\n[(n,nbrdict)forn,nbrdictinG.adjacency()]\n# [(0, {1: {}}), (1, {0: {}, 2: {}}), (2, {1: {}, 3: {}}), (3, {2: {}})]"
                    }
                },
                {
                    "Section ID": "nbunch_iter",
                    "Path": "networkx.MultiGraph",
                    "Description": [
                        "Returns an iterator over nodes contained in nbunch that are\nalso in the graph.",
                        "The nodes in nbunch are checked for membership in the graph\nand if not are silently ignored."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "nbunch : single node, container, or all nodes (default= all nodes)": "The view will only report edges incident to these nodes."
                        },
                        "Returns:": {
                            "niter : iterator": "An iterator over nodes in nbunch that are also in the graph.\nIf nbunch is None, iterate over all nodes in the graph."
                        },
                        "Raises:": {
                            "NetworkXError": "If nbunch is not a node or sequence of nodes.\nIf a node in nbunch is not hashable."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "When nbunch is an iterator, the returned iterator yields values\ndirectly from nbunch, becoming exhausted when nbunch is exhausted. To test whether nbunch is a single node, one can use\n\u201cif nbunch in self:\u201d, even after processing with this routine. If nbunch is not a node or a (possibly empty) sequence/iterator\nor None, a NetworkXError is raised.  Also, if any object in\nnbunch is not hashable, a NetworkXError is raised."
                    }
                },
                {
                    "Section ID": "order",
                    "Path": "networkx.MultiGraph",
                    "Description": [
                        "Returns the number of nodes in the graph."
                    ],
                    "Field List": {
                        "Returns:": {
                            "nnodes : int": "The number of nodes in the graph."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(3)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.order()\n# 3"
                    }
                },
                {
                    "Section ID": "number_of_nodes",
                    "Path": "networkx.MultiGraph",
                    "Description": [
                        "Returns the number of nodes in the graph."
                    ],
                    "Field List": {
                        "Returns:": {
                            "nnodes : int": "The number of nodes in the graph."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(3)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.number_of_nodes()\n# 3"
                    }
                },
                {
                    "Section ID": "__len__",
                    "Path": "networkx.MultiGraph",
                    "Description": [
                        "Returns the number of nodes in the graph. Use: \u2018len(G)\u2019."
                    ],
                    "Field List": {
                        "Returns:": {
                            "nnodes : int": "The number of nodes in the graph."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nlen(G)\n# 4"
                    }
                },
                {
                    "Section ID": "degree",
                    "Path": "networkx.MultiGraph",
                    "Description": [],
                    "Field List": {
                        "Parameters:": {
                            "nbunch : single node, container, or all nodes (default= all nodes)": "The view will only report edges incident to these nodes.",
                            "weight : string or None, optional (default=None)": "The name of an edge attribute that holds the numerical value used\nas a weight.  If None, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node."
                        },
                        "Returns:": {
                            "MultiDegreeView or int": "If multiple nodes are requested (the default), returns aMultiDegreeViewmapping nodes to their degree.\nIf a single node is requested, returns the degree of the node as an integer."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nnx.add_path(G,[0,1,2,3])\nG.degree(0)# node 0 with degree 1\n# 1\nlist(G.degree([0,1]))\n# [(0, 1), (1, 2)]"
                    }
                },
                {
                    "Section ID": "size",
                    "Path": "networkx.MultiGraph",
                    "Description": [
                        "Returns the number of edges or total of all edge weights."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "weight : string or None, optional (default=None)": "The edge attribute that holds the numerical value used\nas a weight. If None, then each edge has weight 1."
                        },
                        "Returns:": {
                            "size : numeric": "The number of edges or\n(if weight keyword is provided) the total weight sum.If weight is None, returns an int. Otherwise a float\n(or more general numeric if the weights are more general)."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.size()\n# 3\nG=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_edge(\"a\",\"b\",weight=2)\nG.add_edge(\"b\",\"c\",weight=4)\nG.size()\n# 2\nG.size(weight=\"weight\")\n# 6.0"
                    }
                },
                {
                    "Section ID": "number_of_edges",
                    "Path": "networkx.MultiGraph",
                    "Description": [
                        "Returns the number of edges between two nodes."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "u, v : nodes, optional (Default=all edges)": "If u and v are specified, return the number of edges between\nu and v. Otherwise return the total number of all edges."
                        },
                        "Returns:": {
                            "nedges : int": "The number of edges in the graph.  If nodesuandvare\nspecified return the number of edges between those nodes. If\nthe graph is directed, this only returns the number of edges\nfromutov."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "For undirected multigraphs, this method counts the total number\nof edges in the graph:\nG=nx.MultiGraph()\nG.add_edges_from([(0,1),(0,1),(1,2)])\n# [0, 1, 0]\nG.number_of_edges()\n# 3\nIf you specify two nodes, this counts the total number of edges\njoining the two nodes:\nG.number_of_edges(0,1)\n# 2\nFor directed multigraphs, this method can count the total number\nof directed edges fromutov:\nG=nx.MultiDiGraph()\nG.add_edges_from([(0,1),(0,1),(1,0)])\n# [0, 1, 0]\nG.number_of_edges(0,1)\n# 2\nG.number_of_edges(1,0)\n# 1"
                    }
                },
                {
                    "Section ID": "copy",
                    "Path": "networkx.MultiGraph",
                    "Description": [
                        "Returns a copy of the graph.",
                        "The copy method by default returns an independent shallow copy\nof the graph and attributes. That is, if an attribute is a\ncontainer, that container is shared by the original an the copy.\nUse Python\u2019s copy.deepcopy for new containers.",
                        "If as_view is True then a view is returned instead of a copy."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "as_view : bool, optional (default=False)": "If True, the returned graph-view provides a read-only view\nof the original graph without actually copying any data."
                        },
                        "Returns:": {
                            "G : Graph": "A copy of the graph."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "All copies reproduce the graph structure, but data attributes\nmay be handled in different ways. There are four types of copies\nof a graph that people might want. Deepcopy \u2013 A \u201cdeepcopy\u201d copies the graph structure as well as\nall data attributes and any objects they might contain.\nThe entire graph object is new so that changes in the copy\ndo not affect the original object. (see Python\u2019s copy.deepcopy) Data Reference (Shallow) \u2013 For a shallow copy the graph structure\nis copied but the edge, node and graph attribute dicts are\nreferences to those in the original graph. This saves\ntime and memory but could cause confusion if you change an attribute\nin one graph and it changes the attribute in the other.\nNetworkX does not provide this level of shallow copy. Independent Shallow \u2013 This copy creates new independent attribute\ndicts and then does a shallow copy of the attributes. That is, any\nattributes that are containers are shared between the new graph\nand the original. This is exactly what dict.copy() provides.\nYou can obtain this style copy using:",
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nH=G.copy()"
                    }
                },
                {
                    "Section ID": "to_undirected",
                    "Path": "networkx.MultiGraph",
                    "Description": [
                        "Returns an undirected copy of the graph."
                    ],
                    "Field List": {
                        "Returns:": {
                            "G : Graph/MultiGraph": "A deepcopy of the graph."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "This returns a \u201cdeepcopy\u201d of the edge, node, and\ngraph attributes which attempts to completely copy\nall of the data and references. This is in contrast to the similar G=nx.MultiGraph(D) which returns a shallow copy of the data. See the Python copy module for more information on shallow\nand deep copies, https://docs.python.org/3/library/copy.html . Warning: If you have subclassed MultiGraph to use dict-like\nobjects in the data structure, those changes do not transfer\nto the MultiGraph created by this method.",
                        "Examples": "G=nx.MultiGraph([(0,1),(0,1),(1,2)])\nH=G.to_directed()\nlist(H.edges)\n# [(0, 1, 0), (0, 1, 1), (1, 0, 0), (1, 0, 1), (1, 2, 0), (2, 1, 0)]\nG2=H.to_undirected()\nlist(G2.edges)\n# [(0, 1, 0), (0, 1, 1), (1, 2, 0)]"
                    }
                },
                {
                    "Section ID": "to_directed",
                    "Path": "networkx.MultiGraph",
                    "Description": [
                        "Returns a directed representation of the graph."
                    ],
                    "Field List": {
                        "Returns:": {
                            "G : MultiDiGraph": "A directed graph with the same name, same nodes, and with\neach edge (u, v, k, data) replaced by two directed edges\n(u, v, k, data) and (v, u, k, data)."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "This returns a \u201cdeepcopy\u201d of the edge, node, and\ngraph attributes which attempts to completely copy\nall of the data and references. This is in contrast to the similar D=MultiDiGraph(G) which\nreturns a shallow copy of the data. See the Python copy module for more information on shallow\nand deep copies, https://docs.python.org/3/library/copy.html . Warning: If you have subclassed MultiGraph to use dict-like objects\nin the data structure, those changes do not transfer to the\nMultiDiGraph created by this method.",
                        "Examples": "G=nx.MultiGraph()\nG.add_edge(0,1)\n# 0\nG.add_edge(0,1)\n# 1\nH=G.to_directed()\nlist(H.edges)\n# [(0, 1, 0), (0, 1, 1), (1, 0, 0), (1, 0, 1)]\nIf already directed, return a (deep) copy\nG=nx.MultiDiGraph()\nG.add_edge(0,1)\n# 0\nH=G.to_directed()\nlist(H.edges)\n# [(0, 1, 0)]"
                    }
                },
                {
                    "Section ID": "subgraph",
                    "Path": "networkx.MultiGraph",
                    "Description": [
                        "Returns a SubGraph view of the subgraph induced on nodes .",
                        "The induced subgraph of the graph contains the nodes in nodes and the edges between those nodes."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "nodes : list, iterable": "A container of nodes which will be iterated through once."
                        },
                        "Returns:": {
                            "G : SubGraph View": "A subgraph view of the graph. The graph structure cannot be\nchanged but node/edge attributes can and are shared with the\noriginal graph."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "The graph, edge and node attributes are shared with the original graph.\nChanges to the graph structure is ruled out by the view, but changes\nto attributes are reflected in the original graph. To create a subgraph with its own copy of the edge/node attributes use:\nG.subgraph(nodes).copy() For an inplace reduction of a graph to a subgraph you can remove nodes:\nG.remove_nodes_from([n for n in G if n not in set(nodes)]) Subgraph views are sometimes NOT what you want. In most cases where\nyou want to do more than simply look at the induced edges, it makes\nmore sense to just create the subgraph as its own graph with code like:",
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nH=G.subgraph([0,1,2])\nlist(H.edges)\n# [(0, 1), (1, 2)]"
                    }
                },
                {
                    "Section ID": "edge_subgraph",
                    "Path": "networkx.MultiGraph",
                    "Description": [
                        "Returns the subgraph induced by the specified edges.",
                        "The induced subgraph contains each edge in edges and each\nnode incident to any one of those edges."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "edges : iterable": "An iterable of edges in this graph."
                        },
                        "Returns:": {
                            "G : Graph": "An edge-induced subgraph of this graph with the same edge\nattributes."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "The graph, edge, and node attributes in the returned subgraph\nview are references to the corresponding attributes in the original\ngraph. The view is read-only. To create a full graph version of the subgraph with its own copy\nof the edge or node attributes, use:",
                        "Examples": "G=nx.path_graph(5)\nH=G.edge_subgraph([(0,1),(3,4)])\nlist(H.nodes)\n# [0, 1, 3, 4]\nlist(H.edges)\n# [(0, 1), (3, 4)]"
                    }
                }
            ]
        },
        "Rubrics": {
            "Examples": "Create an empty graph structure (a \u201cnull graph\u201d) with no nodes and\nno edges.\nG=nx.MultiGraph()\nG can be grown in several ways.\nNodes:\nAdd one node at a time:\nG.add_node(1)\nAdd the nodes from any container (a list, dict, set or\neven the lines from a file or the nodes from another graph).\nG.add_nodes_from([2,3])\nG.add_nodes_from(range(100,110))\nH=nx.path_graph(10)\nG.add_nodes_from(H)\nIn addition to strings and integers any hashable Python object\n(except None) can represent a node, e.g. a customized node object,\nor even another Graph.\nG.add_node(H)\nEdges:\nG can also be grown by adding edges.\nAdd one edge,\nkey=G.add_edge(1,2)\na list of edges,\nkeys=G.add_edges_from([(1,2),(1,3)])\nor a collection of edges,\nkeys=G.add_edges_from(H.edges)\nIf some edges connect nodes not yet in the graph, the nodes\nare added automatically.  If an edge already exists, an additional\nedge is created and stored using a key to identify the edge.\nBy default the key is the lowest unused integer.\nkeys=G.add_edges_from([(4,5,{\"route\":28}),(4,5,{\"route\":37})])\nG[4]\n# AdjacencyView({3: {0: {}}, 5: {0: {}, 1: {'route': 28}, 2: {'route': 37}}})\nAttributes:\nEach graph, node, and edge can hold key/value attribute pairs\nin an associated attribute dictionary (the keys must be hashable).\nBy default these are empty, but can be added or changed using\nadd_edge, add_node or direct manipulation of the attribute\ndictionaries named graph, node and edge respectively.\nG=nx.MultiGraph(day=\"Friday\")\nG.graph\n# {'day': 'Friday'}\nAdd node attributes using add_node(), add_nodes_from() or G.nodes\nG.add_node(1,time=\"5pm\")\nG.add_nodes_from([3],time=\"2pm\")\nG.nodes[1]\n# {'time': '5pm'}\nG.nodes[1][\"room\"]=714\ndelG.nodes[1][\"room\"]# remove attribute\nlist(G.nodes(data=True))\n# [(1, {'time': '5pm'}), (3, {'time': '2pm'})]\nAdd edge attributes using add_edge(), add_edges_from(), subscript\nnotation, or G.edges.\nkey=G.add_edge(1,2,weight=4.7)\nkeys=G.add_edges_from([(3,4),(4,5)],color=\"red\")\nkeys=G.add_edges_from([(1,2,{\"color\":\"blue\"}),(2,3,{\"weight\":8})])\nG[1][2][0][\"weight\"]=4.7\nG.edges[1,2,0][\"weight\"]=4\nWarning: we protect the graph data structure by makingG.edges[1,2,0]a read-only dict-like structure. However, you can assign to\nattributes in e.g.G.edges[1,2,0]. Thus, use 2 sets of brackets\nto add/change data attributes:G.edges[1,2,0]['weight']=4.\nShortcuts:\nMany common graph features allow python syntax to speed reporting.\n1inG# check if node in graph\n# True\n[nforninGifn<3]# iterate through nodes\n# [1, 2]\nlen(G)# number of nodes in graph\n# 5\nG[1]# adjacency dict-like view mapping neighbor -> edge key -> edge attributes\n# AdjacencyView({2: {0: {'weight': 4}, 1: {'color': 'blue'}}})\nOften the best way to traverse all edges of a graph is via the neighbors.\nThe neighbors are reported as an adjacency-dictG.adjorG.adjacency().\nforn,nbrsdictinG.adjacency():\nfornbr,keydictinnbrsdict.items():\nforkey,eattrinkeydict.items():\nif\"weight\"ineattr:\n# Do something useful with the edges\npass\nBut the edges() method is often more convenient:\nforu,v,keys,weightinG.edges(data=\"weight\",keys=True):\nifweightisnotNone:\n# Do something useful with the edges\npass\nReporting:\nSimple graph information is obtained using methods and object-attributes.\nReporting usually provides views instead of containers to reduce memory\nusage. The views update as the graph is updated similarly to dict-views.\nThe objectsnodes,edgesandadjprovide access to data attributes\nvia lookup (e.g.nodes[n],edges[u,v,k],adj[u][v]) and iteration\n(e.g.nodes.items(),nodes.data('color'),nodes.data('color',default='blue')and similarly foredges)\nViews exist fornodes,edges,neighbors()/adjanddegree.\nFor details on these and other miscellaneous methods, see below.\nSubclasses (Advanced):\nThe MultiGraph class uses a dict-of-dict-of-dict-of-dict data structure.\nThe outer dict (node_dict) holds adjacency information keyed by node.\nThe next dict (adjlist_dict) represents the adjacency information\nand holds edge_key dicts keyed by neighbor. The edge_key dict holds\neach edge_attr dict keyed by edge key. The inner dict\n(edge_attr_dict) represents the edge data and holds edge attribute\nvalues keyed by attribute names.\nEach of these four dicts in the dict-of-dict-of-dict-of-dict\nstructure can be replaced by a user defined dict-like object.\nIn general, the dict-like features should be maintained but\nextra features can be added. To replace one of the dicts create\na new graph class by changing the class(!) variable holding the\nfactory for that dict-like structure. The variable names are\nnode_dict_factory, node_attr_dict_factory, adjlist_inner_dict_factory,\nadjlist_outer_dict_factory, edge_key_dict_factory, edge_attr_dict_factory\nand graph_attr_dict_factory."
        }
    },
    {
        "Section ID": "MultiDiGraph",
        "Description": [
            "A directed graph class that can store multiedges.",
            "Multiedges are multiple edges between two nodes.  Each edge\ncan hold optional data or attributes.",
            "A MultiDiGraph holds directed edges.  Self loops are allowed.",
            "Nodes can be arbitrary (hashable) Python objects with optional\nkey/value attributes. By convention None is not used as a node.",
            "Edges are represented as links between nodes with optional\nkey/value attributes."
        ],
        "Field List": {
            "Parameters:": {
                "incoming_graph_data : input graph (optional, default: None)": "Data to initialize graph. If None (default) an empty\ngraph is created.  The data can be any format that is supported\nby the to_networkx_graph() function, currently including edge list,\ndict of dicts, dict of lists, NetworkX graph, 2D NumPy array, SciPy\nsparse matrix, or PyGraphviz graph.",
                "multigraph_input : bool or None (default None)": "Note: Only used whenincoming_graph_datais a dict.\nIf True,incoming_graph_datais assumed to be a\ndict-of-dict-of-dict-of-dict structure keyed by\nnode to neighbor to edge keys to edge data for multi-edges.\nA NetworkXError is raised if this is not the case.\nIf False,to_networkx_graph()is used to try to determine\nthe dict\u2019s graph data structure as either a dict-of-dict-of-dict\nkeyed by node to neighbor to edge data, or a dict-of-iterable\nkeyed by node to neighbors.\nIf None, the treatment for True is tried, but if it fails,\nthe treatment for False is tried.",
                "attr : keyword arguments, optional (default= no attributes)": "Attributes to add to graph as key=value pairs."
            },
            "Methods": [
                {
                    "Section ID": "__init__",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [
                        "Initialize a graph with edges, name, or graph attributes."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "incoming_graph_data : input graph": "Data to initialize graph.  If incoming_graph_data=None (default)\nan empty graph is created.  The data can be an edge list, or any\nNetworkX graph object.  If the corresponding optional Python\npackages are installed the data can also be a 2D NumPy array, a\nSciPy sparse array, or a PyGraphviz graph.",
                            "multigraph_input : bool or None (default None)": "Note: Only used whenincoming_graph_datais a dict.\nIf True,incoming_graph_datais assumed to be a\ndict-of-dict-of-dict-of-dict structure keyed by\nnode to neighbor to edge keys to edge data for multi-edges.\nA NetworkXError is raised if this is not the case.\nIf False,to_networkx_graph()is used to try to determine\nthe dict\u2019s graph data structure as either a dict-of-dict-of-dict\nkeyed by node to neighbor to edge data, or a dict-of-iterable\nkeyed by node to neighbors.\nIf None, the treatment for True is tried, but if it fails,\nthe treatment for False is tried.",
                            "attr : keyword arguments, optional (default= no attributes)": "Attributes to add to graph as key=value pairs."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG=nx.Graph(name=\"my graph\")\ne=[(1,2),(2,3),(3,4)]# list of edges\nG=nx.Graph(e)\nArbitrary graph attribute pairs (key=value) may be assigned\nG=nx.Graph(e,day=\"Friday\")\nG.graph\n# {'day': 'Friday'}"
                    }
                },
                {
                    "Section ID": "add_node",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [
                        "Add a single node node_for_adding and update node attributes."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "node_for_adding : node": "A node can be any hashable Python object except None.",
                            "attr : keyword arguments, optional": "Set or change node attributes using key=value."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "A hashable object is one that can be used as a key in a Python\ndictionary. This includes strings, numbers, tuples of strings\nand numbers, etc. On many platforms hashable items also include mutables such as\nNetworkX Graphs, though one should be careful that the hash\ndoesn\u2019t change on mutables.",
                        "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_node(1)\nG.add_node(\"Hello\")\nK3=nx.Graph([(0,1),(1,2),(2,0)])\nG.add_node(K3)\nG.number_of_nodes()\n# 3\nUse keywords set/change node attributes:\nG.add_node(1,size=10)\nG.add_node(3,weight=0.4,UTM=(\"13S\",382871,3972649))"
                    }
                },
                {
                    "Section ID": "add_nodes_from",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [
                        "Add multiple nodes."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "nodes_for_adding : iterable container": "A container of nodes (list, dict, set, etc.).\nOR\nA container of (node, attribute dict) tuples.\nNode attributes are updated using the attribute dict.",
                            "attr : keyword arguments, optional (default= no attributes)": "Update attributes for all nodes in nodes.\nNode attributes specified in nodes as a tuple take\nprecedence over attributes specified via keyword arguments."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "When adding nodes from an iterator over the graph you are changing,\na RuntimeError can be raised with message: RuntimeError:dictionarychangedsizeduringiteration . This\nhappens when the graph\u2019s underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using list(iterator_of_nodes) , and pass this\nobject to G.add_nodes_from .",
                        "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_nodes_from(\"Hello\")\nK3=nx.Graph([(0,1),(1,2),(2,0)])\nG.add_nodes_from(K3)\nsorted(G.nodes(),key=str)\n# [0, 1, 2, 'H', 'e', 'l', 'o']\nUse keywords to update specific node attributes for every node.\nG.add_nodes_from([1,2],size=10)\nG.add_nodes_from([3,4],weight=0.4)\nUse (node, attrdict) tuples to update attributes for specific nodes.\nG.add_nodes_from([(1,dict(size=11)),(2,{\"color\":\"blue\"})])\nG.nodes[1][\"size\"]\n# 11\nH=nx.Graph()\nH.add_nodes_from(G.nodes(data=True))\nH.nodes[1][\"size\"]\n# 11\nEvaluate an iterator over a graph if using it to modify the same graph\nG=nx.DiGraph([(0,1),(1,2),(3,4)])\n# wrong way - will raise RuntimeError\n# G.add_nodes_from(n + 1 for n in G.nodes)\n# correct way\nG.add_nodes_from(list(n+1forninG.nodes))"
                    }
                },
                {
                    "Section ID": "remove_node",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [
                        "Remove node n.",
                        "Removes the node n and all adjacent edges.\nAttempting to remove a nonexistent node will raise an exception."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "n : node": "A node in the graph"
                        },
                        "Raises:": {
                            "NetworkXError": "If n is not in the graph."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(3)# or DiGraph, MultiGraph, MultiDiGraph, etc\nlist(G.edges)\n# [(0, 1), (1, 2)]\nG.remove_node(1)\nlist(G.edges)\n# []"
                    }
                },
                {
                    "Section ID": "remove_nodes_from",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [
                        "Remove multiple nodes."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "nodes : iterable container": "A container of nodes (list, dict, set, etc.).  If a node\nin the container is not in the graph it is silently ignored."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "When removing nodes from an iterator over the graph you are changing,\na RuntimeError will be raised with message: RuntimeError:dictionarychangedsizeduringiteration . This\nhappens when the graph\u2019s underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using list(iterator_of_nodes) , and pass this\nobject to G.remove_nodes_from .",
                        "Examples": "G=nx.path_graph(3)# or DiGraph, MultiGraph, MultiDiGraph, etc\ne=list(G.nodes)\ne\n# [0, 1, 2]\nG.remove_nodes_from(e)\nlist(G.nodes)\n# []\nEvaluate an iterator over a graph if using it to modify the same graph\nG=nx.DiGraph([(0,1),(1,2),(3,4)])\n# this command will fail, as the graph's dict is modified during iteration\n# G.remove_nodes_from(n for n in G.nodes if n < 2)\n# this command will work, since the dictionary underlying graph is not modified\nG.remove_nodes_from(list(nforninG.nodesifn<2))"
                    }
                },
                {
                    "Section ID": "add_edge",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [
                        "Add an edge between u and v.",
                        "The nodes u and v will be automatically added if they are\nnot already in the graph.",
                        "Edge attributes can be specified with keywords or by directly\naccessing the edge\u2019s attribute dictionary. See examples below."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "u_for_edge, v_for_edge : nodes": "Nodes can be, for example, strings or numbers.\nNodes must be hashable (and not None) Python objects.",
                            "key : hashable identifier, optional (default=lowest unused integer)": "Used to distinguish multiedges between a pair of nodes.",
                            "attr : keyword arguments, optional": "Edge data (or labels or objects) can be assigned using\nkeyword arguments."
                        },
                        "Returns:": {
                            "The edge key assigned to the edge.": ""
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "To replace/update edge data, use the optional key argument\nto identify a unique edge.  Otherwise a new edge will be created. NetworkX algorithms designed for weighted graphs cannot use\nmultigraphs directly because it is not clear how to handle\nmultiedge weights.  Convert to Graph using edge attribute\n\u2018weight\u2019 to enable weighted graph algorithms. Default keys are generated using the method new_edge_key() .\nThis method can be overridden by subclassing the base class and\nproviding a custom new_edge_key() method.",
                        "Examples": "The following all add the edge e=(1, 2) to graph G:\nG=nx.MultiDiGraph()\ne=(1,2)\nkey=G.add_edge(1,2)# explicit two-node form\nG.add_edge(*e)# single edge as tuple of two nodes\n# 1\nG.add_edges_from([(1,2)])# add edges from iterable container\n# [2]\nAssociate data to edges using keywords:\nkey=G.add_edge(1,2,weight=3)\nkey=G.add_edge(1,2,key=0,weight=4)# update data for key=0\nkey=G.add_edge(1,3,weight=7,capacity=15,length=342.7)\nFor non-string attribute keys, use subscript notation.\nekey=G.add_edge(1,2)\nG[1][2][0].update({0:5})\nG.edges[1,2,0].update({0:5})"
                    }
                },
                {
                    "Section ID": "add_edges_from",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [
                        "Add all the edges in ebunch_to_add."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "ebunch_to_add : container of edges": "Each edge given in the container will be added to the\ngraph. The edges can be:2-tuples (u, v) or3-tuples (u, v, d) for an edge data dict d, or3-tuples (u, v, k) for not iterable key k, or4-tuples (u, v, k, d) for an edge with data and key k",
                            "attr : keyword arguments, optional": "Edge data (or labels or objects) can be assigned using\nkeyword arguments."
                        },
                        "Returns:": {
                            "A list of edge keys assigned to the edges in : ebunch : .": ""
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "Adding the same edge twice has no effect but any edge data\nwill be updated when each duplicate edge is added. Edge attributes specified in an ebunch take precedence over\nattributes specified via keyword arguments. Default keys are generated using the method new_edge_key() .\nThis method can be overridden by subclassing the base class and\nproviding a custom new_edge_key() method. When adding edges from an iterator over the graph you are changing,\na RuntimeError can be raised with message: RuntimeError:dictionarychangedsizeduringiteration . This\nhappens when the graph\u2019s underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using list(iterator_of_edges) , and pass this\nobject to G.add_edges_from .",
                        "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_edges_from([(0,1),(1,2)])# using a list of edge tuples\ne=zip(range(0,3),range(1,4))\nG.add_edges_from(e)# Add the path graph 0-1-2-3\nAssociate data to edges\nG.add_edges_from([(1,2),(2,3)],weight=3)\nG.add_edges_from([(3,4),(1,4)],label=\"WN2898\")\nEvaluate an iterator over a graph if using it to modify the same graph\nG=nx.MultiGraph([(1,2),(2,3),(3,4)])\n# Grow graph by one new node, adding edges to all existing nodes.\n# wrong way - will raise RuntimeError\n# G.add_edges_from(((5, n) for n in G.nodes))\n# right way - note that there will be no self-edge for node 5\nassigned_keys=G.add_edges_from(list((5,n)forninG.nodes))"
                    }
                },
                {
                    "Section ID": "add_weighted_edges_from",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [
                        "Add weighted edges in ebunch_to_add with specified weight attr"
                    ],
                    "Field List": {
                        "Parameters:": {
                            "ebunch_to_add : container of edges": "Each edge given in the list or container will be added\nto the graph. The edges must be given as 3-tuples (u, v, w)\nwhere w is a number.",
                            "weight : string, optional (default= \u2018weight\u2019)": "The attribute name for the edge weights to be added.",
                            "attr : keyword arguments, optional (default= no attributes)": "Edge attributes to add/update for all edges."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "Adding the same edge twice for Graph/DiGraph simply updates\nthe edge data. For MultiGraph/MultiDiGraph, duplicate edges\nare stored. When adding edges from an iterator over the graph you are changing,\na RuntimeError can be raised with message: RuntimeError:dictionarychangedsizeduringiteration . This\nhappens when the graph\u2019s underlying dictionary is modified during\niteration. To avoid this error, evaluate the iterator into a separate\nobject, e.g. by using list(iterator_of_edges) , and pass this\nobject to G.add_weighted_edges_from .",
                        "Examples": "G=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_weighted_edges_from([(0,1,3.0),(1,2,7.5)])\nEvaluate an iterator over edges before passing it\nG=nx.Graph([(1,2),(2,3),(3,4)])\nweight=0.1\n# Grow graph by one new node, adding edges to all existing nodes.\n# wrong way - will raise RuntimeError\n# G.add_weighted_edges_from(((5, n, weight) for n in G.nodes))\n# correct way - note that there will be no self-edge for node 5\nG.add_weighted_edges_from(list((5,n,weight)forninG.nodes))"
                    }
                },
                {
                    "Section ID": "new_edge_key",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [
                        "Returns an unused key for edges between nodes u and v .",
                        "The nodes u and v do not need to be already in the graph."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "u, v : nodes": ""
                        },
                        "Returns:": {
                            "key : int": ""
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "In the standard MultiGraph class the new key is the number of existing\nedges between u and v (increased if necessary to ensure unused).\nThe first edge will have key 0, then 1, etc. If an edge is removed\nfurther new_edge_keys may not be in this order."
                    }
                },
                {
                    "Section ID": "remove_edge",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [
                        "Remove an edge between u and v."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "u, v : nodes": "Remove an edge between nodes u and v.",
                            "key : hashable identifier, optional (default=None)": "Used to distinguish multiple edges between a pair of nodes.\nIf None, remove a single edge between u and v. If there are\nmultiple edges, removes the last edge added in terms of\ninsertion order."
                        },
                        "Raises:": {
                            "NetworkXError": "If there is not an edge between u and v, or\nif there is no edge with the specified key."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.MultiDiGraph()\nnx.add_path(G,[0,1,2,3])\nG.remove_edge(0,1)\ne=(1,2)\nG.remove_edge(*e)# unpacks e from an edge tuple\nFor multiple edges\nG=nx.MultiDiGraph()\nG.add_edges_from([(1,2),(1,2),(1,2)])# key_list returned\n# [0, 1, 2]\nWhenkey=None(the default), edges are removed in the opposite\norder that they were added:\nG.remove_edge(1,2)\nG.edges(keys=True)\n# OutMultiEdgeView([(1, 2, 0), (1, 2, 1)])\nFor edges with keys\nG=nx.MultiDiGraph()\nG.add_edge(1,2,key=\"first\")\n# 'first'\nG.add_edge(1,2,key=\"second\")\n# 'second'\nG.remove_edge(1,2,key=\"first\")\nG.edges(keys=True)\n# OutMultiEdgeView([(1, 2, 'second')])"
                    }
                },
                {
                    "Section ID": "remove_edges_from",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [
                        "Remove all edges specified in ebunch."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "ebunch: list or container of edge tuples": "Each edge given in the list or container will be removed\nfrom the graph. The edges can be:2-tuples (u, v) A single edge between u and v is removed.3-tuples (u, v, key) The edge identified by key is removed.4-tuples (u, v, key, data) where data is ignored."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "Will fail silently if an edge in ebunch is not in the graph.",
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nebunch=[(1,2),(2,3)]\nG.remove_edges_from(ebunch)\nRemoving multiple copies of edges\nG=nx.MultiGraph()\nkeys=G.add_edges_from([(1,2),(1,2),(1,2)])\nG.remove_edges_from([(1,2),(2,1)])# edges aren't directed\nlist(G.edges())\n# [(1, 2)]\nG.remove_edges_from([(1,2),(1,2)])# silently ignore extra copy\nlist(G.edges)# now empty graph\n# []\nWhen the edge is a 2-tuple(u,v)but there are multiple edges between\nu and v in the graph, the most recent edge (in terms of insertion\norder) is removed.\nG=nx.MultiGraph()\nforkeyin(\"x\",\"y\",\"a\"):\nk=G.add_edge(0,1,key=key)\nG.edges(keys=True)\n# MultiEdgeView([(0, 1, 'x'), (0, 1, 'y'), (0, 1, 'a')])\nG.remove_edges_from([(0,1)])\nG.edges(keys=True)\n# MultiEdgeView([(0, 1, 'x'), (0, 1, 'y')])"
                    }
                },
                {
                    "Section ID": "update",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [
                        "Update the graph using nodes/edges/graphs as input.",
                        "Like dict.update, this method takes a graph as input, adding the\ngraph\u2019s nodes and edges to this graph. It can also take two inputs:\nedges and nodes. Finally it can take either edges or nodes.\nTo specify only nodes the keyword nodes must be used.",
                        "The collections of edges and nodes are treated similarly to\nthe add_edges_from/add_nodes_from methods. When iterated, they\nshould yield 2-tuples (u, v) or 3-tuples (u, v, datadict)."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "edges : Graph object, collection of edges, or None": "The first parameter can be a graph or some edges. If it has\nattributesnodesandedges, then it is taken to be a\nGraph-like object and those attributes are used as collections\nof nodes and edges to be added to the graph.\nIf the first parameter does not have those attributes, it is\ntreated as a collection of edges and added to the graph.\nIf the first argument is None, no edges are added.",
                            "nodes : collection of nodes, or None": "The second parameter is treated as a collection of nodes\nto be added to the graph unless it is None.\nIfedgesisNoneandnodesisNonean exception is raised.\nIf the first parameter is a Graph, thennodesis ignored."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "It you want to update the graph using an adjacency structure\nit is straightforward to obtain the edges/nodes from adjacency.\nThe following examples provide common cases, your adjacency may\nbe slightly different and require tweaks of these examples:",
                        "Examples": "G=nx.path_graph(5)\nG.update(nx.complete_graph(range(4,10)))\nfromitertoolsimportcombinations\nedges=(\n(u,v,{\"power\":u*v})\nforu,vincombinations(range(10,20),2)\nifu*v<225\n)\nnodes=[1000]# for singleton, use a container\nG.update(edges,nodes)"
                    }
                },
                {
                    "Section ID": "clear",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [
                        "Remove all nodes and edges from the graph.",
                        "This also removes the name, and all graph, node, and edge attributes.",
                        "Examples"
                    ],
                    "Field List": {
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.clear()\nlist(G.nodes)\n# []\nlist(G.edges)\n# []"
                    }
                },
                {
                    "Section ID": "clear_edges",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [
                        "Remove all edges from the graph without altering nodes.",
                        "Examples"
                    ],
                    "Field List": {
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.clear_edges()\nlist(G.nodes)\n# [0, 1, 2, 3]\nlist(G.edges)\n# []"
                    }
                },
                {
                    "Section ID": "nodes",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [],
                    "Field List": {
                        "Parameters:": {
                            "data : string or bool, optional (default=False)": "The node attribute returned in 2-tuple (n, ddict[data]).\nIf True, return entire node attribute dict as (n, ddict).\nIf False, return just the nodes n.",
                            "default : value, optional (default=None)": "Value used for nodes that don\u2019t have the requested attribute.\nOnly relevant if data is not True or False."
                        },
                        "Returns:": {
                            "NodeView": "Allows set-like operations over the nodes as well as node\nattribute dict lookup and calling to get a NodeDataView.\nA NodeDataView iterates over(n,data)and has no set operations.\nA NodeView iterates overnand includes set operations.When called, if data is False, an iterator over nodes.\nOtherwise an iterator of 2-tuples (node, attribute value)\nwhere the attribute is specified indata.\nIf data is True then the attribute becomes the\nentire data dictionary."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "If your node data is not needed, it is simpler and equivalent\nto use the expression forninG , or list(G) .",
                        "Examples": "There are two simple ways of getting a list of all nodes in the graph:\nG=nx.path_graph(3)\nlist(G.nodes)\n# [0, 1, 2]\nlist(G)\n# [0, 1, 2]\nTo get the node data along with the nodes:\nG.add_node(1,time=\"5pm\")\nG.nodes[0][\"foo\"]=\"bar\"\nlist(G.nodes(data=True))\n# [(0, {'foo': 'bar'}), (1, {'time': '5pm'}), (2, {})]\nlist(G.nodes.data())\n# [(0, {'foo': 'bar'}), (1, {'time': '5pm'}), (2, {})]\nlist(G.nodes(data=\"foo\"))\n# [(0, 'bar'), (1, None), (2, None)]\nlist(G.nodes.data(\"foo\"))\n# [(0, 'bar'), (1, None), (2, None)]\nlist(G.nodes(data=\"time\"))\n# [(0, None), (1, '5pm'), (2, None)]\nlist(G.nodes.data(\"time\"))\n# [(0, None), (1, '5pm'), (2, None)]\nlist(G.nodes(data=\"time\",default=\"Not Available\"))\n# [(0, 'Not Available'), (1, '5pm'), (2, 'Not Available')]\nlist(G.nodes.data(\"time\",default=\"Not Available\"))\n# [(0, 'Not Available'), (1, '5pm'), (2, 'Not Available')]\nIf some of your nodes have an attribute and the rest are assumed\nto have a default attribute value you can create a dictionary\nfrom node/attribute pairs using thedefaultkeyword argument\nto guarantee the value is never None:\nG=nx.Graph()\nG.add_node(0)\nG.add_node(1,weight=2)\nG.add_node(2,weight=3)\ndict(G.nodes(data=\"weight\",default=1))\n# {0: 1, 1: 2, 2: 3}"
                    }
                },
                {
                    "Section ID": "__iter__",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [
                        "Iterate over the nodes. Use: \u2018for n in G\u2019."
                    ],
                    "Field List": {
                        "Returns:": {
                            "niter : iterator": "An iterator over all nodes in the graph."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\n[nforninG]\n# [0, 1, 2, 3]\nlist(G)\n# [0, 1, 2, 3]"
                    }
                },
                {
                    "Section ID": "has_node",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [
                        "Returns True if the graph contains the node n.",
                        "Identical to ninG"
                    ],
                    "Field List": {
                        "Parameters:": {
                            "n : node": ""
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(3)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.has_node(0)\n# True\nIt is more readable and simpler to use\n0inG\n# True"
                    }
                },
                {
                    "Section ID": "__contains__",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [
                        "Returns True if n is a node, False otherwise. Use: \u2018n in G\u2019.",
                        "Examples"
                    ],
                    "Field List": {
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\n1inG\n# True"
                    }
                },
                {
                    "Section ID": "edges",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [],
                    "Field List": {
                        "Parameters:": {
                            "nbunch : single node, container, or all nodes (default= all nodes)": "The view will only report edges from these nodes.",
                            "data : string or bool, optional (default=False)": "The edge attribute returned in 3-tuple (u, v, ddict[data]).\nIf True, return edge attribute dict in 3-tuple (u, v, ddict).\nIf False, return 2-tuple (u, v).",
                            "keys : bool, optional (default=False)": "If True, return edge keys with each edge, creating (u, v, k,\nd) tuples when data is also requested (the default) and (u,\nv, k) tuples when data is not requested.",
                            "default : value, optional (default=None)": "Value used for edges that don\u2019t have the requested attribute.\nOnly relevant if data is not True or False."
                        },
                        "Returns:": {
                            "edges : OutMultiEdgeView": "A view of edge attributes, usually it iterates over (u, v)\n(u, v, k) or (u, v, k, d) tuples of edges, but can also be\nused for attribute lookup asedges[u,v,k]['foo']."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "Nodes in nbunch that are not in the graph will be (quietly) ignored.\nFor directed graphs this returns the out-edges.",
                        "Examples": "G=nx.MultiDiGraph()\nnx.add_path(G,[0,1,2])\nkey=G.add_edge(2,3,weight=5)\nkey2=G.add_edge(1,2)# second edge between these nodes\n[eforeinG.edges()]\n# [(0, 1), (1, 2), (1, 2), (2, 3)]\nlist(G.edges(data=True))# default data is {} (empty dict)\n# [(0, 1, {}), (1, 2, {}), (1, 2, {}), (2, 3, {'weight': 5})]\nlist(G.edges(data=\"weight\",default=1))\n# [(0, 1, 1), (1, 2, 1), (1, 2, 1), (2, 3, 5)]\nlist(G.edges(keys=True))# default keys are integers\n# [(0, 1, 0), (1, 2, 0), (1, 2, 1), (2, 3, 0)]\nlist(G.edges(data=True,keys=True))\n# [(0, 1, 0, {}), (1, 2, 0, {}), (1, 2, 1, {}), (2, 3, 0, {'weight': 5})]\nlist(G.edges(data=\"weight\",default=1,keys=True))\n# [(0, 1, 0, 1), (1, 2, 0, 1), (1, 2, 1, 1), (2, 3, 0, 5)]\nlist(G.edges([0,2]))\n# [(0, 1), (2, 3)]\nlist(G.edges(0))\n# [(0, 1)]\nlist(G.edges(1))\n# [(1, 2), (1, 2)]"
                    }
                },
                {
                    "Section ID": "out_edges",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [],
                    "Field List": {
                        "Parameters:": {
                            "nbunch : single node, container, or all nodes (default= all nodes)": "The view will only report edges from these nodes.",
                            "data : string or bool, optional (default=False)": "The edge attribute returned in 3-tuple (u, v, ddict[data]).\nIf True, return edge attribute dict in 3-tuple (u, v, ddict).\nIf False, return 2-tuple (u, v).",
                            "keys : bool, optional (default=False)": "If True, return edge keys with each edge, creating (u, v, k,\nd) tuples when data is also requested (the default) and (u,\nv, k) tuples when data is not requested.",
                            "default : value, optional (default=None)": "Value used for edges that don\u2019t have the requested attribute.\nOnly relevant if data is not True or False."
                        },
                        "Returns:": {
                            "edges : OutMultiEdgeView": "A view of edge attributes, usually it iterates over (u, v)\n(u, v, k) or (u, v, k, d) tuples of edges, but can also be\nused for attribute lookup asedges[u,v,k]['foo']."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "Nodes in nbunch that are not in the graph will be (quietly) ignored.\nFor directed graphs this returns the out-edges.",
                        "Examples": "G=nx.MultiDiGraph()\nnx.add_path(G,[0,1,2])\nkey=G.add_edge(2,3,weight=5)\nkey2=G.add_edge(1,2)# second edge between these nodes\n[eforeinG.edges()]\n# [(0, 1), (1, 2), (1, 2), (2, 3)]\nlist(G.edges(data=True))# default data is {} (empty dict)\n# [(0, 1, {}), (1, 2, {}), (1, 2, {}), (2, 3, {'weight': 5})]\nlist(G.edges(data=\"weight\",default=1))\n# [(0, 1, 1), (1, 2, 1), (1, 2, 1), (2, 3, 5)]\nlist(G.edges(keys=True))# default keys are integers\n# [(0, 1, 0), (1, 2, 0), (1, 2, 1), (2, 3, 0)]\nlist(G.edges(data=True,keys=True))\n# [(0, 1, 0, {}), (1, 2, 0, {}), (1, 2, 1, {}), (2, 3, 0, {'weight': 5})]\nlist(G.edges(data=\"weight\",default=1,keys=True))\n# [(0, 1, 0, 1), (1, 2, 0, 1), (1, 2, 1, 1), (2, 3, 0, 5)]\nlist(G.edges([0,2]))\n# [(0, 1), (2, 3)]\nlist(G.edges(0))\n# [(0, 1)]\nlist(G.edges(1))\n# [(1, 2), (1, 2)]"
                    }
                },
                {
                    "Section ID": "in_edges",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [],
                    "Field List": {
                        "Parameters:": {
                            "nbunch : single node, container, or all nodes (default= all nodes)": "The view will only report edges incident to these nodes.",
                            "data : string or bool, optional (default=False)": "The edge attribute returned in 3-tuple (u, v, ddict[data]).\nIf True, return edge attribute dict in 3-tuple (u, v, ddict).\nIf False, return 2-tuple (u, v).",
                            "keys : bool, optional (default=False)": "If True, return edge keys with each edge, creating 3-tuples\n(u, v, k) or with data, 4-tuples (u, v, k, d).",
                            "default : value, optional (default=None)": "Value used for edges that don\u2019t have the requested attribute.\nOnly relevant if data is not True or False."
                        },
                        "Returns:": {
                            "in_edges : InMultiEdgeView or InMultiEdgeDataView": "A view of edge attributes, usually it iterates over (u, v)\nor (u, v, k) or (u, v, k, d) tuples of edges, but can also be\nused for attribute lookup asedges[u,v,k]['foo']."
                        },
                        "Methods": []
                    },
                    "Rubrics": {}
                },
                {
                    "Section ID": "has_edge",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [
                        "Returns True if the graph has an edge between nodes u and v.",
                        "This is the same as vinG[u]orkeyinG[u][v] without KeyError exceptions."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "u, v : nodes": "Nodes can be, for example, strings or numbers.",
                            "key : hashable identifier, optional (default=None)": "If specified return True only if the edge with\nkey is found."
                        },
                        "Returns:": {
                            "edge_ind : bool": "True if edge is in the graph, False otherwise."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "Can be called either using two nodes u, v, an edge tuple (u, v),\nor an edge tuple (u, v, key).\nG=nx.MultiGraph()# or MultiDiGraph\nnx.add_path(G,[0,1,2,3])\nG.has_edge(0,1)# using two nodes\n# True\ne=(0,1)\nG.has_edge(*e)#  e is a 2-tuple (u, v)\n# True\nG.add_edge(0,1,key=\"a\")\n# 'a'\nG.has_edge(0,1,key=\"a\")# specify key\n# True\nG.has_edge(1,0,key=\"a\")# edges aren't directed\n# True\ne=(0,1,\"a\")\nG.has_edge(*e)# e is a 3-tuple (u, v, 'a')\n# True\nThe following syntax are equivalent:\nG.has_edge(0,1)\n# True\n1inG[0]# though this gives :exc:`KeyError` if 0 not in G\n# True\n0inG[1]# other order; also gives :exc:`KeyError` if 0 not in G\n# True"
                    }
                },
                {
                    "Section ID": "get_edge_data",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [
                        "Returns the attribute dictionary associated with edge (u, v,\nkey).",
                        "If a key is not provided, returns a dictionary mapping edge keys\nto attribute dictionaries for each edge between u and v.",
                        "This is identical to G[u][v][key] except the default is returned\ninstead of an exception is the edge doesn\u2019t exist."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "u, v : nodes": "",
                            "default : any Python object (default=None)": "Value to return if the specific edge (u, v, key) is not\nfound, OR if there are no edges between u and v and no key\nis specified.",
                            "key : hashable identifier, optional (default=None)": "Return data only for the edge with specified key, as an\nattribute dictionary (rather than a dictionary mapping keys\nto attribute dictionaries)."
                        },
                        "Returns:": {
                            "edge_dict : dictionary": "The edge attribute dictionary, OR a dictionary mapping edge\nkeys to attribute dictionaries for each of those edges if no\nspecific key is provided (even if there\u2019s only one edge\nbetween u and v)."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.MultiGraph()# or MultiDiGraph\nkey=G.add_edge(0,1,key=\"a\",weight=7)\nG[0][1][\"a\"]# key='a'\n# {'weight': 7}\nG.edges[0,1,\"a\"]# key='a'\n# {'weight': 7}\nWarning: we protect the graph data structure by makingG.edgesandG[1][2]read-only dict-like structures.\nHowever, you can assign values to attributes in e.g.G.edges[1,2,'a']orG[1][2]['a']using an additional\nbracket as shown next. You need to specify all edge info\nto assign to the edge data associated with an edge.\nG[0][1][\"a\"][\"weight\"]=10\nG.edges[0,1,\"a\"][\"weight\"]=10\nG[0][1][\"a\"][\"weight\"]\n# 10\nG.edges[1,0,\"a\"][\"weight\"]\n# 10\nG=nx.MultiGraph()# or MultiDiGraph\nnx.add_path(G,[0,1,2,3])\nG.edges[0,1,0][\"weight\"]=5\nG.get_edge_data(0,1)\n# {0: {'weight': 5}}\ne=(0,1)\nG.get_edge_data(*e)# tuple form\n# {0: {'weight': 5}}\nG.get_edge_data(3,0)# edge not in graph, returns None\nG.get_edge_data(3,0,default=0)# edge not in graph, return default\n# 0\nG.get_edge_data(1,0,0)# specific key gives back\n# {'weight': 5}"
                    }
                },
                {
                    "Section ID": "neighbors",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [
                        "Returns an iterator over successor nodes of n.",
                        "A successor of n is a node m such that there exists a directed\nedge from n to m."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "n : node": "A node in the graph"
                        },
                        "Raises:": {
                            "NetworkXError": "If n is not in the graph."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "neighbors() and successors() are the same."
                    }
                },
                {
                    "Section ID": "adj",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [],
                    "Field List": {
                        "Methods": []
                    },
                    "Rubrics": {}
                },
                {
                    "Section ID": "__getitem__",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [
                        "Returns a dict of neighbors of node n.  Use: \u2018G[n]\u2019."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "n : node": "A node in the graph."
                        },
                        "Returns:": {
                            "adj_dict : dictionary": "The adjacency dictionary for nodes connected to n."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "G[n] is the same as G.adj[n] and similar to G.neighbors(n)\n(which is an iterator over G.adj[n])",
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG[0]\n# AtlasView({1: {}})"
                    }
                },
                {
                    "Section ID": "successors",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [
                        "Returns an iterator over successor nodes of n.",
                        "A successor of n is a node m such that there exists a directed\nedge from n to m."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "n : node": "A node in the graph"
                        },
                        "Raises:": {
                            "NetworkXError": "If n is not in the graph."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "neighbors() and successors() are the same."
                    }
                },
                {
                    "Section ID": "succ",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [],
                    "Field List": {
                        "Methods": []
                    },
                    "Rubrics": {}
                },
                {
                    "Section ID": "predecessors",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [
                        "Returns an iterator over predecessor nodes of n.",
                        "A predecessor of n is a node m such that there exists a directed\nedge from m to n."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "n : node": "A node in the graph"
                        },
                        "Raises:": {
                            "NetworkXError": "If n is not in the graph."
                        },
                        "Methods": []
                    },
                    "Rubrics": {}
                },
                {
                    "Section ID": "pred",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [],
                    "Field List": {
                        "Methods": []
                    },
                    "Rubrics": {}
                },
                {
                    "Section ID": "adjacency",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [
                        "Returns an iterator over (node, adjacency dict) tuples for all nodes.",
                        "For directed graphs, only outgoing neighbors/adjacencies are included."
                    ],
                    "Field List": {
                        "Returns:": {
                            "adj_iter : iterator": "An iterator over (node, adjacency dictionary) for all nodes in\nthe graph."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\n[(n,nbrdict)forn,nbrdictinG.adjacency()]\n# [(0, {1: {}}), (1, {0: {}, 2: {}}), (2, {1: {}, 3: {}}), (3, {2: {}})]"
                    }
                },
                {
                    "Section ID": "nbunch_iter",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [
                        "Returns an iterator over nodes contained in nbunch that are\nalso in the graph.",
                        "The nodes in nbunch are checked for membership in the graph\nand if not are silently ignored."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "nbunch : single node, container, or all nodes (default= all nodes)": "The view will only report edges incident to these nodes."
                        },
                        "Returns:": {
                            "niter : iterator": "An iterator over nodes in nbunch that are also in the graph.\nIf nbunch is None, iterate over all nodes in the graph."
                        },
                        "Raises:": {
                            "NetworkXError": "If nbunch is not a node or sequence of nodes.\nIf a node in nbunch is not hashable."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "When nbunch is an iterator, the returned iterator yields values\ndirectly from nbunch, becoming exhausted when nbunch is exhausted. To test whether nbunch is a single node, one can use\n\u201cif nbunch in self:\u201d, even after processing with this routine. If nbunch is not a node or a (possibly empty) sequence/iterator\nor None, a NetworkXError is raised.  Also, if any object in\nnbunch is not hashable, a NetworkXError is raised."
                    }
                },
                {
                    "Section ID": "order",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [
                        "Returns the number of nodes in the graph."
                    ],
                    "Field List": {
                        "Returns:": {
                            "nnodes : int": "The number of nodes in the graph."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(3)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.order()\n# 3"
                    }
                },
                {
                    "Section ID": "number_of_nodes",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [
                        "Returns the number of nodes in the graph."
                    ],
                    "Field List": {
                        "Returns:": {
                            "nnodes : int": "The number of nodes in the graph."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(3)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.number_of_nodes()\n# 3"
                    }
                },
                {
                    "Section ID": "__len__",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [
                        "Returns the number of nodes in the graph. Use: \u2018len(G)\u2019."
                    ],
                    "Field List": {
                        "Returns:": {
                            "nnodes : int": "The number of nodes in the graph."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nlen(G)\n# 4"
                    }
                },
                {
                    "Section ID": "degree",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [],
                    "Field List": {
                        "Parameters:": {
                            "nbunch : single node, container, or all nodes (default= all nodes)": "The view will only report edges incident to these nodes.",
                            "weight : string or None, optional (default=None)": "The name of an edge attribute that holds the numerical value used\nas a weight.  If None, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node."
                        },
                        "Returns:": {
                            "DiMultiDegreeView or int": "If multiple nodes are requested (the default), returns aDiMultiDegreeViewmapping nodes to their degree.\nIf a single node is requested, returns the degree of the node as an integer."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.MultiDiGraph()\nnx.add_path(G,[0,1,2,3])\nG.degree(0)# node 0 with degree 1\n# 1\nlist(G.degree([0,1,2]))\n# [(0, 1), (1, 2), (2, 2)]\nG.add_edge(0,1)# parallel edge\n# 1\nlist(G.degree([0,1,2]))# parallel edges are counted\n# [(0, 2), (1, 3), (2, 2)]"
                    }
                },
                {
                    "Section ID": "in_degree",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [],
                    "Field List": {
                        "Parameters:": {
                            "nbunch : single node, container, or all nodes (default= all nodes)": "The view will only report edges incident to these nodes.",
                            "weight : string or None, optional (default=None)": "The edge attribute that holds the numerical value used\nas a weight.  If None, then each edge has weight 1.\nThe degree is the sum of the edge weights adjacent to the node."
                        },
                        "Returns:": {
                            "If a single node is requested": "",
                            "deg : int": "Degree of the node",
                            "OR if multiple nodes are requested": "",
                            "nd_iter : iterator": "The iterator returns two-tuples of (node, in-degree)."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.MultiDiGraph()\nnx.add_path(G,[0,1,2,3])\nG.in_degree(0)# node 0 with degree 0\n# 0\nlist(G.in_degree([0,1,2]))\n# [(0, 0), (1, 1), (2, 1)]\nG.add_edge(0,1)# parallel edge\n# 1\nlist(G.in_degree([0,1,2]))# parallel edges counted\n# [(0, 0), (1, 2), (2, 1)]"
                    }
                },
                {
                    "Section ID": "out_degree",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [],
                    "Field List": {
                        "Parameters:": {
                            "nbunch : single node, container, or all nodes (default= all nodes)": "The view will only report edges incident to these nodes.",
                            "weight : string or None, optional (default=None)": "The edge attribute that holds the numerical value used\nas a weight.  If None, then each edge has weight 1.\nThe degree is the sum of the edge weights."
                        },
                        "Returns:": {
                            "If a single node is requested": "",
                            "deg : int": "Degree of the node",
                            "OR if multiple nodes are requested": "",
                            "nd_iter : iterator": "The iterator returns two-tuples of (node, out-degree)."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.MultiDiGraph()\nnx.add_path(G,[0,1,2,3])\nG.out_degree(0)# node 0 with degree 1\n# 1\nlist(G.out_degree([0,1,2]))\n# [(0, 1), (1, 1), (2, 1)]\nG.add_edge(0,1)# parallel edge\n# 1\nlist(G.out_degree([0,1,2]))# counts parallel edges\n# [(0, 2), (1, 1), (2, 1)]"
                    }
                },
                {
                    "Section ID": "size",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [
                        "Returns the number of edges or total of all edge weights."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "weight : string or None, optional (default=None)": "The edge attribute that holds the numerical value used\nas a weight. If None, then each edge has weight 1."
                        },
                        "Returns:": {
                            "size : numeric": "The number of edges or\n(if weight keyword is provided) the total weight sum.If weight is None, returns an int. Otherwise a float\n(or more general numeric if the weights are more general)."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.size()\n# 3\nG=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.add_edge(\"a\",\"b\",weight=2)\nG.add_edge(\"b\",\"c\",weight=4)\nG.size()\n# 2\nG.size(weight=\"weight\")\n# 6.0"
                    }
                },
                {
                    "Section ID": "number_of_edges",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [
                        "Returns the number of edges between two nodes."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "u, v : nodes, optional (Default=all edges)": "If u and v are specified, return the number of edges between\nu and v. Otherwise return the total number of all edges."
                        },
                        "Returns:": {
                            "nedges : int": "The number of edges in the graph.  If nodesuandvare\nspecified return the number of edges between those nodes. If\nthe graph is directed, this only returns the number of edges\nfromutov."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Examples": "For undirected multigraphs, this method counts the total number\nof edges in the graph:\nG=nx.MultiGraph()\nG.add_edges_from([(0,1),(0,1),(1,2)])\n# [0, 1, 0]\nG.number_of_edges()\n# 3\nIf you specify two nodes, this counts the total number of edges\njoining the two nodes:\nG.number_of_edges(0,1)\n# 2\nFor directed multigraphs, this method can count the total number\nof directed edges fromutov:\nG=nx.MultiDiGraph()\nG.add_edges_from([(0,1),(0,1),(1,0)])\n# [0, 1, 0]\nG.number_of_edges(0,1)\n# 2\nG.number_of_edges(1,0)\n# 1"
                    }
                },
                {
                    "Section ID": "copy",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [
                        "Returns a copy of the graph.",
                        "The copy method by default returns an independent shallow copy\nof the graph and attributes. That is, if an attribute is a\ncontainer, that container is shared by the original an the copy.\nUse Python\u2019s copy.deepcopy for new containers.",
                        "If as_view is True then a view is returned instead of a copy."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "as_view : bool, optional (default=False)": "If True, the returned graph-view provides a read-only view\nof the original graph without actually copying any data."
                        },
                        "Returns:": {
                            "G : Graph": "A copy of the graph."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "All copies reproduce the graph structure, but data attributes\nmay be handled in different ways. There are four types of copies\nof a graph that people might want. Deepcopy \u2013 A \u201cdeepcopy\u201d copies the graph structure as well as\nall data attributes and any objects they might contain.\nThe entire graph object is new so that changes in the copy\ndo not affect the original object. (see Python\u2019s copy.deepcopy) Data Reference (Shallow) \u2013 For a shallow copy the graph structure\nis copied but the edge, node and graph attribute dicts are\nreferences to those in the original graph. This saves\ntime and memory but could cause confusion if you change an attribute\nin one graph and it changes the attribute in the other.\nNetworkX does not provide this level of shallow copy. Independent Shallow \u2013 This copy creates new independent attribute\ndicts and then does a shallow copy of the attributes. That is, any\nattributes that are containers are shared between the new graph\nand the original. This is exactly what dict.copy() provides.\nYou can obtain this style copy using:",
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nH=G.copy()"
                    }
                },
                {
                    "Section ID": "to_undirected",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [
                        "Returns an undirected representation of the digraph."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "reciprocal : bool (optional)": "If True only keep edges that appear in both directions\nin the original digraph.",
                            "as_view : bool (optional, default=False)": "If True return an undirected view of the original directed graph."
                        },
                        "Returns:": {
                            "G : MultiGraph": "An undirected graph with the same name and nodes and\nwith edge (u, v, data) if either (u, v, data) or (v, u, data)\nis in the digraph.  If both edges exist in digraph and\ntheir edge data is different, only one edge is created\nwith an arbitrary choice of which edge data to use.\nYou must check and correct for this manually if desired."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "This returns a \u201cdeepcopy\u201d of the edge, node, and\ngraph attributes which attempts to completely copy\nall of the data and references. This is in contrast to the similar D=MultiDiGraph(G) which\nreturns a shallow copy of the data. See the Python copy module for more information on shallow\nand deep copies, https://docs.python.org/3/library/copy.html . Warning: If you have subclassed MultiDiGraph to use dict-like\nobjects in the data structure, those changes do not transfer\nto the MultiGraph created by this method.",
                        "Examples": "G=nx.path_graph(2)# or MultiGraph, etc\nH=G.to_directed()\nlist(H.edges)\n# [(0, 1), (1, 0)]\nG2=H.to_undirected()\nlist(G2.edges)\n# [(0, 1)]"
                    }
                },
                {
                    "Section ID": "to_directed",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [
                        "Returns a directed representation of the graph."
                    ],
                    "Field List": {
                        "Returns:": {
                            "G : MultiDiGraph": "A directed graph with the same name, same nodes, and with\neach edge (u, v, k, data) replaced by two directed edges\n(u, v, k, data) and (v, u, k, data)."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "This returns a \u201cdeepcopy\u201d of the edge, node, and\ngraph attributes which attempts to completely copy\nall of the data and references. This is in contrast to the similar D=MultiDiGraph(G) which\nreturns a shallow copy of the data. See the Python copy module for more information on shallow\nand deep copies, https://docs.python.org/3/library/copy.html . Warning: If you have subclassed MultiGraph to use dict-like objects\nin the data structure, those changes do not transfer to the\nMultiDiGraph created by this method.",
                        "Examples": "G=nx.MultiGraph()\nG.add_edge(0,1)\n# 0\nG.add_edge(0,1)\n# 1\nH=G.to_directed()\nlist(H.edges)\n# [(0, 1, 0), (0, 1, 1), (1, 0, 0), (1, 0, 1)]\nIf already directed, return a (deep) copy\nG=nx.MultiDiGraph()\nG.add_edge(0,1)\n# 0\nH=G.to_directed()\nlist(H.edges)\n# [(0, 1, 0)]"
                    }
                },
                {
                    "Section ID": "subgraph",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [
                        "Returns a SubGraph view of the subgraph induced on nodes .",
                        "The induced subgraph of the graph contains the nodes in nodes and the edges between those nodes."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "nodes : list, iterable": "A container of nodes which will be iterated through once."
                        },
                        "Returns:": {
                            "G : SubGraph View": "A subgraph view of the graph. The graph structure cannot be\nchanged but node/edge attributes can and are shared with the\noriginal graph."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "The graph, edge and node attributes are shared with the original graph.\nChanges to the graph structure is ruled out by the view, but changes\nto attributes are reflected in the original graph. To create a subgraph with its own copy of the edge/node attributes use:\nG.subgraph(nodes).copy() For an inplace reduction of a graph to a subgraph you can remove nodes:\nG.remove_nodes_from([n for n in G if n not in set(nodes)]) Subgraph views are sometimes NOT what you want. In most cases where\nyou want to do more than simply look at the induced edges, it makes\nmore sense to just create the subgraph as its own graph with code like:",
                        "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nH=G.subgraph([0,1,2])\nlist(H.edges)\n# [(0, 1), (1, 2)]"
                    }
                },
                {
                    "Section ID": "edge_subgraph",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [
                        "Returns the subgraph induced by the specified edges.",
                        "The induced subgraph contains each edge in edges and each\nnode incident to any one of those edges."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "edges : iterable": "An iterable of edges in this graph."
                        },
                        "Returns:": {
                            "G : Graph": "An edge-induced subgraph of this graph with the same edge\nattributes."
                        },
                        "Methods": []
                    },
                    "Rubrics": {
                        "Notes": "The graph, edge, and node attributes in the returned subgraph\nview are references to the corresponding attributes in the original\ngraph. The view is read-only. To create a full graph version of the subgraph with its own copy\nof the edge or node attributes, use:",
                        "Examples": "G=nx.path_graph(5)\nH=G.edge_subgraph([(0,1),(3,4)])\nlist(H.nodes)\n# [0, 1, 3, 4]\nlist(H.edges)\n# [(0, 1), (3, 4)]"
                    }
                },
                {
                    "Section ID": "reverse",
                    "Path": "networkx.MultiDiGraph",
                    "Description": [
                        "Returns the reverse of the graph.",
                        "The reverse is a graph with the same nodes and edges\nbut with the directions of the edges reversed."
                    ],
                    "Field List": {
                        "Parameters:": {
                            "copy : bool optional (default=True)": "If True, return a new DiGraph holding the reversed edges.\nIf False, the reverse graph is created using a view of\nthe original graph."
                        },
                        "Methods": []
                    },
                    "Rubrics": {}
                }
            ]
        },
        "Rubrics": {
            "Examples": "Create an empty graph structure (a \u201cnull graph\u201d) with no nodes and\nno edges.\nG=nx.MultiDiGraph()\nG can be grown in several ways.\nNodes:\nAdd one node at a time:\nG.add_node(1)\nAdd the nodes from any container (a list, dict, set or\neven the lines from a file or the nodes from another graph).\nG.add_nodes_from([2,3])\nG.add_nodes_from(range(100,110))\nH=nx.path_graph(10)\nG.add_nodes_from(H)\nIn addition to strings and integers any hashable Python object\n(except None) can represent a node, e.g. a customized node object,\nor even another Graph.\nG.add_node(H)\nEdges:\nG can also be grown by adding edges.\nAdd one edge,\nkey=G.add_edge(1,2)\na list of edges,\nkeys=G.add_edges_from([(1,2),(1,3)])\nor a collection of edges,\nkeys=G.add_edges_from(H.edges)\nIf some edges connect nodes not yet in the graph, the nodes\nare added automatically.  If an edge already exists, an additional\nedge is created and stored using a key to identify the edge.\nBy default the key is the lowest unused integer.\nkeys=G.add_edges_from([(4,5,dict(route=282)),(4,5,dict(route=37))])\nG[4]\n# AdjacencyView({5: {0: {}, 1: {'route': 282}, 2: {'route': 37}}})\nAttributes:\nEach graph, node, and edge can hold key/value attribute pairs\nin an associated attribute dictionary (the keys must be hashable).\nBy default these are empty, but can be added or changed using\nadd_edge, add_node or direct manipulation of the attribute\ndictionaries named graph, node and edge respectively.\nG=nx.MultiDiGraph(day=\"Friday\")\nG.graph\n# {'day': 'Friday'}\nAdd node attributes using add_node(), add_nodes_from() or G.nodes\nG.add_node(1,time=\"5pm\")\nG.add_nodes_from([3],time=\"2pm\")\nG.nodes[1]\n# {'time': '5pm'}\nG.nodes[1][\"room\"]=714\ndelG.nodes[1][\"room\"]# remove attribute\nlist(G.nodes(data=True))\n# [(1, {'time': '5pm'}), (3, {'time': '2pm'})]\nAdd edge attributes using add_edge(), add_edges_from(), subscript\nnotation, or G.edges.\nkey=G.add_edge(1,2,weight=4.7)\nkeys=G.add_edges_from([(3,4),(4,5)],color=\"red\")\nkeys=G.add_edges_from([(1,2,{\"color\":\"blue\"}),(2,3,{\"weight\":8})])\nG[1][2][0][\"weight\"]=4.7\nG.edges[1,2,0][\"weight\"]=4\nWarning: we protect the graph data structure by makingG.edges[1,2,0]a read-only dict-like structure. However, you can assign to\nattributes in e.g.G.edges[1,2,0]. Thus, use 2 sets of brackets\nto add/change data attributes:G.edges[1,2,0]['weight']=4(for multigraphs the edge key is required:MG.edges[u,v,key][name]=value).\nShortcuts:\nMany common graph features allow python syntax to speed reporting.\n1inG# check if node in graph\n# True\n[nforninGifn<3]# iterate through nodes\n# [1, 2]\nlen(G)# number of nodes in graph\n# 5\nG[1]# adjacency dict-like view mapping neighbor -> edge key -> edge attributes\n# AdjacencyView({2: {0: {'weight': 4}, 1: {'color': 'blue'}}})\nOften the best way to traverse all edges of a graph is via the neighbors.\nThe neighbors are available as an adjacency-viewG.adjobject or via\nthe methodG.adjacency().\nforn,nbrsdictinG.adjacency():\nfornbr,keydictinnbrsdict.items():\nforkey,eattrinkeydict.items():\nif\"weight\"ineattr:\n# Do something useful with the edges\npass\nBut the edges() method is often more convenient:\nforu,v,keys,weightinG.edges(data=\"weight\",keys=True):\nifweightisnotNone:\n# Do something useful with the edges\npass\nReporting:\nSimple graph information is obtained using methods and object-attributes.\nReporting usually provides views instead of containers to reduce memory\nusage. The views update as the graph is updated similarly to dict-views.\nThe objectsnodes,edgesandadjprovide access to data attributes\nvia lookup (e.g.nodes[n],edges[u,v,k],adj[u][v]) and iteration\n(e.g.nodes.items(),nodes.data('color'),nodes.data('color',default='blue')and similarly foredges)\nViews exist fornodes,edges,neighbors()/adjanddegree.\nFor details on these and other miscellaneous methods, see below.\nSubclasses (Advanced):\nThe MultiDiGraph class uses a dict-of-dict-of-dict-of-dict structure.\nThe outer dict (node_dict) holds adjacency information keyed by node.\nThe next dict (adjlist_dict) represents the adjacency information\nand holds edge_key dicts keyed by neighbor. The edge_key dict holds\neach edge_attr dict keyed by edge key. The inner dict\n(edge_attr_dict) represents the edge data and holds edge attribute\nvalues keyed by attribute names.\nEach of these four dicts in the dict-of-dict-of-dict-of-dict\nstructure can be replaced by a user defined dict-like object.\nIn general, the dict-like features should be maintained but\nextra features can be added. To replace one of the dicts create\na new graph class by changing the class(!) variable holding the\nfactory for that dict-like structure. The variable names are\nnode_dict_factory, node_attr_dict_factory, adjlist_inner_dict_factory,\nadjlist_outer_dict_factory, edge_key_dict_factory, edge_attr_dict_factory\nand graph_attr_dict_factory."
        }
    },
    {
        "Section_id": "RectangleDrawer",
        "Description": "Static class which draws rectangular vertices",
        "Field List": {
            "Methods": {
                "draw_path": {
                    "Description": "overrides igraph.drawing.shapes.ShapeDrawer.draw_path\nDraws a rectangle-shaped path on the Cairo context without stroking or filling it.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "ShapeDrawer.draw_path",
                    "example": []
                },
                "intersection_point": {
                    "Description": "overrides igraph.drawing.shapes.ShapeDrawer.intersection_point\nDetermines where the rectangle centered at (center_x, center_y) having the given width and height intersects with a line drawn from (source_x, source_y) to (center_x, center_y).",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "ShapeDrawer.intersection_point",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "RainbowPalette",
        "Description": "A palette that varies the hue of the colors along a scale.\nColors in a rainbow palette all have the same saturation, value and alpha components, while the hue is varied between two given extremes linearly. This palette has the advantage that it wraps around nicely if the hue is varied between zero and one (which is the default).\n",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "overrides igraph.drawing.colors.Palette.__init__\nCreates a rainbow palette.",
                    "Paramters": {
                        "n": "the umber of colors i the palette.",
                        "s": "the aturation of the color in the palette.",
                        "v": "the alue component of the colors in the palette.",
                        "start": "the hue at which the rainbow begins (between 0 and 1).",
                        "end": "the hue at which the rainbow s (between 0 and 1).",
                        "alpha": "the  component of the colors in the palette."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__len__": {
                    "Description": "Inherited from Palette:Returns the number of colors in this palette"
                },
                "__plot__": {
                    "Description": "Inherited from Palette:Plots the colors of the palette on the given Cairo context/mpl Axes"
                },
                "__repr__": {
                    "Description": "Inherited from Palette:Undocumented"
                },
                "clear_cache": {
                    "Description": "Inherited from Palette:Clears the result cache."
                },
                "get": {
                    "Description": "Inherited from Palette:Returns the given color from the palette."
                },
                "get_many": {
                    "Description": "Inherited from Palette:Returns multiple colors from the palette."
                }
            },
            "property": {
                "length": "Inherited from Palette:Returns the number of colors in this palette"
            }
        },
        "Rubric": {
            "Example": [
                "Example:\n>>> pal = RainbowPalette(n=120)\n>>> pal.get(0)\n(1.0, 0.0, 0.0, 1.0)\n>>> pal.get(20)\n(1.0, 1.0, 0.0, 1.0)\n>>> pal.get(40)\n(0.0, 1.0, 0.0, 1.0)\n>>> pal = RainbowPalette(n=120, s=1, v=0.5, alpha=0.75)\n>>> pal.get(60)\n(0.0, 0.5, 0.5, 0.75)\n>>> pal.get(80)\n(0.0, 0.0, 0.5, 0.75)\n>>> pal.get(100)\n(0.5, 0.0, 0.5, 0.75)\n>>> pal = RainbowPalette(n=120)\n>>> pal2 = RainbowPalette(n=120, start=0.5, end=0.5)\n>>> pal.get(60) == pal2.get(0)\nTrue\n>>> pal.get(90) == pal2.get(30)\nTrue\n"
            ]
        }
    },
    {
        "Section_id": "mpl",
        "Description": "Undocumented"
    },
    {
        "Section_id": "plt",
        "Description": "Undocumented"
    },
    {
        "Section_id": "EdgeSeq",
        "Description": "Class representing a sequence of edges in the graph.\nThis class is most easily accessed by the es field of the Graph object, which returns an ordered sequence of all edges in the graph. The edge sequence can be refined by invoking the EdgeSeq.select() method. EdgeSeq.select() can also be accessed by simply calling the EdgeSeq object.\n",
        "Field List": {
            "Methods": {
                "__call__": {
                    "Description": "Shorthand notation to select()\nThis method simply passes all its arguments to EdgeSeq.select().",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "attributes": {
                    "Description": "Returns the list of all the edge attributes in the graph associated to this edge sequence.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "find": {
                    "Description": "overrides igraph._igraph.EdgeSeq.find\nReturns the first edge of the edge sequence that matches some criteria.\nThe selection criteria are equal to the ones allowed by VertexSeq.select. See VertexSeq.select for more details.\nFor instance, to find the first edge with weight larger than 5 in graph g:",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": [
                        "For instance, to find the first edge with weight larger than 5 in graph g:\n>>> g.es.find(weight_gt=5)           #doctest:+SKIP"
                    ]
                },
                "select": {
                    "Description": "overrides igraph._igraph.EdgeSeq.select\nSelects a subset of the edge sequence based on some criteria\nThe selection criteria can be specified by the positional and the keyword arguments. Positional arguments are always processed before keyword arguments.If the first positional argument is None, an empty sequence is returned.If the first positional argument is a callable object, the object will be called for every edge in the sequence. If it returns True, the edge will be included, otherwise it will be excluded.If the first positional argument is an iterable, it must return integers and they will be considered as indices of the current edge set (NOT the whole edge set of the graph -- the difference matters when one filters an edge set that has already been filtered by a previous invocation of EdgeSeq.select(). In this case, the indices do not refer directly to the edges of the graph but to the elements of the filtered edge sequence.If the first positional argument is an integer, all remaining arguments are expected to be integers. They are considered as indices of the current edge set again.\nKeyword arguments can be used to filter the edges based on their attributes and properties. The name of the keyword specifies the name of the attribute and the filtering operator, they should be concatenated by an underscore (_) character. Attribute names can also contain underscores, but operator names don't, so the operator is always the largest trailing substring of the keyword name that does not contain an underscore. Possible operators are:eq: equal tone: not equal tolt: less thangt: greater thanle: less than or equal toge: greater than or equal toin: checks if the value of an attribute is in a given listnotin: checks if the value of an attribute is not in a given list\nFor instance, if you want to filter edges with a numeric weight property larger than 50, you have to write:",
                    "Paramters": {},
                    "Return": [
                        "the new, filtered edge sequence"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": [
                        "For instance, if you want to filter edges with a numeric weight property larger than 50, you have to write:\n>>> g.es.select(weight_gt=50)            #doctest: +SKIP",
                        "Similarly, to filter edges whose type is in a list of predefined types:\n>>> g.es.select(weight_gt=50)            #doctest: +SKIP",
                        "If the operator is omitted, it defaults to eq. For instance, the following selector selects edges whose type property is intracluster:\n>>> g.es.select(weight_gt=50)            #doctest: +SKIP",
                        "For instance, if you want to exclude edges with a betweenness centrality less than 2:\n>>> g.es.select(weight_gt=50)            #doctest: +SKIP",
                        "To select edges originating from vertices 2 and 4:\n>>> g.es.select(weight_gt=50)            #doctest: +SKIP",
                        "To select edges lying entirely within the subgraph spanned by vertices 2, 3, 4 and 7:\n>>> g.es.select(weight_gt=50)            #doctest: +SKIP",
                        "To select edges with one endpoint in the vertex set containing vertices 2, 3, 4 and 7 and the other endpoint in the vertex set containing vertices 8 and 9:\n>>> g.es.select(weight_gt=50)            #doctest: +SKIP",
                        "For properties that take a long time to be computed (e.g., betweenness centrality for large graphs), it is advised to calculate the values in advance and store it in a graph attribute. The same applies when you are selecting based on the same property more than once in the same select() call to avoid calculating it twice unnecessarily. For instance, the following would calculate betweenness centralities twice:\n>>> g.es.select(weight_gt=50)            #doctest: +SKIP",
                        "It is advised to use this instead:\n>>> g.es.select(weight_gt=50)            #doctest: +SKIP"
                    ]
                },
                "attribute_names": {
                    "Description": "Inherited from EdgeSeq:Returns the attribute name list of the graph's edges"
                },
                "get_attribute_values": {
                    "Description": "Inherited from EdgeSeq:Returns the value of a given edge attribute for all edges."
                },
                "is_all": {
                    "Description": "Inherited from EdgeSeq:Returns whether the edge sequence contains all the edges exactly once, in the order of their edge IDs."
                },
                "set_attribute_values": {
                    "Description": "Inherited from EdgeSeq:Sets the value of a given edge attribute for all vertices"
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": [
                "An alternative way to create an edge sequence referring to a given graph is to use the constructor directly:\n>>> g = Graph.Full(3)\n>>> es = EdgeSeq(g)\n>>> restricted_es = EdgeSeq(g, [0, 1])",
                "The individual edges can be accessed by indexing the edge sequence object. It can be used as an iterable as well, or even in a list comprehension:\n>>> g = Graph.Full(3)\n>>> es = EdgeSeq(g)\n>>> restricted_es = EdgeSeq(g, [0, 1])",
                "The edge sequence can also be used as a dictionary where the keys are the attribute names. The values corresponding to the keys are the values of the given attribute of every edge in the graph:\n>>> g = Graph.Full(3)\n>>> es = EdgeSeq(g)\n>>> restricted_es = EdgeSeq(g, [0, 1])",
                "If you specify a sequence that is shorter than the number of edges in the EdgeSeq, the sequence is reused:\n>>> g = Graph.Full(3)\n>>> es = EdgeSeq(g)\n>>> restricted_es = EdgeSeq(g, [0, 1])",
                "You can even pass a single string or integer, it will be considered as a sequence of length 1:\n>>> g = Graph.Full(3)\n>>> es = EdgeSeq(g)\n>>> restricted_es = EdgeSeq(g, [0, 1])",
                "Some methods of the edge sequences are simply proxy methods to the corresponding methods in the Graph object. One such example is EdgeSeq.is_multiple():\n>>> g = Graph.Full(3)\n>>> es = EdgeSeq(g)\n>>> restricted_es = EdgeSeq(g, [0, 1])"
            ]
        }
    },
    {
        "Section_id": "AttributeSpecification",
        "Description": "Class that describes how the value of a given attribute should be retrieved.\nThe class contains the following members: name: the name of the attribute. This is also used when we are trying to get its value from a vertex/edge attribute of a graph. alt_name: alternative name of the attribute. This is used when we are trying to get its value from a Python dict or an igraph.Configuration object. If omitted at construction time, it will be equal to name. default: the default value of the attribute when none of the sources we try can provide a meaningful value. transform: optional transformation to be performed on the attribute value. If None or omitted, it defaults to the type of the default value. func: when given, this function will be called with an index in order to derive the value of the attribute. ",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "MatplotlibDendrogramDrawer",
        "Description": "Matplotlib drawer object for dendrograms.",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "Constructs the drawer and associates it to the given Axes.",
                    "Paramters": {
                        "ax": "the Axes on which we will draw"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw": {
                    "Description": "overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nDraws the given Dendrogram in a matplotlib Axes.\nOther keyword arguments are passed to mpl.patches.Polygon.",
                    "Paramters": {
                        "dendro": "the igraph.Dendrogram to plot.",
                        "orientation": "the direction of the plot. Accepted values are \"lr\" (root on the right), \"rl\" (root on the left), \"tb\" (root at the bottom), and \"bt\" (root at the top). A few aliases are available (see utils.str_to_).",
                        "**kwds": "Undocumented"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "DrawerDirectory",
        "Description": "Static class that finds the object/backend drawer\nThis directory is used by the __plot__ functions.",
        "Field List": {
            "Methods": {
                "resolve": {
                    "Description": "Given a shape name, returns the corresponding shape drawer class",
                    "Paramters": {
                        "cls": "the class to resolve",
                        "obj": "an instance of the ect to plot",
                        "backend": "the name of the "
                    },
                    "Return": [
                        "the corresponding shape drawer class"
                    ],
                    "References": [],
                    "Rasises": {
                        "ValueError": "if no drawer is available for this backend/object"
                    },
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "mpl",
        "Description": "Undocumented"
    },
    {
        "Section_id": "plt",
        "Description": "Undocumented"
    },
    {
        "Section_id": "summary",
        "Description": "Prints a summary of object o to a given stream\nPositional and keyword arguments not explicitly mentioned here are passed on to the underlying summary() method of the object if it has any.",
        "Paramters": {
            "obj": "the ect about which a human-readable summary is requested.",
            "stream": "the  to be used. If None, the standard output will be used.",
            "*args": "Undocumented",
            "**kwds": "Undocumented"
        },
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "AttributeCollectorBase",
        "Description": "Base class for attribute collector subclasses. Classes that inherit this class may use a declarative syntax to specify which vertex or edge attributes they intend to collect. See AttributeCollectorMeta for the details.",
        "Field List": {
            "Methods": {
                "__getitem__": {
                    "Description": "Returns the collected attributes of the vertex/edge with the given index.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__init__": {
                    "Description": "Constructs a new attribute collector that uses the given vertex/edge sequence and the given dict as data sources.",
                    "Paramters": {
                        "seq": "an igraph.VertexSeq or igraph.EdgeSeq class that will be used as a data source for attributes.",
                        "kwds": "a Python dict that will be used to override the attributes collected from seq if necessary."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__len__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "mpl",
        "Description": "Undocumented"
    },
    {
        "Section_id": "plt",
        "Description": "Undocumented"
    },
    {
        "Section_id": "MatplotlibHistogramDrawer",
        "Description": "Matplotlib drawer object for matrices.",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "Constructs the drawer and associates it to the given Axes.",
                    "Paramters": {
                        "ax": "the Axes on which we will draw"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw": {
                    "Description": "overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nDraws the given Matrix in a matplotlib Axes.",
                    "Paramters": {
                        "matrix": "the igraph.Histogram to plot.",
                        "**kwds": "Undocumented"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "mpl",
        "Description": "Undocumented"
    },
    {
        "Section_id": "_",
        "Description": "Undocumented"
    },
    {
        "Section_id": "TriadCensus",
        "Description": "Triad census of a graph.\nThis is a pretty simple class - basically it is a tuple, but it allows the user to refer to its individual items by the following triad names: 003 -- the empty graph 012 -- a graph with a single directed edge (A --> B, C) 102 -- a graph with a single mutual edge (A <-> B, C) 021D -- the binary out-tree (A <-- B --> C) 021U -- the binary in-tree (A --> B <-- C) 021C -- the directed line (A --> B --> C) 111D -- A <-> B <-- C 111U -- A <-> B --> C 030T -- A --> B <-- C, A --> C 030C -- A <-- B <-- C, A --> C 201 -- A <-> B <-> C 120D -- A <-- B --> C, A <-> C 120U -- A --> B <-- C, A <-> C 120C -- A --> B --> C, A <-> C 210C -- A --> B <-> C, A <-> C 300 -- the complete graph (A <-> B <-> C, A <-> C) \nAttribute and item accessors are provided. Due to the syntax of Python, attribute names are not allowed to start with a number, therefore the triad names must be prepended with a lowercase t when accessing them as attributes. This is not necessary with the item accessor syntax.\n",
        "Field List": {
            "Methods": {
                "__getattr__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__getitem__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__repr__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__str__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": [
                "Examples:\n>>> from igraph import Graph\n>>> g=Graph.Erdos_Renyi(100, 0.2, directed=True)\n>>> tc=g.triad_census()\n>>> print(tc.t003)                    #doctest:+SKIP\n39864\n>>> print(tc[\"030C\"])                 #doctest:+SKIP\n1206\n"
            ]
        }
    },
    {
        "Section_id": "ClusterColoringPalette",
        "Description": "A palette suitable for coloring vertices when plotting a clustering.\nThis palette tries to make sure that the colors are easily distinguishable. This is achieved by using a set of base colors and their lighter and darker variants, depending on the number of elements in the palette.\nWhen the desired size of the palette is less than or equal to the number of base colors (denoted by n), only the bsae colors will be used. When the size of the palette is larger than n but less than 2*n, the base colors and their lighter variants will be used. Between 2*n and 3*n, the base colors and their lighter and darker variants will be used. Above 3*n, more darker and lighter variants will be generated, but this makes the individual colors less and less distinguishable.",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "overrides igraph.drawing.colors.PrecalculatedPalette.__init__\nCreates the palette backed by the given list. The list must contain RGBA quadruplets or color names, which will be resolved first by color_name_to_rgba(). Anything that is understood by color_name_to_rgba() is OK here.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "BFSIter",
        "Description": "igraph BFS iterator object",
        "Field List": {
            "Methods": {},
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "NullDrawer",
        "Description": "Static drawer class which draws nothing.\nThis class is used for graph vertices with unknown shapes",
        "Field List": {
            "Methods": {
                "draw_path": {
                    "Description": "overrides igraph.drawing.shapes.ShapeDrawer.draw_path\nDraws nothing.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "plotly",
        "Description": "Undocumented"
    },
    {
        "Section_id": "CairoTextDrawer",
        "Description": "Class that draws text on a Cairo context.\nThis class supports multi-line text unlike the original Cairo text drawing methods.",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "overrides igraph.drawing.cairo.base.AbstractCairoDrawer.__init__\nConstructs a new instance that will draw the given text on the given Cairo context.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw": {
                    "Description": "overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nDraws the text in the current bounding box of the drawer.\nSince the class itself is an instance of AbstractCairoDrawer, it has an attribute named bbox which will be used as a bounding box.",
                    "Paramters": {
                        "wrap": "whether to allow re-ping of the text if it does not fit within the bounding box horizontally."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw_at": {
                    "Description": "Draws the text by setting up an appropriate path on the Cairo context and filling it. x and y denote the coordinates where the drawing should start. If they are both None, the current position of the context will be used.\nVertical alignment settings are not taken into account in this method as the text is not drawn within a box.",
                    "Paramters": {
                        "x": "The X coordinate of the reference point where the layout should start.",
                        "y": "The Y coordinate of the reference point where the laout should start.",
                        "width": "The  of the box in which the text will be fitted. It matters only when the text is right-aligned or centered. The text will overflow the box if any of the lines is longer than the box  and wrap is False.",
                        "wrap": "whether to allow re-ping of the text if it does not fit within the given width."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_text_layout": {
                    "Description": "Calculates the layout of the current text. x and y denote the coordinates where the drawing should start. If they are both None, the current position of the context will be used.\nVertical alignment settings are not taken into account in this method as the text is not drawn within a box.",
                    "Paramters": {
                        "x": "The X coordinate of the reference point where the layout should start.",
                        "y": "The Y coordinate of the reference point where the laout should start.",
                        "width": "The  of the box in which the text will be fitted. It matters only when the text is right-aligned or centered. The text will overflow the box if any of the lines is longer than the box  and wrap is False.",
                        "wrap": "whether to allow re-ping of the text if it does not fit within the given width."
                    },
                    "Return": [
                        "a list consisting of (x, y, line) tuples where x and y refer to reference points on the Cairo canvas and line refers to the corresponding text that should be plotted there."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "text": {
                    "Description": "Sets the text that will be drawn.\nIf text is None, it will be mapped to an empty string; otherwise, it will be converted to a string.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "text_extents": {
                    "Description": "Returns the X-bearing, Y-bearing, width, height, X-advance and Y-advance of the text.\nFor multi-line text, the X-bearing and Y-bearing correspond to the first line, while the X-advance is extracted from the last line. and the Y-advance is the sum of all the Y-advances. The width and height correspond to the entire bounding box of the text.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "bbox.setter": {
                    "Description": "Inherited from AbstractCairoDrawer:Sets the bounding box of the drawing area where this drawer will draw."
                }
            },
            "property": {
                "text": "Returns the text to be drawn.\n",
                "bbox": "Inherited from AbstractCairoDrawer:The bounding box of the drawing area where this drawer will draw."
            }
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "AbstractCairoVertexDrawer",
        "Description": "Abstract base class for vertex drawers that draw on a Cairo canvas.",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "overrides igraph.drawing.baseclasses.AbstractVertexDrawer.__init__\nConstructs the vertex drawer and associates it to the given Cairo context and the given BoundingBox.",
                    "Paramters": {
                        "context": "the  on which we will draw",
                        "bbox": "the bounding box within which we will draw. Can be anything accepted by the constructor of BoundingBox (i.e., a 2-tuple, a 4-tuple or a BoundingBox object).",
                        "palette": "the  that can be used to map integer color indices to colors when drawing vertices",
                        "layout": "the  of the vertices in the graph being drawn"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw": {
                    "Description": "Inherited from AbstractVertexDrawer:Draws the given vertex."
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "GraphBase",
        "Description": "Low-level representation of a graph.\nDon't use it directly, use igraph.Graph instead.",
        "Field List": {
            "Methods": {
                "__new__": {
                    "Description": "Create and return a new object.  See help(type) for accurate signature.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "add_edges": {
                    "Description": "overridden in igraph.Graph\nAdds edges to the graph.",
                    "Paramters": {
                        "es": "the list of edg to be added. Every edge is reprented with a tuple, containing the vertex IDs of the two endpoints. Vertic are enumerated from zero."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "add_vertices": {
                    "Description": "overridden in igraph.Graph\nAdds vertices to the graph.",
                    "Paramters": {
                        "n": "the umber of vertices to be added"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Adjacency": {
                    "Description": "overridden in igraph.Graph\nGenerates a graph from its adjacency matrix.",
                    "Paramters": {
                        "matrix": "the adjacency ",
                        "mode": "the  to be used. Possible values are:\"directed\" - the graph will be directed and a matrix element specifies the number of edges between two vertices.\"undirected\" - the graph will be undirected and a matrix element specifies the number of edges between two vertices. The input matrix must be symmetric.\"max\"   - undirected graph will be created and the number of edges between vertex i and j is max(A(i,\u2009j),\u2009A(j,\u2009i))\"min\"   - like \"max\", but with min(A(i,\u2009j),\u2009A(j,\u2009i))\"plus\"  - like \"max\", but with A(i,\u2009j)\u2009+\u2009A(j,\u2009i)\"upper\" - undirected graph with the upper right triangle of the matrix (including the diagonal)\"lower\" - undirected graph with the lower left triangle of the matrix (including the diagonal)",
                        "loops": "specifies how the diagonal of the matrix should be handled:\"ignore\" - ignore loop edges in the diagonal\"once\" - treat the diagonal entries as loop edge counts\"twice\" - treat the diagonal entries as twice the number of loop edges"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "all_minimal_st_separators": {
                    "Description": "Returns a list containing all the minimal s-t separators of a graph.\nA minimal separator is a set of vertices whose removal disconnects the graph, while the removal of any subset of the set keeps the graph connected.\nReference: Anne Berry, Jean-Paul Bordat and Olivier Cogis: Generating all the minimal separators of a graph. In: Peter Widmayer, Gabriele Neyer and Stephan Eidenbenz (eds.): Graph-theoretic concepts in computer science, 1665, 167-172, 1999. Springer.",
                    "Paramters": {},
                    "Return": [
                        "a list where each item lists the vertex indices of a given minimal s-t separator."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "all_st_cuts": {
                    "Description": "overridden in igraph.Graph\nReturns all the cuts between the source and target vertices in a directed graph.\nThis function lists all edge-cuts between a source and a target vertex. Every cut is listed exactly once.\nAttention: this function has a more convenient interface in class Graph, which wraps the result in a list of Cut objects. It is advised to use that.",
                    "Paramters": {
                        "source": "the  vertex ID",
                        "target": "the  vertex ID"
                    },
                    "Return": [
                        "a tuple where the first element is a list of lists of edge IDs representing a cut and the second element is a list of lists of vertex IDs representing the sets of vertices that were separated by the cuts."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "all_st_mincuts": {
                    "Description": "overridden in igraph.Graph\nReturns all minimum cuts between the source and target vertices in a directed graph.\nAttention: this function has a more convenient interface in class Graph, which wraps the result in a list of Cut objects. It is advised to use that.",
                    "Paramters": {
                        "source": "the  vertex ID",
                        "target": "the  vertex ID"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "are_connected": {
                    "Description": "Decides whether two given vertices are directly connected.",
                    "Paramters": {
                        "v1": "the ID or name of the first vertex",
                        "v2": "the ID or name of the second vertex"
                    },
                    "Return": [
                        "True if there exists an edge from v1 to v2, False otherwise."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "articulation_points": {
                    "Description": "Returns the list of articulation points in the graph.\nA vertex is an articulation point if its removal increases the number of connected components in the graph.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "assortativity": {
                    "Description": "Returns the assortativity of the graph based on numeric properties of the vertices.\nThis coefficient is basically the correlation between the actual connectivity patterns of the vertices and the pattern expected from the distribution of the vertex types.\nSee equation (21) in Newman MEJ: Mixing patterns in networks, Phys Rev E 67:026126 (2003) for the proper definition. The actual calculation is performed using equation (26) in the same paper for directed graphs, and equation (4) in Newman MEJ: Assortative mixing in networks, Phys Rev Lett 89:208701 (2002) for undirected graphs.\n",
                    "Paramters": {
                        "types1": "vertex types in a list or the name of a vertex attribute holding vertex types. Types are ideally denoted by numeric values.",
                        "types2": "in directed assortativity calculations, each vertex can have an out-type and an in-type. In this case, types1 contains the out-types and this parameter contains the in-types in a list or the name of a vertex attribute. If None, it is assumed to be equal to types1.",
                        "directed": "whether to consider edge directions or not.",
                        "normalized": "whether to compute the  covariance, i.e. Pearson correlation. Supply True here to compute the standard assortativity."
                    },
                    "Return": [
                        "the assortativity coefficient"
                    ],
                    "References": [
                        "Newman MEJ: Mixing patterns in networks, Phys Rev E 67:026126, 2003.Newman MEJ: Assortative mixing in networks, Phys Rev Lett 89:208701, 2002."
                    ],
                    "Rasises": {},
                    "See Also": "assortativity_degree() when the types are the vertex degrees",
                    "example": []
                },
                "assortativity_degree": {
                    "Description": "Returns the assortativity of a graph based on vertex degrees.\nSee assortativity() for the details. assortativity_degree() simply calls assortativity() with the vertex degrees as types.",
                    "Paramters": {
                        "directed": "whether to consider edge directions for  graphs or not. This argument is ignored for un graphs."
                    },
                    "Return": [
                        "the assortativity coefficient"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "assortativity()",
                    "example": []
                },
                "assortativity_nominal": {
                    "Description": "Returns the assortativity of the graph based on vertex categories.\nAssuming that the vertices belong to different categories, this function calculates the assortativity coefficient, which specifies the extent to which the connections stay within categories. The assortativity coefficient is one if all the connections stay within categories and minus one if all the connections join vertices of different categories. For a randomly connected network, it is asymptotically zero.\nSee equation (2) in Newman MEJ: Mixing patterns in networks, Phys Rev E 67:026126 (2003) for the proper definition.\nReference: Newman MEJ: Mixing patterns in networks, Phys Rev E 67:026126, 2003.",
                    "Paramters": {
                        "types": "vertex  in a list or the name of a vertex attribute holding vertex . Types should be denoted by numeric values.",
                        "directed": "whether to consider edge directions or not.",
                        "normalized": "whether to compute the (usual)  assortativity. The un version is identical to modularity. Supply True here to compute the standard assortativity."
                    },
                    "Return": [
                        "the assortativity coefficient"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Asymmetric_Preference": {
                    "Description": "Generates a graph based on asymmetric vertex types and connection probabilities.\nThis is the asymmetric variant of Preference(). A given number of vertices are generated. Every vertex is assigned to an \"incoming\" and an \"outgoing\" vertex type according to the given joint type probabilities. Finally, every vertex pair is evaluated and a directed edge is created between them with a probability depending on the \"outgoing\" type of the source vertex and the \"incoming\" type of the target vertex.",
                    "Paramters": {
                        "n": "the umber of vertices i the graph",
                        "type_dist_matrix": "matrix giving the joint distribution of vertex types",
                        "pref_matrix": "matrix giving the connection probabilities for different vertex types.",
                        "attribute": "the vertex  name used to store the vertex types. If None, vertex types are not stored.",
                        "loops": "whether loop edges are allowed."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Atlas": {
                    "Description": "Generates a graph from the Graph Atlas.\nReference: Ronald C. Read and Robin J. Wilson: An Atlas of Graphs. Oxford University Press, 1998.",
                    "Paramters": {
                        "idx": "The index of the graph to be generated. Indices start from zero, graphs are listed:in increasing order of number of vertices;for a fixed number of vertices, in increasing order of the number of edges;for fixed numbers of vertices and edges, in increasing order of the degree sequence, for example 111223 < 112222;for fixed degree sequence, in increasing number of automorphisms."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "attributes": {
                    "Description": "",
                    "Paramters": {},
                    "Return": [
                        "the attribute name list of the graph"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "authority_score": {
                    "Description": "Calculates Kleinberg's authority score for the vertices of the graph",
                    "Paramters": {
                        "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name.",
                        "scale": "whether to normalize the scores so that the largest one is 1.",
                        "arpack_options": "an ARPACKOptions object used to fine-tune the ARPACK eigenvector calculation. If omitted, the module-level variable called  is used.",
                        "return_eigenvalue": "whether to return the largest eigenvalue"
                    },
                    "Return": [
                        "the authority scores in a list and optionally the largest eigenvalue as a second member of a tuple"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "hub_score()",
                    "example": []
                },
                "automorphism_group": {
                    "Description": "Calculates the generators of the automorphism group of a graph using the BLISS isomorphism algorithm.\nThe generator set may not be minimal and may depend on the splitting heuristics. The generators are permutations represented using zero-based indexing.",
                    "Paramters": {
                        "sh": "splitting heuristics for graph as a case-insensitive string, with the following possible values:\"f\": first non-singleton cell\"fl\": first largest non-singleton cell\"fs\": first smallest non-singleton cell\"fm\": first maximally non-trivially connected non-singleton cell\"flm\": largest maximally non-trivially connected non-singleton cell\"fsm\": smallest maximally non-trivially connected non-singleton cell",
                        "color": "optional vector storing a ing of the vertices with respect to which the isomorphism is computed.  If None, all vertices have the same ."
                    },
                    "Return": [
                        "a list of integer vectors, each vector representing an automorphism group of the graph."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "average_path_length": {
                    "Description": "Calculates the average path length in a graph.",
                    "Paramters": {
                        "directed": "whether to consider  paths in case of a  graph. Ignored for un graphs.",
                        "unconn": "what to do when the graph is ected. If True, the average of the geodesic lengths in the components is calculated. Otherwise for all ected vertex pairs, a path length equal to the number of vertices is used.",
                        "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name."
                    },
                    "Return": [
                        "the average path length in the graph"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Barabasi": {
                    "Description": "Generates a graph based on the Barab\u00e1si-Albert model.\nReference: Barab\u00e1si, A-L and Albert, R. 1999. Emergence of scaling in random networks. Science, 286 509-512.",
                    "Paramters": {
                        "n": "the umber of vertices",
                        "m": "either the nuber of outgoing edges generated for each vertex or a list containing the nuber of outgoing edges for each vertex explicitly.",
                        "outpref": "True if the out-degree of a given vertex should also increase its citation probability (as well as its in-degree), but it defaults to False.",
                        "directed": "True if the generated graph should be  (default: False).",
                        "power": "the  constant of the nonlinear model. It can be omitted, and in this case the usual linear model will be used.",
                        "zero_appeal": "the attractivity of vertices with degree zero.",
                        "implementation": "the algorithm to use to generate the network. Possible values are:\"bag\": the algorithm that was the default in igraph before 0.6. It works by putting the ids of the vertices into a bag (multiset) exactly as many times as their in-degree, plus once more. The required number of cited vertices are then drawn from the bag with replacement. It works only for power=1 and zero_appeal=1.\"psumtree\": this algorithm uses a partial prefix-sum tree to generate the graph. It does not generate multiple edges and it works for any values of power and zero_appeal.\"psumtree_multiple\": similar to \"psumtree\", but it will generate multiple edges as well. igraph before 0.6 used this algorithm for powers other than 1.",
                        "start_from": "if given and not None, this must be another GraphBase object. igraph will use this graph as a starting point for the preferential attachment model."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "betweenness": {
                    "Description": "Calculates or estimates the betweenness of vertices in a graph.\nAlso supports calculating betweenness with shortest path length cutoffs or considering shortest paths only from certain source vertices or to certain target vertices.\nKeyword arguments:",
                    "Paramters": {
                        "vertices": "the  for which the betweennesses must be returned. If None, assumes all of the  in the graph.",
                        "directed": "whether to consider  paths.",
                        "cutoff": "if it is an integer, only paths less than or equal to this length are considered, effectively resulting in an estimation of the betweenness for the given vertices. If None, the exact betweenness is returned.",
                        "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name.",
                        "sources": "the set of source vertices to consider when calculating shortest paths.",
                        "targets": "the set of target vertices to consider when calculating shortest paths."
                    },
                    "Return": [
                        "the (possibly cutoff-limited) betweenness of the given vertices in a list"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "bfs": {
                    "Description": "Conducts a breadth first search (BFS) on the graph.",
                    "Paramters": {
                        "vid": "the root vertex ID",
                        "mode": "either \"in\" or \"out\" or \"all\", ignored for undirected graphs."
                    },
                    "Return": [
                        "a tuple with the following items:\n\nThe vertex IDs visited (in order)\nThe start indices of the layers in the vertex list\nThe parent of every vertex in the BFS\n\n"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "bfsiter": {
                    "Description": "Constructs a breadth first search (BFS) iterator of the graph.",
                    "Paramters": {
                        "vid": "the root vertex ID",
                        "mode": "either \"in\" or \"out\" or \"all\".",
                        "advanced": "if False, the iterator returns the next vertex in BFS order in every step. If True, the iterator returns the distance of the vertex from the root and the parent of the vertex in the BFS tree as well."
                    },
                    "Return": [
                        "the BFS iterator as an igraph.BFSIter object."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "bibcoupling": {
                    "Description": "Calculates bibliographic coupling scores for given vertices in a graph.",
                    "Paramters": {
                        "vertices": "the  to be analysed. If None, all  will be considered."
                    },
                    "Return": [
                        "bibliographic coupling scores for all given vertices in a matrix."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "biconnected_components": {
                    "Description": "overridden in igraph.Graph\nCalculates the biconnected components of the graph.\nComponents containing a single vertex only are not considered as being biconnected.",
                    "Paramters": {
                        "return_articulation_points": "whether to return the articulation points as well"
                    },
                    "Return": [
                        "a list of lists containing edge indices making up spanning trees of the biconnected components (one spanning tree for each component) and optionally the list of articulation points"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "bipartite_projection": {
                    "Description": "overridden in igraph.Graph\nInternal function, undocumented.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "Graph.bipartite_projection()",
                    "example": []
                },
                "bipartite_projection_size": {
                    "Description": "overridden in igraph.Graph\nInternal function, undocumented.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "Graph.bipartite_projection_size()",
                    "example": []
                },
                "bridges": {
                    "Description": "Returns the list of bridges in the graph.\nAn edge is a bridge if its removal increases the number of (weakly) connected components in the graph.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "canonical_permutation": {
                    "Description": "Calculates the canonical permutation of a graph using the BLISS isomorphism algorithm.\nPassing the permutation returned here to permute_vertices() will transform the graph into its canonical form.\nSee http://www.tcs.hut.fi/Software/bliss/index.html for more information about the BLISS algorithm and canonical permutations.",
                    "Paramters": {
                        "sh": "splitting heuristics for graph as a case-insensitive string, with the following possible values:\"f\": first non-singleton cell\"fl\": first largest non-singleton cell\"fs\": first smallest non-singleton cell\"fm\": first maximally non-trivially connected non-singleton cell\"flm\": largest maximally non-trivially connected non-singleton cell\"fsm\": smallest maximally non-trivially connected non-singleton cell",
                        "color": "optional vector storing a ing of the vertices with respect to which the isomorphism is computed.  If None, all vertices have the same ."
                    },
                    "Return": [
                        "a permutation vector containing vertex IDs. Vertex 0 in the original graph will be mapped to an ID contained in the first element of this vector; vertex 1 will be mapped to the second and so on."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "chordal_completion": {
                    "Description": "Returns the list of edges needed to be added to the graph to make it chordal.\nA graph is chordal if each of its cycles of four or more nodes has a chord, i.e. an edge joining two nodes that are not adjacent in the cycle. An equivalent definition is that any chordless cycles have at most three nodes.\nThe chordal completion of a graph is the list of edges that needed to be added to the graph to make it chordal. It is an empty list if the graph is already chordal.\nNote that at the moment igraph does not guarantee that the returned chordal completion is minimal; there may exist a subset of the returned chordal completion that is still a valid chordal completion.",
                    "Paramters": {
                        "alpha": "the  vector from the result of calling maximum_cardinality_search() on the graph. Useful only if you already have the  vector; simply passing None here will make igraph calculate the  vector on its own.",
                        "alpham1": "the inverse alpha vector from the result of calling maximum_cardinality_search() on the graph. Useful only if you already have the inverse alpha vector; simply passing None here will make igraph calculate the inverse alpha vector on its own."
                    },
                    "Return": [
                        "the list of edges to add to the graph; each item in the list is a source-target pair of vertex indices."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "clique_number": {
                    "Description": "Returns the clique number of the graph.\nThe clique number of the graph is the size of the largest clique.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "largest_cliques() for the largest cliques.",
                    "example": []
                },
                "cliques": {
                    "Description": "Returns some or all cliques of the graph as a list of tuples.\nA clique is a complete subgraph -- a set of vertices where an edge is present between any two of them (excluding loops)",
                    "Paramters": {
                        "min": "the imum size of cliques to be returned. If zero or negative, no lower bound will be used.",
                        "max": "the imum size of cliques to be returned. If zero or negative, no upper bound will be used."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "closeness": {
                    "Description": "Calculates the closeness centralities of given vertices in a graph.\nThe closeness centrality of a vertex measures how easily other vertices can be reached from it (or the other way: how easily it can be reached from the other vertices). It is defined as the number of vertices minus one divided by the sum of the lengths of all geodesics from/to the given vertex.\nIf the graph is not connected, and there is no path between two vertices, the number of vertices is used instead the length of the geodesic. This is always longer than the longest possible geodesic.",
                    "Paramters": {
                        "vertices": "the  for which the closenesses must be returned. If None, uses all of the  in the graph.",
                        "mode": "must be one of \"in\", \"out\" and \"all\". \"in\" means that the length of the incoming paths, \"out\" means that the length of the outgoing paths must be calculated. \"all\" means that both of them must be calculated.",
                        "cutoff": "if it is an integer, only paths less than or equal to this length are considered, effectively resulting in an estimation of the closeness for the given vertices (which is always an underestimation of the real closeness, since some vertex pairs will appear as disconnected even though they are connected).. If None, the exact closeness is returned.",
                        "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name.",
                        "normalized": "Whether to normalize the raw closeness scores by multiplying by the number of vertices minus one."
                    },
                    "Return": [
                        "the calculated closenesses in a list"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "cocitation": {
                    "Description": "Calculates cocitation scores for given vertices in a graph.",
                    "Paramters": {
                        "vertices": "the  to be analysed. If None, all  will be considered."
                    },
                    "Return": [
                        "cocitation scores for all given vertices in a matrix."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "cohesive_blocks": {
                    "Description": "overridden in igraph.Graph\nCalculates the cohesive block structure of the graph.\nAttention: this function has a more convenient interface in class Graph, which wraps the result in a CohesiveBlocks object. It is advised to use that.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "community_edge_betweenness": {
                    "Description": "overridden in igraph.Graph\nCommunity structure detection based on the betweenness of the edges in the network. This algorithm was invented by M Girvan and MEJ Newman, see: M Girvan and MEJ Newman: Community structure in social and biological networks, Proc. Nat. Acad. Sci. USA 99, 7821-7826 (2002).\nThe idea is that the betweenness of the edges connecting two communities is typically high. So we gradually remove the edge with the highest betweenness from the network and recalculate edge betweenness after every removal, as long as all edges are removed.\nAttention: this function is wrapped in a more convenient syntax in the derived class Graph. It is advised to use that instead of this version.",
                    "Paramters": {
                        "directed": "whether to take into account the ness of the edges when we calculate the betweenness values.",
                        "weights": "name of an edge attribute or a list containing edge ."
                    },
                    "Return": [
                        "a tuple with the merge matrix that describes the dendrogram and the modularity scores before each merge. The modularity scores use the weights if the original graph was weighted."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "community_fastgreedy": {
                    "Description": "overridden in igraph.Graph\nFinds the community structure of the graph according to the algorithm of Clauset et al based on the greedy optimization of modularity.\nThis is a bottom-up algorithm: initially every vertex belongs to a separate community, and communities are merged one by one. In every step, the two communities being merged are the ones which result in the maximal increase in modularity.\nAttention: this function is wrapped in a more convenient syntax in the derived class Graph. It is advised to use that instead of this version.\nReference: A. Clauset, M. E. J. Newman and C. Moore: Finding community structure in very large networks. Phys Rev E 70, 066111 (2004).",
                    "Paramters": {
                        "weights": "name of an edge attribute or a list containing edge "
                    },
                    "Return": [
                        "a tuple with the following elements:\n\nThe list of merges\nThe modularity scores before each merge\n\n"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "modularity()",
                    "example": []
                },
                "community_infomap": {
                    "Description": "overridden in igraph.Graph\nFinds the community structure of the network according to the Infomap method of Martin Rosvall and Carl T. Bergstrom.\nSee http://www.mapequation.org for a visualization of the algorithm or one of the references provided below. ",
                    "Paramters": {
                        "edge_weights": "name of an edge attribute or a list containing edge weights.",
                        "vertex_weights": "name of an vertex attribute or a list containing vertex weights.",
                        "trials": "the number of attempts to partition the network."
                    },
                    "Return": [
                        "the calculated membership vector and the corresponding codelength in a tuple."
                    ],
                    "References": [
                        "M. Rosvall and C. T. Bergstrom: Maps of information flow reveal community structure in complex networks. PNAS 105, 1118 (2008). http://arxiv.org/abs/0707.0609M. Rosvall, D. Axelsson and C. T. Bergstrom: The map equation. Eur Phys J Special Topics 178, 13 (2009). http://arxiv.org/abs/0906.1405"
                    ],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "community_label_propagation": {
                    "Description": "overridden in igraph.Graph\nFinds the community structure of the graph according to the label propagation method of Raghavan et al.\nInitially, each vertex is assigned a different label. After that, each vertex chooses the dominant label in its neighbourhood in each iteration. Ties are broken randomly and the order in which the vertices are updated is randomized before every iteration. The algorithm ends when vertices reach a consensus.\nNote that since ties are broken randomly, there is no guarantee that the algorithm returns the same community structure after each run. In fact, they frequently differ. See the paper of Raghavan et al on how to come up with an aggregated community structure.\nReference: Raghavan, U.N. and Albert, R. and Kumara, S. Near linear time algorithm to detect community structures in large-scale networks. Phys Rev E 76:036106, 2007. http://arxiv.org/abs/0709.2938.",
                    "Paramters": {
                        "weights": "name of an edge attribute or a list containing edge ",
                        "initial": "name of a vertex attribute or a list containing the  vertex labels. Labels are identified by integers from zero to n\u2009\u2212\u20091 where n is the number of vertices. Negative numbers may also be present in this vector, they represent unlabeled vertices.",
                        "fixed": "a list of booleans for each vertex. True corresponds to vertices whose labeling should not change during the algorithm. It only makes sense if initial labels are also given. Unlabeled vertices cannot be . Note that vertex attribute names are not accepted here."
                    },
                    "Return": [
                        "the resulting membership vector"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "community_leading_eigenvector": {
                    "Description": "overridden in igraph.Graph\nA proper implementation of Newman's eigenvector community structure detection. Each split is done by maximizing the modularity regarding the original network. See the reference for details.\nAttention: this function is wrapped in a more convenient syntax in the derived class Graph. It is advised to use that instead of this version.\nReference: MEJ Newman: Finding community structure in networks using the eigenvectors of matrices, arXiv:physics/0605087",
                    "Paramters": {
                        "n": "the desired umber of commuities. If egative, the algorithm tries to do as may splits as possible. Note that the algorithm wo't split a commuity further if the sigs of the leadig eigevector are all the same.",
                        "arpack_options": "an ARPACKOptions object used to fine-tune the ARPACK eigenvector calculation. If omitted, the module-level variable called  is used.",
                        "weights": "name of an edge attribute or a list containing edge "
                    },
                    "Return": [
                        "a tuple where the first element is the membership vector of the clustering and the second element is the merge matrix."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "community_leiden": {
                    "Description": "overridden in igraph.Graph\nFinds the community structure of the graph using the Leiden algorithm of Traag, van Eck & Waltman.",
                    "Paramters": {
                        "edge_weights": "edge weights to be used. Can be a sequence or iterable or even an edge attribute name.",
                        "node_weights": "the node weights used in the Leiden algorithm.",
                        "resolution": "the  parameter to use. Higher s lead to more smaller communities, while lower s lead to fewer larger communities.",
                        "normalize_resolution": "if set to true, the resolution parameter will be divided by the sum of the node weights. If this is not supplied, it will default to the node degree, or weighted degree in case edge_weights are supplied.",
                        "beta": "parameter affecting the randomness in the Leiden algorithm. This affects only the refinement step of the algorithm.",
                        "initial_membership": "if provided, the Leiden algorithm will try to improve this provided membership. If no argument is provided, the aglorithm simply starts from the singleton partition.",
                        "n_iterations": "the number of iterations to iterate the Leiden algorithm. Each iteration may improve the partition further. You can also set this parameter to a negative number, which means that the algorithm will be iterated until an iteration does not change the current membership vector any more."
                    },
                    "Return": [
                        "the community membership vector."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "community_multilevel": {
                    "Description": "overridden in igraph.Graph\nFinds the community structure of the graph according to the multilevel algorithm of Blondel et al. This is a bottom-up algorithm: initially every vertex belongs to a separate community, and vertices are moved between communities iteratively in a way that maximizes the vertices' local contribution to the overall modularity score. When a consensus is reached (i.e. no single move would increase the modularity score), every community in the original graph is shrank to a single vertex (while keeping the total weight of the incident edges) and the process continues on the next level. The algorithm stops when it is not possible to increase the modularity any more after shrinking the communities to vertices.\nReference: VD Blondel, J-L Guillaume, R Lambiotte and E Lefebvre: Fast unfolding of community hierarchies in large networks. J Stat Mech P10008 (2008), http://arxiv.org/abs/0803.0476\nAttention: this function is wrapped in a more convenient syntax in the derived class Graph. It is advised to use that instead of this version.",
                    "Paramters": {
                        "weights": "name of an edge attribute or a list containing edge ",
                        "return_levels": "if True, returns the multilevel result. If False, only the best level (corresponding to the best modularity) is returned.",
                        "resolution": "the  parameter to use in the modularity measure. Smaller values result in a smaller number of larger clusters, while higher values yield a large number of small clusters. The classical modularity measure assumes a  parameter of 1."
                    },
                    "Return": [
                        "either a single list describing the community membership of each vertex (if return_levels is False), or a list of community membership vectors, one corresponding to each level and a list of corresponding modularities (if return_levels is True)."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "modularity()",
                    "example": []
                },
                "community_optimal_modularity": {
                    "Description": "overridden in igraph.Graph\nCalculates the optimal modularity score of the graph and the corresponding community structure.\nThis function uses the GNU Linear Programming Kit to solve a large integer optimization problem in order to find the optimal modularity score and the corresponding community structure, therefore it is unlikely to work for graphs larger than a few (less than a hundred) vertices. Consider using one of the heuristic approaches instead if you have such a large graph.",
                    "Paramters": {
                        "weights": "name of an edge attribute or a list containing edge ."
                    },
                    "Return": [
                        "the calculated membership vector and the corresponding modularity in a tuple."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "community_spinglass": {
                    "Description": "overridden in igraph.Graph\nFinds the community structure of the graph according to the spinglass community detection method of Reichardt & Bornholdt.",
                    "Paramters": {
                        "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name.",
                        "spins": "integer, the number of  to use. This is the upper limit for the number of communities. It is not a problem to supply a (reasonably) big number here, in which case some spin states will be unpopulated.",
                        "parupdate": "whether to update the spins of the vertices in parallel (synchronously) or not",
                        "start_temp": "the starting temperature",
                        "stop_temp": "the stop temperature",
                        "cool_fact": "cooling factor for the simulated annealing",
                        "update_rule": "specifies the null model of the simulation. Possible values are \"config\" (a random graph with the same vertex degrees as the input graph) or \"simple\" (a random graph with the same number of edges)",
                        "gamma": "the  argument of the algorithm, specifying the balance between the importance of present and missing edges within a community. The default value of 1.0 assigns equal importance to both of them.",
                        "implementation": "currently igraph contains two s for the spinglass community detection algorithm. The faster original  is the default. The other  is able to take into account negative weights, this can be chosen by setting  to \"neg\".",
                        "lambda_": "the lambda argument of the algorithm, which specifies the balance between the importance of present and missing negatively weighted edges within a community. Smaller values of lambda lead to communities with less negative intra-connectivity. If the argument is zero, the algorithm reduces to a graph coloring algorithm, using the number of spins as colors. This argument is ignored if the original implementation is used."
                    },
                    "Return": [
                        "the community membership vector."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "community_walktrap": {
                    "Description": "overridden in igraph.Graph\nFinds the community structure of the graph according to the random walk method of Latapy & Pons.\nThe basic idea of the algorithm is that short random walks tend to stay in the same community. The method provides a dendrogram.\nAttention: this function is wrapped in a more convenient syntax in the derived class Graph. It is advised to use that instead of this version.\nReference: Pascal Pons, Matthieu Latapy: Computing communities in large networks using random walks, http://arxiv.org/abs/physics/0512106.",
                    "Paramters": {
                        "weights": "name of an edge attribute or a list containing edge ",
                        "steps": "Undocumented"
                    },
                    "Return": [
                        "a tuple with the list of merges and the modularity scores corresponding to each merge"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "modularity()",
                    "example": []
                },
                "complementer": {
                    "Description": "Returns the complementer of the graph",
                    "Paramters": {
                        "loops": "whether to include loop edges in the complementer."
                    },
                    "Return": [
                        "the complementer of the graph"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "compose": {
                    "Description": "Returns the composition of two graphs.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "connected_components": {
                    "Description": "overridden in igraph.Graph\nCalculates the (strong or weak) connected components for a given graph.\nAttention: this function has a more convenient interface in class Graph, which wraps the result in a VertexClustering object. It is advised to use that.",
                    "Paramters": {
                        "mode": "must be either \"strong\" or \"weak\", depending on the clusters being sought. Optional, defaults to \"strong\"."
                    },
                    "Return": [
                        "the component index for every node in the graph."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "constraint": {
                    "Description": "Calculates Burt's constraint scores for given vertices in a graph.\nBurt's constraint is higher if ego has less, or mutually stronger related (i.e. more redundant) contacts. Burt's measure of constraint, C[i], of vertex i's ego network V[i], is defined for directed and valued graphs as follows:\nC[i] = sum( sum( (p[i,q] p[q,j])^2, q in V[i], q != i,j ), j in V[], j != i)\nfor a graph of order (ie. number od vertices) N, where proportional tie strengths are defined as follows:\np[i,j]=(a[i,j]+a[j,i]) / sum(a[i,k]+a[k,i], k in V[i], k != i), a[i,j] are elements of A and the latter being the graph adjacency matrix.\nFor isolated vertices, constraint is undefined.",
                    "Paramters": {
                        "vertices": "the  to be analysed or None for all .",
                        "weights": " associated to the edges. Can be an attribute name as well. If None, every edge will have the same weight."
                    },
                    "Return": [
                        "constraint scores for all given vertices in a matrix."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "contract_vertices": {
                    "Description": "Contracts some vertices in the graph, i.e. replaces groups of vertices with single vertices. Edges are not affected.",
                    "Paramters": {
                        "mapping": "numeric vector which gives the  between old and new vertex IDs. Vertices having the same new vertex ID in this vector will be remapped into a single new vertex. It is safe to pass the membership vector of a VertexClustering object here.",
                        "combine_attrs": "specifies how to combine the attributes of the vertices being collapsed into a single one. If it is None, all the attributes will be lost. If it is a function, the attributes of the vertices will be collected and passed on to that function which will return the new attribute value that has to be assigned to the single collapsed vertex. It can also be one of the following string constants which define built-in collapsing functions: sum, prod, mean, median, max, min, first, last, random. You can also specify different combination functions for different attributes by passing a dict here which maps attribute names to functions. See simplify() for more details."
                    },
                    "Return": [
                        "None."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "simplify()",
                    "example": []
                },
                "convergence_degree": {
                    "Description": "Undocumented (yet).",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "convergence_field_size": {
                    "Description": "Undocumented (yet).",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "copy": {
                    "Description": "Creates a copy of the graph.\nAttributes are copied by reference; in other words, if you use mutable Python objects as attribute values, these objects will still be shared between the old and new graph. You can use `deepcopy()` from the `copy` module if you need a truly deep copy of the graph.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "coreness": {
                    "Description": "Finds the coreness (shell index) of the vertices of the network.\nThe k-core of a graph is a maximal subgraph in which each vertex has at least degree k. (Degree here means the degree in the subgraph of course). The coreness of a vertex is k if it is a member of the k-core but not a member of the k\u2009+\u20091-core.\nReference: Vladimir Batagelj, Matjaz Zaversnik: An O(m) Algorithm for Core Decomposition of Networks.",
                    "Paramters": {
                        "mode": "whether to compute the in-corenesses (\"in\"), the out-corenesses (\"out\") or the undirected corenesses (\"all\"). Ignored and assumed to be \"all\" for undirected graphs."
                    },
                    "Return": [
                        "the corenesses for each vertex."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "count_automorphisms": {
                    "Description": "Calculates the number of automorphisms of a graph using the BLISS isomorphism algorithm.\nSee http://www.tcs.hut.fi/Software/bliss/index.html for more information about the BLISS algorithm and canonical permutations.",
                    "Paramters": {
                        "sh": "splitting heuristics for graph as a case-insensitive string, with the following possible values:\"f\": first non-singleton cell\"fl\": first largest non-singleton cell\"fs\": first smallest non-singleton cell\"fm\": first maximally non-trivially connected non-singleton cell\"flm\": largest maximally non-trivially connected non-singleton cell\"fsm\": smallest maximally non-trivially connected non-singleton cell",
                        "color": "optional vector storing a ing of the vertices with respect to which the isomorphism is computed.  If None, all vertices have the same ."
                    },
                    "Return": [
                        "the number of automorphisms of the graph."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "count_isomorphisms_vf2": {
                    "Description": "Determines the number of isomorphisms between the graph and another one\nVertex and edge colors may be used to restrict the isomorphisms, as only vertices and edges with the same color will be allowed to match each other.",
                    "Paramters": {
                        "other": "the  graph. If None, the number of automorphisms will be returned.",
                        "color1": "optional vector storing the coloring of the vertices of the first graph. If None, all vertices have the same color.",
                        "color2": "optional vector storing the coloring of the vertices of the second graph. If None, all vertices have the same color.",
                        "edge_color1": "optional vector storing the coloring of the edges of the first graph. If None, all edges have the same color.",
                        "edge_color2": "optional vector storing the coloring of the edges of the second graph. If None, all edges have the same color.",
                        "node_compat_fn": "a function that receives the two graphs and two node indices (one from the first graph, one from the second graph) and returns True if the nodes given by the two indices are compatible (i.e. they could be matched to each other) or False otherwise. This can be used to restrict the set of isomorphisms based on node-specific criteria that are too complicated to be represented by node color vectors (i.e. the color1 and color2 parameters). None means that every node is compatible with every other node.",
                        "edge_compat_fn": "a function that receives the two graphs and two edge indices (one from the first graph, one from the second graph) and returns True if the edges given by the two indices are compatible (i.e. they could be matched to each other) or False otherwise. This can be used to restrict the set of isomorphisms based on edge-specific criteria that are too complicated to be represented by edge color vectors (i.e. the edge_color1 and edge_color2 parameters). None means that every edge is compatible with every other node."
                    },
                    "Return": [
                        "the number of isomorphisms between the two given graphs (or the number of automorphisms if other is None."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "count_multiple": {
                    "Description": "Counts the multiplicities of the given edges.",
                    "Paramters": {
                        "edges": "edge indices for which we want to count their multiplicity. If None, all  are counted."
                    },
                    "Return": [
                        "the multiplicities of the given edges as a list."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "count_subisomorphisms_vf2": {
                    "Description": "Determines the number of subisomorphisms between the graph and another one\nVertex and edge colors may be used to restrict the isomorphisms, as only vertices and edges with the same color will be allowed to match each other.",
                    "Paramters": {
                        "other": "the  graph.",
                        "color1": "optional vector storing the coloring of the vertices of the first graph. If None, all vertices have the same color.",
                        "color2": "optional vector storing the coloring of the vertices of the second graph. If None, all vertices have the same color.",
                        "edge_color1": "optional vector storing the coloring of the edges of the first graph. If None, all edges have the same color.",
                        "edge_color2": "optional vector storing the coloring of the edges of the second graph. If None, all edges have the same color.",
                        "node_compat_fn": "a function that receives the two graphs and two node indices (one from the first graph, one from the second graph) and returns True if the nodes given by the two indices are compatible (i.e. they could be matched to each other) or False otherwise. This can be used to restrict the set of isomorphisms based on node-specific criteria that are too complicated to be represented by node color vectors (i.e. the color1 and color2 parameters). None means that every node is compatible with every other node.",
                        "edge_compat_fn": "a function that receives the two graphs and two edge indices (one from the first graph, one from the second graph) and returns True if the edges given by the two indices are compatible (i.e. they could be matched to each other) or False otherwise. This can be used to restrict the set of isomorphisms based on edge-specific criteria that are too complicated to be represented by edge color vectors (i.e. the edge_color1 and edge_color2 parameters). None means that every edge is compatible with every other node."
                    },
                    "Return": [
                        "the number of subisomorphisms between the two given graphs"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "De_Bruijn": {
                    "Description": "Generates a de Bruijn graph with parameters (m, n)\nA de Bruijn graph represents relationships between strings. An alphabet of m letters are used and strings of length n are considered. A vertex corresponds to every possible string and there is a directed edge from vertex v to vertex w if the string of v can be transformed into the string of w by removing its first letter and appending a letter to it.\nPlease note that the graph will have mn vertices and even more edges, so probably you don't want to supply too big numbers for m and n.",
                    "Paramters": {
                        "m": "the size of the alphabet",
                        "n": "the legth of the strigs"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "decompose": {
                    "Description": "Decomposes the graph into subgraphs.",
                    "Paramters": {
                        "mode": "must be either \"strong\" or \"weak\", depending on the clusters being sought. Optional, defaults to \"strong\".",
                        "maxcompno": "maximum number of components to return. None means all possible components.",
                        "minelements": "minimum number of vertices in a component. By setting this to 2, isolated vertices are not returned as separate components."
                    },
                    "Return": [
                        "a list of the subgraphs. Every returned subgraph is a copy of the original."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "degree": {
                    "Description": "Returns some vertex degrees from the graph.\nThis method accepts a single vertex ID or a list of vertex IDs as a parameter, and returns the degree of the given vertices (in the form of a single integer or a list, depending on the input parameter).",
                    "Paramters": {
                        "vertices": "a single vertex ID or a list of vertex IDs",
                        "mode": "the type of degree to be returned (\"out\" for out-degrees, \"in\" for in-degrees or \"all\" for the sum of them).",
                        "loops": "whether self- should be counted."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Degree_Sequence": {
                    "Description": "Generates a graph with a given degree sequence.",
                    "Paramters": {
                        "out": "the -degree sequence for a directed graph. If the in-degree sequence is omitted, the generated graph will be undirected, so this will be the in-degree sequence as well",
                        "in_": "the in-degree sequence for a directed graph. If omitted, the generated graph will be undirected.",
                        "method": "the generation  to be used. One of the following:\"configuration\" -- simple generator that implements the stub-matching configuration model. It may generate self-loops and multiple edges. This  does not sample multigraphs uniformly, but it can be used to implement uniform sampling for simple graphs by rejecting any result that is non-simple (i.e. contains loops or multi-edges).\"fast_heur_simple\" -- similar to \"configuration\" but avoids the generation of multiple and loop edges at the expense of increased time complexity. The  will re-start the generation every time it gets stuck in a configuration where it is not possible to insert any more edges without creating loops or multiple edges, and there is no upper bound on the number of iterations, but it will succeed eventually if the input degree sequence is graphical and throw an exception if the input degree sequence is not graphical. This  does not sample simple graphs uniformly.\"configuration_simple\" -- similar to \"configuration\" but rejects generated graphs if they are not simple. This  samples simple graphs uniformly.\"edge_switching_simple\" -- an MCMC sampler based on degree-preserving edge switches. It generates simple undirected or directed graphs. The algorithm uses Graph.Realize_Degree_Sequence() to construct an initial graph, then rewires it using Graph.rewire().\"vl\" -- a more sophisticated generator that can sample undirected, connected simple graphs approximately uniformly. It uses edge-switching Monte-Carlo s to randomize the graphs. This generator should be favoured if undirected and connected graphs are to be generated and execution time is not a concern. igraph uses the original implementation of Fabien Viger; see the following URL and the paper cited on it for the details of the algorithm: https://www-complexnetworks.lip6.fr/~latapy/FV/generation.html."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "delete_edges": {
                    "Description": "overridden in igraph.Graph\nRemoves edges from the graph.\nAll vertices will be kept, even if they lose all their edges. Nonexistent edges will be silently ignored.",
                    "Paramters": {
                        "es": "the list of edg to be removed. Edg are identifed by edge IDs. EdgeSeq objects are also accepted here. No argument delet all edg."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "delete_vertices": {
                    "Description": "Deletes vertices and all its edges from the graph.",
                    "Paramters": {
                        "vs": "a single vertex ID or the list of vertex IDs to be deleted. No argument deletes all vertices."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "density": {
                    "Description": "Calculates the density of the graph.",
                    "Paramters": {
                        "loops": "whether to take  into consideration. If True, the algorithm assumes that there might be some  in the graph and calculates the density accordingly. If False, the algorithm assumes that there can't be any ."
                    },
                    "Return": [
                        "the density of the graph."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "dfsiter": {
                    "Description": "Constructs a depth first search (DFS) iterator of the graph.",
                    "Paramters": {
                        "vid": "the root vertex ID",
                        "mode": "either \"in\" or \"out\" or \"all\".",
                        "advanced": "if False, the iterator returns the next vertex in DFS order in every step. If True, the iterator returns the distance of the vertex from the root and the parent of the vertex in the DFS tree as well."
                    },
                    "Return": [
                        "the DFS iterator as an igraph.DFSIter object."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "diameter": {
                    "Description": "Calculates the diameter of the graph.",
                    "Paramters": {
                        "directed": "whether to consider  paths.",
                        "unconn": "if True and the graph is ected, the longest geodesic within a component will be returned. If False and the graph is ected, the result is the number of vertices if there are no weights or infinity if there are weights.",
                        "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name."
                    },
                    "Return": [
                        "the diameter"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "difference": {
                    "Description": "Subtracts the given graph from the original",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "distances": {
                    "Description": "Calculates shortest path lengths for given vertices in a graph.\nThe algorithm used for the calculations is selected automatically: a simple BFS is used for unweighted graphs, Dijkstra's algorithm is used when all the weights are non-negative. Otherwise, the Bellman-Ford algorithm is used if the number of requested source vertices is smaller than 100 and Johnson's algorithm is used otherwise.",
                    "Paramters": {
                        "source": "a list containing the  vertex IDs which should be included in the result. If None, all vertices will be considered.",
                        "target": "a list containing the  vertex IDs which should be included in the result. If None, all vertices will be considered.",
                        "weights": "a list containing the edge . It can also be an attribute name (edge  are retrieved from the given attribute) or None (all edges have equal weight).",
                        "mode": "the type of shortest paths to be used for the calculation in directed graphs. \"out\" means only outgoing, \"in\" means only incoming paths. \"all\" means to consider the directed graph as an undirected one.",
                        "algorithm": "the shortest path  to use. \"auto\" selects an  automatically based on whether the graph has negative weights or not. \"dijkstra\" uses Dijkstra's . \"bellman_ford\" uses the Bellman-Ford . \"johnson\" uses Johnson's . Ignored for unweighted graphs."
                    },
                    "Return": [
                        "the shortest path lengths for given vertices in a matrix"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "diversity": {
                    "Description": "Calculates the structural diversity index of the vertices.\nThe structural diversity index of a vertex is simply the (normalized) Shannon entropy of the weights of the edges incident on the vertex.\nThe measure is defined for undirected graphs only; edge directions are ignored.\nReference: Eagle N, Macy M and Claxton R: Network diversity and economic development, Science 328, 1029-1031, 2010.",
                    "Paramters": {
                        "vertices": "the  for which the diversity indices must be returned. If None, uses all of the  in the graph.",
                        "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name."
                    },
                    "Return": [
                        "the calculated diversity indices in a list, or a single number if a single vertex was supplied."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "dominator": {
                    "Description": "Returns the dominator tree from the given root node",
                    "Paramters": {
                        "vid": "the root vertex ID",
                        "mode": "either \"in\" or \"out\""
                    },
                    "Return": [
                        "a list containing the dominator tree for the current graph."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "dyad_census": {
                    "Description": "overridden in igraph.Graph\nDyad census, as defined by Holland and Leinhardt\nDyad census means classifying each pair of vertices of a directed graph into three categories: mutual, there is an edge from a to b and also from b to a; asymmetric, there is an edge either from a to b or from b to a but not the other way and null, no edges between a and b.\nAttention: this function has a more convenient interface in class Graph, which wraps the result in a DyadCensus object. It is advised to use that.",
                    "Paramters": {},
                    "Return": [
                        "the number of mutual, asymmetric and null connections in a 3-tuple."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "eccentricity": {
                    "Description": "Calculates the eccentricities of given vertices in a graph.\nThe eccentricity of a vertex is calculated by measuring the shortest distance from (or to) the vertex, to (or from) all other vertices in the graph, and taking the maximum.",
                    "Paramters": {
                        "vertices": "the  for which the eccentricity scores must be returned. If None, uses all of the  in the graph.",
                        "mode": "must be one of \"in\", \"out\" and \"all\". \"in\" means that edge directions are followed; \"out\" means that edge directions are followed the opposite direction; \"all\" means that directions are ignored. The argument has no effect for undirected graphs.",
                        "weights": "a list containing the edge . It can also be an attribute name (edge  are retrieved from the given attribute) or None (all edges have equal weight)."
                    },
                    "Return": [
                        "the calculated eccentricities in a list, or a single number if a single vertex was supplied."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "ecount": {
                    "Description": "Counts the number of edges.",
                    "Paramters": {},
                    "Return": [
                        "integerthe number of edges in the graph."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "edge_attributes": {
                    "Description": "",
                    "Paramters": {},
                    "Return": [
                        "the attribute name list of the edges of the graph"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "edge_betweenness": {
                    "Description": "Calculates or estimates the edge betweennesses in a graph.\nAlso supports calculating edge betweenness with shortest path length cutoffs or considering shortest paths only from certain source vertices or to certain target vertices.",
                    "Paramters": {
                        "directed": "whether to consider  paths.",
                        "cutoff": "if it is an integer, only paths less than or equal to this length are considered, effectively resulting in an estimation of the betweenness values. If None, the exact betweennesses are returned.",
                        "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name.",
                        "sources": "the set of source vertices to consider when calculating shortest paths.",
                        "targets": "the set of target vertices to consider when calculating shortest paths."
                    },
                    "Return": [
                        "a list with the (exact or estimated) edge betweennesses of all edges."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "edge_connectivity": {
                    "Description": "Calculates the edge connectivity of the graph or between some vertices.\nThe edge connectivity between two given vertices is the number of edges that have to be removed in order to disconnect the two vertices into two separate components. This is also the number of edge disjoint directed paths between the vertices. The edge connectivity of the graph is the minimal edge connectivity over all vertex pairs.\nThis method calculates the edge connectivity of a given vertex pair if both the source and target vertices are given. If none of them is given (or they are both negative), the overall edge connectivity is returned.",
                    "Paramters": {
                        "source": "the  vertex involved in the calculation.",
                        "target": "the  vertex involved in the calculation.",
                        "checks": "if the whole graph connectivity is calculated and this is True, igraph performs some basic  before calculation. If the graph is not strongly connected, then the connectivity is obviously zero. If the minimum degree is one, then the connectivity is also one. These simple  are much faster than checking the entire graph, therefore it is advised to set this to True. The parameter is ignored if the connectivity between two given vertices is computed."
                    },
                    "Return": [
                        "the edge connectivity"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "eigen_adjacency": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "eigenvector_centrality": {
                    "Description": "Calculates the eigenvector centralities of the vertices in a graph.\nEigenvector centrality is a measure of the importance of a node in a network. It assigns relative scores to all nodes in the network based on the principle that connections from high-scoring nodes contribute more to the score of the node in question than equal connections from low-scoring nodes. In practice, the centralities are determined by calculating eigenvector corresponding to the largest positive eigenvalue of the adjacency matrix. In the undirected case, this function considers the diagonal entries of the adjacency matrix to be twice the number of self-loops on the corresponding vertex.\nIn the directed case, the left eigenvector of the adjacency matrix is calculated. In other words, the centrality of a vertex is proportional to the sum of centralities of vertices pointing to it.\nEigenvector centrality is meaningful only for connected graphs. Graphs that are not connected should be decomposed into connected components, and the eigenvector centrality calculated for each separately.",
                    "Paramters": {
                        "directed": "whether to consider edge directions in a  graph. Ignored for un graphs.",
                        "scale": "whether to normalize the centralities so the largest one will always be 1.",
                        "weights": "edge  given as a list or an edge attribute. If None, all edges have equal weight.",
                        "return_eigenvalue": "whether to return the actual largest eigenvalue along with the centralities",
                        "arpack_options": "an ARPACKOptions object that can be used to fine-tune the calculation. If it is omitted, the module-level variable called  is used."
                    },
                    "Return": [
                        "the eigenvector centralities in a list and optionally the largest eigenvalue (as a second member of a tuple)"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Erdos_Renyi": {
                    "Description": "Generates a graph based on the Erd\u0151s-R\u00e9nyi model.",
                    "Paramters": {
                        "n": "the umber of vertices.",
                        "p": "the robability of edges. If given, m must be missing.",
                        "m": "the nuber of edges. If given, p ust be issing.",
                        "directed": "whether to generate a  graph.",
                        "loops": "whether self- are allowed."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Establishment": {
                    "Description": "Generates a graph based on a simple growing model with vertex types.\nA single vertex is added at each time step. This new vertex tries to connect to k vertices in the graph. The probability that such a connection is realized depends on the types of the vertices involved.",
                    "Paramters": {
                        "n": "the umber of vertices i the graph",
                        "k": "the number of connections tried in each step",
                        "type_dist": "list giving the distribution of vertex types",
                        "pref_matrix": "matrix (list of lists) giving the connection probabilities for different vertex types",
                        "directed": "whether to generate a  graph."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Famous": {
                    "Description": "Generates a famous graph based on its name.\nSeveral famous graphs are known to igraph including (but not limited to) the Chvatal graph, the Petersen graph or the Tutte graph. This method generates one of them based on its name (case insensitive). See the documentation of the C interface of igraph for the names available: https://igraph.org/c/doc.",
                    "Paramters": {
                        "name": "the  of the graph to be generated."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "farthest_points": {
                    "Description": "Returns two vertex IDs whose distance equals the actual diameter of the graph.\nIf there are many shortest paths with the length of the diameter, it returns the first one it found.",
                    "Paramters": {
                        "directed": "whether to consider  paths.",
                        "unconn": "if True and the graph is ected, the longest geodesic within a component will be returned. If False and the graph is ected, the result contains the number of vertices if there are no weights or infinity if there are weights.",
                        "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name."
                    },
                    "Return": [
                        "a triplet containing the two vertex IDs and their distance. The IDs are None if the graph is unconnected and unconn is False."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "feedback_arc_set": {
                    "Description": "Calculates an approximately or exactly minimal feedback arc set.\nA feedback arc set is a set of edges whose removal makes the graph acyclic. Since this is always possible by removing all the edges, we are in general interested in removing the smallest possible number of edges, or an edge set with as small total weight as possible. This method calculates one such edge set. Note that the task is trivial for an undirected graph as it is enough to find a spanning tree and then remove all the edges not in the spanning tree. Of course it is more complicated for directed graphs.\nReference: Eades P, Lin X and Smyth WF: A fast and effective heuristic for the feedback arc set problem. In: Proc Inf Process Lett 319-323, 1993.",
                    "Paramters": {
                        "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name. When given, the algorithm will strive to remove lightweight edges in order to minimize the total weight of the feedback arc set.",
                        "method": "the algorithm to use. \"eades\" uses the greedy cycle breaking heuristic of Eades, Lin and Smyth, which is linear in the number of edges but not necessarily optimal; however, it guarantees that the number of edges to be removed is smaller than |E|/2 - |V|/6. \"ip\" uses an integer programming formulation which is guaranteed to yield an optimal result, but is too slow for large graphs."
                    },
                    "Return": [
                        "the IDs of the edges to be removed, in a list."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Forest_Fire": {
                    "Description": "Generates a graph based on the forest fire model\nThe forest fire model is a growing graph model. In every time step, a new vertex is added to the graph. The new vertex chooses an ambassador (or more than one if ambs\u2009>\u20091) and starts a simulated forest fire at its ambassador(s). The fire spreads through the edges. The spreading probability along an edge is given by fwprob. The fire may also spread backwards on an edge by probability fwprob*bwfactor. When the fire ended, the newly added vertex connects to the vertices ``burned'' in the previous fire.",
                    "Paramters": {
                        "n": "the umber of vertices i the graph",
                        "fw_prob": "forward burning probability",
                        "bw_factor": "ratio of backward and forward burning probability",
                        "ambs": "number of ambassadors chosen in each step",
                        "directed": "whether the graph will be "
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Full": {
                    "Description": "Generates a full graph (directed or undirected, with or without loops).",
                    "Paramters": {
                        "n": "the umber of vertices.",
                        "directed": "whether to generate a  graph.",
                        "loops": "whether self- are allowed."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Full_Citation": {
                    "Description": "Generates a full citation graph\nA full citation graph is a graph where the vertices are indexed from 0 to n\u2009\u2212\u20091 and vertex i has a directed edge towards all vertices with an index less than i.",
                    "Paramters": {
                        "n": "the umber of vertices.",
                        "directed": "whether to generate a  graph."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "fundamental_cycles": {
                    "Description": "Finds a single fundamental cycle basis of the graph",
                    "Paramters": {
                        "start_vid": "when None or negative, a complete fundamental cycle basis is returned. When it is a vertex or a vertex ID, the fundamental cycles associated with the BFS tree rooted in that vertex will be returned, only for the weakly connected component containing that vertex",
                        "cutoff": "when None or negative, a complete cycle basis is returned. Otherwise the BFS is stopped after this many steps, so the result will effectively include cycles of length 2*\u2009+\u20091 or shorter only."
                    },
                    "Return": [
                        "the cycle basis as a list of tuples containing edge IDs"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_adjacency": {
                    "Description": "overridden in igraph.Graph\nReturns the adjacency matrix of a graph.",
                    "Paramters": {
                        "type": "one of \"lower\" (uses the lower triangle of the matrix), \"upper\" (uses the upper triangle) or \"both\" (uses both parts). Ignored for directed graphs.",
                        "loops": "specifies how loop edges should be handled. False or \"ignore\" ignores loop edges. \"once\" counts each loop edge once in the diagonal. \"twice\" counts each loop edge twice (i.e. it counts the endpoints of the loop edges, not the edges themselves)."
                    },
                    "Return": [
                        "the adjacency matrix."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_all_shortest_paths": {
                    "Description": "Calculates all of the shortest paths from/to a given node in a graph.",
                    "Paramters": {
                        "v": "the source for the calculated paths",
                        "to": "a vertex selecr describing the destination for the calculated paths. This can be a single vertex ID, a list of vertex IDs, a single vertex name, a list of vertex names or a VertexSeq object. None means all the vertices.",
                        "weights": "edge  in a list or the name of an edge attribute holding edge . If None, all edges are assumed to have equal weight.",
                        "mode": "the directionality of the paths. \"in\" means to calculate incoming paths, \"out\" means to calculate outgoing paths, \"all\" means to calculate both ones."
                    },
                    "Return": [
                        "all of the shortest path from the given node to every other reachable node in the graph in a list. Note that in case of mode=\"in\", the vertices in a path are returned in reversed order!"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_biadjacency": {
                    "Description": "overridden in igraph.Graph\nInternal function, undocumented.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "Graph.get_biadjacency()",
                    "example": []
                },
                "get_diameter": {
                    "Description": "Returns a path with the actual diameter of the graph.\nIf there are many shortest paths with the length of the diameter, it returns the first one it founds.",
                    "Paramters": {
                        "directed": "whether to consider  paths.",
                        "unconn": "if True and the graph is ected, the longest geodesic within a component will be returned. If False and the graph is ected, the result is the number of vertices if there are no weights or infinity if there are weights.",
                        "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name."
                    },
                    "Return": [
                        "the vertices in the path in order."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_edgelist": {
                    "Description": "Returns the edge list of a graph.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_eid": {
                    "Description": "Returns the edge ID of an arbitrary edge between vertices v1 and v2",
                    "Paramters": {
                        "v1": "the ID or name of the first vertex",
                        "v2": "the ID or name of the second vertex",
                        "directed": "whether edge directions should be considered in  graphs. The default is True. Ignored for un graphs.",
                        "error": "if True, an exception will be raised when the given edge does not exist. If False, -1 will be returned in that case."
                    },
                    "Return": [
                        "the edge ID of an arbitrary edge between vertices v1 and v2"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_eids": {
                    "Description": "Returns the edge IDs of some edges between some vertices.\nThe method does not consider multiple edges; if there are multiple edges between a pair of vertices, only the ID of one of the edges is returned.",
                    "Paramters": {
                        "pairs": "a list of integer . Each integer pair is considered as a source-target vertex pair; the corresponding edge is looked up in the graph and the edge ID is returned for each pair.",
                        "directed": "whether edge directions should be considered in  graphs. The default is True. Ignored for un graphs.",
                        "error": "if True, an exception will be raised if a given edge does not exist. If False, -1 will be returned in that case."
                    },
                    "Return": [
                        "the edge IDs in a list"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_isomorphisms_vf2": {
                    "Description": "Returns all isomorphisms between the graph and another one\nVertex and edge colors may be used to restrict the isomorphisms, as only vertices and edges with the same color will be allowed to match each other.",
                    "Paramters": {
                        "other": "the  graph. If None, the automorphisms will be returned.",
                        "color1": "optional vector storing the coloring of the vertices of the first graph. If None, all vertices have the same color.",
                        "color2": "optional vector storing the coloring of the vertices of the second graph. If None, all vertices have the same color.",
                        "edge_color1": "optional vector storing the coloring of the edges of the first graph. If None, all edges have the same color.",
                        "edge_color2": "optional vector storing the coloring of the edges of the second graph. If None, all edges have the same color.",
                        "node_compat_fn": "a function that receives the two graphs and two node indices (one from the first graph, one from the second graph) and returns True if the nodes given by the two indices are compatible (i.e. they could be matched to each other) or False otherwise. This can be used to restrict the set of isomorphisms based on node-specific criteria that are too complicated to be represented by node color vectors (i.e. the color1 and color2 parameters). None means that every node is compatible with every other node.",
                        "edge_compat_fn": "a function that receives the two graphs and two edge indices (one from the first graph, one from the second graph) and returns True if the edges given by the two indices are compatible (i.e. they could be matched to each other) or False otherwise. This can be used to restrict the set of isomorphisms based on edge-specific criteria that are too complicated to be represented by edge color vectors (i.e. the edge_color1 and edge_color2 parameters). None means that every edge is compatible with every other node."
                    },
                    "Return": [
                        "a list of lists, each item of the list containing the mapping from vertices of the second graph to the vertices of the first one"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_k_shortest_paths": {
                    "Description": "Calculates the k shortest paths from/to a given node in a graph.",
                    "Paramters": {
                        "v": "the ID or name of the ertex from which the paths are calculated.",
                        "to": "the ID or name of the vertex  which the paths are calculated.",
                        "k": "the desired number of shortest path",
                        "weights": "edge  in a list or the name of an edge attribute holding edge . If None, all edges are assumed to have equal weight.",
                        "mode": "the directionality of the paths. \"in\" means to calculate incoming paths, \"out\" means to calculate outgoing paths, \"all\" means to calculate both ones.",
                        "output": "determines what should be returned. If this is \"vpath\", a list of vertex IDs will be returned, one path for each target vertex. For unconnected graphs, some of the list elements may be empty. Note that in case of mode=\"in\", the vertices in a path are returned in reversed order. If =\"epath\", edge IDs are returned instead of vertex IDs."
                    },
                    "Return": [
                        "the k shortest paths from the given source node to the given target node in a list of vertex or edge IDs (depending on the value of the output argument). Note that in case of mode=\"in\", the vertices in a path are returned in reversed order!"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_shortest_path": {
                    "Description": "Calculates the shortest path from a source vertex to a target vertex in a graph.",
                    "Paramters": {
                        "v": "the source ertex of the path",
                        "to": "the target vertex of the path",
                        "weights": "edge  in a list or the name of an edge attribute holding edge . If None, all edges are assumed to have equal weight.",
                        "mode": "the directionality of the paths. \"out\" means to calculate paths from source to target, following edges according to their natural direction. \"in\" means to calculate paths from target to source, flipping the direction of each edge on-the-fly. \"all\" means to ignore edge directions.",
                        "output": "determines what should be returned. If this is \"vpath\", a list of vertex IDs will be returned. If this is \"epath\", edge IDs are returned instead of vertex IDs.",
                        "algorithm": "the shortest path  to use. \"auto\" selects an  automatically based on whether the graph has negative weights or not. \"dijkstra\" uses Dijkstra's . \"bellman_ford\" uses the Bellman-Ford . Ignored for unweighted graphs."
                    },
                    "Return": [
                        "see the documentation of the output parameter."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_shortest_path_astar": {
                    "Description": "Calculates the shortest path from a source vertex to a target vertex in a graph using the A-Star algorithm and a heuristic function.",
                    "Paramters": {
                        "v": "the source ertex of the path",
                        "to": "the target vertex of the path",
                        "heuristics": "a function that will be called with the graph and two vertices, and must return an estimate of the cost of the path from the first vertex to the second vertex. The A-Star algorithm is guaranteed to return an optimal solution if the heuristic is admissible, i.e. if it does never overestimate the cost of the shortest path from the given source vertex to the given target vertex.",
                        "weights": "edge  in a list or the name of an edge attribute holding edge . If None, all edges are assumed to have equal weight.",
                        "mode": "the directionality of the paths. \"out\" means to calculate paths from source to target, following edges according to their natural direction. \"in\" means to calculate paths from target to source, flipping the direction of each edge on-the-fly. \"all\" means to ignore edge directions.",
                        "output": "determines what should be returned. If this is \"vpath\", a list of vertex IDs will be returned. If this is \"epath\", edge IDs are returned instead of vertex IDs."
                    },
                    "Return": [
                        "see the documentation of the output parameter."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_shortest_paths": {
                    "Description": "Calculates the shortest paths from/to a given node in a graph.",
                    "Paramters": {
                        "v": "the source/destination for the calculated paths",
                        "to": "a vertex selecr describing the destination/source for the calculated paths. This can be a single vertex ID, a list of vertex IDs, a single vertex name, a list of vertex names or a VertexSeq object. None means all the vertices.",
                        "weights": "edge  in a list or the name of an edge attribute holding edge . If None, all edges are assumed to have equal weight.",
                        "mode": "the directionality of the paths. \"in\" means to calculate incoming paths, \"out\" means to calculate outgoing paths, \"all\" means to calculate both ones.",
                        "output": "determines what should be returned. If this is \"vpath\", a list of vertex IDs will be returned, one path for each target vertex. For unconnected graphs, some of the list elements may be empty. Note that in case of mode=\"in\", the vertices in a path are returned in reversed order. If =\"epath\", edge IDs are returned instead of vertex IDs.",
                        "algorithm": "the shortest path  to use. \"auto\" selects an  automatically based on whether the graph has negative weights or not. \"dijkstra\" uses Dijkstra's . \"bellman_ford\" uses the Bellman-Ford . Ignored for unweighted graphs."
                    },
                    "Return": [
                        "see the documentation of the output parameter."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_subisomorphisms_lad": {
                    "Description": "Returns all subisomorphisms between the graph and another one using the LAD algorithm.\nThe optional domains argument may be used to restrict vertices that may match each other. You can also specify whether you are interested in induced subgraphs only or not.",
                    "Paramters": {
                        "other": "the pattern graph we are looking for in the graph.",
                        "domains": "a list of lists, one sublist belonging to each vertex in the template graph. Sublist i contains the indices of the vertices in the original graph that may match vertex i in the template graph. None means that every vertex may match every other vertex.",
                        "induced": "whether to consider  subgraphs only.",
                        "time_limit": "an optimal time limit in seconds. Only the integral part of this number is taken into account. If the time limit is exceeded, the method will throw an exception."
                    },
                    "Return": [
                        "a list of lists, each item of the list containing the mapping from vertices of the second graph to the vertices of the first one"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_subisomorphisms_vf2": {
                    "Description": "Returns all subisomorphisms between the graph and another one\nVertex and edge colors may be used to restrict the isomorphisms, as only vertices and edges with the same color will be allowed to match each other.",
                    "Paramters": {
                        "other": "the  graph.",
                        "color1": "optional vector storing the coloring of the vertices of the first graph. If None, all vertices have the same color.",
                        "color2": "optional vector storing the coloring of the vertices of the second graph. If None, all vertices have the same color.",
                        "edge_color1": "optional vector storing the coloring of the edges of the first graph. If None, all edges have the same color.",
                        "edge_color2": "optional vector storing the coloring of the edges of the second graph. If None, all edges have the same color.",
                        "node_compat_fn": "a function that receives the two graphs and two node indices (one from the first graph, one from the second graph) and returns True if the nodes given by the two indices are compatible (i.e. they could be matched to each other) or False otherwise. This can be used to restrict the set of isomorphisms based on node-specific criteria that are too complicated to be represented by node color vectors (i.e. the color1 and color2 parameters). None means that every node is compatible with every other node.",
                        "edge_compat_fn": "a function that receives the two graphs and two edge indices (one from the first graph, one from the second graph) and returns True if the edges given by the two indices are compatible (i.e. they could be matched to each other) or False otherwise. This can be used to restrict the set of isomorphisms based on edge-specific criteria that are too complicated to be represented by edge color vectors (i.e. the edge_color1 and edge_color2 parameters). None means that every edge is compatible with every other node."
                    },
                    "Return": [
                        "a list of lists, each item of the list containing the mapping from vertices of the second graph to the vertices of the first one"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "girth": {
                    "Description": "Returns the girth of the graph.\nThe girth of a graph is the length of the shortest circle in it.",
                    "Paramters": {
                        "return_shortest_circle": "whether to return one of the shortest circles found in the graph."
                    },
                    "Return": [
                        "the length of the shortest circle or (if return_shortest_circle) is true, the shortest circle itself as a list"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "gomory_hu_tree": {
                    "Description": "overridden in igraph.Graph\nInternal function, undocumented.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "Graph.gomory_hu_tree()",
                    "example": []
                },
                "Growing_Random": {
                    "Description": "Generates a growing random graph.",
                    "Paramters": {
                        "n": "The umber of vertices i the graph",
                        "m": "The nuber of edges to add in each step (after adding a new vertex)",
                        "directed": "whether the graph should be .",
                        "citation": "whether the new edges should originate from the most recently added vertex."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "harmonic_centrality": {
                    "Description": "Calculates the harmonic centralities of given vertices in a graph.\nThe harmonic centrality of a vertex measures how easily other vertices can be reached from it (or the other way: how easily it can be reached from the other vertices). It is defined as the mean inverse distance to all other vertices.\nIf the graph is not connected, and there is no path between two vertices, the inverse distance is taken to be zero.",
                    "Paramters": {
                        "vertices": "the  for which the harmonic centrality must be returned. If None, uses all of the  in the graph.",
                        "mode": "must be one of \"in\", \"out\" and \"all\". \"in\" means that the length of the incoming paths, \"out\" means that the length of the outgoing paths must be calculated. \"all\" means that both of them must be calculated.",
                        "cutoff": "if it is not None, only paths less than or equal to this length are considered.",
                        "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name.",
                        "normalized": "Whether to normalize the result. If True, the result is the mean inverse path length to other vertices, i.e. it is  by the number of vertices minus one. If False, the result is the sum of inverse path lengths to other vertices."
                    },
                    "Return": [
                        "the calculated harmonic centralities in a list"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "has_multiple": {
                    "Description": "Checks whether the graph has multiple edges.",
                    "Paramters": {},
                    "Return": [
                        "booleanTrue if the graph has at least one multiple edge, False otherwise."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Hexagonal_Lattice": {
                    "Description": "Generates a regular hexagonal lattice.",
                    "Paramters": {
                        "dim": "list with the ensions of the lattice",
                        "directed": "whether to create a  graph.",
                        "mutual": "whether to create all connections as  in case of a directed graph."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "hub_score": {
                    "Description": "Calculates Kleinberg's hub score for the vertices of the graph",
                    "Paramters": {
                        "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name.",
                        "scale": "whether to normalize the scores so that the largest one is 1.",
                        "arpack_options": "an ARPACKOptions object used to fine-tune the ARPACK eigenvector calculation. If omitted, the module-level variable called  is used.",
                        "return_eigenvalue": "whether to return the largest eigenvalue"
                    },
                    "Return": [
                        "the hub scores in a list and optionally the largest eigenvalue as a second member of a tuple"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "authority_score()",
                    "example": []
                },
                "incident": {
                    "Description": "Returns the edges a given vertex is incident on.",
                    "Paramters": {
                        "vertex": "a  ID",
                        "mode": "whether to return only successors (\"out\"), predecessors (\"in\") or both (\"all\"). Ignored for undirected graphs."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "independence_number": {
                    "Description": "Returns the independence number of the graph.\nThe independence number of the graph is the size of the largest independent vertex set.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "largest_independent_vertex_sets() for the largest independent vertex sets",
                    "example": []
                },
                "independent_vertex_sets": {
                    "Description": "Returns some or all independent vertex sets of the graph as a list of tuples.\nTwo vertices are independent if there is no edge between them. Members of an independent vertex set are mutually independent.",
                    "Paramters": {
                        "min": "the imum size of sets to be returned. If zero or negative, no lower bound will be used.",
                        "max": "the imum size of sets to be returned. If zero or negative, no upper bound will be used."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "induced_subgraph": {
                    "Description": "Returns a subgraph spanned by the given vertices.",
                    "Paramters": {
                        "vertices": "a list containing the vertex IDs which should be included in the result.",
                        "implementation": "the  to use when constructing the new subgraph. igraph includes two s at the moment. \"copy_and_delete\" copies the original graph and removes those vertices that are not in the given set. This is more efficient if the size of the subgraph is comparable to the original graph. The other  (\"create_from_scratch\") constructs the result graph from scratch and then copies the attributes accordingly. This is a better solution if the subgraph is relatively small, compared to the original graph. \"auto\" selects between the two s automatically, based on the ratio of the size of the subgraph and the size of the original graph."
                    },
                    "Return": [
                        "the subgraph"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "is_acyclic": {
                    "Description": "Returns whether the graph is acyclic (i.e. contains no cycles).",
                    "Paramters": {},
                    "Return": [
                        "booleanTrue if the graph is acyclic, False otherwise."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "is_biconnected": {
                    "Description": "Decides whether the graph is biconnected.\nA graph is biconnected if it stays connected after the removal of any single vertex.\nNote that there are different conventions in use about whether to consider a graph consisting of two connected vertices to be biconnected. igraph does consider it biconnected.",
                    "Paramters": {},
                    "Return": [
                        "booleanTrue if it is biconnected, False otherwise."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "is_bipartite": {
                    "Description": "Decides whether the graph is bipartite or not.\nVertices of a bipartite graph can be partitioned into two groups A and B in a way that all edges go between the two groups.",
                    "Paramters": {
                        "return_types": "if False, the method will simply return True or False depending on whether the graph is bipartite or not. If True, the actual group assignments are also returned as a list of boolean values. (Note that the group assignment is not unique, especially if the graph consists of multiple components, since the assignments of components are independent from each other)."
                    },
                    "Return": [
                        "True if the graph is bipartite, False if not. If return_types is True, the group assignment is also returned."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "is_chordal": {
                    "Description": "Returns whether the graph is chordal or not.\nA graph is chordal if each of its cycles of four or more nodes has a chord, i.e. an edge joining two nodes that are not adjacent in the cycle. An equivalent definition is that any chordless cycles have at most three nodes.",
                    "Paramters": {
                        "alpha": "the  vector from the result of calling maximum_cardinality_search() on the graph. Useful only if you already have the  vector; simply passing None here will make igraph calculate the  vector on its own.",
                        "alpham1": "the inverse alpha vector from the result of calling maximum_cardinality_search() on the graph. Useful only if you already have the inverse alpha vector; simply passing None here will make igraph calculate the inverse alpha vector on its own."
                    },
                    "Return": [
                        "True if the graph is chordal, False otherwise."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "is_connected": {
                    "Description": "Decides whether the graph is connected.",
                    "Paramters": {
                        "mode": "whether we should calculate strong or weak connectivity."
                    },
                    "Return": [
                        "True if the graph is connected, False otherwise."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "is_dag": {
                    "Description": "Checks whether the graph is a DAG (directed acyclic graph).\nA DAG is a directed graph with no directed cycles.",
                    "Paramters": {},
                    "Return": [
                        "booleanTrue if it is a DAG, False otherwise."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "is_directed": {
                    "Description": "Checks whether the graph is directed.",
                    "Paramters": {},
                    "Return": [
                        "booleanTrue if it is directed, False otherwise."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "is_loop": {
                    "Description": "Checks whether a specific set of edges contain loop edges",
                    "Paramters": {
                        "edges": "edge indices which we want to check. If None, all  are checked."
                    },
                    "Return": [
                        "a list of booleans, one for every edge given"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "is_minimal_separator": {
                    "Description": "Decides whether the given vertex set is a minimal separator.\nA minimal separator is a set of vertices whose removal disconnects the graph, while the removal of any subset of the set keeps the graph connected.",
                    "Paramters": {
                        "vertices": "a single vertex ID or a list of vertex IDs"
                    },
                    "Return": [
                        "True is the given vertex set is a minimal separator, False otherwise."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "is_multiple": {
                    "Description": "Checks whether an edge is a multiple edge.\nAlso works for a set of edges -- in this case, every edge is checked one by one. Note that if there are multiple edges going between a pair of vertices, there is always one of them that is not reported as multiple (only the others). This allows one to easily detect the edges that have to be deleted in order to make the graph free of multiple edges.",
                    "Paramters": {
                        "edges": "edge indices which we want to check. If None, all  are checked."
                    },
                    "Return": [
                        "a list of booleans, one for every edge given"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "is_mutual": {
                    "Description": "Checks whether an edge has an opposite pair.\nAlso works for a set of edges -- in this case, every edge is checked one by one. The result will be a list of booleans (or a single boolean if only an edge index is supplied), every boolean corresponding to an edge in the edge set supplied. True is returned for a given edge a --> b if there exists another edge b --> a in the original graph (not the given edge set!). All edges in an undirected graph are mutual. In case there are multiple edges between a and b, it is enough to have at least one edge in either direction to report all edges between them as mutual, so the multiplicity of edges do not matter.",
                    "Paramters": {
                        "edges": "edge indices which we want to check. If None, all  are checked.",
                        "loops": "specifies whether loop edges should be treated as mutual in a directed graph."
                    },
                    "Return": [
                        "a list of booleans, one for every edge given"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "is_separator": {
                    "Description": "Decides whether the removal of the given vertices disconnects the graph.",
                    "Paramters": {
                        "vertices": "a single vertex ID or a list of vertex IDs"
                    },
                    "Return": [
                        "True is the given vertex set is a separator, False if not."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "is_simple": {
                    "Description": "Checks whether the graph is simple (no loop or multiple edges).",
                    "Paramters": {},
                    "Return": [
                        "booleanTrue if it is simple, False otherwise."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "is_tree": {
                    "Description": "Checks whether the graph is a (directed or undirected) tree graph.\nFor directed trees, the function may require that the edges are oriented outwards from the root or inwards to the root, depending on the value of the mode argument.",
                    "Paramters": {
                        "mode": "for directed graphs, specifies how the edge directions should be taken into account. \"all\" means that the edge directions must be ignored, \"out\" means that the edges must be oriented away from the root, \"in\" means that the edges must be oriented towards the root. Ignored for undirected graphs."
                    },
                    "Return": [
                        "booleanTrue if the graph is a tree, False otherwise."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Isoclass": {
                    "Description": "Generates a graph with a given isomorphism class.\nCurrently we support directed graphs of size 3 and 4, and undirected graphs of size 3, 4, 5 or 6. Use the isoclass() instance method to find the isomorphism class of a given graph.",
                    "Paramters": {
                        "n": "the umber of vertices i the graph",
                        "cls": "the isomorphism class",
                        "directed": "whether the graph should be ."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "isoclass": {
                    "Description": "Returns the isomorphism class of the graph or its subgraph.\nIsomorphism class calculations are implemented only for directed graphs with 3 or 4 vertices, or undirected graphs with 3, 4, 5 or 6 vertices..",
                    "Paramters": {
                        "vertices": "a list of  if we want to calculate the isomorphism class for only a subset of . None means to use the full graph."
                    },
                    "Return": [
                        "the isomorphism class of the (sub)graph"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "isomorphic": {
                    "Description": "Checks whether the graph is isomorphic to another graph.\nThe algorithm being used is selected using a simple heuristic:If one graph is directed and the other undirected, an exception is thrown.If the two graphs does not have the same number of vertices and edges, it returns with FalseIf the graphs have three or four vertices, then an O(1) algorithm is used with precomputed data.Otherwise if the graphs are directed, then the VF2 isomorphism algorithm is used (see isomorphic_vf2).Otherwise the BLISS isomorphism algorithm is used, see isomorphic_bliss.",
                    "Paramters": {},
                    "Return": [
                        "True if the graphs are isomorphic, False otherwise."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "isomorphic_bliss": {
                    "Description": "Checks whether the graph is isomorphic to another graph, using the BLISS isomorphism algorithm.\nSee http://www.tcs.hut.fi/Software/bliss/index.html for more information about the BLISS algorithm.",
                    "Paramters": {
                        "other": "the  graph with which we want to compare the graph.",
                        "return_mapping_12": "if True, calculates the mapping which maps the vertices of the first graph to the second.",
                        "return_mapping_21": "if True, calculates the mapping which maps the vertices of the second graph to the first.",
                        "sh1": "splitting heuristics for the first graph as a case-insensitive string, with the following possible values:\"f\": first non-singleton cell\"fl\": first largest non-singleton cell\"fs\": first smallest non-singleton cell\"fm\": first maximally non-trivially connected non-singleton cell\"flm\": largest maximally non-trivially connected non-singleton cell\"fsm\": smallest maximally non-trivially connected non-singleton cell",
                        "sh2": "splitting heuristics to be used for the second graph. This must be the same as sh1; alternatively, it can be None, in which case it will automatically use the same value as sh1. Currently it is present for backwards compatibility only.",
                        "color1": "optional vector storing the coloring of the vertices of the first graph. If None, all vertices have the same color.",
                        "color2": "optional vector storing the coloring of the vertices of the second graph. If None, all vertices have the same color."
                    },
                    "Return": [
                        "if no mapping is calculated, the result is True if the graphs are isomorphic, False otherwise. If any or both mappings are calculated, the result is a 3-tuple, the first element being the above mentioned boolean, the second element being the 1 -> 2 mapping and the third element being the 2 -> 1 mapping. If the corresponding mapping was not calculated, None is returned in the appropriate element of the 3-tuple."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "isomorphic_vf2": {
                    "Description": "Checks whether the graph is isomorphic to another graph, using the VF2 isomorphism algorithm.\nVertex and edge colors may be used to restrict the isomorphisms, as only vertices and edges with the same color will be allowed to match each other.",
                    "Paramters": {
                        "other": "the  graph with which we want to compare the graph. If None, the automorphjisms of the graph will be tested.",
                        "color1": "optional vector storing the coloring of the vertices of the first graph. If None, all vertices have the same color.",
                        "color2": "optional vector storing the coloring of the vertices of the second graph. If None, all vertices have the same color.",
                        "edge_color1": "optional vector storing the coloring of the edges of the first graph. If None, all edges have the same color.",
                        "edge_color2": "optional vector storing the coloring of the edges of the second graph. If None, all edges have the same color.",
                        "return_mapping_12": "if True, calculates the mapping which maps the vertices of the first graph to the second.",
                        "return_mapping_21": "if True, calculates the mapping which maps the vertices of the second graph to the first.",
                        "node_compat_fn": "a function that receives the two graphs and two node indices (one from the first graph, one from the second graph) and returns True if the nodes given by the two indices are compatible (i.e. they could be matched to each other) or False otherwise. This can be used to restrict the set of isomorphisms based on node-specific criteria that are too complicated to be represented by node color vectors (i.e. the color1 and color2 parameters). None means that every node is compatible with every other node.",
                        "edge_compat_fn": "a function that receives the two graphs and two edge indices (one from the first graph, one from the second graph) and returns True if the edges given by the two indices are compatible (i.e. they could be matched to each other) or False otherwise. This can be used to restrict the set of isomorphisms based on edge-specific criteria that are too complicated to be represented by edge color vectors (i.e. the edge_color1 and edge_color2 parameters). None means that every edge is compatible with every other node.",
                        "callback": "if not None, the isomorphism search will not stop at the first match; it will call this  function instead for every isomorphism found. The  function must accept four arguments: the first graph, the second graph, a mapping from the nodes of the first graph to the second, and a mapping from the nodes of the second graph to the first. The function must return True if the search should continue or False otherwise."
                    },
                    "Return": [
                        "if no mapping is calculated, the result is True if the graphs are isomorphic, False otherwise. If any or both mappings are calculated, the result is a 3-tuple, the first element being the above mentioned boolean, the second element being the 1 -> 2 mapping and the third element being the 2 -> 1 mapping. If the corresponding mapping was not calculated, None is returned in the appropriate element of the 3-tuple."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "K_Regular": {
                    "Description": "Generates a k-regular random graph\nA k-regular random graph is a random graph where each vertex has degree k. If the graph is directed, both the in-degree and the out-degree of each vertex will be k.",
                    "Paramters": {
                        "n": "The umber of vertices i the graph",
                        "k": "The degree of each vertex if the graph is undirected, or the in-degree and out-degree of each vertex if the graph is directed",
                        "directed": "whether the graph should be .",
                        "multiple": "whether it is allowed to create  edges."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Kautz": {
                    "Description": "Generates a Kautz graph with parameters (m, n)\nA Kautz graph is a labeled graph, vertices are labeled by strings of length n\u2009+\u20091 above an alphabet with m\u2009+\u20091 letters, with the restriction that every two consecutive letters in the string must be different. There is a directed edge from a vertex v to another vertex w if it is possible to transform the string of v into the string of w by removing the first letter and appending a letter to it.",
                    "Paramters": {
                        "m": "the size of the alphabet inus one",
                        "n": "the legth of the strigs mius oe"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "knn": {
                    "Description": "Calculates the average degree of the neighbors for each vertex, and the same quantity as the function of vertex degree.",
                    "Paramters": {
                        "vids": "the vertices for which the calculation is performed. None means all vertices.",
                        "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name. If this is given, the vertex strength will be used instead of the vertex degree in the calculations, but the \"ordinary\" vertex degree will be used for the second (degree- dependent) list in the result."
                    },
                    "Return": [
                        "two lists in a tuple. The first list contains the average degree of neighbors for each vertex, the second contains the average degree of neighbors as a function of vertex degree. The zeroth element of this list corresponds to vertices of degree 1."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "laplacian": {
                    "Description": "Returns the Laplacian matrix of a graph.\nThe Laplacian matrix is similar to the adjacency matrix, but the edges are denoted with -1 and the diagonal contains the node degrees.\nSymmetric normalized Laplacian matrices have 1 or 0 in their diagonals (0 for vertices with no edges), edges are denoted by 1 / sqrt(d_i * d_j) where d_i is the degree of node i.\nLeft-normalized and right-normalized Laplacian matrices are derived from the unnormalized Laplacian by scaling the row or the column sums to be equal to 1.",
                    "Paramters": {
                        "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name. When edge  are used, the degree of a node is considered to be the sum of the  of its incident edges.",
                        "normalized": "whether to return the  Laplacian matrix. False or \"un\" returns the un Laplacian matrix. True or \"symmetric\" returns the symmetric normalization of the Laplacian matrix. \"left\" returns the left-, \"right\" returns the right- Laplacian matrix.",
                        "mode": "for directed graphs, specifies whether to use out- or in-degrees in the Laplacian matrix. \"all\" means that the edge directions must be ignored, \"out\" means that the out-degrees should be used, \"in\" means that the in-degrees should be used. Ignored for undirected graphs."
                    },
                    "Return": [
                        "the Laplacian matrix."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "largest_cliques": {
                    "Description": "Returns the largest cliques of the graph as a list of tuples.\nQuite intuitively a clique is considered largest if there is no clique with more vertices in the whole graph. All largest cliques are maximal (i.e. nonextendable) but not all maximal cliques are largest.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "clique_number() for the size of the largest cliques or maximal_cliques() for the maximal cliques",
                    "example": []
                },
                "largest_independent_vertex_sets": {
                    "Description": "Returns the largest independent vertex sets of the graph as a list of tuples.\nQuite intuitively an independent vertex set is considered largest if there is no other set with more vertices in the whole graph. All largest sets are maximal (i.e. nonextendable) but not all maximal sets are largest.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "independence_number() for the size of the largest independent vertex sets or maximal_independent_vertex_sets() for the maximal (nonextendable) independent vertex sets",
                    "example": []
                },
                "Lattice": {
                    "Description": "Generates a regular square lattice.",
                    "Paramters": {
                        "dim": "list with the ensions of the lattice",
                        "nei": "value giving the distance (number of steps) within which two vertices will be connected.",
                        "directed": "whether to create a  graph.",
                        "mutual": "whether to create all connections as  in case of a directed graph.",
                        "circular": "whether the generated lattice is periodic. May also be an iterable; in this case, the iterator is assumed to yield booleans that specify whether the lattice is periodic along each dimension."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "layout_bipartite": {
                    "Description": "Place the vertices of a bipartite graph in two layers.\nThe layout is created by placing the vertices in two rows, according to their types. The positions of the vertices within the rows are then optimized to minimize the number of edge crossings using the heuristic used by the Sugiyama layout algorithm.",
                    "Paramters": {
                        "types": "an igraph vector containing the vertex , or an attribute name. Anything that evalulates to False corresponds to vertices of the first kind, everything else to the second kind.",
                        "hgap": "minimum horizontal gap between vertices in the same layer.",
                        "vgap": "vertical gap between the two layers.",
                        "maxiter": "maximum number of iterations to take in the crossing reduction step. Increase this if you feel that you are getting too many edge crossings."
                    },
                    "Return": [
                        "the calculated layout."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "layout_circle": {
                    "Description": "Places the vertices of the graph uniformly on a circle or a sphere.",
                    "Paramters": {
                        "dim": "the desired number of ensions for the layout. =2 means a 2D layout, =3 means a 3D layout.",
                        "order": "the  in which the vertices are placed along the circle. Not supported when dim is not equal to 2."
                    },
                    "Return": [
                        "the calculated layout."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "layout_davidson_harel": {
                    "Description": "Places the vertices on a 2D plane according to the Davidson-Harel layout algorithm.\nThe algorithm uses simulated annealing and a sophisticated energy function, which is unfortunately hard to parameterize for different graphs. The original publication did not disclose any parameter values, and the ones below were determined by experimentation.\nThe algorithm consists of two phases: an annealing phase and a fine-tuning phase. There is no simulated annealing in the second phase.",
                    "Paramters": {
                        "seed": "if None, uses a random starting layout for the algorithm. If a matrix (list of lists), uses the given matrix as the starting position.",
                        "maxiter": "Number of iterations to perform in the annealing phase.",
                        "fineiter": "Number of iterations to perform in the fine-tuning phase. Negative numbers set up a reasonable default from the base-2 logarithm of the vertex count, bounded by 10 from above.",
                        "cool_fact": "Cooling factor of the simulated annealing phase.",
                        "weight_node_dist": "Weight for the node-node distances in the energy function.",
                        "weight_border": "Weight for the distance from the border component of the energy function. Zero means that vertices are allowed to sit on the border of the area designated for the layout.",
                        "weight_edge_lengths": "Weight for the edge length component of the energy function. Negative numbers are replaced by the density of the graph divided by 10.",
                        "weight_edge_crossings": "Weight for the edge crossing component of the energy function. Negative numbers are replaced by one minus the square root of the density of the graph.",
                        "weight_node_edge_dist": "Weight for the node-edge distance component of the energy function. Negative numbers are replaced by 0.2 minus 0.2 times the density of the graph."
                    },
                    "Return": [
                        "the calculated layout."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "layout_drl": {
                    "Description": "Places the vertices on a 2D plane or in the 3D space ccording to the DrL layout algorithm.\nThis is an algorithm suitable for quite large graphs, but it can be surprisingly slow for small ones (where the simpler force-based layouts like layout_kamada_kawai() or layout_fruchterman_reingold() are more useful.",
                    "Paramters": {
                        "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name.",
                        "fixed": "ignored. We used to assume that the DrL layout supports  nodes, but later it turned out that the argument has no effect in the original DrL code. We kept the argument for sake of backwards compatibility, but it will have no effect on the final layout.",
                        "seed": "if None, uses a random starting layout for the algorithm. If a matrix (list of lists), uses the given matrix as the starting position.",
                        "options": "if you give a string argument here, you can select from five default preset parameterisations: default, coarsen for a coarser layout, coarsest for an even coarser layout, refine for refining an existing layout and final for finalizing a layout. If you supply an object that is not a string, the DrL layout parameters are retrieved from the respective keys of the object (so it should be a dict or something else that supports the mapping protocol). The following keys can be used:edge_cut: edge cutting is done in the late stages of the algorithm in order to achieve less dense layouts. Edges are cut if there is a lot of stress on them (a large value in the objective function sum). The edge cutting parameter is a value between 0 and 1 with 0 representing no edge cutting and 1 representing maximal edge cutting.init_iterations: number of iterations in the initialization phaseinit_temperature: start temperature during initializationinit_attraction: attraction during initializationinit_damping_mult: damping multiplier during initializationliquid_iterations, liquid_temperature, liquid_attraction, liquid_damping_mult: same parameters for the liquid phaseexpansion_iterations, expansion_temperature, expansion_attraction, expansion_damping_mult: parameters for the expansion phasecooldown_...: parameters for the cooldown phasecrunch_...: parameters for the crunch phasesimmer_...: parameters for the simmer phaseInstead of a mapping, you can also use an arbitrary Python object here: if the object does not support the mapping protocol, an attribute of the object with the same name is looked up instead. If a parameter cannot be found either as a key or an attribute, the default from the default preset will be used.",
                        "dim": "the desired number of ensions for the layout. =2 means a 2D layout, =3 means a 3D layout."
                    },
                    "Return": [
                        "the calculated layout."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "layout_fruchterman_reingold": {
                    "Description": "Places the vertices on a 2D plane according to the Fruchterman-Reingold algorithm.\nThis is a force directed layout, see Fruchterman, T. M. J. and Reingold, E. M.: Graph Drawing by Force-directed Placement. Software -- Practice and Experience, 21/11, 1129--1164, 1991",
                    "Paramters": {
                        "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name.",
                        "niter": "the number of iterations to perform. The default is 500.",
                        "seed": "if None, uses a random starting layout for the algorithm. If a matrix (list of lists), uses the given matrix as the starting position.",
                        "start_temp": "Real scalar, the start temperature. This is the maximum amount of movement alloved along one axis, within one step, for a vertex. Currently it is decreased linearly to zero during the iteration. The default is the square root of the number of vertices divided by 10.",
                        "minx": "if not None, it must be a vector with exactly as many elements as there are vertices in the graph. Each element is a minimum constraint on the X value of the vertex in the layout.",
                        "maxx": "similar to minx, but with maximum constraints",
                        "miny": "similar to minx, but with the Y coordinates",
                        "maxy": "similar to maxx, but with the Y coordinates",
                        "minz": "similar to minx, but with the Z coordinates. Use only for 3D layouts (dim=3).",
                        "maxz": "similar to maxx, but with the Z coordinates. Use only for 3D layouts (dim=3).",
                        "grid": "whether to use a faster, but less accurate -based implementation of the algorithm. \"auto\" decides based on the number of vertices in the graph; a  will be used if there are at least 1000 vertices. \"\" is equivalent to True, \"no\" is equivalent to False."
                    },
                    "Return": [
                        "the calculated layout."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "layout_graphopt": {
                    "Description": "This is a port of the graphopt layout algorithm by Michael Schmuhl. graphopt version 0.4.1 was rewritten in C and the support for layers was removed.\ngraphopt uses physical analogies for defining attracting and repelling forces among the vertices and then the physical system is simulated until it reaches an equilibrium or the maximal number of iterations is reached.\nSee http://www.schmuhl.org/graphopt/ for the original graphopt.",
                    "Paramters": {
                        "niter": "the number of iterations to perform. Should be a couple of hundred in general.",
                        "node_charge": "the charge of the vertices, used to calculate electric repulsion.",
                        "node_mass": "the mass of the vertices, used for the spring forces",
                        "spring_length": "the length of the springs",
                        "spring_constant": "the spring constant",
                        "max_sa_movement": "the maximum amount of movement allowed in a single step along a single axis.",
                        "seed": "a matrix containing a  layout from which the algorithm will be started. If None, a random layout will be used."
                    },
                    "Return": [
                        "the calculated layout."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "layout_grid": {
                    "Description": "Places the vertices of a graph in a 2D or 3D grid.",
                    "Paramters": {
                        "width": "the number of vertices in a single row of the layout. Zero or negative numbers mean that the  should be determined automatically.",
                        "height": "the number of vertices in a single column of the layout. Zero or negative numbers mean that the  should be determined automatically. It must not be given if the number of dimensions is 2.",
                        "dim": "the desired number of ensions for the layout. =2 means a 2D layout, =3 means a 3D layout."
                    },
                    "Return": [
                        "the calculated layout."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "layout_kamada_kawai": {
                    "Description": "Places the vertices on a plane according to the Kamada-Kawai algorithm.\nThis is a force directed layout, see Kamada, T. and Kawai, S.: An Algorithm for Drawing General Undirected Graphs. Information Processing Letters, 31/1, 7--15, 1989.",
                    "Paramters": {
                        "maxiter": "the maximum number of iterations to perform. None selects a reasonable default based on the number of vertices.",
                        "epsilon": "quit if the energy of the system changes less than . See the original paper for details.",
                        "kkconst": "the Kamada-Kawai vertex attraction constant. None means the number of vertices.",
                        "seed": "when None, uses a circular layout as a starting point for the algorithm when no bounds are given, or a random layout when bounds are specified for the coordinated. When the argument is a matrix (list of lists), it uses the given matrix as the initial layout.",
                        "minx": "if not None, it must be a vector with exactly as many elements as there are vertices in the graph. Each element is a minimum constraint on the X value of the vertex in the layout.",
                        "maxx": "similar to minx, but with maximum constraints",
                        "miny": "similar to minx, but with the Y coordinates",
                        "maxy": "similar to maxx, but with the Y coordinates",
                        "minz": "similar to minx, but with the Z coordinates. Use only for 3D layouts (dim=3).",
                        "maxz": "similar to maxx, but with the Z coordinates. Use only for 3D layouts (dim=3).",
                        "dim": "the desired number of ensions for the layout. =2 means a 2D layout, =3 means a 3D layout.",
                        "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name."
                    },
                    "Return": [
                        "the calculated layout."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "layout_lgl": {
                    "Description": "Places the vertices on a 2D plane according to the Large Graph Layout.",
                    "Paramters": {
                        "maxiter": "the number of iterations to perform.",
                        "maxdelta": "the maximum distance to move a vertex in an iteration. If negative, defaults to the number of vertices.",
                        "area": "the  of the square on which the vertices will be placed. If negative, defaults to the number of vertices squared.",
                        "coolexp": "the cooling exponent of the simulated annealing.",
                        "repulserad": "determines the radius at which vertex-vertex repulsion cancels out attraction of adjacent vertices. If negative, defaults to area times the number of vertices.",
                        "cellsize": "the size of the grid cells. When calculating the repulsion forces, only vertices in the same or neighboring grid cells are taken into account. Defaults to the fourth root of area.",
                        "root": "the  vertex, this is placed first, its neighbors in the first iteration, second neighbors in the second, etc. None means that a random vertex will be chosen."
                    },
                    "Return": [
                        "the calculated layout."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "layout_mds": {
                    "Description": "Places the vertices in an Euclidean space with the given number of dimensions using multidimensional scaling.\nThis layout requires a distance matrix, where the intersection of row i and column j specifies the desired distance between vertex i and vertex j. The algorithm will try to place the vertices in a way that approximates the distance relations prescribed in the distance matrix. igraph uses the classical multidimensional scaling by Torgerson (see reference below).\nFor unconnected graphs, the method will decompose the graph into weakly connected components and then lay out the components individually using the appropriate parts of the distance matrix.\nReference: Cox & Cox: Multidimensional Scaling (1994), Chapman and Hall, London.",
                    "Paramters": {
                        "dist": "the ance matrix. It must be symmetric and the symmetry is not checked -- results are unspecified when a non-symmetric ance matrix is used. If this parameter is None, the shortest path lengths will be used as ances. Directed graphs are treated as undirected when calculating the shortest path lengths to ensure symmetry.",
                        "dim": "the number of ensions. For 2D layouts, supply 2 here; for 3D layouts, supply 3.",
                        "arpack_options": "an ARPACKOptions object used to fine-tune the ARPACK eigenvector calculation. If omitted, the module-level variable called  is used."
                    },
                    "Return": [
                        "the calculated layout."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "layout_random": {
                    "Description": "Places the vertices of the graph randomly.",
                    "Paramters": {
                        "dim": "the desired number of ensions for the layout. =2 means a 2D layout, =3 means a 3D layout."
                    },
                    "Return": [
                        "the coordinate pairs in a list."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "layout_reingold_tilford": {
                    "Description": "Places the vertices on a 2D plane according to the Reingold-Tilford layout algorithm.\nThis is a tree layout. If the given graph is not a tree, a breadth-first search is executed first to obtain a possible spanning tree.\nReference: EM Reingold, JS Tilford: Tidier Drawings of Trees. IEEE Transactions on Software Engineering 7:22, 223-228, 1981.",
                    "Paramters": {
                        "mode": "specifies which edges to consider when builing the tree. If it is OUT then only the outgoing, if it is IN then only the incoming edges of a parent are considered. If it is ALL then all edges are used (this was the behaviour in igraph 0.5 and before). This parameter also influences how the root vertices are calculated if they are not given. See the root parameter.",
                        "root": "the index of the  vertex or  vertices. If this is a non-empty vector then the supplied vertex IDs are used as the s of the trees (or a single tree if the graph is connected). If this is None or an empty list, the  vertices are automatically calculated in such a way so that all other vertices would be reachable from them. Currently, automatic  selection prefers low eccentricity vertices in small graphs (fewer than 500 vertices) and high degree vertices in large graphs. This heuristic may change in future versions. Specify s manually for a consistent output.",
                        "rootlevel": "this argument is useful when drawing forests which are not trees. It specifies the level of the root vertices for every tree in the forest."
                    },
                    "Return": [
                        "the calculated layout."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "layout_reingold_tilford_circular",
                    "example": []
                },
                "layout_reingold_tilford_circular": {
                    "Description": "Circular Reingold-Tilford layout for trees.\nThis layout is similar to the Reingold-Tilford layout, but the vertices are placed in a circular way, with the root vertex in the center.\nSee layout_reingold_tilford for the explanation of the parameters.\nReference: EM Reingold, JS Tilford: Tidier Drawings of Trees. IEEE Transactions on Software Engineering 7:22, 223-228, 1981.",
                    "Paramters": {},
                    "Return": [
                        "the calculated layout."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "layout_reingold_tilford",
                    "example": []
                },
                "layout_star": {
                    "Description": "Calculates a star-like layout for the graph.",
                    "Paramters": {
                        "center": "the ID of the vertex to put in the ",
                        "order": "a numeric vector giving the  of the vertices (including the center vertex!). If it is None, the vertices will be placed in increasing vertex ID ."
                    },
                    "Return": [
                        "the calculated layout."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "layout_umap": {
                    "Description": "Uniform Manifold Approximation and Projection (UMAP).\nThis layout is a probabilistic algorithm that places vertices that are connected and have a short distance close by in the embedded space.\nReference: L McInnes, J Healy, J Melville: UMAP: Uniform Manifold Approximation and Projection for Dimension Reduction. arXiv:1802.03426.",
                    "Paramters": {
                        "dist": "ances associated with the graph edges. If None, all edges will be assumed to convey the same ance between the vertices. Either this argument of the weights argument can be set, but not both. It is fine to set neither.",
                        "weights": "precomputed edge  if you have them, as an alternative to setting the dist argument. Zero  will be ignored if this argument is set, e.g. if you computed the  via igraph.umap_compute_().",
                        "dim": "the desired number of ensions for the layout. =2 means a 2D layout, =3 means a 3D layout.",
                        "seed": "if None, uses a random starting layout for the algorithm. If a matrix (list of lists), uses the given matrix as the starting position.",
                        "min_dist": "the minimal distance in the embedded space beyond which the probability of being located closeby decreases.",
                        "epochs": "the number of  (iterations) the algorithm will iterate over. Accuracy increases with more , at the cost of longer runtimes. Values between 50 and 1000 are typical. Notice that UMAP does not technically converge for symmetry reasons, but a larger number of  should generally give an equivalent or better layout."
                    },
                    "Return": [
                        "the calculated layout.\nPlease note that if distances are set, the graph is usually directed, whereas if weights are precomputed, the graph will be treated as undirected. A special case is when the graph is directed but the precomputed weights are symmetrized in a way only one of each pair of opposite edges has nonzero weight, e.g. as computed by igraph.umap_compute_weights(). For example: weights = igraph.umap_compute_weights(graph, dist) layout = graph.layout_umap(weights=weights)\n"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "igraph.umap_compute_weights()",
                    "example": []
                },
                "LCF": {
                    "Description": "Generates a graph from LCF notation.\nLCF is short for Lederberg-Coxeter-Frucht, it is a concise notation for 3-regular Hamiltonian graphs. It consists of three parameters, the number of vertices in the graph, a list of shifts giving additional edges to a cycle backbone and another integer giving how many times the shifts should be performed. See http://mathworld.wolfram.com/LCFNotation.html for details.",
                    "Paramters": {
                        "n": "the umber of vertices",
                        "shifts": "the  in a list or tuple",
                        "repeats": "the number of "
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "linegraph": {
                    "Description": "Returns the line graph of the graph.\nThe line graph L(G) of an undirected graph is defined as follows: L(G) has one vertex for each edge in G and two vertices in L(G) are connected iff their corresponding edges in the original graph share an end point.\nThe line graph of a directed graph is slightly different: two vertices are connected by a directed edge iff the target of the first vertex's corresponding edge is the same as the source of the second vertex's corresponding edge.\nEdge i in the original graph will map to vertex i of the line graph.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "list_triangles": {
                    "Description": "Lists the triangles of the graph",
                    "Paramters": {},
                    "Return": [
                        "the list of triangles in the graph; each triangle is represented by a tuple of length 3, containing the corresponding vertex IDs."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "maxdegree": {
                    "Description": "Returns the maximum degree of a vertex set in the graph.\nThis method accepts a single vertex ID or a list of vertex IDs as a parameter, and returns the degree of the given vertices (in the form of a single integer or a list, depending on the input parameter).",
                    "Paramters": {
                        "vertices": "a single vertex ID or a list of vertex IDs, or None meaning all the  in the graph.",
                        "mode": "the type of degree to be returned (\"out\" for out-degrees, \"in\" IN for in-degrees or \"all\" for the sum of them).",
                        "loops": "whether self- should be counted."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "maxflow": {
                    "Description": "overridden in igraph.Graph\nReturns the maximum flow between the source and target vertices.\nAttention: this function has a more convenient interface in class Graph, which wraps the result in a Flow object. It is advised to use that.",
                    "Paramters": {
                        "source": "the  vertex ID",
                        "target": "the  vertex ID",
                        "capacity": "the  of the edges. It must be a list or a valid attribute name or None. In the latter case, every edge will have the same ."
                    },
                    "Return": [
                        "a tuple containing the following: the value of the maximum flow between the given vertices, the flow value on all the edges, the edge IDs that are part of the corresponding minimum cut, and the vertex IDs on one side of the cut. For directed graphs, the flow value vector gives the flow value on each edge. For undirected graphs, the flow value is positive if the flow goes from the smaller vertex ID to the bigger one and negative if the flow goes from the bigger vertex ID to the smaller."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "maxflow_value": {
                    "Description": "Returns the value of the maximum flow between the source and target vertices.",
                    "Paramters": {
                        "source": "the  vertex ID",
                        "target": "the  vertex ID",
                        "capacity": "the  of the edges. It must be a list or a valid attribute name or None. In the latter case, every edge will have the same ."
                    },
                    "Return": [
                        "the value of the maximum flow between the given vertices"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "maximal_cliques": {
                    "Description": "Returns the maximal cliques of the graph as a list of tuples.\nA maximal clique is a clique which can't be extended by adding any other vertex to it. A maximal clique is not necessarily one of the largest cliques in the graph.",
                    "Paramters": {
                        "min": "the imum size of maximal cliques to be returned. If zero or negative, no lower bound will be used.",
                        "max": "the imum size of imal cliques to be returned. If zero or negative, no upper bound will be used. If nonzero, the size of every imal clique found will be compared to this value and a clique will be returned only if its size is smaller than this limit.",
                        "file": "a  object or the name of the  to write the results to. When this argument is None, the maximal cliques will be returned as a list of lists."
                    },
                    "Return": [
                        "the maximal cliques of the graph as a list of lists, or None if the file argument was given.@see: largest_cliques() for the largest cliques."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "maximal_independent_vertex_sets": {
                    "Description": "Returns the maximal independent vertex sets of the graph as a list of tuples.\nA maximal independent vertex set is an independent vertex set which can't be extended by adding any other vertex to it. A maximal independent vertex set is not necessarily one of the largest independent vertex sets in the graph.\nReference: S. Tsukiyama, M. Ide, H. Ariyoshi and I. Shirawaka: A new algorithm for generating all the maximal independent sets. SIAM J Computing, 6:505-517, 1977.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "largest_independent_vertex_sets() for the largest independent vertex sets",
                    "example": []
                },
                "maximum_cardinality_search": {
                    "Description": "Conducts a maximum cardinality search on the graph. The function computes a rank alpha for each vertex such that visiting vertices in decreasing rank order corresponds to always choosing the vertex with the most already visited neighbors as the next one to visit.\nMaximum cardinality search is useful in deciding the chordality of a graph: a graph is chordal if and only if any two neighbors of a vertex that are higher in rank than the original vertex are connected to each other.\nThe result of this function can be passed to is_chordal() to speed up the chordality computation if you also need the result of the maximum cardinality search for other purposes.",
                    "Paramters": {},
                    "Return": [
                        "a tuple consisting of the rank vector and its inverse."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "mincut": {
                    "Description": "overridden in igraph.Graph\nCalculates the minimum cut between the source and target vertices or within the whole graph.\nThe minimum cut is the minimum set of edges that needs to be removed to separate the source and the target (if they are given) or to disconnect the graph (if the source and target are not given). The minimum is calculated using the weights (capacities) of the edges, so the cut with the minimum total capacity is calculated. For undirected graphs and no source and target, the method uses the Stoer-Wagner algorithm. For a given source and target, the method uses the push-relabel algorithm; see the references below.\nAttention: this function has a more convenient interface in class Graph, which wraps the result in a Cut object. It is advised to use that.\n",
                    "Paramters": {
                        "source": "the  vertex ID. If None, target must also be {None} and the calculation will be done for the entire graph (i.e. all possible vertex pairs).",
                        "target": "the  vertex ID. If None, source must also be {None} and the calculation will be done for the entire graph (i.e. all possible vertex pairs).",
                        "capacity": "the  of the edges. It must be a list or a valid attribute name or None. In the latter case, every edge will have the same ."
                    },
                    "Return": [
                        "the value of the minimum cut, the IDs of vertices in the first and second partition, and the IDs of edges in the cut, packed in a 4-tuple"
                    ],
                    "References": [
                        "M. Stoer, F. Wagner: A simple min-cut algorithm. Journal of the ACM 44(4):585-591, 1997.A. V. Goldberg, R. E. Tarjan: A new approach to the maximum-flow problem. Journal of the ACM 35(4):921-940, 1988."
                    ],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "mincut_value": {
                    "Description": "Returns the minimum cut between the source and target vertices or within the whole graph.",
                    "Paramters": {
                        "source": "the  vertex ID. If negative, the calculation is done for every vertex except the target and the minimum is returned.",
                        "target": "the  vertex ID. If negative, the calculation is done for every vertex except the source and the minimum is returned.",
                        "capacity": "the  of the edges. It must be a list or a valid attribute name or None. In the latter case, every edge will have the same ."
                    },
                    "Return": [
                        "the value of the minimum cut between the given vertices"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "minimum_cycle_basis": {
                    "Description": "Computes a minimum cycle basis of the graph",
                    "Paramters": {
                        "cutoff": "when None or negative, a complete minimum cycle basis is returned. Otherwise only those cycles in the result will be part of some minimum cycle basis that are of length 2*\u2009+\u20091 or shorter. Cycles longer than this limit may not be of the smallest possible size. This parameter effectively limits the depth of the BFS tree when computing candidate cycles and may speed up the computation substantially.",
                        "complete": "used only when a cutoff is specified, and in this case it specifies whether a  basis is returned (True) or the result will be limited to cycles of length 2*cutoff\u2009+\u20091 or shorter only. This limits computation time, but the result may not span the entire cycle space.",
                        "use_cycle_order": "if True, every cycle is returned in natural order: the edge IDs will appear ordered along the cycle. If False, no guarantees are given about the ordering of edge IDs within cycles."
                    },
                    "Return": [
                        "the cycle basis as a list of tuples containing edge IDs"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "minimum_size_separators": {
                    "Description": "Returns a list containing all separator vertex sets of minimum size.\nA vertex set is a separator if its removal disconnects the graph. This method lists all the separators for which no smaller separator set exists in the given graph.\nReference: Arkady Kanevsky: Finding all minimum-size separating vertex sets in a graph. Networks 23:533-541, 1993.",
                    "Paramters": {},
                    "Return": [
                        "a list where each item lists the vertex indices of a given separator of minimum size."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "modularity": {
                    "Description": "overridden in igraph.Graph\nCalculates the modularity of the graph with respect to some vertex types.\nThe modularity of a graph w.r.t. some division measures how good the division is, or how separated are the different vertex types from each other. It is defined as Q\u2009=\u20091\u2009\u2044\u2009(2m)*sum(Aij\u2009\u2212\u2009gamma*ki*kj\u2009\u2044\u2009(2m)delta(ci,\u2009cj),\u2009i,\u2009j). m is the number of edges, Aij is the element of the A adjacency matrix in row i and column j, ki is the degree of node i, kj is the degree of node j, Ci and cj are the types of the two vertices (i and j), and gamma is a resolution parameter that defaults to 1 for the classical definition of modularity. delta(x,\u2009y) is one iff x\u2009=\u2009y, 0 otherwise.\nIf edge weights are given, the definition of modularity is modified as follows: Aij becomes the weight of the corresponding edge, ki is the total weight of edges incident on vertex i, kj is the total weight of edges incident on vertex j and m is the total edge weight in the graph.\nAttention: method overridden in Graph to allow VertexClustering objects as a parameter. This method is not strictly necessary, since the VertexClustering class provides a variable called modularity.\nReference: MEJ Newman and M Girvan: Finding and evaluating community structure in networks. Phys Rev E 69 026113, 2004.",
                    "Paramters": {
                        "membership": "the  vector, e.g. the vertex type index for each vertex.",
                        "weights": "optional edge  or None if all edges are weighed equally.",
                        "resolution": "the  parameter gamma in the formula above. The classical definition of modularity is retrieved when the  parameter is set to 1.",
                        "directed": "whether to consider edge directions if the graph is . True will use the  variant of the modularity measure where the in- and out-degrees of nodes are treated separately; False will treat  graphs as un."
                    },
                    "Return": [
                        "the modularity score."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "modularity_matrix": {
                    "Description": "Calculates the modularity matrix of the graph.",
                    "Paramters": {
                        "weights": "optional edge  or None if all edges are weighed equally.",
                        "resolution": "the  parameter gamma of the modularity formula. The classical definition of modularity is retrieved when the  parameter is set to 1.",
                        "directed": "whether to consider edge directions if the graph is . True will use the  variant of the modularity measure where the in- and out-degrees of nodes are treated separately; False will treat  graphs as un."
                    },
                    "Return": [
                        "the modularity matrix as a list of lists."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "motifs_randesu": {
                    "Description": "Counts the number of motifs in the graph\nMotifs are small subgraphs of a given structure in a graph. It is argued that the motif profile (ie. the number of different motifs in the graph) is characteristic for different types of networks and network function is related to the motifs in the graph.\nCurrently we support motifs of size 3 and 4 for directed graphs, and motifs of size 3, 4, 5 or 6 for undirected graphs.\nIn a big network the total number of motifs can be very large, so it takes a lot of time to find all of them. In such cases, a sampling method can be used. This function is capable of doing sampling via the cut_prob argument. This argument gives the probability that a branch of the motif search tree will not be explored.\nReference: S. Wernicke and F. Rasche: FANMOD: a tool for fast network motif detection, Bioinformatics 22(9), 1152--1153, 2006.",
                    "Paramters": {
                        "size": "the  of the motifs",
                        "cut_prob": "the cut probabilities for different levels of the search tree. This must be a list of length size or None to find all motifs.",
                        "callback": "None or a callable that will be called for every motif found in the graph. The callable must accept three parameters: the graph itself, the list of vertices in the motif and the isomorphism class of the motif (see isoclass()). The search will stop when the  returns an object with a non-zero truth value or raises an exception."
                    },
                    "Return": [
                        "the list of motifs if callback is None, or None otherwise"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "Graph.motifs_randesu_no()",
                    "example": []
                },
                "motifs_randesu_estimate": {
                    "Description": "Counts the total number of motifs in the graph\nMotifs are small subgraphs of a given structure in a graph. This function estimates the total number of motifs in a graph without assigning isomorphism classes to them by extrapolating from a random sample of vertices.\nCurrently we support motifs of size 3 and 4 for directed graphs, and motifs of size 3, 4, 5 or 6 for undirected graphs.\nReference: S. Wernicke and F. Rasche: FANMOD: a tool for fast network motif detection, Bioinformatics 22(9), 1152--1153, 2006.",
                    "Paramters": {
                        "size": "the  of the motifs",
                        "cut_prob": "the cut probabilities for different levels of the search tree. This must be a list of length size or None to find all motifs.",
                        "sample": "the size of the  or the vertex IDs of the vertices to be used for sampling."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "Graph.motifs_randesu()",
                    "example": []
                },
                "motifs_randesu_no": {
                    "Description": "Counts the total number of motifs in the graph\nMotifs are small subgraphs of a given structure in a graph. This function counts the total number of motifs in a graph without assigning isomorphism classes to them.\nCurrently we support motifs of size 3 and 4 for directed graphs, and motifs of size 3, 4, 5 or 6 for undirected graphs.\nReference: S. Wernicke and F. Rasche: FANMOD: a tool for fast network motif detection, Bioinformatics 22(9), 1152--1153, 2006.",
                    "Paramters": {
                        "size": "the  of the motifs",
                        "cut_prob": "the cut probabilities for different levels of the search tree. This must be a list of length size or None to find all motifs."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "Graph.motifs_randesu()",
                    "example": []
                },
                "neighborhood": {
                    "Description": "For each vertex specified by vertices, returns the vertices reachable from that vertex in at most order steps. If mindist is larger than zero, vertices that are reachable in less than mindist steps are excluded.",
                    "Paramters": {
                        "vertices": "a single vertex ID or a list of vertex IDs, or None meaning all the  in the graph.",
                        "order": "the  of the neighborhood, i.e. the maximum number of steps to take from the seed vertex.",
                        "mode": "specifies how to take into account the direction of the edges if a directed graph is analyzed. \"out\" means that only the outgoing edges are followed, so all vertices reachable from the source vertex in at most order steps are counted. \"in\" means that only the incoming edges are followed (in reverse direction of course), so all vertices from which the source vertex is reachable in at most order steps are counted. \"all\" treats directed edges as undirected.",
                        "mindist": "the minimum distance required to include a vertex in the result. If this is one, the seed vertex is not included. If this is two, the direct neighbors of the seed vertex are not included either, and so on."
                    },
                    "Return": [
                        "a single list specifying the neighborhood if vertices was an integer specifying a single vertex index, or a list of lists if vertices was a list or None."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "neighborhood_size": {
                    "Description": "For each vertex specified by vertices, returns the number of vertices reachable from that vertex in at most order steps. If mindist is larger than zero, vertices that are reachable in less than mindist steps are excluded.",
                    "Paramters": {
                        "vertices": "a single vertex ID or a list of vertex IDs, or None meaning all the  in the graph.",
                        "order": "the  of the neighborhood, i.e. the maximum number of steps to take from the seed vertex.",
                        "mode": "specifies how to take into account the direction of the edges if a directed graph is analyzed. \"out\" means that only the outgoing edges are followed, so all vertices reachable from the source vertex in at most order steps are counted. \"in\" means that only the incoming edges are followed (in reverse direction of course), so all vertices from which the source vertex is reachable in at most order steps are counted. \"all\" treats directed edges as undirected.",
                        "mindist": "the minimum distance required to include a vertex in the result. If this is one, the seed vertex is not counted. If this is two, the direct neighbors of the seed vertex are not counted either, and so on."
                    },
                    "Return": [
                        "a single number specifying the neighborhood size if vertices was an integer specifying a single vertex index, or a list of sizes if vertices was a list or None."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "neighbors": {
                    "Description": "Returns adjacent vertices to a given vertex.",
                    "Paramters": {
                        "vertex": "a  ID",
                        "mode": "whether to return only successors (\"out\"), predecessors (\"in\") or both (\"all\"). Ignored for undirected graphs."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "path_length_hist": {
                    "Description": "overridden in igraph.Graph\nCalculates the path length histogram of the graph Attention: this function is wrapped in a more convenient syntax in the derived class Graph. It is advised to use that instead of this version.",
                    "Paramters": {
                        "directed": "whether to consider  paths"
                    },
                    "Return": [
                        "a tuple. The first item of the tuple is a list of path lengths, the ith element of the list contains the number of paths with length i\u2009+\u20091. The second item contains the number of unconnected vertex pairs as a float (since it might not fit into an integer)"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "permute_vertices": {
                    "Description": "Permutes the vertices of the graph according to the given permutation and returns the new graph.\nVertex k of the original graph will become vertex permutation[k] in the new graph. No validity checks are performed on the permutation vector.",
                    "Paramters": {},
                    "Return": [
                        "the new graph"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "personalized_pagerank": {
                    "Description": "Calculates the personalized PageRank values of a graph.\nThe personalized PageRank calculation is similar to the PageRank calculation, but the random walk is reset to a non-uniform distribution over the vertices in every step with probability 1\u2009\u2212\u2009damping instead of a uniform distribution.",
                    "Paramters": {
                        "vertices": "the indices of the  being queried. None means all of the .",
                        "directed": "whether to consider  paths.",
                        "damping": "the  factor.",
                        "reset": "the distribution over the vertices to be used when ting the random walk. Can be a sequence, an iterable or a vertex attribute name as long as they return a list of floats whose length is equal to the number of vertices. If None, a uniform distribution is assumed, which makes the method equivalent to the original PageRank algorithm.",
                        "reset_vertices": "an alternative way to specify the distribution over the vertices to be used when resetting the random walk. Simply supply a list of vertex IDs here, or a VertexSeq or a Vertex. Resetting will take place using a uniform distribution over the specified vertices.",
                        "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name.",
                        "arpack_options": "an ARPACKOptions object used to fine-tune the ARPACK eigenvector calculation. If omitted, the module-level variable called  is used. This argument is ignored if not the ARPACK implementation is used, see the implementation argument.",
                        "implementation": "which  to use to solve the PageRank eigenproblem. Possible values are:\"prpack\": use the PRPACK library. This is a new  in igraph 0.7\"arpack\": use the ARPACK library. This  was used from version 0.5, until version 0.7."
                    },
                    "Return": [
                        "a list with the personalized PageRank values of the specified vertices."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "predecessors": {
                    "Description": "Returns the predecessors of a given vertex.\nEquivalent to calling the neighbors() method with type=\"in\".",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Preference": {
                    "Description": "Generates a graph based on vertex types and connection probabilities.\nThis is practically the non-growing variant of Establishment. A given number of vertices are generated. Every vertex is assigned to a vertex type according to the given type probabilities. Finally, every vertex pair is evaluated and an edge is created between them with a probability depending on the types of the vertices involved.",
                    "Paramters": {
                        "n": "the umber of vertices i the graph",
                        "type_dist": "list giving the distribution of vertex types",
                        "pref_matrix": "matrix giving the connection probabilities for different vertex types.",
                        "attribute": "the vertex  name used to store the vertex types. If None, vertex types are not stored.",
                        "directed": "whether to generate a  graph.",
                        "loops": "whether loop edges are allowed."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Prufer": {
                    "Description": "Generates a tree from its Pr\u00fcfer sequence.\nA Pr\u00fcfer sequence is a unique sequence of integers associated with a labelled tree. A tree on n vertices can be represented by a sequence of n\u2009\u2212\u20092 integers, each between 0 and n\u2009\u2212\u20091 (inclusive).",
                    "Paramters": {
                        "seq": "the Pr\u00fcfer uence as an iterable of integers"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "radius": {
                    "Description": "Calculates the radius of the graph.\nThe radius of a graph is defined as the minimum eccentricity of its vertices (see eccentricity()).",
                    "Paramters": {
                        "mode": "what kind of paths to consider for the calculation in case of directed graphs. OUT considers paths that follow edge directions, IN considers paths that follow the opposite edge directions, ALL ignores edge directions. The argument is ignored for undirected graphs.",
                        "weights": "a list containing the edge . It can also be an attribute name (edge  are retrieved from the given attribute) or None (all edges have equal weight)."
                    },
                    "Return": [
                        "the radius"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "eccentricity()",
                    "example": []
                },
                "random_walk": {
                    "Description": "Performs a random walk of a given length from a given node.",
                    "Paramters": {
                        "start": "the ing vertex of the walk",
                        "steps": "the number of  that the random walk should take",
                        "mode": "whether to follow outbound edges only (\"out\"), inbound edges only (\"in\") or both (\"all\"). Ignored for undirected graphs.@param stuck: what to do when the random walk gets stuck. \"return\" returns a partial random walk; \"error\" throws an exception.",
                        "stuck": "Undocumented",
                        "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name.",
                        "return_type": "what to return. It can be \"vertices\" (default), then the function returns a list of the vertex ids visited; \"edges\", then the function returns a list of edge ids visited; or \"both\", then the function return a dictionary with keys \"vertices\" and \"edges\"."
                    },
                    "Return": [
                        "a random walk that starts from the given vertex and has at most the given length (shorter if the random walk got stuck)."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Read_DIMACS": {
                    "Description": "overridden in igraph.Graph\nReads a graph from a file conforming to the DIMACS minimum-cost flow file format.\nFor the exact description of the format, see http://lpsolve.sourceforge.net/5.5/DIMACS.htm\nRestrictions compared to the official description of the format:igraph's DIMACS reader requires only three fields in an arc definition, describing the edge's source and target node and its capacity.Source vertices are identified by 's' in the FLOW field, target vertices are identified by 't'.Node indices start from 1. Only a single source and target node is allowed.",
                    "Paramters": {
                        "f": "the name o the ile or a Python ile handle",
                        "directed": "whether the generated graph should be ."
                    },
                    "Return": [
                        "the generated graph, the source and the target of the flow and the edge capacities in a tuple"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Read_DL": {
                    "Description": "Reads an UCINET DL file and creates a graph based on it.",
                    "Paramters": {
                        "f": "the name o the ile or a Python ile handle",
                        "directed": "whether the generated graph should be ."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Read_Edgelist": {
                    "Description": "Reads an edge list from a file and creates a graph based on it.\nPlease note that the vertex indices are zero-based. A vertex of zero degree will be created for every integer that is in range but does not appear in the edgelist.",
                    "Paramters": {
                        "f": "the name o the ile or a Python ile handle",
                        "directed": "whether the generated graph should be ."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Read_GML": {
                    "Description": "Reads a GML file and creates a graph based on it.",
                    "Paramters": {
                        "f": "the name o the ile or a Python ile handle"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Read_GraphDB": {
                    "Description": "Reads a GraphDB format file and creates a graph based on it.\nGraphDB is a binary format, used in the graph database for isomorphism testing (see http://amalfi.dis.unina.it/graph/).",
                    "Paramters": {
                        "f": "the name o the ile or a Python ile handle",
                        "directed": "whether the generated graph should be ."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Read_GraphML": {
                    "Description": "Reads a GraphML format file and creates a graph based on it.",
                    "Paramters": {
                        "f": "the name o the ile or a Python ile handle",
                        "index": "if the GraphML file contains multiple graphs, specifies the one that should be loaded. Graph indices start from zero, so if you want to load the first graph, specify 0 here."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Read_Lgl": {
                    "Description": "Reads an .lgl file used by LGL.\nIt is also useful for creating graphs from \"named\" (and optionally weighted) edge lists.\nThis format is used by the Large Graph Layout program. See the documentation of LGL regarding the exact format description.\nLGL originally cannot deal with graphs containing multiple or loop edges, but this condition is not checked here, as igraph is happy with these.",
                    "Paramters": {
                        "f": "the name o the ile or a Python ile handle",
                        "names": "If True, the vertex  are added as a vertex attribute called 'name'.",
                        "weights": "If True, the edge  are added as an edge attribute called 'weight', even if there are no  in the file. If False, the edge  are never added, even if they are present. \"auto\" or \"if_present\" means that  are added if there is at least one weighted edge in the input file, but they are not added otherwise.",
                        "directed": "whether the graph being created should be "
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Read_Ncol": {
                    "Description": "Reads an .ncol file used by LGL.\nIt is also useful for creating graphs from \"named\" (and optionally weighted) edge lists.\nThis format is used by the Large Graph Layout program. See the repository of LGL for more information.\nLGL originally cannot deal with graphs containing multiple or loop edges, but this condition is not checked here, as igraph is happy with these.",
                    "Paramters": {
                        "f": "the name o the ile or a Python ile handle",
                        "names": "If True, the vertex  are added as a vertex attribute called 'name'.",
                        "weights": "If True, the edge  are added as an edge attribute called 'weight', even if there are no  in the file. If False, the edge  are never added, even if they are present. \"auto\" or \"if_present\" means that  are added if there is at least one weighted edge in the input file, but they are not added otherwise.",
                        "directed": "whether the graph being created should be "
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Read_Pajek": {
                    "Description": "Reads a file in the Pajek format and creates a graph based on it. Only Pajek network files (.net extension) are supported, not project files (.paj).",
                    "Paramters": {
                        "f": "the name o the ile or a Python ile handle"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Realize_Bipartite_Degree_Sequence": {
                    "Description": "Generates a bipartite graph from the degree sequences of its partitions.\nThis method implements a Havel-Hakimi style graph construction for biparite graphs. In each step, the algorithm picks two vertices in a deterministic manner and connects them. The way the vertices are picked is defined by the method parameter. The allowed edge types (i.e. whether multi-edges are allowed) are specified in the allowed_edge_types parameter. Self-loops are never created, since a graph with self-loops is not bipartite.",
                    "Paramters": {
                        "degrees1": "the degrees of the first partition.",
                        "degrees2": "the degrees of the second partition.",
                        "allowed_edge_types": "controls whether multi-edges are allowed during the generation process. Possible values are:\"simple\": simple graphs (no multi-edges)\"multi\": multi-edges allowed",
                        "method": "controls how the vertices are selected during the generation process. Possible values are:smallest: The vertex with smallest remaining degree first.largest: The vertex with the largest remaining degree first.index: The vertices are selected in order of their index.The smallest smallest  is guaranteed to produce a connected graph, if one exists."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Realize_Degree_Sequence": {
                    "Description": "Generates a graph from a degree sequence.\nThis method implements a Havel-Hakimi style graph construction from a given degree sequence. In each step, the algorithm picks two vertices in a deterministic manner and connects them. The way the vertices are picked is defined by the method parameter. The allowed edge types (i.e. whether multiple or loop edges are allowed) are specified in the allowed_edge_types parameter.\n",
                    "Paramters": {
                        "out": "the degree sequence of an undirected graph (if in_=None), or the -degree sequence of a directed graph.",
                        "in_": "None to generate an undirected graph, the in-degree sequence to generate a directed graph.",
                        "allowed_edge_types": "controls whether loops or multi-edges are allowed during the generation process. Note that not all combinations are supported for all types of graphs; an exception will be raised for unsupported combinations. Possible values are:\"simple\": simple graphs (no self-loops, no multi-edges)\"loops\": single self-loops allowed, but not multi-edges\"multi\": multi-edges allowed, but not self-loops\"all\": multi-edges and self-loops allowed",
                        "method": "controls how the vertices are selected during the generation process. Possible values are:smallest: The vertex with smallest remaining degree first.largest: The vertex with the largest remaining degree first.index: The vertices are selected in order of their index.In the undirected case, smallest is guaranteed to produce a connected graph. See Horv\u00e1t and Modes (2021) for details."
                    },
                    "Return": [],
                    "References": [
                        "V. Havel, Pozn\u00e1mka o existenci kone\u010dn\u00fdch graf\u016f (A remark on the existence of finite graphs), \u010casopis pro p\u011bstov\u00e1n\u00ed matematiky 80, 477-480 (1955). http://eudml.org/doc/19050S. L. Hakimi, On Realizability of a Set of Integers as Degrees of the Vertices of a Linear Graph, Journal of the SIAM 10, 3 (1962). https://www.jstor.org/stable/2098770D. J. Kleitman and D. L. Wang, Algorithms for Constructing Graphs and Digraphs with Given Valences and Factors, Discrete Mathematics 6, 1 (1973). https://doi.org/10.1016/0012-365X%2873%2990037-XSz. Horv\u00e1t and C. D. Modes, Connectedness matters: construction and exact random sampling of connected networks (2021). https://doi.org/10.1088/2632-072X/abced5"
                    ],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Recent_Degree": {
                    "Description": "Generates a graph based on a stochastic model where the probability of an edge gaining a new node is proportional to the edges gained in a given time window.",
                    "Paramters": {
                        "n": "the umber of vertices",
                        "m": "either the nuber of outgoing edges generated for each vertex or a list containing the nuber of outgoing edges for each vertex explicitly.",
                        "window": "size of the  in time steps",
                        "outpref": "True if the out-degree of a given vertex should also increase its citation probability (as well as its in-degree), but it defaults to False.",
                        "directed": "True if the generated graph should be  (default: False).",
                        "power": "the  constant of the nonlinear model. It can be omitted, and in this case the usual linear model will be used."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "reciprocity": {
                    "Description": "Reciprocity defines the proportion of mutual connections in a directed graph. It is most commonly defined as the probability that the opposite counterpart of a directed edge is also included in the graph. This measure is calculated if mode is \"default\".\nPrior to igraph 0.6, another measure was implemented, defined as the probability of mutual connection between a vertex pair if we know that there is a (possibly non-mutual) connection between them. In other words, (unordered) vertex pairs are classified into three groups: (1) disconnected, (2) non-reciprocally connected and (3) reciprocally connected. The result is the size of group (3), divided by the sum of sizes of groups (2) and (3). This measure is calculated if mode is \"ratio\".",
                    "Paramters": {
                        "ignore_loops": "whether loop edges should be ignored.",
                        "mode": "the algorithm to use to calculate the reciprocity; see above for more details."
                    },
                    "Return": [
                        "the reciprocity of the graph"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "reverse_edges": {
                    "Description": "Reverses the direction of some edges in the graph.\nThis function is a no-op for undirected graphs.",
                    "Paramters": {
                        "es": "the list of edg to be reversed. Edg are identifed by edge IDs. EdgeSeq objects are also accepted here. When omitted, all edg will be reversed."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "rewire": {
                    "Description": "Randomly rewires the graph while preserving the degree distribution.\nPlease note that the rewiring is done \"in-place\", so the original graph will be modified. If you want to preserve the original graph, use the copy method before.",
                    "Paramters": {
                        "n": "the umber of rewirig trials.",
                        "mode": "the rewiring algorithm to use. It can either be \"simple\" or \"loops\"; the former does not create or destroy loop edges while the latter does."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "rewire_edges": {
                    "Description": "Rewires the edges of a graph with constant probability.\nEach endpoint of each edge of the graph will be rewired with a constant probability, given in the first argument.\nPlease note that the rewiring is done \"in-place\", so the original graph will be modified. If you want to preserve the original graph, use the copy method before.",
                    "Paramters": {
                        "prob": "rewiring ability",
                        "loops": "whether the algorithm is allowed to create loop edges",
                        "multiple": "whether the algorithm is allowed to create  edges."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Ring": {
                    "Description": "Generates a ring graph.",
                    "Paramters": {
                        "n": "the umber of vertices i the rig",
                        "directed": "whether to create a  ring.",
                        "mutual": "whether to create  edges in a directed ring.",
                        "circular": "whether to create a closed ring."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "SBM": {
                    "Description": "Generates a graph based on a stochastic block model.\nA given number of vertices are generated. Every vertex is assigned to a vertex type according to the given block sizes. Vertices of the same type will be assigned consecutive vertex IDs. Finally, every vertex pair is evaluated and an edge is created between them with a probability depending on the types of the vertices involved. The probabilities are taken from the preference matrix.",
                    "Paramters": {
                        "n": "the umber of vertices i the graph",
                        "pref_matrix": "matrix giving the connection probabilities for different vertex types.",
                        "block_sizes": "list giving the number of vertices in each block; must sum up to n.",
                        "directed": "whether to generate a  graph.",
                        "loops": "whether loop edges are allowed."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "similarity_dice": {
                    "Description": "Dice similarity coefficient of vertices.\nThe Dice similarity coefficient of two vertices is twice the number of their common neighbors divided by the sum of their degrees. This coefficient is very similar to the Jaccard coefficient, but usually gives higher similarities than its counterpart.",
                    "Paramters": {
                        "vertices": "the  to be analysed. If None and pairs is also None, all  will be considered.",
                        "pairs": "the vertex  to be analysed. If this is given, vertices must be None, and the similarity values will be calculated only for the given . Vertex  must be specified as tuples of vertex IDs.",
                        "mode": "which neighbors should be considered for directed graphs. Can be \"all\", \"in\" or \"out\", ignored for undirected graphs.",
                        "loops": "whether vertices should be considered adjacent to themselves. Setting this to True assumes a loop edge for all vertices even if none is present in the graph. Setting this to False may result in strange results: nonadjacent vertices may have larger similarities compared to the case when an edge is added between them -- however, this might be exactly the result you want to get."
                    },
                    "Return": [
                        "the pairwise similarity coefficients for the vertices specified, in the form of a matrix if pairs is None or in the form of a list if pairs is not None."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "similarity_inverse_log_weighted": {
                    "Description": "Inverse log-weighted similarity coefficient of vertices.\nEach vertex is assigned a weight which is 1 / log(degree). The log-weighted similarity of two vertices is the sum of the weights of their common neighbors.\nNote that the presence of loop edges may yield counter-intuitive results. A node with a loop edge is considered to be a neighbor of itself twice (because there are two edge stems incident on the node). Adding a loop edge to a node may decrease its similarity to other nodes, but it may also increase it. For instance, if nodes A and B are connected but share no common neighbors, their similarity is zero. However, if a loop edge is added to B, then B itself becomes a common neighbor of A and B and thus the similarity of A and B will be increased. Consider removing loop edges explicitly before invoking this function using Graph.simplify().",
                    "Paramters": {
                        "vertices": "the  to be analysed. If None, all  will be considered.",
                        "mode": "which neighbors should be considered for directed graphs. Can be \"all\", \"in\" or \"out\", ignored for undirected graphs. \"in\" means that the weights are determined by the out-degrees, \"out\" means that the weights are determined by the in-degrees."
                    },
                    "Return": [
                        "the pairwise similarity coefficients for the vertices specified, in the form of a matrix (list of lists)."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "similarity_jaccard": {
                    "Description": "Jaccard similarity coefficient of vertices.\nThe Jaccard similarity coefficient of two vertices is the number of their common neighbors divided by the number of vertices that are adjacent to at least one of them.",
                    "Paramters": {
                        "vertices": "the  to be analysed. If None and pairs is also None, all  will be considered.",
                        "pairs": "the vertex  to be analysed. If this is given, vertices must be None, and the similarity values will be calculated only for the given . Vertex  must be specified as tuples of vertex IDs.",
                        "mode": "which neighbors should be considered for directed graphs. Can be \"all\", \"in\" or \"out\", ignored for undirected graphs.",
                        "loops": "whether vertices should be considered adjacent to themselves. Setting this to True assumes a loop edge for all vertices even if none is present in the graph. Setting this to False may result in strange results: nonadjacent vertices may have larger similarities compared to the case when an edge is added between them -- however, this might be exactly the result you want to get."
                    },
                    "Return": [
                        "the pairwise similarity coefficients for the vertices specified, in the form of a matrix if pairs is None or in the form of a list if pairs is not None."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "simplify": {
                    "Description": "Simplifies a graph by removing self-loops and/or multiple edges.\nFor example, suppose you have a graph with an edge attribute named weight. graph.simplify(combine_edges=max) will take the maximum of the weights of multiple edges and assign that weight to the collapsed edge. graph.simplify(combine_edges=sum) will take the sum of the weights. You can also write graph.simplify(combine_edges=dict(weight=\"sum\")) or graph.simplify(combine_edges=dict(weight=sum)), since sum is recognised both as a Python built-in function and as a string constant.",
                    "Paramters": {
                        "multiple": "whether to remove  edges.",
                        "loops": "whether to remove .",
                        "combine_edges": "specifies how to combine the attributes of multiple edges between the same pair of vertices into a single attribute. If it is None, only one of the edges will be kept and all the attributes will be lost. If it is a function, the attributes of multiple edges will be collected and passed on to that function which will return the new attribute value that has to be assigned to the single collapsed edge. It can also be one of the following string constants:\"ignore\": all the edge attributes will be ignored.\"sum\": the sum of the edge attribute values will be used for the new edge.\"product\": the product of the edge attribute values will be used for the new edge.\"mean\": the mean of the edge attribute values will be used for the new edge.\"median\": the median of the edge attribute values will be used for the new edge.\"min\": the minimum of the edge attribute values will be used for the new edge.\"max\": the maximum of the edge attribute values will be used for the new edge.\"first\": the attribute value of the first edge in the collapsed set will be used for the new edge.\"last\": the attribute value of the last edge in the collapsed set will be used for the new edge.\"random\": a randomly selected value will be used for the new edge\"concat\": the attribute values will be concatenated for the new edge.You can also use a dict mapping edge attribute names to functions or the above string constants if you want to make the behaviour of the simplification process depend on the name of the attribute. None is a special key in this dict, its value will be used for all the attributes not specified explicitly in the dictionary."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "st_mincut": {
                    "Description": "overridden in igraph.Graph\nCalculates the minimum cut between the source and target vertices in a graph.\nAttention: this function has a more convenient interface in class Graph, which wraps the result in a list of Cut objects. It is advised to use that.",
                    "Paramters": {
                        "source": "the  vertex ID",
                        "target": "the  vertex ID",
                        "capacity": "the  of the edges. It must be a list or a valid attribute name or None. In the latter case, every edge will have the same ."
                    },
                    "Return": [
                        "the value of the minimum cut, the IDs of vertices in the first and second partition, and the IDs of edges in the cut, packed in a 4-tuple"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Star": {
                    "Description": "Generates a star graph.",
                    "Paramters": {
                        "n": "the umber of vertices i the graph",
                        "mode": "Gives the type of the star graph to create. Should be either \"in\", \"out\", \"mutual\" or \"undirected\"",
                        "center": "Vertex ID for the central vertex in the star."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Static_Fitness": {
                    "Description": "Generates a non-growing graph with edge probabilities proportional to node fitnesses.\nThe algorithm randomly selects vertex pairs and connects them until the given number of edges are created. Each vertex is selected with a probability proportional to its fitness; for directed graphs, a vertex is selected as a source proportional to its out-fitness and as a target proportional to its in-fitness.",
                    "Paramters": {
                        "m": "the nuber of edges in the graph",
                        "fitness_out": "a numeric vector with non-negative entries, one for each vertex. These values represent the fitness scores (out-fitness scores for directed graphs). fitness is an alias of this keyword argument.",
                        "fitness_in": "a numeric vector with non-negative entries, one for each vertex. These values represent the in-fitness scores for directed graphs. For undirected graphs, this argument must be None.",
                        "loops": "whether loop edges are allowed.",
                        "multiple": "whether  edges are allowed."
                    },
                    "Return": [
                        "a directed or undirected graph with the prescribed power-law degree distributions."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Static_Power_Law": {
                    "Description": "Generates a non-growing graph with prescribed power-law degree distributions.\n",
                    "Paramters": {
                        "n": "the umber of vertices i the graph",
                        "m": "the nuber of edges in the graph",
                        "exponent_out": "the exponent of the out-degree distribution, which must be between 2 and infinity (inclusive). When exponent_in is not given or negative, the graph will be undirected and this parameter specifies the degree distribution. exponent is an alias to this keyword argument.",
                        "exponent_in": "the exponent of the in-degree distribution, which must be between 2 and infinity (inclusive) It can also be negative, in which case an undirected graph will be generated.",
                        "loops": "whether loop edges are allowed.",
                        "multiple": "whether  edges are allowed.",
                        "finite_size_correction": "whether to apply a finite-size correction to the generated fitness values for exponents less than 3. See the paper of Cho et al for more details."
                    },
                    "Return": [
                        "a directed or undirected graph with the prescribed power-law degree distributions."
                    ],
                    "References": [
                        "Goh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.Cho YS, Kim JS, Park J, Kahng B, Kim D: Percolation transitions in scale-free networks under the Achlioptas process. Phys Rev Lett 103:135702, 2009."
                    ],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "strength": {
                    "Description": "Returns the strength (weighted degree) of some vertices from the graph\nThis method accepts a single vertex ID or a list of vertex IDs as a parameter, and returns the strength (that is, the sum of the weights of all incident edges) of the given vertices (in the form of a single integer or a list, depending on the input parameter).",
                    "Paramters": {
                        "vertices": "a single vertex ID or a list of vertex IDs",
                        "mode": "the type of degree to be returned (\"out\" for out-degrees, \"in\" for in-degrees or \"all\" for the sum of them).",
                        "loops": "whether self- should be counted.",
                        "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name. ``None`` means to treat the graph as unweighted, falling back to ordinary degree calculations."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "subcomponent": {
                    "Description": "Determines the indices of vertices which are in the same component as a given vertex.",
                    "Paramters": {
                        "v": "the index of the ertex used as the source/destination",
                        "mode": "if equals to \"in\", returns the vertex IDs from where the given vertex can be reached. If equals to \"out\", returns the vertex IDs which are reachable from the given vertex. If equals to \"all\", returns all vertices within the same component as the given vertex, ignoring edge directions. Note that this is not equal to calculating the union of the results of \"in\" and \"out\"."
                    },
                    "Return": [
                        "the indices of vertices which are in the same component as a given vertex."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "subgraph_edges": {
                    "Description": "Returns a subgraph spanned by the given edges.",
                    "Paramters": {
                        "edges": "a list containing the edge IDs which should be included in the result.",
                        "delete_vertices": "if True, vertices not incident on any of the specified edges will be deleted from the result. If False, all vertices will be kept."
                    },
                    "Return": [
                        "the subgraph"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "subisomorphic_lad": {
                    "Description": "Checks whether a subgraph of the graph is isomorphic to another graph.\nThe optional domains argument may be used to restrict vertices that may match each other. You can also specify whether you are interested in induced subgraphs only or not.",
                    "Paramters": {
                        "other": "the pattern graph we are looking for in the graph.",
                        "domains": "a list of lists, one sublist belonging to each vertex in the template graph. Sublist i contains the indices of the vertices in the original graph that may match vertex i in the template graph. None means that every vertex may match every other vertex.",
                        "induced": "whether to consider  subgraphs only.",
                        "time_limit": "an optimal time limit in seconds. Only the integral part of this number is taken into account. If the time limit is exceeded, the method will throw an exception.",
                        "return_mapping": "when True, the function will return a tuple, where the first element is a boolean denoting whether a subisomorphism has been found or not, and the second element describes the mapping of the vertices from the template graph to the original graph. When False, only the boolean is returned."
                    },
                    "Return": [
                        "if no mapping is calculated, the result is True if the graph contains a subgraph that is isomorphic to the given template, False otherwise. If the mapping is calculated, the result is a tuple, the first element being the above mentioned boolean, and the second element being the mapping from the target to the original graph."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "subisomorphic_vf2": {
                    "Description": "Checks whether a subgraph of the graph is isomorphic to another graph.\nVertex and edge colors may be used to restrict the isomorphisms, as only vertices and edges with the same color will be allowed to match each other.",
                    "Paramters": {
                        "other": "the  graph with which we want to compare the graph.",
                        "color1": "optional vector storing the coloring of the vertices of the first graph. If None, all vertices have the same color.",
                        "color2": "optional vector storing the coloring of the vertices of the second graph. If None, all vertices have the same color.",
                        "edge_color1": "optional vector storing the coloring of the edges of the first graph. If None, all edges have the same color.",
                        "edge_color2": "optional vector storing the coloring of the edges of the second graph. If None, all edges have the same color.",
                        "return_mapping_12": "if True, calculates the mapping which maps the vertices of the first graph to the second. The mapping can contain -1 if a given node is not mapped.",
                        "return_mapping_21": "if True, calculates the mapping which maps the vertices of the second graph to the first. The mapping can contain -1 if a given node is not mapped.",
                        "callback": "if not None, the subisomorphism search will not stop at the first match; it will call this  function instead for every subisomorphism found. The  function must accept four arguments: the first graph, the second graph, a mapping from the nodes of the first graph to the second, and a mapping from the nodes of the second graph to the first. The function must return True if the search should continue or False otherwise.",
                        "node_compat_fn": "a function that receives the two graphs and two node indices (one from the first graph, one from the second graph) and returns True if the nodes given by the two indices are compatible (i.e. they could be matched to each other) or False otherwise. This can be used to restrict the set of isomorphisms based on node-specific criteria that are too complicated to be represented by node color vectors (i.e. the color1 and color2 parameters). None means that every node is compatible with every other node.",
                        "edge_compat_fn": "a function that receives the two graphs and two edge indices (one from the first graph, one from the second graph) and returns True if the edges given by the two indices are compatible (i.e. they could be matched to each other) or False otherwise. This can be used to restrict the set of isomorphisms based on edge-specific criteria that are too complicated to be represented by edge color vectors (i.e. the edge_color1 and edge_color2 parameters). None means that every edge is compatible with every other node."
                    },
                    "Return": [
                        "if no mapping is calculated, the result is True if the graph contains a subgraph that's isomorphic to the given one, False otherwise. If any or both mappings are calculated, the result is a 3-tuple, the first element being the above mentioned boolean, the second element being the 1 -> 2 mapping and the third element being the 2 -> 1 mapping. If the corresponding mapping was not calculated, None is returned in the appropriate element of the 3-tuple."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "successors": {
                    "Description": "Returns the successors of a given vertex.\nEquivalent to calling the neighbors() method with type=\"out\".",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "to_directed": {
                    "Description": "Converts an undirected graph to directed.",
                    "Paramters": {
                        "mode": "specifies how to convert undirected edges into directed ones. True or \"mutual\" creates a mutual edge pair for each undirected edge. False or \"arbitrary\" picks an arbitrary (but deterministic) edge direction for each edge. \"random\" picks a random direction for each edge. \"acyclic\" picks the edge directions in a way that the resulting graph will be acyclic if there were no self-loops in the original graph."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "to_prufer": {
                    "Description": "Converts a tree graph into a Pr\u00fcfer sequence.",
                    "Paramters": {},
                    "Return": [
                        "the Pr\u00fcfer sequence as a list"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "to_undirected": {
                    "Description": "Converts a directed graph to undirected.",
                    "Paramters": {
                        "mode": "specifies what to do with multiple directed edges going between the same vertex pair. True or \"collapse\" means that only a single edge should be created from multiple directed edges. False or \"each\" means that every edge will be kept (with the arrowheads removed). \"mutual\" creates one undirected edge for each mutual directed edge pair.",
                        "combine_edges": "specifies how to combine the attributes of multiple edges between the same pair of vertices into a single attribute. See simplify() for more details."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "topological_sorting": {
                    "Description": "Calculates a possible topological sorting of the graph.\nReturns a partial sorting and issues a warning if the graph is not a directed acyclic graph.",
                    "Paramters": {
                        "mode": "if \"out\", vertices are returned according to the forward topological order -- all vertices come before their successors. If \"in\", all vertices come before their ancestors."
                    },
                    "Return": [
                        "a possible topological ordering as a list"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "transitivity_avglocal_undirected": {
                    "Description": "overridden in igraph.Graph\nCalculates the average of the vertex transitivities of the graph.\nThe transitivity measures the probability that two neighbors of a vertex are connected. In case of the average local transitivity, this probability is calculated for each vertex and then the average is taken. Vertices with less than two neighbors require special treatment, they will either be left out from the calculation or they will be considered as having zero transitivity, depending on the mode parameter.\nNote that this measure is different from the global transitivity measure (see transitivity_undirected()) as it simply takes the average local transitivity across the whole network.\nReference: D. J. Watts and S. Strogatz: Collective dynamics of small-world networks. Nature 393(6884):440-442, 1998.",
                    "Paramters": {
                        "mode": "defines how to treat vertices with degree less than two. If TRANSITIVITT_ZERO or \"zero\", these vertices will have zero transitivity. If TRANSITIVITY_NAN or \"nan\", these vertices will be excluded from the average."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "transitivity_undirected(), transitivity_local_undirected()",
                    "example": []
                },
                "transitivity_local_undirected": {
                    "Description": "Calculates the local transitivity (clustering coefficient) of the given vertices in the graph.\nThe transitivity measures the probability that two neighbors of a vertex are connected. In case of the local transitivity, this probability is calculated separately for each vertex.\nNote that this measure is different from the global transitivity measure (see transitivity_undirected()) as it calculates a transitivity value for each vertex individually.\nThe traditional local transitivity measure applies for unweighted graphs only. When the weights argument is given, this function calculates the weighted local transitivity proposed by Barrat et al (see references).\n",
                    "Paramters": {
                        "vertices": "a list containing the vertex IDs which should be included in the result. None means all of the .",
                        "mode": "defines how to treat vertices with degree less than two. If TRANSITIVITT_ZERO or \"zero\", these vertices will have zero transitivity. If TRANSITIVITY_NAN or \"nan\", these vertices will have NaN (not a number) as their transitivity.",
                        "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name."
                    },
                    "Return": [
                        "the transitivities for the given vertices in a list"
                    ],
                    "References": [
                        ":D. J. Watts and S. Strogatz: Collective dynamics of small-world networks. Nature 393(6884):440-442, 1998.Barrat A, Barthelemy M, Pastor-Satorras R and Vespignani A: The architecture of complex weighted networks. PNAS 101, 3747 (2004). http://arxiv.org/abs/cond-mat/0311416."
                    ],
                    "Rasises": {},
                    "See Also": "transitivity_undirected(), transitivity_avglocal_undirected()",
                    "example": []
                },
                "transitivity_undirected": {
                    "Description": "Calculates the global transitivity (clustering coefficient) of the graph.\nThe transitivity measures the probability that two neighbors of a vertex are connected. More precisely, this is the ratio of the triangles and connected triplets in the graph. The result is a single real number. Directed graphs are considered as undirected ones.\nNote that this measure is different from the local transitivity measure (see transitivity_local_undirected()) as it calculates a single value for the whole graph.\nReference: S. Wasserman and K. Faust: Social Network Analysis: Methods and Applications. Cambridge: Cambridge University Press, 1994.",
                    "Paramters": {
                        "mode": "if TRANSITIVITY_ZERO or \"zero\", the result will be zero if the graph does not have any triplets. If \"nan\" or TRANSITIVITY_NAN, the result will be NaN (not a number)."
                    },
                    "Return": [
                        "the transitivity"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "transitivity_local_undirected(), transitivity_avglocal_undirected()",
                    "example": []
                },
                "Tree": {
                    "Description": "Generates a tree in which almost all vertices have the same number of children.",
                    "Paramters": {
                        "n": "the umber of vertices i the graph",
                        "children": "the number of  of a vertex in the graph",
                        "mode": "determines whether the tree should be directed, and if this is the case, also its orientation. Must be one of \"in\", \"out\" and \"undirected\"."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Tree_Game": {
                    "Description": "Generates a random tree by sampling uniformly from the set of labelled trees with a given number of nodes.",
                    "Paramters": {
                        "n": "the umber of vertices i the tree",
                        "directed": "whether the graph should be ",
                        "method": "the generation  to be used. One of the following:\"prufer\" -- samples Pr\u00fcfer sequences uniformly, then converts them to trees\"lerw\" -- performs a loop-erased random walk on the complete graph to uniformly sample its spanning trees (Wilson's algorithm). This is the default choice as it supports both directed and undirected graphs."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "triad_census": {
                    "Description": "overridden in igraph.Graph\nTriad census, as defined by Davis and Leinhardt\nCalculating the triad census means classifying every triplets of vertices in a directed graph. A triplet can be in one of 16 states, these are listed in the documentation of the C interface of igraph.\nAttention: this function has a more convenient interface in class Graph, which wraps the result in a TriadCensus object. It is advised to use that. The name of the triplet classes are also documented there.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Triangular_Lattice": {
                    "Description": "Generates a regular triangular lattice.",
                    "Paramters": {
                        "dim": "list with the ensions of the lattice",
                        "directed": "whether to create a  graph.",
                        "mutual": "whether to create all connections as  in case of a directed graph."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "unfold_tree": {
                    "Description": "Unfolds the graph using a BFS to a tree by duplicating vertices as necessary.",
                    "Paramters": {
                        "sources": "the source vertices to start the unfolding from. It should be a list of vertex indices, preferably one vertex from each connected component. You can use topological_sorting() to determine a suitable set. A single vertex index is also accepted.",
                        "mode": "which edges to follow during the BFS. OUT follows outgoing edges, IN follows incoming edges, ALL follows both. Ignored for undirected graphs."
                    },
                    "Return": [
                        "the unfolded tree graph and a mapping from the new vertex indices to the old ones."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "vcount": {
                    "Description": "Counts the number of vertices.",
                    "Paramters": {},
                    "Return": [
                        "integerthe number of vertices in the graph."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "vertex_attributes": {
                    "Description": "",
                    "Paramters": {},
                    "Return": [
                        "the attribute name list of the vertices of the graph"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "vertex_coloring_greedy": {
                    "Description": "Calculates a greedy vertex coloring for the graph based on some heuristics.",
                    "Paramters": {
                        "method": "the heuristics to use. colored_neighbors always picks the vertex with the largest number of colored neighbors as the next vertex to pick a color for. dsatur picks the vertex with the largest number of unique colors in its neighborhood; this is also known as the DSatur heuristics (hence the name)."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "vertex_connectivity": {
                    "Description": "Calculates the vertex connectivity of the graph or between some vertices.\nThe vertex connectivity between two given vertices is the number of vertices that have to be removed in order to disconnect the two vertices into two separate components. This is also the number of vertex disjoint directed paths between the vertices (apart from the source and target vertices of course). The vertex connectivity of the graph is the minimal vertex connectivity over all vertex pairs.\nThis method calculates the vertex connectivity of a given vertex pair if both the source and target vertices are given. If none of them is given (or they are both negative), the overall vertex connectivity is returned.",
                    "Paramters": {
                        "source": "the  vertex involved in the calculation.",
                        "target": "the  vertex involved in the calculation.",
                        "checks": "if the whole graph connectivity is calculated and this is True, igraph performs some basic  before calculation. If the graph is not strongly connected, then the connectivity is obviously zero. If the minimum degree is one, then the connectivity is also one. These simple  are much faster than checking the entire graph, therefore it is advised to set this to True. The parameter is ignored if the connectivity between two given vertices is computed.",
                        "neighbors": "tells igraph what to do when the two vertices are connected. \"error\" raises an exception, \"negative\" returns a negative value, \"number_of_nodes\" or \"nodes\" returns the number of nodes, or \"ignore\" ignores the edge."
                    },
                    "Return": [
                        "the vertex connectivity"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Watts_Strogatz": {
                    "Description": "This function generates networks with the small-world property based on a variant of the Watts-Strogatz model. The network is obtained by first creating a periodic undirected lattice, then rewiring both endpoints of each edge with probability p, while avoiding the creation of multi-edges.\nThis process differs from the original model of Watts and Strogatz (see reference) in that it rewires both endpoints of edges. Thus in the limit of p=1, we obtain a G(n,m) random graph with the same number of vertices and edges as the original lattice. In comparison, the original Watts-Strogatz model only rewires a single endpoint of each edge, thus the network does not become fully random even for <code>p=1</code>.\nFor appropriate choices of p, both models exhibit the property of simultaneously having short path lengths and high clustering.\nReference: Duncan J Watts and Steven H Strogatz: Collective dynamics of small world networks, Nature 393, 440-442, 1998",
                    "Paramters": {
                        "dim": "the ension of the lattice",
                        "size": "the  of the lattice along all dimensions",
                        "nei": "value giving the distance (number of steps) within which two vertices will be connected.",
                        "p": "rewiring robability",
                        "loops": "specifies whether loop edges are allowed",
                        "multiple": "specifies whether  edges are allowed"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "Lattice(), rewire(), rewire_edges() if more flexibility is needed",
                    "example": []
                },
                "write_dimacs": {
                    "Description": "overridden in igraph.Graph\nWrites the graph in DIMACS format to the given file.",
                    "Paramters": {
                        "f": "the name o the ile to be written or a Python ile handle",
                        "source": "the  vertex ID",
                        "target": "the  vertex ID",
                        "capacity": "the capacities of the edges in a list. If it is not a list, the corresponding edge attribute will be used to retrieve capacities."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "write_dot": {
                    "Description": "Writes the graph in DOT format to the given file.\nDOT is the format used by the GraphViz software package.",
                    "Paramters": {
                        "f": "the name o the ile to be written or a Python ile handle"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "write_edgelist": {
                    "Description": "Writes the edge list of a graph to a file.\nDirected edges are written in (from, to) order.",
                    "Paramters": {
                        "f": "the name o the ile to be written or a Python ile handle"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "write_gml": {
                    "Description": "Writes the graph in GML format to the given file.",
                    "Paramters": {
                        "f": "the name o the ile to be written or a Python ile handle",
                        "creator": "optional  information to be written to the file. If None, the current date and time is added.",
                        "ids": "optional numeric vertex IDs to use in the file. This must be a list of integers or None. If None, the id attribute of the vertices are used, or if they don't exist, numeric vertex IDs will be generated automatically."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "write_graphml": {
                    "Description": "Writes the graph to a GraphML file.",
                    "Paramters": {
                        "f": "the name o the ile to be written or a Python ile handle"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "write_leda": {
                    "Description": "Writes the graph to a file in LEDA native format.\nThe LEDA format supports at most one attribute per vertex and edge. You can specify which vertex and edge attribute you want to use. Note that the name of the attribute is not saved in the LEDA file.",
                    "Paramters": {
                        "f": "the name o the ile to be written or a Python ile handle",
                        "names": "the name of the vertex attribute to be stored along with the vertices. It is usually used to store the vertex  (hence the name of the keyword argument), but you may also use a numeric attribute. If you don't want to store any vertex attributes, supply None here.",
                        "weights": "the name of the edge attribute to be stored along with the edges. It is usually used to store the edge  (hence the name of the keyword argument), but you may also use a string attribute. If you don't want to store any edge attributes, supply None here."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "write_lgl": {
                    "Description": "Writes the edge list of a graph to a file in .lgl format.\nNote that multiple edges and/or loops break the LGL software, but igraph does not check for this condition. Unless you know that the graph does not have multiple edges and/or loops, it is wise to call simplify() before saving.",
                    "Paramters": {
                        "f": "the name o the ile to be written or a Python ile handle",
                        "names": "the name of the vertex attribute containing the name of the vertices. If you don't want to store vertex , supply None here.",
                        "weights": "the name of the edge attribute containing the weight of the vertices. If you don't want to store , supply None here.",
                        "isolates": "whether to include isolated vertices in the output."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "write_ncol": {
                    "Description": "Writes the edge list of a graph to a file in .ncol format.\nNote that multiple edges and/or loops break the LGL software, but igraph does not check for this condition. Unless you know that the graph does not have multiple edges and/or loops, it is wise to call simplify() before saving.",
                    "Paramters": {
                        "f": "the name o the ile to be written or a Python ile handle",
                        "names": "the name of the vertex attribute containing the name of the vertices. If you don't want to store vertex , supply None here.",
                        "weights": "the name of the edge attribute containing the weight of the vertices. If you don't want to store , supply None here."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "write_pajek": {
                    "Description": "Writes the graph in Pajek format to the given file.",
                    "Paramters": {
                        "f": "the name o the ile to be written or a Python ile handle"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "Types",
        "Description": "Static class for the implementation of custom getter/setter functions for configuration keys",
        "Field List": {
            "Methods": {
                "setboolean": {
                    "Description": "Sets a boolean value in the given configuration object.",
                    "Paramters": {
                        "obj": "a configuration ect",
                        "section": "the  of the value to be set",
                        "key": "the  of the value to be set",
                        "value": "the  itself. 0, false, no and off means false, 1, true, yes and on means true, everything else results in a ValueError being thrown. Values are case-insensitive"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "setfloat": {
                    "Description": "Sets a float value in the given configuration object.\nNote that float values are converted to strings in the configuration object, which may lead to some precision loss.",
                    "Paramters": {
                        "obj": "a configuration ect",
                        "section": "the  of the value to be set",
                        "key": "the  of the value to be set",
                        "value": "the  itself."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "setint": {
                    "Description": "Sets an integer value in the given configuration object.",
                    "Paramters": {
                        "obj": "a configuration ect",
                        "section": "the  of the value to be set",
                        "key": "the  of the value to be set",
                        "value": "the  itself."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "PlotlyEdgeDrawer",
        "Description": "Matplotlib-specific abstract edge drawer object.",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "Constructs the edge drawer.",
                    "Paramters": {
                        "context": "a plotly Figure object on which the edges will be drawn.",
                        "palette": "the  that can be used to map integer color indices to colors when drawing edges"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw_directed_edge": {
                    "Description": "overrides igraph.drawing.baseclasses.AbstractEdgeDrawer.draw_directed_edge\nDraws a directed edge.",
                    "Paramters": {
                        "edge": "the  to be drawn. Visual properties of the  are defined by the attributes of this object.",
                        "src_vertex": "the source vertex. Visual properties are defined by the attributes of this object.",
                        "dest_vertex": "the source vertex. Visual properties are defined by the attributes of this object."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw_loop_edge": {
                    "Description": "Draws a loop edge.\nThe default implementation draws a small circle.",
                    "Paramters": {
                        "edge": "the  to be drawn. Visual properties of the  are defined by the attributes of this object.",
                        "vertex": "the  to which the edge is attached. Visual properties are given again as attributes."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw_undirected_edge": {
                    "Description": "overrides igraph.drawing.baseclasses.AbstractEdgeDrawer.draw_undirected_edge\nDraws an undirected edge.\nThe default implementation of this method draws undirected edges as straight lines. Loop edges are drawn as small circles.",
                    "Paramters": {
                        "edge": "the  to be drawn. Visual properties of the  are defined by the attributes of this object.",
                        "src_vertex": "the source vertex. Visual properties are given again as attributes.",
                        "dest_vertex": "the target vertex. Visual properties are given again as attributes."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_label_position": {
                    "Description": "Inherited from AbstractEdgeDrawer:Returns the position where the label of an edge should be drawn. the default implementation returns the midpoint of the edge and an alignment that tries to avoid overlapping the label with the edge."
                },
                "get_label_rotation": {
                    "Description": "Inherited from AbstractEdgeDrawer:Get the rotation angle of the label to align with the edge."
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "MatplotlibVertexDrawer",
        "Description": "Matplotlib backend-specific vertex drawer.",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "overrides igraph.drawing.baseclasses.AbstractVertexDrawer.__init__\nConstructs the vertex drawer and associates it to the given palette.",
                    "Paramters": {
                        "ax": "Undocumented",
                        "palette": "the  that can be used to map integer color indices to colors when drawing vertices",
                        "layout": "the  of the vertices in the graph being drawn"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw": {
                    "Description": "overrides igraph.drawing.baseclasses.AbstractVertexDrawer.draw\nBuild the Artist for a vertex and return it.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "DownTriangleDrawer",
        "Description": "Static class which draws triangles pointing down",
        "Field List": {
            "Methods": {
                "draw_path": {
                    "Description": "overrides igraph.drawing.shapes.ShapeDrawer.draw_path\nDraws a triangle on the Cairo context without stroking or filling it.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "ShapeDrawer.draw_path",
                    "example": []
                },
                "intersection_point": {
                    "Description": "overrides igraph.drawing.shapes.ShapeDrawer.intersection_point\nDetermines where the triangle centered at (center_x, center_y) intersects with a line drawn from (source_x, source_y) to (center_x, center_y).",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "ShapeDrawer.intersection_point",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "TextAlignment",
        "Description": "Text alignment constants.",
        "Field List": {
            "Methods": {},
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "FakeWrapper",
        "Description": "Object whose interface is compatible with textwrap.TextWrapper but does no wrapping.",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "fill": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "wrap": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "mpl",
        "Description": "Undocumented"
    },
    {
        "Section_id": "_",
        "Description": "Undocumented"
    },
    {
        "Section_id": "AdvancedGradientPalette",
        "Description": "Advanced gradient that consists of more than two base colors.\n",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "overrides igraph.drawing.colors.Palette.__init__\nCreates an advanced gradient palette",
                    "Paramters": {
                        "colors": "the  in the gradient.",
                        "indices": "the color  belonging to the given colors. If None, the colors are distributed equidistantly",
                        "n": "the total umber of colors i the palette"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__len__": {
                    "Description": "Inherited from Palette:Returns the number of colors in this palette"
                },
                "__plot__": {
                    "Description": "Inherited from Palette:Plots the colors of the palette on the given Cairo context/mpl Axes"
                },
                "__repr__": {
                    "Description": "Inherited from Palette:Undocumented"
                },
                "clear_cache": {
                    "Description": "Inherited from Palette:Clears the result cache."
                },
                "get": {
                    "Description": "Inherited from Palette:Returns the given color from the palette."
                },
                "get_many": {
                    "Description": "Inherited from Palette:Returns multiple colors from the palette."
                }
            },
            "property": {
                "length": "Inherited from Palette:Returns the number of colors in this palette"
            }
        },
        "Rubric": {
            "Example": [
                "Example:\n>>> pal = AdvancedGradientPalette([\"red\", \"black\", \"blue\"], n=9)\n>>> pal.get(2)\n(0.5, 0.0, 0.0, 1.0)\n>>> pal.get(7)\n(0.0, 0.0, 0.75, 1.0)\n"
            ]
        }
    },
    {
        "Section_id": "AbstractCairoDrawer",
        "Description": "Abstract class that serves as a base class for anything that draws on a Cairo context within a given bounding box.\nA subclass of AbstractCairoDrawer is guaranteed to have an attribute named context that represents the Cairo context to draw on, and an attribute named bbox for the BoundingBox of the drawing area.",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "overridden in igraph.drawing.cairo.coord.DescartesCoordinateSystem, igraph.drawing.cairo.dendrogram.CairoDendrogramDrawer, igraph.drawing.cairo.graph.AbstractCairoGraphDrawer, igraph.drawing.cairo.histogram.CairoHistogramDrawer, igraph.drawing.cairo.matrix.CairoMatrixDrawer, igraph.drawing.cairo.palette.CairoPaletteDrawer, igraph.drawing.cairo.polygon.CairoPolygonDrawer, igraph.drawing.cairo.text.CairoTextDrawer, igraph.drawing.cairo.vertex.AbstractCairoVertexDrawer\nConstructs the drawer and associates it to the given Cairo context and the given BoundingBox.",
                    "Paramters": {
                        "context": "the  on which we will draw",
                        "bbox": ":BoundingBox or Nonethe bounding box within which we will draw. Can be anything accepted by the constructor of BoundingBox (i.e., a 2-tuple, a 4-tuple or a BoundingBox object)."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "bbox": {
                    "Description": "overridden in igraph.drawing.cairo.coord.DescartesCoordinateSystem\nSets the bounding box of the drawing area where this drawer will draw.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw": {
                    "Description": "Inherited from AbstractDrawer:Abstract method, must be implemented in derived classes."
                }
            },
            "property": {
                "bbox": "overridden in igraph.drawing.cairo.coord.DescartesCoordinateSystem, igraph.drawing.cairo.graph.CairoGraphDrawer, igraph.drawing.cairo.histogram.CairoHistogramDrawer, igraph.drawing.cairo.matrix.CairoMatrixDrawer, igraph.drawing.cairo.palette.CairoPaletteDrawer\nThe bounding box of the drawing area where this drawer will draw.\n"
            }
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "mean",
        "Description": "Returns the mean of an iterable.\nExample:>>> mean([1, 4, 7, 11])5.75",
        "Paramters": {
            "xs": "an iterable yielding numbers."
        },
        "Return": [
            "the mean of the numbers provided by the iterable."
        ],
        "Raises": {},
        "References": [],
        "See Also": "RunningMean() if you also need the variance or the standard deviation"
    },
    {
        "Section_id": "median",
        "Description": "Returns the median of an unsorted or sorted numeric vector.",
        "Paramters": {
            "xs": "the vector itself.",
            "sort": "whether to  the vector. If you know that the vector is ed already, pass False here."
        },
        "Return": [
            "the median, which will always be a float, even if the vector contained integers originally."
        ],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "percentile",
        "Description": "Returns the pth percentile of an unsorted or sorted numeric vector.\nThis is equivalent to calling quantile(xs, p/100.0); see quantile for more details on the calculation.\nExample:>>> round(percentile([15, 20, 40, 35, 50], 40), 2)26.0>>> for perc in percentile([15, 20, 40, 35, 50], (0, 25, 50, 75, 100)):...     print(\"%.2f\" % perc)...15.0017.5035.0045.0050.00",
        "Paramters": {
            "xs": "the vector itself.",
            "p": "the ercentile we are looking for. It may also be a list if you want to calculate multile quantiles with a single call. The default value calculates the 25th, 50th and 75th ercentile.",
            "sort": "whether to  the vector. If you know that the vector is ed already, pass False here."
        },
        "Return": [
            "the pth percentile, which will always be a float, even if the vector contained integers originally. If p is a list, the result will also be a list containing the percentiles for each item in the list."
        ],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "power_law_fit",
        "Description": "Fitting a power-law distribution to empirical data\n",
        "Paramters": {
            "data": "the  to fit, a list containing integer values",
            "xmin": "the lower bound for fitting the power-law. If None, the optimal  value will be estimated as well. Zero means that the smallest possible  value will be used.",
            "method": "the fitting  to use. The following s are implemented so far:continuous, hill: exact maximum likelihood estimation when the input data comes from a continuous scale. This is known as the Hill estimator. The statistical error of this estimator is (alpha\u2009\u2212\u20091)\u2009\u2044\u2009sqrt(n), where alpha is the estimated exponent and n is the number of data points above xmin. The estimator is known to exhibit a small finite sample-size bias of order O(n\u2009\u2212\u20091), which is small when n\u2009>\u2009100. igraph will try to compensate for the finite sample size if n is small.discrete: exact maximum likelihood estimation when the input comes from a discrete scale (see Clauset et al. among the references).auto: exact maximum likelihood estimation where the continuous  is used if the input vector contains at least one fractional value and the discrete  is used if the input vector contains integers only.",
            "p_precision": "desired precision of the p-value calculation. The precision ultimately depends on the number of resampling attempts. The number of resampling trials is determined by 0.25 divided by the square of the required precision. For instance, a required precision of 0.01 means that 2500 samples will be drawn."
        },
        "Return": [
            "a FittedPowerLaw object. The fitted xmin value and the power-law exponent can be queried from the xmin and alpha properties of the returned object."
        ],
        "Raises": {},
        "References": [
            "MEJ Newman: Power laws, Pareto distributions and Zipf's law. Contemporary Physics 46, 323-351 (2005)",
            "A Clauset, CR Shalizi, MEJ Newman: Power-law distributions in empirical data. E-print (2007). arXiv:0706.1062"
        ],
        "See Also": ""
    },
    {
        "Section_id": "quantile",
        "Description": "Returns the qth quantile of an unsorted or sorted numeric vector.\nThere are a number of different ways to calculate the sample quantile. The method implemented by igraph is the one recommended by NIST. First we calculate a rank n as q(N+1), where N is the number of items in xs, then we split n into its integer component k and decimal component d. If k <= 1, we return the first element; if k >= N, we return the last element, otherwise we return the linear interpolation between xs[k-1] and xs[k] using a factor d.\nExample:>>> round(quantile([15, 20, 40, 35, 50], 0.4), 2)26.0",
        "Paramters": {
            "xs": "the vector itself.",
            "q": "the uantile we are looking for. It may also be a list if you want to calculate multiple uantiles with a single call. The default value calculates the 25th, 50th and 75th percentile.",
            "sort": "whether to  the vector. If you know that the vector is ed already, pass False here."
        },
        "Return": [
            "the qth quantile, which will always be a float, even if the vector contained integers originally. If q is a list, the result will also be a list containing the quantiles for each item in the list."
        ],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "sd",
        "Description": "Returns the standard deviation of an iterable.\nExample:>>> sd([1, 4, 7, 11])       #doctest:+ELLIPSIS4.2720...",
        "Paramters": {
            "xs": "an iterable yielding numbers."
        },
        "Return": [
            "the standard deviation of the numbers provided by the iterable."
        ],
        "Raises": {},
        "References": [],
        "See Also": "RunningMean() if you also need the mean"
    },
    {
        "Section_id": "var",
        "Description": "Returns the variance of an iterable.\nExample:>>> var([1, 4, 8, 11])            #doctest:+ELLIPSIS19.333333...",
        "Paramters": {
            "xs": "an iterable yielding numbers."
        },
        "Return": [
            "the variance of the numbers provided by the iterable."
        ],
        "Raises": {},
        "References": [],
        "See Also": "RunningMean() if you also need the mean"
    },
    {
        "Section_id": "construct_graph_from_formula",
        "Description": "Graph.Formula(formula = None, attr = \"name\", simplify = True)\nGenerates a graph from a graph formula\nA graph formula is a simple string representation of a graph. It is very handy for creating small graphs quickly. The string consists of vertex names separated by edge operators. An edge operator is a sequence of dashes (-) that may or may not start with an arrowhead (< at the beginning of the sequence or > at the end of the sequence). The edge operators can be arbitrarily long, i.e., you may use as many dashes to draw them as you like. This makes a total of four different edge operators:----- makes an undirected edge<---- makes a directed edge pointing from the vertex on the right hand side of the operator to the vertex on the left hand side----> is the opposite of <----<---> creates a mutual directed edge pair between the two vertices\nIf you only use the undirected edge operator (-----), the graph will be undirected. Otherwise it will be directed. Vertex names used in the formula will be assigned to the name vertex attribute of the graph.\nSome simple examples:>>> from igraph import Graph>>> print(Graph.Formula())          # empty graphIGRAPH UN-- 0 0 --+ attr: name (v)>>> g = Graph.Formula(\"A-B\")        # undirected graph>>> g.vs[\"name\"]['A', 'B']>>> print(g)IGRAPH UN-- 2 1 --+ attr: name (v)+ edges (vertex names):A--B>>> g.get_edgelist()[(0, 1)]>>> g2 = Graph.Formula(\"A-----------B\")>>> g2.isomorphic(g)True>>> g = Graph.Formula(\"A  --->  B\") # directed graph>>> g.vs[\"name\"]['A', 'B']>>> print(g)IGRAPH DN-- 2 1 --+ attr: name (v)+ edges (vertex names):A->B\nIf you have many disconnected componnets, you can separate them with commas. You can also specify isolated vertices:>>> g = Graph.Formula(\"A--B, C--D, E--F, G--H, I, J, K\")>>> print(\", \".join(g.vs[\"name\"]))A, B, C, D, E, F, G, H, I, J, K>>> g.connected_components().membership[0, 0, 1, 1, 2, 2, 3, 3, 4, 5, 6]\nThe colon (:) operator can be used to specify vertex sets. If an edge operator connects two vertex sets, then every vertex from the first vertex set will be connected to every vertex in the second set:>>> g = Graph.Formula(\"A:B:C:D --- E:F:G\")>>> g.isomorphic(Graph.Full_Bipartite(4, 3))True\nNote that you have to quote vertex names if they include spaces or special characters:>>> g = Graph.Formula('\"this is\" +- \"a silly\" -+ \"graph here\"')>>> g.vs[\"name\"]['this is', 'a silly', 'graph here']",
        "Paramters": {
            "cls": "Undocumented",
            "formula": "the  itself",
            "attr": "name of the vertex ibute where the vertex names will be stored",
            "simplify": "whether to  the constructed graph"
        },
        "Return": [
            "the constructed graph:"
        ],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "generate_edges",
        "Description": "Parses an edge specification from the head of the given formula part and yields the following:startpoint(s) of the edge by vertex namesendpoint(s) of the edge by names or an empty list if the vertices are isolateda pair of bools to denote whether we had arrowheads at the start and end vertices",
        "Paramters": {},
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "Histogram",
        "Description": "Generic histogram class for real numbers\n",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "Initializes the histogram with the given data set.",
                    "Paramters": {
                        "bin_width": "the bin width of the histogram.",
                        "data": "the  set to be used. Must contain real numbers."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__plot__": {
                    "Description": "Plotting support",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__str__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "add": {
                    "Description": "Adds a single number to the histogram.",
                    "Paramters": {
                        "num": "the ber to be added",
                        "repeat": "number of ed additions"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "add_many": {
                    "Description": "Adds a single number or the elements of an iterable to the histogram.",
                    "Paramters": {
                        "data": "the  to be added"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "bins": {
                    "Description": "Generator returning the bins of the histogram in increasing order",
                    "Paramters": {},
                    "Return": [
                        "a tuple with the following elements: left bound, right bound, number of elements in the bin"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "clear": {
                    "Description": "Clears the collected data",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "to_string": {
                    "Description": "Returns the string representation of the histogram.",
                    "Paramters": {
                        "max_width": "the maximal width of each line of the string This value may not be obeyed if it is too small.",
                        "show_bars": "specify whether the histogram bars should be shown",
                        "show_counts": "specify whether the histogram counts should be shown. If both show_bars and  are False, only a general descriptive statistics (number of elements, mean and standard deviation) is shown."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {
                "mean": "Returns the mean of the elements in the histogram\n",
                "n": "Returns the number of elements in the histogram\n",
                "sd": "Returns the standard deviation of the elements in the histogram\n",
                "var": "Returns the variance of the elements in the histogram\n"
            }
        },
        "Rubric": {
            "Example": [
                "Example:\n>>> h = Histogram(5)     # Initializing, bin width = 5\n>>> h << [2,3,2,7,8,5,5,0,7,9]     # Adding more items\n>>> print(h)\nN = 10, mean +- sd: 4.8000 +- 2.9740\n[ 0,  5): **** (4)\n[ 5, 10): ****** (6)\n"
            ]
        }
    },
    {
        "Section_id": "Cover",
        "Description": "Class representing a cover of an arbitrary ordered set.\nCovers are similar to clusterings, but each element of the set may belong to more than one cluster in a cover, and elements not belonging to any cluster are also allowed.\nCover instances provide a similar API as Clustering instances; for instance, iterating over a Cover will iterate over the clusters just like with a regular Clustering instance. However, they are not derived from each other or from a common superclass, and there might be functions that exist only in one of them or the other.\n",
        "Field List": {
            "Methods": {
                "__getitem__": {
                    "Description": "Returns the cluster with the given index.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__init__": {
                    "Description": "overridden in igraph.VertexCover\nConstructs a cover with the given clusters.",
                    "Paramters": {
                        "clusters": "the  in this cover, as a list or iterable. Each cluster is specified by a list or tuple that contains the IDs of the items in this cluster. IDs start from zero.",
                        "n": "the total umber of elemets i the set that is covered by this cover. If it is less tha the umber of uique elemets foud i all the clusters, we will simply use the umber of uique elemets, so it is safe to leave this at zero. You oly have to specify this parameter if there are some elemets that are covered by oe of the clusters."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__iter__": {
                    "Description": "Iterates over the clusters in this cover.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__len__": {
                    "Description": "Returns the number of clusters in this cover.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__str__": {
                    "Description": "Returns a string representation of the cover.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "size": {
                    "Description": "Returns the size of a given cluster.",
                    "Paramters": {
                        "idx": "the cluster in which we are interested."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "size_histogram": {
                    "Description": "Returns the histogram of cluster sizes.",
                    "Paramters": {
                        "bin_width": "the bin width of the histogram"
                    },
                    "Return": [
                        "a Histogram object"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "sizes": {
                    "Description": "Returns the size of given clusters.\nThe indices are given as positional arguments. If there are no positional arguments, the function will return the sizes of all clusters.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "summary": {
                    "Description": "Returns the summary of the cover.\nThe summary includes the number of items and clusters, and also the list of members for each of the clusters if the verbosity is nonzero.",
                    "Paramters": {
                        "verbosity": "determines whether the cluster members should be printed. Zero  prints the number of items and clusters only.",
                        "width": "Undocumented"
                    },
                    "Return": [
                        "the summary of the cover as a string."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {
                "membership": "Returns the membership vector of this cover.\nThe membership vector of a cover covering n elements is a list of length n, where element i contains the cluster indices of the ith item.\n\n",
                "n": "Returns the number of elements in the set covered by this cover.\n"
            }
        },
        "Rubric": {
            "Example": [
                "Clusters of an individual cover can be accessed by the [] operator:\n>>> cl = Cover([[0,1,2,3], [2,3,4], [0,1,6]])\n>>> cl[0]\n[0, 1, 2, 3]\n",
                "The membership vector can be accessed by the membership property. Note that contrary to Clustering instances, the membership vector will contain lists that contain the cluster indices each item belongs to:\n>>> cl = Cover([[0,1,2,3], [2,3,4], [0,1,6]])\n>>> cl[0]\n[0, 1, 2, 3]\n",
                "The number of clusters can be retrieved by the len function:\n>>> cl = Cover([[0,1,2,3], [2,3,4], [0,1,6]])\n>>> cl[0]\n[0, 1, 2, 3]\n",
                "You can iterate over the cover as if it were a regular list of clusters:\n>>> cl = Cover([[0,1,2,3], [2,3,4], [0,1,6]])\n>>> cl[0]\n[0, 1, 2, 3]\n",
                "If you need all the clusters at once as lists, you can simply convert the cover to a list:\n>>> cl = Cover([[0,1,2,3], [2,3,4], [0,1,6]])\n>>> cl[0]\n[0, 1, 2, 3]\n",
                "Clustering objects can readily be converted to Cover objects using the constructor:\n>>> cl = Cover([[0,1,2,3], [2,3,4], [0,1,6]])\n>>> cl[0]\n[0, 1, 2, 3]\n"
            ]
        }
    },
    {
        "Section_id": "clamp",
        "Description": "Clamps the given value between min and max",
        "Paramters": {},
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "color_name_to_rgb",
        "Description": "Converts a color given in one of the supported color formats to R-G-B values.\nThis is done by calling color_name_to_rgba and then throwing away the alpha value.",
        "Paramters": {},
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": "color_name_to_rgba for more details about what formats are understood by this function."
    },
    {
        "Section_id": "color_name_to_rgba",
        "Description": "Converts a color given in one of the supported color formats to R-G-B-A values.\nExamples:>>> color_name_to_rgba(\"red\")(1.0, 0.0, 0.0, 1.0)>>> color_name_to_rgba(\"#ff8000\") == (1.0, 128/255.0, 0.0, 1.0)True>>> color_name_to_rgba(\"#ff800080\") == (1.0, 128/255.0, 0.0, 128/255.0)True>>> color_name_to_rgba(\"#08f\") == (0.0, 136/255.0, 1.0, 1.0)True>>> color_name_to_rgba(\"rgb(100%, 50%, 0%)\")(1.0, 0.5, 0.0, 1.0)>>> color_name_to_rgba(\"rgba(100%, 50%, 0%, 25%)\")(1.0, 0.5, 0.0, 0.25)>>> color_name_to_rgba(\"hsla(120, 100%, 50%, 0.5)\")(0.0, 1.0, 0.0, 0.5)>>> color_name_to_rgba(\"hsl(60, 100%, 50%)\")(1.0, 1.0, 0.0, 1.0)>>> color_name_to_rgba(\"hsv(60, 100%, 100%)\")(1.0, 1.0, 0.0, 1.0)",
        "Paramters": {
            "color": "the  to be converted in one of the following formats:CSS3  specification: #rrggbb, #rgb, #rrggbbaa, #rgba, rgb(red, green, blue), rgba(red, green, blue, alpha), hsl(hue, saturation, lightness), hsla(hue, saturation, lightness, alpha), hsv(hue, saturation, value) and hsva(hue, saturation, value, alpha) where the components are given as hexadecimal numbers in the first four cases and as decimals or percentages (0%-100%) in the remaining cases. Red, green and blue components are between 0 and 255; hue is between 0 and 360; saturation, lightness and value is between 0 and 100; alpha is between 0 and 1.Valid HTML  names, i.e. those that are present in the HTML 4.0 specificationValid X11  names, see http://en.wikipedia.org/wiki/X11__namesRed-green-blue components given separately in either a comma-, slash- or whitespace-separated string or a list or a tuple, in the range of 0-255. An alpha value of 255 (maximal opacity) will be assumed.Red-green-blue-alpha components given separately in either a comma-, slash- or whitespace-separated string or a list or a tuple, in the range of 0-255A single palette index given either as a string or a number. Uses the palette given in the palette parameter of the method call.",
            "palette": "the  to be used if a single number is passed to the method. Must be an instance of colors.Palette."
        },
        "Return": [
            "the RGBA values corresponding to the given color in a 4-tuple. Since these colors are primarily used by Cairo routines, the tuples contain floats in the range 0.0-1.0"
        ],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "color_to_html_format",
        "Description": "Formats a color given as a 3-tuple or 4-tuple in HTML format.\nThe HTML format is simply given by #rrggbbaa, where rr gives the red component in hexadecimal format, gg gives the green component bb gives the blue component and gg gives the alpha level. The alpha level is optional.",
        "Paramters": {},
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "darken",
        "Description": "Creates a darker version of a color given by an RGB triplet.\nThis is done by mixing the original color with black using the given ratio. A ratio of 1.0 will yield a completely black color, a ratio of 0.0 will yield the original color. The alpha values are left intact.",
        "Paramters": {},
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "hsl_to_rgb",
        "Description": "Converts a color given by its HSL coordinates (hue, saturation, lightness) to RGB coordinates.\nEach of the HSL coordinates must be in the range [0, 1].",
        "Paramters": {},
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "hsla_to_rgba",
        "Description": "Converts a color given by its HSLA coordinates (hue, saturation, lightness, alpha) to RGBA coordinates.\nEach of the HSLA coordinates must be in the range [0, 1].",
        "Paramters": {},
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "hsv_to_rgb",
        "Description": "Converts a color given by its HSV coordinates (hue, saturation, value) to RGB coordinates.\nEach of the HSV coordinates must be in the range [0, 1].",
        "Paramters": {},
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "hsva_to_rgba",
        "Description": "Converts a color given by its HSVA coordinates (hue, saturation, value, alpha) to RGB coordinates.\nEach of the HSVA coordinates must be in the range [0, 1].",
        "Paramters": {},
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "lighten",
        "Description": "Creates a lighter version of a color given by an RGB triplet.\nThis is done by mixing the original color with white using the given ratio. A ratio of 1.0 will yield a completely white color, a ratio of 0.0 will yield the original color.",
        "Paramters": {},
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "rgb_to_hsl",
        "Description": "Converts a color given by its RGB coordinates to HSL coordinates (hue, saturation, lightness).\nEach of the RGB coordinates must be in the range [0, 1].",
        "Paramters": {},
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "rgb_to_hsv",
        "Description": "Converts a color given by its RGB coordinates to HSV coordinates (hue, saturation, value).\nEach of the RGB coordinates must be in the range [0, 1].",
        "Paramters": {},
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "rgba_to_hsla",
        "Description": "Converts a color given by its RGBA coordinates to HSLA coordinates (hue, saturation, lightness, alpha).\nEach of the RGBA coordinates must be in the range [0, 1].",
        "Paramters": {},
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "rgba_to_hsva",
        "Description": "Converts a color given by its RGBA coordinates to HSVA coordinates (hue, saturation, value, alpha).\nEach of the RGBA coordinates must be in the range [0, 1].",
        "Paramters": {},
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "default_edge_colors",
        "Description": "Undocumented"
    },
    {
        "Section_id": "known_colors",
        "Description": "Undocumented"
    },
    {
        "Section_id": "palettes",
        "Description": "Undocumented"
    },
    {
        "Section_id": "GephiConnection",
        "Description": "Object that represents a connection to a Gephi master server.",
        "Field List": {
            "Methods": {
                "__del__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__init__": {
                    "Description": "Constructs a connection to a Gephi master server.\nThe connection object can be constructed either by specifying theurl directly, or by specifying the host, port andworkspace arguments.  The latter three are evaluated only ifurl is None; otherwise the url will take precedence.\nThe url argument does not have to include the operation (e.g.,?operation=updateGraph); the connection will take care of it.E.g., if you wish to connect to workspace 2 in a local Gephi instanceon port 7341, the correct form to use for the url is as follows:",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": [
                        "The url argument does not have to include the operation (e.g.,\n?operation=updateGraph); the connection will take care of it.\nE.g., if you wish to connect to workspace 2 in a local Gephi instance\non port 7341, the correct form to use for the url is as follows:\nhttp://localhost:7341/workspace0\n"
                    ]
                },
                "__repr__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "close": {
                    "Description": "Flushes all the pending operations to the Gephi master server in asingle request.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "flush": {
                    "Description": "Flushes all the pending operations to the Gephi master server in asingle request.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "url": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "write": {
                    "Description": "Sends the given raw data to the Gephi streaming master server in an HTTPPOST request.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {
                "url": "The URL of the Gephi workspace where the data will be sent.\n"
            }
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "ShapeDrawer",
        "Description": "Static class, the ancestor of all vertex shape drawer classes.\nCustom shapes must implement at least the draw_path method of the class. The method must not stroke or fill, it should just set up the current Cairo path appropriately.",
        "Field List": {
            "Methods": {
                "draw_path": {
                    "Description": "overridden in igraph.drawing.shapes.CircleDrawer, igraph.drawing.shapes.DiamondDrawer, igraph.drawing.shapes.DownTriangleDrawer, igraph.drawing.shapes.NullDrawer, igraph.drawing.shapes.RectangleDrawer, igraph.drawing.shapes.UpTriangleDrawer\nDraws the path of the shape on the given Cairo context, without stroking or filling it.\nThis method must be overridden in derived classes implementing custom shapes and declared as a static method using staticmethod(...).",
                    "Paramters": {
                        "ctx": "the context to draw on",
                        "center_x": "the X coordinate of the center of the object",
                        "center_y": "the Y coordinate of the center of the object",
                        "width": "the  of the object",
                        "height": "the  of the object. If None, equals to the width.",
                        "**kwargs": "Undocumented"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "intersection_point": {
                    "Description": "overridden in igraph.drawing.shapes.CircleDrawer, igraph.drawing.shapes.DiamondDrawer, igraph.drawing.shapes.DownTriangleDrawer, igraph.drawing.shapes.RectangleDrawer, igraph.drawing.shapes.UpTriangleDrawer\nDetermines where the shape centered at (center_x, center_y) intersects with a line drawn from (source_x, source_y) to (center_x, center_y).\nCan be overridden in derived classes. Must always be defined as a static method using staticmethod(...)",
                    "Paramters": {
                        "center_x": "Undocumented",
                        "center_y": "Undocumented",
                        "source_x": "Undocumented",
                        "source_y": "Undocumented",
                        "width": "the  of the shape",
                        "height": "the  of the shape. If None, defaults to the width"
                    },
                    "Return": [
                        "the intersection point (the closest to (source_x, source_y) if there are more than one) or (center_x, center_y) if there is no intersection"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "MatplotlibMatrixDrawer",
        "Description": "Matplotlib drawer object for matrices.",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "Constructs the drawer and associates it to the given Axes.",
                    "Paramters": {
                        "ax": "the Axes on which we will draw"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw": {
                    "Description": "overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nDraws the given Matrix in a matplotlib Axes.",
                    "Paramters": {
                        "matrix": "the igraph.Matrix to plot.Keyword arguments are passed to Axes.imshow.",
                        "**kwds": "Undocumented"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "test",
        "Description": "Testing routine for CairoTextDrawer",
        "Paramters": {},
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "AbstractCairoGraphDrawer",
        "Description": "Abstract base class for graph drawers that draw on a Cairo canvas.",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "overrides igraph.drawing.cairo.base.AbstractCairoDrawer.__init__\nConstructs the graph drawer and associates it to the given Cairo context and the given BoundingBox.",
                    "Paramters": {
                        "context": "the  on which we will draw",
                        "bbox": "the bounding box within which we will draw. Can be anything accepted by the constructor of BoundingBox (i.e., a 2-tuple, a 4-tuple or a BoundingBox object)."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw": {
                    "Description": "Inherited from AbstractGraphDrawer:Abstract method, must be implemented in derived classes."
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "FakeModule",
        "Description": "Fake module that raises an exception for everything",
        "Field List": {
            "Methods": {
                "__call__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__getattr__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__init__": {
                    "Description": "Constructor.",
                    "Paramters": {
                        "message": " to print in exceptions raised from this module"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__setattr__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "LightToDarkEdgeDrawer",
        "Description": "Edge drawer implementation that draws undirected edges as straight lines and directed edges by using an alpha value of zero (total transparency) at the source and an alpha value of one (full opacity) at the destination. The alpha value is interpolated in-between.",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "overrides igraph.drawing.cairo.edge.AlphaVaryingEdgeDrawer.__init__\nConstructs the edge drawer.",
                    "Paramters": {
                        "context": "a Cairo  on which the edges will be drawn.",
                        "palette": "the  that can be used to map integer color indices to colors when drawing edges"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw_directed_edge": {
                    "Description": "Inherited from AlphaVaryingEdgeDrawer:Draws a directed edge."
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "MatplotlibPaletteDrawer",
        "Description": "Matplotlib drawer object for matrices.",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "Constructs the drawer and associates it to the given Axes.",
                    "Paramters": {
                        "ax": "the Axes on which we will draw"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw": {
                    "Description": "overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nDraws the given Matrix in a matplotlib Axes.",
                    "Paramters": {
                        "matrix": "the igraph.Histogram to plot.",
                        "**kwds": "Undocumented"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "Shell",
        "Description": "Superclass of the embeddable shells supported by igraph",
        "Field List": {
            "Methods": {
                "__call__": {
                    "Description": "overridden in igraph.app.shell.ClassicPythonShell, igraph.app.shell.IDLEShell, igraph.app.shell.IPythonShell\nUndocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_progress_handler": {
                    "Description": "Returns the progress handler (if exists) or None (if not).",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_status_handler": {
                    "Description": "Returns the status handler (if exists) or None (if not).",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "supports_progress_bar": {
                    "Description": "Checks whether the shell supports progress bars.\nThis is done by checking for the existence of an attribute called _progress_handler.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "supports_status_messages": {
                    "Description": "Checks whether the shell supports status messages.\nThis is done by checking for the existence of an attribute called _status_handler.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "GradientPalette",
        "Description": "Base class for gradient palettes\nGradient palettes contain a gradient between two given colors.\n",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "overrides igraph.drawing.colors.Palette.__init__\nCreates a gradient palette.",
                    "Paramters": {
                        "color1": "the color where the gradient starts.",
                        "color2": "the color where the gradient ends.",
                        "n": "the umber of colors i the palette."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__len__": {
                    "Description": "Inherited from Palette:Returns the number of colors in this palette"
                },
                "__plot__": {
                    "Description": "Inherited from Palette:Plots the colors of the palette on the given Cairo context/mpl Axes"
                },
                "__repr__": {
                    "Description": "Inherited from Palette:Undocumented"
                },
                "clear_cache": {
                    "Description": "Inherited from Palette:Clears the result cache."
                },
                "get": {
                    "Description": "Inherited from Palette:Returns the given color from the palette."
                },
                "get_many": {
                    "Description": "Inherited from Palette:Returns multiple colors from the palette."
                }
            },
            "property": {
                "length": "Inherited from Palette:Returns the number of colors in this palette"
            }
        },
        "Rubric": {
            "Example": [
                "Example:\n>>> pal = GradientPalette(\"red\", \"blue\", 5)\n>>> pal.get(0)\n(1.0, 0.0, 0.0, 1.0)\n>>> pal.get(2)\n(0.5, 0.0, 0.5, 1.0)\n>>> pal.get(4)\n(0.0, 0.0, 1.0, 1.0)\n"
            ]
        }
    },
    {
        "Section_id": "TerminalController",
        "Description": "A class that can be used to portably generate formatted output to a terminal.\n",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "Create a TerminalController and initialize its attributes with appropriate values for the current terminal. term_stream is the stream that will be used for terminal output; if this stream is not a tty, then the terminal is assumed to be a dumb terminal (i.e., have no capabilities).",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "render": {
                    "Description": "Replace each $-substitutions in the given template string with the corresponding terminal control string (if it's defined) or '' (if it's not).",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": [
                "TerminalController defines a set of instance variables whose values are initialized to the control sequence necessary to perform a given action.  These can be simply included in normal output to the terminal:\n>>> term = TerminalController()\n>>> print('This is '+term.GREEN+'green'+term.NORMAL)\nThis is green\n",
                "Alternatively, the render() method can used, which replaces ${action} with the string required to perform action:\n>>> term = TerminalController()\n>>> print('This is '+term.GREEN+'green'+term.NORMAL)\nThis is green\n",
                "If the terminal doesn't support a given action, then the value of the corresponding instance variable will be set to ''.  As a result, the above code will still work on terminals that do not support color, except that their output will not be colored. Also, this means that you can test whether the terminal supports a given action by simply testing the truth value of the corresponding instance variable:\n>>> term = TerminalController()\n>>> print('This is '+term.GREEN+'green'+term.NORMAL)\nThis is green\n"
            ]
        }
    },
    {
        "Section_id": "RunningMean",
        "Description": "Running mean calculator.\nThis class can be used to calculate the mean of elements from a list, tuple, iterable or any other data source. The mean is calculated on the fly without explicitly summing the values, so it can be used for data sets with arbitrary item count. Also capable of returning the standard deviation (also calculated on the fly)",
        "Field List": {
            "Methods": {
                "__complex__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__float__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__init__": {
                    "Description": "RunningMean(items=None, n=0.0, mean=0.0, sd=0.0)\nInitializes the running mean calculator.\nThere are two possible ways to initialize the calculator. First, one can provide an iterable of items; alternatively, one can specify the number of items, the mean and the standard deviation if we want to continue an interrupted calculation.",
                    "Paramters": {
                        "items": "the  that are used to initialize the running mean calcuator. If  is given, n, mean and sd must be zeros.",
                        "n": "the iitial umber of elemets already processed. If this is give, items must be Noe.",
                        "mean": "the initial . If this is given, items must be None.",
                        "sd": "the initial standard deviation. If this is given, items must be None."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__int__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__len__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__repr__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__str__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "add": {
                    "Description": "RunningMean.add(value, repeat=1)\nAdds the given value to the elements from which we calculate the mean and the standard deviation.",
                    "Paramters": {
                        "value": "the element to be added",
                        "repeat": "number of ed additions"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "add_many": {
                    "Description": "RunningMean.add(values)\nAdds the values in the given iterable to the elements from which we calculate the mean. Can also accept a single number. The left shift (<<) operator is aliased to this function, so you can use it to add elements as well:",
                    "Paramters": {
                        "values": ":iterablethe element(s) to be added"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": [
                        "Adds the values in the given iterable to the elements from which we calculate the mean. Can also accept a single number. The left shift (<<) operator is aliased to this function, so you can use it to add elements as well:\n>>> rm=RunningMean()\n>>> rm << [1,2,3,4]\n>>> rm.result               # doctest:+ELLIPSIS\n(2.5, 1.290994...)\n"
                    ]
                },
                "clear": {
                    "Description": "Resets the running mean calculator.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {
                "mean": "Returns the current mean\n",
                "result": "Returns the current mean and standard deviation as a tuple\n",
                "sd": "Returns the current standard deviation\n",
                "var": "Returns the current variation\n"
            }
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "Cut",
        "Description": "A cut of a given graph.\nThis is a simple class used to represent cuts returned by Graph.mincut(), Graph.all_st_cuts() and other functions that calculate cuts.\nA cut is a special vertex clustering with only two clusters. Besides the usual VertexClustering methods, it also has the following attributes: value - the value (capacity) of the cut. It is equal to the number of edges if there are no capacities on the edges. partition - vertex IDs in the parts created after removing edges in the cut cut - edge IDs in the cut es - an edge selector restricted to the edges in the cut. \nYou can use indexing on this object to obtain lists of vertex IDs for both sides of the partition.\nThis class is usually not instantiated directly, everything is taken care of by the functions that return cuts.\n",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "overrides igraph.VertexClustering.__init__\nInitializes the cut.\nThis should not be called directly, everything is taken care of by the functions that return cuts.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__repr__": {
                    "Description": "overridden in igraph.Flow\nUndocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__str__": {
                    "Description": "overrides igraph.Clustering.__str__\nUndocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__plot__": {
                    "Description": "Inherited from VertexClustering:Plots the clustering to the given Cairo context or matplotlib Axes."
                },
                "as_cover": {
                    "Description": "Inherited from VertexClustering:Returns a VertexCover that contains the same clusters as this clustering."
                },
                "cluster_graph": {
                    "Description": "Inherited from VertexClustering:Returns a graph where each cluster is contracted into a single vertex."
                },
                "crossing": {
                    "Description": "Inherited from VertexClustering:Returns a boolean vector where element i is True iff edge i lies between clusters, False otherwise."
                },
                "giant": {
                    "Description": "Inherited from VertexClustering:Returns the largest cluster of the clustered graph."
                },
                "recalculate_modularity": {
                    "Description": "Inherited from VertexClustering:Recalculates the stored modularity value."
                },
                "subgraph": {
                    "Description": "Inherited from VertexClustering:Get the subgraph belonging to a given cluster."
                },
                "subgraphs": {
                    "Description": "Inherited from VertexClustering:Gets all the subgraphs belonging to each of the clusters."
                }
            },
            "property": {
                "cut": "Returns the edge IDs in the cut\n",
                "es": "Returns an edge selector restricted to the cut\n",
                "partition": "Returns the vertex IDs partitioned according to the cut\n",
                "value": "Returns the sum of edge capacities in the cut\n",
                "graph": "Inherited from VertexClustering:Returns the graph belonging to this object",
                "modularity": "Inherited from VertexClustering:Returns the modularity score"
            }
        },
        "Rubric": {
            "Example": [
                "Examples:\n>>> from igraph import Graph\n>>> g = Graph.Ring(20)\n>>> mc = g.mincut()\n>>> print(mc.value)\n2.0\n>>> print(min(len(x) for x in mc))\n1\n>>> mc.es[\"color\"] = \"red\""
            ]
        }
    },
    {
        "Section_id": "HullCollection",
        "Description": "Collection for hulls connecting vertex covers/clusters.\nThe class takes the normal arguments of a PathCollection, plus one argument called \"corner_radius\" that specifies how much to smoothen the polygon vertices into round corners. This argument can be a float or a sequence of floats, one for each hull to be drawn.",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "CairoGraphDrawer",
        "Description": "Class implementing the default visualisation of a graph.\nThe default visualisation of a graph draws the nodes on a 2D plane according to a given Layout, then draws a straight or curved edge between nodes connected by edges. This is the visualisation used when one invokes the plot() function on a Graph object.\nSee Graph.__plot__() for the keyword arguments understood by this drawer.",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "overrides igraph.drawing.cairo.graph.AbstractCairoGraphDrawer.__init__\nConstructs the graph drawer and associates it to the given Cairo context and the given BoundingBox.",
                    "Paramters": {
                        "context": "the  on which we will draw",
                        "bbox": "the bounding box within which we will draw. Can be anything accepted by the constructor of BoundingBox (i.e., a 2-tuple, a 4-tuple or a BoundingBox object).",
                        "vertex_drawer_factory": "a factory method that returns an AbstractCairoVertexDrawer instance bound to a given Cairo context. The factory method must take four parameters: the Cairo context, the bounding box of the drawing area, the palette to be used for drawing colored vertices, and the graph layout. The default vertex drawer is CairoVertexDrawer.",
                        "edge_drawer_factory": "a factory method that returns an AbstractCairoEdgeDrawer instance bound to a given Cairo context. The factory method must take two parameters: the Cairo context and the palette to be used for drawing colored edges. You can use any of the actual AbstractEdgeDrawer implementations here to control the style of edges drawn by igraph. The default edge drawer is CairoArrowEdgeDrawer.",
                        "label_drawer_factory": "a factory method that returns a CairoTextDrawer instance bound to a given Cairo context. The method must take one parameter: the Cairo context. The default label drawer is CairoTextDrawer."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw": {
                    "Description": "overrides igraph.drawing.baseclasses.AbstractGraphDrawer.draw\nAbstract method, must be implemented in derived classes.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "Vertex",
        "Description": "Class representing a single vertex in a graph.\nThe vertex is referenced by its index, so if the underlying graph changes, the semantics of the vertex object might change as well (if the vertex indices are altered in the original graph).\n",
        "Field List": {
            "Methods": {
                "all_edges": {
                    "Description": "Proxy method to Graph.incident(..., mode=\"all\")\nThis method calls the incident() method of the Graph class with this vertex as the first argument and \"all\" as the mode argument, and returns the result.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "Graph.incident() for details.",
                    "example": []
                },
                "attribute_names": {
                    "Description": "Returns the list of vertex attribute names",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "attributes": {
                    "Description": "Returns a dict of attribute names and values for the vertex",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "betweenness": {
                    "Description": "Proxy method to Graph.betweenness()\nThis method calls the betweenness() method of the Graph class with this vertex as the first argument, and returns the result.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "Graph.betweenness() for details.",
                    "example": []
                },
                "closeness": {
                    "Description": "Proxy method to Graph.closeness()\nThis method calls the closeness() method of the Graph class with this vertex as the first argument, and returns the result.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "Graph.closeness() for details.",
                    "example": []
                },
                "constraint": {
                    "Description": "Proxy method to Graph.constraint()\nThis method calls the constraint() method of the Graph class with this vertex as the first argument, and returns the result.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "Graph.constraint() for details.",
                    "example": []
                },
                "degree": {
                    "Description": "Proxy method to Graph.degree()\nThis method calls the degree() method of the Graph class with this vertex as the first argument, and returns the result.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "Graph.degree() for details.",
                    "example": []
                },
                "delete": {
                    "Description": "Proxy method to Graph.delete_vertices()\nThis method calls the delete_vertices method of the Graph class with this vertex as the first argument, and returns the result.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "Graph.delete_vertices() for details.",
                    "example": []
                },
                "distances": {
                    "Description": "Proxy method to Graph.distances()\nThis method calls the distances() method of the Graph class with this vertex as the first argument, and returns the result.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "Graph.distances() for details.",
                    "example": []
                },
                "diversity": {
                    "Description": "Proxy method to Graph.diversity()\nThis method calls the diversity() method of the Graph class with this vertex as the first argument, and returns the result.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "Graph.diversity() for details.",
                    "example": []
                },
                "eccentricity": {
                    "Description": "Proxy method to Graph.eccentricity()\nThis method calls the eccentricity() method of the Graph class with this vertex as the first argument, and returns the result.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "Graph.eccentricity() for details.",
                    "example": []
                },
                "get_shortest_paths": {
                    "Description": "Proxy method to Graph.get_shortest_paths()\nThis method calls the get_shortest_paths() method of the Graph class with this vertex as the first argument, and returns the result.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "Graph.get_shortest_paths() for details.",
                    "example": []
                },
                "in_edges": {
                    "Description": "Proxy method to Graph.incident(..., mode=\"in\")\nThis method calls the incident() method of the Graph class with this vertex as the first argument and \"in\" as the mode argument, and returns the result.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "Graph.incident() for details.",
                    "example": []
                },
                "incident": {
                    "Description": "Proxy method to Graph.incident()\nThis method calls the incident() method of the Graph class with this vertex as the first argument, and returns the result.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "Graph.incident() for details.",
                    "example": []
                },
                "indegree": {
                    "Description": "Proxy method to Graph.indegree()\nThis method calls the indegree() method of the Graph class with this vertex as the first argument, and returns the result.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "Graph.indegree() for details.",
                    "example": []
                },
                "is_minimal_separator": {
                    "Description": "Proxy method to Graph.is_minimal_separator()\nThis method calls the is_minimal_separator() method of the Graph class with this vertex as the first argument, and returns the result.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "Graph.is_minimal_separator() for details.",
                    "example": []
                },
                "is_separator": {
                    "Description": "Proxy method to Graph.is_separator()\nThis method calls the is_separator() method of the Graph class with this vertex as the first argument, and returns the result.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "Graph.is_separator() for details.",
                    "example": []
                },
                "neighbors": {
                    "Description": "Proxy method to Graph.neighbors()\nThis method calls the neighbors() method of the Graph class with this vertex as the first argument, and returns the result.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "Graph.neighbors() for details.",
                    "example": []
                },
                "out_edges": {
                    "Description": "Proxy method to Graph.incident(..., mode=\"out\")\nThis method calls the incident() method of the Graph class with this vertex as the first argument and \"out\" as the mode argument, and returns the result.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "Graph.incident() for details.",
                    "example": []
                },
                "outdegree": {
                    "Description": "Proxy method to Graph.outdegree()\nThis method calls the outdegree() method of the Graph class with this vertex as the first argument, and returns the result.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "Graph.outdegree() for details.",
                    "example": []
                },
                "pagerank": {
                    "Description": "Proxy method to Graph.pagerank()\nThis method calls the pagerank() method of the Graph class with this vertex as the first argument, and returns the result.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "Graph.pagerank() for details.",
                    "example": []
                },
                "personalized_pagerank": {
                    "Description": "Proxy method to Graph.personalized_pagerank()\nThis method calls the personalized_pagerank() method of the Graph class with this vertex as the first argument, and returns the result.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "Graph.personalized_pagerank() for details.",
                    "example": []
                },
                "predecessors": {
                    "Description": "Proxy method to Graph.predecessors()\nThis method calls the predecessors() method of the Graph class with this vertex as the first argument, and returns the result.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "Graph.predecessors() for details.",
                    "example": []
                },
                "strength": {
                    "Description": "Proxy method to Graph.strength()\nThis method calls the strength() method of the Graph class with this vertex as the first argument, and returns the result.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "Graph.strength() for details.",
                    "example": []
                },
                "successors": {
                    "Description": "Proxy method to Graph.successors()\nThis method calls the successors() method of the Graph class with this vertex as the first argument, and returns the result.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "Graph.successors() for details.",
                    "example": []
                },
                "update_attributes": {
                    "Description": "Updates the attributes of the vertex from dict/iterable E and F.\nIf E has a keys() method, it does: for k in E: self[k] = E[k]. If E lacks a keys() method, it does: for (k, v) in E: self[k] = v. In either case, this is followed by: for k in F: self[k] = F[k].\nThis method thus behaves similarly to the update() method of Python dictionaries.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": [
                "The attributes of the vertex can be accessed by using the vertex as a hash:\n>>> v[\"color\"] = \"red\"                  #doctest: +SKIP\n>>> print(v[\"color\"])                     #doctest: +SKIP\nred\n"
            ]
        }
    },
    {
        "Section_id": "Palette",
        "Description": "Base class of color palettes.\nColor palettes are mappings that assign integers from the range 0..n\u2009\u2212\u20091 to colors (4-tuples). n is called the size or length of the palette. igraph comes with a number of predefined palettes, so this class is useful for you only if you want to define your own palette. This can be done by subclassing this class and implementing the Palette._get method as necessary.\nPalettes can also be used as lists or dicts, for the __getitem__ method is overridden properly to call Palette.get.",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "overridden in igraph.drawing.colors.AdvancedGradientPalette, igraph.drawing.colors.GradientPalette, igraph.drawing.colors.PrecalculatedPalette, igraph.drawing.colors.RainbowPalette\nUndocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__len__": {
                    "Description": "Returns the number of colors in this palette",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__plot__": {
                    "Description": "Plots the colors of the palette on the given Cairo context/mpl Axes\nSupported keywork arguments in both Cairo and matplotlib are:orientation: the orientation of the palette. Must be one of the following values: left-right, bottom-top, right-left or top-bottom. Possible aliases: horizontal = left-right, vertical = bottom-top, lr = left-right, rl = right-left, tb = top-bottom, bt = bottom-top. The default is left-right.\nAdditional supported keyword arguments in Cairo are:border_width: line width of the border shown around the palette. If zero or negative, the border is turned off. Default is 1.grid_width: line width of the grid that separates palette cells. If zero or negative, the grid is turned off. The grid is also turned off if the size of a cell is less than three times the given line width. Default is 0.  Fractional widths are also allowed.\nKeyword arguments in matplotlib are passes to Axes.imshow.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__repr__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "clear_cache": {
                    "Description": "Clears the result cache.\nThe return values of Palette.get are cached. Use this method to clear the cache.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get": {
                    "Description": "Returns the given color from the palette.\nValues are cached: if the specific value given has already been looked up, its value will be returned from the cache instead of calculating it again. Use Palette.clear_cache to clear the cache if necessary.",
                    "Paramters": {
                        "v": "the color to be retrieed. If it is an integer, it is passed to Palette._get to be translated to an RGBA quadruplet. Otherwise it is passed to color_name_to_rgb() to determine the RGBA alues."
                    },
                    "Return": [
                        "the color as an RGBA quadruplet",
                        "you shouldn't override this method in subclasses, override _get instead. If you override this method, lookups in the known_colors dict won't work, so you won't be able to refer to colors by names or RGBA quadruplets, only by integer indices. The caching functionality will disappear as well. However, feel free to override this method if this is exactly the behaviour you want."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_many": {
                    "Description": "Returns multiple colors from the palette.\nValues are cached: if the specific value given has already been looked upon, its value will be returned from the cache instead of calculating it again. Use Palette.clear_cache to clear the cache if necessary.",
                    "Paramters": {
                        "colors": "the list of  to be retrieved. The palette class tries to make an educated guess here: if it is not possible to interpret the value you passed here as a list of , the class will simply try to interpret it as a single color by forwarding the value to Palette.get."
                    },
                    "Return": [
                        "the colors as a list of RGBA quadruplets. The result will be a list even if you passed a single color index or color name."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {
                "length": "Returns the number of colors in this palette\n"
            }
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "VertexSeq",
        "Description": "Low-level representation of a vertex sequence.\nDon't use it directly, use igraph.VertexSeq instead.",
        "Field List": {
            "Methods": {
                "attribute_names": {
                    "Description": "Returns the attribute name list of the graph's vertices",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "find": {
                    "Description": "overridden in igraph.VertexSeq\nFor internal use only.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_attribute_values": {
                    "Description": "Returns the value of a given vertex attribute for all vertices in a list.\nThe values stored in the list are exactly the same objects that are stored in the vertex attribute, meaning that in the case of mutable objects, the modification of the list element does affect the attribute stored in the vertex. In the case of immutable objects, modification of the list does not affect the attribute values.",
                    "Paramters": {
                        "attrname": "the name of the attribute"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "select": {
                    "Description": "overridden in igraph.VertexSeq\nFor internal use only.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "set_attribute_values": {
                    "Description": "Sets the value of a given vertex attribute for all vertices",
                    "Paramters": {
                        "attrname": "the name of the attribute",
                        "values": "the new attribute  in a list"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "Dendrogram",
        "Description": "The hierarchical clustering (dendrogram) of some dataset.\nA hierarchical clustering means that we know not only the way the elements are separated into groups, but also the exact history of how individual elements were joined into larger subgroups.\n",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "overridden in igraph.VertexDendrogram\nCreates a hierarchical clustering.",
                    "Paramters": {
                        "merges": "the merge history either in matrix or tuple format"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__plot__": {
                    "Description": "overridden in igraph.VertexDendrogram\nDraws the dendrogram on the given Cairo context or matplotlib Axes.\nSupported keyword arguments are:orientation: the orientation of the dendrogram. Must be one of the following values: left-right, bottom-top, right-left or top-bottom. Individual elements are always placed at the former edge and merges are performed towards the latter edge. Possible aliases: horizontal = left-right, vertical = bottom-top, lr = left-right, rl = right-left, tb = top-bottom, bt = bottom-top. The default is left-right.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__str__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "format": {
                    "Description": "Formats the dendrogram in a foreign format.\nCurrently only the Newick format is supported.\nExample:",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": [
                        "Example:\n>>> d = Dendrogram([(2, 3), (0, 1), (4, 5)])\n>>> d.format()\n'((2,3)4,(0,1)5)6;'\n>>> d.names = list(\"ABCDEFG\")\n>>> d.format()\n'((C,D)E,(A,B)F)G;'\n"
                    ]
                },
                "names": {
                    "Description": "Sets the names of the nodes in the dendrogram",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "summary": {
                    "Description": "Returns the summary of the dendrogram.\nThe summary includes the number of leafs and branches, and also an ASCII art representation of the dendrogram unless it is too large.",
                    "Paramters": {
                        "verbosity": "determines whether the ASCII representation of the dendrogram should be printed. Zero  prints only the number of leafs and branches.",
                        "max_leaf_count": "the maximal number of leafs to print in the ASCII representation. If the dendrogram has more leafs than this limit, the ASCII representation will not be printed even if the verbosity is larger than or equal to 1."
                    },
                    "Return": [
                        "the summary of the dendrogram as a string."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {
                "merges": "Returns the performed merges in matrix format\n",
                "names": "Returns the names of the nodes in the dendrogram\n"
            }
        },
        "Rubric": {
            "Example": [
                "This class internally represents the hierarchy by a matrix with n rows and 2 columns -- or more precisely, a list of lists of size 2. This is exactly the same as the original format used by igraph's C core. The ith row of the matrix contains the indices of the two clusters being joined in time step i. The joint group will be represented by the ID n\u2009+\u2009i, with i starting from one. The ID of the joint group will be referenced in the upcoming steps instead of any of its individual members. So, IDs less than or equal to n (where n is the number of rows in the matrix) mean the original members of the dataset (with ID from 0 to n), while IDs up from n\u2009+\u20091 mean joint groups. As an example, take a look at the dendrogram and the internal representation of a given clustering of five nodes:\n  0 -+\n     |\n  1 -+-+\n       |\n  2 ---+-+        <====>   [[0, 1], [3, 4], [2, 5], [6, 7]]\n         |\n  3 -+   |\n     |   |\n  4 -+---+---\n"
            ]
        }
    },
    {
        "Section_id": "CytoscapeGraphDrawer",
        "Description": "Graph drawer that sends/receives graphs to/from Cytoscape using CytoscapeRPC.\nThis graph drawer cooperates with Cytoscape using CytoscapeRPC. You need to install the CytoscapeRPC plugin first and start the XML-RPC server on a given port (port 9000 by default) from the appropriate Plugins submenu in Cytoscape.\nGraph, vertex and edge attributes are transferred to Cytoscape whenever possible (i.e. when a suitable mapping exists between a Python type and a Cytoscape type). If there is no suitable Cytoscape type for a Python type, the drawer will use a string attribute on the Cytoscape side and invoke str() on the Python attributes.\nIf an attribute to be created on the Cytoscape side already exists with a different type, an underscore will be appended to the attribute name to resolve the type conflict.\nYou can use the network_id attribute of this class to figure out the network ID of the last graph drawn with this drawer.",
        "Field List": {
            "Methods": {
                "infer_cytoscape_type": {
                    "Description": "Returns a Cytoscape type that can be used to represent all the values in values and an appropriately converted copy of values that is suitable for an XML-RPC call.  Note that the string type in Cytoscape is used as a catch-all type; if no other type fits, attribute values will be converted to string and then posted to Cytoscape.\nNone entries are allowed in values, they will be ignored on the Cytoscape side.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__init__": {
                    "Description": "overrides igraph.drawing.baseclasses.AbstractXMLRPCDrawer.__init__\nConstructs a Cytoscape graph drawer using the XML-RPC interface of Cytoscape at the given URL.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw": {
                    "Description": "overrides igraph.drawing.baseclasses.AbstractGraphDrawer.draw\nSends the given graph to Cytoscape as a new network.",
                    "Paramters": {
                        "graph": "Undocumented",
                        "name": "the  of the network in Cytoscape.",
                        "create_view": "whether to create a view for the network in Cytoscape.The default is True.",
                        "*args": "Undocumented",
                        "node_ids": "specifies the identifiers of the nodes to be used in Cytoscape. This must either be the name of a vertex attribute or a list specifying the identifiers, one for each node in the graph. The default is None, which simply uses the vertex index for each vertex."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "fetch": {
                    "Description": "Fetches the network with the given name from Cytoscape.\nWhen fetching networks from Cytoscape, the canonicalName attributes of vertices and edges are not converted by default. Use the keep_canonical_names parameter to retrieve these attributes as well.",
                    "Paramters": {
                        "name": "the  of the network in Cytoscape.",
                        "directed": "whether the network is .",
                        "keep_canonical_names": "whether to keep the canonicalName vertex/edge attributes that are added automatically by Cytoscape"
                    },
                    "Return": [
                        "an appropriately constructed igraph Graph."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "GraphArtist",
        "Description": "Artist for an igraph.Graph object.ParametersgraphAn igraph.Graph object to plotlayoutA layout object or matrix of coordinates to use for plotting. Each element or row should describes the coordinates for a vertex.vertex_styleA dictionary specifying style options for vertices.edge_styleA dictionary specifying style options for edges.",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "contains": {
                    "Description": "Track 'contains' event for mouse interactions.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw": {
                    "Description": "overrides igraph.drawing.baseclasses.AbstractGraphDrawer.draw\nDraw each of the children, with some buffering mechanism.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_children": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_datalim": {
                    "Description": "Get limits on x/y axes based on the graph layout data.\nThere is a small padding based on the size of the vertex marker to ensure it fits into the canvas.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_edge_labels": {
                    "Description": "Get list of edge label artists.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_edges": {
                    "Description": "Get EdgeCollection artist.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_groups": {
                    "Description": "Get HullCollection group/cluster/cover artists.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_vertex_labels": {
                    "Description": "Get list of vertex label artists.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_vertices": {
                    "Description": "Get VertexCollection artist.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "pick": {
                    "Description": "Track 'pick' event for mouse interactions.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "set": {
                    "Description": "Set multiple parameters at once.\nThe same options can be used as in the igraph.plot function.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "VertexClustering",
        "Description": "The clustering of the vertex set of a graph.\nThis class extends Clustering by linking it to a specific Graph object and by optionally storing the modularity score of the clustering. It also provides some handy methods like getting the subgraph corresponding to a cluster and such.Notesince this class is linked to a Graph, destroying the graph by the del operator does not free the memory occupied by the graph if there exists a VertexClustering that references the Graph.",
        "Field List": {
            "Methods": {
                "FromAttribute": {
                    "Description": "Creates a vertex clustering based on the value of a vertex attribute.\nVertices having the same attribute will correspond to the same cluster.",
                    "Paramters": {
                        "graph": "the  on which we are working",
                        "attribute": "name of the  on which the clustering is based.",
                        "intervals": "for numeric attributes, you can either pass a single number or a list of numbers here. A single number means that the vertices will be put in bins of that width and vertices ending up in the same bin will be in the same cluster. A list of numbers specify the bin positions explicitly; e.g., [10, 20, 30] means that there will be four categories: vertices with the attribute value less than 10, between 10 and 20, between 20 and 30 and over 30. Intervals are closed from the left and open from the right.",
                        "params": "additional parameters to be stored in this object."
                    },
                    "Return": [
                        "a new VertexClustering object"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__init__": {
                    "Description": "overrides igraph.Clustering.__init__\nCreates a clustering object for a given graph.",
                    "Paramters": {
                        "graph": "the  that will be associated to the clustering",
                        "membership": "the  list. The length of the list must be equal to the number of vertices in the graph. If None, every vertex is assumed to belong to the same cluster.",
                        "modularity": "the  score of the clustering. If None, it will be calculated when needed.",
                        "params": "additional parameters to be stored in this object.",
                        "modularity_params": "arguments that should be passed to Graph.modularity when the modularity is (re)calculated. If the original graph was weighted, you should pass a dictionary containing a weight key with the appropriate value here."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__plot__": {
                    "Description": "Plots the clustering to the given Cairo context or matplotlib Axes.\nThis is done by calling Graph.__plot__() with the same arguments, but coloring the graph vertices according to the current clustering (unless overridden by the vertex_color argument explicitly).\nThis method understands all the positional and keyword arguments that are understood by Graph.__plot__(), only the differences will be highlighted here:mark_groups: whether to highlight some of the vertex groups by colored polygons. Besides the values accepted by Graph.__plot__ (i.e., a dict mapping colors to vertex indices, a list containing lists of vertex indices, or False), the following are also accepted:True: all the groups will be highlighted, the colors matching the corresponding color indices from the current palette (see the palette keyword argument of Graph.__plot__).A dict mapping cluster indices or tuples of vertex indices to color names.  The given clusters or vertex groups will be highlighted by the given colors.A list of cluster indices. This is equivalent to passing a dict mapping numeric color indices from the current palette to cluster indices; therefore, the cluster referred to by element i of the list will be highlighted by color i from the palette.The value of the plotting.mark_groups configuration key is also taken into account here; if that configuration key is True and mark_groups is not given explicitly, it will automatically be set to True.In place of lists of vertex indices, you may also use VertexSeq instances.In place of color names, you may also use color indices into the current palette. None as a color name will mean that the corresponding group is ignored.palette: the palette used to resolve numeric color indices to RGBA values. By default, this is an instance of ClusterColoringPalette.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "Graph.__plot__() for more supported keyword arguments.",
                    "example": []
                },
                "as_cover": {
                    "Description": "overrides igraph.Clustering.as_cover\nReturns a VertexCover that contains the same clusters as this clustering.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "cluster_graph": {
                    "Description": "Returns a graph where each cluster is contracted into a single vertex.\nIn the resulting graph, vertex i represents cluster i in this clustering. Vertex i and j will be connected if there was at least one connected vertex pair (a,\u2009b) in the original graph such that vertex a was in cluster i and vertex b was in cluster j.",
                    "Paramters": {
                        "combine_vertices": "specifies how to derive the attributes of the vertices in the new graph from the attributes of the old ones. See Graph.contract_vertices() for more details.",
                        "combine_edges": "specifies how to derive the attributes of the edges in the new graph from the attributes of the old ones. See Graph.simplify() for more details. If you specify False here, edges will not be combined, and the number of edges between the vertices representing the original clusters will be equal to the number of edges between the members of those clusters in the original graph."
                    },
                    "Return": [
                        "the new graph."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "crossing": {
                    "Description": "Returns a boolean vector where element i is True iff edge i lies between clusters, False otherwise.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "giant": {
                    "Description": "Returns the largest cluster of the clustered graph.\nThe largest cluster is a cluster for which no larger cluster exists in the clustering. It may also be known as the giant community if the clustering represents the result of a community detection function.\nPrecondition: the vertex set of the graph hasn't been modified since the moment the cover was constructed.",
                    "Paramters": {},
                    "Return": [
                        "a copy of the largest cluster.",
                        "there can be multiple largest clusters, this method will return the copy of an arbitrary one if there are multiple largest clusters."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "recalculate_modularity": {
                    "Description": "Recalculates the stored modularity value.\nThis method must be called before querying the modularity score of the clustering through the class member modularity or q if the graph has been modified (edges have been added or removed) since the creation of the VertexClustering object.",
                    "Paramters": {},
                    "Return": [
                        "the new modularity score"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "subgraph": {
                    "Description": "Get the subgraph belonging to a given cluster.\nPrecondition: the vertex set of the graph hasn't been modified since the moment the cover was constructed.",
                    "Paramters": {
                        "idx": "the cluster index"
                    },
                    "Return": [
                        "a copy of the subgraph"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "subgraphs": {
                    "Description": "Gets all the subgraphs belonging to each of the clusters.\nPrecondition: the vertex set of the graph hasn't been modified since the moment the cover was constructed.",
                    "Paramters": {},
                    "Return": [
                        "a list containing copies of the subgraphs"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__getitem__": {
                    "Description": "Inherited from Clustering:Returns the members of the specified cluster."
                },
                "__iter__": {
                    "Description": "Inherited from Clustering:Iterates over the clusters in this clustering."
                },
                "__len__": {
                    "Description": "Inherited from Clustering:Returns the number of clusters."
                },
                "__str__": {
                    "Description": "Inherited from Clustering:Undocumented"
                },
                "compare_to": {
                    "Description": "Inherited from Clustering:Compares this clustering to another one using some similarity or distance metric."
                },
                "size": {
                    "Description": "Inherited from Clustering:Returns the size of a given cluster."
                },
                "size_histogram": {
                    "Description": "Inherited from Clustering:Returns the histogram of cluster sizes."
                },
                "sizes": {
                    "Description": "Inherited from Clustering:Returns the size of given clusters."
                },
                "summary": {
                    "Description": "Inherited from Clustering:Returns the summary of the clustering."
                }
            },
            "property": {
                "graph": "Returns the graph belonging to this object\n",
                "modularity": "Returns the modularity score\n",
                "membership": "Inherited from Clustering:Returns the membership vector.",
                "n": "Inherited from Clustering:Returns the number of elements covered by this clustering."
            }
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "plot",
        "Description": "Plots the given object to the given target.\nPositional and keyword arguments not explicitly mentioned here will be passed down to the __plot__ method of the object being plotted. Since you are most likely interested in the keyword arguments available for graph plots, see Graph.__plot__ as well.",
        "Paramters": {
            "obj": "the ect to be plotted",
            "target": "the  where the object should be plotted. It can be one of the following types:matplotib.axes.Axes -- a matplotlib/pyplot axes in which the graph will be plotted. Drawing is delegated to the chosen matplotlib backend, and you can use interactive backends and matplotlib functions to save to file as well.string -- a file with the given name will be created and the plot will be stored there. If you are using the Cairo backend, an appropriate Cairo surface will be attached to the file. If you are using the matplotlib backend, the Figure will be saved to that file using Figure.savefig with default parameters. The supported image formats for Cairo are: PNG, PDF, SVG and PostScript; matplotlib might support additional formats.cairo.Surface -- the given Cairo surface will be used. This can refer to a PNG image, an arbitrary window, an SVG file, anything that Cairo can handle.None -- If you are using the Cairo backend, no plotting will be performed; igraph simply returns a CairoPlot_ object that you can use to manipulate the plot and save it to a file later. If you are using the matplotlib backend, a Figure objet and an Axes are created and the Axes is returned so you can manipulate it further. Similarly, if you are using the plotly backend, a Figure object is returned.",
            "bbox": "the bounding box of the plot. It must be a tuple with either two or four integers, or a BoundingBox object. If this is a tuple with two integers, it is interpreted as the width and height of the plot (in pixels for PNG images and on-screen plots, or in points for PDF, SVG and PostScript plots, where 72 pt = 1 inch = 2.54 cm). If this is a tuple with four integers, the first two denotes the X and Y coordinates of a corner and the latter two denoting the X and Y coordinates of the opposite corner. Ignored for Matplotlib plots.",
            "*args": "Undocumented",
            "opacity": "the  of the object being plotted. It can be used to overlap several plots of the same graph if you use the same layout for them -- for instance, you might plot a graph with  0.5 and then plot its spanning tree over it with  0.1. To achieve this, you'll need to modify the Plot object returned with Plot.add. Ignored for Matplotlib plots.",
            "palette": "the  primarily used on the plot if the added objects do not specify a private . Must be either an igraph.drawing.colors.Palette object or a string referring to a valid key of igraph.drawing.colors.s (see module igraph.drawing.colors) or None. In the latter case, the default  given by the configuration key plotting. is used.",
            "margin": "the top, right, bottom, left s as a 4-tuple. If it has less than 4 elements or is a single float, the elements will be re-used until the length is at least 4. The default  is 20 units on each side. Ignored for Matplotlib plots.",
            "inline": "whether to try and show the plot object  in the current IPython notebook. Passing None here or omitting this keyword argument will look up the preferred behaviour from the shell.ipython.inlining.Plot configuration key.  Note that this keyword argument has an effect only if igraph is run inside IPython and target is None.",
            "backend": "the plotting  to use; one of \"cairo\", \"matplotlib\" or \"plotly\". None means to try to decide the  from the plotting target and the default igraph configuration object."
        },
        "Return": [
            "an appropriate CairoPlot object for the Cairo backend, the Matplotlib Axes object for the Matplotlib backend, and the Figure object for the plotly backend."
        ],
        "Raises": {},
        "References": [],
        "See Also": "Graph.__plot__"
    },
    {
        "Section_id": "mpl",
        "Description": "Undocumented"
    },
    {
        "Section_id": "plt",
        "Description": "Undocumented"
    },
    {
        "Section_id": "UpTriangleDrawer",
        "Description": "Static class which draws upright triangles",
        "Field List": {
            "Methods": {
                "draw_path": {
                    "Description": "overrides igraph.drawing.shapes.ShapeDrawer.draw_path\nDraws an upright triangle on the Cairo context without stroking or filling it.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "ShapeDrawer.draw_path",
                    "example": []
                },
                "intersection_point": {
                    "Description": "overrides igraph.drawing.shapes.ShapeDrawer.intersection_point\nDetermines where the triangle centered at (center_x, center_y) intersects with a line drawn from (source_x, source_y) to (center_x, center_y).",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "ShapeDrawer.intersection_point",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "AbstractVertexDrawer",
        "Description": "Abstract vertex drawer object from which all concrete vertex drawer implementations are derived.",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "overridden in igraph.drawing.cairo.vertex.AbstractCairoVertexDrawer, igraph.drawing.matplotlib.vertex.MatplotlibVertexDrawer, igraph.drawing.plotly.vertex.PlotlyVerticesDrawer\nConstructs the vertex drawer and associates it to the given palette.",
                    "Paramters": {
                        "palette": "the  that can be used to map integer color indices to colors when drawing vertices",
                        "layout": "the  of the vertices in the graph being drawn"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw": {
                    "Description": "overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nDraws the given vertex.",
                    "Paramters": {
                        "visual_vertex": "object specifying the visual properties of the vertex. Its structure is defined by the VisualVertexBuilder of the CairoGraphDrawer; see its source code.",
                        "vertex": "the raw igraph  being drawn",
                        "coords": "the X and Y coordinates of the vertex as specified by the layout algorithm, scaled into the bounding box."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "CairoPlot",
        "Description": "Class representing an arbitrary plot that uses the Cairo plotting backend.\nObjects that you can plot include graphs, matrices, palettes, clusterings, covers, and dendrograms.\nIn Cairo, every plot has an associated surface object. The surface is an instance of cairo.Surface, a member of the pycairo library. The surface itself provides a unified API to various plotting targets like SVG files, X11 windows, PostScript files, PNG files and so on. igraph does not usually know on which surface it is plotting at each point in time, since pycairo takes care of the actual drawing. Everything that's supported by pycairo should be supported by this class as well.\nCurrent Cairo surfaces include: cairo.GlitzSurface -- OpenGL accelerated surface for the X11 Window System. cairo.ImageSurface -- memory buffer surface. Can be written to a PNG image file. cairo.PDFSurface -- PDF document surface. cairo.PSSurface -- PostScript document surface. cairo.SVGSurface -- SVG (Scalable Vector Graphics) document surface. cairo.Win32Surface -- Microsoft Windows screen rendering. cairo.XlibSurface -- X11 Window System screen rendering. \nIf you create a Plot object with a string given as the target surface, the string will be treated as a filename, and its extension will decide which surface class will be used. Please note that not all surfaces might be available, depending on your pycairo installation.\nA Plot has an assigned default palette (see igraph.drawing.colors.Palette) which is used for plotting objects.\nA Plot object also has a list of objects to be plotted with their respective bounding boxes, palettes and opacities. Palettes assigned to an object override the default palette of the plot. Objects can be added by the Plot.add method and removed by the Plot.remove method.",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "Creates a new plot.",
                    "Paramters": {
                        "target": "the  surface to write to. It can be one of the following types:None -- a Cairo surface will be created and the object will be plotted there.cairo.Surface -- the given Cairo surface will be used.string -- a file with the given name will be created and an appropriate Cairo surface will be attached to it.",
                        "bbox": "the bounding box of the surface. It is interpreted differently with different surfaces: PDF and PS surfaces will treat it as points (1 point = 1/72 inch). Image surfaces will treat it as pixels. SVG surfaces will treat it as an abstract unit, but it will mostly be interpreted as pixels when viewing the SVG file in Firefox.",
                        "palette": "the  primarily used on the plot if the added objects do not specify a private . Must be either an igraph.drawing.colors.Palette object or a string referring to a valid key of igraph.drawing.colors.s (see module igraph.drawing.colors) or None. In the latter case, the default  given by the configuration key plotting. is used.",
                        "background": "the  color. If None, the  will be transparent. You can use any color specification here that is understood by igraph.drawing.colors.color_name_to_rgba."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "add": {
                    "Description": "Adds an object to the plot.\nArguments not specified here are stored and passed to the object's plotting function when necessary. Since you are most likely interested in the arguments acceptable by graphs, see Graph.__plot__ for more details.",
                    "Paramters": {
                        "obj": "the ect to be added",
                        "bbox": "the bounding box of the object. If None, the object will fill the entire area of the plot.",
                        "palette": "the color  used for drawing the object. If the object tries to get a color assigned to a positive integer, it will use this . If None, defaults to the global  of the plot.",
                        "opacity": "the  of the object being plotted, in the range 0.0-1.0",
                        "*args": "Undocumented",
                        "**kwds": "Undocumented"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "Graph.__plot__",
                    "example": []
                },
                "background": {
                    "Description": "Sets the background color of the plot. None means a transparent background. You can use any color specification here that is understood by the get method of the current palette or by igraph.drawing.colors.color_name_to_rgb.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "mark_dirty": {
                    "Description": "Marks the plot as dirty (should be redrawn)",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "redraw": {
                    "Description": "Redraws the plot",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "remove": {
                    "Description": "Removes an object from the plot.\nIf the object has been added multiple times and no bounding box was specified, it removes the instance which occurs idxth in the list of identical instances of the object.",
                    "Paramters": {
                        "obj": "the ect to be removed",
                        "bbox": "optional bounding box specification for the object. If given, only objects with exactly this bounding box will be considered.",
                        "idx": "if multiple objects match the specification given by obj and bbox, only the th occurrence will be removed."
                    },
                    "Return": [
                        "True if the object has been removed successfully, False if the object was not on the plot at all or idx was larger than the count of occurrences"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "save": {
                    "Description": "Saves the plot.",
                    "Paramters": {
                        "fname": "the filename to save to. It is ignored if the surface of the plot is not an ImageSurface."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {
                "background": "Returns the background color of the plot. None means a transparent background.\n",
                "bounding_box": "Returns the bounding box of the Cairo surface as a BoundingBox object\n",
                "height": "Returns the height of the Cairo surface on which the plot is drawn\n",
                "surface": "Returns the Cairo surface on which the plot is drawn\n",
                "width": "Returns the width of the Cairo surface on which the plot is drawn\n"
            }
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "GraphSummary",
        "Description": "Summary representation of a graph.\n",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "Constructs a summary representation of a graph.",
                    "Paramters": {
                        "graph": "Undocumented",
                        "verbosity": "the  of the summary. If zero, only the header line will be returned. If one, the header line and the list of edges will both be returned.",
                        "width": "the maximal  of each line in the summary. None means that no limit will be enforced.",
                        "edge_list_format": "format of the edge list in the summary. Supported formats are: compressed, adjlist, edgelist, auto, which selects automatically from the other three based on some simple criteria.",
                        "max_rows": "the maximal number of rows to print in a single table (e.g., vertex attribute table or edge attribute table)",
                        "print_graph_attributes": "whether to print graph attributes if there are any.",
                        "print_vertex_attributes": "whether to print vertex attributes if there are any.",
                        "print_edge_attributes": "whether to print edge attributes if there are any.",
                        "full": "False has no effect; True turns on the attribute printing for graph, vertex and edge attributes with verbosity 1."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__str__": {
                    "Description": "Returns the summary representation as a string.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": [
                "The summary representation includes a header line and the list of edges. The header line consists of IGRAPH, followed by a four-character long code, the number of vertices, the number of edges, two dashes (--) and the name of the graph (i.e. the contents of the name attribute, if any). For instance, a header line may look like this:\n    IGRAPH U--- 4 5 --\n"
            ]
        }
    },
    {
        "Section_id": "EdgeSeq",
        "Description": "Low-level representation of an edge sequence.\nDon't use it directly, use igraph.EdgeSeq instead.",
        "Field List": {
            "Methods": {
                "attribute_names": {
                    "Description": "Returns the attribute name list of the graph's edges",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "find": {
                    "Description": "overridden in igraph.EdgeSeq\nFor internal use only.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_attribute_values": {
                    "Description": "Returns the value of a given edge attribute for all edges.",
                    "Paramters": {
                        "attrname": "the name of the attribute"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "is_all": {
                    "Description": "Returns whether the edge sequence contains all the edges exactly once, in the order of their edge IDs.\nThis is used for optimizations in some of the edge selector routines.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "select": {
                    "Description": "overridden in igraph.EdgeSeq\nFor internal use only.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "set_attribute_values": {
                    "Description": "Sets the value of a given edge attribute for all vertices",
                    "Paramters": {
                        "attrname": "the name of the attribute",
                        "values": "the new attribute  in a list"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "Configuration",
        "Description": "Class representing igraph configuration details.\nNote that there is one primary instance of this class, which is used by igraph itself to retrieve configuration parameters when needed. You can access this instance with the instance() method. You may construct other instances by invoking the constructor directly, but these instances will not affect igraph's behaviour. If you are interested in configuring igraph, use igraph.config to get hold of the singleton instance and then modify it. General ideas The configuration of igraph is stored in the form of name-value pairs. This object provides an interface to the configuration data using the syntax known from dict:  >>> c = Configuration() >>> c[\"general.verbose\"] = True >>> print(c[\"general.verbose\"]) True Configuration keys are organized into sections, and the name to be used for a given key is always in the form section.keyname, like general.verbose in the example above. In that case, general is the name of the configuration section, and verbose is the name of the key. If the name of the section is omitted, it defaults to general, so general.verbose can be referred to as verbose:  >>> c = Configuration() >>> c[\"verbose\"] = True >>> print(c[\"general.verbose\"]) True User-level configuration is stored in ~/.igraphrc per default on Linux and Mac OS X systems, or in C:\\Documents and Settings\\username\\.igraphrc on Windows systems. However, this configuration is read only when igraph is launched through its shell interface defined in igraph.app.shell. This behaviour might change before version 1.0.  Known configuration keys The known configuration keys are presented below, sorted by section. When referring to them in program code, don't forget to add the section name, expect in the case of section general.  General settings These settings are all stored in section general.  shells: the list of preferred Python shells to be used with the command-line igraph script. The shells in the list are tried one by one until any of them is found on the system. igraph functions are then imported into the main namespace of the shell and the shell is launched. Known shells and their respective class names to be used can be found in igraph.app.shell. Example: IPythonShell, ClassicPythonShell. This is the default, by the way. verbose: whether igraph should talk more than really necessary. For instance, if set to True, some functions display progress bars.    Plotting settings These settings specify the default values used by plotting functions. They are all stored in section plotting.  backend: either \"cairo\" if you want to use Cairo for plotting or \"matplotlib\" if you want to use the Matplotlib plotting backend. layout: default graph layout algorithm to be used. mark_groups: whether to mark the clusters by polygons when plotting a clustering object. palette: default palette to be used for converting integer numbers to colors. See colors.Palette for more information. Valid palette names are stored in colors.palettes. wrap_labels: whether to try to wrap the labels of the vertices automatically if they don't fit within the vertex. Default: False.    Shell settings These settings specify options for external environments in which igraph is embedded (e.g., IPython and its Qt console). These settings are stored in section shell.  ipython.inlining.Plot: whether to show instances of the Plot class inline in IPython's console if the console supports it. Default: True   ",
        "Field List": {
            "Methods": {
                "instance": {
                    "Description": "Returns the single instance of the configuration object.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__contains__": {
                    "Description": "Checks whether the given configuration item is set.",
                    "Paramters": {
                        "item": ":strthe configuration key to check."
                    },
                    "Return": [
                        "boolTrue if the key has an associated value, False otherwise."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__delitem__": {
                    "Description": "Deletes the given item from the configuration.\nIf the item has a default value, the default value is written back instead of the current value. Without a default value, the item is really deleted.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__getitem__": {
                    "Description": "Returns the given configuration item.",
                    "Paramters": {
                        "item": ":strthe configuration key to retrieve."
                    },
                    "Return": [
                        "the configuration value"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__init__": {
                    "Description": "Creates a new configuration instance.",
                    "Paramters": {
                        "filename": "file or file-like object to be read. Can be omitted."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__setitem__": {
                    "Description": "Sets the given configuration item.",
                    "Paramters": {
                        "item": ":strthe configuration key to set",
                        "value": "the new  of the configuration key"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "has_key": {
                    "Description": "Checks if the configuration has a given key.",
                    "Paramters": {
                        "item": ":strthe key being sought"
                    },
                    "Return": [
                        "boolUndocumented"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "load": {
                    "Description": "Loads the configuration from the given file.",
                    "Paramters": {
                        "stream": "name of a file or a file object. The configuration will be loaded from here. Can be omitted, in this case, the user-level configuration is loaded."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "save": {
                    "Description": "Saves the configuration.",
                    "Paramters": {
                        "stream": ":Optional[Union[str, IO[str]]]name of a file or a file-like object. The configuration will be saved there. Can be omitted, in this case, the user-level configuration file will be overwritten."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {
                "filename": "Returns the filename associated to the object.\nIt is usually the name of the configuration file that was used when creating the object. Configuration.load always overwrites it with the filename given to it. If None, the configuration was either created from scratch or it was updated from a stream without name information.\n\n"
            }
        },
        "Rubric": {
            "Example": [
                "The configuration of igraph is stored in the form of name-value pairs. This object provides an interface to the configuration data using the syntax known from dict:\n>>> c = Configuration()\n>>> c[\"general.verbose\"] = True\n>>> print(c[\"general.verbose\"])\nTrue\n",
                "Configuration keys are organized into sections, and the name to be used for a given key is always in the form section.keyname, like general.verbose in the example above. In that case, general is the name of the configuration section, and verbose is the name of the key. If the name of the section is omitted, it defaults to general, so general.verbose can be referred to as verbose:\n>>> c = Configuration()\n>>> c[\"general.verbose\"] = True\n>>> print(c[\"general.verbose\"])\nTrue\n"
            ]
        }
    },
    {
        "Section_id": "VertexSeq",
        "Description": "Class representing a sequence of vertices in the graph.\nThis class is most easily accessed by the vs field of the Graph object, which returns an ordered sequence of all vertices in the graph. The vertex sequence can be refined by invoking the VertexSeq.select() method. VertexSeq.select() can also be accessed by simply calling the VertexSeq object.\n",
        "Field List": {
            "Methods": {
                "__call__": {
                    "Description": "Shorthand notation to select()\nThis method simply passes all its arguments to VertexSeq.select().",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "attributes": {
                    "Description": "Returns the list of all the vertex attributes in the graph associated to this vertex sequence.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "find": {
                    "Description": "overrides igraph._igraph.VertexSeq.find\nReturns the first vertex of the vertex sequence that matches some criteria.\nThe selection criteria are equal to the ones allowed by VertexSeq.select. See VertexSeq.select for more details.\nFor instance, to find the first vertex with name foo in graph g:",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": [
                        "For instance, to find the first vertex with name foo in graph g:\n>>> g.vs.find(name=\"foo\")            #doctest:+SKIP",
                        "To find an arbitrary isolated vertex:\n>>> g.vs.find(name=\"foo\")            #doctest:+SKIP"
                    ]
                },
                "select": {
                    "Description": "overrides igraph._igraph.VertexSeq.select\nSelects a subset of the vertex sequence based on some criteria\nThe selection criteria can be specified by the positional and the keyword arguments. Positional arguments are always processed before keyword arguments.If the first positional argument is None, an empty sequence is returned.If the first positional argument is a callable object, the object will be called for every vertex in the sequence. If it returns True, the vertex will be included, otherwise it will be excluded.If the first positional argument is an iterable, it must return integers and they will be considered as indices of the current vertex set (NOT the whole vertex set of the graph -- the difference matters when one filters a vertex set that has already been filtered by a previous invocation of VertexSeq.select(). In this case, the indices do not refer directly to the vertices of the graph but to the elements of the filtered vertex sequence.If the first positional argument is an integer, all remaining arguments are expected to be integers. They are considered as indices of the current vertex set again.\nKeyword arguments can be used to filter the vertices based on their attributes. The name of the keyword specifies the name of the attribute and the filtering operator, they should be concatenated by an underscore (_) character. Attribute names can also contain underscores, but operator names don't, so the operator is always the largest trailing substring of the keyword name that does not contain an underscore. Possible operators are:eq: equal tone: not equal tolt: less thangt: greater thanle: less than or equal toge: greater than or equal toin: checks if the value of an attribute is in a given listnotin: checks if the value of an attribute is not in a given list\nFor instance, if you want to filter vertices with a numeric age property larger than 200, you have to write:",
                    "Paramters": {},
                    "Return": [
                        "the new, filtered vertex sequence"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": [
                        "For instance, if you want to filter vertices with a numeric age property larger than 200, you have to write:\n>>> g.vs.select(age_gt=200)                   #doctest: +SKIP",
                        "Similarly, to filter vertices whose type is in a list of predefined types:\n>>> g.vs.select(age_gt=200)                   #doctest: +SKIP",
                        "If the operator is omitted, it defaults to eq. For instance, the following selector selects vertices whose cluster property equals to 2:\n>>> g.vs.select(age_gt=200)                   #doctest: +SKIP",
                        "Attribute names inferred from keyword arguments are treated specially if they start with an underscore (_). These are not real attributes but refer to specific properties of the vertices, e.g., its degree. The rule is as follows: if an attribute name starts with an underscore, the rest of the name is interpreted as a method of the Graph object. This method is called with the vertex sequence as its first argument (all others left at default values) and vertices are filtered according to the value returned by the method. For instance, if you want to exclude isolated vertices:\n>>> g.vs.select(age_gt=200)                   #doctest: +SKIP",
                        "For properties that take a long time to be computed (e.g., betweenness centrality for large graphs), it is advised to calculate the values in advance and store it in a graph attribute. The same applies when you are selecting based on the same property more than once in the same select() call to avoid calculating it twice unnecessarily. For instance, the following would calculate betweenness centralities twice:\n>>> g.vs.select(age_gt=200)                   #doctest: +SKIP",
                        "It is advised to use this instead:\n>>> g.vs.select(age_gt=200)                   #doctest: +SKIP"
                    ]
                },
                "attribute_names": {
                    "Description": "Inherited from VertexSeq:Returns the attribute name list of the graph's vertices"
                },
                "get_attribute_values": {
                    "Description": "Inherited from VertexSeq:Returns the value of a given vertex attribute for all vertices in a list."
                },
                "set_attribute_values": {
                    "Description": "Inherited from VertexSeq:Sets the value of a given vertex attribute for all vertices"
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": [
                "An alternative way to create a vertex sequence referring to a given graph is to use the constructor directly:\n>>> g = Graph.Full(3)\n>>> vs = VertexSeq(g)\n>>> restricted_vs = VertexSeq(g, [0, 1])",
                "The individual vertices can be accessed by indexing the vertex sequence object. It can be used as an iterable as well, or even in a list comprehension:\n>>> g = Graph.Full(3)\n>>> vs = VertexSeq(g)\n>>> restricted_vs = VertexSeq(g, [0, 1])",
                "The vertex set can also be used as a dictionary where the keys are the attribute names. The values corresponding to the keys are the values of the given attribute for every vertex selected by the sequence.\n>>> g = Graph.Full(3)\n>>> vs = VertexSeq(g)\n>>> restricted_vs = VertexSeq(g, [0, 1])",
                "If you specify a sequence that is shorter than the number of vertices in the VertexSeq, the sequence is reused:\n>>> g = Graph.Full(3)\n>>> vs = VertexSeq(g)\n>>> restricted_vs = VertexSeq(g, [0, 1])",
                "You can even pass a single string or integer, it will be considered as a sequence of length 1:\n>>> g = Graph.Full(3)\n>>> vs = VertexSeq(g)\n>>> restricted_vs = VertexSeq(g, [0, 1])",
                "Some methods of the vertex sequences are simply proxy methods to the corresponding methods in the Graph object. One such example is VertexSeq.degree():\n>>> g = Graph.Full(3)\n>>> vs = VertexSeq(g)\n>>> restricted_vs = VertexSeq(g, [0, 1])"
            ]
        }
    },
    {
        "Section_id": "AbstractDrawer",
        "Description": "Abstract class that serves as a base class for anything that draws an igraph object.",
        "Field List": {
            "Methods": {
                "draw": {
                    "Description": "overridden in igraph.drawing.baseclasses.AbstractGraphDrawer, igraph.drawing.baseclasses.AbstractVertexDrawer, igraph.drawing.cairo.coord.CoordinateSystem, igraph.drawing.cairo.dendrogram.CairoDendrogramDrawer, igraph.drawing.cairo.graph.CairoGraphDrawer, igraph.drawing.cairo.histogram.CairoHistogramDrawer, igraph.drawing.cairo.matrix.CairoMatrixDrawer, igraph.drawing.cairo.palette.CairoPaletteDrawer, igraph.drawing.cairo.polygon.CairoPolygonDrawer, igraph.drawing.cairo.text.CairoTextDrawer, igraph.drawing.cairo.vertex.CairoVertexDrawer, igraph.drawing.graph.CytoscapeGraphDrawer, igraph.drawing.matplotlib.dendrogram.MatplotlibDendrogramDrawer, igraph.drawing.matplotlib.histogram.MatplotlibHistogramDrawer, igraph.drawing.matplotlib.matrix.MatplotlibMatrixDrawer, igraph.drawing.matplotlib.palette.MatplotlibPaletteDrawer\nAbstract method, must be implemented in derived classes.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "Edge",
        "Description": "Class representing a single edge in a graph.\nThe edge is referenced by its index, so if the underlying graph changes, the semantics of the edge object might change as well (if the edge indices are altered in the original graph).\n",
        "Field List": {
            "Methods": {
                "attribute_names": {
                    "Description": "Returns the list of edge attribute names",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "attributes": {
                    "Description": "Returns a dict of attribute names and values for the edge",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "count_multiple": {
                    "Description": "Proxy method to Graph.count_multiple()\nThis method calls the count_multiple method of the Graph class with this edge as the first argument, and returns the result.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "Graph.count_multiple() for details.",
                    "example": []
                },
                "delete": {
                    "Description": "Proxy method to Graph.delete_edges()\nThis method calls the delete_edges method of the Graph class with this edge as the first argument, and returns the result.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "Graph.delete_edges() for details.",
                    "example": []
                },
                "is_loop": {
                    "Description": "Proxy method to Graph.is_loop()\nThis method calls the is_loop method of the Graph class with this edge as the first argument, and returns the result.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "Graph.is_loop() for details.",
                    "example": []
                },
                "is_multiple": {
                    "Description": "Proxy method to Graph.is_multiple()\nThis method calls the is_multiple method of the Graph class with this edge as the first argument, and returns the result.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "Graph.is_multiple() for details.",
                    "example": []
                },
                "is_mutual": {
                    "Description": "Proxy method to Graph.is_mutual()\nThis method calls the is_mutual method of the Graph class with this edge as the first argument, and returns the result.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "Graph.is_mutual() for details.",
                    "example": []
                },
                "update_attributes": {
                    "Description": "Updates the attributes of the edge from dict/iterable E and F.\nIf E has a keys() method, it does: for k in E: self[k] = E[k]. If E lacks a keys() method, it does: for (k, v) in E: self[k] = v. In either case, this is followed by: for k in F: self[k] = F[k].\nThis method thus behaves similarly to the update() method of Python dictionaries.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": [
                "The attributes of the edge can be accessed by using the edge as a hash:\n>>> e[\"weight\"] = 2                  #doctest: +SKIP\n>>> print(e[\"weight\"])               #doctest: +SKIP\n2\n"
            ]
        }
    },
    {
        "Section_id": "autocurve",
        "Description": "Calculates curvature values for each of the edges in the graph to make sure that multiple edges are shown properly on a graph plot.\nThis function checks the multiplicity of each edge in the graph and assigns curvature values (numbers between -1 and 1, corresponding to CCW (-1), straight (0) and CW (1) curved edges) to them. The assigned values are either stored in an edge attribute or returned as a list, depending on the value of the attribute argument.",
        "Paramters": {
            "graph": "the  on which the calculation will be run",
            "attribute": "the name of the edge  to save the curvature values to. The default value is curved, which is the name of the edge  the default graph plotter checks to decide whether an edge should be curved on the plot or not. If  is None, the result will not be stored.",
            "default": "the  curvature for single edges. Zero means that single edges will be straight. If you want single edges to be curved as well, try passing 0.5 or -0.5 here."
        },
        "Return": [
            "the list of curvature values if attribute is None, otherwise None."
        ],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "calculate_corner_radii",
        "Description": "Given a list of points and a desired corner radius, returns a list containing proposed corner radii for each of the points such that it is ensured that the corner radius at a point is never larger than half of the minimum distance between the point and its neighbors.",
        "Paramters": {},
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "euclidean_distance",
        "Description": "Computes the Euclidean distance between points (x1,y1) and (x2,y2).",
        "Paramters": {},
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "evaluate_cubic_bezier",
        "Description": "Evaluates the Bezier curve from point (x0,y0) to (x3,y3) via control points (x1,y1) and (x2,y2) at t. t is typically in the range [0; 1] such that 0 returns (x0, y0) and 1 returns (x3, y3).",
        "Paramters": {},
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "get_bezier_control_points_for_curved_edge",
        "Description": "Helper function that calculates the Bezier control points for a curved edge that goes from (x1, y1) to (x2, y2).",
        "Paramters": {},
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "intersect_bezier_curve_and_circle",
        "Description": "Binary search solver for finding the intersection of a Bezier curve and a circle centered at the curve's end point.\nReturns the x, y coordinates of the intersection point.",
        "Paramters": {},
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "str_to_orientation",
        "Description": "Tries to interpret a string as an orientation value.\nThe following basic values are understood: ``left-right``, ``bottom-top``, ``right-left``, ``top-bottom``. Possible aliases are:``horizontal``, ``horiz``, ``h`` and ``lr`` for ``left-right````vertical``, ``vert``, ``v`` and ``tb`` for top-bottom.``lr`` for ``left-right``.``rl`` for ``right-left``.\n``reversed_horizontal`` reverses the meaning of ``horizontal``, ``horiz`` and ``h`` to ``rl`` (instead of ``lr``); similarly, ``reversed_vertical`` reverses the meaning of ``vertical``, ``vert`` and ``v`` to ``bt`` (instead of ``tb``).\nReturns one of ``lr``, ``rl``, ``tb`` or ``bt``, or throws ``ValueError`` if the string cannot be interpreted as an orientation.",
        "Paramters": {},
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "AttributeCollectorMeta",
        "Description": "Metaclass for attribute collector classes\nClasses that use this metaclass are intended to collect vertex/edge attributes from various sources (a Python dict, a vertex/edge sequence, default values from the igraph configuration and such) in a given order of precedence. See the module documentation for more details. This metaclass enables the user to use a simple declarative syntax to specify which attributes he is interested in. For each vertex/edge attribute, a corresponding class attribute must be defined with a value that describes the default value of that attribute if no other data source provides us with any suitable value. The default value can also be a tuple; in that case, the first element of the tuple is the actual default value, the second element is a converter function that will convert the attribute values to a format expected by the caller who uses the class being defined.\nThere is a special class attribute called _kwds_prefix; this is not used as an attribute declaration. It can contain a string which will be used to derive alternative names for the attributes when the attribute is accessed in a Python dict. This is useful in many situations; for instance, the default graph drawer would want to access the vertex colors using the color vertex attribute, but when it looks at the keyword arguments passed to the original call of igraph.Graph.__plot__, the vertex_color keyword argument should be looked up because we also have colors for the edges. _kwds_prefix will be prepended to the attribute names when they are looked up in a dict of keyword arguments.\nIf you require a more fine-tuned behaviour, you can assign an AttributeSpecification instance to a class attribute directly.See AlsoAttributeCollectorBase",
        "Field List": {
            "Methods": {
                "record_generator": {
                    "Description": "Generates a simple class that has the given slots and nothing else",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__new__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "operator_method_registry",
        "Description": "Undocumented"
    },
    {
        "Section_id": "multidict",
        "Description": "A dictionary-like object that is customized to deal with multiple values for the same key.\nEach value in this dictionary will be a list. Methods which emulate the methods of a standard Python dict object will return or manipulate the first items of the lists only. Special methods are provided to deal with keys having multiple values.",
        "Field List": {
            "Methods": {
                "__contains__": {
                    "Description": "Returns whether there are any items associated to the givenkey.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__delitem__": {
                    "Description": "Removes all the items associated to the given key.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__getitem__": {
                    "Description": "Returns an arbitrary item associated to the given key. Raises KeyErrorif no such key exists.\nExample:>>> d = multidict([(\"spam\", \"eggs\"), (\"spam\", \"bacon\")])>>> d[\"spam\"]'eggs'",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": [
                        ">>> d = multidict([(\"spam\", \"eggs\"), (\"spam\", \"bacon\")])\n>>> d[\"spam\"]\n'eggs'\n"
                    ]
                },
                "__init__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__iter__": {
                    "Description": "Iterates over the keys of the multidict.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__len__": {
                    "Description": "Returns the number of distinct keys in this multidict.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__setitem__": {
                    "Description": "Sets the item associated to the given key. Any values associated to thekey will be erased and replaced by value.\nExample:>>> d = multidict([(\"spam\", \"eggs\"), (\"spam\", \"bacon\")])>>> d[\"spam\"] = \"ham\">>> d[\"spam\"]'ham'",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": [
                        ">>> d = multidict([(\"spam\", \"eggs\"), (\"spam\", \"bacon\")])\n>>> d[\"spam\"] = \"ham\"\n>>> d[\"spam\"]\n'ham'\n"
                    ]
                },
                "add": {
                    "Description": "Adds value to the list of items associated to key.\nExample:>>> d = multidict()>>> d.add(\"spam\", \"ham\")>>> d[\"spam\"]'ham'>>> d.add(\"spam\", \"eggs\")>>> d.getlist(\"spam\")['ham', 'eggs']",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": [
                        ">>> d = multidict()\n>>> d.add(\"spam\", \"ham\")\n>>> d[\"spam\"]\n'ham'\n>>> d.add(\"spam\", \"eggs\")\n>>> d.getlist(\"spam\")\n['ham', 'eggs']\n"
                    ]
                },
                "clear": {
                    "Description": "Removes all the items from the multidict.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get": {
                    "Description": "Returns an arbitrary item associated to the given key. If keydoes not exist or has zero associated items, default will bereturned.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "getlist": {
                    "Description": "Returns the list of values for the given key. An empty list willbe returned if there is no such key.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "iterlists": {
                    "Description": "Iterates over (key, values) pairs where values is the listof values associated with key.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "lists": {
                    "Description": "Returns a list of (key, values) pairs where values is the listof values associated with key.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "update": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "IPythonShell",
        "Description": "IPython embedded shell interface.\nThis class allows igraph to be embedded in IPython's interactive shell.",
        "Field List": {
            "Methods": {
                "__call__": {
                    "Description": "overrides igraph.app.shell.Shell.__call__\nStarts the embedded shell.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__init__": {
                    "Description": "overrides igraph.app.shell.ConsoleProgressBarMixin.__init__\nConstructor.\nImports IPython's embedded shell with separator lines removed.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_progress_handler": {
                    "Description": "Inherited from Shell:Returns the progress handler (if exists) or None (if not)."
                },
                "get_status_handler": {
                    "Description": "Inherited from Shell:Returns the status handler (if exists) or None (if not)."
                },
                "supports_progress_bar": {
                    "Description": "Inherited from Shell:Checks whether the shell supports progress bars."
                },
                "supports_status_messages": {
                    "Description": "Inherited from Shell:Checks whether the shell supports status messages."
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "PlotlyGraphDrawer",
        "Description": "Graph drawer that uses a pyplot.Axes as context",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "Constructs the graph drawer and associates it with the plotly Figure",
                    "Paramters": {
                        "fig": "the plotly.graph_objects.Figure to draw into.",
                        "vertex_drawer_factory": "Undocumented",
                        "edge_drawer_factory": "Undocumented"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw": {
                    "Description": "overrides igraph.drawing.baseclasses.AbstractGraphDrawer.draw\nAbstract method, must be implemented in derived classes.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "CoordinateSystem",
        "Description": "Class implementing a coordinate system object.\nCoordinate system objects are used when drawing plots which 2D or 3D coordinate system axes. This is an abstract class which must be extended in order to use it. In general, you'll only need the documentation of this class if you intend to implement an own coordinate system not present in igraph yet.",
        "Field List": {
            "Methods": {
                "draw": {
                    "Description": "overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nDraws the coordinate system.\nThis method must be overridden in derived classes.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "local_to_context": {
                    "Description": "overridden in igraph.drawing.cairo.coord.DescartesCoordinateSystem\nConverts local coordinates to the context coordinate system (given by the bounding box).\nThis method must be overridden in derived classes.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__init__": {
                    "Description": "Inherited from AbstractCairoDrawer:Constructs the drawer and associates it to the given Cairo context and the given BoundingBox."
                },
                "bbox.setter": {
                    "Description": "Inherited from AbstractCairoDrawer:Sets the bounding box of the drawing area where this drawer will draw."
                }
            },
            "property": {
                "bbox": "Inherited from AbstractCairoDrawer:The bounding box of the drawing area where this drawer will draw."
            }
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "disjoint_union",
        "Description": "Graph disjoint union.\nThe disjoint union of two or more graphs is created.\nThis function keeps the attributes of all graphs. All graph, vertex andedge attributes are copied to the result. If an attribute is present inmultiple graphs and would result a name clash, then this attribute isrenamed by adding suffixes: _1, _2, etc.\nAn error is generated if some input graphs are directed and others areundirected.",
        "Paramters": {
            "graphs": "list of . A lazy sequence is not acceptable."
        },
        "Return": [
            "the disjoint union graph"
        ],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "intersection",
        "Description": "Graph intersection.\nThe intersection of two or more graphs is created. The graphs may haveidentical or overlapping vertex sets. Edges which are included in allgraphs will be part of the new graph.\nThis function keeps the attributes of all graphs. All graph, vertex andedge attributes are copied to the result. If an attribute is present inmultiple graphs and would result a name clash, then this attribute isrenamed by adding suffixes: _1, _2, etc.\nThe name vertex attribute is treated specially if the operation isperformed based on symbolic vertex names. In this case name must bepresent in all graphs, and it is not renamed in the result graph.\nAn error is generated if some input graphs are directed and others areundirected.",
        "Paramters": {
            "graphs": "list of . A lazy sequence is not acceptable.",
            "byname": "bool or 'auto' specifying the function behaviour withrespect to names vertices (i.e. vertices with the 'name' attribute). IfFalse, ignore vertex names. If True, merge vertices based on names. If'auto', use True if all graphs have named vertices and False otherwise(in the latter case, a warning is generated too).",
            "keep_all_vertices": "bool specifying if vertices that are not presentin all graphs should be kept in the intersection."
        },
        "Return": [
            "the intersection graph"
        ],
        "Raises": {
            "RuntimeError": "if 'byname' is set to True and some graphs are not named or\nthe set of names is not unique in one of the graphs"
        },
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "name_set",
        "Description": "Converts a list of names to a set of names while checking for duplicates.",
        "Paramters": {
            "names": "the list of  to convert"
        },
        "Return": [
            "the set of unique names appearing in the list"
        ],
        "Raises": {
            "RuntimeError": "if the input name list has duplicates"
        },
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "union",
        "Description": "Graph union.\nThe union of two or more graphs is created. The graphs may have identicalor overlapping vertex sets. Edges which are included in at least one graphwill be part of the new graph.\nThis function keeps the attributes of all graphs. All graph, vertex andedge attributes are copied to the result. If an attribute is present inmultiple graphs and would result a name clash, then this attribute isrenamed by adding suffixes: _1, _2, etc.\nThe name vertex attribute is treated specially if the operation isperformed based on symbolic vertex names. In this case name must bepresent in all graphs, and it is not renamed in the result graph.\nAn error is generated if some input graphs are directed and others areundirected.",
        "Paramters": {
            "graphs": "list of . A lazy sequence is not acceptable.",
            "byname": "bool or 'auto' specifying the function behaviour withrespect to names vertices (i.e. vertices with the 'name' attribute). IfFalse, ignore vertex names. If True, merge vertices based on names. If'auto', use True if all graphs have named vertices and False otherwise(in the latter case, a warning is generated too)."
        },
        "Return": [
            "the union graph"
        ],
        "Raises": {
            "RuntimeError": "if 'byname' is set to True and some graphs are not named or\nthe set of names is not unique in one of the graphs"
        },
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "CairoPolygonDrawer",
        "Description": "Class that is used to draw polygons in Cairo.\nThe corner points of the polygon can be set by the points property of the drawer, or passed at construction time. Most drawing methods in this class also have an extra points argument that can be used to override the set of points in the points property.",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "overrides igraph.drawing.cairo.base.AbstractCairoDrawer.__init__\nConstructs a new polygon drawer that draws on the given Cairo context.",
                    "Paramters": {
                        "context": "the Cairo  to draw on",
                        "bbox": "ignored, leave it at its default value"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw": {
                    "Description": "overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nDraws the polygon using the current stroke of the Cairo context.",
                    "Paramters": {
                        "points": "the coordinates of the corners of the polygon, in clockwise or counter-clockwise order."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw_path": {
                    "Description": "Sets up a Cairo path for the outline of a polygon on the given Cairo context.",
                    "Paramters": {
                        "points": "the coordinates of the corners of the polygon, in clockwise or counter-clockwise order.",
                        "corner_radius": "if zero, an ordinary polygon will be drawn. If positive, the corners of the polygon will be rounded with the given radius."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "bbox.setter": {
                    "Description": "Inherited from AbstractCairoDrawer:Sets the bounding box of the drawing area where this drawer will draw."
                }
            },
            "property": {
                "bbox": "Inherited from AbstractCairoDrawer:The bounding box of the drawing area where this drawer will draw."
            }
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "main",
        "Description": "The main entry point for igraph when invoked from the command line shell",
        "Paramters": {},
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "get_user_config_file",
        "Description": "Returns the path where the user-level configuration file is stored",
        "Paramters": {},
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "init",
        "Description": "Default mechanism to initiate igraph configuration\nThis method loads the user-specific configuration file from the user's home directory, or if it does not exist, creates a default configuration.\nThe method is safe to be called multiple times, it will not parse the configuration file twice.",
        "Paramters": {},
        "Return": [
            "Configurationthe Configuration object loaded or created."
        ],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "ARPACKOptions",
        "Description": "Class representing the parameters of the ARPACK module.\nARPACK is a Fortran implementation of the implicitly restarted Arnoldi method, an algorithm for calculating some of the eigenvalues and eigenvectors of a given matrix. igraph uses this package occasionally, and this class can be used to fine-tune the behaviour of ARPACK in such cases.\nThe class has several attributes which are not documented here, since they are usually of marginal use to the ordinary user. See the source code of the original ARPACK Fortran package (especially the file dsaupd.f) for a detailed explanation of the parameters. Only the most basic attributes are explained here. Most of them are read only unless stated otherwise. bmat: type of the eigenproblem solved. 'I' means standard eigenproblem (A*x = lambda*x), 'G' means generalized eigenproblem (A*x = lambda*B*x). n: dimension of the eigenproblem tol: precision. If less than or equal to zero, the standard machine precision is used as computed by the LAPACK utility called dlamch. This can be modified. mxiter: maximum number of update iterations to take. This can be modified. You can also use maxiter. iter: actual number of update iterations taken numop: total number of OP*x operations numopb: total number of B*x operations if bmat is 'G' numreo: total number of steps of re-orthogonalization ",
        "Field List": {
            "Methods": {},
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "GephiGraphStreamer",
        "Description": "Class that produces JSON event objects that stream an igraph graph to Gephi using the Gephi Graph Streaming API.\nThe Gephi graph streaming format is a simple JSON-based format that can be used to post mutations to a graph (i.e. node and edge additions, removals and updates) to a remote component. For instance, one can open up Gephi (http://www.gephi.org), install the Gephi graph streaming plugin and then send a graph from igraph straight into the Gephi window by using GephiGraphStreamer with the appropriate URL where Gephi is listening.\n",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "Constructs a Gephi graph streamer that will post graphs to agiven file-like object or a Gephi connection.\nencoder must either be None or an instance of json.JSONEncoderand it must contain the JSON encoder to be used when posting JSON objects.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "iterjsonobj": {
                    "Description": "Iterates over the JSON objects that build up the graph using theGephi graph streaming API. The objects returned from this function arePython objects; they must be formatted with json.dumps beforesending them to the destination.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "post": {
                    "Description": "Posts the given graph to the destination of the streamer using thegiven JSON encoder. When encoder is None, it falls back to thedefault JSON encoder of the streamer in the encoder property.\ndestination must be a file-like object or an instance ofGephiConnection.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "send_event": {
                    "Description": "Sends a single JSON event to the given destination using the givenJSON encoder.  When encoder is None, it falls back to thedefault JSON encoder of the streamer in the encoder property.\ndestination must be a file-like object or an instance ofGephiConnection.\nThe method flushes the destination after sending the event. If you wantto avoid this (e.g., because you are sending many events), setflush to False.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": [
                "Example:\n>>> from cStringIO import StringIO\n>>> from igraph import Graph\n>>> buf = StringIO()\n>>> streamer = GephiGraphStreamer()\n>>> graph = Graph.Formula(\"A --> B, B --> C\")\n>>> streamer.post(graph, buf)\n>>> print(buf.getvalue())        # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE\n{\"an\": {\"igraph:...:v:0\": {\"name\": \"A\"}}}\n{\"an\": {\"igraph:...:v:1\": {\"name\": \"B\"}}}\n{\"an\": {\"igraph:...:v:2\": {\"name\": \"C\"}}}\n{\"ae\": {\"igraph:...:e:0:1\": {...}}}\n{\"ae\": {\"igraph:...:e:1:2\": {...}}}\n<BLANKLINE>\n"
            ]
        }
    },
    {
        "Section_id": "find_matplotlib",
        "Description": "Tries to import the matplotlib Python module if it is installed.Returns a fake module if everything fails.",
        "Paramters": {},
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "VertexCollection",
        "Description": "Collection of vertex patches for plotting.\nThis class takes additional keyword arguments compared to PatchCollection:Parametersvertex_builderA list of vertex builders to construct the visual vertices. This is updated if the size of the vertices is changed.size_callbackA function to be triggered after vertex sizes are changed. Typically this redraws the edges.",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_size": {
                    "Description": "Get vertex sizes.\nIf width and height are unequal, get the largest of the two.",
                    "Paramters": {},
                    "Return": [
                        "An array of vertex sizes."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_sizes": {
                    "Description": "Same as get_size.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "set_size": {
                    "Description": "Set vertex sizes.\nThis rescales the current vertex symbol/path linearly, using this value as the largest of width and height.",
                    "Paramters": {
                        "sizes": "A sequence of vertex  or a single size."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "set_sizes": {
                    "Description": "Same as set_size.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "stale": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {
                "stale": "Undocumented\n"
            }
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "TaperedEdgeDrawer",
        "Description": "Edge drawer implementation that draws undirected edges as straight lines and directed edges as tapered lines that are wider at the source and narrow at the destination.",
        "Field List": {
            "Methods": {
                "draw_directed_edge": {
                    "Description": "overrides igraph.drawing.baseclasses.AbstractEdgeDrawer.draw_directed_edge\nDraws a directed edge.",
                    "Paramters": {
                        "edge": "the  to be drawn. Visual properties of the  are defined by the attributes of this object.",
                        "src_vertex": "the source vertex. Visual properties are defined by the attributes of this object.",
                        "dest_vertex": "the source vertex. Visual properties are defined by the attributes of this object."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__init__": {
                    "Description": "Inherited from AbstractCairoEdgeDrawer:Constructs the edge drawer."
                },
                "draw_loop_edge": {
                    "Description": "Inherited from AbstractCairoEdgeDrawer:Draws a loop edge."
                },
                "draw_undirected_edge": {
                    "Description": "Inherited from AbstractCairoEdgeDrawer:Draws an undirected edge."
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "Rectangle",
        "Description": "Class representing a rectangle.",
        "Field List": {
            "Methods": {
                "__bool__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__eq__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__hash__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__init__": {
                    "Description": "Creates a rectangle.\nThe corners of the rectangle can be specified by either a tuple (four items, two for each corner, respectively), four separate numbers (X and Y coordinates for each corner) or two separate numbers (width and height, the upper left corner is assumed to be at (0,0))",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__ior__": {
                    "Description": "overridden in igraph.drawing.utils.BoundingBox\nExpands this rectangle to include itself and another completely while still being as small as possible.\nExample:",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": [
                        "Example:\n    >>> r1 = Rectangle(10, 10, 30, 30)\n    >>> r2 = Rectangle(20, 20, 50, 50)\n    >>> r3 = Rectangle(70, 70, 90, 90)\n    >>> r1 |= r2\n    >>> r1\n    Rectangle(10.0, 10.0, 50.0, 50.0)\n    >>> r1 |= r3\n    >>> r1\n    Rectangle(10.0, 10.0, 90.0, 90.0)\n"
                    ]
                },
                "__ne__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__repr__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "bottom": {
                    "Description": "Sets the Y coordinate of the bottom edge of the box",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "contract": {
                    "Description": "Contracts the rectangle by the given margins.",
                    "Paramters": {},
                    "Return": [
                        "a new Rectangle object."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "coords": {
                    "Description": "Sets the coordinates of the corners.",
                    "Paramters": {
                        "coords": "a 4-tuple with the coordinates of the corners"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "expand": {
                    "Description": "Expands the rectangle by the given margins.",
                    "Paramters": {},
                    "Return": [
                        "a new Rectangle object."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "height": {
                    "Description": "Sets the height of the rectangle by adjusting the bottom edge.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "intersection": {
                    "Description": "Returns the intersection of this rectangle with another.\nExample:",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": [
                        "Example:\n    >>> r1 = Rectangle(10, 10, 30, 30)\n    >>> r2 = Rectangle(20, 20, 50, 50)\n    >>> r3 = Rectangle(70, 70, 90, 90)\n    >>> r1.intersection(r2)\n    Rectangle(20.0, 20.0, 30.0, 30.0)\n    >>> r2 & r1\n    Rectangle(20.0, 20.0, 30.0, 30.0)\n    >>> r2.intersection(r1) == r1.intersection(r2)\n    True\n    >>> r1.intersection(r3)\n    Rectangle(0.0, 0.0, 0.0, 0.0)\n"
                    ]
                },
                "isdisjoint": {
                    "Description": "Returns True if the two rectangles have no intersection.\nExample:",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": [
                        "Example:\n    >>> r1 = Rectangle(10, 10, 30, 30)\n    >>> r2 = Rectangle(20, 20, 50, 50)\n    >>> r3 = Rectangle(70, 70, 90, 90)\n    >>> r1.isdisjoint(r2)\n    False\n    >>> r2.isdisjoint(r1)\n    False\n    >>> r1.isdisjoint(r3)\n    True\n    >>> r3.isdisjoint(r1)\n    True\n"
                    ]
                },
                "isempty": {
                    "Description": "Returns True if the rectangle is empty (i.e. it has zero width and height).\nExample:",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": [
                        "Example:\n    >>> r1 = Rectangle(10, 10, 30, 30)\n    >>> r2 = Rectangle(70, 70, 90, 90)\n    >>> r1.isempty()\n    False\n    >>> r2.isempty()\n    False\n    >>> r1.intersection(r2).isempty()\n    True\n"
                    ]
                },
                "left": {
                    "Description": "Sets the X coordinate of the left side of the box",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "midx": {
                    "Description": "Moves the center of the box to the given X coordinate",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "midy": {
                    "Description": "Moves the center of the box to the given Y coordinate",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "right": {
                    "Description": "Sets the X coordinate of the right side of the box",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "shape": {
                    "Description": "Sets the shape of the rectangle (width, height).",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "top": {
                    "Description": "Sets the Y coordinate of the top edge of the box",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "translate": {
                    "Description": "Translates the rectangle in-place.\nExample:",
                    "Paramters": {
                        "dx": "the X coordinate of the translation vector",
                        "dy": "the Y coordinate of the translation vector"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": [
                        "Example:\n>>> r = Rectangle(10, 20, 50, 70)\n>>> r.translate(30, -10)\n>>> r\nRectangle(40.0, 10.0, 80.0, 60.0)\n"
                    ]
                },
                "union": {
                    "Description": "Returns the union of this rectangle with another.\nThe resulting rectangle is the smallest rectangle that contains both rectangles.\nExample:",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": [
                        "Example:\n    >>> r1 = Rectangle(10, 10, 30, 30)\n    >>> r2 = Rectangle(20, 20, 50, 50)\n    >>> r3 = Rectangle(70, 70, 90, 90)\n    >>> r1.union(r2)\n    Rectangle(10.0, 10.0, 50.0, 50.0)\n    >>> r2 | r1\n    Rectangle(10.0, 10.0, 50.0, 50.0)\n    >>> r2.union(r1) == r1.union(r2)\n    True\n    >>> r1.union(r3)\n    Rectangle(10.0, 10.0, 90.0, 90.0)\n"
                    ]
                },
                "width": {
                    "Description": "Sets the width of the rectangle by adjusting the right edge.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {
                "bottom": "The Y coordinate of the bottom edge of the box\n",
                "coords": "The coordinates of the corners.\nThe coordinates are returned as a 4-tuple in the following order: left edge, top edge, right edge, bottom edge.\n\n",
                "left": "The X coordinate of the left side of the box\n",
                "midx": "The X coordinate of the center of the box\n",
                "midy": "The Y coordinate of the center of the box\n",
                "right": "The X coordinate of the right side of the box\n",
                "shape": "The shape of the rectangle (width, height)\n",
                "top": "The Y coordinate of the top edge of the box\n"
            }
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "cairo",
        "Description": "Undocumented"
    },
    {
        "Section_id": "AbstractEdgeDrawer",
        "Description": "Abstract edge drawer object from which all concrete edge drawer implementations are derived.",
        "Field List": {
            "Methods": {
                "draw_directed_edge": {
                    "Description": "overridden in igraph.drawing.cairo.edge.AlphaVaryingEdgeDrawer, igraph.drawing.cairo.edge.CairoArrowEdgeDrawer, igraph.drawing.cairo.edge.TaperedEdgeDrawer, igraph.drawing.matplotlib.edge.MatplotlibEdgeDrawer, igraph.drawing.plotly.edge.PlotlyEdgeDrawer\nDraws a directed edge.",
                    "Paramters": {
                        "edge": "the  to be drawn. Visual properties of the  are defined by the attributes of this object.",
                        "src_vertex": "the source vertex. Visual properties are defined by the attributes of this object.",
                        "dest_vertex": "the source vertex. Visual properties are defined by the attributes of this object."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw_undirected_edge": {
                    "Description": "overridden in igraph.drawing.cairo.edge.AbstractCairoEdgeDrawer, igraph.drawing.matplotlib.edge.MatplotlibEdgeDrawer, igraph.drawing.plotly.edge.PlotlyEdgeDrawer\nDraws an undirected edge.",
                    "Paramters": {
                        "edge": "the  to be drawn. Visual properties of the  are defined by the attributes of this object.",
                        "src_vertex": "the source vertex. Visual properties are defined by the attributes of this object.",
                        "dest_vertex": "the source vertex. Visual properties are defined by the attributes of this object."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_label_position": {
                    "Description": "Returns the position where the label of an edge should be drawn. the default implementation returns the midpoint of the edge and an alignment that tries to avoid overlapping the label with the edge.",
                    "Paramters": {
                        "edge": "the  to be drawn. visual properties of the  are defined by the attributes of this object.",
                        "src_vertex": "the source vertex. visual properties are given again as attributes.",
                        "dest_vertex": "the target vertex. visual properties are given again as attributes."
                    },
                    "Return": [
                        "a tuple containing two more tuples: the desired position of the label and the desired alignment of the label, where the position is given as c{(x, y)} and the alignment is given as c{(horizontal, vertical)}. members of the alignment tuple are taken from constants in the l{textalignment} class."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_label_rotation": {
                    "Description": "Get the rotation angle of the label to align with the edge.",
                    "Paramters": {
                        "edge": "the  to be drawn. visual properties of the  are defined by the attributes of this object.",
                        "src_vertex": "the source vertex. visual properties are given again as attributes.",
                        "dest_vertex": "the target vertex. visual properties are given again as attributes."
                    },
                    "Return": [
                        "a float with the desired angle, in degrees (out of 360)."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "find_plotly",
        "Description": "Tries to import the plotly Python module if it is installed.Returns a fake module if everything fails.",
        "Paramters": {},
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "format_arc",
        "Description": "Approximation of an SVG-style arc\nNOTE: plotly does not currently support the native SVG \"A/a\" commands",
        "Paramters": {},
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "format_path_step",
        "Description": "Format step in SVG path for plotly",
        "Paramters": {},
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "format_rgba",
        "Description": "Format colors in a way understood by plotly",
        "Paramters": {},
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "DFSIter",
        "Description": "igraph DFS iterator object",
        "Field List": {
            "Methods": {},
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "cairo",
        "Description": "Undocumented"
    },
    {
        "Section_id": "CairoMatrixDrawer",
        "Description": "Default Cairo drawer object for matrices.",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "overrides igraph.drawing.cairo.base.AbstractCairoDrawer.__init__\nConstructs the vertex drawer and associates it to the given palette.",
                    "Paramters": {
                        "context": "the  on which we will draw"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw": {
                    "Description": "overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nDraws the given Matrix in a Cairo context.",
                    "Paramters": {
                        "matrix": "the igraph.Matrix to plot.It accepts the following keyword arguments:bbox:    the bounding box within which we will draw. Can be anything accepted by the constructor of BoundingBox (i.e., a 2-tuple, a 4-tuple or a BoundingBox object).palette: the palette that can be used to map integer color indices to colors when drawing verticesstyle: the style of the plot. boolean is useful for plotting matrices with boolean (True/False or 0/1) values: False will be shown with a white box and True with a black box. palette uses the given palette to represent numbers by colors, the minimum will be assigned to palette color index 0 and the maximum will be assigned to the length of the palette. None draws transparent cell backgrounds only. The default style is boolean (but it may change in the future). None values in the  are treated specially in both cases: nothing is drawn in the cell corresponding to None.square: whether the cells of the  should be square or not. Default is True.grid_width: line width of the grid shown on the . If zero or negative, the grid is turned off. The grid is also turned off if the size of a cell is less than three times the given line width. Default is 1. Fractional widths are also allowed.border_width: line width of the border drawn around the . If zero or negative, the border is turned off. Default is 1.row_names: the names of the rowscol_names: the names of the columns.values: values to be displayed in the cells. If None or False, no values are displayed. If True, the values come from the  being plotted. If it is another , the values of that  are shown in the cells. In this case, the shape of the value  must match the shape of the  being plotted.value_format: a format string or a callable that specifies how the values should be plotted. If it is a callable, it must be a function that expects a single value and returns a string. Example: \"%#.2f\" for floating-point numbers with always exactly two digits after the decimal point. See the Python documentation of the % operator for details on the format string. If the format string is not given, it defaults to the str function.If only the row names or the column names are given and the  is square-shaped, the same names are used for both column and row names.",
                        "**kwds": "Undocumented"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "bbox.setter": {
                    "Description": "Inherited from AbstractCairoDrawer:Sets the bounding box of the drawing area where this drawer will draw."
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "Matrix",
        "Description": "Simple matrix data type.\nOf course there are much more advanced matrix data types for Python (for instance, the ndarray data type of Numeric Python) and this implementation does not want to compete with them. The only role of this data type is to provide a convenient interface for the matrices returned by the Graph object (for instance, allow indexing with tuples in the case of adjacency matrices and so on).",
        "Field List": {
            "Methods": {
                "Fill": {
                    "Description": "Creates a matrix filled with the given value",
                    "Paramters": {
                        "value": "the  to be used",
                        "*args": "Undocumented",
                        "shape": "the  of the matrix. Can be a single integer, two integers or a tuple. If a single integer is given here, the matrix is assumed to be square-d."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Identity": {
                    "Description": "Creates an identity matrix.",
                    "Paramters": {
                        "*args": "Undocumented",
                        "shape": "the  of the matrix. Can be a single integer, two integers or a tuple. If a single integer is given here, the matrix is assumed to be square-d."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Zero": {
                    "Description": "Creates a matrix filled with zeros.",
                    "Paramters": {
                        "*args": "Undocumented",
                        "shape": "the  of the matrix. Can be a single integer, two integers or a tuple. If a single integer is given here, the matrix is assumed to be square-d."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__add__": {
                    "Description": "Adds the given value to the matrix.",
                    "Paramters": {
                        "other": "either a scalar or a matrix. Scalars will be added to each element of the matrix. Matrices will be added together elementwise."
                    },
                    "Return": [
                        "the result matrix"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__eq__": {
                    "Description": "Checks whether a given matrix is equal to another one",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__getitem__": {
                    "Description": "Returns a single item, a row or a column of the matrix",
                    "Paramters": {
                        "i": "f a sngle nteger, returns the th row as a lst. If a slce, returns the correspondng rows as another Matrx object. If a 2-tuple, the frst element of the tuple s used to select a row and the second s used to select a column."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__hash__": {
                    "Description": "Returns a hash value for a matrix.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__iadd__": {
                    "Description": "In-place addition of a matrix or scalar.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__init__": {
                    "Description": "Initializes a matrix.",
                    "Paramters": {
                        "data": "the elements of the matrix as a list of lists, or None to create a 0x0 matrix."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__isub__": {
                    "Description": "In-place subtraction of a matrix or scalar.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__iter__": {
                    "Description": "Support for iteration.\nThis is actually implemented as a generator, so there is no need for a separate iterator class. The generator returns copies of the rows in the matrix as lists to avoid messing around with the internals. Feel free to do anything with the copies, the changes won't be reflected in the original matrix.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__len__": {
                    "Description": "Returns the number of rows in the matrix.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__ne__": {
                    "Description": "Checks whether a given matrix is not equal to another one",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__plot__": {
                    "Description": "Plots the matrix to the given Cairo context or matplotlib Axes.\nBesides the usual self-explanatory plotting parameters (context, bbox, palette), it accepts the following keyword arguments:style: the style of the plot. boolean is useful for plotting matrices with boolean (True/False or 0/1) values: False will be shown with a white box and True with a black box. palette uses the given palette to represent numbers by colors, the minimum will be assigned to palette color index 0 and the maximum will be assigned to the length of the palette. None draws transparent cell backgrounds only. The default style is boolean (but it may change in the future). None values in the matrix are treated specially in both cases: nothing is drawn in the cell corresponding to None.square: whether the cells of the matrix should be square or not. Default is True.grid_width: line width of the grid shown on the matrix. If zero or negative, the grid is turned off. The grid is also turned off if the size of a cell is less than three times the given line width. Default is 1. Fractional widths are also allowed.border_width: line width of the border drawn around the matrix. If zero or negative, the border is turned off. Default is 1.row_names: the names of the rowscol_names: the names of the columns.values: values to be displayed in the cells. If None or False, no values are displayed. If True, the values come from the matrix being plotted. If it is another matrix, the values of that matrix are shown in the cells. In this case, the shape of the value matrix must match the shape of the matrix being plotted.value_format: a format string or a callable that specifies how the values should be plotted. If it is a callable, it must be a function that expects a single value and returns a string. Example: \"%#.2f\" for floating-point numbers with always exactly two digits after the decimal point. See the Python documentation of the % operator for details on the format string. If the format string is not given, it defaults to the str function.\nIf only the row names or the column names are given and the matrix is square-shaped, the same names are used for both column and row names.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__repr__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__setitem__": {
                    "Description": "Sets a single item, a row or a column of the matrix",
                    "Paramters": {
                        "i": "f a sngle nteger, sets the th row as a lst. If a slce, sets the correspondng rows from another Matrx object. If a 2-tuple, the frst element of the tuple s used to select a row and the second s used to select a column.",
                        "value": "the new "
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__str__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__sub__": {
                    "Description": "Subtracts the given value from the matrix.",
                    "Paramters": {
                        "other": "either a scalar or a matrix. Scalars will be subtracted from each element of the matrix. Matrices will be subtracted together elementwise."
                    },
                    "Return": [
                        "the result matrix"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "max": {
                    "Description": "Returns the maximum of the matrix along the given dimension",
                    "Paramters": {
                        "dim": "the ension. 0 means determining the column maximums, 1 means determining the row maximums. If None, the global maximum is returned."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "min": {
                    "Description": "Returns the minimum of the matrix along the given dimension",
                    "Paramters": {
                        "dim": "the ension. 0 means determining the column minimums, 1 means determining the row minimums. If None, the global minimum is returned."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {
                "shape": "Returns the shape of the matrix as a tuple\n"
            }
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "EdgeCollection",
        "Description": "Undocumented",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_arrow_size": {
                    "Description": "Get arrow sizes for the edges (directed only).",
                    "Paramters": {},
                    "Return": [
                        "An array of arrow sizes."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_arrow_sizes": {
                    "Description": "Same as get_arrow_size.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_arrow_width": {
                    "Description": "Get arrow widths for the edges (directed only).",
                    "Paramters": {},
                    "Return": [
                        "An array of arrow widths."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_arrow_widths": {
                    "Description": "Same as get_arrow_width.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "set_arrow_size": {
                    "Description": "Set arrow sizes.",
                    "Paramters": {
                        "sizes": "A sequence of arrow  or a single size."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "set_arrow_sizes": {
                    "Description": "Same as set_arrow_size",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "set_arrow_width": {
                    "Description": "Set arrow widths.",
                    "Paramters": {
                        "widths": "A sequence of arrow  or a single width."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "set_arrow_widths": {
                    "Description": "Same as set_arrow_width",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "stale": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {
                "stale": "Undocumented\n"
            }
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "Layout",
        "Description": "Represents the layout of a graph.\nA layout is practically a list of coordinates in an n-dimensional space. This class is generic in the sense that it can store coordinates in any n-dimensional space.\nLayout objects are not associated directly with a graph. This is deliberate: there were times when I worked with almost identical copies of the same graph, the only difference was that they had different colors assigned to the vertices. It was particularly convenient for me to use the same layout for all of them, especially when I made figures for a paper. However, igraph will of course refuse to draw a graph with a layout that has fewer coordinates than the node count of the graph.\n",
        "Field List": {
            "Methods": {
                "__copy__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__delitem__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__getitem__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__init__": {
                    "Description": "Constructor.",
                    "Paramters": {
                        "coords": "the coordinates to be stored in the layout.",
                        "dim": "the number of ensions. If None, the number of ensions is determined automatically from the length of the first item of the coordinate list. If there are no entries in the coordinate list, the default will be 2.  Generally, this should be given if the length of the coordinate list is zero, otherwise it should be left as is."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__len__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__repr__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__setitem__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "append": {
                    "Description": "Appends a new point to the layout",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "boundaries": {
                    "Description": "Returns the boundaries of the layout.\nThe boundaries are the minimum and maximum coordinates along all dimensions.",
                    "Paramters": {
                        "border": "this value gets subtracted from the minimum bounds and gets added to the maximum bounds before returning the coordinates of the box. Defaults to zero."
                    },
                    "Return": [
                        "the minimum and maximum coordinates along all dimensions, in a tuple containing two lists, one for the minimum coordinates, the other one for the maximum."
                    ],
                    "References": [],
                    "Rasises": {
                        "ValueError": "if the layout contains no layout items"
                    },
                    "See Also": "",
                    "example": []
                },
                "bounding_box": {
                    "Description": "Returns the bounding box of the layout.\nThe bounding box of the layout is the smallest box enclosing all the points in the layout.",
                    "Paramters": {
                        "border": "this value gets subtracted from the minimum bounds and gets added to the maximum bounds before returning the coordinates of the box. Defaults to zero."
                    },
                    "Return": [
                        "the coordinates of the lower left and the upper right corner of the box. \"Lower left\" means the minimum coordinates and \"upper right\" means the maximum. These are encapsulated in a BoundingBox object."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "center": {
                    "Description": "Centers the layout around the given point.\nThe point itself can be supplied as multiple unnamed arguments, as a simple unnamed list or as a keyword argument. This operation moves the centroid of the layout to the given point. If no point is supplied, defaults to the origin of the coordinate system.",
                    "Paramters": {
                        "*args": "Undocumented",
                        "p": "the oint where the centroid of the layout will be after the oeration."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "centroid": {
                    "Description": "Returns the centroid of the layout.\nThe centroid of the layout is the arithmetic mean of the points in the layout.",
                    "Paramters": {},
                    "Return": [
                        "the centroid as a list of floats"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "copy": {
                    "Description": "Creates an exact copy of the layout.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "fit_into": {
                    "Description": "Fits the layout into the given bounding box.\nThe layout will be modified in-place.",
                    "Paramters": {
                        "bbox": "the bounding box in which to fit the layout. If the dimension of the layout is d, it can either be a d-tuple (defining the sizes of the box), a 2d-tuple (defining the coordinates of the top left and the bottom right point of the box), or a BoundingBox object (for 2D layouts only).",
                        "keep_aspect_ratio": "whether to keep the aspect ratio of the current layout. If False, the layout will be rescaled to fit exactly into the bounding box. If True, the original aspect ratio of the layout will be kept and it will be centered within the bounding box."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "mirror": {
                    "Description": "Mirrors the layout along the given dimension(s)",
                    "Paramters": {
                        "dim": "the list of ensions or a single ension"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "rotate": {
                    "Description": "Rotates the layout by the given degrees on the plane defined by the given two dimensions.",
                    "Paramters": {
                        "angle": "the  of the rotation, specified in degrees.",
                        "dim1": "the first axis of the plane of the rotation.",
                        "dim2": "the second axis of the plane of the rotation.",
                        "origin": "the  of the rotation. If not specified, the  will be the  of the coordinate system."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "scale": {
                    "Description": "Scales the layout.\nScaling parameters can be provided either through the scale keyword argument or through plain unnamed arguments. If a single integer or float is given, it is interpreted as a uniform multiplier to be applied on all dimensions. If it is a list or tuple, its length must be equal to the number of dimensions in the layout, and each element must be an integer or float describing the scaling coefficient in one of the dimensions.",
                    "Paramters": {
                        "*args": "Undocumented",
                        "scale": "scaling coefficients (integer, float, list or tuple)",
                        "origin": "the  of scaling (this point will stay in place). Optional, defaults to the  of the coordinate system being used."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "to_radial": {
                    "Description": "Converts a planar layout to a radial one\nThis method applies only to 2D layouts. The X coordinate of the layout is transformed to an angle, with min(x) corresponding to the parameter called min_angle and max(y) corresponding to max_angle. Angles are given in degrees, zero degree corresponds to the direction pointing upwards. The Y coordinate is interpreted as a radius, with min(y) belonging to the minimum and max(y) to the maximum radius given in the arguments.\nThis is not a fully generic polar coordinate transformation, but it is fairly useful in creating radial tree layouts from ordinary top-down ones (that's why the Y coordinate belongs to the radius). It can also be used in conjunction with the Fruchterman-Reingold layout algorithm via its miny and maxy parameters (see Graph.layout_fruchterman_reingold()) to produce radial layouts where the radius belongs to some property of the vertices.",
                    "Paramters": {
                        "min_angle": "the angle corresponding to the minimum X value",
                        "max_angle": "the angle corresponding to the maximum X value",
                        "min_radius": "the radius corresponding to the minimum Y value",
                        "max_radius": "the radius corresponding to the maximum Y value"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "transform": {
                    "Description": "Performs an arbitrary transformation on the layout\nAdditional positional and keyword arguments are passed intact to the given function.",
                    "Paramters": {
                        "function": "a  which receives the coordinates as a tuple and returns the transformed tuple.",
                        "*args": "Undocumented",
                        "**kwds": "Undocumented"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "translate": {
                    "Description": "Translates the layout.\nThe translation vector can be provided either through the v keyword argument or through plain unnamed arguments. If unnamed arguments are used, the vector can be supplied as a single list (or tuple) or just as a series of arguments. In all cases, the translation vector must have the same number of dimensions as the layout.",
                    "Paramters": {
                        "*args": "Undocumented",
                        "v": "the translation ector"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {
                "coords": "The coordinates as a list of lists\n",
                "dim": "Returns the number of dimensions\n"
            }
        },
        "Rubric": {
            "Example": [
                "Layouts behave exactly like lists when they are accessed using the item index operator ([...]). They can even be iterated through. Items returned by the index operator are only copies of the coordinates, but the stored coordinates can be modified by directly assigning to an index.\n>>> layout = Layout([(0, 1), (0, 2)])\n>>> coords = layout[1]\n>>> print(coords)\n[0, 2]\n>>> coords = (0, 3)\n>>> print(layout[1])\n[0, 2]\n>>> layout[1] = coords\n>>> print(layout[1])\n[0, 3]\n"
            ]
        }
    },
    {
        "Section_id": "plotly",
        "Description": "Undocumented"
    },
    {
        "Section_id": "ProgressBar",
        "Description": "A 2-line progress bar.\n",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "clear": {
                    "Description": "Clears the progress bar (i.e. removes it from the screen)",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "update": {
                    "Description": "Updates the progress bar.",
                    "Paramters": {
                        "percent": "the age to be shown. If None, the previous value will be used.",
                        "message": "the  to be shown above the progress bar. If None, the previous  will be used."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "update_message": {
                    "Description": "Updates the message of the progress bar.",
                    "Paramters": {
                        "message": "the  to be shown above the progress bar"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": [
                "The progress bar looks roughly like this in the console:\n                            Header\n    20% [===========----------------------------------]\n"
            ]
        }
    },
    {
        "Section_id": "BoundingBox",
        "Description": "Class representing a bounding box (a rectangular area) that encloses some objects.",
        "Field List": {
            "Methods": {
                "__ior__": {
                    "Description": "overrides igraph.drawing.utils.Rectangle.__ior__\nReplaces this bounding box with the union of itself and another.\nExample:",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": [
                        "Example:\n    >>> box1 = BoundingBox(10, 20, 50, 60)\n    >>> box2 = BoundingBox(70, 40, 100, 90)\n    >>> box1 |= box2\n    >>> print(box1)\n    BoundingBox(10.0, 20.0, 100.0, 90.0)\n"
                    ]
                },
                "__or__": {
                    "Description": "Takes the union of this bounding box with another.\nThe result is a bounding box which encloses both bounding boxes.\nExample:",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": [
                        "Example:\n    >>> box1 = BoundingBox(10, 20, 50, 60)\n    >>> box2 = BoundingBox(70, 40, 100, 90)\n    >>> box1 | box2\n    BoundingBox(10.0, 20.0, 100.0, 90.0)\n"
                    ]
                },
                "__bool__": {
                    "Description": "Inherited from Rectangle:Undocumented"
                },
                "__eq__": {
                    "Description": "Inherited from Rectangle:Undocumented"
                },
                "__hash__": {
                    "Description": "Inherited from Rectangle:Undocumented"
                },
                "__init__": {
                    "Description": "Inherited from Rectangle:Creates a rectangle."
                },
                "__ne__": {
                    "Description": "Inherited from Rectangle:Undocumented"
                },
                "__repr__": {
                    "Description": "Inherited from Rectangle:Undocumented"
                },
                "bottom.setter": {
                    "Description": "Inherited from Rectangle:Sets the Y coordinate of the bottom edge of the box"
                },
                "contract": {
                    "Description": "Inherited from Rectangle:Contracts the rectangle by the given margins."
                },
                "coords.setter": {
                    "Description": "Inherited from Rectangle:Sets the coordinates of the corners."
                },
                "expand": {
                    "Description": "Inherited from Rectangle:Expands the rectangle by the given margins."
                },
                "height.setter": {
                    "Description": "Inherited from Rectangle:Sets the height of the rectangle by adjusting the bottom edge."
                },
                "intersection": {
                    "Description": "Inherited from Rectangle:Returns the intersection of this rectangle with another."
                },
                "isdisjoint": {
                    "Description": "Inherited from Rectangle:Returns True if the two rectangles have no intersection."
                },
                "isempty": {
                    "Description": "Inherited from Rectangle:Returns True if the rectangle is empty (i.e. it has zero width and height)."
                },
                "left.setter": {
                    "Description": "Inherited from Rectangle:Sets the X coordinate of the left side of the box"
                },
                "midx.setter": {
                    "Description": "Inherited from Rectangle:Moves the center of the box to the given X coordinate"
                },
                "midy.setter": {
                    "Description": "Inherited from Rectangle:Moves the center of the box to the given Y coordinate"
                },
                "right.setter": {
                    "Description": "Inherited from Rectangle:Sets the X coordinate of the right side of the box"
                },
                "shape.setter": {
                    "Description": "Inherited from Rectangle:Sets the shape of the rectangle (width, height)."
                },
                "top.setter": {
                    "Description": "Inherited from Rectangle:Sets the Y coordinate of the top edge of the box"
                },
                "translate": {
                    "Description": "Inherited from Rectangle:Translates the rectangle in-place."
                },
                "union": {
                    "Description": "Inherited from Rectangle:Returns the union of this rectangle with another."
                },
                "width.setter": {
                    "Description": "Inherited from Rectangle:Sets the width of the rectangle by adjusting the right edge."
                }
            },
            "property": {
                "bottom": "Inherited from Rectangle:The Y coordinate of the bottom edge of the box",
                "coords": "Inherited from Rectangle:The coordinates of the corners.",
                "left": "Inherited from Rectangle:The X coordinate of the left side of the box",
                "midx": "Inherited from Rectangle:The X coordinate of the center of the box",
                "midy": "Inherited from Rectangle:The Y coordinate of the center of the box",
                "right": "Inherited from Rectangle:The X coordinate of the right side of the box",
                "shape": "Inherited from Rectangle:The shape of the rectangle (width, height)",
                "top": "Inherited from Rectangle:The Y coordinate of the top edge of the box"
            }
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "GephiGraphStreamingDrawer",
        "Description": "Graph drawer that sends a graph to a file-like object (e.g., socket, URL connection, file) using the Gephi graph streaming format.\nThe Gephi graph streaming format is a simple JSON-based format that can be used to post mutations to a graph (i.e. node and edge additions, removals and updates) to a remote component. For instance, one can open up Gephi (http://www.gephi.org), install the Gephi graph streaming plugin and then send a graph from igraph straight into the Gephi window by using GephiGraphStreamingDrawer with the appropriate URL where Gephi is listening.\nThe connection property exposes the GephiConnection that the drawer uses. The drawer also has a property called streamer which exposes the underlying GephiGraphStreamer that is responsible for generating the JSON objects, encoding them and writing them to a file-like object. If you want to customize the encoding process, this is the object where you can tweak things to your taste.",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "Constructs a Gephi graph streaming drawer that will post graphs to the given Gephi connection. If conn is None, the remaining arguments of the constructor are forwarded intact to the constructor of GephiConnection in order to create a connection. This means that any of the following are valid:GephiGraphStreamingDrawer() will construct a drawer that connects to workspace 0 of the local Gephi instance on port 8080.GephiGraphStreamingDrawer(workspace=2) will connect to workspace 2 of the local Gephi instance on port 8080.GephiGraphStreamingDrawer(port=1234) will connect to workspace 0 of the local Gephi instance on port 1234.GephiGraphStreamingDrawer(host=\"remote\", port=1234, workspace=7) will connect to workspace 7 of the Gephi instance on host remote, port 1234.GephiGraphStreamingDrawer(url=\"http://remote:1234/workspace7) is the same as above, but with an explicit URL.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw": {
                    "Description": "overrides igraph.drawing.baseclasses.AbstractGraphDrawer.draw\nDraws (i.e. sends) the given graph to the destination of the drawer using the Gephi graph streaming API.\nThe following keyword arguments are allowed:encoder lets one specify an instance of json.JSONEncoder that will be used to encode the JSON objects.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "_layout_mapping",
        "Description": "Undocumented"
    },
    {
        "Section_id": "VertexCover",
        "Description": "The cover of the vertex set of a graph.\nThis class extends Cover by linking it to a specific Graph object. It also provides some handy methods like getting the subgraph corresponding to a cluster and such.Notesince this class is linked to a Graph, destroying the graph by the del operator does not free the memory occupied by the graph if there exists a VertexCover that references the Graph.",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "overrides igraph.Cover.__init__\nCreates a cover object for a given graph.",
                    "Paramters": {
                        "graph": "the  that will be associated to the cover",
                        "clusters": "the list of . If None, it is assumed that there is only a single cluster that covers the whole graph."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__plot__": {
                    "Description": "overridden in igraph.CohesiveBlocks\nPlots the cover to the given Cairo context or matplotlib Axes.\nThis is done by calling Graph.__plot__() with the same arguments, but drawing nice colored blobs around the vertex groups.\nThis method understands all the positional and keyword arguments that are understood by Graph.__plot__(), only the differences will be highlighted here:mark_groups: whether to highlight the vertex clusters by colored polygons. Besides the values accepted by Graph.__plot__ (i.e., a dict mapping colors to vertex indices, a list containing lists of vertex indices, or False), the following are also accepted:True: all the clusters will be highlighted, the colors matching the corresponding color indices from the current palette (see the palette keyword argument of Graph.__plot__).A dict mapping cluster indices or tuples of vertex indices to color names.  The given clusters or vertex groups will be highlighted by the given colors.A list of cluster indices. This is equivalent to passing a dict mapping numeric color indices from the current palette to cluster indices; therefore, the cluster referred to by element i of the list will be highlighted by color i from the palette.The value of the plotting.mark_groups configuration key is also taken into account here; if that configuration key is True and mark_groups is not given explicitly, it will automatically be set to True.In place of lists of vertex indices, you may also use VertexSeq instances.In place of color names, you may also use color indices into the current palette. None as a color name will mean that the corresponding group is ignored.palette: the palette used to resolve numeric color indices to RGBA values. By default, this is an instance of ClusterColoringPalette.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "Graph.__plot__() for more supported keyword arguments.",
                    "example": []
                },
                "crossing": {
                    "Description": "Returns a boolean vector where element i is True iff edge i lies between clusters, False otherwise.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "subgraph": {
                    "Description": "Get the subgraph belonging to a given cluster.\nPrecondition: the vertex set of the graph hasn't been modified since the moment the cover was constructed.",
                    "Paramters": {
                        "idx": "the cluster index"
                    },
                    "Return": [
                        "a copy of the subgraph"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "subgraphs": {
                    "Description": "Gets all the subgraphs belonging to each of the clusters.\nPrecondition: the vertex set of the graph hasn't been modified since the moment the cover was constructed.",
                    "Paramters": {},
                    "Return": [
                        "a list containing copies of the subgraphs"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__getitem__": {
                    "Description": "Inherited from Cover:Returns the cluster with the given index."
                },
                "__iter__": {
                    "Description": "Inherited from Cover:Iterates over the clusters in this cover."
                },
                "__len__": {
                    "Description": "Inherited from Cover:Returns the number of clusters in this cover."
                },
                "__str__": {
                    "Description": "Inherited from Cover:Returns a string representation of the cover."
                },
                "size": {
                    "Description": "Inherited from Cover:Returns the size of a given cluster."
                },
                "size_histogram": {
                    "Description": "Inherited from Cover:Returns the histogram of cluster sizes."
                },
                "sizes": {
                    "Description": "Inherited from Cover:Returns the size of given clusters."
                },
                "summary": {
                    "Description": "Inherited from Cover:Returns the summary of the cover."
                }
            },
            "property": {
                "graph": "Returns the graph belonging to this object\n",
                "membership": "Inherited from Cover:Returns the membership vector of this cover.",
                "n": "Inherited from Cover:Returns the number of elements in the set covered by this cover."
            }
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "Point",
        "Description": "Class representing a point on the 2D plane.",
        "Field List": {
            "Methods": {
                "FromPolar": {
                    "Description": "Constructs a point from polar coordinates.\nradius is the distance of the point from the origin; angle is the angle between the X axis and the vector pointing to the point from the origin.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__add__": {
                    "Description": "Adds the coordinates of a point to another one",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__div__": {
                    "Description": "Divides the coordinates by a scalar",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__mul__": {
                    "Description": "Multiplies the coordinates by a scalar",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__sub__": {
                    "Description": "Subtracts the coordinates of a point to another one",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "as_polar": {
                    "Description": "Returns the polar coordinate representation of the point.",
                    "Paramters": {},
                    "Return": [
                        "the radius and the angle in a tuple."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "distance": {
                    "Description": "Returns the distance of the point from another one.\nExample:",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": [
                        "Example:\n>>> p1 = Point(5, 7)\n>>> p2 = Point(8, 3)\n>>> p1.distance(p2)\n5.0\n"
                    ]
                },
                "interpolate": {
                    "Description": "Linearly interpolates between the coordinates of this point and another one.",
                    "Paramters": {
                        "other": "the  point",
                        "ratio": "the interpolation  between 0 and 1. Zero will return this point, 1 will return the other point."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "length": {
                    "Description": "Returns the length of the vector pointing from the origin to this point.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "normalized": {
                    "Description": "Normalizes the coordinates of the point s.t. its length will be 1 after normalization. Returns the normalized point.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "sq_length": {
                    "Description": "Returns the squared length of the vector pointing from the origin to this point.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "towards": {
                    "Description": "Returns the point that is at a given distance from this point towards another one.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "AlphaVaryingEdgeDrawer",
        "Description": "Edge drawer implementation that draws undirected edges as straight lines and directed edges by varying the alpha value of the specified edge color between the source and the destination.",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "overrides igraph.drawing.cairo.edge.AbstractCairoEdgeDrawer.__init__\nConstructs the edge drawer.",
                    "Paramters": {
                        "context": "a Cairo  on which the edges will be drawn.",
                        "palette": "the  that can be used to map integer color indices to colors when drawing edges",
                        "alpha_at_src": "Undocumented",
                        "alpha_at_dest": "Undocumented"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw_directed_edge": {
                    "Description": "overrides igraph.drawing.baseclasses.AbstractEdgeDrawer.draw_directed_edge\nDraws a directed edge.",
                    "Paramters": {
                        "edge": "the  to be drawn. Visual properties of the  are defined by the attributes of this object.",
                        "src_vertex": "the source vertex. Visual properties are defined by the attributes of this object.",
                        "dest_vertex": "the source vertex. Visual properties are defined by the attributes of this object."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw_loop_edge": {
                    "Description": "Inherited from AbstractCairoEdgeDrawer:Draws a loop edge."
                },
                "draw_undirected_edge": {
                    "Description": "Inherited from AbstractCairoEdgeDrawer:Draws an undirected edge."
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "CairoPaletteDrawer",
        "Description": "Default Cairo drawer object for palettes",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "overrides igraph.drawing.cairo.base.AbstractCairoDrawer.__init__\nConstructs the vertex drawer and associates it to the given palette.",
                    "Paramters": {
                        "context": "the  on which we will draw"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw": {
                    "Description": "overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nTODO",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "bbox.setter": {
                    "Description": "Inherited from AbstractCairoDrawer:Sets the bounding box of the drawing area where this drawer will draw."
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "CairoHistogramDrawer",
        "Description": "Default Cairo drawer object for histograms",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "overrides igraph.drawing.cairo.base.AbstractCairoDrawer.__init__\nConstructs the vertex drawer and associates it to the given palette.",
                    "Paramters": {
                        "context": "the  on which we will draw"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw": {
                    "Description": "overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nTODO",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "bbox.setter": {
                    "Description": "Inherited from AbstractCairoDrawer:Sets the bounding box of the drawing area where this drawer will draw."
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "safe_locale",
        "Description": "Helper function that establishes a context that temporarily switches the current locale to use decimal dots when printing numbers.\nThis can be used to establish an execution context within which it is safe to call functions that read or write graphs from/to the disk and ensure that they use decimal dots for interoperability with systems that are running with another locale.",
        "Paramters": {},
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "find_cairo",
        "Description": "Tries to import the cairo Python module if it is installed,also trying cairocffi (a drop-in replacement of cairo).Returns a fake module if everything fails.",
        "Paramters": {},
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "IDLEShell",
        "Description": "IDLE embedded shell interface.\nThis class allows igraph to be embedded in IDLE (the Tk Python IDE).",
        "Field List": {
            "Methods": {
                "__call__": {
                    "Description": "overrides igraph.app.shell.Shell.__call__\nStarts the shell",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__init__": {
                    "Description": "Constructor.\nImports IDLE's embedded shell. The implementation of this method is ripped from idlelib.PyShell.main() after removing the unnecessary parts.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_progress_handler": {
                    "Description": "Inherited from Shell:Returns the progress handler (if exists) or None (if not)."
                },
                "get_status_handler": {
                    "Description": "Inherited from Shell:Returns the status handler (if exists) or None (if not)."
                },
                "supports_progress_bar": {
                    "Description": "Inherited from Shell:Checks whether the shell supports progress bars."
                },
                "supports_status_messages": {
                    "Description": "Inherited from Shell:Checks whether the shell supports status messages."
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "DescartesCoordinateSystem",
        "Description": "Class implementing a 2D Descartes coordinate system object.",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "overrides igraph.drawing.cairo.base.AbstractCairoDrawer.__init__\nInitializes the coordinate system.",
                    "Paramters": {
                        "context": "the  on which the coordinate system will be drawn.",
                        "bbox": "the bounding box that will contain the coordinate system.",
                        "bounds": "minimum and maximum X and Y values in a 4-tuple."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "bbox": {
                    "Description": "overrides igraph.drawing.cairo.base.AbstractCairoDrawer.bbox.setter\nSets the bounding box of the coordinate system",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "bounds": {
                    "Description": "Sets the lower and upper bounds of the X and Y values",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw": {
                    "Description": "overrides igraph.drawing.cairo.coord.CoordinateSystem.draw\nDraws the coordinate system.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "local_to_context": {
                    "Description": "overrides igraph.drawing.cairo.coord.CoordinateSystem.local_to_context\nConverts local coordinates to the context coordinate system (given by the bounding box).",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {
                "bbox": "overrides igraph.drawing.cairo.base.AbstractCairoDrawer.bbox\nReturns the bounding box of the coordinate system\n",
                "bounds": "Returns the lower and upper bounds of the X and Y values\n"
            }
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "VertexDendrogram",
        "Description": "The dendrogram resulting from the hierarchical clustering of the vertex set of a graph.",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "overrides igraph.Dendrogram.__init__\nCreates a dendrogram object for a given graph.",
                    "Paramters": {
                        "graph": "the  that will be associated to the clustering",
                        "merges": "the  performed given in matrix form.",
                        "optimal_count": "the optimal number of clusters where the dendrogram should be cut. This is a hint usually provided by the clustering algorithm that produces the dendrogram. None means that such a hint is not available; the optimal count will then be selected based on the modularity in such a case.",
                        "modularity_params": "arguments that should be passed to Graph.modularity when the modularity is (re)calculated. If the original graph was weighted, you should pass a dictionary containing a weight key with the appropriate value here."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__plot__": {
                    "Description": "overrides igraph.Dendrogram.__plot__\nDraws the vertex dendrogram on the given Cairo context or matplotlib Axes\nSee Dendrogram.__plot__ for the list of supported keyword arguments.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "as_clustering": {
                    "Description": "Cuts the dendrogram at the given level and returns a corresponding VertexClustering object.",
                    "Paramters": {
                        "n": "the desired umber of clusters. Merges are replayed from the begiig util the membership vector has exactly  distict elemets or util there are o more recorded merges, whichever happes first. If Noe, the optimal cout hit give by the clusterig algorithm will be used If the optimal cout was ot give either, it will be calculated by selectig the level where the modularity is maximal."
                    },
                    "Return": [
                        "a new VertexClustering object."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "optimal_count": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__str__": {
                    "Description": "Inherited from Dendrogram:Undocumented"
                },
                "format": {
                    "Description": "Inherited from Dendrogram:Formats the dendrogram in a foreign format."
                },
                "names.setter": {
                    "Description": "Inherited from Dendrogram:Sets the names of the nodes in the dendrogram"
                },
                "summary": {
                    "Description": "Inherited from Dendrogram:Returns the summary of the dendrogram."
                }
            },
            "property": {
                "optimal_count": "Returns the optimal number of clusters for this dendrogram.\nIf an optimal count hint was given at construction time, this property simply returns the hint. If such a count was not given, this method calculates the optimal number of clusters by maximizing the modularity along all the possible cuts in the dendrogram.\n\n",
                "merges": "Inherited from Dendrogram:Returns the performed merges in matrix format",
                "names": "Inherited from Dendrogram:Returns the names of the nodes in the dendrogram"
            }
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "GephiGraphStreamingAPIFormat",
        "Description": "Object that implements the Gephi graph streaming API format and returns Python objects corresponding to the events defined in the API.",
        "Field List": {
            "Methods": {
                "get_add_edge_event": {
                    "Description": "Generates a Python object corresponding to the event that adds an edgewith the given source, target, directednessr and attributes in the Gephigraph streaming API.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_add_node_event": {
                    "Description": "Generates a Python object corresponding to the event that adds a nodewith the given identifier and attributes in the Gephi graph streaming API.\nExample:",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": [
                        "Example:\n>>> api = GephiGraphStreamingAPIFormat()\n>>> api.get_add_node_event(\"spam\")\n{'an': {'spam': {}}}\n>>> api.get_add_node_event(\"spam\", dict(ham=\"eggs\"))\n{'an': {'spam': {'ham': 'eggs'}}}\n"
                    ]
                },
                "get_change_edge_event": {
                    "Description": "Generates a Python object corresponding to the event that changes theattributes of some edge in the Gephi graph streaming API. The given attributesare merged into the existing ones; use C{None} as the attribute value todelete a given attribute.\nExample:",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": [
                        "Example:\n>>> api = GephiGraphStreamingAPIFormat()\n>>> api.get_change_edge_event(\"spam\", dict(ham=\"eggs\"))\n{'ce': {'spam': {'ham': 'eggs'}}}\n>>> api.get_change_edge_event(\"spam\", dict(ham=None))\n{'ce': {'spam': {'ham': None}}}\n"
                    ]
                },
                "get_change_node_event": {
                    "Description": "Generates a Python object corresponding to the event that changes theattributes of some node in the Gephi graph streaming API. The given attributesare merged into the existing ones; use C{None} as the attribute value todelete a given attribute.\nExample:",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": [
                        "Example:\n>>> api = GephiGraphStreamingAPIFormat()\n>>> api.get_change_node_event(\"spam\", dict(ham=\"eggs\"))\n{'cn': {'spam': {'ham': 'eggs'}}}\n>>> api.get_change_node_event(\"spam\", dict(ham=None))\n{'cn': {'spam': {'ham': None}}}\n"
                    ]
                },
                "get_delete_edge_event": {
                    "Description": "Generates a Python object corresponding to the event that deletes anedge with the given identifier in the Gephi graph streaming API.\nExample:",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": [
                        "Example:\n>>> api = GephiGraphStreamingAPIFormat()\n>>> api.get_delete_edge_event(\"spam:ham\")\n{'de': {'spam:ham': {}}}\n"
                    ]
                },
                "get_delete_node_event": {
                    "Description": "Generates a Python object corresponding to the event that deletes anode with the given identifier in the Gephi graph streaming API.\nExample:",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": [
                        "Example:\n>>> api = GephiGraphStreamingAPIFormat()\n>>> api.get_delete_node_event(\"spam\")\n{'dn': {'spam': {}}}\n"
                    ]
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "AbstractCairoEdgeDrawer",
        "Description": "Cairo-specific abstract edge drawer object.",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "overridden in igraph.drawing.cairo.edge.AlphaVaryingEdgeDrawer\nConstructs the edge drawer.",
                    "Paramters": {
                        "context": "a Cairo  on which the edges will be drawn.",
                        "palette": "the  that can be used to map integer color indices to colors when drawing edges"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw_loop_edge": {
                    "Description": "Draws a loop edge.\nThe default implementation draws a small circle.",
                    "Paramters": {
                        "edge": "the  to be drawn. Visual properties of the  are defined by the attributes of this object.",
                        "vertex": "the  to which the edge is attached. Visual properties are given again as attributes."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw_undirected_edge": {
                    "Description": "overrides igraph.drawing.baseclasses.AbstractEdgeDrawer.draw_undirected_edge\nDraws an undirected edge.\nThe default implementation of this method draws undirected edges as straight lines. Loop edges are drawn as small circles.",
                    "Paramters": {
                        "edge": "the  to be drawn. Visual properties of the  are defined by the attributes of this object.",
                        "src_vertex": "the source vertex. Visual properties are given again as attributes.",
                        "dest_vertex": "the target vertex. Visual properties are given again as attributes."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw_directed_edge": {
                    "Description": "Inherited from AbstractEdgeDrawer:Draws a directed edge."
                },
                "get_label_position": {
                    "Description": "Inherited from AbstractEdgeDrawer:Returns the position where the label of an edge should be drawn. the default implementation returns the midpoint of the edge and an alignment that tries to avoid overlapping the label with the edge."
                },
                "get_label_rotation": {
                    "Description": "Inherited from AbstractEdgeDrawer:Get the rotation angle of the label to align with the edge."
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "PrecalculatedPalette",
        "Description": "A palette that returns colors from a pre-calculated list of colors",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "overrides igraph.drawing.colors.Palette.__init__\nCreates the palette backed by the given list. The list must contain RGBA quadruplets or color names, which will be resolved first by color_name_to_rgba(). Anything that is understood by color_name_to_rgba() is OK here.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__len__": {
                    "Description": "Inherited from Palette:Returns the number of colors in this palette"
                },
                "__plot__": {
                    "Description": "Inherited from Palette:Plots the colors of the palette on the given Cairo context/mpl Axes"
                },
                "__repr__": {
                    "Description": "Inherited from Palette:Undocumented"
                },
                "clear_cache": {
                    "Description": "Inherited from Palette:Clears the result cache."
                },
                "get": {
                    "Description": "Inherited from Palette:Returns the given color from the palette."
                },
                "get_many": {
                    "Description": "Inherited from Palette:Returns multiple colors from the palette."
                }
            },
            "property": {
                "length": "Inherited from Palette:Returns the number of colors in this palette"
            }
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "FittedPowerLaw",
        "Description": "Result of fitting a power-law to a vector of samples\n",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__repr__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__str__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "summary": {
                    "Description": "Returns the summary of the power law fit.",
                    "Paramters": {
                        "significance": "the  level of the Kolmogorov-Smirnov test used to decide whether the input data could have come from the fitted distribution"
                    },
                    "Return": [
                        "the summary as a string"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": [
                "Example:\n>>> result = power_law_fit([1, 2, 3, 4, 5, 6])\n>>> result                   # doctest:+ELLIPSIS\nFittedPowerLaw(continuous=False, alpha=2.42..., xmin=3.0, L=-7.54..., D=0.21..., p=0.993...)\n>>> print(result)            # doctest:+ELLIPSIS\nFitted power-law distribution on discrete data\n<BLANKLINE>\nExponent (alpha)  = 2.42...\nCutoff (xmin)     = 3.000000\n<BLANKLINE>\nLog-likelihood    = -7.54...\n<BLANKLINE>\nH0: data was drawn from the fitted distribution\n<BLANKLINE>\nKS test statistic = 0.21...\np-value           = 0.993...\n<BLANKLINE>\nH0 could not be rejected at significance level 0.05\n>>> result.alpha             # doctest:+ELLIPSIS\n2.42...\n>>> result.xmin\n3.0\n>>> result.continuous\nFalse\n"
            ]
        }
    },
    {
        "Section_id": "plotly",
        "Description": "Undocumented"
    },
    {
        "Section_id": "cairo",
        "Description": "Undocumented"
    },
    {
        "Section_id": "DyadCensus",
        "Description": "Dyad census of a graph.\nThis is a pretty simple class - basically it is a tuple, but it allows the user to refer to its individual items by the names mutual (or mut), asymmetric (or asy or asym or asymm) and null.\n",
        "Field List": {
            "Methods": {
                "__getattr__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__getitem__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__repr__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__str__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "as_dict": {
                    "Description": "Converts the dyad census to a dict using the known dyad names.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": [
                "Examples:\n>>> from igraph import Graph\n>>> g=Graph.Erdos_Renyi(100, 0.2, directed=True)\n>>> dc=g.dyad_census()\n>>> print(dc.mutual)            #doctest:+SKIP\n179\n>>> print(dc[\"asym\"])           #doctest:+SKIP\n1609\n>>> print(tuple(dc), list(dc))  #doctest:+SKIP\n(179, 1609, 3162) [179, 1609, 3162]\n>>> print(sorted(dc.as_dict().items()))  #doctest:+ELLIPSIS\n[('asymmetric', ...), ('mutual', ...), ('null', ...)]\n"
            ]
        }
    },
    {
        "Section_id": "MatplotlibGraphDrawer",
        "Description": "Graph drawer that uses a pyplot.Axes as context",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "Constructs the graph drawer and associates it with the mpl Axes",
                    "Paramters": {
                        "ax": "the matplotlib Axes to draw into.",
                        "vertex_drawer_factory": "a factory method that returns an AbstractVertexDrawer instance bound to the given Matplotlib axes. The factory method must take three parameters: the axes and the palette to be used for drawing colored vertices, and the layout of the graph. The default vertex drawer is MatplotlibVertexDrawer.",
                        "edge_drawer_factory": "a factory method that returns an AbstractEdgeDrawer instance bound to a given Matplotlib Axes. The factory method must take two parameters: the Axes and the palette to be used for drawing colored edges. The default edge drawer is MatplotlibEdgeDrawer."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw": {
                    "Description": "overrides igraph.drawing.baseclasses.AbstractGraphDrawer.draw\nAbstract method, must be implemented in derived classes.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "UniqueIdGenerator",
        "Description": "A dictionary-like class that can be used to assign unique IDs to names (say, vertex names).\n",
        "Field List": {
            "Methods": {
                "__contains__": {
                    "Description": "Checks whether item already has an ID or not.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__getitem__": {
                    "Description": "Retrieves the ID corresponding to item. Generates a new ID for item if it is the first time we request an ID for it.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__init__": {
                    "Description": "Creates a new unique ID generator. id_generator specifies how do we assign new IDs to elements that do not have an ID yet. If it is None, elements will be assigned integer identifiers starting from 0. If it is an integer, elements will be assigned identifiers starting from the given integer. If it is an iterator or generator, its next() method will be called every time a new ID is needed.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__len__": {
                    "Description": "Returns the number of items.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__setitem__": {
                    "Description": "Overrides the ID for item.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "reverse_dict": {
                    "Description": "Returns the reverse mapping, i.e., the one that maps from generated IDs to their corresponding objects",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "values": {
                    "Description": "Returns the values stored so far. If the generator generates items according to the standard sorting order, the values returned will be exactly in the order they were added. This holds for integer IDs for instance (but for many other ID generators as well).",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": [
                "Usage:\n>>> gen = UniqueIdGenerator()\n>>> gen[\"A\"]\n0\n>>> gen[\"B\"]\n1\n>>> gen[\"C\"]\n2\n>>> gen[\"A\"]      # Retrieving already existing ID\n0\n>>> gen.add(\"D\")  # Synonym of gen[\"D\"]\n3\n>>> len(gen)      # Number of already used IDs\n4\n>>> \"C\" in gen\nTrue\n>>> \"E\" in gen\nFalse\n"
            ]
        }
    },
    {
        "Section_id": "DiamondDrawer",
        "Description": "Static class which draws diamonds (i.e. rhombuses)",
        "Field List": {
            "Methods": {
                "draw_path": {
                    "Description": "overrides igraph.drawing.shapes.ShapeDrawer.draw_path\nDraws a rhombus on the Cairo context without stroking or filling it.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "ShapeDrawer.draw_path",
                    "example": []
                },
                "intersection_point": {
                    "Description": "overrides igraph.drawing.shapes.ShapeDrawer.intersection_point\nDetermines where the rhombus centered at (center_x, center_y) intersects with a line drawn from (source_x, source_y) to (center_x, center_y).",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "ShapeDrawer.intersection_point",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "ConsoleProgressBarMixin",
        "Description": "Mixin class for console shells that support a progress bar.",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "overridden in igraph.app.shell.ClassicPythonShell, igraph.app.shell.IPythonShell\nUndocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "CircleDrawer",
        "Description": "Static class which draws circular vertices",
        "Field List": {
            "Methods": {
                "draw_path": {
                    "Description": "overrides igraph.drawing.shapes.ShapeDrawer.draw_path\nDraws a circular path on the Cairo context without stroking or filling it.\nHeight is ignored, it is the width that determines the diameter of the circle.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "ShapeDrawer.draw_path",
                    "example": []
                },
                "intersection_point": {
                    "Description": "overrides igraph.drawing.shapes.ShapeDrawer.intersection_point\nDetermines where the circle centered at (center_x, center_y) intersects with a line drawn from (source_x, source_y) to (center_x, center_y).",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "ShapeDrawer.intersection_point",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "plotly",
        "Description": "Undocumented"
    },
    {
        "Section_id": "PlotlyPolygonDrawer",
        "Description": "Class that is used to draw polygons in matplotlib.\nThe corner points of the polygon can be set by the points property of the drawer, or passed at construction time. Most drawing methods in this class also have an extra points argument that can be used to override the set of points in the points property.",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "Constructs a new polygon drawer that draws on the given Matplotlib axes.",
                    "Paramters": {
                        "fig": "the plotly Figure to draw on"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw": {
                    "Description": "Draws a polygon to the associated axes.",
                    "Paramters": {
                        "points": "the coordinates of the corners of the polygon, in clockwise or counter-clockwise order, or None if we are about to use the  property of the class.",
                        "corner_radius": "if zero, an ordinary polygon will be drawn. If positive, the corners of the polygon will be rounded with the given radius.",
                        "**kwds": "Undocumented"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "_format_mapping",
        "Description": "Undocumented"
    },
    {
        "Section_id": "CohesiveBlocks",
        "Description": "The cohesive block structure of a graph.\nInstances of this type are created by Graph.cohesive_blocks(). See the documentation of Graph.cohesive_blocks() for an explanation of what cohesive blocks are.\nThis class provides a few more methods that make handling of cohesive block structures easier.",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "overrides igraph.VertexCover.__init__\nConstructs a new cohesive block structure for the given graph.\nIf any of blocks, cohesion or parent is None, all the arguments will be ignored and Graph.cohesive_blocks() will be called to calculate the cohesive blocks. Otherwise, these three variables should describe the *result* of a cohesive block structure calculation. Chances are that you never have to construct CohesiveBlocks instances directly, just use Graph.cohesive_blocks().",
                    "Paramters": {
                        "graph": "the  itself",
                        "blocks": "a list containing the ; each block is described as a list containing vertex IDs.",
                        "cohesion": "the  of each block. The length of this list must be equal to the length of blocks.",
                        "parent": "the  block of each block. Negative values or None mean that there is no  block for that block. There should be only one  block, which covers the entire graph."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "Graph.cohesive_blocks()",
                    "example": []
                },
                "__plot__": {
                    "Description": "overrides igraph.VertexCover.__plot__\nPlots the cohesive block structure to the given Cairo context or matplotlib Axes.\nSince a CohesiveBlocks instance is also a VertexCover, keyword arguments accepted by VertexCover.__plot__() are also accepted here. The only difference is that the vertices are colored according to their maximal cohesions by default, and groups are marked by colored blobs except the last group which encapsulates the whole graph.\nSee the documentation of VertexCover.__plot__() for more details.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "cohesion": {
                    "Description": "Returns the cohesion of the group with the given index.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "cohesions": {
                    "Description": "Returns the list of cohesion values for each group.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "hierarchy": {
                    "Description": "Returns a new graph that describes the hierarchical relationships between the groups.\nThe new graph will be a directed tree; an edge will point from vertex i to vertex j if group i is a superset of group j. In other words, the edges point downwards.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "max_cohesion": {
                    "Description": "Finds the maximum cohesion score among all the groups that contain the given vertex.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "max_cohesions": {
                    "Description": "For each vertex in the graph, returns the maximum cohesion score among all the groups that contain the vertex.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "parent": {
                    "Description": "Returns the parent group index of the group with the given index or None if the given group is the root.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "parents": {
                    "Description": "Returns the list of parent group indices for each group or None if the given group is the root.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "crossing": {
                    "Description": "Inherited from VertexCover:Returns a boolean vector where element i is True iff edge i lies between clusters, False otherwise."
                },
                "subgraph": {
                    "Description": "Inherited from VertexCover:Get the subgraph belonging to a given cluster."
                },
                "subgraphs": {
                    "Description": "Inherited from VertexCover:Gets all the subgraphs belonging to each of the clusters."
                }
            },
            "property": {
                "graph": "Inherited from VertexCover:Returns the graph belonging to this object"
            }
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "consecutive_pairs",
        "Description": "Returns consecutive pairs of items from the given iterable.\nWhen circular is True, the pair consisting of the lastand first elements is also returned.\nExample:>>> list(consecutive_pairs(range(5)))[(0, 1), (1, 2), (2, 3), (3, 4)]>>> list(consecutive_pairs(range(5), circular=True))[(0, 1), (1, 2), (2, 3), (3, 4), (4, 0)]>>> list(consecutive_pairs([]))[]>>> list(consecutive_pairs([], circular=True))[]>>> list(consecutive_pairs([0]))[]>>> list(consecutive_pairs([0], circular=True))[(0, 0)]",
        "Paramters": {},
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "dbl_epsilon",
        "Description": "Approximates the machine epsilon value for doubles.",
        "Paramters": {},
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "deprecated",
        "Description": "Prints a warning message related to the deprecation of some igraphfeature.",
        "Paramters": {},
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "named_temporary_file",
        "Description": "Context manager that creates a named temporary file andreturns its name.\nAll parameters are passed on to tempfile.mkstemp, seeits documentation for more info.",
        "Paramters": {},
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "numpy_to_contiguous_memoryview",
        "Description": "Converts a NumPy array or matrix into a contiguous memoryview objectthat is suitable to be forwarded to the Graph constructor.\nThis is used internally to allow us to use a NumPy array or matrixdirectly when constructing a Graph.",
        "Paramters": {},
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "rescale",
        "Description": "Rescales a list of numbers into a given range.\nout_range gives the range of the output values; by default, the minimumof the original numbers in the list will be mapped to the first elementin the output range and the maximum will be mapped to the second element.Elements between the minimum and maximum values in the input list will beinterpolated linearly between the first and second values of the outputrange.\nin_range may be used to override which numbers are mapped to the firstand second values of the output range. This must also be a tuple, wherethe first element will be mapped to the first element of the output rangeand the second element to the second.\nIf clamp is True, elements which are outside the given out_rangeafter rescaling are clamped to the output range to ensure that no numberwill be outside out_range in the result.\nIf scale is not None, it will be called for every element of valuesand the rescaling will take place on the results instead. This can be used,for instance, to transform the logarithm of the original values instead ofthe actual values. A typical use-case is to map a range of values to coloridentifiers on a logarithmic scale. Scaling also applies to the in_rangeparameter if present.\nExamples:>>> rescale(range(5), (0, 8))[0.0, 2.0, 4.0, 6.0, 8.0]>>> rescale(range(5), (2, 10))[2.0, 4.0, 6.0, 8.0, 10.0]>>> rescale(range(5), (0, 4), (1, 3))[-2.0, 0.0, 2.0, 4.0, 6.0]>>> rescale(range(5), (0, 4), (1, 3), clamp=True)[0.0, 0.0, 2.0, 4.0, 4.0]>>> rescale([0]*5, (1, 3))[2.0, 2.0, 2.0, 2.0, 2.0]>>> from math import log10>>> rescale([1, 10, 100, 1000, 10000], (0, 8), scale=log10)[0.0, 2.0, 4.0, 6.0, 8.0]>>> rescale([1, 10, 100, 1000, 10000], (0, 4), (10, 1000), scale=log10)[-2.0, 0.0, 2.0, 4.0, 6.0]",
        "Paramters": {
            "values": "Undocumented",
            "out_range": "the range of output values",
            "in_range": "the range of the input values; this is the range that is mappedto out_range. None means to use the minimum and maximum ofthe input, respectively.",
            "clamp": "specifies what to do when an input value falls outside in_range.True means to  the value to the bounds of in_range,False means not to .",
            "scale": "an optional transformation to perform on the input values beforemapping them to the output range."
        },
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "safemax",
        "Description": "Safer variant of max() that returns a default value if the iterableis empty.\nExample:>>> safemax([-5, 6, 4])6>>> safemax([])0>>> safemax((), 2)2",
        "Paramters": {},
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "safemin",
        "Description": "Safer variant of min() that returns a default value if the iterableis empty.\nExample:>>> safemin([-5, 6, 4])-5>>> safemin([])0>>> safemin((), 2)2",
        "Paramters": {},
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "InternalError",
        "Description": "Undocumented",
        "Field List": {
            "Methods": {},
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "AbstractXMLRPCDrawer",
        "Description": "Abstract drawer that uses a remote service via XML-RPC to draw something on a remote display.",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "overridden in igraph.drawing.graph.CytoscapeGraphDrawer\nConstructs an abstract drawer using the XML-RPC service at the given URL.",
                    "Paramters": {
                        "url": "the URL where the XML-RPC calls for the service should be addressed to.",
                        "service": "the name of the  at the XML-RPC address. If None, requests will be directed to the server proxy object constructed by xmlrpclib.ServerProxy; if not None, the given attribute will be looked up in the server proxy object."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw": {
                    "Description": "Inherited from AbstractDrawer:Abstract method, must be implemented in derived classes."
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "AbstractGraphDrawer",
        "Description": "Abstract class that serves as a base class for anything that draws an igraph.Graph.",
        "Field List": {
            "Methods": {
                "ensure_layout": {
                    "Description": "Helper method that ensures that layout is an instance of Layout. If it is not, the method will try to convert it to a Layout according to the following rules:If layout is a string, it is assumed to be a name of an igraph layout, and it will be passed on to the layout method of the given graph if graph is not None.If layout is None and graph has a \"layout\" attribute, call this same function with the value of that attribute.If layout is None and graph does not have a \"layout\" attribute, the layout method of graph will be invoked with no parameters, which will call the default layout algorithm.Otherwise, layout will be passed on to the constructor of Layout. This handles lists of lists, lists of tuples and such.\nIf layout is already a Layout instance, it will still be copied and a copy will be returned. This is because graph drawers are allowed to transform the layout for their purposes, and we don't want the transformation to propagate back to the caller.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw": {
                    "Description": "overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nAbstract method, must be implemented in derived classes.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "CairoDendrogramDrawer",
        "Description": "Default Cairo drawer object for dendrograms.",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "overrides igraph.drawing.cairo.base.AbstractCairoDrawer.__init__\nConstructs the drawer and associates it to the given palette.",
                    "Paramters": {
                        "context": "the  on which we will draw",
                        "bbox": "the bounding box within which we will draw. Can be anything accepted by the constructor of BoundingBox (i.e., a 2-tuple, a 4-tuple or a BoundingBox object).",
                        "palette": "the  that can be used to map integer color indices to colors when drawing vertices"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw": {
                    "Description": "overrides igraph.drawing.baseclasses.AbstractDrawer.draw\nDraws the given Dendrogram in a Cairo context.",
                    "Paramters": {
                        "dendro": "the igraph.Dendrogram to plot.It accepts the following keyword arguments:style: the style of the plot. boolean is useful for plotting matrices with boolean (True/False or 0/1) values: False will be shown with a white box and True with a black box. palette uses the given palette to represent numbers by colors, the minimum will be assigned to palette color index 0 and the maximum will be assigned to the length of the palette. None draws transparent cell backgrounds only. The default style is boolean (but it may change in the future). None values in the matrix are treated specially in both cases: nothing is drawn in the cell corresponding to None.square: whether the cells of the matrix should be square or not. Default is True.grid_width: line width of the grid shown on the matrix. If zero or negative, the grid is turned off. The grid is also turned off if the size of a cell is less than three times the given line width. Default is 1. Fractional widths are also allowed.border_width: line width of the border drawn around the matrix. If zero or negative, the border is turned off. Default is 1.row_names: the names of the rowscol_names: the names of the columns.values: values to be displayed in the cells. If None or False, no values are displayed. If True, the values come from the matrix being plotted. If it is another matrix, the values of that matrix are shown in the cells. In this case, the shape of the value matrix must match the shape of the matrix being plotted.value_format: a format string or a callable that specifies how the values should be plotted. If it is a callable, it must be a function that expects a single value and returns a string. Example: \"%#.2f\" for floating-point numbers with always exactly two digits after the decimal point. See the Python documentation of the % operator for details on the format string. If the format string is not given, it defaults to the str function.If only the row names or the column names are given and the matrix is square-shaped, the same names are used for both column and row names.",
                        "**kwds": "Undocumented"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "bbox.setter": {
                    "Description": "Inherited from AbstractCairoDrawer:Sets the bounding box of the drawing area where this drawer will draw."
                }
            },
            "property": {
                "bbox": "Inherited from AbstractCairoDrawer:The bounding box of the drawing area where this drawer will draw."
            }
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "DarkToLightEdgeDrawer",
        "Description": "Edge drawer implementation that draws undirected edges as straight lines and directed edges by using an alpha value of one (full opacity) at the source and an alpha value of zero (total transparency) at the destination. The alpha value is interpolated in-between.",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "overrides igraph.drawing.cairo.edge.AlphaVaryingEdgeDrawer.__init__\nConstructs the edge drawer.",
                    "Paramters": {
                        "context": "a Cairo  on which the edges will be drawn.",
                        "palette": "the  that can be used to map integer color indices to colors when drawing edges"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw_directed_edge": {
                    "Description": "Inherited from AlphaVaryingEdgeDrawer:Draws a directed edge."
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "ShapeDrawerDirectory",
        "Description": "Static class that resolves shape names to their corresponding shape drawer classes.\nClasses that are derived from ShapeDrawer in this module are automatically registered by ShapeDrawerDirectory when the module is loaded for the first time.",
        "Field List": {
            "Methods": {
                "register": {
                    "Description": "Registers the given shape drawer class under the given names.",
                    "Paramters": {
                        "drawer_class": "the shape drawer class to be registered"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "register_namespace": {
                    "Description": "Registers all ShapeDrawer classes in the given namespace",
                    "Paramters": {
                        "namespace": "a Python dict mapping names to Python objects."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "resolve": {
                    "Description": "Given a shape name, returns the corresponding shape drawer class",
                    "Paramters": {
                        "shape": "the name of the "
                    },
                    "Return": [
                        "the corresponding shape drawer class"
                    ],
                    "References": [],
                    "Rasises": {
                        "ValueError": "if the shape is unknown"
                    },
                    "See Also": "",
                    "example": []
                },
                "resolve_default": {
                    "Description": "Given a shape name, returns the corresponding shape drawer class or the given default shape drawer if the shape name is unknown.",
                    "Paramters": {
                        "shape": "the name of the ",
                        "default": "the  shape drawer to return when the shape is unknown"
                    },
                    "Return": [
                        "the shape drawer class corresponding to the given name or the default shape drawer class if the name is unknown"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "PlotlyVerticesDrawer",
        "Description": "Plotly backend-specific vertex drawer.",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "overrides igraph.drawing.baseclasses.AbstractVertexDrawer.__init__\nConstructs the vertex drawer and associates it to the given palette.",
                    "Paramters": {
                        "fig": "Undocumented",
                        "palette": "the  that can be used to map integer color indices to colors when drawing vertices",
                        "layout": "the  of the vertices in the graph being drawn"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw": {
                    "Description": "overrides igraph.drawing.baseclasses.AbstractVertexDrawer.draw\nDraws the given vertex.",
                    "Paramters": {
                        "visual_vertex": "object specifying the visual properties of the vertex. Its structure is defined by the VisualVertexBuilder of the CairoGraphDrawer; see its source code.",
                        "vertex": "the raw igraph  being drawn",
                        "point": "Undocumented",
                        "coords": "the X and Y coordinates of the vertex as specified by the layout algorithm, scaled into the bounding box."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw_label": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "Flow",
        "Description": "A flow of a given graph.\nThis is a simple class used to represent flows returned by Graph.maxflow. It has the following attributes: graph - the graph on which this flow is defined value - the value (capacity) of the flow flow - the flow values on each edge. For directed graphs, this is simply a list where element i corresponds to the flow on edge i. For undirected graphs, the direction of the flow is not constrained (since the edges are undirected), hence positive flow always means a flow from the smaller vertex ID to the larger, while negative flow means a flow from the larger vertex ID to the smaller. cut - edge IDs in the minimal cut corresponding to the flow. partition - vertex IDs in the parts created after removing edges in the cut es - an edge selector restricted to the edges in the cut. \nThis class is usually not instantiated directly, everything is taken care of by Graph.maxflow.\n",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "overrides igraph.Cut.__init__\nInitializes the flow.\nThis should not be called directly, everything is taken care of by Graph.maxflow.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__repr__": {
                    "Description": "overrides igraph.Cut.__repr__\nUndocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__str__": {
                    "Description": "overrides igraph.Cut.__str__\nUndocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {
                "flow": "Returns the flow values for each edge.\nFor directed graphs, this is simply a list where element i corresponds to the flow on edge i. For undirected graphs, the direction of the flow is not constrained (since the edges are undirected), hence positive flow always means a flow from the smaller vertex ID to the larger, while negative flow means a flow from the larger vertex ID to the smaller.\n\n",
                "cut": "Inherited from Cut:Returns the edge IDs in the cut",
                "es": "Inherited from Cut:Returns an edge selector restricted to the cut",
                "partition": "Inherited from Cut:Returns the vertex IDs partitioned according to the cut",
                "value": "Inherited from Cut:Returns the sum of edge capacities in the cut"
            }
        },
        "Rubric": {
            "Example": [
                "Examples:\n>>> from igraph import Graph\n>>> g = Graph.Ring(20)\n>>> mf = g.maxflow(0, 10)\n>>> print(mf.value)\n2.0\n>>> mf.es[\"color\"] = \"red\""
            ]
        }
    },
    {
        "Section_id": "Graph",
        "Description": "Generic graph.\nThis class is built on top of GraphBase, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. Graph provides many functions that GraphBase does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of Graph accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of GraphBase does not. This extension was needed to make Graph serializable through the pickle module. Graph also overrides some functions from GraphBase to provide a more convenient interface; e.g., layout functions return a Layout instance from Graph instead of a list of coordinate pairs.\n",
        "Field List": {
            "Methods": {
                "Adjacency": {
                    "Description": "overrides igraph.GraphBase.Adjacency\nGenerates a graph from its adjacency matrix.",
                    "Paramters": {
                        "matrix": "the adjacency . Possible types are:a list of listsa numpy 2D array or  (will be converted to list of lists)a scipy.sparse  (will be converted to a COO , but not to a dense )a pandas.DataFrame (column/row names must match, and will be used as vertex names).",
                        "mode": "the  to be used. Possible values are:\"directed\" - the graph will be directed and a matrix element specifies the number of edges between two vertices.\"undirected\" - the graph will be undirected and a matrix element specifies the number of edges between two vertices. The matrix must be symmetric.\"max\" - undirected graph will be created and the number of edges between vertex i and j is max(A(i,\u2009j),\u2009A(j,\u2009i))\"min\" - like \"max\", but with min(A(i,\u2009j),\u2009A(j,\u2009i))\"plus\"  - like \"max\", but with A(i,\u2009j)\u2009+\u2009A(j,\u2009i)\"upper\" - undirected graph with the upper right triangle of the matrix (including the diagonal)\"lower\" - undirected graph with the lower left triangle of the matrix (including the diagonal)",
                        "loops": "specifies how to handle loop edges. When False or \"ignore\", the diagonal of the adjacency matrix will be ignored. When True or \"once\", the diagonal is assumed to contain the multiplicity of the corresponding loop edge. When \"twice\", the diagonal is assumed to contain twice the multiplicity of the corresponding loop edge."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Biadjacency": {
                    "Description": "Creates a bipartite graph from a bipartite adjacency matrix.\nExample:",
                    "Paramters": {
                        "matrix": "the bipartite adjacency .",
                        "directed": "whether to create a  graph.",
                        "mode": "defines the direction of edges in the graph. If \"out\", then edges go from vertices of the first kind (corresponding to rows of the matrix) to vertices of the second kind (the columns of the matrix). If \"in\", the opposite direction is used. \"all\" creates mutual edges. Ignored for undirected graphs.",
                        "multiple": "defines what to do with non-zero entries in the matrix. If False, non-zero entries will create an edge no matter what the value is. If True, non-zero entries are rounded up to the nearest integer and this will be the number of  edges created.",
                        "weighted": "defines whether to create a  graph from the adjacency matrix. If it is c{None} then an un graph is created and the multiple argument is used to determine the edges of the graph. If it is a string then for every non-zero matrix entry, an edge is created and the value of the entry is added as an edge attribute named by the  argument. If it is True then a  graph is created and the name of the edge attribute will be \"weight\".",
                        "*args": "Undocumented",
                        "**kwds": "Undocumented"
                    },
                    "Return": [
                        "the graph with a binary vertex attribute named \"type\" that stores the vertex classes."
                    ],
                    "References": [],
                    "Rasises": {
                        "ValueError": "if the weighted and multiple are passed together."
                    },
                    "See Also": "",
                    "example": [
                        "Example:\n>>> g = Graph.Biadjacency([[0, 1, 1], [1, 1, 0]])"
                    ]
                },
                "Bipartite": {
                    "Description": "Creates a bipartite graph with the given vertex types and edges. This is similar to the default constructor of the graph, the only difference is that it checks whether all the edges go between the two vertex classes and it assigns the type vector to a type attribute afterwards.\nExamples:",
                    "Paramters": {
                        "types": "the vertex  as a boolean list. Anything that evaluates to False will denote a vertex of the first kind, anything that evaluates to True will denote a vertex of the second kind.",
                        "edges": "the  as a list of tuples.",
                        "directed": "whether to create a  graph. Bipartite networks are usually un, so the default is False",
                        "*args": "Undocumented",
                        "**kwds": "Undocumented"
                    },
                    "Return": [
                        "the graph with a binary vertex attribute named \"type\" that stores the vertex classes."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": [
                        "Examples:\n>>> g = Graph.Bipartite([0, 1, 0, 1], [(0, 1), (2, 3), (0, 3)])\n>>> g.is_bipartite()\nTrue\n>>> g.vs[\"type\"]\n[False, True, False, True]\n"
                    ]
                },
                "DataFrame": {
                    "Description": "Generates a graph from one or two dataframes.",
                    "Paramters": {
                        "edges": "pandas DataFrame containing  and metadata. The first two columns of this DataFrame contain the source and target vertices for each edge. These indicate the vertex IDs as nonnegative integers rather than vertex names unless use_vids is False. Further columns may contain edge attributes.",
                        "directed": ":boolwhether the graph is ",
                        "vertices": "None (default) or pandas DataFrame containing vertex metadata. The DataFrame's index must contain the vertex IDs as a sequence of intergers from 0 to len() - 1. If use_vids is False, the first column must contain the unique vertex names. Vertex names should be strings for full compatibility, but many functions will work if you set the name with any hashable object. All other columns will be added as vertex attributes by column name.",
                        "use_vids": ":boolwhether to interpret the first two columns of the edges argument as vertex ids (0-based integers) instead of vertex names. If this argument is set to True and the first two columns of edges are not integers, an error is thrown."
                    },
                    "Return": [
                        "the graph\nVertex names in either the edges or vertices arguments that are set to NaN (not a number) will be set to the string \"NA\". That might lead to unexpected behaviour: fill your NaNs with values before calling this function to mitigate.\n"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "DictDict": {
                    "Description": "Constructs a graph from a dict-of-dicts representation.\nEach key can be an integer or a string and represent a vertex. Each value is a dict representing edges (outgoing if the graph is directed) from that vertex. Each dict key is an integer/string for a target vertex, such that an edge will be created between those two vertices. Integers are interpreted as vertex_ids from 0 (as used in igraph), strings are interpreted as vertex names, in which case vertices are given separate numeric ids. Each value is a dictionary of edge attributes for that edge.\nExample:",
                    "Paramters": {
                        "edges": "the dict of dict of dicts specifying the  and their attributes",
                        "directed": ":boolwhether to create a  graph",
                        "vertex_name_attr": ":strvertex attribute that will store the names"
                    },
                    "Return": [
                        "a Graph object"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": [
                        "Example:\n>>> {'Alice': {'Bob': {'weight': 1.5}, 'David': {'weight': 2}}}"
                    ]
                },
                "DictList": {
                    "Description": "Constructs a graph from a list-of-dictionaries representation.\nThis function is useful when you have two lists of dictionaries, one for vertices and one for edges, each containing their attributes (e.g. name, weight). Of course, the edge dictionary must also contain two special keys that indicate the source and target vertices connected by that edge. Non-list iterables should work as long as they yield dictionaries or dict-like objects (they should have the 'items' and '__getitem__' methods). For instance, a database query result is likely to be fit as long as it's iterable and yields dict-like objects with every iteration.",
                    "Paramters": {
                        "vertices": "the list of dictionaries for the  or None if there are no special attributes assigned to  and we should simply use the edge list of dicts to infer vertex names.",
                        "edges": "the list of dictionaries for the . Each dict must have at least the two keys specified by edge_foreign_keys to label the source and target vertices, while additional items will be treated as edge attributes.",
                        "directed": ":boolwhether the constructed graph will be ",
                        "vertex_name_attr": ":strthe name of the distinguished key in the dicts in the vertex data source that contains the vertex names. Ignored if vertices is None.",
                        "edge_foreign_keys": "tuple specifying the attributes in each edge dictionary that contain the source (1st) and target (2nd) vertex names. These items of each dictionary are also added as edge_attributes.",
                        "iterative": ":boolwhether to add the edges to the graph one by one, ly, or to build a large edge list first and use that to construct the graph. The latter approach is faster but it may not be suitable if your dataset is large. The default is to add the edges in a batch from an edge list."
                    },
                    "Return": [
                        "the graph that was constructed\nExample:\n\n>>> vertices = [{'name': 'apple'}, {'name': 'pear'}, {'name': 'peach'}]\n>>> edges = [{'source': 'apple', 'target': 'pear', 'weight': 1.2},\n...          {'source': 'apple', 'target': 'peach', 'weight': 0.9}]\n>>> g = Graph.DictList(vertices, edges)The graph has three vertices with names and two edges with weights.\n"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": [
                        "Example:\n>>> vertices = [{'name': 'apple'}, {'name': 'pear'}, {'name': 'peach'}]\n>>> edges = [{'source': 'apple', 'target': 'pear', 'weight': 1.2},\n...          {'source': 'apple', 'target': 'peach', 'weight': 0.9}]\n>>> g = Graph.DictList(vertices, edges)"
                    ]
                },
                "from_graph_tool": {
                    "Description": "Converts the graph from graph-tool",
                    "Paramters": {
                        "g": "raph-tool Graph"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "from_networkx": {
                    "Description": "Converts the graph from networkx\nVertex names will be stored as a vertex_attr_hashable attribute (usually \"_nx_name\", but see below). Because igraph stored vertices in an ordered manner, vertices will get new IDs from 0 up. In case of multigraphs, each edge will have an \"_nx_multiedge_key\" attribute, to distinguish edges that connect the same two vertices.",
                    "Paramters": {
                        "g": "networkx Graph or DiGraph",
                        "vertex_attr_hashable": ":strattribute used to store the Python hashable used by networkx to identify each vertex. The default value '_nx_name' ensures lossless round trip conversions to/from networkx. An alternative choice is 'name': in that case, using strings for vertex names is recommended and, if the graph is re-exported to networkx, Graph.to_networkx(=\"name\") must be used to recover the correct vertex nomenclature in the exported network."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Full_Bipartite": {
                    "Description": "Generates a full bipartite graph (directed or undirected, with or without loops).",
                    "Paramters": {
                        "n1": "the number of vertices of the first kind.",
                        "n2": "the number of vertices of the second kind.",
                        "directed": "whether tp generate a  graph.",
                        "mode": "if \"out\", then all vertices of the first kind are connected to the others; \"in\" specifies the opposite direction, \"all\" creates mutual edges. Ignored for undirected graphs.",
                        "*args": "Undocumented",
                        "**kwds": "Undocumented"
                    },
                    "Return": [
                        "the graph with a binary vertex attribute named \"type\" that stores the vertex classes."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": [
                        "Generates a full bipartite graph (directed or undirected, with or without loops).\n>>> g = Graph.Full_Bipartite(2, 3)\n>>> g.is_bipartite()\nTrue\n>>> g.vs[\"type\"]\n[False, False, True, True, True]\n"
                    ]
                },
                "GRG": {
                    "Description": "Generates a random geometric graph.\nThe algorithm drops the vertices randomly on the 2D unit square and connects them if they are closer to each other than the given radius. The coordinates of the vertices are stored in the vertex attributes x and y.",
                    "Paramters": {
                        "n": "The umber of vertices i the graph",
                        "radius": "The given ",
                        "torus": "This should be True if we want to use a  instead of a square."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Incidence": {
                    "Description": "Deprecated alias to Graph.Biadjacency().",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "ListDict": {
                    "Description": "Constructs a graph from a dict-of-lists representation.\nThis function is used to construct a graph from a dictionary of lists. Other, non-list sequences (e.g. tuples) and lazy iterators are are accepted. For each key x, its corresponding value must be a sequence of multiple values y: the edge (x,y) will be created in the graph. x and y must be either one of:two integers: the vertices with those ids will be connectedtwo strings: the vertices with those names will be connected\nIf names are used, the order of vertices is not guaranteed, and each vertex will be given the vertex_name_attr attribute.",
                    "Paramters": {
                        "edges": "the dict of sequences describing the ",
                        "directed": ":boolwhether to create a  graph",
                        "vertex_name_attr": ":strvertex attribute that will store the names"
                    },
                    "Return": [
                        "a Graph object\nExample:\n\n>>> mydict = {'apple': ['pear', 'peach'], 'pear': ['peach']}\n>>> g = Graph.ListDict(mydict)# The graph has three vertices with names and three edges connecting # each pair.\n"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": [
                        "Example:\n>>> mydict = {'apple': ['pear', 'peach'], 'pear': ['peach']}\n>>> g = Graph.ListDict(mydict)"
                    ]
                },
                "Random_Bipartite": {
                    "Description": "Generates a random bipartite graph with the given number of vertices and edges (if m is given), or with the given number of vertices and the given connection probability (if p is given).\nIf m is given but p is not, the generated graph will have n1 vertices of type 1, n2 vertices of type 2 and m randomly selected edges between them. If p is given but m is not, the generated graph will have n1 vertices of type 1 and n2 vertices of type 2, and each edge will exist between them with probability p.",
                    "Paramters": {
                        "n1": "the number of vertices of type 1.",
                        "n2": "the number of vertices of type 2.",
                        "p": "the robability of edges. If given, m must be missing.",
                        "m": "the nuber of edges. If given, p ust be issing.",
                        "directed": "whether to generate a  graph.",
                        "neimode": "if the graph is directed, specifies how the edges will be generated. If it is \"all\", edges will be generated in both directions (from type 1 to type 2 and vice versa) independently. If it is \"out\" edges will always point from type 1 to type 2. If it is \"in\", edges will always point from type 2 to type 1. This argument is ignored for undirected graphs.",
                        "*args": "Undocumented",
                        "**kwds": "Undocumented"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Read": {
                    "Description": "Unified reading function for graphs.\nThis method tries to identify the format of the graph given in the first parameter and calls the corresponding reader method.\nThe remaining arguments are passed to the reader method without any changes.",
                    "Paramters": {
                        "f": "the ile containing the graph to be loaded",
                        "format": "the  of the file (if known in advance). None means auto-detection. Possible values are: \"ncol\" (NCOL ), \"lgl\" (LGL ), \"graphdb\" (GraphDB ), \"graphml\", \"graphmlz\" (GraphML and gzipped GraphML ), \"gml\" (GML ), \"net\", \"pajek\" (Pajek ), \"dimacs\" (DIMACS ), \"edgelist\", \"edges\" or \"edge\" (edge list), \"adjacency\" (adjacency matrix), \"dl\" (DL  used by UCINET), \"pickle\" (Python pickled ), \"picklez\" (gzipped Python pickled )",
                        "*args": "Undocumented",
                        "**kwds": "Undocumented"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {
                        "IOError": "if the file format can't be identified and none was given."
                    },
                    "See Also": "",
                    "example": []
                },
                "Read_Adjacency": {
                    "Description": "Constructs a graph based on an adjacency matrix from the given file.\nAdditional positional and keyword arguments not mentioned here are passed intact to Graph.Adjacency.",
                    "Paramters": {
                        "f": "the name o the ile to be read or a ile object",
                        "sep": "the string that arates the matrix elements in a row. None means an arbitrary sequence of whitespace characters.",
                        "comment_char": "lines starting with this string are treated as comments.",
                        "attribute": "an edge  name where the edge weights are stored in the case of a weighted adjacency matrix. If None, no weights are stored, values larger than 1 are considered as edge multiplicities.",
                        "*args": "Undocumented",
                        "**kwds": "Undocumented"
                    },
                    "Return": [
                        "the created graph"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Read_DIMACS": {
                    "Description": "overrides igraph.GraphBase.Read_DIMACS\nReads a graph from a file conforming to the DIMACS minimum-cost flow file format.\nFor the exact definition of the format, see http://lpsolve.sourceforge.net/5.5/DIMACS.htm.\nRestrictions compared to the official description of the format are as follows:igraph's DIMACS reader requires only three fields in an arc definition, describing the edge's source and target node and its capacity.Source vertices are identified by 's' in the FLOW field, target vertices are identified by 't'.Node indices start from 1. Only a single source and target node is allowed.",
                    "Paramters": {
                        "f": "the name o the ile or a Python ile handle",
                        "directed": "whether the generated graph should be ."
                    },
                    "Return": [
                        "the generated graph. The indices of the source and target vertices are attached as graph attributes source and target, the edge capacities are stored in the capacity edge attribute."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Read_GraphMLz": {
                    "Description": "Reads a graph from a zipped GraphML file.",
                    "Paramters": {
                        "f": "the name o the ile",
                        "index": "if the GraphML file contains multiple graphs, specified the one that should be loaded. Graph indices start from zero, so if you want to load the first graph, specify 0 here."
                    },
                    "Return": [
                        "the loaded graph object"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Read_Pickle": {
                    "Description": "Reads a graph from Python pickled format",
                    "Paramters": {
                        "fname": "the name of the file, a stream to read from, or a string containing the pickled data."
                    },
                    "Return": [
                        "the created graph object."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Read_Picklez": {
                    "Description": "Reads a graph from compressed Python pickled format, uncompressing it on-the-fly.",
                    "Paramters": {
                        "fname": "the name of the file or a stream to read from."
                    },
                    "Return": [
                        "the created graph object."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "TupleList": {
                    "Description": "Constructs a graph from a list-of-tuples representation.\nThis representation assumes that the edges of the graph are encoded in a list of tuples (or lists). Each item in the list must have at least two elements, which specify the source and the target vertices of the edge. The remaining elements (if any) specify the edge attributes of that edge, where the names of the edge attributes originate from the edge_attrs list. The names of the vertices will be stored in the vertex attribute given by vertex_name_attr.\nThe default parameters of this function are suitable for creating unweighted graphs from lists where each item contains the source vertex and the target vertex. If you have a weighted graph, you can use items where the third item contains the weight of the edge by setting edge_attrs to \"weight\" or [\"weight\"]. If you have even more edge attributes, add them to the end of each item in the edges list and also specify the corresponding edge attribute names in edge_attrs as a list.",
                    "Paramters": {
                        "edges": "the data source for the . This must be a list where each item is a tuple (or list) containing at least two items: the name of the source and the target vertex. Note that names will be assigned to the name vertex attribute (or another vertex attribute if vertex_name_attr is specified), even if all the vertex names in the list are in fact numbers.",
                        "directed": ":boolwhether the constructed graph will be ",
                        "vertex_name_attr": ":strthe name of the vertex attribute that will contain the vertex names.",
                        "edge_attrs": "the names of the edge attributes that are filled with the extra items in the edge list (starting from index 2, since the first two items are the source and target vertices). If None or an empty sequence, only the source and target vertices will be extracted and additional tuple items will be ignored. If a string, it is interpreted as a single edge attribute.",
                        "weights": "alternative way to specify that the graph is weighted. If you set  to true and edge_attrs is not given, it will be assumed that edge_attrs is [\"weight\"] and igraph will parse the third element from each item into an edge weight. If you set  to a string, it will be assumed that edge_attrs contains that string only, and igraph will store the edge  in that attribute."
                    },
                    "Return": [
                        "the graph that was constructed"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "Weighted_Adjacency": {
                    "Description": "Generates a graph from its weighted adjacency matrix.",
                    "Paramters": {
                        "matrix": "the adjacency . Possible types are:a list of listsa numpy 2D array or  (will be converted to list of lists)a scipy.sparse  (will be converted to a COO , but not to a dense )",
                        "mode": "the  to be used. Possible values are:\"directed\" - the graph will be directed and a matrix element specifies the number of edges between two vertices.\"undirected\" - the graph will be undirected and a matrix element specifies the number of edges between two vertices. The matrix must be symmetric.\"max\"   - undirected graph will be created and the number of edges between vertex i and j is max(A(i,\u2009j),\u2009A(j,\u2009i))\"min\"   - like \"max\", but with min(A(i,\u2009j),\u2009A(j,\u2009i))\"plus\"  - like \"max\", but with A(i,\u2009j)\u2009+\u2009A(j,\u2009i)\"upper\" - undirected graph with the upper right triangle of the matrix (including the diagonal)\"lower\" - undirected graph with the lower left triangle of the matrix (including the diagonal)These values can also be given as strings without the ADJ prefix.",
                        "attr": "the name of the edge ibute that stores the edge weights.",
                        "loops": "specifies how to handle loop edges. When False or \"ignore\", the diagonal of the adjacency matrix will be ignored. When True or \"once\", the diagonal is assumed to contain the weight of the corresponding loop edge. When \"twice\", the diagonal is assumed to contain twice the weight of the corresponding loop edge."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__add__": {
                    "Description": "Copies the graph and extends the copy depending on the type of the other object given.",
                    "Paramters": {
                        "graph": "Undocumented",
                        "other": "if it is an integer, the copy is extended by the given number of vertices. If it is a string, the copy is extended by a single vertex whose name attribute will be equal to the given string. If it is a tuple with two elements, the copy is extended by a single edge. If it is a list of tuples, the copy is extended by multiple edges. If it is a Graph, a disjoint union is performed."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__and__": {
                    "Description": "Graph intersection operator.",
                    "Paramters": {
                        "graph": "Undocumented",
                        "other": "the  graph to take the intersection with."
                    },
                    "Return": [
                        "the intersected graph."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__bool__": {
                    "Description": "Returns True if the graph has at least one vertex, False otherwise.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__coerce__": {
                    "Description": "Coercion rules.\nThis method is needed to allow the graph to react to additions with lists, tuples, integers, strings, vertices, edges and so on.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__iadd__": {
                    "Description": "In-place addition (disjoint union).",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "__add__",
                    "example": []
                },
                "__init__": {
                    "Description": "__init__(n=0, edges=None, directed=False, graph_attrs=None, vertex_attrs=None, edge_attrs=None)\nConstructs a graph from scratch.",
                    "Paramters": {
                        "*args": "Undocumented",
                        "n": "the umber of vertices. Ca be omitted, the default is zero. Note that if the edge list cotais vertices with idexes larger tha or equal to , the the umber of vertices will be adjusted accordigly.",
                        "edges": "the edge list where every list item is a pair of integers. If any of the integers is larger than n\u2009\u2212\u20091, the number of vertices is adjusted accordingly. None means no .",
                        "directed": "whether the graph should be ",
                        "graph_attrs": "the attributes of the graph as a dictionary.",
                        "vertex_attrs": "the attributes of the vertices as a dictionary. The keys of the dictionary must be the names of the attributes; the values must be iterables with exactly n items where n is the number of vertices.",
                        "edge_attrs": "the attributes of the edges as a dictionary. The keys of the dictionary must be the names of the attributes; the values must be iterables with exactly m items where m is the number of edges."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__isub__": {
                    "Description": "In-place subtraction (difference).",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "__sub__",
                    "example": []
                },
                "__mul__": {
                    "Description": "Copies exact replicas of the original graph an arbitrary number of times.",
                    "Paramters": {
                        "graph": "Undocumented",
                        "other": "if it is an integer, multiplies the graph by creating the given number of identical copies and taking the disjoint union of them."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__or__": {
                    "Description": "Graph union operator.",
                    "Paramters": {
                        "graph": "Undocumented",
                        "other": "the  graph to take the union with."
                    },
                    "Return": [
                        "the union graph."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__plot__": {
                    "Description": "Plots the graph to the given Cairo context or matplotlib Axes.\nThe visual style of vertices and edges can be modified at three places in the following order of precedence (lower indices override higher indices):Keyword arguments of this function (or of plot() which is passed intact to Graph.__plot__().Vertex or edge attributes, specified later in the list of keyword arguments.igraph-wide plotting defaults (see igraph.config.Configuration)Built-in defaults.\nE.g., if the vertex_size keyword attribute is not present, but there exists a vertex attribute named size, the sizes of the vertices will be specified by that attribute.\nBesides the usual self-explanatory plotting parameters (context, bbox, palette), it accepts the following keyword arguments:autocurve: whether to use curves instead of straight lines for multiple edges on the graph plot. This argument may be True or False; when omitted, True is assumed for graphs with less than 10.000 edges and False otherwise.drawer_factory: a subclass of AbstractCairoGraphDrawer which will be used to draw the graph. You may also provide a function here which takes two arguments: the Cairo context to draw on and a bounding box (an instance of BoundingBox). If this keyword argument is missing, igraph will use the default graph drawer which should be suitable for most purposes. It is safe to omit this keyword argument unless you need to use a specific graph drawer.keep_aspect_ratio: whether to keep the aspect ratio of the layout that igraph calculates to place the nodes. True means that the layout will be scaled proportionally to fit into the bounding box where the graph is to be drawn but the aspect ratio will be kept the same (potentially leaving empty space next to, below or above the graph). False means that the layout will be scaled independently along the X and Y axis in order to fill the entire bounding box. The default is False.layout: the layout to be used. If not an instance of Layout, it will be passed to layout to calculate the layout. Note that if you want a deterministic layout that does not change with every plot, you must either use a deterministic layout function (like GraphBase.layout_circle) or calculate the layout in advance and pass a Layout object here.margin: the top, right, bottom, left margins as a 4-tuple. If it has less than 4 elements or is a single float, the elements will be re-used until the length is at least 4.mark_groups: whether to highlight some of the vertex groups by colored polygons. This argument can be one of the following:False: no groups will be highlightedTrue: only valid if the object plotted is a VertexClustering or VertexCover. The vertex groups in the clutering or cover will be highlighted such that the i-th group will be colored by the i-th color from the current palette. If used when plotting a graph, it will throw an error.A dict mapping tuples of vertex indices to color names. The given vertex groups will be highlighted by the given colors.A list containing pairs or an iterable yielding pairs, where the first element of each pair is a list of vertex indices and the second element is a color.A VertexClustering or VertexCover instance. The vertex groups in the clustering or cover will be highlighted such that the i-th group will be colored by the i-th color from the current palette.In place of lists of vertex indices, you may also use VertexSeq instances.In place of color names, you may also use color indices into the current palette. None as a color name will mean that the corresponding group is ignored.vertex_size: size of the vertices. The corresponding vertex attribute is called size. The default is 10. Vertex sizes are measured in the unit of the Cairo context on which igraph is drawing.vertex_color: color of the vertices. The corresponding vertex attribute is color, the default is red.  Colors can be specified either by common X11 color names (see the source code of igraph.drawing.colors for a list of known colors), by 3-tuples of floats (ranging between 0 and 255 for the R, G and B components), by CSS-style string specifications (#rrggbb) or by integer color indices of the specified palette.vertex_frame_color: color of the frame (i.e. stroke) of the vertices. The corresponding vertex attribute is frame_color, the default is black. See vertex_color for the possible ways of specifying a color.vertex_frame_width: the width of the frame (i.e. stroke) of the vertices. The corresponding vertex attribute is frame_width. The default is 1. Vertex frame widths are measured in the unit of the Cairo context on which igraph is drawing.vertex_shape: shape of the vertices. Alternatively it can be specified by the shape vertex attribute. Possibilities are: square, {circle}, {triangle}, {triangle-down} or hidden. See the source code of igraph.drawing for a list of alternative shape names that are also accepted and mapped to these.vertex_label: labels drawn next to the vertices. The corresponding vertex attribute is label.vertex_label_dist: distance of the midpoint of the vertex label from the center of the corresponding vertex. The corresponding vertex attribute is label_dist.vertex_label_color: color of the label. Corresponding vertex attribute: label_color. See vertex_color for color specification syntax.vertex_label_size: font size of the label, specified in the unit of the Cairo context on which we are drawing. Corresponding vertex attribute: label_size.vertex_label_angle: the direction of the line connecting the midpoint of the vertex with the midpoint of the label. This can be used to position the labels relative to the vertices themselves in conjunction with vertex_label_dist. Corresponding vertex attribute: label_angle. The default is -math.pi/2.vertex_order: drawing order of the vertices. This must be a list or tuple containing vertex indices; vertices are then drawn according to this order.vertex_order_by: an alternative way to specify the drawing order of the vertices; this attribute is interpreted as the name of a vertex attribute, and vertices are drawn such that those with a smaller attribute value are drawn first. You may also reverse the order by passing a tuple here; the first element of the tuple should be the name of the attribute, the second element specifies whether the order is reversed (True, False, \"asc\" and \"desc\" are accepted values).edge_color: color of the edges. The corresponding edge attribute is color, the default is red. See vertex_color for color specification syntax.edge_curved: whether the edges should be curved. Positive numbers correspond to edges curved in a counter-clockwise direction, negative numbers correspond to edges curved in a clockwise direction. Zero represents straight edges. True is interpreted as 0.5, False is interpreted as 0. The default is 0 which makes all the edges straight.edge_width: width of the edges in the default unit of the Cairo context on which we are drawing. The corresponding edge attribute is width, the default is 1.edge_arrow_size: arrow size of the edges. The corresponding edge attribute is arrow_size, the default is 1.edge_arrow_width: width of the arrowhead on the edge. The corresponding edge attribute is arrow_width, the default is 1.edge_order: drawing order of the edges. This must be a list or tuple containing edge indices; edges are then drawn according to this order.edge_order_by: an alternative way to specify the drawing order of the edges; this attribute is interpreted as the name of an edge attribute, and edges are drawn such that those with a smaller attribute value are drawn first. You may also reverse the order by passing a tuple here; the first element of the tuple should be the name of the attribute, the second element specifies whether the order is reversed (True, False, \"asc\" and \"desc\" are accepted values).",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__reduce__": {
                    "Description": "Support for pickling.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__str__": {
                    "Description": "Returns a string representation of the graph.\nBehind the scenes, this method constructs a GraphSummary instance and invokes its __str__ method with a verbosity of 1 and attribute printing turned off.\nSee the documentation of GraphSummary for more details about the output.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__sub__": {
                    "Description": "Removes the given object(s) from the graph",
                    "Paramters": {
                        "graph": "Undocumented",
                        "other": "if it is an integer, removes the vertex with the given ID from the graph (note that the remaining vertices will get re-indexed!). If it is a tuple, removes the given edge. If it is a graph, takes the difference of the two graphs. Accepts lists of integers or lists of tuples as well, but they can't be mixed! Also accepts Edge and EdgeSeq objects."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "add_edge": {
                    "Description": "Adds a single edge to the graph.\nKeyword arguments (except the source and target arguments) will be assigned to the edge as attributes.\nThe performance cost of adding a single edge or several edges to a graph is similar. Thus, when adding several edges, a single add_edges() call is more efficient than multiple add_edge() calls.",
                    "Paramters": {
                        "graph": "Undocumented",
                        "source": "the  vertex of the edge or its name.",
                        "target": "the  vertex of the edge or its name.",
                        "**kwds": "Undocumented"
                    },
                    "Return": [
                        "the newly added edge as an Edge object. Use add_edges([(source, target)]) if you don't need the Edge object and want to avoid the overhead of creating it."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "add_edges": {
                    "Description": "overrides igraph.GraphBase.add_edges\nAdds some edges to the graph.",
                    "Paramters": {
                        "graph": "Undocumented",
                        "es": "the list of edg to be added. Every edge is reprented with a tuple containing the vertex IDs or nam of the two endpoints. Vertic are enumerated from zero.",
                        "attributes": "dict of sequences, each of length equal to the number of edges to be added, containing the  of the new edges."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "add_vertex": {
                    "Description": "Adds a single vertex to the graph. Keyword arguments will be assigned as vertex attributes. Note that name as a keyword argument is treated specially; if a graph has name as a vertex attribute, it allows one to refer to vertices by their names in most places where igraph expects a vertex ID.",
                    "Paramters": {},
                    "Return": [
                        "the newly added vertex as a Vertex object. Use add_vertices(1) if you don't need the Vertex object and want to avoid the overhead of creating t."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "add_vertices": {
                    "Description": "overrides igraph.GraphBase.add_vertices\nAdds some vertices to the graph.\nNote that if n is a sequence of strings, indicating the names of the new vertices, and attributes has a key name, the two conflict. In that case the attribute will be applied.",
                    "Paramters": {
                        "graph": "Undocumented",
                        "n": "the umber of vertices to be added, or the ame of a sigle vertex to be added, or a sequece of strigs, each correspodig to the ame of a vertex to be added. Names will be assiged to the ame vertex attribute.",
                        "attributes": "dict of sequences, each of length equal to the number of vertices to be added, containing the  of the new vertices. If n is a string (so a single vertex is added), then the values of this dict are the  themselves, but if n=1 then they have to be lists of length 1."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "all_st_cuts": {
                    "Description": "overrides igraph.GraphBase.all_st_cuts\nReturns all the cuts between the source and target vertices in a directed graph.\nThis function lists all edge-cuts between a source and a target vertex. Every cut is listed exactly once.\nReference: JS Provan and DR Shier: A paradigm for listing (s,t)-cuts in graphs. Algorithmica 15, 351-372, 1996.",
                    "Paramters": {
                        "graph": "Undocumented",
                        "source": "the  vertex ID",
                        "target": "the  vertex ID"
                    },
                    "Return": [
                        "a list of Cut objects."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "all_st_mincuts": {
                    "Description": "overrides igraph.GraphBase.all_st_mincuts\nReturns all the mincuts between the source and target vertices in a directed graph.\nThis function lists all minimum edge-cuts between a source and a target vertex.\nReference: JS Provan and DR Shier: A paradigm for listing (s,t)-cuts in graphs. Algorithmica 15, 351-372, 1996.",
                    "Paramters": {
                        "graph": "Undocumented",
                        "source": "the  vertex ID",
                        "target": "the  vertex ID",
                        "capacity": "the edge capacities (weights). If None, all edges have equal weight. May also be an attribute name."
                    },
                    "Return": [
                        "a list of Cut objects."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "as_directed": {
                    "Description": "Returns a directed copy of this graph. Arguments are passed on to GraphBase.to_directed() that is invoked on the copy.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "as_undirected": {
                    "Description": "Returns an undirected copy of this graph. Arguments are passed on to GraphBase.to_undirected() that is invoked on the copy.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "biconnected_components": {
                    "Description": "overrides igraph.GraphBase.biconnected_components\nCalculates the biconnected components of the graph.",
                    "Paramters": {
                        "graph": "Undocumented",
                        "return_articulation_points": "whether to return the articulation points as well"
                    },
                    "Return": [
                        "a VertexCover object describing the biconnected components, and optionally the list of articulation points as well"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "bipartite_projection": {
                    "Description": "overrides igraph.GraphBase.bipartite_projection\nProjects a bipartite graph into two one-mode graphs. Edge directions are ignored while projecting.\nExamples:",
                    "Paramters": {
                        "graph": "Undocumented",
                        "types": "an igraph vector containing the vertex , or an attribute name. Anything that evalulates to False corresponds to vertices of the first kind, everything else to the second kind.",
                        "multiplicity": "if True, then igraph keeps the  of the edges in the projection in an edge attribute called \"weight\". E.g., if there is an A-C-B and an A-D-B triplet in the bipartite graph and there is no other X (apart from X=B and X=D) for which an A-X-B triplet would exist in the bipartite graph, the  of the A-B edge in the projection will be 2.",
                        "probe1": "this argument can be used to specify the order of the projections in the resulting list. If given and non-negative, then it is considered as a vertex ID; the projection containing the vertex will be the first one in the result.",
                        "which": "this argument can be used to specify  of the two projections should be returned if only one of them is needed. Passing 0 here means that only the first projection is returned, while 1 means that only the second projection is returned. (Note that we use 0 and 1 because Python indexing is zero-based). False is equivalent to 0 and True is equivalent to 1. Any other value means that both projections will be returned in a tuple."
                    },
                    "Return": [
                        "a tuple containing the two projected one-mode graphs if which is not 1 or 2, or the projected one-mode graph specified by the which argument if its value is 0, 1, False or True."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": [
                        "Examples:\n>>> g = Graph.Full_Bipartite(10, 5)\n>>> g1, g2 = g.bipartite_projection()\n>>> g1.isomorphic(Graph.Full(10))\nTrue\n>>> g2.isomorphic(Graph.Full(5))\nTrue\n"
                    ]
                },
                "bipartite_projection_size": {
                    "Description": "overrides igraph.GraphBase.bipartite_projection_size\nCalculates the number of vertices and edges in the bipartite projections of this graph according to the specified vertex types. This is useful if you have a bipartite graph and you want to estimate the amount of memory you would need to calculate the projections themselves.",
                    "Paramters": {
                        "graph": "Undocumented",
                        "types": "an igraph vector containing the vertex , or an attribute name. Anything that evalulates to False corresponds to vertices of the first kind, everything else to the second kind.",
                        "*args": "Undocumented",
                        "**kwds": "Undocumented"
                    },
                    "Return": [
                        "a 4-tuple containing the number of vertices and edges in the first projection, followed by the number of vertices and edges in the second projection."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "blocks": {
                    "Description": "Calculates the biconnected components of the graph.",
                    "Paramters": {
                        "graph": "Undocumented",
                        "return_articulation_points": "whether to return the articulation points as well"
                    },
                    "Return": [
                        "a VertexCover object describing the biconnected components, and optionally the list of articulation points as well"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "clear": {
                    "Description": "Clears the graph, deleting all vertices, edges, and attributes.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "GraphBase.delete_vertices and Graph.delete_edges.",
                    "example": []
                },
                "clusters": {
                    "Description": "Deprecated alias to Graph.connected_components().",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "cohesive_blocks": {
                    "Description": "overrides igraph.GraphBase.cohesive_blocks\nCalculates the cohesive block structure of the graph.\nCohesive blocking is a method of determining hierarchical subsets of graph vertices based on their structural cohesion (i.e. vertex connectivity). For a given graph G, a subset of its vertices S is said to be maximally k-cohesive if there is no superset of S with vertex connectivity greater than or equal to k. Cohesive blocking is a process through which, given a k-cohesive set of vertices, maximally l-cohesive subsets are recursively identified with l > k. Thus a hierarchy of vertex subsets is obtained in the end, with the entire graph G at its root.",
                    "Paramters": {},
                    "Return": [
                        "an instance of CohesiveBlocks. See the documentation of CohesiveBlocks for more information."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "CohesiveBlocks",
                    "example": []
                },
                "community_edge_betweenness": {
                    "Description": "overrides igraph.GraphBase.community_edge_betweenness\nCommunity structure based on the betweenness of the edges in the network.\nThe idea is that the betweenness of the edges connecting two communities is typically high, as many of the shortest paths between nodes in separate communities go through them. So we gradually remove the edge with the highest betweenness and recalculate the betweennesses after every removal. This way sooner or later the network falls of to separate components. The result of the clustering will be represented by a dendrogram.",
                    "Paramters": {
                        "graph": "Undocumented",
                        "clusters": "the number of  we would like to see. This practically defines the \"level\" where we \"cut\" the dendrogram to get the membership vector of the vertices. If None, the dendrogram is cut at the level that maximizes the modularity when the graph is unweighted; otherwise the dendrogram is cut at at a single cluster (because cluster count selection based on modularities does not make sense for this method if not all the weights are equal).",
                        "directed": "whether the directionality of the edges should be taken into account or not.",
                        "weights": "name of an edge attribute or a list containing edge ."
                    },
                    "Return": [
                        "a VertexDendrogram object, initally cut at the maximum modularity or at the desired number of clusters."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "community_fastgreedy": {
                    "Description": "overrides igraph.GraphBase.community_fastgreedy\nCommunity structure based on the greedy optimization of modularity.\nThis algorithm merges individual nodes into communities in a way that greedily maximizes the modularity score of the graph. It can be proven that if no merge can increase the current modularity score, the algorithm can be stopped since no further increase can be achieved.\nThis algorithm is said to run almost in linear time on sparse graphs.\nReference: A Clauset, MEJ Newman and C Moore: Finding community structure in very large networks. Phys Rev E 70, 066111 (2004).",
                    "Paramters": {
                        "graph": "Undocumented",
                        "weights": "edge attribute name or a list containing edge "
                    },
                    "Return": [
                        "an appropriate VertexDendrogram object."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "community_infomap": {
                    "Description": "overrides igraph.GraphBase.community_infomap\nFinds the community structure of the network according to the Infomap method of Martin Rosvall and Carl T. Bergstrom.\n",
                    "Paramters": {
                        "graph": "Undocumented",
                        "edge_weights": "name of an edge attribute or a list containing edge weights.",
                        "vertex_weights": "name of a vertex attribute or a list containing vertex weights.",
                        "trials": "the number of attempts to partition the network."
                    },
                    "Return": [
                        "an appropriate VertexClustering object with an extra attribute called codelength that stores the code length determined by the algorithm."
                    ],
                    "References": [
                        "M. Rosvall and C. T. Bergstrom: Maps of information flow reveal community structure in complex networks, PNAS 105, 1118 (2008). http://dx.doi.org/10.1073/pnas.0706851105, http://arxiv.org/abs/0707.0609.M. Rosvall, D. Axelsson, and C. T. Bergstrom: The map equation, Eur Phys. J Special Topics 178, 13 (2009). http://dx.doi.org/10.1140/epjst/e2010-01179-1, http://arxiv.org/abs/0906.1405."
                    ],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "community_label_propagation": {
                    "Description": "overrides igraph.GraphBase.community_label_propagation\nFinds the community structure of the graph according to the label propagation method of Raghavan et al.\nInitially, each vertex is assigned a different label. After that, each vertex chooses the dominant label in its neighbourhood in each iteration. Ties are broken randomly and the order in which the vertices are updated is randomized before every iteration. The algorithm ends when vertices reach a consensus.\nNote that since ties are broken randomly, there is no guarantee that the algorithm returns the same community structure after each run. In fact, they frequently differ. See the paper of Raghavan et al. on how to come up with an aggregated community structure.\nAlso note that the community _labels_ (numbers) have no semantic meaning and igraph is free to re-number communities. If you use fixed labels, igraph may still re-number the communities, but co-community membership constraints will be respected: if you had two vertices with fixed labels that belonged to the same community, they will still be in the same community at the end. Similarly, if you had two vertices with fixed labels that belonged to different communities, they will still be in different communities at the end.\nReference: Raghavan, U.N. and Albert, R. and Kumara, S. Near linear time algorithm to detect community structures in large-scale networks. Phys Rev E 76:036106, 2007. http://arxiv.org/abs/0709.2938.",
                    "Paramters": {
                        "graph": "Undocumented",
                        "weights": "name of an edge attribute or a list containing edge ",
                        "initial": "name of a vertex attribute or a list containing the  vertex labels. Labels are identified by integers from zero to n\u2009\u2212\u20091 where n is the number of vertices. Negative numbers may also be present in this vector, they represent unlabeled vertices.",
                        "fixed": "a list of booleans for each vertex. True corresponds to vertices whose labeling should not change during the algorithm. It only makes sense if initial labels are also given. Unlabeled vertices cannot be . It may also be the name of a vertex attribute; each attribute value will be interpreted as a Boolean."
                    },
                    "Return": [
                        "an appropriate VertexClustering object."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "community_leading_eigenvector": {
                    "Description": "overrides igraph.GraphBase.community_leading_eigenvector\nNewman's leading eigenvector method for detecting community structure.\nThis is the proper implementation of the recursive, divisive algorithm: each split is done by maximizing the modularity regarding the original network.\nReference: MEJ Newman: Finding community structure in networks using the eigenvectors of matrices, arXiv:physics/0605087",
                    "Paramters": {
                        "graph": "Undocumented",
                        "clusters": "the desired number of communities. If None, the algorithm tries to do as many splits as possible. Note that the algorithm won't split a community further if the signs of the leading eigenvector are all the same, so the actual number of discovered communities can be less than the desired one.",
                        "weights": "name of an edge attribute or a list containing edge .",
                        "arpack_options": "an ARPACKOptions object used to fine-tune the ARPACK eigenvector calculation. If omitted, the module-level variable called  is used."
                    },
                    "Return": [
                        "an appropriate VertexClustering object."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "community_leiden": {
                    "Description": "overrides igraph.GraphBase.community_leiden\nFinds the community structure of the graph using the Leiden algorithm of Traag, van Eck & Waltman.\nReference: Traag, V. A., Waltman, L., & van Eck, N. J. (2019). From Louvain to Leiden: guaranteeing well-connected communities. Scientific Reports, 9(1), 5233. doi: 10.1038/s41598-019-41695-z",
                    "Paramters": {
                        "graph": "Undocumented",
                        "objective_function": "whether to use the Constant Potts Model (CPM) or modularity. Must be either \"CPM\" or \"modularity\".",
                        "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name.",
                        "resolution": "the  parameter to use. Higher s lead to more smaller communities, while lower s lead to fewer larger communities.",
                        "beta": "parameter affecting the randomness in the Leiden algorithm. This affects only the refinement step of the algorithm.",
                        "initial_membership": "if provided, the Leiden algorithm will try to improve this provided membership. If no argument is provided, the aglorithm simply starts from the singleton partition.",
                        "n_iterations": "the number of iterations to iterate the Leiden algorithm. Each iteration may improve the partition further. Using a negative number of iterations will run until a stable iteration is encountered (i.e. the quality was not increased during that iteration).",
                        "node_weights": "the node weights used in the Leiden algorithm. If this is not provided, it will be automatically determined on the basis of whether you want to use CPM or modularity. If you do provide this, please make sure that you understand what you are doing.",
                        "**kwds": "Undocumented"
                    },
                    "Return": [
                        "an appropriate VertexClustering object with an extra attribute called quality that stores the value of the internal quality function optimized by the algorithm."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "community_multilevel": {
                    "Description": "overrides igraph.GraphBase.community_multilevel\nCommunity structure based on the multilevel algorithm of Blondel et al.\nThis is a bottom-up algorithm: initially every vertex belongs to a separate community, and vertices are moved between communities iteratively in a way that maximizes the vertices' local contribution to the overall modularity score. When a consensus is reached (i.e. no single move would increase the modularity score), every community in the original graph is shrunk to a single vertex (while keeping the total weight of the incident edges) and the process continues on the next level. The algorithm stops when it is not possible to increase the modularity anymore after shrinking the communities to vertices.\nThis algorithm is said to run almost in linear time on sparse graphs.\nReference: VD Blondel, J-L Guillaume, R Lambiotte and E Lefebvre: Fast unfolding of community hierarchies in large networks, J Stat Mech P10008 (2008). http://arxiv.org/abs/0803.0476",
                    "Paramters": {
                        "graph": "Undocumented",
                        "weights": "edge attribute name or a list containing edge ",
                        "return_levels": "if True, the communities at each level are returned in a list. If False, only the community structure with the best modularity is returned.",
                        "resolution": "the  parameter to use in the modularity measure. Smaller values result in a smaller number of larger clusters, while higher values yield a large number of small clusters. The classical modularity measure assumes a  parameter of 1."
                    },
                    "Return": [
                        "a list of VertexClustering objects, one corresponding to each level (if return_levels is True), or a VertexClustering corresponding to the best modularity."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "community_optimal_modularity": {
                    "Description": "overrides igraph.GraphBase.community_optimal_modularity\nCalculates the optimal modularity score of the graph and the corresponding community structure.\nThis function uses the GNU Linear Programming Kit to solve a large integer optimization problem in order to find the optimal modularity score and the corresponding community structure, therefore it is unlikely to work for graphs larger than a few (less than a hundred) vertices. Consider using one of the heuristic approaches instead if you have such a large graph.",
                    "Paramters": {},
                    "Return": [
                        "the calculated membership vector and the corresponding modularity in a tuple."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "community_spinglass": {
                    "Description": "overrides igraph.GraphBase.community_spinglass\nFinds the community structure of the graph according to the spinglass community detection method of Reichardt & Bornholdt.\n",
                    "Paramters": {
                        "graph": "Undocumented",
                        "*args": "Undocumented",
                        "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name.",
                        "spins": "integer, the number of  to use. This is the upper limit for the number of communities. It is not a problem to supply a (reasonably) big number here, in which case some spin states will be unpopulated.",
                        "parupdate": "whether to update the spins of the vertices in parallel (synchronously) or not",
                        "start_temp": "the starting temperature",
                        "stop_temp": "the stop temperature",
                        "cool_fact": "cooling factor for the simulated annealing",
                        "update_rule": "specifies the null model of the simulation. Possible values are \"config\" (a random graph with the same vertex degrees as the input graph) or \"simple\" (a random graph with the same number of edges)",
                        "gamma": "the  argument of the algorithm, specifying the balance between the importance of present and missing edges within a community. The default value of 1.0 assigns equal importance to both of them.",
                        "implementation": "currently igraph contains two s of the spinglass community detection algorithm. The faster original  is the default. The other  is able to take into account negative weights, this can be chosen by setting  to \"neg\"",
                        "lambda_": "the lambda argument of the algorithm, which specifies the balance between the importance of present and missing negatively weighted edges within a community. Smaller values of lambda lead to communities with less negative intra-connectivity. If the argument is zero, the algorithm reduces to a graph coloring algorithm, using the number of spins as colors. This argument is ignored if the original implementation is used. Note the underscore at the end of the argument name; this is due to the fact that lambda is a reserved keyword in Python."
                    },
                    "Return": [
                        "an appropriate VertexClustering object."
                    ],
                    "References": [
                        "Reichardt J and Bornholdt S: Statistical mechanics of community detection. Phys Rev E 74:016110 (2006). http://arxiv.org/abs/cond-mat/0603718.Traag VA and Bruggeman J: Community detection in networks with positive and negative links. Phys Rev E 80:036115 (2009). http://arxiv.org/abs/0811.2329."
                    ],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "community_walktrap": {
                    "Description": "overrides igraph.GraphBase.community_walktrap\nCommunity detection algorithm of Latapy & Pons, based on random walks.\nThe basic idea of the algorithm is that short random walks tend to stay in the same community. The result of the clustering will be represented as a dendrogram.\nReference: Pascal Pons, Matthieu Latapy: Computing communities in large networks using random walks, http://arxiv.org/abs/physics/0512106.",
                    "Paramters": {
                        "graph": "Undocumented",
                        "weights": "name of an edge attribute or a list containing edge ",
                        "steps": "length of random walks to perform"
                    },
                    "Return": [
                        "a VertexDendrogram object, initially cut at the maximum modularity."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "components": {
                    "Description": "Calculates the (strong or weak) connected components for a given graph.",
                    "Paramters": {
                        "graph": "Undocumented",
                        "mode": "must be either \"strong\" or \"weak\", depending on the connected components being sought. Optional, defaults to \"strong\"."
                    },
                    "Return": [
                        "a VertexClustering object"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "connected_components": {
                    "Description": "overrides igraph.GraphBase.connected_components\nCalculates the (strong or weak) connected components for a given graph.",
                    "Paramters": {
                        "graph": "Undocumented",
                        "mode": "must be either \"strong\" or \"weak\", depending on the connected components being sought. Optional, defaults to \"strong\"."
                    },
                    "Return": [
                        "a VertexClustering object"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "count_automorphisms_vf2": {
                    "Description": "Returns the number of automorphisms of the graph.\nThis function simply calls count_isomorphisms_vf2 with the graph itgraph. See count_isomorphisms_vf2 for an explanation of the parameters.",
                    "Paramters": {},
                    "Return": [
                        "the number of automorphisms of the graph"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "Graph.count_isomorphisms_vf2",
                    "example": []
                },
                "degree_distribution": {
                    "Description": "Calculates the degree distribution of the graph.\nUnknown keyword arguments are directly passed to GraphBase.degree.",
                    "Paramters": {
                        "graph": "Undocumented",
                        "bin_width": "the bin width of the histogram",
                        "*args": "Undocumented",
                        "**kwds": "Undocumented"
                    },
                    "Return": [
                        "a histogram representing the degree distribution of the graph."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "delete_edges": {
                    "Description": "overrides igraph.GraphBase.delete_edges\nDeletes some edges from the graph.\nThe set of edges to be deleted is determined by the positional and keyword arguments. If the function is called without any arguments, all edges are deleted. If any keyword argument is present, or the first positional argument is callable, an edge sequence is derived by calling EdgeSeq.select with the same positional and keyword arguments. Edges in the derived edge sequence will be removed. Otherwise, the first positional argument is considered as follows:\nDeprecation notice: delete_edges(None) has been replaced by delete_edges() - with no arguments - since igraph 0.8.3.None - deletes all edges (deprecated since 0.8.3)a single integer - deletes the edge with the given IDa list of integers - deletes the edges denoted by the given IDsa list of 2-tuples - deletes the edges denoted by the given source-target vertex pairs. When multiple edges are present between a given source-target vertex pair, only one is removed.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "dfs": {
                    "Description": "Conducts a depth first search (DFS) on the graph.",
                    "Paramters": {
                        "vid": "the root vertex ID",
                        "mode": "either \"in\" or \"out\" or \"all\", ignored for undirected graphs."
                    },
                    "Return": [
                        "a tuple with the following items:\n\nThe vertex IDs visited (in order)\nThe parent of every vertex in the DFS\n\n"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "disjoint_union": {
                    "Description": "Creates the disjoint union of two (or more) graphs.",
                    "Paramters": {
                        "graph": "Undocumented",
                        "other": "graph or list of graphs to be united with the current one."
                    },
                    "Return": [
                        "the disjoint union graph"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "dyad_census": {
                    "Description": "overrides igraph.GraphBase.dyad_census\nCalculates the dyad census of the graph.\nDyad census means classifying each pair of vertices of a directed graph into three categories: mutual (there is an edge from a to b and also from b to a), asymmetric (there is an edge from a to b or from b to a but not the other way round) and null (there is no connection between a and b).\nReference: Holland, P.W. and Leinhardt, S. A Method for Detecting Structure in Sociometric Data. American Journal of Sociology, 70, 492-513, 1970.",
                    "Paramters": {},
                    "Return": [
                        "a DyadCensus object."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_adjacency": {
                    "Description": "overrides igraph.GraphBase.get_adjacency\nReturns the adjacency matrix of a graph.",
                    "Paramters": {
                        "type": "either GET_ADJACENCY_LOWER (uses the lower triangle of the matrix) or GET_ADJACENCY_UPPER (uses the upper triangle) or GET_ADJACENCY_BOTH (uses both parts). Ignored for directed graphs.",
                        "attribute": "if None, returns the ordinary adjacency matrix. When the name of a valid edge  is given here, the matrix returned will contain the default value at the places where there is no edge or the value of the given  where there is an edge. Multiple edges are not supported, the value written in the matrix in this case will be unpredictable. This parameter is ignored if eids is True",
                        "default": "the  value written to the cells in the case of adjacency matrices with attributes.",
                        "eids": "specifies whether the edge IDs should be returned in the adjacency matrix. Since zero is a valid edge ID, the cells in the matrix that correspond to unconnected vertex pairs will contain -1 instead of 0 if  is True. If  is False, the number of edges will be returned in the matrix for each vertex pair."
                    },
                    "Return": [
                        "the adjacency matrix as a Matrix."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_adjacency_sparse": {
                    "Description": "Returns the adjacency matrix of a graph as a SciPy CSR matrix.",
                    "Paramters": {
                        "attribute": "if None, returns the ordinary adjacency matrix. When the name of a valid edge  is given here, the matrix returned will contain the default value at the places where there is no edge or the value of the given  where there is an edge."
                    },
                    "Return": [
                        "the adjacency matrix as a scipy.sparse.csr_matrix."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_adjlist": {
                    "Description": "Returns the adjacency list representation of the graph.\nThe adjacency list representation is a list of lists. Each item of the outer list belongs to a single vertex of the graph. The inner list contains the neighbors of the given vertex.",
                    "Paramters": {
                        "mode": "if \"out\", returns the successors of the vertex. If \"in\", returns the predecessors of the vertex. If \"all\", both the predecessors and the successors will be returned. Ignored for undirected graphs."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_all_simple_paths": {
                    "Description": "Calculates all the simple paths from a given node to some other nodes (or all of them) in a graph.\nA path is simple if its vertices are unique, i.e. no vertex is visited more than once.\nNote that potentially there are exponentially many paths between two vertices of a graph, especially if your graph is lattice-like. In this case, you may run out of memory when using this function.",
                    "Paramters": {
                        "v": "the source for the calculated paths",
                        "to": "a vertex selecr describing the destination for the calculated paths. This can be a single vertex ID, a list of vertex IDs, a single vertex name, a list of vertex names or a VertexSeq object. None means all the vertices.",
                        "cutoff": "maximum length of path that is considered. If negative, paths of all lengths are considered.",
                        "mode": "the directionality of the paths. \"in\" means to calculate incoming paths, \"out\" means to calculate outgoing paths, \"all\" means to calculate both ones."
                    },
                    "Return": [
                        "all of the simple paths from the given node to every other reachable node in the graph in a list. Note that in case of mode=\"in\", the vertices in a path are returned in reversed order!"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_automorphisms_vf2": {
                    "Description": "Returns all the automorphisms of the graph\nThis function simply calls get_isomorphisms_vf2 with the graph itgraph. See get_isomorphisms_vf2 for an explanation of the parameters.",
                    "Paramters": {},
                    "Return": [
                        "a list of lists, each item containing a possible mapping of the graph vertices to itgraph according to the automorphism"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "Graph.get_isomorphisms_vf2",
                    "example": []
                },
                "get_biadjacency": {
                    "Description": "overrides igraph.GraphBase.get_biadjacency\nReturns the bipartite adjacency matrix of a bipartite graph. The bipartite adjacency matrix is an n times m matrix, where n and m are the number of vertices in the two vertex classes.",
                    "Paramters": {
                        "graph": "Undocumented",
                        "types": "an igraph vector containing the vertex , or an attribute name. Anything that evalulates to False corresponds to vertices of the first kind, everything else to the second kind.",
                        "*args": "Undocumented",
                        "**kwds": "Undocumented"
                    },
                    "Return": [
                        "the bipartite adjacency matrix and two lists in a triplet. The first list defines the mapping between row indices of the matrix and the original vertex IDs. The second list is the same for the column indices."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_edge_dataframe": {
                    "Description": "Export edges with attributes to pandas.DataFrame\nIf you want to use source and target vertex IDs as index, you can do:",
                    "Paramters": {},
                    "Return": [
                        "a pandas.DataFrame representing edges and their attributes. The index uses edge IDs, from 0 to M - 1 where M is the number of edges. The first two columns of the dataframe represent the IDs of source and target vertices for each edge. These columns have names \"source\" and \"target\". If your edges have attributes with the same names, they will be present in the dataframe, but not in the first two columns."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": [
                        "If you want to use source and target vertex IDs as index, you can do:\n>>> from string import ascii_letters\n>>> graph = Graph.GRG(25, 0.4)\n>>> graph.vs[\"name\"] = ascii_letters[:graph.vcount()]\n>>> df = graph.get_edge_dataframe()\n>>> df.set_index(['source', 'target'], inplace=True)",
                        "If you want to use vertex names in the source and target columns:\n>>> from string import ascii_letters\n>>> graph = Graph.GRG(25, 0.4)\n>>> graph.vs[\"name\"] = ascii_letters[:graph.vcount()]\n>>> df = graph.get_edge_dataframe()\n>>> df.set_index(['source', 'target'], inplace=True)"
                    ]
                },
                "get_incidence": {
                    "Description": "Deprecated alias to Graph.get_biadjacency().",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_inclist": {
                    "Description": "Returns the incidence list representation of the graph.\nThe incidence list representation is a list of lists. Each item of the outer list belongs to a single vertex of the graph. The inner list contains the IDs of the incident edges of the given vertex.",
                    "Paramters": {
                        "graph": "Undocumented",
                        "mode": "if \"out\", returns the successors of the vertex. If \"in\", returns the predecessors of the vertex. If \"all\", both the predecessors and the successors will be returned. Ignored for undirected graphs."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_vertex_dataframe": {
                    "Description": "Export vertices with attributes to pandas.DataFrame\nIf you want to use vertex names as index, you can do:",
                    "Paramters": {},
                    "Return": [
                        "a pandas.DataFrame representing vertices and their attributes. The index uses vertex IDs, from 0 to N - 1 where N is the number of vertices."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": [
                        "If you want to use vertex names as index, you can do:\n>>> from string import ascii_letters\n>>> graph = Graph.GRG(25, 0.4)\n>>> graph.vs[\"name\"] = ascii_letters[:graph.vcount()]\n>>> df = graph.get_vertex_dataframe()\n>>> df.set_index('name', inplace=True)"
                    ]
                },
                "gomory_hu_tree": {
                    "Description": "overrides igraph.GraphBase.gomory_hu_tree\nCalculates the Gomory-Hu tree of an undirected graph with optional edge capacities.\nThe Gomory-Hu tree is a concise representation of the value of all the maximum flows (or minimum cuts) in a graph. The vertices of the tree correspond exactly to the vertices of the original graph in the same order. Edges of the Gomory-Hu tree are annotated by flow values.  The value of the maximum flow (or minimum cut) between an arbitrary (u,v) vertex pair in the original graph is then given by the minimum flow value (i.e. edge annotation) along the shortest path between u and v in the Gomory-Hu tree.",
                    "Paramters": {
                        "graph": "Undocumented",
                        "capacity": "the edge capacities (weights). If None, all edges have equal weight. May also be an attribute name.",
                        "flow": "the name of the edge attribute in the returned graph in which the  values will be stored."
                    },
                    "Return": [
                        "the Gomory-Hu tree as a Graph object."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "indegree": {
                    "Description": "Returns the in-degrees in a list.\nSee GraphBase.degree for possible arguments.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "intersection": {
                    "Description": "Creates the intersection of two (or more) graphs.",
                    "Paramters": {
                        "graph": "Undocumented",
                        "other": "graph or list of graphs to be intersected with the current one.",
                        "byname": "whether to use vertex names instead of ids. See igraph.operators.intersection for details."
                    },
                    "Return": [
                        "the intersection graph"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "is_named": {
                    "Description": "Returns whether the graph is named.\nA graph is named if and only if it has a \"name\" vertex attribute.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "is_weighted": {
                    "Description": "Returns whether the graph is weighted.\nA graph is weighted if and only if it has a \"weight\" edge attribute.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "k_core": {
                    "Description": "Returns some k-cores of the graph.\nThe method accepts an arbitrary number of arguments representing the desired indices of the k-cores to be returned. The arguments can also be lists or tuples. The result is a single Graph object if an only integer argument was given, otherwise the result is a list of Graph objects representing the desired k-cores in the order the arguments were specified. If no argument is given, returns all k-cores in increasing order of k.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "layout": {
                    "Description": "Returns the layout of the graph according to a layout algorithm.\nParameters and keyword arguments not specified here are passed to the layout algorithm directly. See the documentation of the layout algorithms for the explanation of these parameters.\nRegistered layout names understood by this method are:auto, automatic: automatic layout (see Graph.layout_auto)bipartite: bipartite layout (see GraphBase.layout_bipartite)circle, circular: circular layout (see GraphBase.layout_circle)dh, davidson_harel: Davidson-Harel layout (see GraphBase.layout_davidson_harel)drl: DrL layout for large graphs (see GraphBase.layout_drl)drl_3d: 3D DrL layout for large graphs (see GraphBase.layout_drl)fr, fruchterman_reingold: Fruchterman-Reingold layout (see GraphBase.layout_fruchterman_reingold).fr_3d, fr3d, fruchterman_reingold_3d: 3D Fruchterman- Reingold layout (see GraphBase.layout_fruchterman_reingold).grid: regular grid layout in 2D (see GraphBase.layout_grid)grid_3d: regular grid layout in 3D (see GraphBase.layout_grid)graphopt: the graphopt algorithm (see GraphBase.layout_graphopt)kk, kamada_kawai: Kamada-Kawai layout (see GraphBase.layout_kamada_kawai)kk_3d, kk3d, kamada_kawai_3d: 3D Kamada-Kawai layout (see GraphBase.layout_kamada_kawai)lgl, large, large_graph: Large Graph Layout (see GraphBase.layout_lgl)mds: multidimensional scaling layout (see GraphBase.layout_mds)random: random layout (see GraphBase.layout_random)random_3d: random 3D layout (see GraphBase.layout_random)rt, tree, reingold_tilford: Reingold-Tilford tree layout (see GraphBase.layout_reingold_tilford)rt_circular, reingold_tilford_circular: circular Reingold-Tilford tree layout (see GraphBase.layout_reingold_tilford_circular)sphere, spherical, circle_3d, circular_3d: spherical layout (see GraphBase.layout_circle)star: star layout (see GraphBase.layout_star)sugiyama: Sugiyama layout (see Graph.layout_sugiyama)",
                    "Paramters": {
                        "graph": "Undocumented",
                        "layout": "the  to use. This can be one of the registered  names or a callable which returns either a Layout object or a list of lists containing the coordinates. If None, uses the value of the plotting. configuration key.",
                        "*args": "Undocumented",
                        "**kwds": "Undocumented"
                    },
                    "Return": [
                        "a Layout object."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "layout_auto": {
                    "Description": "Chooses and runs a suitable layout function based on simple topological properties of the graph.\nThis function tries to choose an appropriate layout function for the graph using the following rules:If the graph has an attribute called layout, it will be used. It may either be a Layout instance, a list of coordinate pairs, the name of a layout function, or a callable function which generates the layout when called with the graph as a parameter.Otherwise, if the graph has vertex attributes called x and y, these will be used as coordinates in the layout. When a 3D layout is requested (by setting dim to 3), a vertex attribute named z will also be needed.Otherwise, if the graph is connected and has at most 100 vertices, the Kamada-Kawai layout will be used (see GraphBase.layout_kamada_kawai()).Otherwise, if the graph has at most 1000 vertices, the Fruchterman-Reingold layout will be used (see GraphBase.layout_fruchterman_reingold()).If everything else above failed, the DrL layout algorithm will be used (see GraphBase.layout_drl()).\nAll the arguments of this function except dim are passed on to the chosen layout function (in case we have to call some layout function).",
                    "Paramters": {
                        "graph": "Undocumented",
                        "*args": "Undocumented",
                        "dim": "specifies whether we would like to obtain a 2D or a 3D layout."
                    },
                    "Return": [
                        "a Layout object."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "layout_sugiyama": {
                    "Description": "Places the vertices using a layered Sugiyama layout.\nThis is a layered layout that is most suitable for directed acyclic graphs, although it works on undirected or cyclic graphs as well.\nEach vertex is assigned to a layer and each layer is placed on a horizontal line. Vertices within the same layer are then permuted using the barycenter heuristic that tries to minimize edge crossings.\nDummy vertices will be added on edges that span more than one layer. The returned layout therefore contains more rows than the number of nodes in the original graph; the extra rows correspond to the dummy vertices.\n",
                    "Paramters": {
                        "graph": "Undocumented",
                        "layers": "a vector specifying a non-negative integer layer index for each vertex, or the name of a numeric vertex attribute that contains the layer indices. If None, a layering will be determined automatically. For undirected graphs, a spanning tree will be extracted and vertices will be assigned to  using a breadth first search from the node with the largest degree. For directed graphs, cycles are broken by reversing the direction of edges in an approximate feedback arc set using the heuristic of Eades, Lin and Smyth, and then using longest path layering to place the vertices in .",
                        "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name.",
                        "hgap": "minimum horizontal gap between vertices in the same layer.",
                        "vgap": "vertical gap between layers. The layer index will be multiplied by  to obtain the Y coordinate.",
                        "maxiter": "maximum number of iterations to take in the crossing reduction step. Increase this if you feel that you are getting too many edge crossings.",
                        "return_extended_graph": "specifies that the extended graph with the added dummy vertices should also be returned. When this is True, the result will be a tuple containing the layout and the extended graph. The first |V| nodes of the extended graph will correspond to the nodes of the original graph, the remaining ones are dummy nodes. Plotting the extended graph with the returned layout and hidden dummy nodes will produce a layout that is similar to the original graph, but with the added edge bends. The extended graph also contains an edge attribute called _original_eid which specifies the ID of the edge in the original graph from which the edge of the extended graph was created."
                    },
                    "Return": [
                        "the calculated layout, which may (and usually will) have more rows than the number of vertices; the remaining rows correspond to the dummy nodes introduced in the layering step. When return_extended_graph is True, it will also contain the extended graph."
                    ],
                    "References": [
                        ":K Sugiyama, S Tagawa, M Toda: Methods for visual understanding of hierarchical system structures. IEEE Systems, Man and Cybernetics 11(2):109-125, 1981.P Eades, X Lin and WF Smyth: A fast effective heuristic for the feedback arc set problem. Information Processing Letters 47:319-323, 1993."
                    ],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "maxflow": {
                    "Description": "overrides igraph.GraphBase.maxflow\nReturns a maximum flow between the given source and target vertices in a graph.\nA maximum flow from source to target is an assignment of non-negative real numbers to the edges of the graph, satisfying two properties:For each edge, the flow (i.e. the assigned number) is not more than the capacity of the edge (see the capacity argument)For every vertex except the source and the target, the incoming flow is the same as the outgoing flow.\nThe value of the flow is the incoming flow of the target or the outgoing flow of the source (which are equal). The maximum flow is the maximum possible such value.",
                    "Paramters": {
                        "graph": "Undocumented",
                        "source": "Undocumented",
                        "target": "Undocumented",
                        "capacity": "the edge capacities (weights). If None, all edges have equal weight. May also be an attribute name."
                    },
                    "Return": [
                        "a Flow object describing the maximum flow"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "maximum_bipartite_matching": {
                    "Description": "Finds a maximum matching in a bipartite graph.\nA maximum matching is a set of edges such that each vertex is incident on at most one matched edge and the number (or weight) of such edges in the set is as large as possible.",
                    "Paramters": {
                        "graph": "Undocumented",
                        "types": "vertex  in a list or the name of a vertex attribute holding vertex . Types should be denoted by zeros and ones (or False and True) for the two sides of the bipartite graph. If omitted, it defaults to type, which is the default vertex type attribute for bipartite graphs.",
                        "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name.",
                        "eps": "a small real number used in equality tests in the weighted bipartite matching algorithm. Two real numbers are considered equal in the algorithm if their difference is smaller than this value. This is required to avoid the accumulation of numerical errors. If you pass None here, igraph will try to determine an appropriate value automatically."
                    },
                    "Return": [
                        "an instance of Matching."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "mincut": {
                    "Description": "overrides igraph.GraphBase.mincut\nCalculates the minimum cut between the given source and target vertices or within the whole graph.\nThe minimum cut is the minimum set of edges that needs to be removed to separate the source and the target (if they are given) or to disconnect the graph (if neither the source nor the target are given). The minimum is calculated using the weights (capacities) of the edges, so the cut with the minimum total capacity is calculated.\nFor undirected graphs and no source and target, the method uses the Stoer-Wagner algorithm. For a given source and target, the method uses the push-relabel algorithm; see the references below.",
                    "Paramters": {
                        "graph": "Undocumented",
                        "source": "the  vertex ID. If None, the target must also be None and the calculation will be done for the entire graph (i.e. all possible vertex pairs).",
                        "target": "the  vertex ID. If None, the source must also be None and the calculation will be done for the entire graph (i.e. all possible vertex pairs).",
                        "capacity": "the edge capacities (weights). If None, all edges have equal weight. May also be an attribute name."
                    },
                    "Return": [
                        "a Cut object describing the minimum cut"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "modularity": {
                    "Description": "overrides igraph.GraphBase.modularity\nCalculates the modularity score of the graph with respect to a given clustering.\nThe modularity of a graph w.r.t. some division measures how good the division is, or how separated are the different vertex types from each other. It's defined as Q\u2009=\u20091\u2009\u2044\u2009(2m)*sum(Aij\u2009\u2212\u2009gamma*ki*kj\u2009\u2044\u2009(2m)delta(ci,\u2009cj),\u2009i,\u2009j). m is the number of edges, Aij is the element of the A adjacency matrix in row i and column j, ki is the degree of node i, kj is the degree of node j, and Ci and cj are the types of the two vertices (i and j), and gamma is a resolution parameter that defaults to 1 for the classical definition of modularity. delta(x,\u2009y) is one iff x\u2009=\u2009y, 0 otherwise.\nIf edge weights are given, the definition of modularity is modified as follows: Aij becomes the weight of the corresponding edge, ki is the total weight of edges adjacent to vertex i, kj is the total weight of edges adjacent to vertex j and m is the total edge weight in the graph.\nReference: MEJ Newman and M Girvan: Finding and evaluating community structure in networks. Phys Rev E 69 026113, 2004.",
                    "Paramters": {
                        "membership": "a  list or a VertexClustering object",
                        "weights": "optional edge  or None if all edges are weighed equally. Attribute names are also allowed.",
                        "resolution": "the  parameter gamma in the formula above. The classical definition of modularity is retrieved when the  parameter is set to 1.",
                        "directed": "whether to consider edge directions if the graph is . True will use the  variant of the modularity measure where the in- and out-degrees of nodes are treated separately; False will treat  graphs as un."
                    },
                    "Return": [
                        "the modularity score"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "outdegree": {
                    "Description": "Returns the out-degrees in a list.\nSee GraphBase.degree for possible arguments.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "pagerank": {
                    "Description": "Calculates the PageRank values of a graph.",
                    "Paramters": {
                        "graph": "Undocumented",
                        "vertices": "the indices of the  being queried. None means all of the .",
                        "directed": "whether to consider  paths.",
                        "damping": "the  factor. 1\u2009\u2212\u2009 is the probability of resetting the random walk to a uniform distribution in each step.",
                        "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name.",
                        "arpack_options": "an ARPACKOptions object used to fine-tune the ARPACK eigenvector calculation. If omitted, the module-level variable called  is used. This argument is ignored if not the ARPACK implementation is used, see the implementation argument.",
                        "implementation": "which  to use to solve the PageRank eigenproblem. Possible values are:\"prpack\": use the PRPACK library. This is a new  in igraph 0.7\"arpack\": use the ARPACK library. This  was used from version 0.5, until version 0.7."
                    },
                    "Return": [
                        "a list with the PageRank values of the specified vertices."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "path_length_hist": {
                    "Description": "overrides igraph.GraphBase.path_length_hist\nReturns the path length histogram of the graph",
                    "Paramters": {
                        "directed": "whether to consider  paths. Ignored for un graphs."
                    },
                    "Return": [
                        "a Histogram object. The object will also have an unconnected attribute that stores the number of unconnected vertex pairs (where the second vertex can not be reached from the first one). The latter one will be of type long (and not a simple integer), since this can be very large."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "shortest_paths": {
                    "Description": "Deprecated alias to Graph.distances().",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "spanning_tree": {
                    "Description": "Calculates a minimum spanning tree for a graph.\nReference: Prim, R.C. Shortest connection networks and some generalizations. Bell System Technical Journal 36:1389-1401, 1957.",
                    "Paramters": {
                        "weights": "a vector containing  for every edge in the graph. None means that the graph is unweighted.",
                        "return_tree": "whether to return the minimum spanning tree (when  is True) or to return the IDs of the edges in the minimum spanning tree instead (when  is False). The default is True for historical reasons as this argument was introduced in igraph 0.6."
                    },
                    "Return": [
                        "the spanning tree as a Graph object if return_tree is True or the IDs of the edges that constitute the spanning tree if return_tree is False."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "st_mincut": {
                    "Description": "overrides igraph.GraphBase.st_mincut\nCalculates the minimum cut between the source and target vertices in a graph.",
                    "Paramters": {
                        "graph": "Undocumented",
                        "source": "the  vertex ID",
                        "target": "the  vertex ID",
                        "capacity": "the  of the edges. It must be a list or a valid attribute name or None. In the latter case, every edge will have the same ."
                    },
                    "Return": [
                        "the value of the minimum cut, the IDs of vertices in the first and second partition, and the IDs of edges in the cut, packed in a 4-tuple"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "summary": {
                    "Description": "Returns the summary of the graph.\nThe output of this method is similar to the output of the __str__ method. If verbosity is zero, only the header line is returned (see __str__ for more details), otherwise the header line and the edge list is printed.\nBehind the scenes, this method constructs a GraphSummary object and invokes its __str__ method.",
                    "Paramters": {
                        "verbosity": "if zero, only the header line is returned (see __str__ for more details), otherwise the header line and the full edge list is printed.",
                        "width": "the number of characters to use in one line. If None, no limit will be enforced on the line lengths.",
                        "*args": "Undocumented",
                        "**kwds": "Undocumented"
                    },
                    "Return": [
                        "the summary of the graph."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "to_dict_dict": {
                    "Description": "Export graph to dictionary of dicts of edge attributes\nThis function is the reverse of Graph.DictDict.\nExample:",
                    "Paramters": {
                        "graph": "Undocumented",
                        "use_vids": ":boolwhether to label vertices in the output data structure by their ids or their vertex_name_attr attribute. If =False but vertices lack a vertex_name_attr attribute, an AttributeError is raised.",
                        "edge_attrs": ":Union[str, Sequence[str]]list of edge attributes to export. None (default) signified all attributes (unlike Graph.to_tuple_list). A string is acceptable to signify a single attribute and will be wrapped in a list internally.",
                        "skip_none": ":boolwhether to skip, for each edge, attributes that have a value of None. This is useful if only some edges are expected to possess an attribute.",
                        "vertex_name_attr": ":stronly used with use_vids=False to choose what vertex attribute to use to name your vertices in the output data structure."
                    },
                    "Return": [
                        "dictionary of dictionaries of dictionaries, with the outer keys vertex ids/names, the middle keys ids/names of their neighbors, and the innermost dictionary representing attributes of that edge."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": [
                        "Example:\n>>> g = Graph.Full(3)\n>>> g.es['name'] = ['first_edge', 'second', 'third']\n>>> g.to_dict_dict()\n{0: {1: {'name': 'first_edge'}, 2: {'name': 'second'}}, 1: {2: {'name': 'third'}}}\n"
                    ]
                },
                "to_dict_list": {
                    "Description": "Export graph as two lists of dictionaries, for vertices and edges.\nThis function is the reverse of Graph.DictList.\nExample:",
                    "Paramters": {
                        "graph": "Undocumented",
                        "use_vids": ":boolwhether to label vertices in the output data structure by their ids or their vertex_name_attr attribute. If =False but vertices lack a vertex_name_attr attribute, an AttributeError is raised.",
                        "skip_none": ":boolwhether to skip, for each edge, attributes that have a value of None. This is useful if only some edges are expected to possess an attribute.",
                        "vertex_name_attr": ":stronly used with use_vids=False to choose what vertex attribute to use to name your vertices in the output data structure."
                    },
                    "Return": [
                        "a tuple with two lists of dictionaries, representing the vertices and the edges, respectively, with their attributes."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": [
                        "Example:\n>>> g = Graph([(0, 1), (1, 2)])\n>>> g.vs[\"name\"] = [\"apple\", \"pear\", \"peach\"]\n>>> g.es[\"name\"] = [\"first_edge\", \"second\"]",
                        ">>> g = Graph([(0, 1), (1, 2)])\n>>> g.vs[\"name\"] = [\"apple\", \"pear\", \"peach\"]\n>>> g.es[\"name\"] = [\"first_edge\", \"second\"]",
                        ">>> g = Graph([(0, 1), (1, 2)])\n>>> g.vs[\"name\"] = [\"apple\", \"pear\", \"peach\"]\n>>> g.es[\"name\"] = [\"first_edge\", \"second\"]"
                    ]
                },
                "to_graph_tool": {
                    "Description": "Converts the graph to graph-tool\nData types: graph-tool only accepts specific data types. See the following web page for a list:\nhttps://graph-tool.skewed.de/static/doc/quickstart.html\nNote: because of the restricted data types in graph-tool, vertex and edge attributes require to be type-consistent across all vertices or edges. If you set the property for only some vertices/edges, the other will be tagged as None in igraph, so they can only be converted to graph-tool with the type 'object' and any other conversion will fail.",
                    "Paramters": {
                        "graph": "Undocumented",
                        "graph_attributes": "dictionary of graph attributes to transfer. Keys are attributes from the graph, values are data types (see below). None means no graph attributes are transferred.",
                        "vertex_attributes": "dictionary of vertex attributes to transfer. Keys are attributes from the vertices, values are data types (see below). None means no vertex attributes are transferred.",
                        "edge_attributes": "dictionary of edge attributes to transfer. Keys are attributes from the edges, values are data types (see below). None means no vertex attributes are transferred."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "to_list_dict": {
                    "Description": "Export graph to a dictionary of lists (or other sequences).\nThis function is the reverse of Graph.ListDict.\nExample:",
                    "Paramters": {
                        "graph": "Undocumented",
                        "use_vids": ":boolwhether to label vertices in the output data structure by their ids or their vertex_name_attr attribute. If =False but vertices lack a vertex_name_attr attribute, an AttributeError is raised.",
                        "sequence_constructor": ":callableconstructor for the data structure to be used as values of the dictionary. The default (list) makes a dict of lists, with each list representing the neighbors of the vertex specified in the respective dictionary key.",
                        "vertex_name_attr": ":stronly used with use_vids=False to choose what vertex attribute to use to name your vertices in the output data structure."
                    },
                    "Return": [
                        "dictionary of sequences, keyed by vertices, with each value containing the neighbors of that vertex."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": [
                        "Example:\n>>> g = Graph.Full(3)\n>>> g.to_sequence_dict() -> {0: [1, 2], 1: [2]}\n>>> g.to_sequence_dict(sequence_constructor=tuple) -> {0: (1, 2), 1: (2,)}\n>>> g.vs['name'] = ['apple', 'pear', 'peach']\n>>> g.to_sequence_dict(use_vids=False)\n{'apple': ['pear', 'peach'], 'pear': ['peach']}\n"
                    ]
                },
                "to_networkx": {
                    "Description": "Converts the graph to networkx format.\nigraph has ordered vertices and edges, but networkx does not. To keep track of the original order, the '_igraph_index' vertex property is added to both vertices and edges.",
                    "Paramters": {
                        "graph": "Undocumented",
                        "create_using": "specifies which NetworkX graph class to use when constructing the graph. None means to let igraph infer the most appropriate class based on whether the graph is directed and whether it has multi-edges.",
                        "vertex_attr_hashable": ":strvertex attribute used to name vertices in the exported network. The default \"_nx_name\" ensures round trip conversions to/from networkx are lossless."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "to_tuple_list": {
                    "Description": "Export graph to a list of edge tuples\nThis function is the reverse of Graph.TupleList.\nExample:",
                    "Paramters": {
                        "graph": "Undocumented",
                        "use_vids": ":boolwhether to label vertices in the output data structure by their ids or their vertex_name_attr attribute. If =False but vertices lack a vertex_name_attr attribute, an AttributeError is raised.",
                        "edge_attrs": ":Union[str, Sequence[str]]list of edge attributes to export in addition to source and target vertex, which are always the first two elements of each tuple. None (default) is equivalent to an empty list. A string is acceptable to signify a single attribute and will be wrapped in a list internally.",
                        "vertex_name_attr": ":stronly used with use_vids=False to choose what vertex attribute to use to name your vertices in the output data structure."
                    },
                    "Return": [
                        "a list of tuples, each representing an edge of the graph."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": [
                        "Example:\n>>> g = Graph.Full(3)\n>>> g.vs[\"name\"] = [\"apple\", \"pear\", \"peach\"]\n>>> g.es[\"name\"] = [\"first_edge\", \"second\", \"third\"]",
                        ">>> g = Graph.Full(3)\n>>> g.vs[\"name\"] = [\"apple\", \"pear\", \"peach\"]\n>>> g.es[\"name\"] = [\"first_edge\", \"second\", \"third\"]",
                        ">>> g = Graph.Full(3)\n>>> g.vs[\"name\"] = [\"apple\", \"pear\", \"peach\"]\n>>> g.es[\"name\"] = [\"first_edge\", \"second\", \"third\"]"
                    ]
                },
                "transitivity_avglocal_undirected": {
                    "Description": "overrides igraph.GraphBase.transitivity_avglocal_undirected\nCalculates the average of the vertex transitivities of the graph.\nIn the unweighted case, the transitivity measures the probability that two neighbors of a vertex are connected. In case of the average local transitivity, this probability is calculated for each vertex and then the average is taken. Vertices with less than two neighbors require special treatment, they will either be left out from the calculation or they will be considered as having zero transitivity, depending on the mode parameter. The calculation is slightly more involved for weighted graphs; in this case, weights are taken into account according to the formula of Barrat et al (see the references).\nNote that this measure is different from the global transitivity measure (see transitivity_undirected()) as it simply takes the average local transitivity across the whole network.\n",
                    "Paramters": {
                        "mode": "defines how to treat vertices with degree less than two. If TRANSITIVITY_ZERO or \"zero\", these vertices will have zero transitivity. If TRANSITIVITY_NAN or \"nan\", these vertices will be excluded from the average.",
                        "weights": "edge  to be used. Can be a sequence or iterable or even an edge attribute name."
                    },
                    "Return": [],
                    "References": [
                        "Watts DJ and Strogatz S: Collective dynamics of small-world networks. Nature 393(6884):440-442, 1998.Barrat A, Barthelemy M, Pastor-Satorras R and Vespignani A: The architecture of complex weighted networks. PNAS 101, 3747 (2004). http://arxiv.org/abs/cond-mat/0311416."
                    ],
                    "Rasises": {},
                    "See Also": "transitivity_undirected(), transitivity_local_undirected()",
                    "example": []
                },
                "triad_census": {
                    "Description": "overrides igraph.GraphBase.triad_census\nCalculates the triad census of the graph.\nReference: Davis, J.A. and Leinhardt, S. The Structure of Positive Interpersonal Relations in Small Groups. In: J. Berger (Ed.), Sociological Theories in Progress, Volume 2, 218-251. Boston: Houghton Mifflin (1972).",
                    "Paramters": {},
                    "Return": [
                        "a TriadCensus object."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "union": {
                    "Description": "Creates the union of two (or more) graphs.",
                    "Paramters": {
                        "graph": "Undocumented",
                        "other": "graph or list of graphs to be united with the current one.",
                        "byname": "whether to use vertex names instead of ids. See igraph.operators.union for details."
                    },
                    "Return": [
                        "the union graph"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "write": {
                    "Description": "Unified writing function for graphs.\nThis method tries to identify the format of the graph given in the first parameter (based on extension) and calls the corresponding writer method.\nThe remaining arguments are passed to the writer method without any changes.",
                    "Paramters": {
                        "graph": "Undocumented",
                        "f": "the ile containing the graph to be saved",
                        "format": "the  of the file (if one wants to override the  determined from the filename extension, or the filename itself is a stream). None means auto-detection. Possible values are:\"adjacency\": adjacency matrix \"dimacs\": DIMACS \"dot\", \"graphviz\": GraphViz DOT \"edgelist\", \"edges\" or \"edge\": numeric edge list \"gml\": GML \"graphml\" and \"graphmlz\": standard and gzipped GraphML \"gw\", \"leda\", \"lgr\": LEDA native \"lgl\": LGL \"ncol\": NCOL \"net\", \"pajek\": Pajek \"pickle\", \"picklez\": standard and gzipped Python pickled \"svg\": SVG ",
                        "*args": "Undocumented",
                        "**kwds": "Undocumented"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {
                        "IOError": "if the file format can't be identified and none was given."
                    },
                    "See Also": "",
                    "example": []
                },
                "write_adjacency": {
                    "Description": "Writes the adjacency matrix of the graph to the given file\nAll the remaining arguments not mentioned here are passed intact to Graph.get_adjacency.",
                    "Paramters": {
                        "graph": "Undocumented",
                        "f": "the name o the ile to be written.",
                        "sep": "the string that arates the matrix elements in a row",
                        "eol": "the string that separates the rows of the matrix. Please note that igraph is able to read back the written adjacency matrix if and only if this is a single newline character",
                        "*args": "Undocumented",
                        "**kwds": "Undocumented"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "write_dimacs": {
                    "Description": "overrides igraph.GraphBase.write_dimacs\nWrites the graph in DIMACS format to the given file.",
                    "Paramters": {
                        "graph": "Undocumented",
                        "f": "the name o the ile to be written or a Python ile handle.",
                        "source": "the  vertex ID. If None, igraph will try to infer it from the  graph attribute.",
                        "target": "the  vertex ID. If None, igraph will try to infer it from the  graph attribute.",
                        "capacity": "the capacities of the edges in a list or the name of an edge attribute that holds the capacities. If there is no such edge attribute, every edge will have a  of 1."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "write_graphmlz": {
                    "Description": "Writes the graph to a zipped GraphML file.\nThe library uses the gzip compression algorithm, so the resulting file can be unzipped with regular gzip uncompression (like gunzip or zcat from Unix command line) or the Python gzip module.\nUses a temporary file to store intermediate GraphML data, so make sure you have enough free space to store the unzipped GraphML file as well.",
                    "Paramters": {
                        "graph": "Undocumented",
                        "f": "the name o the ile to be written.",
                        "compresslevel": "the level of compression. 1 is fastest and produces the least compression, and 9 is slowest and produces the most compression."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "write_pickle": {
                    "Description": "Saves the graph in Python pickled format",
                    "Paramters": {
                        "graph": "Undocumented",
                        "fname": "the name of the file or a stream to save to. If None, saves the graph to a string and returns the string.",
                        "version": "pickle protocol  to be used. If -1, uses the highest protocol available"
                    },
                    "Return": [
                        "None if the graph was saved successfully to the given file, or a string if fname was None."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "write_picklez": {
                    "Description": "Saves the graph in Python pickled format, compressed with gzip.\nSaving in this format is a bit slower than saving in a Python pickle without compression, but the final file takes up much less space on the hard drive.",
                    "Paramters": {
                        "graph": "Undocumented",
                        "fname": "the name of the file or a stream to save to.",
                        "version": "pickle protocol  to be used. If -1, uses the highest protocol available"
                    },
                    "Return": [
                        "None if the graph was saved successfully to the given file."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "write_svg": {
                    "Description": "Saves the graph as an SVG (Scalable Vector Graphics) file\nThe file will be Inkscape (http://inkscape.org) compatible. In Inkscape, as nodes are rearranged, the edges auto-update.",
                    "Paramters": {
                        "graph": "Undocumented",
                        "fname": "the name of the file or a Python file handle",
                        "layout": "the  of the graph. Can be either an explicitly specified  (using a list of coordinate pairs) or the name of a  algorithm (which should refer to a method in the Graph object, but without the _ prefix.",
                        "width": "the preferred  in pixels (default: 400)",
                        "height": "the preferred  in pixels (default: 400)",
                        "labels": "the vertex . Either it is the name of a vertex attribute to use, or a list explicitly specifying the . It can also be None.",
                        "colors": "the vertex . Either it is the name of a vertex attribute to use, or a list explicitly specifying the . A color can be anything acceptable in an SVG file.",
                        "shapes": "the vertex . Either it is the name of a vertex attribute to use, or a list explicitly specifying the  as integers. Shape 0 means hidden (nothing is drawn), shape 1 is a circle, shape 2 is a rectangle and shape 3 is a rectangle that automatically sizes to the inner text.",
                        "vertex_size": "vertex size in pixels",
                        "edge_colors": "the edge colors. Either it is the name of an edge attribute to use, or a list explicitly specifying the colors. A color can be anything acceptable in an SVG file.",
                        "edge_stroke_widths": "the stroke widths of the edges. Either it is the name of an edge attribute to use, or a list explicitly specifying the stroke widths. The stroke width can be anything acceptable in an SVG file.",
                        "font_size": "font size. If it is a string, it is written into the SVG file as-is (so you can specify anything which is valid as the value of the font-size style). If it is a number, it is interpreted as pixel size and converted to the proper attribute value accordingly.",
                        "*args": "Undocumented",
                        "**kwds": "Undocumented"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__new__": {
                    "Description": "Inherited from GraphBase:Create and return a new object.  See help(type) for accurate signature."
                },
                "all_minimal_st_separators": {
                    "Description": "Inherited from GraphBase:Returns a list containing all the minimal s-t separators of a graph."
                },
                "are_connected": {
                    "Description": "Inherited from GraphBase:Decides whether two given vertices are directly connected."
                },
                "articulation_points": {
                    "Description": "Inherited from GraphBase:Returns the list of articulation points in the graph."
                },
                "assortativity": {
                    "Description": "Inherited from GraphBase:Returns the assortativity of the graph based on numeric properties of the vertices."
                },
                "assortativity_degree": {
                    "Description": "Inherited from GraphBase:Returns the assortativity of a graph based on vertex degrees."
                },
                "assortativity_nominal": {
                    "Description": "Inherited from GraphBase:Returns the assortativity of the graph based on vertex categories."
                },
                "Asymmetric_Preference": {
                    "Description": "Inherited from GraphBase:Generates a graph based on asymmetric vertex types and connection probabilities."
                },
                "Atlas": {
                    "Description": "Inherited from GraphBase:Generates a graph from the Graph Atlas."
                },
                "attributes": {
                    "Description": "Inherited from GraphBase:No summary"
                },
                "authority_score": {
                    "Description": "Inherited from GraphBase:Calculates Kleinberg's authority score for the vertices of the graph"
                },
                "automorphism_group": {
                    "Description": "Inherited from GraphBase:Calculates the generators of the automorphism group of a graph using the BLISS isomorphism algorithm."
                },
                "average_path_length": {
                    "Description": "Inherited from GraphBase:Calculates the average path length in a graph."
                },
                "Barabasi": {
                    "Description": "Inherited from GraphBase:Generates a graph based on the Barab\u00e1si-Albert model."
                },
                "betweenness": {
                    "Description": "Inherited from GraphBase:Calculates or estimates the betweenness of vertices in a graph."
                },
                "bfs": {
                    "Description": "Inherited from GraphBase:Conducts a breadth first search (BFS) on the graph."
                },
                "bfsiter": {
                    "Description": "Inherited from GraphBase:Constructs a breadth first search (BFS) iterator of the graph."
                },
                "bibcoupling": {
                    "Description": "Inherited from GraphBase:Calculates bibliographic coupling scores for given vertices in a graph."
                },
                "bridges": {
                    "Description": "Inherited from GraphBase:Returns the list of bridges in the graph."
                },
                "canonical_permutation": {
                    "Description": "Inherited from GraphBase:Calculates the canonical permutation of a graph using the BLISS isomorphism algorithm."
                },
                "chordal_completion": {
                    "Description": "Inherited from GraphBase:Returns the list of edges needed to be added to the graph to make it chordal."
                },
                "clique_number": {
                    "Description": "Inherited from GraphBase:Returns the clique number of the graph."
                },
                "cliques": {
                    "Description": "Inherited from GraphBase:Returns some or all cliques of the graph as a list of tuples."
                },
                "closeness": {
                    "Description": "Inherited from GraphBase:Calculates the closeness centralities of given vertices in a graph."
                },
                "cocitation": {
                    "Description": "Inherited from GraphBase:Calculates cocitation scores for given vertices in a graph."
                },
                "complementer": {
                    "Description": "Inherited from GraphBase:Returns the complementer of the graph"
                },
                "compose": {
                    "Description": "Inherited from GraphBase:Returns the composition of two graphs."
                },
                "constraint": {
                    "Description": "Inherited from GraphBase:Calculates Burt's constraint scores for given vertices in a graph."
                },
                "contract_vertices": {
                    "Description": "Inherited from GraphBase:Contracts some vertices in the graph, i.e. replaces groups of vertices with single vertices. Edges are not affected."
                },
                "convergence_degree": {
                    "Description": "Inherited from GraphBase:Undocumented (yet)."
                },
                "convergence_field_size": {
                    "Description": "Inherited from GraphBase:Undocumented (yet)."
                },
                "copy": {
                    "Description": "Inherited from GraphBase:Creates a copy of the graph."
                },
                "coreness": {
                    "Description": "Inherited from GraphBase:Finds the coreness (shell index) of the vertices of the network."
                },
                "count_automorphisms": {
                    "Description": "Inherited from GraphBase:Calculates the number of automorphisms of a graph using the BLISS isomorphism algorithm."
                },
                "count_isomorphisms_vf2": {
                    "Description": "Inherited from GraphBase:Determines the number of isomorphisms between the graph and another one"
                },
                "count_multiple": {
                    "Description": "Inherited from GraphBase:Counts the multiplicities of the given edges."
                },
                "count_subisomorphisms_vf2": {
                    "Description": "Inherited from GraphBase:Determines the number of subisomorphisms between the graph and another one"
                },
                "De_Bruijn": {
                    "Description": "Inherited from GraphBase:Generates a de Bruijn graph with parameters (m, n)"
                },
                "decompose": {
                    "Description": "Inherited from GraphBase:Decomposes the graph into subgraphs."
                },
                "degree": {
                    "Description": "Inherited from GraphBase:Returns some vertex degrees from the graph."
                },
                "Degree_Sequence": {
                    "Description": "Inherited from GraphBase:Generates a graph with a given degree sequence."
                },
                "delete_vertices": {
                    "Description": "Inherited from GraphBase:Deletes vertices and all its edges from the graph."
                },
                "density": {
                    "Description": "Inherited from GraphBase:Calculates the density of the graph."
                },
                "dfsiter": {
                    "Description": "Inherited from GraphBase:Constructs a depth first search (DFS) iterator of the graph."
                },
                "diameter": {
                    "Description": "Inherited from GraphBase:Calculates the diameter of the graph."
                },
                "difference": {
                    "Description": "Inherited from GraphBase:Subtracts the given graph from the original"
                },
                "distances": {
                    "Description": "Inherited from GraphBase:Calculates shortest path lengths for given vertices in a graph."
                },
                "diversity": {
                    "Description": "Inherited from GraphBase:Calculates the structural diversity index of the vertices."
                },
                "dominator": {
                    "Description": "Inherited from GraphBase:Returns the dominator tree from the given root node"
                },
                "eccentricity": {
                    "Description": "Inherited from GraphBase:Calculates the eccentricities of given vertices in a graph."
                },
                "ecount": {
                    "Description": "Inherited from GraphBase:Counts the number of edges."
                },
                "edge_attributes": {
                    "Description": "Inherited from GraphBase:No summary"
                },
                "edge_betweenness": {
                    "Description": "Inherited from GraphBase:Calculates or estimates the edge betweennesses in a graph."
                },
                "edge_connectivity": {
                    "Description": "Inherited from GraphBase:Calculates the edge connectivity of the graph or between some vertices."
                },
                "eigen_adjacency": {
                    "Description": "Inherited from GraphBase:Undocumented"
                },
                "eigenvector_centrality": {
                    "Description": "Inherited from GraphBase:Calculates the eigenvector centralities of the vertices in a graph."
                },
                "Erdos_Renyi": {
                    "Description": "Inherited from GraphBase:Generates a graph based on the Erd\u0151s-R\u00e9nyi model."
                },
                "Establishment": {
                    "Description": "Inherited from GraphBase:Generates a graph based on a simple growing model with vertex types."
                },
                "Famous": {
                    "Description": "Inherited from GraphBase:Generates a famous graph based on its name."
                },
                "farthest_points": {
                    "Description": "Inherited from GraphBase:Returns two vertex IDs whose distance equals the actual diameter of the graph."
                },
                "feedback_arc_set": {
                    "Description": "Inherited from GraphBase:Calculates an approximately or exactly minimal feedback arc set."
                },
                "Forest_Fire": {
                    "Description": "Inherited from GraphBase:Generates a graph based on the forest fire model"
                },
                "Full": {
                    "Description": "Inherited from GraphBase:Generates a full graph (directed or undirected, with or without loops)."
                },
                "Full_Citation": {
                    "Description": "Inherited from GraphBase:Generates a full citation graph"
                },
                "fundamental_cycles": {
                    "Description": "Inherited from GraphBase:Finds a single fundamental cycle basis of the graph"
                },
                "get_all_shortest_paths": {
                    "Description": "Inherited from GraphBase:Calculates all of the shortest paths from/to a given node in a graph."
                },
                "get_diameter": {
                    "Description": "Inherited from GraphBase:Returns a path with the actual diameter of the graph."
                },
                "get_edgelist": {
                    "Description": "Inherited from GraphBase:Returns the edge list of a graph."
                },
                "get_eid": {
                    "Description": "Inherited from GraphBase:Returns the edge ID of an arbitrary edge between vertices v1 and v2"
                },
                "get_eids": {
                    "Description": "Inherited from GraphBase:Returns the edge IDs of some edges between some vertices."
                },
                "get_isomorphisms_vf2": {
                    "Description": "Inherited from GraphBase:Returns all isomorphisms between the graph and another one"
                },
                "get_k_shortest_paths": {
                    "Description": "Inherited from GraphBase:Calculates the k shortest paths from/to a given node in a graph."
                },
                "get_shortest_path": {
                    "Description": "Inherited from GraphBase:Calculates the shortest path from a source vertex to a target vertex in a graph."
                },
                "get_shortest_path_astar": {
                    "Description": "Inherited from GraphBase:Calculates the shortest path from a source vertex to a target vertex in a graph using the A-Star algorithm and a heuristic function."
                },
                "get_shortest_paths": {
                    "Description": "Inherited from GraphBase:Calculates the shortest paths from/to a given node in a graph."
                },
                "get_subisomorphisms_lad": {
                    "Description": "Inherited from GraphBase:Returns all subisomorphisms between the graph and another one using the LAD algorithm."
                },
                "get_subisomorphisms_vf2": {
                    "Description": "Inherited from GraphBase:Returns all subisomorphisms between the graph and another one"
                },
                "girth": {
                    "Description": "Inherited from GraphBase:Returns the girth of the graph."
                },
                "Growing_Random": {
                    "Description": "Inherited from GraphBase:Generates a growing random graph."
                },
                "harmonic_centrality": {
                    "Description": "Inherited from GraphBase:Calculates the harmonic centralities of given vertices in a graph."
                },
                "has_multiple": {
                    "Description": "Inherited from GraphBase:Checks whether the graph has multiple edges."
                },
                "Hexagonal_Lattice": {
                    "Description": "Inherited from GraphBase:Generates a regular hexagonal lattice."
                },
                "hub_score": {
                    "Description": "Inherited from GraphBase:Calculates Kleinberg's hub score for the vertices of the graph"
                },
                "incident": {
                    "Description": "Inherited from GraphBase:Returns the edges a given vertex is incident on."
                },
                "independence_number": {
                    "Description": "Inherited from GraphBase:Returns the independence number of the graph."
                },
                "independent_vertex_sets": {
                    "Description": "Inherited from GraphBase:Returns some or all independent vertex sets of the graph as a list of tuples."
                },
                "induced_subgraph": {
                    "Description": "Inherited from GraphBase:Returns a subgraph spanned by the given vertices."
                },
                "is_acyclic": {
                    "Description": "Inherited from GraphBase:Returns whether the graph is acyclic (i.e. contains no cycles)."
                },
                "is_biconnected": {
                    "Description": "Inherited from GraphBase:Decides whether the graph is biconnected."
                },
                "is_bipartite": {
                    "Description": "Inherited from GraphBase:Decides whether the graph is bipartite or not."
                },
                "is_chordal": {
                    "Description": "Inherited from GraphBase:Returns whether the graph is chordal or not."
                },
                "is_connected": {
                    "Description": "Inherited from GraphBase:Decides whether the graph is connected."
                },
                "is_dag": {
                    "Description": "Inherited from GraphBase:Checks whether the graph is a DAG (directed acyclic graph)."
                },
                "is_directed": {
                    "Description": "Inherited from GraphBase:Checks whether the graph is directed."
                },
                "is_loop": {
                    "Description": "Inherited from GraphBase:Checks whether a specific set of edges contain loop edges"
                },
                "is_minimal_separator": {
                    "Description": "Inherited from GraphBase:Decides whether the given vertex set is a minimal separator."
                },
                "is_multiple": {
                    "Description": "Inherited from GraphBase:Checks whether an edge is a multiple edge."
                },
                "is_mutual": {
                    "Description": "Inherited from GraphBase:Checks whether an edge has an opposite pair."
                },
                "is_separator": {
                    "Description": "Inherited from GraphBase:Decides whether the removal of the given vertices disconnects the graph."
                },
                "is_simple": {
                    "Description": "Inherited from GraphBase:Checks whether the graph is simple (no loop or multiple edges)."
                },
                "is_tree": {
                    "Description": "Inherited from GraphBase:Checks whether the graph is a (directed or undirected) tree graph."
                },
                "Isoclass": {
                    "Description": "Inherited from GraphBase:Generates a graph with a given isomorphism class."
                },
                "isoclass": {
                    "Description": "Inherited from GraphBase:Returns the isomorphism class of the graph or its subgraph."
                },
                "isomorphic": {
                    "Description": "Inherited from GraphBase:Checks whether the graph is isomorphic to another graph."
                },
                "isomorphic_bliss": {
                    "Description": "Inherited from GraphBase:Checks whether the graph is isomorphic to another graph, using the BLISS isomorphism algorithm."
                },
                "isomorphic_vf2": {
                    "Description": "Inherited from GraphBase:Checks whether the graph is isomorphic to another graph, using the VF2 isomorphism algorithm."
                },
                "K_Regular": {
                    "Description": "Inherited from GraphBase:Generates a k-regular random graph"
                },
                "Kautz": {
                    "Description": "Inherited from GraphBase:Generates a Kautz graph with parameters (m, n)"
                },
                "knn": {
                    "Description": "Inherited from GraphBase:Calculates the average degree of the neighbors for each vertex, and the same quantity as the function of vertex degree."
                },
                "laplacian": {
                    "Description": "Inherited from GraphBase:Returns the Laplacian matrix of a graph."
                },
                "largest_cliques": {
                    "Description": "Inherited from GraphBase:Returns the largest cliques of the graph as a list of tuples."
                },
                "largest_independent_vertex_sets": {
                    "Description": "Inherited from GraphBase:Returns the largest independent vertex sets of the graph as a list of tuples."
                },
                "Lattice": {
                    "Description": "Inherited from GraphBase:Generates a regular square lattice."
                },
                "layout_bipartite": {
                    "Description": "Inherited from GraphBase:Place the vertices of a bipartite graph in two layers."
                },
                "layout_circle": {
                    "Description": "Inherited from GraphBase:Places the vertices of the graph uniformly on a circle or a sphere."
                },
                "layout_davidson_harel": {
                    "Description": "Inherited from GraphBase:Places the vertices on a 2D plane according to the Davidson-Harel layout algorithm."
                },
                "layout_drl": {
                    "Description": "Inherited from GraphBase:Places the vertices on a 2D plane or in the 3D space ccording to the DrL layout algorithm."
                },
                "layout_fruchterman_reingold": {
                    "Description": "Inherited from GraphBase:Places the vertices on a 2D plane according to the Fruchterman-Reingold algorithm."
                },
                "layout_graphopt": {
                    "Description": "Inherited from GraphBase:This is a port of the graphopt layout algorithm by Michael Schmuhl. graphopt version 0.4.1 was rewritten in C and the support for layers was removed."
                },
                "layout_grid": {
                    "Description": "Inherited from GraphBase:Places the vertices of a graph in a 2D or 3D grid."
                },
                "layout_kamada_kawai": {
                    "Description": "Inherited from GraphBase:Places the vertices on a plane according to the Kamada-Kawai algorithm."
                },
                "layout_lgl": {
                    "Description": "Inherited from GraphBase:Places the vertices on a 2D plane according to the Large Graph Layout."
                },
                "layout_mds": {
                    "Description": "Inherited from GraphBase:Places the vertices in an Euclidean space with the given number of dimensions using multidimensional scaling."
                },
                "layout_random": {
                    "Description": "Inherited from GraphBase:Places the vertices of the graph randomly."
                },
                "layout_reingold_tilford": {
                    "Description": "Inherited from GraphBase:Places the vertices on a 2D plane according to the Reingold-Tilford layout algorithm."
                },
                "layout_reingold_tilford_circular": {
                    "Description": "Inherited from GraphBase:Circular Reingold-Tilford layout for trees."
                },
                "layout_star": {
                    "Description": "Inherited from GraphBase:Calculates a star-like layout for the graph."
                },
                "layout_umap": {
                    "Description": "Inherited from GraphBase:Uniform Manifold Approximation and Projection (UMAP)."
                },
                "LCF": {
                    "Description": "Inherited from GraphBase:Generates a graph from LCF notation."
                },
                "linegraph": {
                    "Description": "Inherited from GraphBase:Returns the line graph of the graph."
                },
                "list_triangles": {
                    "Description": "Inherited from GraphBase:Lists the triangles of the graph"
                },
                "maxdegree": {
                    "Description": "Inherited from GraphBase:Returns the maximum degree of a vertex set in the graph."
                },
                "maxflow_value": {
                    "Description": "Inherited from GraphBase:Returns the value of the maximum flow between the source and target vertices."
                },
                "maximal_cliques": {
                    "Description": "Inherited from GraphBase:Returns the maximal cliques of the graph as a list of tuples."
                },
                "maximal_independent_vertex_sets": {
                    "Description": "Inherited from GraphBase:Returns the maximal independent vertex sets of the graph as a list of tuples."
                },
                "maximum_cardinality_search": {
                    "Description": "Inherited from GraphBase:Conducts a maximum cardinality search on the graph. The function computes a rank alpha for each vertex such that visiting vertices in decreasing rank order corresponds to always choosing the vertex with the most already visited neighbors as the next one to visit."
                },
                "mincut_value": {
                    "Description": "Inherited from GraphBase:Returns the minimum cut between the source and target vertices or within the whole graph."
                },
                "minimum_cycle_basis": {
                    "Description": "Inherited from GraphBase:Computes a minimum cycle basis of the graph"
                },
                "minimum_size_separators": {
                    "Description": "Inherited from GraphBase:Returns a list containing all separator vertex sets of minimum size."
                },
                "modularity_matrix": {
                    "Description": "Inherited from GraphBase:Calculates the modularity matrix of the graph."
                },
                "motifs_randesu": {
                    "Description": "Inherited from GraphBase:Counts the number of motifs in the graph"
                },
                "motifs_randesu_estimate": {
                    "Description": "Inherited from GraphBase:Counts the total number of motifs in the graph"
                },
                "motifs_randesu_no": {
                    "Description": "Inherited from GraphBase:Counts the total number of motifs in the graph"
                },
                "neighborhood": {
                    "Description": "Inherited from GraphBase:For each vertex specified by vertices, returns the vertices reachable from that vertex in at most order steps. If mindist is larger than zero, vertices that are reachable in less than mindist steps are excluded."
                },
                "neighborhood_size": {
                    "Description": "Inherited from GraphBase:For each vertex specified by vertices, returns the number of vertices reachable from that vertex in at most order steps. If mindist is larger than zero, vertices that are reachable in less than mindist..."
                },
                "neighbors": {
                    "Description": "Inherited from GraphBase:Returns adjacent vertices to a given vertex."
                },
                "permute_vertices": {
                    "Description": "Inherited from GraphBase:Permutes the vertices of the graph according to the given permutation and returns the new graph."
                },
                "personalized_pagerank": {
                    "Description": "Inherited from GraphBase:Calculates the personalized PageRank values of a graph."
                },
                "predecessors": {
                    "Description": "Inherited from GraphBase:Returns the predecessors of a given vertex."
                },
                "Preference": {
                    "Description": "Inherited from GraphBase:Generates a graph based on vertex types and connection probabilities."
                },
                "Prufer": {
                    "Description": "Inherited from GraphBase:Generates a tree from its Pr\u00fcfer sequence."
                },
                "radius": {
                    "Description": "Inherited from GraphBase:Calculates the radius of the graph."
                },
                "random_walk": {
                    "Description": "Inherited from GraphBase:Performs a random walk of a given length from a given node."
                },
                "Read_DL": {
                    "Description": "Inherited from GraphBase:Reads an UCINET DL file and creates a graph based on it."
                },
                "Read_Edgelist": {
                    "Description": "Inherited from GraphBase:Reads an edge list from a file and creates a graph based on it."
                },
                "Read_GML": {
                    "Description": "Inherited from GraphBase:Reads a GML file and creates a graph based on it."
                },
                "Read_GraphDB": {
                    "Description": "Inherited from GraphBase:Reads a GraphDB format file and creates a graph based on it."
                },
                "Read_GraphML": {
                    "Description": "Inherited from GraphBase:Reads a GraphML format file and creates a graph based on it."
                },
                "Read_Lgl": {
                    "Description": "Inherited from GraphBase:Reads an .lgl file used by LGL."
                },
                "Read_Ncol": {
                    "Description": "Inherited from GraphBase:Reads an .ncol file used by LGL."
                },
                "Read_Pajek": {
                    "Description": "Inherited from GraphBase:Reads a file in the Pajek format and creates a graph based on it. Only Pajek network files (.net extension) are supported, not project files (.paj)."
                },
                "Realize_Bipartite_Degree_Sequence": {
                    "Description": "Inherited from GraphBase:Generates a bipartite graph from the degree sequences of its partitions."
                },
                "Realize_Degree_Sequence": {
                    "Description": "Inherited from GraphBase:Generates a graph from a degree sequence."
                },
                "Recent_Degree": {
                    "Description": "Inherited from GraphBase:Generates a graph based on a stochastic model where the probability of an edge gaining a new node is proportional to the edges gained in a given time window."
                },
                "reciprocity": {
                    "Description": "Inherited from GraphBase:Reciprocity defines the proportion of mutual connections in a directed graph. It is most commonly defined as the probability that the opposite counterpart of a directed edge is also included in the graph..."
                },
                "reverse_edges": {
                    "Description": "Inherited from GraphBase:Reverses the direction of some edges in the graph."
                },
                "rewire": {
                    "Description": "Inherited from GraphBase:Randomly rewires the graph while preserving the degree distribution."
                },
                "rewire_edges": {
                    "Description": "Inherited from GraphBase:Rewires the edges of a graph with constant probability."
                },
                "Ring": {
                    "Description": "Inherited from GraphBase:Generates a ring graph."
                },
                "SBM": {
                    "Description": "Inherited from GraphBase:Generates a graph based on a stochastic block model."
                },
                "similarity_dice": {
                    "Description": "Inherited from GraphBase:Dice similarity coefficient of vertices."
                },
                "similarity_inverse_log_weighted": {
                    "Description": "Inherited from GraphBase:Inverse log-weighted similarity coefficient of vertices."
                },
                "similarity_jaccard": {
                    "Description": "Inherited from GraphBase:Jaccard similarity coefficient of vertices."
                },
                "simplify": {
                    "Description": "Inherited from GraphBase:Simplifies a graph by removing self-loops and/or multiple edges."
                },
                "Star": {
                    "Description": "Inherited from GraphBase:Generates a star graph."
                },
                "Static_Fitness": {
                    "Description": "Inherited from GraphBase:Generates a non-growing graph with edge probabilities proportional to node fitnesses."
                },
                "Static_Power_Law": {
                    "Description": "Inherited from GraphBase:Generates a non-growing graph with prescribed power-law degree distributions."
                },
                "strength": {
                    "Description": "Inherited from GraphBase:Returns the strength (weighted degree) of some vertices from the graph"
                },
                "subcomponent": {
                    "Description": "Inherited from GraphBase:Determines the indices of vertices which are in the same component as a given vertex."
                },
                "subgraph_edges": {
                    "Description": "Inherited from GraphBase:Returns a subgraph spanned by the given edges."
                },
                "subisomorphic_lad": {
                    "Description": "Inherited from GraphBase:Checks whether a subgraph of the graph is isomorphic to another graph."
                },
                "subisomorphic_vf2": {
                    "Description": "Inherited from GraphBase:Checks whether a subgraph of the graph is isomorphic to another graph."
                },
                "successors": {
                    "Description": "Inherited from GraphBase:Returns the successors of a given vertex."
                },
                "to_directed": {
                    "Description": "Inherited from GraphBase:Converts an undirected graph to directed."
                },
                "to_prufer": {
                    "Description": "Inherited from GraphBase:Converts a tree graph into a Pr\u00fcfer sequence."
                },
                "to_undirected": {
                    "Description": "Inherited from GraphBase:Converts a directed graph to undirected."
                },
                "topological_sorting": {
                    "Description": "Inherited from GraphBase:Calculates a possible topological sorting of the graph."
                },
                "transitivity_local_undirected": {
                    "Description": "Inherited from GraphBase:Calculates the local transitivity (clustering coefficient) of the given vertices in the graph."
                },
                "transitivity_undirected": {
                    "Description": "Inherited from GraphBase:Calculates the global transitivity (clustering coefficient) of the graph."
                },
                "Tree": {
                    "Description": "Inherited from GraphBase:Generates a tree in which almost all vertices have the same number of children."
                },
                "Tree_Game": {
                    "Description": "Inherited from GraphBase:Generates a random tree by sampling uniformly from the set of labelled trees with a given number of nodes."
                },
                "Triangular_Lattice": {
                    "Description": "Inherited from GraphBase:Generates a regular triangular lattice."
                },
                "unfold_tree": {
                    "Description": "Inherited from GraphBase:Unfolds the graph using a BFS to a tree by duplicating vertices as necessary."
                },
                "vcount": {
                    "Description": "Inherited from GraphBase:Counts the number of vertices."
                },
                "vertex_attributes": {
                    "Description": "Inherited from GraphBase:No summary"
                },
                "vertex_coloring_greedy": {
                    "Description": "Inherited from GraphBase:Calculates a greedy vertex coloring for the graph based on some heuristics."
                },
                "vertex_connectivity": {
                    "Description": "Inherited from GraphBase:Calculates the vertex connectivity of the graph or between some vertices."
                },
                "Watts_Strogatz": {
                    "Description": "Inherited from GraphBase:This function generates networks with the small-world property based on a variant of the Watts-Strogatz model. The network is obtained by first creating a periodic undirected lattice, then rewiring both endpoints of each edge with probability ..."
                },
                "write_dot": {
                    "Description": "Inherited from GraphBase:Writes the graph in DOT format to the given file."
                },
                "write_edgelist": {
                    "Description": "Inherited from GraphBase:Writes the edge list of a graph to a file."
                },
                "write_gml": {
                    "Description": "Inherited from GraphBase:Writes the graph in GML format to the given file."
                },
                "write_graphml": {
                    "Description": "Inherited from GraphBase:Writes the graph to a GraphML file."
                },
                "write_leda": {
                    "Description": "Inherited from GraphBase:Writes the graph to a file in LEDA native format."
                },
                "write_lgl": {
                    "Description": "Inherited from GraphBase:Writes the edge list of a graph to a file in .lgl format."
                },
                "write_ncol": {
                    "Description": "Inherited from GraphBase:Writes the edge list of a graph to a file in .ncol format."
                },
                "write_pajek": {
                    "Description": "Inherited from GraphBase:Writes the graph in Pajek format to the given file."
                }
            },
            "property": {
                "es": "The edge sequence of the graph\n",
                "vs": "The vertex sequence of the graph\n",
                "_as_parameter_": "Undocumented\n"
            }
        },
        "Rubric": {
            "Example": [
                "Graphs can also be indexed by strings or pairs of vertex indices or vertex names.  When a graph is indexed by a string, the operation translates to the retrieval, creation, modification or deletion of a graph attribute:\n>>> g = Graph.Full(3)\n>>> g[\"name\"] = \"Triangle graph\"\n>>> g[\"name\"]\n'Triangle graph'\n>>> del g[\"name\"]",
                "When a graph is indexed by a pair of vertex indices or names, the graph itself is treated as an adjacency matrix and the corresponding cell of the matrix is returned:\n>>> g = Graph.Full(3)\n>>> g[\"name\"] = \"Triangle graph\"\n>>> g[\"name\"]\n'Triangle graph'\n>>> del g[\"name\"]",
                "Assigning values different from zero or one to the adjacency matrix will be translated to one, unless the graph is weighted, in which case the numbers will be treated as weights:\n>>> g = Graph.Full(3)\n>>> g[\"name\"] = \"Triangle graph\"\n>>> g[\"name\"]\n'Triangle graph'\n>>> del g[\"name\"]"
            ]
        }
    },
    {
        "Section_id": "CairoArrowEdgeDrawer",
        "Description": "Edge drawer implementation that draws undirected edges as straight lines and directed edges as arrows.",
        "Field List": {
            "Methods": {
                "draw_directed_edge": {
                    "Description": "overrides igraph.drawing.baseclasses.AbstractEdgeDrawer.draw_directed_edge\nDraws a directed edge.",
                    "Paramters": {
                        "edge": "the  to be drawn. Visual properties of the  are defined by the attributes of this object.",
                        "src_vertex": "the source vertex. Visual properties are defined by the attributes of this object.",
                        "dest_vertex": "the source vertex. Visual properties are defined by the attributes of this object."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__init__": {
                    "Description": "Inherited from AbstractCairoEdgeDrawer:Constructs the edge drawer."
                },
                "draw_loop_edge": {
                    "Description": "Inherited from AbstractCairoEdgeDrawer:Draws a loop edge."
                },
                "draw_undirected_edge": {
                    "Description": "Inherited from AbstractCairoEdgeDrawer:Draws an undirected edge."
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "community_to_membership",
        "Description": "Undocumented",
        "Paramters": {},
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "convex_hull",
        "Description": "Calculates the convex hull of a given point set.",
        "Paramters": {
            "vs": "the point set as a list of lists",
            "coords": "if True, the function returns the coordinates of the corners of the convex hull polygon, otherwise returns the corner indices."
        },
        "Return": [
            "either the hull's corner coordinates or the point indices corresponding to them, depending on the coords parameter."
        ],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "is_bigraphical",
        "Description": "Returns whether two sequences of integers can be the degree sequences of a bipartite graph.\nThe bipartite graph may or may not have multiple edges, depending on the allowed edge types in the remaining arguments.",
        "Paramters": {
            "degrees1": "the list of degrees in the first partition.",
            "degrees2": "the list of degrees in the second partition.",
            "multiple": "whether  edges are allowed."
        },
        "Return": [
            "True if there exists some bipartite graph that can realize the given degree sequences with or without multiple edges, False otherwise."
        ],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "is_degree_sequence",
        "Description": "Deprecated since 0.9 in favour of is_graphical().\nReturns whether a list of degrees can be a degree sequence of some graph.\nNote that it is not required for the graph to be simple; in other words, this function may return True for degree sequences that can be realized using one or more multiple or loop edges only.\nIn particular, this function checks whetherall the degrees are non-negativefor undirected graphs, the sum of degrees are evenfor directed graphs, the two degree sequences are of the same length and equal sums",
        "Paramters": {
            "out_deg": "the list of degrees. For directed graphs, this list must contain the out-degrees of the vertices.",
            "in_deg": "the list of in-degrees for directed graphs. This parameter must be None for undirected graphs."
        },
        "Return": [
            "True if there exists some graph that can realize the given degree sequence, False otherwise."
        ],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "is_graphical",
        "Description": "Returns whether a list of degrees can be a degree sequence of some graph, with or without multiple and loop edges, depending on the allowed edge types in the remaining arguments.",
        "Paramters": {
            "out_deg": "the list of degrees. For directed graphs, this list must contain the out-degrees of the vertices.",
            "in_deg": "the list of in-degrees for directed graphs. This parameter must be None for undirected graphs.",
            "loops": "whether loop edges are allowed.",
            "multiple": "whether  edges are allowed."
        },
        "Return": [
            "True if there exists some graph that can realize the given degree sequence with the given edge types, False otherwise."
        ],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "is_graphical_degree_sequence",
        "Description": "Deprecated since 0.9 in favour of is_graphical().\nReturns whether a list of degrees can be a degree sequence of some simple graph.\nNote that it is required for the graph to be simple; in other words, this function will return False for degree sequences that cannot be realized without using one or more multiple or loop edges.",
        "Paramters": {
            "out_deg": "the list of degrees. For directed graphs, this list must contain the out-degrees of the vertices.",
            "in_deg": "the list of in-degrees for directed graphs. This parameter must be None for undirected graphs."
        },
        "Return": [
            "True if there exists some simple graph that can realize the given degree sequence, False otherwise."
        ],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "set_progress_handler",
        "Description": "Sets the handler to be called when igraph is performing a long operation.",
        "Paramters": {
            "handler": "the progress  function. It must accept two arguments, the first is the message informing the user about what igraph is doing right now, the second is the actual progress information (a percentage)."
        },
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "set_random_number_generator",
        "Description": "Sets the random number generator used by igraph.",
        "Paramters": {
            "generator": "the  to be used. It must be a Python object with at least three attributes: random, randint and gauss. Each of them must be callable and their signature and behaviour must be identical to random.random, random.randint and random.gauss. Optionally, the object can provide a function named getrandbits with a signature identical to randpm.getrandbits that provides a given number of random bits on demand. By default, igraph uses the random module for random number generation, but you can supply your alternative implementation here. If the given  is None, igraph reverts to the default PCG32  implemented in the C layer, which might be slightly faster than calling back to Python for random numbers, but you cannot set its seed or save its state."
        },
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "set_status_handler",
        "Description": "Sets the handler to be called when igraph tries to display a status message.\nThis is used to communicate the progress of some calculations where no reasonable progress percentage can be given (so it is not possible to use the progress handler).",
        "Paramters": {
            "handler": "the status  function. It must accept a single argument, the message that informs the user about what igraph is doing right now."
        },
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "umap_compute_weights",
        "Description": "Compute undirected UMAP weights from directed distance graph. UMAP is a layout algorithm that usually takes as input a directed distance graph, for instance a k nearest neighbor graph based on Euclidean distance between points in a vector space. The graph is directed because vertex v1 might consider vertex v2 a close neighbor, but v2 itself might have many neighbors that are closer than v1. This function computes the symmetrized weights from the distance graph using union as the symmetry operator. In simple terms, if either vertex considers the other a close neighbor, they will be treated as close neighbors.\nThis function can be used as a separate preprocessing step to Graph.layout_umap(). For efficiency reasons, the returned weights have the same length as the input distances, however because of the symmetryzation some information is lost. Therefore, the weight of one of the edges is set to zero whenever edges in opposite directions are found in the input distance graph. You can pipe the output of this function directly into Graph.layout_umap() as follows: weights = igraph.umap_compute_weights(graph, dist) layout = graph.layout_umap(weights=weights)",
        "Paramters": {
            "graph": "directed  to compute weights for.",
            "dist": "ances associated with the graph edges."
        },
        "Return": [
            "Symmetrized weights associated with each edge. If the distance graph has both directed edges between a pair of vertices, one of the returned weights will be set to zero."
        ],
        "Raises": {},
        "References": [],
        "See Also": "Graph.layout_umap()"
    },
    {
        "Section_id": "compare_communities",
        "Description": "Compares two community structures using various distance measures.\n",
        "Paramters": {
            "comm1": "the first community structure as a membership list or as a Clustering object.",
            "comm2": "the second community structure as a membership list or as a Clustering object.",
            "method": "the measure to use. \"vi\" or \"meila\" means the variation of information metric of Meila (2003), \"nmi\" or \"danon\" means the normalized mutual information as defined by Danon et al. (2005), \"split-join\" means the split-join distance of van Dongen (2000), \"rand\" means the Rand index of Rand (1971), \"adjusted_rand\" means the adjusted Rand index of Hubert and Arabie (1985).",
            "remove_none": "whether to remove None entries from the membership lists. This is handy if your Clustering object was constructed using VertexClustering.FromAttribute using an attribute which was not defined for all the vertices. If  is False, a None entry in either comm1 or comm2 will result in an exception. If  is True, None values are filtered away and only the remaining lists are compared."
        },
        "Return": [
            "the calculated measure."
        ],
        "Raises": {},
        "References": [
            "all the degrees are non-negative",
            "for undirected graphs, the sum of degrees are even",
            "for directed graphs, the two degree sequences are of the same length and equal sums"
        ],
        "See Also": ""
    },
    {
        "Section_id": "split_join_distance",
        "Description": "Calculates the split-join distance between two community structures.\nThe split-join distance is a distance measure defined on the space of partitions of a given set. It is the sum of the projection distance of one partition from the other and vice versa, where the projection number of A from B is if calculated as follows:For each set in A, find the set in B with which it has the maximal overlap, and take note of the size of the overlap.Take the sum of the maximal overlap sizes for each set in A.Subtract the sum from n, the number of elements in the partition.\nNote that the projection distance is asymmetric, that's why it has to be calculated in both directions and then added together.  This function returns the projection distance of comm1 from comm2 and the projection distance of comm2 from comm1, and returns them in a pair. The actual split-join distance is the sum of the two distances. The reason why it is presented this way is that one of the elements being zero then implies that one of the partitions is a subpartition of the other (and if it is close to zero, then one of the partitions is close to being a subpartition of the other).\nReference: van Dongen S: Performance criteria for graph clustering and Markov cluster experiments. Technical Report INS-R0012, National Research Institute for Mathematics and Computer Science in the Netherlands, Amsterdam, May 2000.",
        "Paramters": {
            "comm1": "the first community structure as a membership list or as a Clustering object.",
            "comm2": "the second community structure as a membership list or as a Clustering object.",
            "remove_none": "whether to remove None entries from the membership lists. This is handy if your Clustering object was constructed using VertexClustering.FromAttribute using an attribute which was not defined for all the vertices. If  is False, a None entry in either comm1 or comm2 will result in an exception. If  is True, None values are filtered away and only the remaining lists are compared."
        },
        "Return": [
            "the projection distance of comm1 from comm2 and vice versa in a tuple. The split-join distance is the sum of the two."
        ],
        "Raises": {},
        "References": [],
        "See Also": "compare_communities() with method = \"split-join\" if you are not interested in the individual projection distances but only the sum of them."
    },
    {
        "Section_id": "get_include",
        "Description": "Returns the folder that contains the C API headers of the Python interface of igraph.",
        "Paramters": {},
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "read",
        "Description": "Loads a graph from the given filename.\nThis is just a convenience function, calls Graph.Read directly. All arguments are passed unchanged to Graph.Read",
        "Paramters": {
            "filename": "the name of the file to be loaded",
            "*args": "Undocumented",
            "**kwds": "Undocumented"
        },
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "write",
        "Description": "Saves a graph to the given file.\nThis is just a convenience function, calls Graph.write directly. All arguments are passed unchanged to Graph.write",
        "Paramters": {
            "graph": "the  to be saved",
            "filename": "the name of the file to be written",
            "*args": "Undocumented",
            "**kwds": "Undocumented"
        },
        "Return": [],
        "Raises": {},
        "References": [],
        "See Also": ""
    },
    {
        "Section_id": "__license__",
        "Description": "Undocumented"
    },
    {
        "Section_id": "__version__",
        "Description": "Undocumented"
    },
    {
        "Section_id": "__version_info__",
        "Description": "Undocumented"
    },
    {
        "Section_id": "config",
        "Description": "The main configuration object of igraph. Use this object to modify igraph's behaviour, typically when used in interactive mode."
    },
    {
        "Section_id": "CairoVertexDrawer",
        "Description": "The default vertex drawer implementation of igraph.",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "overrides igraph.drawing.cairo.vertex.AbstractCairoVertexDrawer.__init__\nConstructs the vertex drawer and associates it to the given Cairo context and the given BoundingBox.",
                    "Paramters": {
                        "context": "the  on which we will draw",
                        "bbox": "the bounding box within which we will draw. Can be anything accepted by the constructor of BoundingBox (i.e., a 2-tuple, a 4-tuple or a BoundingBox object).",
                        "palette": "the  that can be used to map integer color indices to colors when drawing vertices",
                        "layout": "the  of the vertices in the graph being drawn"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw": {
                    "Description": "overrides igraph.drawing.baseclasses.AbstractVertexDrawer.draw\nDraws the given vertex.",
                    "Paramters": {
                        "visual_vertex": "object specifying the visual properties of the vertex. Its structure is defined by the VisualVertexBuilder of the CairoGraphDrawer; see its source code.",
                        "vertex": "the raw igraph  being drawn",
                        "coords": "the X and Y coordinates of the vertex as specified by the layout algorithm, scaled into the bounding box."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "Matching",
        "Description": "A matching of vertices in a graph.\nA matching of an undirected graph is a set of edges such that each vertex is incident on at most one matched edge. When each vertex is incident on exactly one matched edge, the matching called perfect. This class is used in igraph to represent non-perfect and perfect matchings in undirected graphs.\nThis class is usually not instantiated directly, everything is taken care of by the functions that return matchings.\n",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "Initializes the matching.",
                    "Paramters": {
                        "graph": "the  the matching belongs to",
                        "matching": "a numeric vector where element i corresponds to vertex i of the graph. Element i is -1 or if the corresponding vertex is unmatched, otherwise it contains the index of the vertex to which vertex i is matched.",
                        "types": "the  of the vertices if the graph is bipartite. It must either be the name of a vertex attribute (which will be retrieved for all vertices) or a list. Elements in the list will be converted to boolean values True or False, and this will determine which part of the bipartite graph a given vertex belongs to."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {
                        "ValueError": "if the matching vector supplied does not describe a valid matching of the graph."
                    },
                    "See Also": "",
                    "example": []
                },
                "__len__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__repr__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__str__": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "edges": {
                    "Description": "Returns an edge sequence that contains the edges in the matching.\nIf there are multiple edges between a pair of matched vertices, only one of them will be returned.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "is_matched": {
                    "Description": "Returns whether the given vertex is matched to another one.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "is_maximal": {
                    "Description": "Returns whether the matching is maximal.\nA matching is maximal when it is not possible to extend it any more with extra edges; in other words, unmatched vertices in the graph must be adjacent to matched vertices only.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "match_of": {
                    "Description": "Returns the vertex a given vertex is matched to.",
                    "Paramters": {
                        "vertex": "the  we are interested in; either an integer index or an instance of Vertex."
                    },
                    "Return": [
                        "the index of the vertex matched to the given vertex, either as an integer index (if vertex was integer) or as an instance of Vertex. When the vertex is unmatched, returns None."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "matching": {
                    "Description": "Sets the matching vector.",
                    "Paramters": {
                        "value": "the matching vector which must contain the ID of the vertex matching vertex i at the ith position, or -1 if the vertex is unmatched."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {
                        "ValueError": "if the matching vector supplied does not describe a valid matching of the graph."
                    },
                    "See Also": "",
                    "example": []
                },
                "types": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {
                "graph": "Returns the graph corresponding to the matching.\n",
                "matching": "Returns the matching vector where element i contains the ID of the vertex that vertex i is matched to.\nThe matching vector will contain -1 for unmatched vertices.\n\n",
                "types": "Returns the type vector if the graph is bipartite.\nElement i of the type vector will be False or True depending on which side of the bipartite graph vertex i belongs to.\nFor non-bipartite graphs, this property returns None.\n\n"
            }
        },
        "Rubric": {
            "Example": [
                "Examples:\n>>> from igraph import Graph\n>>> g = Graph.Famous(\"noperfectmatching\")\n>>> matching = g.maximum_matching()"
            ]
        }
    },
    {
        "Section_id": "MatplotlibEdgeDrawer",
        "Description": "Matplotlib-specific abstract edge drawer object.",
        "Field List": {
            "Methods": {
                "__init__": {
                    "Description": "Constructs the edge drawer.",
                    "Paramters": {
                        "context": "a Matplotlib axes object on which the edges will be drawn.",
                        "palette": "the  that can be used to map integer color indices to colors when drawing edges"
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "build_patch": {
                    "Description": "Undocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw_directed_edge": {
                    "Description": "overrides igraph.drawing.baseclasses.AbstractEdgeDrawer.draw_directed_edge\nDraws a directed edge.",
                    "Paramters": {
                        "edge": "the  to be drawn. Visual properties of the  are defined by the attributes of this object.",
                        "src_vertex": "the source vertex. Visual properties are defined by the attributes of this object.",
                        "dest_vertex": "the source vertex. Visual properties are defined by the attributes of this object."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "draw_undirected_edge": {
                    "Description": "overrides igraph.drawing.baseclasses.AbstractEdgeDrawer.draw_undirected_edge\nDraws an undirected edge.",
                    "Paramters": {
                        "edge": "the  to be drawn. Visual properties of the  are defined by the attributes of this object.",
                        "src_vertex": "the source vertex. Visual properties are defined by the attributes of this object.",
                        "dest_vertex": "the source vertex. Visual properties are defined by the attributes of this object."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_label_position": {
                    "Description": "Inherited from AbstractEdgeDrawer:Returns the position where the label of an edge should be drawn. the default implementation returns the midpoint of the edge and an alignment that tries to avoid overlapping the label with the edge."
                },
                "get_label_rotation": {
                    "Description": "Inherited from AbstractEdgeDrawer:Get the rotation angle of the label to align with the edge."
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "ClassicPythonShell",
        "Description": "Classic Python shell interface.\nThis class allows igraph to be embedded in Python's shell.",
        "Field List": {
            "Methods": {
                "__call__": {
                    "Description": "overrides igraph.app.shell.Shell.__call__\nStarts the embedded shell.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__init__": {
                    "Description": "overrides igraph.app.shell.ConsoleProgressBarMixin.__init__\nConstructor.\nImports Python's classic shell",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "get_progress_handler": {
                    "Description": "Inherited from Shell:Returns the progress handler (if exists) or None (if not)."
                },
                "get_status_handler": {
                    "Description": "Inherited from Shell:Returns the status handler (if exists) or None (if not)."
                },
                "supports_progress_bar": {
                    "Description": "Inherited from Shell:Checks whether the shell supports progress bars."
                },
                "supports_status_messages": {
                    "Description": "Inherited from Shell:Checks whether the shell supports status messages."
                }
            },
            "property": {}
        },
        "Rubric": {
            "Example": []
        }
    },
    {
        "Section_id": "Clustering",
        "Description": "Class representing a clustering of an arbitrary ordered set.\nThis is now used as a base for VertexClustering, but it might be useful for other purposes as well.\n",
        "Field List": {
            "Methods": {
                "__getitem__": {
                    "Description": "Returns the members of the specified cluster.",
                    "Paramters": {
                        "idx": "the index of the cluster"
                    },
                    "Return": [
                        "the members of the specified cluster as a list"
                    ],
                    "References": [],
                    "Rasises": {
                        "IndexError": "if the index is out of bounds"
                    },
                    "See Also": "",
                    "example": []
                },
                "__init__": {
                    "Description": "overridden in igraph.VertexClustering\nConstructor.",
                    "Paramters": {
                        "membership": "the  list -- that is, the cluster index in which each element of the set belongs to.",
                        "params": "additional parameters to be stored in this object's dictionary."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__iter__": {
                    "Description": "Iterates over the clusters in this clustering.\nThis method will return a generator that generates the clusters one by one.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__len__": {
                    "Description": "Returns the number of clusters.",
                    "Paramters": {},
                    "Return": [
                        "the number of clusters"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "__str__": {
                    "Description": "overridden in igraph.Cut\nUndocumented",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "as_cover": {
                    "Description": "overridden in igraph.VertexClustering\nReturns a Cover that contains the same clusters as this clustering.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "compare_to": {
                    "Description": "Compares this clustering to another one using some similarity or distance metric.\nThis is a convenience method that simply calls compare_communities with the two clusterings as arguments. Any extra positional or keyword argument is also forwarded to compare_communities.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "size": {
                    "Description": "Returns the size of a given cluster.",
                    "Paramters": {
                        "idx": "the cluster in which we are interested."
                    },
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "size_histogram": {
                    "Description": "Returns the histogram of cluster sizes.",
                    "Paramters": {
                        "bin_width": "the bin width of the histogram"
                    },
                    "Return": [
                        "a Histogram object"
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "sizes": {
                    "Description": "Returns the size of given clusters.\nThe indices are given as positional arguments. If there are no positional arguments, the function will return the sizes of all clusters.",
                    "Paramters": {},
                    "Return": [],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                },
                "summary": {
                    "Description": "Returns the summary of the clustering.\nThe summary includes the number of items and clusters, and also the list of members for each of the clusters if the verbosity is nonzero.",
                    "Paramters": {
                        "verbosity": "determines whether the cluster members should be printed. Zero  prints the number of items and clusters only.",
                        "width": "Undocumented"
                    },
                    "Return": [
                        "the summary of the clustering as a string."
                    ],
                    "References": [],
                    "Rasises": {},
                    "See Also": "",
                    "example": []
                }
            },
            "property": {
                "membership": "Returns the membership vector.\n",
                "n": "Returns the number of elements covered by this clustering.\n"
            }
        },
        "Rubric": {
            "Example": [
                "Members of an individual cluster can be accessed by the [] operator:\n>>> cl = Clustering([0,0,0,0,1,1,1,2,2,2,2])\n>>> cl[0]\n[0, 1, 2, 3]\n",
                "The membership vector can be accessed by the membership property:\n>>> cl = Clustering([0,0,0,0,1,1,1,2,2,2,2])\n>>> cl[0]\n[0, 1, 2, 3]\n",
                "The number of clusters can be retrieved by the len function:\n>>> cl = Clustering([0,0,0,0,1,1,1,2,2,2,2])\n>>> cl[0]\n[0, 1, 2, 3]\n",
                "You can iterate over the clustering object as if it were a regular list of clusters:\n>>> cl = Clustering([0,0,0,0,1,1,1,2,2,2,2])\n>>> cl[0]\n[0, 1, 2, 3]\n",
                "If you need all the clusters at once as lists, you can simply convert the clustering object to a list:\n>>> cl = Clustering([0,0,0,0,1,1,1,2,2,2,2])\n>>> cl[0]\n[0, 1, 2, 3]\n"
            ]
        }
    },
    {
        "Section_id": "NodeClustering",
        "Description": "Node Communities representation.",
        "Field List": {
            "Parameters": {
                "communities": "list of communities",
                "graph": "a networkx/igraph object",
                "method_name": "community discovery algorithm name",
                "method_parameters": "configuration for the community discovery algorithm used",
                "overlap": "boolean, whether the partition is overlapping or not"
            },
            "Methods": {
                "adjusted_mutual_information": {
                    "Paramters": {
                        "clustering": "NodeClustering object"
                    },
                    "Return": [
                        "AMI score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.adjusted_mutual_information(leiden_communities)"
                    ],
                    "References": [
                        "Vinh, N. X., Epps, J., & Bailey, J. (2010). Information theoretic measures for clusterings comparison: Variants, properties, normalization and correction for chance. Journal of Machine Learning Research, 11(Oct), 2837-2854."
                    ],
                    "Description": "Adjusted Mutual Information between two clusterings.\nAdjusted Mutual Information (AMI) is an adjustment of the Mutual\nInformation (MI) score to account for chance. It accounts for the fact that\nthe MI is generally higher for two clusterings with a larger number of\nclusters, regardless of whether there is actually more information shared.\nFor two clusterings \\(U\\) and \\(V\\), the AMI is given as:\nAMI(U, V) = [MI(U, V) - E(MI(U, V))] / [max(H(U), H(V)) - E(MI(U, V))]\n\nThis metric is independent of the absolute values of the labels:\na permutation of the class or cluster label values won\u2019t change the\nscore value in any way.\nThis metric is furthermore symmetric: switching label_true with\nlabel_pred will return the same score value. This can be useful to\nmeasure the agreement of two independent label assignments strategies\non the same dataset when the real ground truth is not known.\nBe mindful that this function is an order of magnitude slower than other\nmetrics, such as the Adjusted Rand Index.\n"
                },
                "adjusted_rand_index": {
                    "Paramters": {
                        "clustering": "NodeClustering object"
                    },
                    "Return": [
                        "ARI score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.adjusted_rand_index(leiden_communities)"
                    ],
                    "References": [
                        "Hubert, L., & Arabie, P. (1985). Comparing partitions. Journal of classification, 2(1), 193-218."
                    ],
                    "Description": "Rand index adjusted for chance.\nThe Rand Index computes a similarity measure between two clusterings\nby considering all pairs of samples and counting pairs that are\nassigned in the same or different clusters in the predicted and\ntrue clusterings.\nThe raw RI score is then \u201cadjusted for chance\u201d into the ARI score\nusing the following scheme:\nARI = (RI - Expected_RI) / (max(RI) - Expected_RI)\n\nThe adjusted Rand index is thus ensured to have a value close to\n0.0 for random labeling independently of the number of clusters and\nsamples and exactly 1.0 when the clusterings are identical (up to\na permutation).\nARI is a symmetric measure:\nadjusted_rand_index(a, b) == adjusted_rand_index(b, a)\n\n"
                },
                "average_internal_degree": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.average_internal_degree()"
                    ],
                    "References": [],
                    "Description": "The average internal degree of the algorithms set.\n\n\\[f(S) = \\frac{2m_S}{n_S}\\]\nwhere \\(m_S\\) is the number of algorithms internal edges and \\(n_S\\) is the number of algorithms nodes.\n"
                },
                "avg_distance": {
                    "Paramters": {
                        "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
                    },
                    "Return": [
                        "If summary==True a FitnessResult object, otherwise a list of floats."
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Average distance.\nThe average distance of a community is defined average path length across all possible pair of nodes composing it.\n"
                },
                "avg_embeddedness": {
                    "Paramters": {
                        "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
                    },
                    "Return": [
                        "If summary==True a FitnessResult object, otherwise a list of floats."
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Average embeddedness of nodes within the community.\nThe embeddedness of a node n w.r.t. a community C is the ratio of its degree within the community and its overall degree.\n\n\\[emb(n,C) = \\frac{k_n^C}{k_n}\\]\nThe average embeddedness of a community C is:\n\n\\[avg_embd(c) = \\frac{1}{|C|} \\sum_{i \\in C} \\frac{k_n^C}{k_n}\\]\n"
                },
                "avg_odf": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.avg_odf()"
                    ],
                    "References": [],
                    "Description": "Average fraction of edges of a node of a algorithms that point outside the algorithms itself.\n\n\\[\\frac{1}{n_S} \\sum_{u \\in S} \\frac{|\\{(u,v)\\in E: v \\not\\in S\\}|}{d(u)}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\), \\(d(u)\\) is the degree of \\(u\\) and \\(n_S\\) is the set of algorithms nodes.\n"
                },
                "avg_transitivity": {
                    "Paramters": {
                        "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
                    },
                    "Return": [
                        "If summary==True a FitnessResult object, otherwise a list of floats."
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Average transitivity.\nThe average transitivity of a community is defined the as the average clustering coefficient of its nodes w.r.t. their connection within the community itself.\n"
                },
                "conductance": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.conductance()"
                    ],
                    "References": [],
                    "Description": "Fraction of total edge volume that points outside the algorithms.\n\n\\[f(S) = \\frac{c_S}{2 m_S+c_S}\\]\nwhere \\(c_S\\) is the number of algorithms nodes and, \\(m_S\\) is the number of algorithms edges\n"
                },
                "cut_ratio": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.cut_ratio()"
                    ],
                    "References": [],
                    "Description": "Fraction of existing edges (out of all possible edges) leaving the algorithms.\n..math:: f(S) = frac{c_S}{n_S (n \u2212 n_S)}\nwhere \\(c_S\\) is the number of algorithms nodes and, \\(n_S\\) is the number of edges on the algorithms boundary\n"
                },
                "edges_inside": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.edges_inside()"
                    ],
                    "References": [],
                    "Description": "Number of edges internal to the algorithms.\n"
                },
                "erdos_renyi_modularity": {
                    "Paramters": {},
                    "Return": [
                        "the Erdos-Renyi modularity score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.erdos_renyi_modularity()"
                    ],
                    "References": [],
                    "Description": "Erdos-Renyi modularity is a variation of the Newman-Girvan one.\nIt assumes that vertices in a network are connected randomly with a constant probability \\(p\\).\n\n\\[Q(S) = \\frac{1}{m}\\sum_{c \\in S} (m_S \u2212 \\frac{mn_S(n_S \u22121)}{n(n\u22121)})\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms edges, \\(l_S\\) is the number of edges from nodes in S to nodes outside S.\n"
                },
                "expansion": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.expansion()"
                    ],
                    "References": [],
                    "Description": "Number of edges per algorithms node that point outside the cluster.\n\n\\[f(S) = \\frac{c_S}{n_S}\\]\nwhere \\(n_S\\) is the number of edges on the algorithms boundary, \\(c_S\\) is the number of algorithms nodes.\n"
                },
                "f1": {
                    "Paramters": {
                        "clustering": "NodeClustering object"
                    },
                    "Return": [
                        "F1 score (harmonic mean of precision and recall)"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.f1(leiden_communities)"
                    ],
                    "References": [
                        "Rossetti, G., Pappalardo, L., & Rinzivillo, S. (2016). A novel approach to evaluate algorithms detection internal on ground truth. In Complex Networks VII (pp. 133-144). Springer, Cham."
                    ],
                    "Description": "Compute the average F1 score of the optimal algorithms matches among the partitions in input.\nWorks on overlapping/non-overlapping complete/partial coverage partitions.\n"
                },
                "flake_odf": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.flake_odf()"
                    ],
                    "References": [],
                    "Description": "Fraction of nodes in S that have fewer edges pointing inside than to the outside of the algorithms.\n\n\\[f(S) = \\frac{| \\{ u:u \\in S,| \\{(u,v) \\in E: v \\in S \\}| < d(u)/2 \\}|}{n_S}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\), \\(d(u)\\) is the degree of \\(u\\) and \\(n_S\\) is the set of algorithms nodes.\n"
                },
                "fraction_over_median_degree": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.fraction_over_median_degree()"
                    ],
                    "References": [],
                    "Description": "Fraction of algorithms nodes of having internal degree higher than the median degree value.\n\n\\[f(S) = \\frac{|\\{u: u \\in S,| \\{(u,v): v \\in S\\}| > d_m\\}| }{n_S}\\]\nwhere \\(d_m\\) is the internal degree median value\n"
                },
                "get_description": {
                    "Paramters": {
                        "parameters_to_display": "parameters to display. By default, all float parameters.",
                        "precision": "precision used to plot parameters. default: 3"
                    },
                    "Return": [
                        "a string description of the method.\n"
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Return a description of the clustering, with the name of the method and its numeric parameters.\n"
                },
                "hub_dominance": {
                    "Paramters": {
                        "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
                    },
                    "Return": [
                        "If summary==True a FitnessResult object, otherwise a list of floats."
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Hub dominance.\nThe hub dominance of a community is defined as the ratio of the degree of its most connected node w.r.t. the theoretically maximal degree within the community.\n"
                },
                "internal_edge_density": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.internal_edge_density()"
                    ],
                    "References": [],
                    "Description": "The internal density of the algorithms set.\n\n\\[f(S) = \\frac{m_S}{n_S(n_S\u22121)/2}\\]\nwhere \\(m_S\\) is the number of algorithms internal edges and \\(n_S\\) is the number of algorithms nodes.\n"
                },
                "link_modularity": {
                    "Paramters": {},
                    "Return": [
                        "the link modularity score"
                    ],
                    "Example": [
                        "from cdlib import evaluation\nfrom cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.link_modularity()"
                    ],
                    "References": [],
                    "Description": "Quality function designed for directed graphs with overlapping communities.\n"
                },
                "max_odf": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.max_odf()"
                    ],
                    "References": [],
                    "Description": "Maximum fraction of edges of a node of a algorithms that point outside the algorithms itself.\n\n\\[max_{u \\in S} \\frac{|\\{(u,v)\\in E: v \\not\\in S\\}|}{d(u)}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\) and \\(d(u)\\) is the degree of \\(u\\)\n"
                },
                "modularity_density": {
                    "Paramters": {},
                    "Return": [
                        "the modularity density score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.modularity_density()"
                    ],
                    "References": [],
                    "Description": "The modularity density is one of several propositions that envisioned to palliate the resolution limit issue of modularity based measures.\nThe idea of this metric is to include the information about algorithms size into the expected density of algorithms to avoid the negligence of small and dense communities.\nFor each algorithms \\(C\\) in partition \\(S\\), it uses the average modularity degree calculated by \\(d(C) = d^{int(C)} \u2212 d^{ext(C)}\\) where \\(d^{int(C)}\\) and \\(d^{ext(C)}\\) are the average internal and external degrees of \\(C\\) respectively to evaluate the fitness of \\(C\\) in its network.\nFinally, the modularity density can be calculated as follows:\n\n\\[Q(S) = \\sum_{C \\in S} \\frac{1}{n_C} ( \\sum_{i \\in C} k^{int}_{iC} - \\sum_{i \\in C} k^{out}_{iC})\\]\nwhere \\(n_C\\) is the number of nodes in C, \\(k^{int}_{iC}\\) is the degree of node i within \\(C\\) and \\(k^{out}_{iC}\\) is the deree of node i outside \\(C\\).\n"
                },
                "modularity_overlap": {
                    "Paramters": {
                        "weight": "label identifying the edge weight parameter name (if present), default None"
                    },
                    "Return": [
                        "FitnessResult object"
                    ],
                    "Example": [],
                    "References": [
                        "\nLazar, D. Abel and T. Vicsek, \u201cModularity measure of networks with overlapping communities\u201d  EPL, 90 (2010) 18001 doi: 10.1209/0295-5075/90/18001\n\n",
                        "Lazar, D. Abel and T. Vicsek, \u201cModularity measure of networks with overlapping communities\u201d  EPL, 90 (2010) 18001 doi: 10.1209/0295-5075/90/18001"
                    ],
                    "Description": "Determines the Overlapping Modularity of a partition C on a graph G.\nOverlapping Modularity is defined as\n\n\\[M_{c_{r}}^{ov} = \\sum_{i \\in c_{r}} \\frac{\\sum_{j \\in c_{r}, i \\neq j}a_{ij} - \\sum_{j \\not \\in c_{r}}a_{ij}}{d_{i} \\cdot s_{i}} \\cdot \\frac{n_{c_{r}}^{e}}{n_{c_{r}} \\cdot \\binom{n_{c_{r}}}{2}}\\]\n"
                },
                "newman_girvan_modularity": {
                    "Paramters": {},
                    "Return": [
                        "the Newman-Girvan modularity score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.newman_girvan_modularity()"
                    ],
                    "References": [],
                    "Description": "Difference the fraction of intra algorithms edges of a partition with the expected number of such edges if distributed according to a null model.\nIn the standard version of modularity, the null model preserves the expected degree sequence of the graph under consideration. In other words, the modularity compares the real network structure with a corresponding one where nodes are connected without any preference about their neighbors.\n\n\\[Q(S) = \\frac{1}{m}\\sum_{c \\in S}(m_S - \\frac{(2 m_S + l_S)^2}{4m})\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms edges, \\(l_S\\) is the number of edges from nodes in S to nodes outside S.\n"
                },
                "nf1": {
                    "Paramters": {
                        "clustering": "NodeClustering object"
                    },
                    "Return": [
                        "MatchingResult instance"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.nf1(leiden_communities)"
                    ],
                    "References": [
                        "Rossetti, G., Pappalardo, L., & Rinzivillo, S. (2016). A novel approach to evaluate algorithms detection internal on ground truth.",
                        "Rossetti, G. (2017). : RDyn: graph benchmark handling algorithms dynamics. Journal of Complex Networks. 5(6), 893-912."
                    ],
                    "Description": "Compute the Normalized F1 score of the optimal algorithms matches among the partitions in input.\nWorks on overlapping/non-overlapping complete/partial coverage partitions.\n"
                },
                "normalized_cut": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.normalized_cut()"
                    ],
                    "References": [],
                    "Description": "Normalized variant of the Cut-Ratio\n\n\\[: f(S) = \\frac{c_S}{2m_S+c_S} + \\frac{c_S}{2(m\u2212m_S )+c_S}\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms internal edges and \\(c_S\\) is the number of algorithms nodes.\n"
                },
                "normalized_mutual_information": {
                    "Paramters": {
                        "clustering": "NodeClustering object"
                    },
                    "Return": [
                        "normalized mutual information score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.normalized_mutual_information(leiden_communities)"
                    ],
                    "References": [],
                    "Description": "Normalized Mutual Information between two clusterings.\nNormalized Mutual Information (NMI) is an normalization of the Mutual\nInformation (MI) score to scale the results between 0 (no mutual\ninformation) and 1 (perfect correlation). In this function, mutual\ninformation is normalized by sqrt(H(labels_true) * H(labels_pred))\n"
                },
                "omega": {
                    "Paramters": {
                        "clustering": "NodeClustering object"
                    },
                    "Return": [
                        "omega index"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.omega(leiden_communities)"
                    ],
                    "References": [
                        "Gabriel Murray, Giuseppe Carenini, and Raymond Ng. 2012. Using the omega index for evaluating abstractive algorithms detection. In Proceedings of Workshop on Evaluation Metrics and System Comparison for Automatic Summarization. Association for Computational Linguistics, Stroudsburg, PA, USA, 10-18."
                    ],
                    "Description": "Index of resemblance for overlapping, complete coverage, network clusterings.\n"
                },
                "overlapping_normalized_mutual_information_LFK": {
                    "Paramters": {
                        "clustering": "NodeClustering object"
                    },
                    "Return": [
                        "onmi score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.overlapping_normalized_mutual_information_LFK(leiden_communities)"
                    ],
                    "References": [
                        "Lancichinetti, A., Fortunato, S., & Kertesz, J. (2009). Detecting the overlapping and hierarchical community structure in complex networks. New Journal of Physics, 11(3), 033015."
                    ],
                    "Description": "Overlapping Normalized Mutual Information between two clusterings.\nExtension of the Normalized Mutual Information (NMI) score to cope with overlapping partitions.\nThis is the version proposed by Lancichinetti et al.\n"
                },
                "overlapping_normalized_mutual_information_MGH": {
                    "Paramters": {
                        "clustering": "NodeClustering object",
                        "normalization": "one of \u201cmax\u201d or \u201cLFK\u201d. Default \u201cmax\u201d (corresponds to the main method described in the article)"
                    },
                    "Return": [
                        "onmi score\n"
                    ],
                    "Example": [
                        "from cdlib import evaluation, algorithms\ng = nx.karate_club_graph()\nlouvain_communities = algorithms.louvain(g)\nleiden_communities = algorithms.leiden(g)\nevaluation.overlapping_normalized_mutual_information_MGH(louvain_communities,leiden_communities)"
                    ],
                    "References": [
                        "McDaid, A. F., Greene, D., & Hurley, N. (2011). Normalized mutual information to evaluate overlapping community finding algorithms. arXiv preprint arXiv:1110.2515. Chicago"
                    ],
                    "Description": "Overlapping Normalized Mutual Information between two clusterings.\nExtension of the Normalized Mutual Information (NMI) score to cope with overlapping partitions.\nThis is the version proposed by McDaid et al. using a different normalization than the original LFR one. See ref.\nfor more details.\n"
                },
                "scaled_density": {
                    "Paramters": {
                        "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
                    },
                    "Return": [
                        "If summary==True a FitnessResult object, otherwise a list of floats."
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Scaled density.\nThe scaled density of a community is defined as the ratio of the community density w.r.t. the complete graph density.\n"
                },
                "significance": {
                    "Paramters": {},
                    "Return": [
                        "the significance score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.significance()"
                    ],
                    "References": [],
                    "Description": "Significance estimates how likely a partition of dense communities appear in a random graph.\n"
                },
                "size": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Size is the number of nodes in the community\n"
                },
                "surprise": {
                    "Paramters": {},
                    "Return": [
                        "the surprise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.surprise()"
                    ],
                    "References": [],
                    "Description": "Surprise is statistical approach proposes a quality metric assuming that edges between vertices emerge randomly according to a hyper-geometric distribution.\nAccording to the Surprise metric, the higher the score of a partition, the less likely it is resulted from a random realization, the better the quality of the algorithms structure.\n"
                },
                "to_json": {
                    "Paramters": {},
                    "Return": [
                        "a JSON formatted string representing the object"
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Generate a JSON representation of the algorithms object\n"
                },
                "to_node_community_map": {
                    "Paramters": {},
                    "Return": [
                        "dict of the form <node, list(communities)>"
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Generate a <node, list(communities)> representation of the current clustering\n"
                },
                "triangle_participation_ratio": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.triangle_participation_ratio()"
                    ],
                    "References": [],
                    "Description": "Fraction of algorithms nodes that belong to a triad.\n\n\\[f(S) = \\frac{ | \\{ u: u \\in S,\\{(v,w):v, w \\in S,(u,v) \\in E,(u,w) \\in E,(v,w) \\in E \\} \\not = \\emptyset \\} |}{n_S}\\]\nwhere \\(n_S\\) is the set of algorithms nodes.\n"
                },
                "variation_of_information": {
                    "Paramters": {
                        "clustering": "NodeClustering object"
                    },
                    "Return": [
                        "VI score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.variation_of_information(leiden_communities)"
                    ],
                    "References": [
                        "Meila, M. (2007). Comparing clusterings - an information based distance. Journal of Multivariate Analysis, 98, 873-895. doi:10.1016/j.jmva.2006.11.013"
                    ],
                    "Description": "Variation of Information among two nodes partitions.\n$$ H(p)+H(q)-2MI(p, q) $$\nwhere MI is the mutual information, H the partition entropy and p,q are the algorithms sets\n"
                },
                "z_modularity": {
                    "Paramters": {},
                    "Return": [
                        "the z-modularity score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.z_modularity()"
                    ],
                    "References": [],
                    "Description": "Z-modularity is another variant of the standard modularity proposed to avoid the resolution limit.\nThe concept of this version is based on an observation that the difference between the fraction of edges inside communities and the expected number of such edges in a null model should not be considered as the only contribution to the final quality of algorithms structure.\n"
                }
            }
        }
    },
    {
        "Section_id": "dpclus",
        "Description": "DPClus projects weights onto an unweighted graph using a common neighbors approach.\nIn DPClus, the weight of an edge (u, v) is de\ufb01ned as the number of common neighbors between u and v.\nSimilarly, the weight of a vertex is its weighted degree \u2013 the sum of all edges connected to the vertex-\nDPClus does not natively generate overlapping clusters but does allow for overlapping cluster nodes to be added in a post-processing step.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "weights": "label used for the edge weights. Default, None.",
            "d_threshold": "cluster density threshold, default 0.9",
            "cp_threshold": "cluster property threshold, default 0.5",
            "overlap": "wheter to output overlapping or crisp communities. Default, True."
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.dpclus(G)"
        ],
        "References": []
    },
    {
        "Section_id": "mod_m",
        "Description": "Community Discovery algorithm designed to find local optimal community structures in large networks starting from a given source vertex.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "query_node": "Id of the network node whose local community is queried."
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.mod_m(G, 1)"
        ],
        "References": []
    },
    {
        "Section_id": "overlapping_normalized_mutual_information_MGH",
        "Description": "Overlapping Normalized Mutual Information between two clusterings.\nExtension of the Normalized Mutual Information (NMI) score to cope with overlapping partitions.\nThis is the version proposed by McDaid et al. using a different normalization than the original LFR one. See ref.\nfor more details.\n",
        "Parameters": {
            "first_partition": "NodeClustering object",
            "second_partition": "NodeClustering object",
            "normalization": "one of \u201cmax\u201d or \u201cLFK\u201d. Default \u201cmax\u201d (corresponds to the main method described in the article)"
        },
        "Return": [
            "MatchingResult object\n"
        ],
        "Example": [
            "from cdlib import evaluation, algorithms\ng = nx.karate_club_graph()\nlouvain_communities = algorithms.louvain(g)\nleiden_communities = algorithms.leiden(g)\nevaluation.overlapping_normalized_mutual_information_MGH(louvain_communities,leiden_communities)"
        ],
        "References": [
            "McDaid, A. F., Greene, D., & Hurley, N. (2011). Normalized mutual information to evaluate overlapping community finding algorithms. arXiv preprint arXiv:1110.2515. Chicago"
        ]
    },
    {
        "Section_id": "ebgc",
        "Description": "The entropy-based clustering approach finds locally optimal clusters by growing a random seed in a manner that minimizes graph entropy.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object"
        },
        "Return": [
            "NodeClustering object"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.ebgc(G)"
        ],
        "References": []
    },
    {
        "Section_id": "purity",
        "Description": "Purity is the product of the frequencies of the most frequent labels carried by the nodes within the communities\n",
        "Parameters": {
            "communities": "AttrNodeClustering object"
        },
        "Return": [
            "FitnessResult object"
        ],
        "Example": [
            "from cdlib.algorithms import eva\nfrom cdlib import evaluation\nimport random\nl1 = ['A', 'B', 'C', 'D']\nl2 = [\"E\", \"F\", \"G\"]\ng = nx.barabasi_albert_graph(100, 5)\nlabels=dict()\nfor node in g.nodes():\n   labels[node]={\"l1\":random.choice(l1), \"l2\":random.choice(l2)}\ncommunities = eva(g_attr, labels, alpha=0.5)\npur = evaluation.purity(communities)"
        ],
        "References": [
            "Citraro, Salvatore, and Giulio Rossetti. \u201cEva: Attribute-Aware Network Segmentation.\u201d International Conference on Complex Networks and Their Applications. Springer, Cham, 2019."
        ]
    },
    {
        "Section_id": "newman_girvan_modularity",
        "Description": "Difference the fraction of intra community edges of a partition with the expected number of such edges if distributed according to a null model.\nIn the standard version of modularity, the null model preserves the expected degree sequence of the graph under consideration. In other words, the modularity compares the real network structure with a corresponding one where nodes are connected without any preference about their neighbors.\n\n\\[Q(S) = \\frac{1}{m}\\sum_{c \\in S}(m_S - \\frac{(2 m_S + l_S)^2}{4m})\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of community edges, \\(l_S\\) is the number of edges from nodes in S to nodes outside S.\n",
        "Parameters": {
            "graph": "a networkx/igraph object",
            "communities": "NodeClustering object"
        },
        "Return": [
            "FitnessResult object\n"
        ],
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = evaluation.newman_girvan_modularity(g,communities)"
        ],
        "References": [
            "Newman, M.E.J. & Girvan, M. Finding and evaluating community structure in networks. Physical Review E 69, 26113(2004)."
        ]
    },
    {
        "Section_id": "eigenvector",
        "Description": "Newman\u2019s leading eigenvector method for detecting community structure based on modularity.\nThis is the proper internal of the recursive, divisive algorithm: each split is done by maximizing the modularity regarding the original network.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object"
        },
        "Return": [
            "NodeClustering object"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncom = algorithms.eigenvector(G)"
        ],
        "References": []
    },
    {
        "Section_id": "demon",
        "Description": "Demon is a node-centric bottom-up overlapping community discovery algorithm.\nIt leverages ego-network structures and overlapping label propagation to identify micro-scale communities that are subsequently merged in mesoscale ones.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "epsilon": "merging threshold in [0,1], default 0.25.",
            "min_com_size": "minimum community size, default 3."
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.demon(G, min_com_size=3, epsilon=0.25)"
        ],
        "References": [
            "Coscia, M., Rossetti, G., Giannotti, F., & Pedreschi, D. (2012, August). Demon: a local-first discovery method for overlapping communities. In Proceedings of the 18th ACM SIGKDD international conference on Knowledge discovery and data mining (pp. 615-623). ACM.",
            "Coscia, M., Rossetti, G., Giannotti, F., & Pedreschi, D. (2014). Uncovering hierarchical and overlapping communities with a local-first approach. ACM Transactions on Knowledge Discovery from Data (TKDD), 9(1), 6."
        ]
    },
    {
        "Section_id": "plot_community_graph",
        "Description": "Plot a algorithms-graph with node color coding for communities.\n",
        "Parameters": {
            "graph": "NetworkX/igraph graph",
            "partition": "NodeClustering object",
            "figsize": "the figure size; it is a pair of float, default (8, 8)",
            "node_size": "int, default 200",
            "plot_overlaps": "bool, default False. Flag to control if multiple algorithms memberships are plotted.",
            "plot_labels": "bool, default False. Flag to control if node labels are plotted.",
            "cmap": "str or Matplotlib colormap, Colormap(Matplotlib colormap) for mapping intensities of nodes. If set to None, original colormap is used..",
            "top_k": "int, Show the top K influential communities. If set to zero or negative value indicates all.",
            "min_size": "int, Exclude communities below the specified minimum size."
        },
        "Return": [],
        "Example": [
            "from cdlib import algorithms, viz\nimport networkx as nx\ng = nx.karate_club_graph()\ncoms = algorithms.louvain(g)\nviz.plot_community_graph(g, coms)"
        ],
        "References": []
    },
    {
        "Section_id": "paris",
        "Description": "Paris is a hierarchical graph clustering algorithm inspired by modularity-based clustering techniques.\nThe algorithm is agglomerative and based on a simple distance between clusters induced by the probability of sampling node pairs.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object"
        },
        "Return": [
            "NodeClustering object"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.paris(G)"
        ],
        "References": []
    },
    {
        "Section_id": "kclique",
        "Description": "Find k-clique communities in graph using the percolation method.\nA k-clique community is the union of all cliques of size k that can be reached through adjacent (sharing k-1 nodes) k-cliques.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "k": "Size of smallest clique"
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncom = algorithms.kclique(G, k=3)"
        ],
        "References": []
    },
    {
        "Section_id": "endntm",
        "Description": "Overlapping community detection algorithm based on an ensemble  approach with a distributed neighbourhood threshold method (EnDNTM).\nEnDNTM uses pre-partitioned disjoint communities generated by the ensemble mechanism and then analyzes the neighbourhood distribution  of boundary nodes in disjoint communities to detect overlapping communities.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "clusterings": "an iterable of Clustering objects (non overlapping node partitions only)",
            "epsilon": "neighbourhood threshold, default 2."
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms_l = [algorithms.louvain(G), algorithms.label_propagation(G), algorithms.walktrap(G)]\ncoms = algorithms.endntm(G, coms_l)"
        ],
        "References": []
    },
    {
        "Section_id": "multicom",
        "Description": "MULTICOM is an algorithm for detecting multiple local communities, possibly overlapping, by expanding the initial seed set.\nThis algorithm uses local scoring metrics to define an embedding of the graph around the seed set. Based on this embedding, it picks new seeds in the neighborhood of the original seed set, and uses these new seeds to recover multiple communities.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "seed_node": "Id of the seed node around which we want to detect communities."
        },
        "Return": [
            "EdgeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.multicom(G, seed_node=0)"
        ],
        "References": []
    },
    {
        "Section_id": "gdmp2",
        "Description": "Gdmp2 is a method for identifying a set of dense subgraphs of a given sparse graph.\nIt is inspired by an effective technique designed for a similar problem\u2014matrix blocking, from a different discipline (solving linear systems).\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "min_threshold": "the minimum density threshold parameter to control the density of the output subgraphs, default 0.75"
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncom = algorithms.gdmp2(G)"
        ],
        "References": []
    },
    {
        "Section_id": "random_search",
        "Description": "Returns the optimal partition of the specified graph w.r.t. the selected algorithm and quality score over a randomized sample of the input parameters.\n",
        "Parameters": {
            "method": "community discovery method (from nclib.community)",
            "graph": "networkx/igraph object",
            "parameters": "list of Parameter and BoolParameter objects",
            "quality_score": "a fitness function to evaluate the obtained partition (from nclib.evaluation)",
            "instances": "number of randomly selected parameters configurations",
            "aggregate": "function to select the best fitness value. Possible values: min/max"
        },
        "Return": [
            "at each call the generator yields a tuple composed by: the optimal configuration for the given algorithm, input paramters and fitness function; the obtained communities; the fitness score\n"
        ],
        "Example": [
            "import networkx as nx\nfrom cdlib import algorithms, ensemble\ng = nx.karate_club_graph()\nresolution = ensemble.Parameter(name=\"resolution\", start=0.1, end=1, step=0.1)\nrandomize = ensemble.BoolParameter(name=\"randomize\")\ncommunities, scoring = ensemble.random_search(graph=g, method=algorithms.louvain,\n                                                      parameters=[resolution, randomize],\n                                                      quality_score=evaluation.erdos_renyi_modularity,\n                                                      instances=5, aggregate=max)\nprint(communities, scoring)"
        ],
        "References": []
    },
    {
        "Section_id": "frc_fgsn",
        "Description": "Fuzzy-Rough Community Detection on Fuzzy Granular model of Social Network.\nFRC-FGSN assigns nodes to communities specifying the probability of each association.\nThe flattened partition ensure that each node is associated to the community that maximize such association probability.\nFRC-FGSN may generate orphan nodes (i.e., nodes not assigned to any community).\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "networkx/igraph object",
            "theta": "community density coefficient",
            "eps": "coupling coefficient of the community. Ranges in [0, 1], small values ensure that only strongly connected node granules are merged togheter.",
            "r": "radius of the granule (int)"
        },
        "Return": [
            "FuzzyNodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = frc_fgsn(G, theta=1, eps=0.5, r=3)"
        ],
        "References": []
    },
    {
        "Section_id": "triangle_participation_ratio",
        "Description": "Fraction of community nodes that belong to a triad.\n\n\\[f(S) = \\frac{ | \\{ u: u \\in S,\\{(v,w):v, w \\in S,(u,v) \\in E,(u,w) \\in E,(v,w) \\in E \\} \\not = \\emptyset \\} |}{n_S}\\]\nwhere \\(n_S\\) is the set of community nodes.\n",
        "Parameters": {
            "graph": "a networkx/igraph object",
            "community": "NodeClustering object",
            "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
        },
        "Return": [
            "If summary==True a FitnessResult object, otherwise a list of floats.\n"
        ],
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = evaluation.triangle_participation_ratio(g,communities)"
        ],
        "References": [
            "Yang, J., Leskovec, J.: Defining and evaluating network communities based on ground-truth. Knowledge and Information Systems 42(1), 181\u2013213 (2015)"
        ]
    },
    {
        "Section_id": "avg_embeddedness",
        "Description": "Average embeddedness of nodes within the community.\nThe embeddedness of a node n w.r.t. a community C is the ratio of its degree within the community and its overall degree.\n\n\\[emb(n,C) = \\frac{k_n^C}{k_n}\\]\nThe average embeddedness of a community C is:\n\n\\[avg_embd(c) = \\frac{1}{|C|} \\sum_{i \\in C} \\frac{k_n^C}{k_n}\\]\n",
        "Parameters": {
            "graph": "a networkx/igraph object",
            "communities": "NodeClustering object",
            "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
        },
        "Return": [
            "If summary==True a FitnessResult object, otherwise a list of floats.\n"
        ],
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nave = evaluation.avg_embeddedness(g,communities)"
        ],
        "References": []
    },
    {
        "Section_id": "nx_node_integer_mapping",
        "Description": "Maps node labels from strings to integers.\n",
        "Parameters": {
            "graph": "networkx graph"
        },
        "Return": [
            "if the node labels are string: networkx graph, dictionary <numeric_id, original_node_label>, false otherwise"
        ],
        "Example": [],
        "References": []
    },
    {
        "Section_id": "sbm_dl",
        "Description": "Efficient Monte Carlo and greedy heuristic for the inference of stochastic block models.\nFit a non-overlapping stochastic block model (SBM) by minimizing its description length using an agglomerative heuristic.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "network/igraph object"
        },
        "Return": [
            "NodeClustering object"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.sbm_dl(G)"
        ],
        "References": []
    },
    {
        "Section_id": "omega",
        "Description": "Index of resemblance for overlapping, complete coverage, network clusterings.\n",
        "Parameters": {
            "first_partition": "NodeClustering object",
            "second_partition": "NodeClustering object"
        },
        "Return": [
            "MatchingResult object\n"
        ],
        "Example": [
            "from cdlib import evaluation, algorithms\ng = nx.karate_club_graph()\nlouvain_communities = algorithms.louvain(g)\nleiden_communities = algorithms.leiden(g)\nevaluation.omega(louvain_communities,leiden_communities)"
        ],
        "References": [
            "Gabriel Murray, Giuseppe Carenini, and Raymond Ng. 2012. Using the omega index for evaluating abstractive algorithms detection. In Proceedings of Workshop on Evaluation Metrics and System Comparison for Automatic Summarization. Association for Computational Linguistics, Stroudsburg, PA, USA, 10-18."
        ]
    },
    {
        "Section_id": "node_perception",
        "Description": "Node perception is based on the idea of joining together small sets of nodes.\nThe algorithm first identifies sub-communities corresponding to each node\u2019s perception of the network around it.\nTo perform this step, it considers each node individually, and partition that node\u2019s neighbors into communities using some existing community detection method.\nNext, it creates a new network in which every node corresponds to a sub-community, and two nodes are linked if their associated sub-communities overlap by at least some threshold amount.\nFinally, the algorithm identifies overlapping communities in this new network, and for every such community, merge together the associated sub-communities to identify communities in the original network.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "threshold": "the tolerance required in order to merge communities",
            "overlap_threshold": "the overlap tolerance",
            "min_comm_size": "minimum community size default 3"
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.node_perception(G, threshold=0.25, overlap_threshold=0.25)"
        ],
        "References": []
    },
    {
        "Section_id": "spectral",
        "Description": "SCD implements a Spectral Clustering algorithm for Communities Discovery.\nIt is based on Fielder\u2019s vector (obtained from the eigenvector related to the second eigenvalue of the normalized Laplacian) that are leveraged to extract the communities using Kmeans clustering.\nSCD a hierarchical graph clustering algorithm inspired by modularity-based clustering techniques.\nThe algorithm is agglomerative and based on a simple distance between clusters induced by the probability of sampling node pairs.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "kmax": "maximum number of desired communities (mandatory). Default 2.",
            "projection_on_smaller_class": "a boolean value that if True then it project a bipartite network in the smallest class of node. (default is True)",
            "scaler": "the function to scale the fielder\u2019s vector to apply KMeans"
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.spectral(G, kmax=2)"
        ],
        "References": []
    },
    {
        "Section_id": "nf1",
        "Description": "Compute the Normalized F1 score of the optimal algorithms matches among the partitions in input.\nWorks on overlapping/non-overlapping complete/partial coverage partitions.\n",
        "Parameters": {
            "first_partition": "NodeClustering object",
            "second_partition": "NodeClustering object"
        },
        "Return": [
            "MatchingResult object\n"
        ],
        "Example": [
            "from cdlib import evaluation, algorithms\ng = nx.karate_club_graph()\nlouvain_communities = algorithms.louvain(g)\nleiden_communities = algorithms.leiden(g)\nevaluation.nf1(louvain_communities,leiden_communities)"
        ],
        "References": [
            "Rossetti, G., Pappalardo, L., & Rinzivillo, S. (2016). A novel approach to evaluate algorithms detection internal on ground truth.",
            "Rossetti, G. (2017). : RDyn: graph benchmark handling algorithms dynamics. Journal of Complex Networks. 5(6), 893-912."
        ]
    },
    {
        "Section_id": "core_expansion",
        "Description": "Core Expansion automatically detect the core of each possible community in the network. Then, it iteratively expand each core by adding the nodes to form the fnal communities. The expansion process is based on the neighborhood overlap measure.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "tolerance": "numerical tollerance, default 0.0001"
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.core_expansion(G)"
        ],
        "References": []
    },
    {
        "Section_id": "pycombo",
        "Description": "This is an implementation (for Modularity maximization) of the community detection algorithm called \u201cCombo\u201d.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "weight": "Optional, defaults to weight. Graph edges property to use as weights. If None, graph assumed to be unweighted. Ignored if graph is passed as string (path to the file), or such property does not exist.",
            "max_communities": "Optional, defaults to None. Maximum number of communities. If <= 0 or None, assume to be infinite.",
            "modularity_resolution": "float, defaults to 1.0. Modularity resolution parameter.",
            "num_split_attempts": "int, defaults to 0. Number of split attempts. If 0, autoadjust this number automatically.",
            "start_separate": "bool, default False. Indicates if Combo should start from assigning each node into its own separate community. This could help to achieve higher modularity, but it makes execution much slower.",
            "treat_as_modularity": "bool, default False. Indicates if edge weights should be treated as modularity scores. If True, the algorithm solves clique partitioning problem over the given graph, treated as modularity graph (matrix). For example, this allows users to provide their own custom \u2018modularity\u2019 matrix. modularity_resolution is ignored in this case.",
            "random_seed": "int, defaults to 42. Random seed to use."
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.pycombo(G)"
        ],
        "References": []
    },
    {
        "Section_id": "ga",
        "Description": "Genetic based approach to discover communities in social networks.\nGA optimizes a simple but efficacious fitness function able to identify densely connected groups of nodes with sparse connections between groups.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "population": "",
            "generation": "",
            "r": ""
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.ga(G)"
        ],
        "References": []
    },
    {
        "Section_id": "adjusted_mutual_information",
        "Description": "Adjusted Mutual Information between two clusterings.\nAdjusted Mutual Information (AMI) is an adjustment of the Mutual\nInformation (MI) score to account for chance. It accounts for the fact that\nthe MI is generally higher for two clusterings with a larger number of\nclusters, regardless of whether there is actually more information shared.\nFor two clusterings \\(U\\) and \\(V\\), the AMI is given as:\nAMI(U, V) = [MI(U, V) - E(MI(U, V))] / [max(H(U), H(V)) - E(MI(U, V))]\n\nThis metric is independent of the absolute values of the labels:\na permutation of the class or cluster label values won\u2019t change the\nscore value in any way.\nThis metric is furthermore symmetric: switching label_true with\nlabel_pred will return the same score value. This can be useful to\nmeasure the agreement of two independent label assignments strategies\non the same dataset when the real ground truth is not known.\nBe mindful that this function is an order of magnitude slower than other\nmetrics, such as the Adjusted Rand Index.\n",
        "Parameters": {
            "first_partition": "NodeClustering object",
            "second_partition": "NodeClustering object"
        },
        "Return": [
            "MatchingResult object\n"
        ],
        "Example": [
            "from cdlib import evaluation, algorithms\ng = nx.karate_club_graph()\nlouvain_communities = algorithms.louvain(g)\nleiden_communities = algorithms.leiden(g)\nevaluation.adjusted_mutual_information(louvain_communities,leiden_communities)"
        ],
        "References": [
            "Vinh, N. X., Epps, J., & Bailey, J. (2010). Information theoretic measures for clusterings comparison: Variants, properties, normalization and correction for chance. Journal of Machine Learning Research, 11(Oct), 2837-2854."
        ]
    },
    {
        "Section_id": "max_odf",
        "Description": "Maximum fraction of edges of a node of a community that point outside the community itself.\n\n\\[max_{u \\in S} \\frac{|\\{(u,v)\\in E: v \\not\\in S\\}|}{d(u)}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\) and \\(d(u)\\) is the degree of \\(u\\)\n",
        "Parameters": {
            "graph": "a networkx/igraph object",
            "community": "NodeClustering object",
            "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
        },
        "Return": [
            "If summary==True a FitnessResult object, otherwise a list of floats.\n"
        ],
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = evaluation.max_odf(g,communities)"
        ],
        "References": [
            "Flake, G.W., Lawrence, S., Giles, C.L., et al.: Efficient identification of web communities. In: KDD, vol. 2000, pp. 150\u2013160 (2000)"
        ]
    },
    {
        "Section_id": "rber_pots",
        "Description": "rber_pots is a  model where the quality function to optimize is:\n\n\\[Q = \\sum_{ij} \\left(A_{ij} - \\gamma p \\right)\\delta(\\sigma_i, \\sigma_j)\\]\nwhere \\(A\\) is the adjacency matrix,  \\(p = \\frac{m}{\\binom{n}{2}}\\) is the overall density of the graph, \\(\\sigma_i\\) denotes the community of node \\(i\\), \\(\\delta(\\sigma_i, \\sigma_j) = 1\\) if  \\(\\sigma_i = \\sigma_j\\) and 0 otherwise, and, finally \\(\\gamma\\) is a resolution parameter.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "initial_membership": "list of int Initial membership for the partition. IfNonethen defaults to a singleton partition. Deafault None",
            "weights": "list of double, or edge attribute Weights of edges. Can be either an iterable or an edge attribute. Deafault None",
            "node_sizes": "list of int, or vertex attribute Sizes of nodes are necessary to know the size of communities in aggregate graphs. Usually this is set to 1 for all nodes, but in specific cases  this could be changed. Deafault None",
            "resolution_parameter": "double >0 A parameter value controlling the coarseness of the clustering. Higher resolutions lead to more communities, while lower resolutions lead to fewer communities. Deafault 1"
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.rber_pots(G)"
        ],
        "References": []
    },
    {
        "Section_id": "infomap_bipartite",
        "Description": "Infomap is based on ideas of information theory.\nThe algorithm uses the probability flow of random walks on a bipartite network as a proxy for information flows in the real system and it decomposes the network into modules by compressing a description of the probability flow.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "flags": "str flags for Infomap"
        },
        "Return": [
            "BiNodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.algorithms.bipartite.generators.random_graph(100, 20, 0.5)\ncoms = algorithms.infomap_bipartite(G)"
        ],
        "References": []
    },
    {
        "Section_id": "plot_scoring",
        "Description": "Plot the scores obtained by a list of methods on a list of graphs.\n",
        "Parameters": {
            "graphs": "list of graphs on which to make computations",
            "ref_partitions": "list of reference clusterings corresponding to graphs",
            "graph_names": "list of the names of the graphs to display",
            "methods": "list of functions that take a graph as input and return a Clustering as output",
            "scoring": "the scoring function to use, default anmi",
            "nbRuns": "number of runs to do for each method on each graph"
        },
        "Return": [
            "a seaborn lineplot\n"
        ],
        "Example": [
            "from cdlib import algorithms, viz, evaluation\nimport networkx as nx\ng1 = nx.algorithms.community.LFR_benchmark_graph(1000, 3, 1.5, 0.5, min_community=20, average_degree=5)\ng2 = nx.algorithms.community.LFR_benchmark_graph(1000, 3, 1.5, 0.7, min_community=20, average_degree=5)\nnames = [\"g1\", \"g2\"]\ngraphs = [g1, g2]\nfor g in graphs:\n    references.append(NodeClustering(communities={frozenset(g.nodes[v]['community']) for v in g}, graph=g, method_name=\"reference\"))\nalgos = [algorithms.crisp_partition.louvain, algorithms.crisp_partition.label_propagation]\nviz.plot_scoring(graphs, references, names, algos, nbRuns=2)"
        ],
        "References": []
    },
    {
        "Section_id": "aslpaw",
        "Description": "ASLPAw can be used for disjoint and overlapping community detection and works on weighted/unweighted and directed/undirected networks.\nASLPAw is adaptive with virtually no configuration parameters.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object"
        },
        "Return": [
            "NodeClustering object"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.aslpaw(G)"
        ],
        "References": []
    },
    {
        "Section_id": "lfm",
        "Description": "LFM is based on the local optimization of a fitness function.\nIt finds both overlapping communities and the hierarchical structure.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "alpha": "parameter to controll the size of the communities:  Large values of alpha yield very small communities, small values instead deliver large modules. If alpha is small enough, all nodes end up in the same cluster, the network itself. In most cases, for alpha < 0.5 there is only one community, for alpha > 2 one recovers the smallest communities. A natural choise is alpha =1."
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncom = algorithms.lfm(G, alpha=0.8)"
        ],
        "References": []
    },
    {
        "Section_id": "hub_dominance",
        "Description": "Hub dominance.\nThe hub dominance of a community is defined as the ratio of the degree of its most connected node w.r.t. the theoretically maximal degree within the community.\n",
        "Parameters": {
            "graph": "a networkx/igraph object",
            "communities": "NodeClustering object",
            "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
        },
        "Return": [
            "If summary==True a FitnessResult object, otherwise a list of floats.\n"
        ],
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nscd = evaluation.hub_dominance(g,communities)"
        ],
        "References": []
    },
    {
        "Section_id": "belief",
        "Description": "Belief community seeks the consensus of many high-modularity partitions.\nIt does this with a scalable message-passing algorithm, derived by treating the modularity as a Hamiltonian and applying the cavity method.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "max_it": "",
            "eps": "",
            "reruns_if_not_conv": "",
            "threshold": "",
            "q_max": ""
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.belief(G)"
        ],
        "References": []
    },
    {
        "Section_id": "overlapping_normalized_mutual_information_LFK",
        "Description": "Overlapping Normalized Mutual Information between two clusterings.\nExtension of the Normalized Mutual Information (NMI) score to cope with overlapping partitions.\nThis is the version proposed by Lancichinetti et al. (1)\n",
        "Parameters": {
            "first_partition": "NodeClustering object",
            "second_partition": "NodeClustering object"
        },
        "Return": [
            "MatchingResult object\n"
        ],
        "Example": [
            "from cdlib import evaluation, algorithms\ng = nx.karate_club_graph()\nlouvain_communities = algorithms.louvain(g)\nleiden_communities = algorithms.leiden(g)\nevaluation.overlapping_normalized_mutual_information_LFK(louvain_communities,leiden_communities)"
        ],
        "References": [
            "Lancichinetti, A., Fortunato, S., & Kertesz, J. (2009). Detecting the overlapping and hierarchical community structure in complex networks. New Journal of Physics, 11(3), 033015."
        ]
    },
    {
        "Section_id": "avg_transitivity",
        "Description": "Average transitivity.\nThe average transitivity of a community is defined the as the average clustering coefficient of its nodes w.r.t. their connection within the community itself.\n",
        "Parameters": {
            "graph": "a networkx/igraph object",
            "communities": "NodeClustering object",
            "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
        },
        "Return": [
            "If summary==True a FitnessResult object, otherwise a list of floats.\n"
        ],
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nscd = evaluation.avg_transitivity(g,communities)"
        ],
        "References": []
    },
    {
        "Section_id": "erdos_renyi_modularity",
        "Description": "Erdos-Renyi modularity is a variation of the Newman-Girvan one.\nIt assumes that vertices in a network are connected randomly with a constant probability \\(p\\).\n\n\\[Q(S) = \\frac{1}{m}\\sum_{c \\in S} (m_S \u2212 \\frac{mn_S(n_S \u22121)}{n(n\u22121)})\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of community edges, \\(l_S\\) is the number of edges from nodes in S to nodes outside S.\n",
        "Parameters": {
            "graph": "a networkx/igraph object",
            "communities": "NodeClustering object"
        },
        "Return": [
            "FitnessResult object\n"
        ],
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = evaluation.erdos_renyi_modularity(g,communities)"
        ],
        "References": [
            "Erdos, P., & Renyi, A. (1959). On random graphs I. Publ. Math. Debrecen, 6, 290-297."
        ]
    },
    {
        "Section_id": "threshold_clustering",
        "Description": "Developed for semantic similarity networks, this algorithm specifically targets weighted and directed graphs.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "threshold_function": "callable, optional\nTies smaller than threshold_function(out_ties) are deleted. Example: np.mean, np.median. Default is np.mean."
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.threshold_clustering(G)"
        ],
        "References": []
    },
    {
        "Section_id": "size",
        "Description": "Size is the number of nodes in the community\n",
        "Parameters": {
            "graph": "a networkx/igraph object",
            "communities": "NodeClustering object",
            "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
        },
        "Return": [
            "If summary==True a FitnessResult object, otherwise a list of floats.\n"
        ],
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nsz = evaluation.size(g,communities)"
        ],
        "References": []
    },
    {
        "Section_id": "eva",
        "Description": "The Eva algorithm extends the Louvain approach in order to deal with the attributes of the nodes (aka Louvain Extended to Vertex Attributes).\nIt optimizes - combining them linearly - two quality functions, a structural and a clustering one, namely Newman\u2019s modularity and purity, estimated as the product of the frequencies of the most frequent labels carried by the nodes within the communities.\nA parameter alpha tunes the importance of the two functions: an high value of alpha favors the clustering criterion instead of the structural one.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "labels": "dictionary specifying for each node (key) a dict (value) specifying the name attribute (key) and its value (value)",
            "weight": "str, optional the key in graph to use as weight. Default to \u2018weight\u2019",
            "resolution": "double, optional  Will change the size of the communities, default to 1.",
            "alpha": "float, assumed in [0,1], optional Will tune the importance of modularity and purity criteria, default to 0.5"
        },
        "Return": [
            "AttrNodeClustering object\n"
        ],
        "Example": [
            "from cdlib.algorithms import eva\nimport networkx as nx\nimport random\nl1 = ['A', 'B', 'C', 'D']\nl2 = [\"E\", \"F\", \"G\"]\ng_attr = nx.barabasi_albert_graph(100, 5)\nlabels=dict()\nfor node in g_attr.nodes():\n   labels[node]={\"l1\":random.choice(l1), \"l2\":random.choice(l2)}\ncommunities = eva(g_attr, labels, alpha=0.8)"
        ],
        "References": []
    },
    {
        "Section_id": "lemon",
        "Description": "Lemon is a large scale overlapping community detection method based on local expansion via minimum one norm.\nThe algorithm adopts a local expansion method in order to identify the community members from a few exemplary seed members.\nThe algorithm finds the community by seeking a sparse vector in the span of the local spectra such that the seeds are in its support. LEMON can achieve the highest detection accuracy among state-of-the-art proposals. The running time depends on the size of the community rather than that of the entire graph.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "seeds": "Node list",
            "min_com_size": "the minimum size of a single community in the network, default 20",
            "max_com_size": "the maximum size of a single community in the network, default 50",
            "expand_step": "the step of seed set increasement during expansion process, default 6",
            "subspace_dim": "dimension of the subspace; choosing a large dimension is undesirable because it would increase the computation cost of generating local spectra default 3",
            "walk_steps": "the number of step for the random walk, default 3",
            "biased": "boolean; set if the random walk starting from seed nodes, default False"
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\nseeds = [\"$0$\", \"$2$\", \"$3$\"]\ncoms = algorithms.lemon(G, seeds, min_com_size=2, max_com_size=5)"
        ],
        "References": []
    },
    {
        "Section_id": "remap_node_communities",
        "Description": "Apply a map to the obtained communities to retreive the original node labels\n",
        "Parameters": {
            "communities": "NodeClustering object",
            "node_map": "dictionary <numeric_id, node_label>"
        },
        "Return": [
            "remapped communities\n"
        ],
        "Example": [],
        "References": []
    },
    {
        "Section_id": "ricci_community",
        "Description": "Curvature is a geometric property to describe the local shape of an object. If we draw two parallel paths on a surface with positive curvature like a sphere, these two paths move closer to each other while for a negatively curved surface like a saddle, these two paths tend to be apart.\nCurrently there are multiple ways to discretize curvature on graph, in this algorithm, we include two of the most frequently used discrete Ricci curvature: Ollivier-Ricci curvature which is based on optimal transportation theory and Forman-Ricci curvature which is base on CW complexes.\nEdge Ricci curvature is observed to play an important role in the graph structure.\nAn edge with positive curvature represents an edge within a cluster, while a negatively curved edge tent to be a bridge within clusters.\nAlso, negatively curved edges are highly related to graph connectivity, with negatively curved edges removed from a connected graph, the graph soon become disconnected.\nRicci flow is a process to uniformized the edge Ricci curvature of the graph.\nFor a given graph, the Ricci flow gives a \u201cRicci flow metric\u201d on each edge as edge weights, such that under these edge weights, the Ricci curvature of the graph is mostly equal everywhere. In [Ni3], this \u201cRicci flow metric\u201d is shown to be able to detect communities.\nBoth Ricci curvature and Ricci flow metric can act as a graph fingerprint for graph classification.\nThe different graph gives different edge Ricci curvature distributions and different Ricci flow metric.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "alpha": "The parameter for the probability distribution, range from [0 ~ 1]. It means the share of mass to leave on the original node. Default, 0.5.",
            "method": "Transportation method. [\u201cOTD\u201d, \u201cATD\u201d, \u201cSinkhorn\u201d]. Default: Sinkhorn"
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.ricci_community(G)"
        ],
        "References": []
    },
    {
        "Section_id": "angel",
        "Description": "Angel is a node-centric bottom-up community discovery algorithm.\nIt leverages ego-network structures and overlapping label propagation to identify micro-scale communities that are subsequently merged in mesoscale ones.\nAngel is the, faster, successor of Demon.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "threshold": "merging threshold in [0,1].",
            "min_community_size": "minimum community size, default 3."
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.angel(G, min_com_size=3, threshold=0.25)"
        ],
        "References": [
            "Rossetti, Giulio. \u201cExorcising the Demon: Angel, Efficient Node-Centric Community Discovery.\u201d International Conference on Complex Networks and Their Applications. Springer, Cham, 2019."
        ]
    },
    {
        "Section_id": "percomvc",
        "Description": "The PercoMVC approach composes of two steps.\nIn the first step, the algorithm attempts to determine all communities that the clique percolation algorithm may find.\nIn the second step, the algorithm computes the Eigenvector Centrality method on the output of the first step to measure the influence of network nodes and reduce the rate of the unclassified nodes\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object"
        },
        "Return": [
            "NodeClustering object"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.percomvc(G)"
        ],
        "References": []
    },
    {
        "Section_id": "graph_entropy",
        "Description": "This method takes advantage of the use of entropy with regard to information theory.\nEntropy is a measure of uncertainty involved in a random variable.\nThis approach uses a new de\ufb01nition, Graph Entropy, as a measure of structural complexity in a graph.\nThis algorithm incorporates a seed-growth technique.\nUnlike the other seed-growth style methods, however, the graph entropy approach does not require any predetermined threshold because it searches for an optimal solution by minimizing graph entropy.\nThis method \ufb01nds locally optimal clusters with minimal graph entropy.\nA seed vertex is selected at random from a candidate set of seed vertices.\nThen, an initial cluster which is composed of the seed vertex and its immediate neighbors is created.\nNext, the neighbors are iteratively evaluated for removal to minimize the initial entropy of the graph.\nFinally, outer boundary vertices are added recursively if their addition causes the entropy of the graph to decrease.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "weights": "label used for the edge weights.. Default, None"
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.graph_entropy(G)"
        ],
        "References": []
    },
    {
        "Section_id": "plot_network_clusters",
        "Description": "Plot a graph with node color coding for communities.\n",
        "Parameters": {
            "graph": "NetworkX/igraph graph",
            "partition": "NodeClustering object",
            "position": "A dictionary with nodes as keys and positions as values. Example: networkx.fruchterman_reingold_layout(G). By default, uses nx.spring_layout(g)",
            "figsize": "the figure size; it is a pair of float, default (8, 8)",
            "node_size": "int, default 200",
            "plot_overlaps": "bool, default False. Flag to control if multiple algorithms memberships are plotted.",
            "plot_labels": "bool, default False. Flag to control if node labels are plotted.",
            "cmap": "str or Matplotlib colormap, Colormap(Matplotlib colormap) for mapping intensities of nodes. If set to None, original colormap is used.",
            "top_k": "int, Show the top K influential communities. If set to zero or negative value indicates all.",
            "min_size": "int, Exclude communities below the specified minimum size."
        },
        "Return": [],
        "Example": [
            "from cdlib import algorithms, viz\nimport networkx as nx\ng = nx.karate_club_graph()\ncoms = algorithms.louvain(g)\npos = nx.spring_layout(g)\nviz.plot_network_clusters(g, coms, pos)"
        ],
        "References": []
    },
    {
        "Section_id": "BoolParameter",
        "Description": "Initialize self.  See help(type(self)) for accurate signature.",
        "Field List": {
            "Parameters": {},
            "Methods": {}
        }
    },
    {
        "Section_id": "wCommunity",
        "Description": "Algorithm to identify overlapping communities in weighted graphs\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "min_bel_degree": "the tolerance, in terms of beloging degree, required in order to add a node in a community",
            "threshold_bel_degree": "the tolerance, in terms of beloging degree, required in order to add a node in a \u2018NLU\u2019 community",
            "weightName": "name of the edge attribute containing the weights"
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\nnx.set_edge_attributes(G, values=1, name='weight')\ncoms = algorithms.wCommunity(G, min_bel_degree=0.6, threshold_bel_degree=0.6)"
        ],
        "References": []
    },
    {
        "Section_id": "modularity_density",
        "Description": "The modularity density is one of several propositions that envisioned to palliate the resolution limit issue of modularity based measures.\nThe idea of this metric is to include the information about community size into the expected density of community to avoid the negligence of small and dense communities.\nFor each community \\(C\\) in partition \\(S\\), it uses the average modularity degree calculated by \\(d(C) = d^{int(C)} \u2212 d^{ext(C)}\\) where \\(d^{int(C)}\\) and \\(d^{ext(C)}\\) are the average internal and external degrees of \\(C\\) respectively to evaluate the fitness of \\(C\\) in its network.\nFinally, the modularity density can be calculated as follows:\n\n\\[Q(S) = \\sum_{C \\in S} \\frac{1}{n_C} ( \\sum_{i \\in C} 2 * \\lambda * k^{int}_{iC} - \\sum_{i \\in C} 2 * (1 - \\lambda) * k^{out}_{iC})\\]\nwhere \\(n_C\\) is the number of nodes in C, \\(k^{int}_{iC}\\) is the degree of node i within \\(C\\), \\(k^{out}_{iC}\\) is the deree of node i outside \\(C\\) and \\(\\lambda\\) is a paramter that allows for tuning the measure resolution (its default value, 0.5, computes the standard modularity density score).\n",
        "Parameters": {
            "graph": "a networkx/igraph object",
            "communities": "NodeClustering object",
            "lmbd": "resolution parameter, float in [0,1]. Default 0.5."
        },
        "Return": [
            "FitnessResult object\n"
        ],
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = evaluation.modularity_density(g,communities)"
        ],
        "References": [
            "Zhang, S., Ning, XM., Ding, C. et al. Determining modular organization of protein interaction networks by maximizing modularity density. <https://doi.org/10.1186/1752-0509-4-S2-S10>`_ BMC Syst Biol 4, S10 (2010)."
        ]
    },
    {
        "Section_id": "FuzzyNodeClustering",
        "Description": "Fuzzy Node Communities representation.",
        "Field List": {
            "Parameters": {
                "communities": "list of communities",
                "node_allocation": "dictionary specifying for each node the allocation of probability toward the communities it is placed in",
                "graph": "a networkx/igraph object",
                "method_name": "community discovery algorithm name",
                "method_parameters": "configuration for the community discovery algorithm used",
                "overlap": "boolean, whether the partition is overlapping or not"
            },
            "Methods": {
                "adjusted_mutual_information": {
                    "Paramters": {
                        "clustering": "NodeClustering object"
                    },
                    "Return": [
                        "AMI score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.adjusted_mutual_information(leiden_communities)"
                    ],
                    "References": [
                        "Vinh, N. X., Epps, J., & Bailey, J. (2010). Information theoretic measures for clusterings comparison: Variants, properties, normalization and correction for chance. Journal of Machine Learning Research, 11(Oct), 2837-2854."
                    ],
                    "Description": "Adjusted Mutual Information between two clusterings.\nAdjusted Mutual Information (AMI) is an adjustment of the Mutual\nInformation (MI) score to account for chance. It accounts for the fact that\nthe MI is generally higher for two clusterings with a larger number of\nclusters, regardless of whether there is actually more information shared.\nFor two clusterings \\(U\\) and \\(V\\), the AMI is given as:\nAMI(U, V) = [MI(U, V) - E(MI(U, V))] / [max(H(U), H(V)) - E(MI(U, V))]\n\nThis metric is independent of the absolute values of the labels:\na permutation of the class or cluster label values won\u2019t change the\nscore value in any way.\nThis metric is furthermore symmetric: switching label_true with\nlabel_pred will return the same score value. This can be useful to\nmeasure the agreement of two independent label assignments strategies\non the same dataset when the real ground truth is not known.\nBe mindful that this function is an order of magnitude slower than other\nmetrics, such as the Adjusted Rand Index.\n"
                },
                "adjusted_rand_index": {
                    "Paramters": {
                        "clustering": "NodeClustering object"
                    },
                    "Return": [
                        "ARI score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.adjusted_rand_index(leiden_communities)"
                    ],
                    "References": [
                        "Hubert, L., & Arabie, P. (1985). Comparing partitions. Journal of classification, 2(1), 193-218."
                    ],
                    "Description": "Rand index adjusted for chance.\nThe Rand Index computes a similarity measure between two clusterings\nby considering all pairs of samples and counting pairs that are\nassigned in the same or different clusters in the predicted and\ntrue clusterings.\nThe raw RI score is then \u201cadjusted for chance\u201d into the ARI score\nusing the following scheme:\nARI = (RI - Expected_RI) / (max(RI) - Expected_RI)\n\nThe adjusted Rand index is thus ensured to have a value close to\n0.0 for random labeling independently of the number of clusters and\nsamples and exactly 1.0 when the clusterings are identical (up to\na permutation).\nARI is a symmetric measure:\nadjusted_rand_index(a, b) == adjusted_rand_index(b, a)\n\n"
                },
                "average_internal_degree": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.average_internal_degree()"
                    ],
                    "References": [],
                    "Description": "The average internal degree of the algorithms set.\n\n\\[f(S) = \\frac{2m_S}{n_S}\\]\nwhere \\(m_S\\) is the number of algorithms internal edges and \\(n_S\\) is the number of algorithms nodes.\n"
                },
                "avg_distance": {
                    "Paramters": {
                        "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
                    },
                    "Return": [
                        "If summary==True a FitnessResult object, otherwise a list of floats."
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Average distance.\nThe average distance of a community is defined average path length across all possible pair of nodes composing it.\n"
                },
                "avg_embeddedness": {
                    "Paramters": {
                        "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
                    },
                    "Return": [
                        "If summary==True a FitnessResult object, otherwise a list of floats."
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Average embeddedness of nodes within the community.\nThe embeddedness of a node n w.r.t. a community C is the ratio of its degree within the community and its overall degree.\n\n\\[emb(n,C) = \\frac{k_n^C}{k_n}\\]\nThe average embeddedness of a community C is:\n\n\\[avg_embd(c) = \\frac{1}{|C|} \\sum_{i \\in C} \\frac{k_n^C}{k_n}\\]\n"
                },
                "avg_odf": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.avg_odf()"
                    ],
                    "References": [],
                    "Description": "Average fraction of edges of a node of a algorithms that point outside the algorithms itself.\n\n\\[\\frac{1}{n_S} \\sum_{u \\in S} \\frac{|\\{(u,v)\\in E: v \\not\\in S\\}|}{d(u)}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\), \\(d(u)\\) is the degree of \\(u\\) and \\(n_S\\) is the set of algorithms nodes.\n"
                },
                "avg_transitivity": {
                    "Paramters": {
                        "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
                    },
                    "Return": [
                        "If summary==True a FitnessResult object, otherwise a list of floats."
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Average transitivity.\nThe average transitivity of a community is defined the as the average clustering coefficient of its nodes w.r.t. their connection within the community itself.\n"
                },
                "conductance": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.conductance()"
                    ],
                    "References": [],
                    "Description": "Fraction of total edge volume that points outside the algorithms.\n\n\\[f(S) = \\frac{c_S}{2 m_S+c_S}\\]\nwhere \\(c_S\\) is the number of algorithms nodes and, \\(m_S\\) is the number of algorithms edges\n"
                },
                "cut_ratio": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.cut_ratio()"
                    ],
                    "References": [],
                    "Description": "Fraction of existing edges (out of all possible edges) leaving the algorithms.\n..math:: f(S) = frac{c_S}{n_S (n \u2212 n_S)}\nwhere \\(c_S\\) is the number of algorithms nodes and, \\(n_S\\) is the number of edges on the algorithms boundary\n"
                },
                "edges_inside": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.edges_inside()"
                    ],
                    "References": [],
                    "Description": "Number of edges internal to the algorithms.\n"
                },
                "erdos_renyi_modularity": {
                    "Paramters": {},
                    "Return": [
                        "the Erdos-Renyi modularity score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.erdos_renyi_modularity()"
                    ],
                    "References": [],
                    "Description": "Erdos-Renyi modularity is a variation of the Newman-Girvan one.\nIt assumes that vertices in a network are connected randomly with a constant probability \\(p\\).\n\n\\[Q(S) = \\frac{1}{m}\\sum_{c \\in S} (m_S \u2212 \\frac{mn_S(n_S \u22121)}{n(n\u22121)})\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms edges, \\(l_S\\) is the number of edges from nodes in S to nodes outside S.\n"
                },
                "expansion": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.expansion()"
                    ],
                    "References": [],
                    "Description": "Number of edges per algorithms node that point outside the cluster.\n\n\\[f(S) = \\frac{c_S}{n_S}\\]\nwhere \\(n_S\\) is the number of edges on the algorithms boundary, \\(c_S\\) is the number of algorithms nodes.\n"
                },
                "f1": {
                    "Paramters": {
                        "clustering": "NodeClustering object"
                    },
                    "Return": [
                        "F1 score (harmonic mean of precision and recall)"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.f1(leiden_communities)"
                    ],
                    "References": [
                        "Rossetti, G., Pappalardo, L., & Rinzivillo, S. (2016). A novel approach to evaluate algorithms detection internal on ground truth. In Complex Networks VII (pp. 133-144). Springer, Cham."
                    ],
                    "Description": "Compute the average F1 score of the optimal algorithms matches among the partitions in input.\nWorks on overlapping/non-overlapping complete/partial coverage partitions.\n"
                },
                "flake_odf": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.flake_odf()"
                    ],
                    "References": [],
                    "Description": "Fraction of nodes in S that have fewer edges pointing inside than to the outside of the algorithms.\n\n\\[f(S) = \\frac{| \\{ u:u \\in S,| \\{(u,v) \\in E: v \\in S \\}| < d(u)/2 \\}|}{n_S}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\), \\(d(u)\\) is the degree of \\(u\\) and \\(n_S\\) is the set of algorithms nodes.\n"
                },
                "fraction_over_median_degree": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.fraction_over_median_degree()"
                    ],
                    "References": [],
                    "Description": "Fraction of algorithms nodes of having internal degree higher than the median degree value.\n\n\\[f(S) = \\frac{|\\{u: u \\in S,| \\{(u,v): v \\in S\\}| > d_m\\}| }{n_S}\\]\nwhere \\(d_m\\) is the internal degree median value\n"
                },
                "get_description": {
                    "Paramters": {
                        "parameters_to_display": "parameters to display. By default, all float parameters.",
                        "precision": "precision used to plot parameters. default: 3"
                    },
                    "Return": [
                        "a string description of the method.\n"
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Return a description of the clustering, with the name of the method and its numeric parameters.\n"
                },
                "hub_dominance": {
                    "Paramters": {
                        "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
                    },
                    "Return": [
                        "If summary==True a FitnessResult object, otherwise a list of floats."
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Hub dominance.\nThe hub dominance of a community is defined as the ratio of the degree of its most connected node w.r.t. the theoretically maximal degree within the community.\n"
                },
                "internal_edge_density": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.internal_edge_density()"
                    ],
                    "References": [],
                    "Description": "The internal density of the algorithms set.\n\n\\[f(S) = \\frac{m_S}{n_S(n_S\u22121)/2}\\]\nwhere \\(m_S\\) is the number of algorithms internal edges and \\(n_S\\) is the number of algorithms nodes.\n"
                },
                "link_modularity": {
                    "Paramters": {},
                    "Return": [
                        "the link modularity score"
                    ],
                    "Example": [
                        "from cdlib import evaluation\nfrom cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.link_modularity()"
                    ],
                    "References": [],
                    "Description": "Quality function designed for directed graphs with overlapping communities.\n"
                },
                "max_odf": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.max_odf()"
                    ],
                    "References": [],
                    "Description": "Maximum fraction of edges of a node of a algorithms that point outside the algorithms itself.\n\n\\[max_{u \\in S} \\frac{|\\{(u,v)\\in E: v \\not\\in S\\}|}{d(u)}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\) and \\(d(u)\\) is the degree of \\(u\\)\n"
                },
                "modularity_density": {
                    "Paramters": {},
                    "Return": [
                        "the modularity density score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.modularity_density()"
                    ],
                    "References": [],
                    "Description": "The modularity density is one of several propositions that envisioned to palliate the resolution limit issue of modularity based measures.\nThe idea of this metric is to include the information about algorithms size into the expected density of algorithms to avoid the negligence of small and dense communities.\nFor each algorithms \\(C\\) in partition \\(S\\), it uses the average modularity degree calculated by \\(d(C) = d^{int(C)} \u2212 d^{ext(C)}\\) where \\(d^{int(C)}\\) and \\(d^{ext(C)}\\) are the average internal and external degrees of \\(C\\) respectively to evaluate the fitness of \\(C\\) in its network.\nFinally, the modularity density can be calculated as follows:\n\n\\[Q(S) = \\sum_{C \\in S} \\frac{1}{n_C} ( \\sum_{i \\in C} k^{int}_{iC} - \\sum_{i \\in C} k^{out}_{iC})\\]\nwhere \\(n_C\\) is the number of nodes in C, \\(k^{int}_{iC}\\) is the degree of node i within \\(C\\) and \\(k^{out}_{iC}\\) is the deree of node i outside \\(C\\).\n"
                },
                "modularity_overlap": {
                    "Paramters": {
                        "weight": "label identifying the edge weight parameter name (if present), default None"
                    },
                    "Return": [
                        "FitnessResult object"
                    ],
                    "Example": [],
                    "References": [
                        "\nLazar, D. Abel and T. Vicsek, \u201cModularity measure of networks with overlapping communities\u201d  EPL, 90 (2010) 18001 doi: 10.1209/0295-5075/90/18001\n\n",
                        "Lazar, D. Abel and T. Vicsek, \u201cModularity measure of networks with overlapping communities\u201d  EPL, 90 (2010) 18001 doi: 10.1209/0295-5075/90/18001"
                    ],
                    "Description": "Determines the Overlapping Modularity of a partition C on a graph G.\nOverlapping Modularity is defined as\n\n\\[M_{c_{r}}^{ov} = \\sum_{i \\in c_{r}} \\frac{\\sum_{j \\in c_{r}, i \\neq j}a_{ij} - \\sum_{j \\not \\in c_{r}}a_{ij}}{d_{i} \\cdot s_{i}} \\cdot \\frac{n_{c_{r}}^{e}}{n_{c_{r}} \\cdot \\binom{n_{c_{r}}}{2}}\\]\n"
                },
                "newman_girvan_modularity": {
                    "Paramters": {},
                    "Return": [
                        "the Newman-Girvan modularity score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.newman_girvan_modularity()"
                    ],
                    "References": [],
                    "Description": "Difference the fraction of intra algorithms edges of a partition with the expected number of such edges if distributed according to a null model.\nIn the standard version of modularity, the null model preserves the expected degree sequence of the graph under consideration. In other words, the modularity compares the real network structure with a corresponding one where nodes are connected without any preference about their neighbors.\n\n\\[Q(S) = \\frac{1}{m}\\sum_{c \\in S}(m_S - \\frac{(2 m_S + l_S)^2}{4m})\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms edges, \\(l_S\\) is the number of edges from nodes in S to nodes outside S.\n"
                },
                "nf1": {
                    "Paramters": {
                        "clustering": "NodeClustering object"
                    },
                    "Return": [
                        "MatchingResult instance"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.nf1(leiden_communities)"
                    ],
                    "References": [
                        "Rossetti, G., Pappalardo, L., & Rinzivillo, S. (2016). A novel approach to evaluate algorithms detection internal on ground truth.",
                        "Rossetti, G. (2017). : RDyn: graph benchmark handling algorithms dynamics. Journal of Complex Networks. 5(6), 893-912."
                    ],
                    "Description": "Compute the Normalized F1 score of the optimal algorithms matches among the partitions in input.\nWorks on overlapping/non-overlapping complete/partial coverage partitions.\n"
                },
                "normalized_cut": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.normalized_cut()"
                    ],
                    "References": [],
                    "Description": "Normalized variant of the Cut-Ratio\n\n\\[: f(S) = \\frac{c_S}{2m_S+c_S} + \\frac{c_S}{2(m\u2212m_S )+c_S}\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms internal edges and \\(c_S\\) is the number of algorithms nodes.\n"
                },
                "normalized_mutual_information": {
                    "Paramters": {
                        "clustering": "NodeClustering object"
                    },
                    "Return": [
                        "normalized mutual information score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.normalized_mutual_information(leiden_communities)"
                    ],
                    "References": [],
                    "Description": "Normalized Mutual Information between two clusterings.\nNormalized Mutual Information (NMI) is an normalization of the Mutual\nInformation (MI) score to scale the results between 0 (no mutual\ninformation) and 1 (perfect correlation). In this function, mutual\ninformation is normalized by sqrt(H(labels_true) * H(labels_pred))\n"
                },
                "omega": {
                    "Paramters": {
                        "clustering": "NodeClustering object"
                    },
                    "Return": [
                        "omega index"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.omega(leiden_communities)"
                    ],
                    "References": [
                        "Gabriel Murray, Giuseppe Carenini, and Raymond Ng. 2012. Using the omega index for evaluating abstractive algorithms detection. In Proceedings of Workshop on Evaluation Metrics and System Comparison for Automatic Summarization. Association for Computational Linguistics, Stroudsburg, PA, USA, 10-18."
                    ],
                    "Description": "Index of resemblance for overlapping, complete coverage, network clusterings.\n"
                },
                "overlapping_normalized_mutual_information_LFK": {
                    "Paramters": {
                        "clustering": "NodeClustering object"
                    },
                    "Return": [
                        "onmi score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.overlapping_normalized_mutual_information_LFK(leiden_communities)"
                    ],
                    "References": [
                        "Lancichinetti, A., Fortunato, S., & Kertesz, J. (2009). Detecting the overlapping and hierarchical community structure in complex networks. New Journal of Physics, 11(3), 033015."
                    ],
                    "Description": "Overlapping Normalized Mutual Information between two clusterings.\nExtension of the Normalized Mutual Information (NMI) score to cope with overlapping partitions.\nThis is the version proposed by Lancichinetti et al.\n"
                },
                "overlapping_normalized_mutual_information_MGH": {
                    "Paramters": {
                        "clustering": "NodeClustering object",
                        "normalization": "one of \u201cmax\u201d or \u201cLFK\u201d. Default \u201cmax\u201d (corresponds to the main method described in the article)"
                    },
                    "Return": [
                        "onmi score\n"
                    ],
                    "Example": [
                        "from cdlib import evaluation, algorithms\ng = nx.karate_club_graph()\nlouvain_communities = algorithms.louvain(g)\nleiden_communities = algorithms.leiden(g)\nevaluation.overlapping_normalized_mutual_information_MGH(louvain_communities,leiden_communities)"
                    ],
                    "References": [
                        "McDaid, A. F., Greene, D., & Hurley, N. (2011). Normalized mutual information to evaluate overlapping community finding algorithms. arXiv preprint arXiv:1110.2515. Chicago"
                    ],
                    "Description": "Overlapping Normalized Mutual Information between two clusterings.\nExtension of the Normalized Mutual Information (NMI) score to cope with overlapping partitions.\nThis is the version proposed by McDaid et al. using a different normalization than the original LFR one. See ref.\nfor more details.\n"
                },
                "scaled_density": {
                    "Paramters": {
                        "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
                    },
                    "Return": [
                        "If summary==True a FitnessResult object, otherwise a list of floats."
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Scaled density.\nThe scaled density of a community is defined as the ratio of the community density w.r.t. the complete graph density.\n"
                },
                "significance": {
                    "Paramters": {},
                    "Return": [
                        "the significance score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.significance()"
                    ],
                    "References": [],
                    "Description": "Significance estimates how likely a partition of dense communities appear in a random graph.\n"
                },
                "size": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Size is the number of nodes in the community\n"
                },
                "surprise": {
                    "Paramters": {},
                    "Return": [
                        "the surprise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.surprise()"
                    ],
                    "References": [],
                    "Description": "Surprise is statistical approach proposes a quality metric assuming that edges between vertices emerge randomly according to a hyper-geometric distribution.\nAccording to the Surprise metric, the higher the score of a partition, the less likely it is resulted from a random realization, the better the quality of the algorithms structure.\n"
                },
                "to_json": {
                    "Paramters": {},
                    "Return": [
                        "a JSON formatted string representing the object"
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Generate a JSON representation of the algorithms object\n"
                },
                "to_node_community_map": {
                    "Paramters": {},
                    "Return": [
                        "dict of the form <node, list(communities)>"
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Generate a <node, list(communities)> representation of the current clustering\n"
                },
                "triangle_participation_ratio": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.triangle_participation_ratio()"
                    ],
                    "References": [],
                    "Description": "Fraction of algorithms nodes that belong to a triad.\n\n\\[f(S) = \\frac{ | \\{ u: u \\in S,\\{(v,w):v, w \\in S,(u,v) \\in E,(u,w) \\in E,(v,w) \\in E \\} \\not = \\emptyset \\} |}{n_S}\\]\nwhere \\(n_S\\) is the set of algorithms nodes.\n"
                },
                "variation_of_information": {
                    "Paramters": {
                        "clustering": "NodeClustering object"
                    },
                    "Return": [
                        "VI score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.variation_of_information(leiden_communities)"
                    ],
                    "References": [
                        "Meila, M. (2007). Comparing clusterings - an information based distance. Journal of Multivariate Analysis, 98, 873-895. doi:10.1016/j.jmva.2006.11.013"
                    ],
                    "Description": "Variation of Information among two nodes partitions.\n$$ H(p)+H(q)-2MI(p, q) $$\nwhere MI is the mutual information, H the partition entropy and p,q are the algorithms sets\n"
                },
                "z_modularity": {
                    "Paramters": {},
                    "Return": [
                        "the z-modularity score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.z_modularity()"
                    ],
                    "References": [],
                    "Description": "Z-modularity is another variant of the standard modularity proposed to avoid the resolution limit.\nThe concept of this version is based on an observation that the difference between the fraction of edges inside communities and the expected number of such edges in a null model should not be considered as the only contribution to the final quality of algorithms structure.\n"
                }
            }
        }
    },
    {
        "Section_id": "der",
        "Description": "DER is a Diffusion Entropy Reducer graph clustering algorithm.\nThe algorithm uses random walks to embed the graph in a space of measures, after which a modification of k-means in that space is applied. It creates the walks, creates an initialization, runs the algorithm,\nand finally extracts the communities.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "an undirected networkx graph object",
            "walk_len": "length of the random walk, default 3",
            "threshold": "threshold for stop criteria; if the likelihood_diff is less than threshold tha algorithm stops, default 0.00001",
            "iter_bound": "maximum number of iteration, default 50"
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.der(G, 3, .00001, 50)"
        ],
        "References": []
    },
    {
        "Section_id": "Parameter",
        "Description": "Initialize self.  See help(type(self)) for accurate signature.",
        "Field List": {
            "Parameters": {},
            "Methods": {}
        }
    },
    {
        "Section_id": "head_tail",
        "Description": "Identifying homogeneous communities in complex networks by applying head/tail breaks on edge betweenness given its heavy-tailed distribution.\nNote: this implementation is suited for small-medium sized graphs, and it may take couple of minutes or longer for a bigger graph.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "head_tail_ratio": "head/tail division rule. Float in [0,1], dafault 0.4."
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.head_tail(G, head_tail_ratio=0.8)"
        ],
        "References": []
    },
    {
        "Section_id": "lais2",
        "Description": "LAIS2 is an overlapping community discovery algorithm based on the density function.\nIn the algorithm considers the density of a group is defined as the average density of the communication exchanges between the actors of the group.\nLAIS2 IS composed of two procedures LA (Link Aggregate Algorithm) and IS2 (Iterative Scan Algorithm).\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object"
        },
        "Return": [
            "NodeClustering object"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncom = algorithms.lais2(G)"
        ],
        "References": []
    },
    {
        "Section_id": "plot_sim_matrix",
        "Description": "Plot a similarity matrix between a list of clusterings, using the provided scoring function.\n",
        "Parameters": {
            "clusterings": "list of clusterings to compare",
            "scoring": "the scoring function to use"
        },
        "Return": [
            "a ClusterGrid instance\n"
        ],
        "Example": [
            "from cdlib import algorithms, viz, evaluation\nimport networkx as nx\ng = nx.karate_club_graph()\ncoms = algorithms.louvain(g)\ncoms2 = algorithms.walktrap(g)\nclustermap = viz.plot_sim_matrix([coms,coms2],evaluation.adjusted_mutual_information)"
        ],
        "References": []
    },
    {
        "Section_id": "grid_search",
        "Description": "Returns the optimal partition of the specified graph w.r.t. the selected algorithm and quality score.\n",
        "Parameters": {
            "method": "community discovery method (from nclib.community)",
            "graph": "networkx/igraph object",
            "parameters": "list of Parameter and BoolParameter objects",
            "quality_score": "a fitness function to evaluate the obtained partition (from nclib.evaluation)",
            "aggregate": "function to select the best fitness value. Possible values: min/max"
        },
        "Return": [
            "at each call the generator yields a tuple composed by: the optimal configuration for the given algorithm, input paramters and fitness function; the obtained communities; the fitness score\n"
        ],
        "Example": [
            "import networkx as nx\nfrom cdlib import algorithms, ensemble\ng = nx.karate_club_graph()\nresolution = ensemble.Parameter(name=\"resolution\", start=0.1, end=1, step=0.1)\nrandomize = ensemble.BoolParameter(name=\"randomize\")\ncommunities, scoring = ensemble.grid_search(graph=g, method=algorithms.louvain,\n                                                    parameters=[resolution, randomize],\n                                                    quality_score=evaluation.erdos_renyi_modularity,\n                                                    aggregate=max)\nprint(communities, scoring)"
        ],
        "References": []
    },
    {
        "Section_id": "mcode",
        "Description": "MCODE is the earliest seed-growth method for predicting protein complexes from PPI networks. MCODE works in two steps:\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "weights": "label used for the edge weights. Default, None.",
            "weight_threshold": "Threshold for similarity weighs"
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.mcode(G)"
        ],
        "References": [
            "vertex weighting, and",
            "molecular complex prediction."
        ]
    },
    {
        "Section_id": "variation_of_information",
        "Description": "Variation of Information among two nodes partitions.\n$$ H(p)+H(q)-2MI(p, q) $$\nwhere MI is the mutual information, H the partition entropy and p,q are the algorithms sets\n",
        "Parameters": {
            "first_partition": "NodeClustering object",
            "second_partition": "NodeClustering object"
        },
        "Return": [
            "MatchingResult object\n"
        ],
        "Example": [
            "from cdlib import evaluation, algorithms\ng = nx.karate_club_graph()\nlouvain_communities = algorithms.louvain(g)\nleiden_communities = algorithms.leiden(g)\nevaluation.variation_of_information(louvain_communities,leiden_communities)"
        ],
        "References": [
            "Meila, M. (2007). Comparing clusterings - an information based distance. Journal of Multivariate Analysis, 98, 873-895. doi:10.1016/j.jmva.2006.11.013"
        ]
    },
    {
        "Section_id": "scan",
        "Description": "SCAN (Structural Clustering Algorithm for Networks) is an algorithm which detects clusters, hubs and outliers in networks.\nIt clusters vertices based on a structural similarity measure.\nThe method uses the neighborhood of the vertices as clustering criteria instead of only their direct connections.\nVertices are grouped into the clusters by how they share neighbors.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "epsilon": "the minimum threshold to assigning cluster membership",
            "mu": "minimum number of neineighbors with a structural similarity that exceeds the threshold epsilon"
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncom = algorithms.scan(G, epsilon=0.7, mu=3)"
        ],
        "References": []
    },
    {
        "Section_id": "umstmo",
        "Description": "Overlapping community detection based on the union of all maximum spanning trees\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object"
        },
        "Return": [
            "NodeClustering object"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.umstmo(G)"
        ],
        "References": []
    },
    {
        "Section_id": "significance",
        "Description": "Significance estimates how likely a partition of dense communities appear in a random graph.\n",
        "Parameters": {
            "graph": "a networkx/igraph object",
            "communities": "NodeClustering object"
        },
        "Return": [
            "FitnessResult object\n"
        ],
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = evaluation.significance(g,communities)"
        ],
        "References": [
            "Traag, V. A., Aldecoa, R., & Delvenne, J. C. (2015). Detecting communities using asymptotical surprise. Physical Review E, 92(2), 022816."
        ]
    },
    {
        "Section_id": "plot_com_properties_relation",
        "Description": "Plot the relation between two properties/fitness function of a clustering\n",
        "Parameters": {
            "com_clusters": "clustering(s) to analyze (cluster or cluster list)",
            "com_fitness_x": "first fitness/community property",
            "com_fitness_y": "first fitness/community property",
            "kwargs": "parameters for the seaborn lmplot"
        },
        "Return": [
            "a seaborn lmplot\n"
        ],
        "Example": [
            "from cdlib import algorithms, viz, evaluation\nimport networkx as nx\ng = nx.karate_club_graph()\ncoms = algorithms.louvain(g)\ncoms2 = algorithms.walktrap(g)\nlmplot = viz.plot_com_properties_relation([coms,coms2],evaluation.size,evaluation.internal_edge_density)"
        ],
        "References": []
    },
    {
        "Section_id": "kcut",
        "Description": "An Efficient Spectral Algorithm for Network Community Discovery.\nKcut is designed to provide a unique combination of recursive partitioning and direct k-way methods, able to guarantee the efficiency of a recursive approach, while also having the same accuracy as a direct k-way method.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "kmax": "maximum value of k, dafault 4."
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.kcut(G, kmax=4)"
        ],
        "References": []
    },
    {
        "Section_id": "avg_distance",
        "Description": "Average distance.\nThe average distance of a community is defined average path length across all possible pair of nodes composing it.\n",
        "Parameters": {
            "graph": "a networkx/igraph object",
            "communities": "NodeClustering object",
            "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
        },
        "Return": [
            "If summary==True a FitnessResult object, otherwise a list of floats.\n"
        ],
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nscd = evaluation.avg_distance(g,communities)"
        ],
        "References": []
    },
    {
        "Section_id": "ilouvain",
        "Description": "The I-Louvain algorithm extends the Louvain approach in order to deal only with the scalar attributes of the nodes.\nIt optimizes Newman\u2019s modularity combined with an entropy measure.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "labels": "dictionary specifying for each node (key) a dict (value) specifying the name attribute (key) and its value (value)"
        },
        "Return": [
            "AttrNodeClustering object\n"
        ],
        "Example": [
            "from cdlib.algorithms import ilouvain\nimport networkx as nx\nimport random\nl1 = [0.1, 0.4, 0.5]\nl2 = [34, 3, 112]\ng_attr = nx.barabasi_albert_graph(100, 5)\nlabels=dict()\nfor node in g_attr.nodes():\n   labels[node]={\"l1\":random.choice(l1), \"l2\":random.choice(l2)}\nid = dict()\nfor n in g.nodes():\n    id[n] = n\ncommunities = ilouvain(g_attr, labels, id)"
        ],
        "References": []
    },
    {
        "Section_id": "agdl",
        "Description": "AGDL is a graph-based agglomerative algorithm, for clustering high-dimensional data.\nThe algorithm uses  the indegree and outdegree to characterize the affinity between two clusters.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "number_communities": "number of communities",
            "kc": "size of the neighbor set for each cluster"
        },
        "Return": [
            "NodeClustering object\n\n\n\n\nExample:\n\n\n\n\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncom = algorithms.agdl(g, number_communities=3, kc=4)"
        ],
        "References": []
    },
    {
        "Section_id": "pool",
        "Description": "Execute on a pool of community discovery internal on the input graph.\n",
        "Parameters": {
            "methods": "list community discovery methods (from nclib.community)",
            "graph": "networkx/igraph object",
            "configurations": "list of lists (one for each method) of Parameter and BoolParameter objects"
        },
        "Return": [
            "at each call the generator yields a tuple composed by: the actual method, its current configuration and the obtained communities\n"
        ],
        "Example": [
            "import networkx as nx\nfrom cdlib import algorithms, ensemble\ng = nx.karate_club_graph()\n# Louvain\nresolution = ensemble.Parameter(name=\"resolution\", start=0.1, end=1, step=0.1)\nrandomize = ensemble.BoolParameter(name=\"randomize\")\nlouvain_conf = [resolution, randomize]\n# Angel\nthreshold = ensemble.Parameter(name=\"threshold\", start=0.1, end=1, step=0.1)\nangel_conf = [threshold]\nmethods = [algorithms.louvain, algorithms.angel]\nfor communities in ensemble.pool(g, methods, [louvain_conf, angel_conf]):\n    print(communities)"
        ],
        "References": []
    },
    {
        "Section_id": "rb_pots",
        "Description": "Rb_pots is a model where the quality function to optimize is:\n\n\\[Q = \\sum_{ij} \\left(A_{ij} - \\gamma \\frac{k_i k_j}{2m} \\right)\\delta(\\sigma_i, \\sigma_j)\\]\nwhere \\(A\\) is the adjacency matrix, \\(k_i\\) is the (weighted) degree of node \\(i\\), \\(m\\) is the total number of edges (or total edge weight), \\(\\sigma_i\\) denotes the community of node \\(i\\) and \\(\\delta(\\sigma_i, \\sigma_j) = 1\\) if \\(\\sigma_i = \\sigma_j\\) and 0 otherwise.\nFor directed graphs a slightly different formulation is used, as proposed by Leicht and Newman :\n\n\\[Q = \\sum_{ij} \\left(A_{ij} - \\gamma \\frac{k_i^\\mathrm{out} k_j^\\mathrm{in}}{m} \\right)\\delta(\\sigma_i, \\sigma_j),\\]\nwhere \\(k_i^\\mathrm{out}\\) and \\(k_i^\\mathrm{in}\\) refers to respectively the outdegree and indegree of node \\(i\\) , and \\(A_{ij}\\) refers to an edge from \\(i\\) to \\(j\\).\nNote that this is the same of Leiden algorithm when setting \\(\\gamma=1\\) and normalising by \\(2m\\), or \\(m\\) for directed graphs.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "initial_membership": "list of int Initial membership for the partition. IfNonethen defaults to a singleton partition. Deafault None",
            "weights": "list of double, or edge attribute Weights of edges. Can be either an iterable or an edge attribute. Deafault None",
            "resolution_parameter": "double >0 A parameter value controlling the coarseness of the clustering. Higher resolutions lead to more communities, while lower resolutions lead to fewer communities. Default 1"
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.rb_pots(G)"
        ],
        "References": []
    },
    {
        "Section_id": "flake_odf",
        "Description": "Fraction of nodes in S that have fewer edges pointing inside than to the outside of the community.\n\n\\[f(S) = \\frac{| \\{ u:u \\in S,| \\{(u,v) \\in E: v \\in S \\}| < d(u)/2 \\}|}{n_S}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\), \\(d(u)\\) is the degree of \\(u\\) and \\(n_S\\) is the set of community nodes.\n",
        "Parameters": {
            "graph": "a networkx/igraph object",
            "community": "NodeClustering object",
            "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
        },
        "Return": [
            "If summary==True a FitnessResult object, otherwise a list of floats.\n"
        ],
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = evaluation.flake_odf(g,communities)"
        ],
        "References": [
            "Flake, G.W., Lawrence, S., Giles, C.L., et al.: Efficient identification of web communities. In: KDD, vol. 2000, pp. 150\u2013160 (2000)"
        ]
    },
    {
        "Section_id": "ego_networks",
        "Description": "Ego-networks returns overlapping communities centered at each nodes within a given radius.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "level": "extrac communities with all neighbors of distance<=level from a node. Deafault 1"
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.ego_networks(G)"
        ],
        "References": []
    },
    {
        "Section_id": "modularity_overlap",
        "Description": "Determines the Overlapping Modularity of a partition C on a graph G.\nOverlapping Modularity is defined as\n",
        "Parameters": {
            "graph": "a networkx/igraph object",
            "communities": "NodeClustering object",
            "weight": "label identifying the edge weight parameter name (if present), default None"
        },
        "Return": [
            "FitnessResult object\n"
        ],
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = evaluation.modularity_overlap(g, communities)"
        ],
        "References": [
            "\nLazar, D. Abel and T. Vicsek, \u201cModularity measure of networks with overlapping communities\u201d  EPL, 90 (2010) 18001 doi: 10.1209/0295-5075/90/18001\n\n",
            "Lazar, D. Abel and T. Vicsek, \u201cModularity measure of networks with overlapping communities\u201d  EPL, 90 (2010) 18001 doi: 10.1209/0295-5075/90/18001"
        ]
    },
    {
        "Section_id": "congo",
        "Description": "CONGO (CONGA Optimized) is an optimization of the CONGA algortithm.\nThe CONGO algorithm is the same as CONGA but using local betweenness. The complete CONGO algorithm is as follows:\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "number_communities": "the number of communities desired",
            "height": "The lengh of the longest shortest paths that CONGO considers, default 2"
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncom = algorithms.congo(G, number_communities=3, height=2)"
        ],
        "References": [
            "Calculate edge betweenness of edges and split betweenness of vertices.",
            "Find edge with maximum edge betweenness or vertex with maximum split betweenness, if greater.",
            "\nRecalculate edge betweenness and split betweenness:\n\nSubtract betweenness of h-region centred on the removed edge or split vertex.\nRemove the edge or split the vertex.\nAdd betweenness for the same region.\n\n\n\n",
            "Subtract betweenness of h-region centred on the removed edge or split vertex.",
            "Remove the edge or split the vertex.",
            "Add betweenness for the same region.",
            "Repeat from step 2 until no edges remain."
        ]
    },
    {
        "Section_id": "dcs",
        "Description": "Divide and Conquer Strategy\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object"
        },
        "Return": [
            "NodeClustering object"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.dcs(G)"
        ],
        "References": []
    },
    {
        "Section_id": "girvan_newman",
        "Description": "The Girvan\u2013Newman algorithm detects communities by progressively removing edges from the original graph.\nThe algorithm removes the \u201cmost valuable\u201d edge, traditionally the edge with the highest betweenness centrality, at each step. As the graph breaks down into pieces, the tightly knit community structure is exposed and the result can be depicted as a dendrogram.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "level": "the level where to cut the dendrogram"
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncom = algorithms.girvan_newman(G, level=3)"
        ],
        "References": []
    },
    {
        "Section_id": "AttrNodeClustering",
        "Description": "Attribute Node Communities representation.",
        "Field List": {
            "Parameters": {
                "communities": "list of communities",
                "graph": "a networkx/igraph object",
                "method_name": "community discovery algorithm name",
                "coms_labels": "dictionary specifying for each community the frequency of the attribute values",
                "method_parameters": "configuration for the community discovery algorithm used",
                "overlap": "boolean, whether the partition is overlapping or not"
            },
            "Methods": {
                "adjusted_mutual_information": {
                    "Paramters": {
                        "clustering": "NodeClustering object"
                    },
                    "Return": [
                        "AMI score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.adjusted_mutual_information(leiden_communities)"
                    ],
                    "References": [
                        "Vinh, N. X., Epps, J., & Bailey, J. (2010). Information theoretic measures for clusterings comparison: Variants, properties, normalization and correction for chance. Journal of Machine Learning Research, 11(Oct), 2837-2854."
                    ],
                    "Description": "Adjusted Mutual Information between two clusterings.\nAdjusted Mutual Information (AMI) is an adjustment of the Mutual\nInformation (MI) score to account for chance. It accounts for the fact that\nthe MI is generally higher for two clusterings with a larger number of\nclusters, regardless of whether there is actually more information shared.\nFor two clusterings \\(U\\) and \\(V\\), the AMI is given as:\nAMI(U, V) = [MI(U, V) - E(MI(U, V))] / [max(H(U), H(V)) - E(MI(U, V))]\n\nThis metric is independent of the absolute values of the labels:\na permutation of the class or cluster label values won\u2019t change the\nscore value in any way.\nThis metric is furthermore symmetric: switching label_true with\nlabel_pred will return the same score value. This can be useful to\nmeasure the agreement of two independent label assignments strategies\non the same dataset when the real ground truth is not known.\nBe mindful that this function is an order of magnitude slower than other\nmetrics, such as the Adjusted Rand Index.\n"
                },
                "adjusted_rand_index": {
                    "Paramters": {
                        "clustering": "NodeClustering object"
                    },
                    "Return": [
                        "ARI score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.adjusted_rand_index(leiden_communities)"
                    ],
                    "References": [
                        "Hubert, L., & Arabie, P. (1985). Comparing partitions. Journal of classification, 2(1), 193-218."
                    ],
                    "Description": "Rand index adjusted for chance.\nThe Rand Index computes a similarity measure between two clusterings\nby considering all pairs of samples and counting pairs that are\nassigned in the same or different clusters in the predicted and\ntrue clusterings.\nThe raw RI score is then \u201cadjusted for chance\u201d into the ARI score\nusing the following scheme:\nARI = (RI - Expected_RI) / (max(RI) - Expected_RI)\n\nThe adjusted Rand index is thus ensured to have a value close to\n0.0 for random labeling independently of the number of clusters and\nsamples and exactly 1.0 when the clusterings are identical (up to\na permutation).\nARI is a symmetric measure:\nadjusted_rand_index(a, b) == adjusted_rand_index(b, a)\n\n"
                },
                "average_internal_degree": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.average_internal_degree()"
                    ],
                    "References": [],
                    "Description": "The average internal degree of the algorithms set.\n\n\\[f(S) = \\frac{2m_S}{n_S}\\]\nwhere \\(m_S\\) is the number of algorithms internal edges and \\(n_S\\) is the number of algorithms nodes.\n"
                },
                "avg_distance": {
                    "Paramters": {
                        "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
                    },
                    "Return": [
                        "If summary==True a FitnessResult object, otherwise a list of floats."
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Average distance.\nThe average distance of a community is defined average path length across all possible pair of nodes composing it.\n"
                },
                "avg_embeddedness": {
                    "Paramters": {
                        "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
                    },
                    "Return": [
                        "If summary==True a FitnessResult object, otherwise a list of floats."
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Average embeddedness of nodes within the community.\nThe embeddedness of a node n w.r.t. a community C is the ratio of its degree within the community and its overall degree.\n\n\\[emb(n,C) = \\frac{k_n^C}{k_n}\\]\nThe average embeddedness of a community C is:\n\n\\[avg_embd(c) = \\frac{1}{|C|} \\sum_{i \\in C} \\frac{k_n^C}{k_n}\\]\n"
                },
                "avg_odf": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.avg_odf()"
                    ],
                    "References": [],
                    "Description": "Average fraction of edges of a node of a algorithms that point outside the algorithms itself.\n\n\\[\\frac{1}{n_S} \\sum_{u \\in S} \\frac{|\\{(u,v)\\in E: v \\not\\in S\\}|}{d(u)}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\), \\(d(u)\\) is the degree of \\(u\\) and \\(n_S\\) is the set of algorithms nodes.\n"
                },
                "avg_transitivity": {
                    "Paramters": {
                        "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
                    },
                    "Return": [
                        "If summary==True a FitnessResult object, otherwise a list of floats."
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Average transitivity.\nThe average transitivity of a community is defined the as the average clustering coefficient of its nodes w.r.t. their connection within the community itself.\n"
                },
                "conductance": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.conductance()"
                    ],
                    "References": [],
                    "Description": "Fraction of total edge volume that points outside the algorithms.\n\n\\[f(S) = \\frac{c_S}{2 m_S+c_S}\\]\nwhere \\(c_S\\) is the number of algorithms nodes and, \\(m_S\\) is the number of algorithms edges\n"
                },
                "cut_ratio": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.cut_ratio()"
                    ],
                    "References": [],
                    "Description": "Fraction of existing edges (out of all possible edges) leaving the algorithms.\n..math:: f(S) = frac{c_S}{n_S (n \u2212 n_S)}\nwhere \\(c_S\\) is the number of algorithms nodes and, \\(n_S\\) is the number of edges on the algorithms boundary\n"
                },
                "edges_inside": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.edges_inside()"
                    ],
                    "References": [],
                    "Description": "Number of edges internal to the algorithms.\n"
                },
                "erdos_renyi_modularity": {
                    "Paramters": {},
                    "Return": [
                        "the Erdos-Renyi modularity score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.erdos_renyi_modularity()"
                    ],
                    "References": [],
                    "Description": "Erdos-Renyi modularity is a variation of the Newman-Girvan one.\nIt assumes that vertices in a network are connected randomly with a constant probability \\(p\\).\n\n\\[Q(S) = \\frac{1}{m}\\sum_{c \\in S} (m_S \u2212 \\frac{mn_S(n_S \u22121)}{n(n\u22121)})\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms edges, \\(l_S\\) is the number of edges from nodes in S to nodes outside S.\n"
                },
                "expansion": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.expansion()"
                    ],
                    "References": [],
                    "Description": "Number of edges per algorithms node that point outside the cluster.\n\n\\[f(S) = \\frac{c_S}{n_S}\\]\nwhere \\(n_S\\) is the number of edges on the algorithms boundary, \\(c_S\\) is the number of algorithms nodes.\n"
                },
                "f1": {
                    "Paramters": {
                        "clustering": "NodeClustering object"
                    },
                    "Return": [
                        "F1 score (harmonic mean of precision and recall)"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.f1(leiden_communities)"
                    ],
                    "References": [
                        "Rossetti, G., Pappalardo, L., & Rinzivillo, S. (2016). A novel approach to evaluate algorithms detection internal on ground truth. In Complex Networks VII (pp. 133-144). Springer, Cham."
                    ],
                    "Description": "Compute the average F1 score of the optimal algorithms matches among the partitions in input.\nWorks on overlapping/non-overlapping complete/partial coverage partitions.\n"
                },
                "flake_odf": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.flake_odf()"
                    ],
                    "References": [],
                    "Description": "Fraction of nodes in S that have fewer edges pointing inside than to the outside of the algorithms.\n\n\\[f(S) = \\frac{| \\{ u:u \\in S,| \\{(u,v) \\in E: v \\in S \\}| < d(u)/2 \\}|}{n_S}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\), \\(d(u)\\) is the degree of \\(u\\) and \\(n_S\\) is the set of algorithms nodes.\n"
                },
                "fraction_over_median_degree": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.fraction_over_median_degree()"
                    ],
                    "References": [],
                    "Description": "Fraction of algorithms nodes of having internal degree higher than the median degree value.\n\n\\[f(S) = \\frac{|\\{u: u \\in S,| \\{(u,v): v \\in S\\}| > d_m\\}| }{n_S}\\]\nwhere \\(d_m\\) is the internal degree median value\n"
                },
                "get_description": {
                    "Paramters": {
                        "parameters_to_display": "parameters to display. By default, all float parameters.",
                        "precision": "precision used to plot parameters. default: 3"
                    },
                    "Return": [
                        "a string description of the method.\n"
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Return a description of the clustering, with the name of the method and its numeric parameters.\n"
                },
                "hub_dominance": {
                    "Paramters": {
                        "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
                    },
                    "Return": [
                        "If summary==True a FitnessResult object, otherwise a list of floats."
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Hub dominance.\nThe hub dominance of a community is defined as the ratio of the degree of its most connected node w.r.t. the theoretically maximal degree within the community.\n"
                },
                "internal_edge_density": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.internal_edge_density()"
                    ],
                    "References": [],
                    "Description": "The internal density of the algorithms set.\n\n\\[f(S) = \\frac{m_S}{n_S(n_S\u22121)/2}\\]\nwhere \\(m_S\\) is the number of algorithms internal edges and \\(n_S\\) is the number of algorithms nodes.\n"
                },
                "link_modularity": {
                    "Paramters": {},
                    "Return": [
                        "the link modularity score"
                    ],
                    "Example": [
                        "from cdlib import evaluation\nfrom cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.link_modularity()"
                    ],
                    "References": [],
                    "Description": "Quality function designed for directed graphs with overlapping communities.\n"
                },
                "max_odf": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.max_odf()"
                    ],
                    "References": [],
                    "Description": "Maximum fraction of edges of a node of a algorithms that point outside the algorithms itself.\n\n\\[max_{u \\in S} \\frac{|\\{(u,v)\\in E: v \\not\\in S\\}|}{d(u)}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\) and \\(d(u)\\) is the degree of \\(u\\)\n"
                },
                "modularity_density": {
                    "Paramters": {},
                    "Return": [
                        "the modularity density score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.modularity_density()"
                    ],
                    "References": [],
                    "Description": "The modularity density is one of several propositions that envisioned to palliate the resolution limit issue of modularity based measures.\nThe idea of this metric is to include the information about algorithms size into the expected density of algorithms to avoid the negligence of small and dense communities.\nFor each algorithms \\(C\\) in partition \\(S\\), it uses the average modularity degree calculated by \\(d(C) = d^{int(C)} \u2212 d^{ext(C)}\\) where \\(d^{int(C)}\\) and \\(d^{ext(C)}\\) are the average internal and external degrees of \\(C\\) respectively to evaluate the fitness of \\(C\\) in its network.\nFinally, the modularity density can be calculated as follows:\n\n\\[Q(S) = \\sum_{C \\in S} \\frac{1}{n_C} ( \\sum_{i \\in C} k^{int}_{iC} - \\sum_{i \\in C} k^{out}_{iC})\\]\nwhere \\(n_C\\) is the number of nodes in C, \\(k^{int}_{iC}\\) is the degree of node i within \\(C\\) and \\(k^{out}_{iC}\\) is the deree of node i outside \\(C\\).\n"
                },
                "modularity_overlap": {
                    "Paramters": {
                        "weight": "label identifying the edge weight parameter name (if present), default None"
                    },
                    "Return": [
                        "FitnessResult object"
                    ],
                    "Example": [],
                    "References": [
                        "\nLazar, D. Abel and T. Vicsek, \u201cModularity measure of networks with overlapping communities\u201d  EPL, 90 (2010) 18001 doi: 10.1209/0295-5075/90/18001\n\n",
                        "Lazar, D. Abel and T. Vicsek, \u201cModularity measure of networks with overlapping communities\u201d  EPL, 90 (2010) 18001 doi: 10.1209/0295-5075/90/18001"
                    ],
                    "Description": "Determines the Overlapping Modularity of a partition C on a graph G.\nOverlapping Modularity is defined as\n\n\\[M_{c_{r}}^{ov} = \\sum_{i \\in c_{r}} \\frac{\\sum_{j \\in c_{r}, i \\neq j}a_{ij} - \\sum_{j \\not \\in c_{r}}a_{ij}}{d_{i} \\cdot s_{i}} \\cdot \\frac{n_{c_{r}}^{e}}{n_{c_{r}} \\cdot \\binom{n_{c_{r}}}{2}}\\]\n"
                },
                "newman_girvan_modularity": {
                    "Paramters": {},
                    "Return": [
                        "the Newman-Girvan modularity score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.newman_girvan_modularity()"
                    ],
                    "References": [],
                    "Description": "Difference the fraction of intra algorithms edges of a partition with the expected number of such edges if distributed according to a null model.\nIn the standard version of modularity, the null model preserves the expected degree sequence of the graph under consideration. In other words, the modularity compares the real network structure with a corresponding one where nodes are connected without any preference about their neighbors.\n\n\\[Q(S) = \\frac{1}{m}\\sum_{c \\in S}(m_S - \\frac{(2 m_S + l_S)^2}{4m})\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms edges, \\(l_S\\) is the number of edges from nodes in S to nodes outside S.\n"
                },
                "nf1": {
                    "Paramters": {
                        "clustering": "NodeClustering object"
                    },
                    "Return": [
                        "MatchingResult instance"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.nf1(leiden_communities)"
                    ],
                    "References": [
                        "Rossetti, G., Pappalardo, L., & Rinzivillo, S. (2016). A novel approach to evaluate algorithms detection internal on ground truth.",
                        "Rossetti, G. (2017). : RDyn: graph benchmark handling algorithms dynamics. Journal of Complex Networks. 5(6), 893-912."
                    ],
                    "Description": "Compute the Normalized F1 score of the optimal algorithms matches among the partitions in input.\nWorks on overlapping/non-overlapping complete/partial coverage partitions.\n"
                },
                "normalized_cut": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.normalized_cut()"
                    ],
                    "References": [],
                    "Description": "Normalized variant of the Cut-Ratio\n\n\\[: f(S) = \\frac{c_S}{2m_S+c_S} + \\frac{c_S}{2(m\u2212m_S )+c_S}\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms internal edges and \\(c_S\\) is the number of algorithms nodes.\n"
                },
                "normalized_mutual_information": {
                    "Paramters": {
                        "clustering": "NodeClustering object"
                    },
                    "Return": [
                        "normalized mutual information score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.normalized_mutual_information(leiden_communities)"
                    ],
                    "References": [],
                    "Description": "Normalized Mutual Information between two clusterings.\nNormalized Mutual Information (NMI) is an normalization of the Mutual\nInformation (MI) score to scale the results between 0 (no mutual\ninformation) and 1 (perfect correlation). In this function, mutual\ninformation is normalized by sqrt(H(labels_true) * H(labels_pred))\n"
                },
                "omega": {
                    "Paramters": {
                        "clustering": "NodeClustering object"
                    },
                    "Return": [
                        "omega index"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.omega(leiden_communities)"
                    ],
                    "References": [
                        "Gabriel Murray, Giuseppe Carenini, and Raymond Ng. 2012. Using the omega index for evaluating abstractive algorithms detection. In Proceedings of Workshop on Evaluation Metrics and System Comparison for Automatic Summarization. Association for Computational Linguistics, Stroudsburg, PA, USA, 10-18."
                    ],
                    "Description": "Index of resemblance for overlapping, complete coverage, network clusterings.\n"
                },
                "overlapping_normalized_mutual_information_LFK": {
                    "Paramters": {
                        "clustering": "NodeClustering object"
                    },
                    "Return": [
                        "onmi score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.overlapping_normalized_mutual_information_LFK(leiden_communities)"
                    ],
                    "References": [
                        "Lancichinetti, A., Fortunato, S., & Kertesz, J. (2009). Detecting the overlapping and hierarchical community structure in complex networks. New Journal of Physics, 11(3), 033015."
                    ],
                    "Description": "Overlapping Normalized Mutual Information between two clusterings.\nExtension of the Normalized Mutual Information (NMI) score to cope with overlapping partitions.\nThis is the version proposed by Lancichinetti et al.\n"
                },
                "overlapping_normalized_mutual_information_MGH": {
                    "Paramters": {
                        "clustering": "NodeClustering object",
                        "normalization": "one of \u201cmax\u201d or \u201cLFK\u201d. Default \u201cmax\u201d (corresponds to the main method described in the article)"
                    },
                    "Return": [
                        "onmi score\n"
                    ],
                    "Example": [
                        "from cdlib import evaluation, algorithms\ng = nx.karate_club_graph()\nlouvain_communities = algorithms.louvain(g)\nleiden_communities = algorithms.leiden(g)\nevaluation.overlapping_normalized_mutual_information_MGH(louvain_communities,leiden_communities)"
                    ],
                    "References": [
                        "McDaid, A. F., Greene, D., & Hurley, N. (2011). Normalized mutual information to evaluate overlapping community finding algorithms. arXiv preprint arXiv:1110.2515. Chicago"
                    ],
                    "Description": "Overlapping Normalized Mutual Information between two clusterings.\nExtension of the Normalized Mutual Information (NMI) score to cope with overlapping partitions.\nThis is the version proposed by McDaid et al. using a different normalization than the original LFR one. See ref.\nfor more details.\n"
                },
                "scaled_density": {
                    "Paramters": {
                        "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
                    },
                    "Return": [
                        "If summary==True a FitnessResult object, otherwise a list of floats."
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Scaled density.\nThe scaled density of a community is defined as the ratio of the community density w.r.t. the complete graph density.\n"
                },
                "significance": {
                    "Paramters": {},
                    "Return": [
                        "the significance score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.significance()"
                    ],
                    "References": [],
                    "Description": "Significance estimates how likely a partition of dense communities appear in a random graph.\n"
                },
                "size": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Size is the number of nodes in the community\n"
                },
                "surprise": {
                    "Paramters": {},
                    "Return": [
                        "the surprise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.surprise()"
                    ],
                    "References": [],
                    "Description": "Surprise is statistical approach proposes a quality metric assuming that edges between vertices emerge randomly according to a hyper-geometric distribution.\nAccording to the Surprise metric, the higher the score of a partition, the less likely it is resulted from a random realization, the better the quality of the algorithms structure.\n"
                },
                "to_json": {
                    "Paramters": {},
                    "Return": [
                        "a JSON formatted string representing the object"
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Generate a JSON representation of the algorithms object\n"
                },
                "to_node_community_map": {
                    "Paramters": {},
                    "Return": [
                        "dict of the form <node, list(communities)>"
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Generate a <node, list(communities)> representation of the current clustering\n"
                },
                "triangle_participation_ratio": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.triangle_participation_ratio()"
                    ],
                    "References": [],
                    "Description": "Fraction of algorithms nodes that belong to a triad.\n\n\\[f(S) = \\frac{ | \\{ u: u \\in S,\\{(v,w):v, w \\in S,(u,v) \\in E,(u,w) \\in E,(v,w) \\in E \\} \\not = \\emptyset \\} |}{n_S}\\]\nwhere \\(n_S\\) is the set of algorithms nodes.\n"
                },
                "variation_of_information": {
                    "Paramters": {
                        "clustering": "NodeClustering object"
                    },
                    "Return": [
                        "VI score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.variation_of_information(leiden_communities)"
                    ],
                    "References": [
                        "Meila, M. (2007). Comparing clusterings - an information based distance. Journal of Multivariate Analysis, 98, 873-895. doi:10.1016/j.jmva.2006.11.013"
                    ],
                    "Description": "Variation of Information among two nodes partitions.\n$$ H(p)+H(q)-2MI(p, q) $$\nwhere MI is the mutual information, H the partition entropy and p,q are the algorithms sets\n"
                },
                "z_modularity": {
                    "Paramters": {},
                    "Return": [
                        "the z-modularity score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.z_modularity()"
                    ],
                    "References": [],
                    "Description": "Z-modularity is another variant of the standard modularity proposed to avoid the resolution limit.\nThe concept of this version is based on an observation that the difference between the fraction of edges inside communities and the expected number of such edges in a null model should not be considered as the only contribution to the final quality of algorithms structure.\n"
                }
            }
        }
    },
    {
        "Section_id": "MatchingResult",
        "Description": "Initialize self.  See help(type(self)) for accurate signature.",
        "Field List": {
            "Parameters": {},
            "Methods": {}
        }
    },
    {
        "Section_id": "expansion",
        "Description": "Number of edges per community node that point outside the cluster.\n\n\\[f(S) = \\frac{c_S}{n_S}\\]\nwhere \\(c_S\\) is the number of edges on the community boundary, \\(n_S\\) is the number of community nodes.\n",
        "Parameters": {
            "graph": "a networkx/igraph object",
            "community": "NodeClustering object",
            "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
        },
        "Return": [
            "If summary==True a FitnessResult object, otherwise a list of floats.\n"
        ],
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = evaluation.expansion(g,communities)"
        ],
        "References": [
            "Radicchi, F., Castellano, C., Cecconi, F., Loreto, V., & Parisi, D. (2004). Defining and identifying communities in networks. Proceedings of the National Academy of Sciences, 101(9), 2658-2663."
        ]
    },
    {
        "Section_id": "walktrap",
        "Description": "walktrap is an approach based on random walks.\nThe general idea is that if you perform random walks on the graph, then the walks are more likely to stay within the same community because there are only a few edges that lead outside a given community. Walktrap runs short random walks and uses the results of these random walks to merge separate communities in a bottom-up manner.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object"
        },
        "Return": [
            "NodeClusterint object"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.walktrap(G)"
        ],
        "References": []
    },
    {
        "Section_id": "avg_odf",
        "Description": "Average fraction of edges of a node of a community that point outside the community itself.\n\n\\[\\frac{1}{n_S} \\sum_{u \\in S} \\frac{|\\{(u,v)\\in E: v \\not\\in S\\}|}{d(u)}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\), \\(d(u)\\) is the degree of \\(u\\) and \\(n_S\\) is the set of community nodes.\n",
        "Parameters": {
            "graph": "a networkx/igraph object",
            "community": "NodeClustering object",
            "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
        },
        "Return": [
            "If summary==True a FitnessResult object, otherwise a list of floats.\n"
        ],
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = evaluation.avg_odf(g,communities)"
        ],
        "References": [
            "Flake, G.W., Lawrence, S., Giles, C.L., et al.: Efficient identification of web communities. In: KDD, vol. 2000, pp. 150\u2013160 (2000)"
        ]
    },
    {
        "Section_id": "pool_grid_filter",
        "Description": "Execute a pool of community discovery internal on the input graph.\nReturns the optimal partition for each algorithm given the specified quality function.\n",
        "Parameters": {
            "methods": "list community discovery methods (from nclib.community)",
            "graph": "networkx/igraph object",
            "configurations": "list of lists (one for each method) of Parameter and BoolParameter objects",
            "quality_score": "a fitness function to evaluate the obtained partition (from nclib.evaluation)",
            "aggregate": "function to select the best fitness value. Possible values: min/max"
        },
        "Return": [
            "at each call the generator yields a tuple composed by: the actual method, its optimal configuration; the obtained communities; the fitness score.\n"
        ],
        "Example": [
            "import networkx as nx\nfrom cdlib import algorithms, ensemble\ng = nx.karate_club_graph()\n# Louvain\nresolution = ensemble.Parameter(name=\"resolution\", start=0.1, end=1, step=0.1)\nrandomize = ensemble.BoolParameter(name=\"randomize\")\nlouvain_conf = [resolution, randomize]\n# Angel\nthreshold = ensemble.Parameter(name=\"threshold\", start=0.1, end=1, step=0.1)\nangel_conf = [threshold]\nmethods = [algorithms.louvain, algorithms.angel]\nfor communities, scoring in ensemble.pool_grid_filter(g, methods, [louvain_conf, angel_conf], quality_score=evaluation.erdos_renyi_modularity, aggregate=max):\n    print(communities, scoring)"
        ],
        "References": []
    },
    {
        "Section_id": "EdgeClustering",
        "Description": "Edge Clustering representation.",
        "Field List": {
            "Parameters": {
                "communities": "list of communities",
                "graph": "a networkx/igraph object",
                "method_name": "community discovery algorithm name",
                "method_parameters": "configuration for the community discovery algorithm used",
                "overlap": "boolean, whether the partition is overlapping or not"
            },
            "Methods": {
                "get_description": {
                    "Paramters": {
                        "parameters_to_display": "parameters to display. By default, all float parameters.",
                        "precision": "precision used to plot parameters. default: 3"
                    },
                    "Return": [
                        "a string description of the method.\n"
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Return a description of the clustering, with the name of the method and its numeric parameters.\n"
                },
                "to_edge_community_map": {
                    "Paramters": {},
                    "Return": [
                        "dict of the form <edge, list(communities)>"
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Generate a <edge, list(communities)> representation of the current clustering\n"
                },
                "to_json": {
                    "Paramters": {},
                    "Return": [
                        "a JSON formatted string representing the object"
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Generate a JSON representation of the algorithms object\n"
                }
            }
        }
    },
    {
        "Section_id": "async_fluid",
        "Description": "Fluid Communities (FluidC) is based on the simple idea of fluids (i.e., communities) interacting in an environment (i.e., a non-complete graph), expanding and contracting.\nIt is propagation-based algorithm and it allows to specify the number of desired communities (k) and it is asynchronous, where each vertex update is computed using the latest partial state of the graph.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "k": "Number of communities to search"
        },
        "Return": [
            "EdgeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.async_fluid(G,k=2)"
        ],
        "References": []
    },
    {
        "Section_id": "em",
        "Description": "EM is based on based on a mixture model.\nThe algorithm uses the expectation\u2013maximization algorithm to detect structure in networks.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "k": "the number of desired communities"
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncom = algorithms.em(G, k=3)"
        ],
        "References": []
    },
    {
        "Section_id": "scaled_density",
        "Description": "Scaled density.\nThe scaled density of a community is defined as the ratio of the community density w.r.t. the complete graph density.\n",
        "Parameters": {
            "graph": "a networkx/igraph object",
            "communities": "NodeClustering object",
            "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
        },
        "Return": [
            "If summary==True a FitnessResult object, otherwise a list of floats.\n"
        ],
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nscd = evaluation.scaled_density(g,communities)"
        ],
        "References": []
    },
    {
        "Section_id": "grid_execution",
        "Description": "Instantiate the specified community discovery method performing a grid search on the parameter set.\n",
        "Parameters": {
            "method": "community discovery method (from nclib.community)",
            "graph": "networkx/igraph object",
            "parameters": "list of Parameter and BoolParameter objects"
        },
        "Return": [
            "at each call the generator yields a tuple composed by the current configuration and the obtained communities\n"
        ],
        "Example": [
            "import networkx as nx\nfrom cdlib import algorithms, ensemble\ng = nx.karate_club_graph()\nresolution = ensemble.Parameter(name=\"resolution\", start=0.1, end=1, step=0.1)\nfor communities in ensemble.grid_execution(graph=g, method=algorithms.louvain, parameters=[resolution]):\n    print(communities)"
        ],
        "References": []
    },
    {
        "Section_id": "surprise_communities",
        "Description": "Surprise_communities is a model where the quality function to optimize is:\n\n\\[Q = m D(q \\parallel \\langle q \\rangle)\\]\nwhere \\(m\\) is the number of edges,  \\(q = \\frac{\\sum_c m_c}{m}\\),  is the fraction of internal edges, \\(\\langle q \\rangle = \\frac{\\sum_c \\binom{n_c}{2}}{\\binom{n}{2}}\\) is the expected fraction of internal edges, and finally\n\\(D(x \\parallel y) = x \\ln \\frac{x}{y} + (1 - x) \\ln \\frac{1 - x}{1 - y}\\)  is the binary Kullback-Leibler divergence.\nFor directed graphs we can multiplying the binomials by 2, and this leaves \\(\\langle q \\rangle\\) unchanged, so that we can simply use the same\nformulation.  For weighted graphs we can simply count the total internal weight instead of the total number of edges for \\(q\\) , while \\(\\langle q \\rangle\\) remains unchanged.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "initial_membership": "list of int Initial membership for the partition. IfNonethen defaults to a singleton partition. Deafault None",
            "weights": "list of double, or edge attribute Weights of edges. Can be either an iterable or an edge attribute. Deafault None",
            "node_sizes": "list of int, or vertex attribute Sizes of nodes are necessary to know the size of communities in aggregate graphs. Usually this is set to 1 for all nodes, but in specific cases  this could be changed. Deafault None"
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.surprise_communities(G)"
        ],
        "References": []
    },
    {
        "Section_id": "internal_edge_density",
        "Description": "The internal density of the community set.\n",
        "Parameters": {
            "graph": "a networkx/igraph object",
            "community": "NodeClustering object",
            "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
        },
        "Return": [
            "If summary==True a FitnessResult object, otherwise a list of floats.\n"
        ],
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = evaluation.internal_edge_density(g,communities)"
        ],
        "References": [
            "Radicchi, F., Castellano, C., Cecconi, F., Loreto, V., & Parisi, D. (2004). Defining and identifying communities in networks. Proceedings of the National Academy of Sciences, 101(9), 2658-2663."
        ]
    },
    {
        "Section_id": "spinglass",
        "Description": "Spinglass relies on an analogy between a very popular statistical mechanic model called Potts spin glass, and the community structure.\nIt applies the simulated annealing optimization technique on this model to optimize the modularity.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "spins": "the number of spins to use. This is the upper limit for the number of communities. It is not a problem to supply a (reasonably) big number here, in which case some spin states will be unpopulated."
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncom = algorithms.spinglass(G)"
        ],
        "References": []
    },
    {
        "Section_id": "lpam",
        "Description": "Link Partitioning Around Medoids\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "k": "number of clusters",
            "threshold": "merging threshold in [0,1], default 0.5",
            "distance": "type of distance: \u201camp\u201d - amplified commute distance, or \u201ccm\u201d - commute distance, or distance matrix between all edges as np ndarray",
            "seed": "random seed for k-medoid heuristic"
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.lpam(G, k=2, threshold=0.4, distance = \"amp\")"
        ],
        "References": []
    },
    {
        "Section_id": "slpa",
        "Description": "SLPA is an overlapping community discovery that extends tha LPA.\nSLPA consists of the following three stages:\n1) the initialization\n2) the evolution\n3) the post-processing\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "t": "maximum number of iterations, default 20",
            "r": "threshold  \u2208 [0, 1]. It is used in the post-processing stage: if the probability of seeing a particular label during the whole process is less than r, this label is deleted from a node\u2019s memory. Default 0.1"
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.slpa(G,  t=21, r=0.1)"
        ],
        "References": []
    },
    {
        "Section_id": "lpanni",
        "Description": "LPANNI (Label Propagation Algorithm with Neighbor Node Influence) detects overlapping community structures by adopting fixed label propagation sequence based on the ascending order of node importance and label update strategy based on neighbor node influence and historical label preferred strategy.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "threshold": "Default 0.0001"
        },
        "Return": [],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.lpanni(G)"
        ],
        "References": []
    },
    {
        "Section_id": "adjusted_rand_index",
        "Description": "Rand index adjusted for chance.\nThe Rand Index computes a similarity measure between two clusterings\nby considering all pairs of samples and counting pairs that are\nassigned in the same or different clusters in the predicted and\ntrue clusterings.\nThe raw RI score is then \u201cadjusted for chance\u201d into the ARI score\nusing the following scheme:\nARI = (RI - Expected_RI) / (max(RI) - Expected_RI)\n\nThe adjusted Rand index is thus ensured to have a value close to\n0.0 for random labeling independently of the number of clusters and\nsamples and exactly 1.0 when the clusterings are identical (up to\na permutation).\nARI is a symmetric measure:\nadjusted_rand_index(a, b) == adjusted_rand_index(b, a)\n\n",
        "Parameters": {
            "first_partition": "NodeClustering object",
            "second_partition": "NodeClustering object"
        },
        "Return": [
            "MatchingResult object\n"
        ],
        "Example": [
            "from cdlib import evaluation, algorithms\ng = nx.karate_club_graph()\nlouvain_communities = algorithms.louvain(g)\nleiden_communities = algorithms.leiden(g)\nevaluation.adjusted_rand_index(louvain_communities,leiden_communities)"
        ],
        "References": [
            "Hubert, L., & Arabie, P. (1985). Comparing partitions. Journal of classification, 2(1), 193-218."
        ]
    },
    {
        "Section_id": "tiles",
        "Description": "TILES is designed to incrementally identify and update communities in stream graphs.\nThis implementation assume an explicit edge removal when pairwise interactions cease to exist.\nSupported Graph Types\n",
        "Parameters": {
            "dg": "dynetx graph object",
            "obs": "community observation interval (default=1)"
        },
        "Return": [
            "TemporalClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport dynetx as dn\ndg = dn.DynGraph()\nfor x in range(10):\n    g = nx.erdos_renyi_graph(200, 0.05)\n    dg.add_interactions_from(list(g.edges()), t=x)\ncoms = algorithms.tiles(dg, 2)"
        ],
        "References": []
    },
    {
        "Section_id": "significance_communities",
        "Description": "Significance_communities is a model where the quality function to optimize is:\n\n\\[Q = \\sum_c \\binom{n_c}{2} D(p_c \\parallel p)\\]\nwhere \\(n_c\\) is the number of nodes in community \\(c\\), \\(p_c = \\frac{m_c}{\\binom{n_c}{2}}\\), is the density of community \\(c\\),  \\(p = \\frac{m}{\\binom{n}{2}}\\)  is the overall density of the graph, and finally  \\(D(x \\parallel y) = x \\ln \\frac{x}{y} + (1 - x) \\ln \\frac{1 - x}{1 - y}\\) is the binary Kullback-Leibler divergence.\nFor directed graphs simply multiply the binomials by 2. The expected Significance in Erdos-Renyi graphs behaves roughly as \\(\\frac{1}{2} n \\ln n\\) for both directed and undirected graphs in this formulation.\n\nWarning\nThis method is not suitable for weighted graphs.\n\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "initial_membership": "list of int Initial membership for the partition. IfNonethen defaults to a singleton partition. Deafault None",
            "node_sizes": "list of int, or vertex attribute Sizes of nodes are necessary to know the size of communities in aggregate graphs. Usually this is set to 1 for all nodes, but in specific cases  this could be changed. Deafault None"
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.significance_communities(G)"
        ],
        "References": []
    },
    {
        "Section_id": "average_internal_degree",
        "Description": "The average internal degree of the community set.\n\n\\[ \\begin{align}\\begin{aligned}f(S) = \\frac{2m_S}{n_S}\\\\where :math:`m_S` is the number of community internal edges and :math:`n_S` is the number of community nodes.\\end{aligned}\\end{align} \\]\n",
        "Parameters": {
            "graph": "a networkx/igraph object",
            "community": "NodeClustering object",
            "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
        },
        "Return": [
            "If summary==True a FitnessResult object, otherwise a list of floats.\n"
        ],
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = evaluation.average_internal_degree(g,communities)"
        ],
        "References": [
            "Radicchi, F., Castellano, C., Cecconi, F., Loreto, V., & Parisi, D. (2004). Defining and identifying communities in networks. Proceedings of the National Academy of Sciences, 101(9), 2658-2663."
        ]
    },
    {
        "Section_id": "conductance",
        "Description": "Fraction of total edge volume that points outside the community.\n\n\\[f(S) = \\frac{c_S}{2 m_S+c_S}\\]\nwhere \\(c_S\\) is the number of community nodes and, \\(m_S\\) is the number of community edges\n",
        "Parameters": {
            "graph": "a networkx/igraph object",
            "community": "NodeClustering object",
            "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
        },
        "Return": [
            "If summary==True a FitnessResult object, otherwise a list of floats.\n"
        ],
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = evaluation.conductance(g,communities)"
        ],
        "References": []
    },
    {
        "Section_id": "sbm_dl_nested",
        "Description": "Efficient Monte Carlo and greedy heuristic for the inference of stochastic block models. (nested)\nFit a nested non-overlapping stochastic block model (SBM) by minimizing its description length using an agglomerative heuristic.\nReturn the lowest level found. Currently cdlib do not support hierarchical clustering.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "igraph/networkx object"
        },
        "Return": [
            "NodeClustering object"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.sbm_dl(G)"
        ],
        "References": []
    },
    {
        "Section_id": "bayan",
        "Description": "The Bayan algorithm is community detection method that is capable of providing a globally optimal solution to the modularity maximization problem.\nBayan can also be implemented such that it provides an approximation of the maximum modularity with a guarantee of proximity.\nThis algorithm is theoretically grounded by the Integer Programming (IP) formulation of the modularity maximization problem and relies on an exact branch-and-cut scheme for solving the NP-complete optimization problem to global optimality.\nThe algorithm is integrated as an optional feature in CDlib due to its dependency on the Gurobi solver.\nFor a detailed description on how to satisfy such a dependency please refer to the instructions provided in the official documentation: https://github.com/saref/bayan\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "threshold": "Threshold is the minimum optimality gap that Bayan should execute till. In the above example if Bayan finds a solution with modularity within 0.001 of the optimal solution, it will return that solution.",
            "time_allowed": "Time allowed is the maximum time in seconds that Bayan should execute for.",
            "resolution": "Resolution is the resolution parameter of the modularity function."
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncom = algorithms.bayan(G)"
        ],
        "References": []
    },
    {
        "Section_id": "coach",
        "Description": "The motivation behind the core-attachment (CoAch) algorithm  comes from the observation that protein complexes often have a dense core of highly interactive proteins.\nCoAch works in two steps, \ufb01rst discovering highly connected regions (\u201cpreliminary cores\u201d) of a network and then expanding these regions by adding strongly associated neighbors.\nThe algorithm operates with three user-speci\ufb01ed parameters: minimum core density (for preliminary cores), maximum core affinity (similarity threshold for distinct preliminary cores), and minimum neighbor closeness (for attaching non-core neighbors to preliminary cores).\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "density_threshold": "minimum core density. Default, 0.7",
            "affinity_threshold": "maximum core affinity. Default, 0.225",
            "closeness_threshold": "minimum neighbor closeness. Default, 0.5"
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.coach(G)"
        ],
        "References": []
    },
    {
        "Section_id": "markov_clustering",
        "Description": "The Markov clustering algorithm (MCL) is based on simulation of (stochastic) flow in graphs.\nThe MCL algorithm finds cluster structure in graphs by a mathematical bootstrapping procedure. The process deterministically computes (the probabilities of) random walks through the graph, and uses two operators transforming one set of probabilities into another. It does so using the language of stochastic matrices (also called Markov matrices) which capture the mathematical concept of random walks on a graph.\nThe MCL algorithm simulates random walks within a graph by alternation of two operators called expansion and inflation.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "expansion": "The cluster expansion factor",
            "inflation": "The cluster inflation factor",
            "loop_value": "Initialization value for self-loops",
            "iterations": "Maximum number of iterations\n(actual number of iterations will be less if convergence is reached)",
            "pruning_threshold": "Threshold below which matrix elements will be set set to 0",
            "pruning_frequency": "Perform pruning every \u2018pruning_frequency\u2019\niterations.",
            "convergence_check_frequency": "Perform the check for convergence\nevery convergence_check_frequency iterations"
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.markov_clustering(G)"
        ],
        "References": []
    },
    {
        "Section_id": "read_community_json",
        "Description": "Read community list from JSON file.\n",
        "Parameters": {
            "path": "input filename",
            "compress": "wheter the file is in a copress format, default False"
        },
        "Return": [
            "a Clustering object\n"
        ],
        "Example": [
            "import networkx as nx\nfrom cdlib import algorithms, readwrite\ng = nx.karate_club_graph()\ncoms = algorithms.louvain(g)\nreadwrite.write_community_json(coms, \"communities.json\")\nreadwrite.read_community_json(coms, \"communities.json\")"
        ],
        "References": []
    },
    {
        "Section_id": "BiNodeClustering",
        "Description": "Bipartite Node Communities representation.",
        "Field List": {
            "Parameters": {
                "left_communities": "list of left communities",
                "right_communities": "list of right communities",
                "graph": "a networkx/igraph object",
                "method_name": "community discovery algorithm name",
                "method_parameters": "configuration for the community discovery algorithm used",
                "overlap": "boolean, whether the partition is overlapping or not"
            },
            "Methods": {
                "adjusted_mutual_information": {
                    "Paramters": {
                        "clustering": "NodeClustering object"
                    },
                    "Return": [
                        "AMI score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.adjusted_mutual_information(leiden_communities)"
                    ],
                    "References": [
                        "Vinh, N. X., Epps, J., & Bailey, J. (2010). Information theoretic measures for clusterings comparison: Variants, properties, normalization and correction for chance. Journal of Machine Learning Research, 11(Oct), 2837-2854."
                    ],
                    "Description": "Adjusted Mutual Information between two clusterings.\nAdjusted Mutual Information (AMI) is an adjustment of the Mutual\nInformation (MI) score to account for chance. It accounts for the fact that\nthe MI is generally higher for two clusterings with a larger number of\nclusters, regardless of whether there is actually more information shared.\nFor two clusterings \\(U\\) and \\(V\\), the AMI is given as:\nAMI(U, V) = [MI(U, V) - E(MI(U, V))] / [max(H(U), H(V)) - E(MI(U, V))]\n\nThis metric is independent of the absolute values of the labels:\na permutation of the class or cluster label values won\u2019t change the\nscore value in any way.\nThis metric is furthermore symmetric: switching label_true with\nlabel_pred will return the same score value. This can be useful to\nmeasure the agreement of two independent label assignments strategies\non the same dataset when the real ground truth is not known.\nBe mindful that this function is an order of magnitude slower than other\nmetrics, such as the Adjusted Rand Index.\n"
                },
                "adjusted_rand_index": {
                    "Paramters": {
                        "clustering": "NodeClustering object"
                    },
                    "Return": [
                        "ARI score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.adjusted_rand_index(leiden_communities)"
                    ],
                    "References": [
                        "Hubert, L., & Arabie, P. (1985). Comparing partitions. Journal of classification, 2(1), 193-218."
                    ],
                    "Description": "Rand index adjusted for chance.\nThe Rand Index computes a similarity measure between two clusterings\nby considering all pairs of samples and counting pairs that are\nassigned in the same or different clusters in the predicted and\ntrue clusterings.\nThe raw RI score is then \u201cadjusted for chance\u201d into the ARI score\nusing the following scheme:\nARI = (RI - Expected_RI) / (max(RI) - Expected_RI)\n\nThe adjusted Rand index is thus ensured to have a value close to\n0.0 for random labeling independently of the number of clusters and\nsamples and exactly 1.0 when the clusterings are identical (up to\na permutation).\nARI is a symmetric measure:\nadjusted_rand_index(a, b) == adjusted_rand_index(b, a)\n\n"
                },
                "average_internal_degree": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.average_internal_degree()"
                    ],
                    "References": [],
                    "Description": "The average internal degree of the algorithms set.\n\n\\[f(S) = \\frac{2m_S}{n_S}\\]\nwhere \\(m_S\\) is the number of algorithms internal edges and \\(n_S\\) is the number of algorithms nodes.\n"
                },
                "avg_distance": {
                    "Paramters": {
                        "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
                    },
                    "Return": [
                        "If summary==True a FitnessResult object, otherwise a list of floats."
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Average distance.\nThe average distance of a community is defined average path length across all possible pair of nodes composing it.\n"
                },
                "avg_embeddedness": {
                    "Paramters": {
                        "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
                    },
                    "Return": [
                        "If summary==True a FitnessResult object, otherwise a list of floats."
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Average embeddedness of nodes within the community.\nThe embeddedness of a node n w.r.t. a community C is the ratio of its degree within the community and its overall degree.\n\n\\[emb(n,C) = \\frac{k_n^C}{k_n}\\]\nThe average embeddedness of a community C is:\n\n\\[avg_embd(c) = \\frac{1}{|C|} \\sum_{i \\in C} \\frac{k_n^C}{k_n}\\]\n"
                },
                "avg_odf": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.avg_odf()"
                    ],
                    "References": [],
                    "Description": "Average fraction of edges of a node of a algorithms that point outside the algorithms itself.\n\n\\[\\frac{1}{n_S} \\sum_{u \\in S} \\frac{|\\{(u,v)\\in E: v \\not\\in S\\}|}{d(u)}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\), \\(d(u)\\) is the degree of \\(u\\) and \\(n_S\\) is the set of algorithms nodes.\n"
                },
                "avg_transitivity": {
                    "Paramters": {
                        "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
                    },
                    "Return": [
                        "If summary==True a FitnessResult object, otherwise a list of floats."
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Average transitivity.\nThe average transitivity of a community is defined the as the average clustering coefficient of its nodes w.r.t. their connection within the community itself.\n"
                },
                "conductance": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.conductance()"
                    ],
                    "References": [],
                    "Description": "Fraction of total edge volume that points outside the algorithms.\n\n\\[f(S) = \\frac{c_S}{2 m_S+c_S}\\]\nwhere \\(c_S\\) is the number of algorithms nodes and, \\(m_S\\) is the number of algorithms edges\n"
                },
                "cut_ratio": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.cut_ratio()"
                    ],
                    "References": [],
                    "Description": "Fraction of existing edges (out of all possible edges) leaving the algorithms.\n..math:: f(S) = frac{c_S}{n_S (n \u2212 n_S)}\nwhere \\(c_S\\) is the number of algorithms nodes and, \\(n_S\\) is the number of edges on the algorithms boundary\n"
                },
                "edges_inside": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.edges_inside()"
                    ],
                    "References": [],
                    "Description": "Number of edges internal to the algorithms.\n"
                },
                "erdos_renyi_modularity": {
                    "Paramters": {},
                    "Return": [
                        "the Erdos-Renyi modularity score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.erdos_renyi_modularity()"
                    ],
                    "References": [],
                    "Description": "Erdos-Renyi modularity is a variation of the Newman-Girvan one.\nIt assumes that vertices in a network are connected randomly with a constant probability \\(p\\).\n\n\\[Q(S) = \\frac{1}{m}\\sum_{c \\in S} (m_S \u2212 \\frac{mn_S(n_S \u22121)}{n(n\u22121)})\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms edges, \\(l_S\\) is the number of edges from nodes in S to nodes outside S.\n"
                },
                "expansion": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.expansion()"
                    ],
                    "References": [],
                    "Description": "Number of edges per algorithms node that point outside the cluster.\n\n\\[f(S) = \\frac{c_S}{n_S}\\]\nwhere \\(n_S\\) is the number of edges on the algorithms boundary, \\(c_S\\) is the number of algorithms nodes.\n"
                },
                "f1": {
                    "Paramters": {
                        "clustering": "NodeClustering object"
                    },
                    "Return": [
                        "F1 score (harmonic mean of precision and recall)"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.f1(leiden_communities)"
                    ],
                    "References": [
                        "Rossetti, G., Pappalardo, L., & Rinzivillo, S. (2016). A novel approach to evaluate algorithms detection internal on ground truth. In Complex Networks VII (pp. 133-144). Springer, Cham."
                    ],
                    "Description": "Compute the average F1 score of the optimal algorithms matches among the partitions in input.\nWorks on overlapping/non-overlapping complete/partial coverage partitions.\n"
                },
                "flake_odf": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.flake_odf()"
                    ],
                    "References": [],
                    "Description": "Fraction of nodes in S that have fewer edges pointing inside than to the outside of the algorithms.\n\n\\[f(S) = \\frac{| \\{ u:u \\in S,| \\{(u,v) \\in E: v \\in S \\}| < d(u)/2 \\}|}{n_S}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\), \\(d(u)\\) is the degree of \\(u\\) and \\(n_S\\) is the set of algorithms nodes.\n"
                },
                "fraction_over_median_degree": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.fraction_over_median_degree()"
                    ],
                    "References": [],
                    "Description": "Fraction of algorithms nodes of having internal degree higher than the median degree value.\n\n\\[f(S) = \\frac{|\\{u: u \\in S,| \\{(u,v): v \\in S\\}| > d_m\\}| }{n_S}\\]\nwhere \\(d_m\\) is the internal degree median value\n"
                },
                "get_description": {
                    "Paramters": {
                        "parameters_to_display": "parameters to display. By default, all float parameters.",
                        "precision": "precision used to plot parameters. default: 3"
                    },
                    "Return": [
                        "a string description of the method.\n"
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Return a description of the clustering, with the name of the method and its numeric parameters.\n"
                },
                "hub_dominance": {
                    "Paramters": {
                        "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
                    },
                    "Return": [
                        "If summary==True a FitnessResult object, otherwise a list of floats."
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Hub dominance.\nThe hub dominance of a community is defined as the ratio of the degree of its most connected node w.r.t. the theoretically maximal degree within the community.\n"
                },
                "internal_edge_density": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.internal_edge_density()"
                    ],
                    "References": [],
                    "Description": "The internal density of the algorithms set.\n\n\\[f(S) = \\frac{m_S}{n_S(n_S\u22121)/2}\\]\nwhere \\(m_S\\) is the number of algorithms internal edges and \\(n_S\\) is the number of algorithms nodes.\n"
                },
                "link_modularity": {
                    "Paramters": {},
                    "Return": [
                        "the link modularity score"
                    ],
                    "Example": [
                        "from cdlib import evaluation\nfrom cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.link_modularity()"
                    ],
                    "References": [],
                    "Description": "Quality function designed for directed graphs with overlapping communities.\n"
                },
                "max_odf": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.max_odf()"
                    ],
                    "References": [],
                    "Description": "Maximum fraction of edges of a node of a algorithms that point outside the algorithms itself.\n\n\\[max_{u \\in S} \\frac{|\\{(u,v)\\in E: v \\not\\in S\\}|}{d(u)}\\]\nwhere \\(E\\) is the graph edge set, \\(v\\) is a node in \\(S\\) and \\(d(u)\\) is the degree of \\(u\\)\n"
                },
                "modularity_density": {
                    "Paramters": {},
                    "Return": [
                        "the modularity density score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.modularity_density()"
                    ],
                    "References": [],
                    "Description": "The modularity density is one of several propositions that envisioned to palliate the resolution limit issue of modularity based measures.\nThe idea of this metric is to include the information about algorithms size into the expected density of algorithms to avoid the negligence of small and dense communities.\nFor each algorithms \\(C\\) in partition \\(S\\), it uses the average modularity degree calculated by \\(d(C) = d^{int(C)} \u2212 d^{ext(C)}\\) where \\(d^{int(C)}\\) and \\(d^{ext(C)}\\) are the average internal and external degrees of \\(C\\) respectively to evaluate the fitness of \\(C\\) in its network.\nFinally, the modularity density can be calculated as follows:\n\n\\[Q(S) = \\sum_{C \\in S} \\frac{1}{n_C} ( \\sum_{i \\in C} k^{int}_{iC} - \\sum_{i \\in C} k^{out}_{iC})\\]\nwhere \\(n_C\\) is the number of nodes in C, \\(k^{int}_{iC}\\) is the degree of node i within \\(C\\) and \\(k^{out}_{iC}\\) is the deree of node i outside \\(C\\).\n"
                },
                "modularity_overlap": {
                    "Paramters": {
                        "weight": "label identifying the edge weight parameter name (if present), default None"
                    },
                    "Return": [
                        "FitnessResult object"
                    ],
                    "Example": [],
                    "References": [
                        "\nLazar, D. Abel and T. Vicsek, \u201cModularity measure of networks with overlapping communities\u201d  EPL, 90 (2010) 18001 doi: 10.1209/0295-5075/90/18001\n\n",
                        "Lazar, D. Abel and T. Vicsek, \u201cModularity measure of networks with overlapping communities\u201d  EPL, 90 (2010) 18001 doi: 10.1209/0295-5075/90/18001"
                    ],
                    "Description": "Determines the Overlapping Modularity of a partition C on a graph G.\nOverlapping Modularity is defined as\n\n\\[M_{c_{r}}^{ov} = \\sum_{i \\in c_{r}} \\frac{\\sum_{j \\in c_{r}, i \\neq j}a_{ij} - \\sum_{j \\not \\in c_{r}}a_{ij}}{d_{i} \\cdot s_{i}} \\cdot \\frac{n_{c_{r}}^{e}}{n_{c_{r}} \\cdot \\binom{n_{c_{r}}}{2}}\\]\n"
                },
                "newman_girvan_modularity": {
                    "Paramters": {},
                    "Return": [
                        "the Newman-Girvan modularity score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.newman_girvan_modularity()"
                    ],
                    "References": [],
                    "Description": "Difference the fraction of intra algorithms edges of a partition with the expected number of such edges if distributed according to a null model.\nIn the standard version of modularity, the null model preserves the expected degree sequence of the graph under consideration. In other words, the modularity compares the real network structure with a corresponding one where nodes are connected without any preference about their neighbors.\n\n\\[Q(S) = \\frac{1}{m}\\sum_{c \\in S}(m_S - \\frac{(2 m_S + l_S)^2}{4m})\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms edges, \\(l_S\\) is the number of edges from nodes in S to nodes outside S.\n"
                },
                "nf1": {
                    "Paramters": {
                        "clustering": "NodeClustering object"
                    },
                    "Return": [
                        "MatchingResult instance"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.nf1(leiden_communities)"
                    ],
                    "References": [
                        "Rossetti, G., Pappalardo, L., & Rinzivillo, S. (2016). A novel approach to evaluate algorithms detection internal on ground truth.",
                        "Rossetti, G. (2017). : RDyn: graph benchmark handling algorithms dynamics. Journal of Complex Networks. 5(6), 893-912."
                    ],
                    "Description": "Compute the Normalized F1 score of the optimal algorithms matches among the partitions in input.\nWorks on overlapping/non-overlapping complete/partial coverage partitions.\n"
                },
                "normalized_cut": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.normalized_cut()"
                    ],
                    "References": [],
                    "Description": "Normalized variant of the Cut-Ratio\n\n\\[: f(S) = \\frac{c_S}{2m_S+c_S} + \\frac{c_S}{2(m\u2212m_S )+c_S}\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of algorithms internal edges and \\(c_S\\) is the number of algorithms nodes.\n"
                },
                "normalized_mutual_information": {
                    "Paramters": {
                        "clustering": "NodeClustering object"
                    },
                    "Return": [
                        "normalized mutual information score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.normalized_mutual_information(leiden_communities)"
                    ],
                    "References": [],
                    "Description": "Normalized Mutual Information between two clusterings.\nNormalized Mutual Information (NMI) is an normalization of the Mutual\nInformation (MI) score to scale the results between 0 (no mutual\ninformation) and 1 (perfect correlation). In this function, mutual\ninformation is normalized by sqrt(H(labels_true) * H(labels_pred))\n"
                },
                "omega": {
                    "Paramters": {
                        "clustering": "NodeClustering object"
                    },
                    "Return": [
                        "omega index"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.omega(leiden_communities)"
                    ],
                    "References": [
                        "Gabriel Murray, Giuseppe Carenini, and Raymond Ng. 2012. Using the omega index for evaluating abstractive algorithms detection. In Proceedings of Workshop on Evaluation Metrics and System Comparison for Automatic Summarization. Association for Computational Linguistics, Stroudsburg, PA, USA, 10-18."
                    ],
                    "Description": "Index of resemblance for overlapping, complete coverage, network clusterings.\n"
                },
                "overlapping_normalized_mutual_information_LFK": {
                    "Paramters": {
                        "clustering": "NodeClustering object"
                    },
                    "Return": [
                        "onmi score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.overlapping_normalized_mutual_information_LFK(leiden_communities)"
                    ],
                    "References": [
                        "Lancichinetti, A., Fortunato, S., & Kertesz, J. (2009). Detecting the overlapping and hierarchical community structure in complex networks. New Journal of Physics, 11(3), 033015."
                    ],
                    "Description": "Overlapping Normalized Mutual Information between two clusterings.\nExtension of the Normalized Mutual Information (NMI) score to cope with overlapping partitions.\nThis is the version proposed by Lancichinetti et al.\n"
                },
                "overlapping_normalized_mutual_information_MGH": {
                    "Paramters": {
                        "clustering": "NodeClustering object",
                        "normalization": "one of \u201cmax\u201d or \u201cLFK\u201d. Default \u201cmax\u201d (corresponds to the main method described in the article)"
                    },
                    "Return": [
                        "onmi score\n"
                    ],
                    "Example": [
                        "from cdlib import evaluation, algorithms\ng = nx.karate_club_graph()\nlouvain_communities = algorithms.louvain(g)\nleiden_communities = algorithms.leiden(g)\nevaluation.overlapping_normalized_mutual_information_MGH(louvain_communities,leiden_communities)"
                    ],
                    "References": [
                        "McDaid, A. F., Greene, D., & Hurley, N. (2011). Normalized mutual information to evaluate overlapping community finding algorithms. arXiv preprint arXiv:1110.2515. Chicago"
                    ],
                    "Description": "Overlapping Normalized Mutual Information between two clusterings.\nExtension of the Normalized Mutual Information (NMI) score to cope with overlapping partitions.\nThis is the version proposed by McDaid et al. using a different normalization than the original LFR one. See ref.\nfor more details.\n"
                },
                "scaled_density": {
                    "Paramters": {
                        "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
                    },
                    "Return": [
                        "If summary==True a FitnessResult object, otherwise a list of floats."
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Scaled density.\nThe scaled density of a community is defined as the ratio of the community density w.r.t. the complete graph density.\n"
                },
                "significance": {
                    "Paramters": {},
                    "Return": [
                        "the significance score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.significance()"
                    ],
                    "References": [],
                    "Description": "Significance estimates how likely a partition of dense communities appear in a random graph.\n"
                },
                "size": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Size is the number of nodes in the community\n"
                },
                "surprise": {
                    "Paramters": {},
                    "Return": [
                        "the surprise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.surprise()"
                    ],
                    "References": [],
                    "Description": "Surprise is statistical approach proposes a quality metric assuming that edges between vertices emerge randomly according to a hyper-geometric distribution.\nAccording to the Surprise metric, the higher the score of a partition, the less likely it is resulted from a random realization, the better the quality of the algorithms structure.\n"
                },
                "to_json": {
                    "Paramters": {},
                    "Return": [
                        "a JSON formatted string representing the object"
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Generate a JSON representation of the algorithms object\n"
                },
                "to_node_community_map": {
                    "Paramters": {},
                    "Return": [
                        "dict of the form <node, list(communities)>"
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Generate a <node, list(communities)> representation of the current clustering\n"
                },
                "triangle_participation_ratio": {
                    "Paramters": {
                        "summary": "(optional, default True) ifTrue, an overall summary is returned for the partition (min, max, avg, std); ifFalsea list of community-wise score"
                    },
                    "Return": [
                        "a FitnessResult object/a list of community-wise score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.triangle_participation_ratio()"
                    ],
                    "References": [],
                    "Description": "Fraction of algorithms nodes that belong to a triad.\n\n\\[f(S) = \\frac{ | \\{ u: u \\in S,\\{(v,w):v, w \\in S,(u,v) \\in E,(u,w) \\in E,(v,w) \\in E \\} \\not = \\emptyset \\} |}{n_S}\\]\nwhere \\(n_S\\) is the set of algorithms nodes.\n"
                },
                "variation_of_information": {
                    "Paramters": {
                        "clustering": "NodeClustering object"
                    },
                    "Return": [
                        "VI score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nleiden_communities = algorithms.leiden(g)\nmod = communities.variation_of_information(leiden_communities)"
                    ],
                    "References": [
                        "Meila, M. (2007). Comparing clusterings - an information based distance. Journal of Multivariate Analysis, 98, 873-895. doi:10.1016/j.jmva.2006.11.013"
                    ],
                    "Description": "Variation of Information among two nodes partitions.\n$$ H(p)+H(q)-2MI(p, q) $$\nwhere MI is the mutual information, H the partition entropy and p,q are the algorithms sets\n"
                },
                "z_modularity": {
                    "Paramters": {},
                    "Return": [
                        "the z-modularity score"
                    ],
                    "Example": [
                        "from cdlib.algorithms import louvain\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = communities.z_modularity()"
                    ],
                    "References": [],
                    "Description": "Z-modularity is another variant of the standard modularity proposed to avoid the resolution limit.\nThe concept of this version is based on an observation that the difference between the fraction of edges inside communities and the expected number of such edges in a null model should not be considered as the only contribution to the final quality of algorithms structure.\n"
                }
            }
        }
    },
    {
        "Section_id": "convert_graph_formats",
        "Description": "Converts from/to networkx/igraph\n",
        "Parameters": {
            "graph": "original graph object",
            "desired_format": "desired final type. Either nx.Graph or ig.Graph",
            "directed": "boolean, defaultFalse"
        },
        "Return": [
            "the converted graph\n"
        ],
        "Example": [],
        "References": []
    },
    {
        "Section_id": "overlapping_seed_set_expansion",
        "Description": "OSSE is an overlapping community detection algorithm optimizing the conductance community score\nThe algorithm uses a seed set expansion approach; the key idea is to find good seeds, and then expand these seed sets using the personalized PageRank clustering procedure.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "seeds": "Node list",
            "ninf": "Neighbourhood Inflation parameter (boolean)",
            "expansion": "Seed expansion: ppr or vppr",
            "stopping": "Stopping criteria: cond",
            "nworkers": "Number of Workers: default 1",
            "nruns": "Number of runs: default 13",
            "alpha": "alpha value for Personalized PageRank expansion: default 0.99",
            "maxexpand": "Maximum expansion allowed for approximate ppr: default INF",
            "delta": "Minimum distance parameter for near duplicate communities: default 0.2"
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncom = algorithms.overlapping_seed_set_expansion(G)"
        ],
        "References": []
    },
    {
        "Section_id": "cpm",
        "Description": "CPM is a model where the quality function to optimize is:\n\n\\[Q = \\sum_{ij} \\left(A_{ij} - \\gamma \\right)\\delta(\\sigma_i, \\sigma_j)\\]\nwhere \\(A\\) is the adjacency matrix, \\(\\sigma_i\\) denotes the community of node \\(i\\), \\(\\delta(\\sigma_i, \\sigma_j) = 1\\) if  \\(\\sigma_i = \\sigma_j\\) and 0 otherwise, and, finally \\(\\gamma\\) is a resolution parameter.\nThe internal density of communities\n\n\\[p_c = \\frac{m_c}{\\binom{n_c}{2}} \\geq \\gamma\\]\nis higher than \\(\\gamma\\), while the external density\n\\(p_{cd} = \\frac{m_{cd}}{n_c n_d} \\leq \\gamma\\)    is lower than \\(\\gamma\\). In other words, choosing a particular\n\\(\\gamma\\) corresponds to choosing to find communities of a particular\ndensity, and as such defines communities. Finally, the definition of a community is in a sense independent of the actual graph, which is not the case for any of the other methods.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "initial_membership": "list of int Initial membership for the partition. IfNonethen defaults to a singleton partition. Deafault None",
            "weights": "list of double, or edge attribute Weights of edges. Can be either an iterable or an edge attribute. Deafault None",
            "node_sizes": "list of int, or vertex attribute Sizes of nodes are necessary to know the size of communities in aggregate graphs. Usually this is set to 1 for all nodes, but in specific cases  this could be changed. Deafault None",
            "resolution_parameter": "double >0 A parameter value controlling the coarseness of the clustering. Higher resolutions lead to more communities, while lower resolutions lead to fewer communities. Deafault 1"
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.cpm(G)"
        ],
        "References": []
    },
    {
        "Section_id": "infomap",
        "Description": "Infomap is based on ideas of information theory.\nThe algorithm uses the probability flow of random walks on a network as a proxy for information flows in the real system and it decomposes the network into modules by compressing a description of the probability flow.\nNB: in case the Infomap package is not installed/installable (e.g., on M1 silicon Macs), the implementation used is the one from the igraph library.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "flags": "str flags for Infomap"
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.infomap(G)"
        ],
        "References": []
    },
    {
        "Section_id": "plot_com_stat",
        "Description": "Plot the distribution of a property among all communities for a clustering, or a list of clusterings (violin-plots)\n",
        "Parameters": {
            "com_clusters": "list of clusterings to compare, or a single clustering",
            "com_fitness": "the fitness/community property to use"
        },
        "Return": [
            "the violin-plots\n"
        ],
        "Example": [
            "from cdlib import algorithms, viz, evaluation\nimport networkx as nx\ng = nx.karate_club_graph()\ncoms = algorithms.louvain(g)\ncoms2 = algorithms.walktrap(g)\nviolinplot = viz.plot_com_stat([coms,coms2],evaluation.size)"
        ],
        "References": []
    },
    {
        "Section_id": "z_modularity",
        "Description": "Z-modularity is another variant of the standard modularity proposed to avoid the resolution limit.\nThe concept of this version is based on an observation that the difference between the fraction of edges inside communities and the expected number of such edges in a null model should not be considered as the only contribution to the final quality of community structure.\n",
        "Parameters": {
            "graph": "a networkx/igraph object",
            "communities": "NodeClustering object"
        },
        "Return": [
            "FitnessResult object\n"
        ],
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = evaluation.z_modularity(g,communities)"
        ],
        "References": [
            "Miyauchi, Atsushi, and Yasushi Kawase. Z-score-based modularity for community detection in networks. PloS one 11.1 (2016): e0147805."
        ]
    },
    {
        "Section_id": "surprise",
        "Description": "Surprise is statistical approach proposes a quality metric assuming that edges between vertices emerge randomly according to a hyper-geometric distribution.\nAccording to the Surprise metric, the higher the score of a partition, the less likely it is resulted from a random realization, the better the quality of the community structure.\n",
        "Parameters": {
            "graph": "a networkx/igraph object",
            "communities": "NodeClustering object"
        },
        "Return": [
            "FitnessResult object\n"
        ],
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = evaluation.surprise(g,communities)"
        ],
        "References": [
            "Traag, V. A., Aldecoa, R., & Delvenne, J. C. (2015). Detecting communities using asymptotical surprise. Physical Review E, 92(2), 022816."
        ]
    },
    {
        "Section_id": "edges_inside",
        "Description": "Number of edges internal to the community.\n",
        "Parameters": {
            "graph": "a networkx/igraph object",
            "community": "NodeClustering object",
            "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
        },
        "Return": [
            "If summary==True a FitnessResult object, otherwise a list of floats.\n"
        ],
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = evaluation.edges_inside(g,communities)"
        ],
        "References": [
            "Radicchi, F., Castellano, C., Cecconi, F., Loreto, V., & Parisi, D. (2004). Defining and identifying communities in networks. Proceedings of the National Academy of Sciences, 101(9), 2658-2663."
        ]
    },
    {
        "Section_id": "normalized_cut",
        "Description": "Normalized variant of the Cut-Ratio\n\n\\[f(S) = \\frac{c_S}{2m_S+c_S} + \\frac{c_S}{2(m\u2212m_S )+c_S}\\]\nwhere \\(m\\) is the number of graph edges, \\(m_S\\) is the number of community internal edges and \\(c_S\\) is the number of community nodes.\n",
        "Parameters": {
            "graph": "a networkx/igraph object",
            "community": "NodeClustering object",
            "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
        },
        "Return": [
            "If summary==True a FitnessResult object, otherwise a list of floats.\n"
        ],
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = evaluation.normalized_cut(g,communities)"
        ],
        "References": []
    },
    {
        "Section_id": "CPM_Bipartite",
        "Description": "CPM_Bipartite is the extension of CPM to bipartite graphs\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "resolution_parameter_01": "Resolution parameter for in between two classes.",
            "resolution_parameter_0": "Resolution parameter for class 0.",
            "resolution_parameter_1": "Resolution parameter for class 1.",
            "degree_as_node_size": "IfTrueuse degree as node size instead of 1, to mimic modularity",
            "seed": "the random seed to be used in CPM method to keep results/partitions replicable"
        },
        "Return": [
            "BiNodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.algorithms.bipartite.generators.random_graph(100, 20, 0.5)\ncoms = algorithms.CPM_Bipartite(G, 0.5)"
        ],
        "References": []
    },
    {
        "Section_id": "r_spectral_clustering",
        "Description": "Spectral clustering partitions the nodes of a graph into groups based upon the eigenvectors of the graph Laplacian.\nDespite the claims of spectral clustering being \u201cpopular\u201d, in applied research using graph data, spectral clustering (without regularization) often returns a partition of the nodes that is uninteresting, typically finding a large cluster that contains most of the data and many smaller clusters, each with only a few nodes.\nThis method allows to compute spectral clustering with/withouth different regualarization functions designed to address such a limitation.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "n_clusters": "How many clusters to look at",
            "method": "one among \u201cvanilla\u201d, \u201cregularized\u201d, \u201cregularized_with_kmeans\u201d, \u201csklearn_spectral_embedding\u201d, \u201csklearn_kmeans\u201d, \u201cpercentile\u201d.",
            "percentile": "percentile of the degree distribution to perform regularization. Value in [0, 100]. Mandatory if method=\u201dpercentile\u201d or \u201cregularized\u201d, otherwise None"
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.r_spectral_clustering(G, n_clusters=2, method=\"regularized\", percentile=20)"
        ],
        "References": []
    },
    {
        "Section_id": "principled_clustering",
        "Description": "An efficient and principled method for detecting communities in networks\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "networkx/igraph object",
            "cluster_count": "number of desired communities"
        },
        "Return": [
            "FuzzyNodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.principled_clustering(G, 3)"
        ],
        "References": []
    },
    {
        "Section_id": "read_community_csv",
        "Description": "Read community list from comma separated value (csv) file.\n",
        "Parameters": {
            "path": "input filename",
            "delimiter": "column delimiter",
            "nodetype": "specify the type of node labels, default str",
            "compress": "wheter the file is compressed or not, default False"
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "import networkx as nx\nfrom cdlib import algorithms, readwrite\ng = nx.karate_club_graph()\ncoms = algorithms.louvain(g)\nreadwrite.write_community_csv(coms, \"communities.csv\", \",\")\ncoms = readwrite.read_community_csv(coms, \"communities.csv\", \",\", str)"
        ],
        "References": []
    },
    {
        "Section_id": "cut_ratio",
        "Description": "Fraction of existing edges (out of all possible edges) leaving the community.\n\n\\[f(S) = \\frac{c_S}{n_S (n \u2212 n_S)}\\]\nwhere \\(c_S\\) is the cut size (number of edges on the community boundary) and \\(n_S\\) is the number of community nodes\n",
        "Parameters": {
            "graph": "a networkx/igraph object",
            "community": "NodeClustering object",
            "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
        },
        "Return": [
            "If summary==True a FitnessResult object, otherwise a list of floats.\n"
        ],
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = evaluation.cut_ratio(g,communities)"
        ],
        "References": [
            "Fortunato, S.: Community detection in graphs. Physics reports 486(3-5), 75\u2013174 (2010)"
        ]
    },
    {
        "Section_id": "label_propagation",
        "Description": "The Label Propagation algorithm (LPA) detects communities using network structure alone.\nThe algorithm doesn\u2019t require a pre-defined objective function or prior information about the communities.\nIt works as follows:\n-Every node is initialized with a unique label (an identifier)\n-These labels propagate through the network\n-At every iteration of propagation, each node updates its label to the one that the maximum numbers of its neighbours belongs to. Ties are broken uniformly and randomly.\n-LPA reaches convergence when each node has the majority label of its neighbours.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object"
        },
        "Return": [
            "EdgeClustering object"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.label_propagation(G)"
        ],
        "References": []
    },
    {
        "Section_id": "write_community_json",
        "Description": "Generate a JSON representation of the clustering object\n",
        "Parameters": {
            "communities": "a cdlib clustering object",
            "path": "output filename",
            "compress": "wheter to copress the JSON, default False"
        },
        "Return": [
            "a JSON formatted string representing the object\n"
        ],
        "Example": [
            "import networkx as nx\nfrom cdlib import algorithms, readwrite\ng = nx.karate_club_graph()\ncoms = algorithms.louvain(g)\nreadwrite.write_community_json(coms, \"communities.json\")"
        ],
        "References": []
    },
    {
        "Section_id": "walkscan",
        "Description": "Random walk community detection method leveraging PageRank node scoring.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "nb_steps": "the length of the random walk",
            "eps": "DBSCAN eps",
            "min_samples": "DBSCAN min_samples",
            "init_vector": "dictionary node_id -> initial_probability to initialize the random walk. Default, random selected node with probability set to 1."
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.walkscan(G)"
        ],
        "References": []
    },
    {
        "Section_id": "lswl_plus",
        "Description": "LSWL+ is capable of finding a partition with overlapping communities or without them, based on user preferences.\nThis method can also find outliers (peripheral nodes of the graph that are marginally connected to communities) and hubs (nodes that bridge the communities)\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "strength_type": "1 strengths between [-1,+1] or, 2 strengths between [0,1]. Default, 2.",
            "merge_outliers": "If outliers need to merge into communities. Default, True.",
            "detect_overlap": "If overlapping communities need to be detected. Default, False"
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.lswl_plus(G)"
        ],
        "References": []
    },
    {
        "Section_id": "hierarchical_link_community",
        "Description": "HLC (hierarchical link clustering) is a method to classify links into topologically related groups.\nThe algorithm uses a similarity between links to build a dendrogram where each leaf is a link from the original network and branches represent link communities.\nAt each level of the link dendrogram is calculated the partition density function, based on link density inside communities, to pick the best level to cut.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object"
        },
        "Return": [
            "EdgeClustering object"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncom = algorithms.hierarchical_link_community(G)"
        ],
        "References": []
    },
    {
        "Section_id": "FitnessResult",
        "Description": "Initialize self.  See help(type(self)) for accurate signature.",
        "Field List": {
            "Parameters": {},
            "Methods": {}
        }
    },
    {
        "Section_id": "lswl",
        "Description": "LSWL locally discovers networks\u2019 the communities precisely, deterministically, and quickly.\nThis method works in a one-node-expansion model based on a notion of strong and weak links in a graph.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "timeout": "The maximum time in which LSWL should retrieve the community. Default is 1 second.",
            "strength_type": "1 strengths between [-1,+1] or, 2 strengths between [0,1]. Default, 2.",
            "query_node": "Id of the network node whose local community is queried.",
            "online": "wehter the computation should happen in memory or not. Default, True."
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.lswl(G, 1)"
        ],
        "References": []
    },
    {
        "Section_id": "link_modularity",
        "Description": "Quality function designed for directed graphs with overlapping communities.\n",
        "Parameters": {
            "graph": "a networkx/igraph object",
            "communities": "NodeClustering object"
        },
        "Return": [
            "FitnessResult object\n"
        ],
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = evaluation.link_modularity(g,communities)"
        ],
        "References": [
            "Nicosia, V., Mangioni, G., Carchiolo, V., Malgeri, M.: Extending the definition of modularity to directed graphs with overlapping communities. Journal of Statistical Mechanics: Theory and Experiment 2009(03), 03024 (2009)"
        ]
    },
    {
        "Section_id": "bimlpa",
        "Description": "BiMLPA is designed to detect the many-to-many correspondence community in bipartite networks using multi-label propagation algorithm.\nThis method works for the connected graph. If the graph is not connected, the method will be applied to each connected component of the graph and the results will be merged.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object (instance of igraph.Graph or nx.Graph).",
            "theta": "Label weights threshold. Default 0.3.",
            "lambd": "The max number of labels. Default 7."
        },
        "Return": [
            "BiNodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.algorithms.bipartite.random_graph(50, 50, 0.25)\ncoms = algorithms.bimlpa(G)"
        ],
        "References": []
    },
    {
        "Section_id": "ipca",
        "Description": "IPCA was introduced by Li et al. (2008) as a modi\ufb01ed version of DPClus.\nIn contrast to DPClus, this method focuses on the maintaining the diameter of a cluster, de\ufb01ned as the maximum shortest distance between all pairs of vertices, rather than its density.\nIn doing so, the seed growth aspect of IPCA emphasizes structural closeness of a predicted protein complex, as well as structural connectivity.\nLike DPClus, IPCA computes local vertex and edge weights by counting the number of common neighbors shared between two vertices.\nHowever, IPCA calculates these values only once at the beginning of the algorithm, rather than updating them every time a discovered cluster is removed from the graph.\nThis allows overlap to occur naturally between clusters, as cluster nodes are not permanently removed from the graph; however, it can also lead to a large amount of cluster overlap.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "weights": "label used for the edge weights. Default, None.",
            "t_in": ""
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.ipca(G)"
        ],
        "References": []
    },
    {
        "Section_id": "TemporalClustering",
        "Description": "Add to the Temporal Clustering the communities observed at a given time",
        "Field List": {
            "Parameters": {
                "clustering": "a Clustering object",
                "time": "time of observation"
            },
            "Methods": {
                "add_clustering": {
                    "Paramters": {
                        "clustering": "a Clustering object",
                        "time": "time of observation"
                    },
                    "Return": [],
                    "Example": [],
                    "References": [],
                    "Description": "Add to the Temporal Clustering the communities observed at a given time\n"
                },
                "add_matching": {
                    "Paramters": {
                        "matching": "a list of tuples [(Ti_Ca, Tj_Cb, score), \u2026 ].\nCommunity names needs to satisfy the pattern {tid}_{cid}, where tid is the time of observation and\ncid is the position of the community within the Clustering object."
                    },
                    "Return": [],
                    "Example": [],
                    "References": [],
                    "Description": "Add a precomputed matching of the communities.\n"
                },
                "clustering_stability_trend": {
                    "Paramters": {
                        "method": "a comparison score taking as input two Clustering objects (e.g., NMI, NF1, ARI\u2026)"
                    },
                    "Return": [
                        "a list of floats"
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Returns the trend for community stability.\nThe stability index is computed for temporally adjacent clustering pairs.\n"
                },
                "community_matching": {
                    "Paramters": {
                        "method": "a set similarity function with co-domain in [0,1] (e.g., Jaccard)",
                        "two_sided": "boolean.\nWhether the match has to be applied only from the past to the future (False, default)\nor even from the future to the past (True)"
                    },
                    "Return": [
                        "a list of tuples [(Ti_Ca, Tj_Cb, score), \u2026 ].\nCommunity names are assigned following the pattern {tid}_{cid}, where tid is the time of observation and\ncid is the position of the community within the Clustering object.\n"
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Reconstruct community matches across adjacent observations using a provided similarity function.\n"
                },
                "get_clustering_at": {
                    "Paramters": {
                        "time": "the time of observation"
                    },
                    "Return": [
                        "a Clustering object"
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Returns the clustering observed at a given time\n"
                },
                "get_community": {
                    "Paramters": {
                        "cid": "community id of the form {tid}_{cid}, where tid is the time of observation and\ncid is the position of the community within the Clustering object."
                    },
                    "Return": [
                        "list of nodes within cid"
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Returns the nodes within a given temporal community\n"
                },
                "get_explicit_community_match": {
                    "Paramters": {},
                    "Return": [
                        "a list of tuple [(Ti_Ca, Tj_Cb, score), \u2026 ].\nCommunity names are assigned following the pattern {tid}_{cid}, where tid is the time of observation and\ncid is the position of the community within the Clustering object."
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Return an explicit matching of computed communities (if it exists)\n"
                },
                "has_explicit_match": {
                    "Paramters": {},
                    "Return": [
                        "a list of tuple [(Ti_Ca, Tj_Cb, score), \u2026 ].\nCommunity names are assigned following the pattern {tid}_{cid}, where tid is the time of observation and\ncid is the position of the community within the Clustering object."
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Checks if the algorithm provided an explicit match of temporal communities\n"
                },
                "lifecycle_polytree": {
                    "Paramters": {
                        "method": "a set similarity function with co-domain in [0,1] (e.g., Jaccard)",
                        "two_sided": "boolean.\nWhether the match has to be applied only from the past to the future (False, default)\nor even from the future to the past (True)"
                    },
                    "Return": [
                        "a networkx DiGraph object.\nNodes represent communities, their ids are assigned following the pattern {tid}_{cid},\nwhere tid is the time of observation and\ncid is the position of the community within the Clustering object.\n"
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Reconstruct the poly-tree representing communities lifecycles using a provided similarity function.\n"
                },
                "to_json": {
                    "Paramters": {},
                    "Return": [
                        "a JSON formatted string representing the object"
                    ],
                    "Example": [],
                    "References": [],
                    "Description": "Generate a JSON representation of the TemporalClustering object\n"
                }
            }
        }
    },
    {
        "Section_id": "f1",
        "Description": "Compute the average F1 score of the optimal algorithms matches among the partitions in input.\nWorks on overlapping/non-overlapping complete/partial coverage partitions.\n",
        "Parameters": {
            "first_partition": "NodeClustering object",
            "second_partition": "NodeClustering object"
        },
        "Return": [
            "MatchingResult object\n"
        ],
        "Example": [
            "from cdlib import evaluation, algorithms\ng = nx.karate_club_graph()\nlouvain_communities = algorithms.louvain(g)\nleiden_communities = algorithms.leiden(g)\nevaluation.f1(louvain_communities,leiden_communities)"
        ],
        "References": [
            "Rossetti, G., Pappalardo, L., & Rinzivillo, S. (2016). A novel approach to evaluate algorithms detection internal on ground truth. In Complex Networks VII (pp. 133-144). Springer, Cham."
        ]
    },
    {
        "Section_id": "siblinarity_antichain",
        "Description": "The algorithm extract communities from a DAG that (i) respects its intrinsic order and (ii) are composed of similar nodes.\nThe approach takes inspiration from classic similarity measures of bibliometrics, used to assess how similar two publications are, based on their relative citation patterns.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object representing a DAG (directed acyclic graph)",
            "forwards_backwards_on": "checks successors\u2019 similarity. Boolean, default True",
            "backwards_forwards_on": "checks predecessors\u2019 similarity. Boolean, default True",
            "Lambda": "desired resolution of the partition. Default 1",
            "with_replacement": "If True he similarity of a node to itself is equal to the number of its neighbours based on which the similarity is defined. Boolean, default True."
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.siblinarity_antichain(G, Lambda=1)"
        ],
        "References": []
    },
    {
        "Section_id": "leiden",
        "Description": "The Leiden algorithm is an improvement of the Louvain algorithm.\nThe Leiden algorithm consists of three phases:\n(1) local moving of nodes,\n(2) refinement of the partition\n(3) aggregation of the network based on the refined partition, using the non-refined partition to create an initial partition for the aggregate network.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "initial_membership": "list of int Initial membership for the partition. IfNonethen defaults to a singleton partition. Deafault None",
            "weights": "list of double, or edge attribute Weights of edges. Can be either an iterable or an edge attribute. Deafault None"
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.leiden(G)"
        ],
        "References": []
    },
    {
        "Section_id": "mod_r",
        "Description": "Community Discovery algorithm that infers the hierarchy of communities that enclose a given vertex by exploring the graph one vertex at a time.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "query_node": "Id of the network node whose local community is queried."
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.mod_r(G, 1)"
        ],
        "References": []
    },
    {
        "Section_id": "normalized_mutual_information",
        "Description": "Normalized Mutual Information between two clusterings.\nNormalized Mutual Information (NMI) is an normalization of the Mutual\nInformation (MI) score to scale the results between 0 (no mutual\ninformation) and 1 (perfect correlation). In this function, mutual\ninformation is normalized by sqrt(H(labels_true) * H(labels_pred))\n",
        "Parameters": {
            "first_partition": "NodeClustering object",
            "second_partition": "NodeClustering object"
        },
        "Return": [
            "MatchingResult object\n"
        ],
        "Example": [
            "from cdlib import evaluation, algorithms\ng = nx.karate_club_graph()\nlouvain_communities = algorithms.louvain(g)\nleiden_communities = algorithms.leiden(g)\nevaluation.normalized_mutual_information(louvain_communities,leiden_communities)"
        ],
        "References": []
    },
    {
        "Section_id": "condor",
        "Description": "BRIM algorithm for bipartite community structure detection.\nWorks on weighted and unweighted graphs.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object"
        },
        "Return": [
            "BiNodeClustering object"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.algorithms.bipartite.random_graph(50, 50, 0.25)\ncoms = algorithms.condor(G)"
        ],
        "References": []
    },
    {
        "Section_id": "louvain",
        "Description": "Louvain  maximizes a modularity score for each community.\nThe algorithm optimises the modularity in two elementary phases:\n(1) local moving of nodes;\n(2) aggregation of the network.\nIn the local moving phase, individual nodes are moved to the community that yields the largest increase in the quality function.\nIn the aggregation phase, an aggregate network is created based on the partition obtained in the local moving phase.\nEach community in this partition becomes a node in the aggregate network. The two phases are repeated until the quality function cannot be increased further.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "weight": "str, optional the key in graph to use as weight. Default to \u2018weight\u2019",
            "resolution": "double, optional  Will change the size of the communities, default to 1.",
            "randomize": "int, RandomState instance or None, optional (default=None). If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used bynp.random."
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.louvain(G, weight='weight', resolution=1.)"
        ],
        "References": []
    },
    {
        "Section_id": "greedy_modularity",
        "Description": "The CNM algorithm uses the modularity to find the communities strcutures.\nAt every step of the algorithm two communities that contribute maximum positive value to global modularity are merged.\nSupported Graph Types\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "weight": "list of double, or edge attribute Weights of edges. Can be either an iterable or an edge attribute. Deafault None"
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncoms = algorithms.greedy_modularity(G)"
        ],
        "References": []
    },
    {
        "Section_id": "conga",
        "Description": "CONGA (Cluster-Overlap Newman Girvan Algorithm) is an algorithm for discovering overlapping communities.\nIt extends the  Girvan and Newman\u2019s algorithm with a specific method of deciding when and how to split vertices. The algorithm is as follows:\n",
        "Parameters": {
            "g_original": "a networkx/igraph object",
            "number_communities": "the number of communities desired"
        },
        "Return": [
            "NodeClustering object\n"
        ],
        "Example": [
            "from cdlib import algorithms\nimport networkx as nx\nG = nx.karate_club_graph()\ncom = algorithms.conga(G, number_communities=3)"
        ],
        "References": [
            "Calculate edge betweenness of all edges in network.",
            "Calculate vertex betweenness of vertices, from edge betweennesses.",
            "Find candidate set of vertices: those whose vertex betweenness is greater than the maximum edge betweenness.",
            "If candidate set is non-empty, calculate pair betweennesses of candidate vertices, and then calculate split betweenness of candidate vertices.",
            "Remove edge with maximum edge betweenness or split vertex with maximum split betweenness (if greater).",
            "Recalculate edge betweenness for all remaining edges in same component(s) as removed edge or split vertex.",
            "Repeat from step 2 until no edges remain."
        ]
    },
    {
        "Section_id": "fraction_over_median_degree",
        "Description": "Fraction of community nodes of having internal degree higher than the median degree value.\n\n\\[f(S) = \\frac{|\\{u: u \\in S,| \\{(u,v): v \\in S\\}| > d_m\\}| }{n_S}\\]\nwhere \\(d_m\\) is the internal degree median value\n",
        "Parameters": {
            "graph": "a networkx/igraph object",
            "community": "NodeClustering object",
            "summary": "boolean. IfTrueit is returned an aggregated score for the partition is returned, otherwise individual-community ones. DefaultTrue."
        },
        "Return": [
            "If summary==True a FitnessResult object, otherwise a list of floats.\n"
        ],
        "Example": [
            "from cdlib.algorithms import louvain\nfrom cdlib import evaluation\ng = nx.karate_club_graph()\ncommunities = louvain(g)\nmod = evaluation.fraction_over_median_degree(g,communities)"
        ],
        "References": [
            "Yang, J., Leskovec, J.: Defining and evaluating network communities based on ground-truth. Knowledge and Information Systems 42(1), 181\u2013213 (2015)"
        ]
    },
    {
        "Section_id": "write_community_csv",
        "Description": "Save community structure to comma separated value (csv) file.\n",
        "Parameters": {
            "communities": "a NodeClustering object",
            "path": "output filename",
            "delimiter": "column delimiter",
            "compress": "wheter to copress the csv, default False"
        },
        "Return": [],
        "Example": [
            "import networkx as nx\nfrom cdlib import algorithms, readwrite\ng = nx.karate_club_graph()\ncoms = algorithms.louvain(g)\nreadwrite.write_community_csv(coms, \"communities.csv\", \",\")"
        ],
        "References": []
    },
    {
        "Section_id": "SignFlips",
        "Description": "Flips the signs of all entries in one dataset, X along some of the dimensions. In particular, it does so in a way that brings this dataset to the same orthant as the second dataset, Y, according to some criterion, computed along each dimension. The two critera currently available are the median and the maximum (in magnitude) value along each dimension.\nThis module can also be used to bring the dataset to the first orthant (i.e. with all criteras being positive) by providing the identity matrix as the second dataset.",
        "Field List": {
            "Parameters": {
                "criterion": "string, {'median' (default), 'max'}, optional\nString describing the criterion used to choose whether to flip signs. Two options are currently supported:\n\n'median' Uses the median along each dimension\n'max' Uses the maximum (in magintude) along each dimension"
            },
            "Attributes": {
                "Q_array_": "size (d, d)\nFinal orthogonal matrix, used to modify X."
            },
            "Methods": {
                "__init__": {
                    "Parameters": {
                        "criterion": "str"
                    }
                },
                "set_criterion_function": {
                    "Returns": {
                        "None": ""
                    }
                },
                "fit": {
                    "Description": "Uses the two datasets to learn the matrix Q_ that aligns the first dataset with the second.\nIn sign flips, Q_ is an diagonal orthogonal matrices (i.e. a matrix with 1 or -1 in each entry on diagonal and 0 everywhere else) picked such that all dimensions of X @ Q_ and Y are in the same orthant using some critera (median or max magnitude).",
                    "Parameters": {
                        "X": "np.ndarray, shape (n, d)\nDataset to be mapped to Y, must have same number of dimensions (axis 1) as Y.",
                        "Y": "np.ndarray, shape (m, d)\nTarget dataset, must have same number of dimensions (axis 1) as X."
                    },
                    "Returns": {
                        "self": "returns an instance of self"
                    }
                },
                "fit_transform": {
                    "Description": "Uses the two datasets to learn the matrix Q_ that aligns the first dataset with the second. Then, transforms the first dataset X using the learned matrix Q_.",
                    "Parameters": {
                        "X": "np.ndarray, shape (n, d)\nDataset to be mapped to Y, must have same number of dimensions (axis 1) as Y.",
                        "Y": "np.ndarray, shape (m, d)\nTarget dataset, must have same number of dimensions (axis 1) as X."
                    },
                    "Returns": {
                        "X_prime": "np.ndarray, shape (n, d)\nFirst dataset of vectors, aligned to second. Equal to X @ Q_."
                    }
                },
                "get_metadata_routing": {
                    "Description": "Get metadata routing of this object.\nPlease check User Guide on how the routing mechanism works.",
                    "Returns": {
                        "routing": "MetadataRequest\nA MetadataRequest encapsulating routing information."
                    }
                },
                "get_params": {
                    "Description": "Get parameters for this estimator.",
                    "Parameters": {
                        "deep": "bool, default=True\nIf True, will return the parameters for this estimator and contained subobjects that are estimators."
                    },
                    "Returns": {
                        "params": "dict\nParameter names mapped to their values."
                    }
                },
                "set_params": {
                    "Description": "Set the parameters of this estimator.\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.",
                    "Parameters": {
                        "**params": "dict\nEstimator parameters."
                    },
                    "Returns": {
                        "self": "estimator instance\nEstimator instance."
                    }
                },
                "transform": {
                    "Description": "Transforms the dataset X using the learned matrix Q_. This may be the same as the first dataset as in fit(), or a new dataset. For example, additional samples from the same dataset.",
                    "Parameters": {
                        "X": "np.ndarray, shape(m, d)\nDataset to be transformed, must have same number of dimensions (axis 1) as X and Y that were passed to fit."
                    },
                    "Returns": {
                        "X_prime": "np.ndarray, shape (n, d)\nFirst dataset of vectors, aligned to second. Equal to X @ Q_."
                    }
                }
            }
        }
    },
    {
        "Section_id": "OrthogonalProcrustes",
        "Description": "Computes the matrix solution of the seedless Procrustes problem, which is that given two matrices X and Y of equal shape (n, d), find an orthogonal matrix that most closely maps X to Y. Subsequently, uses that matrix to transform either the original X, or a different dataset in the same space.\nNote that when used to match two datasets, this method only requires that the datasets have the same number of entries, but not that there is some correspondence between the entries. In graph embeddings, this usually corresponds to the assumption that the vertex i in graph X has the same latent position as the vertex i in graph Y.",
        "Field List": {
            "Attributes": {
                "Q_array_": "size (d, d)\nFinal orthogonal matrix, used to modify X.",
                "score_": "float\nFinal value of the objective function: Lower means the datasets have been matched together better."
            },
            "Methods": {
                "__init__": {
                    "Returns": {
                        "None": ""
                    }
                },
                "fit": {
                    "Description": "Uses the two datasets to learn the matrix Q_ that aligns the first dataset with the second.",
                    "Parameters": {
                        "X": "np.ndarray, shape (n, d)\nDataset to be mapped to Y, must have the same shape as Y.",
                        "Y": "np.ndarray, shape (m, d)\nTarget dataset, must have the same shape as X."
                    },
                    "Returns": {
                        "self": "returns an instance of self"
                    }
                },
                "fit_transform": {
                    "Description": "Uses the two datasets to learn the matrix Q_ that aligns the first dataset with the second. Then, transforms the first dataset X using the learned matrix Q_.",
                    "Parameters": {
                        "X": "np.ndarray, shape (n, d)\nDataset to be mapped to Y, must have the same shape as Y.",
                        "Y": "np.ndarray, shape (m, d)\nTarget dataset, must have the same shape as X."
                    },
                    "Returns": {
                        "X_prime": "np.ndarray, shape (n, d)\nFirst dataset of vectors, aligned to second. Equal to X @ Q_."
                    }
                },
                "get_metadata_routing": {
                    "Description": "Get metadata routing of this object.\nPlease check User Guide on how the routing mechanism works.",
                    "Returns": {
                        "routing": "MetadataRequest\nA MetadataRequest encapsulating routing information."
                    }
                },
                "get_params": {
                    "Description": "Get parameters for this estimator.",
                    "Parameters": {
                        "deep": "bool, default=True\nIf True, will return the parameters for this estimator and contained subobjects that are estimators."
                    },
                    "Returns": {
                        "params": "dict\nParameter names mapped to their values."
                    }
                },
                "set_params": {
                    "Description": "Set the parameters of this estimator.\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.",
                    "Parameters": {
                        "**params": "dict\nEstimator parameters."
                    },
                    "Returns": {
                        "self": "estimator instance\nEstimator instance."
                    }
                },
                "transform": {
                    "Description": "Transforms the dataset X using the learned matrix Q_. This may be the same as the first dataset as in fit(), or a new dataset. For example, additional samples from the same dataset.",
                    "Parameters": {
                        "X": "np.ndarray, shape(m, d)\nDataset to be transformed, must have same number of dimensions (axis 1) as X and Y that were passed to fit."
                    },
                    "Returns": {
                        "X_prime": "np.ndarray, shape (n, d)\nFirst dataset of vectors, aligned to second. Equal to X @ Q_."
                    }
                }
            }
        },
        "Rubric": {
            "Note": "Formally, minimizes ||X @ Q_ - Y||_F^2, which has a closed form solution, whenever Q_ is constrained to be an orthogonal matrix, that is a matrix that satisfies Q_ @ Q_.T = I. For the more details, including the proof of the closed-form solution see [1].\nImplementation-wise, this class is a wrapper of the scipy.linalg.orthogonal_procrustes(), which itself uses an algorithm described in find the optimal solution algorithm [2].",
            "References": [
                "(1,2) https://en.wikipedia.org/wiki/Orthogonal_Procrustes_problem",
                "(2) Peter H. Schonemann, \"A generalized solution of the orthogonal Procrustes problem\", Psychometrica -- Vol. 31, No. 1, March, 1996."
            ]
        }
    },
    {
        "Section_id": "SeedlessProcrustes",
        "Description": "Matches two datasets using an orthogonal matrix. Unlike OrthogonalProcrustes, this does not require a matching between entries. It can even be used in the settings where the two datasets do not have the same number of entries.\nIn graph setting, it is used to align the embeddings of two different graphs, when it requires some simultaneous inference task and no 1-1 matching between the vertices of the two graphs can be established, for example, inside of the test for the equivalence of the latent distributions (see: LatentDistributionTest).",
        "Field List": {
            "Parameters": {
                "optimal_transport_lambda": "float (default=0.1), optional\nRegularization term of the Sinkhorn optimal transport algorithm.",
                "optimal_transport_eps": "float (default=0.01), optional\nTolerance parameter for the each Sinkhorn optimal transport algorithm. I.e. tolerance for each \"E-step\".",
                "optimal_transport_num_reps": "int (default=1000), optional\nNumber of repetitions in each iteration of the iterative optimal transport problem. I.e. maximum number of repetitions in each \"E-step\".",
                "iterative_num_reps": "int (default=100), optional\nNumber of reps in each iteration of the iterative optimal transport problem. I.e. maxumum number of total iterations the whole \"EM\" algorithm.",
                "init": "string, {'2d' (default), 'sign_flips', 'custom'}, optional\n'2d'\nUses  different restarts, where  is the dimension of the datasets. In particular, tries all matrices that are simultaneously diagonal and orthogonal. In other words, these are diagonal matrices with all entries on the diagonal being either +1 or -1. This is motivated by the fact that spectral graph embeddings have two types of orthogonal non-identifiability, one of which is captured by the orthogonal diagonal matrices. The final result is picked based on the final values of the objective function. For more on this, see [2].\n'sign_flips'\nInitial alignment done by making the median value in each dimension have the same sign. The motivation is similar to that in '2d', except this is a heuristic that can save time, but can sometimes yield suboptimal results.\n'custom'\nExpects either an initial guess for Q_ or an initial guess for P_, but not both. See initial_Q and initial_P, respectively. If neither is provided, initializes initial_Q to an identity with an appropriate number of dimensions.",
                "initial_Q": "np.ndarray, shape (d, d) or None, optional (default=None)\nAn initial guess for the alignment matrix, Q_, if such exists. Only one of initial_Q, initial_P can be provided at the same time, and only if init argument is set to 'custom'. If None, and initial_P is also None - initializes initial_Q to identity matrix. Must be an orthogonal matrix, if provided.",
                "initial_P": "np.ndarray, shape (n, m) or None, optional (default=None)\nInitial guess for the optimal transport matrix, P_, if such exists. Only one of initial_Q, initial_P can be provided at the same time, and only if init argument is set to 'custom'. If None, and initial_Q is also None - initializes initial_Q to identity matrix. Must be a soft assignment matrix if provided (rows sum up to 1/n, cols sum up to 1/m.)"
            },
            "Attributes": {
                "Q_array_": "size (d, d)\nFinal orthogonal matrix, used to modify X.",
                "P_array_": "size (n, m) where n and m are the sizes of two datasets\nFinal matrix of optimal transports, represent soft matching weights from points in one dataset to the other, normalized such that all rows sum to 1/n and all columns sum to 1/m.",
                "score_": "float\nFinal value of the objective function: Lower means the datasets have been matched together better.",
                "selected_initial_Q_": "array, size (d, d)\nInitial orthogonal matrix which was used as the initialization. If init was set to '2d' or 'sign_flips', then it is the adaptively selected matrix. If init was set to 'custom', and initial_Q was provided, then equal to that. If it was not provided, but initial_P was, then it is the matrix after the first procrustes performed. If neither was provided, then it is the identity matrix."
            },
            "Methods": {
                "__init__": {
                    "Parameters": {
                        "optimal_transport_lambda": "float",
                        "optimal_transport_eps": "float",
                        "optimal_transport_num_reps": "int",
                        "iterative_num_reps": "int",
                        "init": "str",
                        "initial_Q": "ndarray | None",
                        "initial_P": "ndarray | None"
                    }
                },
                "fit": {
                    "Description": "Uses the two datasets to learn the matrix self.Q_ that aligns the first dataset with the second.",
                    "Parameters": {
                        "X": "np.ndarray, shape (n, d)\nDataset to be mapped to Y, must have same number of dimensions (axis 1) as Y.",
                        "Y": "np.ndarray, shape (m, d)\nTarget dataset, must have same number of dimensions (axis 1) as X."
                    },
                    "Returns": {
                        "self": "returns an instance of self"
                    }
                },
                "fit_transform": {
                    "Description": "Uses the two datasets to learn the matrix Q_ that aligns the first dataset with the second. Then, transforms the first dataset X using the learned matrix Q_.",
                    "Parameters": {
                        "X": "np.ndarray, shape (n, d)\nDataset to be mapped to Y, must have same number of dimensions (axis 1) as Y.",
                        "Y": "np.ndarray, shape (m, d)\nTarget dataset, must have same number of dimensions (axis 1) as X."
                    },
                    "Returns": {
                        "X_prime": "np.ndarray, shape (n, d)\nFirst dataset of vectors, aligned to second. Equal to X @ Q_."
                    }
                },
                "get_metadata_routing": {
                    "Description": "Get metadata routing of this object.\nPlease check User Guide on how the routing mechanism works.",
                    "Returns": {
                        "routing": "MetadataRequest\nA MetadataRequest encapsulating routing information."
                    }
                },
                "get_params": {
                    "Description": "Get parameters for this estimator.",
                    "Parameters": {
                        "deep": "bool, default=True\nIf True, will return the parameters for this estimator and contained subobjects that are estimators."
                    },
                    "Returns": {
                        "params": "dict\nParameter names mapped to their values."
                    }
                },
                "set_params": {
                    "Description": "Set the parameters of this estimator.\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.",
                    "Parameters": {
                        "**params": "dict\nEstimator parameters."
                    },
                    "Returns": {
                        "self": "estimator instance\nEstimator instance."
                    }
                },
                "transform": {
                    "Description": "Transforms the dataset X using the learned matrix Q_. This may be the same as the first dataset as in fit(), or a new dataset. For example, additional samples from the same dataset.",
                    "Parameters": {
                        "X": "np.ndarray, shape(m, d)\nDataset to be transformed, must have same number of dimensions (axis 1) as X and Y that were passed to fit."
                    },
                    "Returns": {
                        "X_prime": "np.ndarray, shape (n, d)\nFirst dataset of vectors, aligned to second. Equal to X @ Q_."
                    }
                }
            }
        },
        "Rubric": {
            "Note": "In essence, the goal of this procedure is to simultaneously obtain a, not necessarily 1-to-1, correspondence between the vertices of the two data sets, and an orthogonal alignment between two datasets. If the two datasets are represented with matrices  and , then the correspondence is a matrix  that is soft assignment matrix (that is, its rows sum to , and columns sum to ) and the orthogonal alignment is an orthogonal matrix  (an orthogonal matrix is any matrix that satisfies ). The global objective function is .\n\nNote that both  and  are matrices in . Thus, if one knew , it would be simple to obtain an estimate for , using the regular orthogonal procrustes. On the other hand, if  was known, then  and  could be thought of distributions over a finite number of masses, each with weight  or , respectively. These distributions could be \"matched\" via solving an optimal transport problem.\n\nHowever, both  and  are simultaneously unknown here. So the algorithm performs a sequence of alternating steps, obtaining iteratively improving estimates of  and , similarly to an expectation-maximization (EM) procedure. It is not known whether this procedure is formally an EM, but the analogy can be drawn as follows: after obtaining an initial guess of of , obtaining an assignment matrix  (\"E-step\") is done by solving an optimal transport problem via Sinkhorn algorithm, whereas obtaining an orthogonal alignment matrix  (\"M-step\") is done via regular orthogonal procurstes. These alternating steps are performed until iterative_num_reps is reached.\n\nFor more on how the initial guess can be performed, see init.",
            "References": [
                "(1) Agterberg, J., Tang, M., Priebe., C. E. (2020). \"Nonparametric Two-Sample Hypothesis Testing for Random Graphs with Negative and Repeated Eigenvalues\" arXiv:2012.09828",
                "(2) Agterberg, J., Tang, M., Priebe., C. E. (2020). \"On Two Distinct Sources of Nonidentifiability in Latent Position Random Graph Models\" arXiv:2003.14250"
            ]
        }
    },
    {
        "Section_id": "KMeansCluster",
        "Description": "KMeans Cluster.\nIt computes all possible models from one component to max_clusters. When the true labels are known, the best model is given by the model with highest adjusted Rand index (ARI). Otherwise, the best model is given by the model with highest silhouette score.",
        "Field List": {
            "Parameters": {
                "max_clusters": "int, default=2.\nThe maximum number of clusters to consider. Must be >=2.",
                "random_state": "int, RandomState instance or None, optional (default=None)\nIf int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random."
            },
            "Attributes": {
                "n_clusters_": "int\nOptimal number of clusters. If y is given, it is based on largest ARI. Otherwise, it is based on highest silhouette score.",
                "model_KMeans_": "object\nFitted KMeans object fitted with n_clusters_.",
                "silhouette_list_": "List of silhouette scores computed for all possible number of clusters given by range(2, max_clusters).",
                "ari_list_": "Only computed when y is given. List of ARI values computed for all possible number of clusters given by range(2, max_clusters)."
            },
            "Methods": {
                "__init__": {
                    "Parameters": {
                        "max_clusters": "int",
                        "random_state": "int | RandomState | None"
                    }
                },
                "fit": {
                    "Description": "Fits kmeans model to the data.",
                    "Parameters": {
                        "X": "array-like, shape (n_samples, n_features)\nList of n_features-dimensional data points. Each row corresponds to a single data point.",
                        "y": "array-like, shape (n_samples,), optional (default=None)\nList of labels for X if available. Used to compute ARI scores."
                    },
                    "Returns": {
                        "self": "returns an instance of self"
                    }
                },
                "fit_predict": {
                    "Description": "Fit the models and predict clusters based on best model.",
                    "Parameters": {
                        "X": "array-like, shape (n_samples, n_features)\nList of n_features-dimensional data points. Each row corresponds to a single data point.",
                        "y": "array-like, shape (n_samples, ), optional (default=None)\nList of labels for X if available. Used to compute ARI scores."
                    },
                    "Returns": {
                        "labels": "array, shape (n_samples,)\nComponent labels."
                    }
                },
                "get_metadata_routing": {
                    "Description": "Get metadata routing of this object.\nPlease check User Guide on how the routing mechanism works.",
                    "Returns": {
                        "routing": "MetadataRequest\nA MetadataRequest encapsulating routing information."
                    }
                },
                "get_params": {
                    "Description": "Get parameters for this estimator.",
                    "Parameters": {
                        "deep": "bool, default=True\nIf True, will return the parameters for this estimator and contained subobjects that are estimators."
                    },
                    "Returns": {
                        "params": "dict\nParameter names mapped to their values."
                    }
                },
                "predict": {
                    "Description": "Predict clusters based on best model.",
                    "Parameters": {
                        "X": "array-like, shape (n_samples, n_features)\nList of n_features-dimensional data points. Each row corresponds to a single data point.",
                        "y": "array-like, shape (n_samples, ), optional (default=None)\nList of labels for X if available. Used to compute ARI scores."
                    },
                    "Returns": {
                        "labels": "array, shape (n_samples,)\nComponent labels."
                    }
                },
                "set_params": {
                    "Description": "Set the parameters of this estimator.\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.",
                    "Parameters": {
                        "**params": "dict\nEstimator parameters."
                    },
                    "Returns": {
                        "self": "estimator instance\nEstimator instance."
                    }
                }
            }
        }
    },
    {
        "Section_id": "GaussianCluster",
        "Description": "Gaussian Mixture Model (GMM)\nRepresentation of a Gaussian mixture model probability distribution. This class allows to estimate the parameters of a Gaussian mixture distribution. It computes all possible models from one component to max_components. The best model is given by the lowest BIC score.",
        "Field List": {
            "Parameters": {
                "min_components": "int, default=2.\nThe minimum number of mixture components to consider (unless max_components is None, in which case this is the maximum number of components to consider). If max_componens is not None, min_components must be less than or equal to max_components.",
                "max_components": "int or None, default=None.\nThe maximum number of mixture components to consider. Must be greater than or equal to min_components.",
                "covariance_type": "{'all' (default), 'full', 'tied', 'diag', 'spherical'}, optional\nString or list/array describing the type of covariance parameters to use. If a string, it must be one of:\n\n'all'\nconsiders all covariance structures in ['spherical', 'diag', 'tied', 'full']\n'full'\neach component has its own general covariance matrix\n'tied'\nall components share the same general covariance matrix\n'diag'\neach component has its own diagonal covariance matrix\n'spherical'\neach component has its own single variance\nIf a list/array, it must be a list/array of strings containing only\n'spherical', 'tied', 'diag', and/or 'full'.",
                "tol": "float, defaults to 1e-3.\nThe convergence threshold. EM iterations will stop when the lower bound average gain is below this threshold.",
                "reg_covar": "float, defaults to 1e-6.\nNon-negative regularization added to the diagonal of covariance. Allows to assure that the covariance matrices are all positive.",
                "max_iter": "int, defaults to 100.\nThe number of EM iterations to perform.",
                "n_init": "int, defaults to 1.\nThe number of initializations to perform. The best results are kept.",
                "init_params": "{'kmeans', 'random'}, defaults to 'kmeans'.\nThe method used to initialize the weights, the means and the precisions. Must be one of:\n\n'kmeans' : responsibilities are initialized using kmeans.\n'random' : responsibilities are initialized randomly.",
                "random_state": "int, RandomState instance or None, optional (default=None)\nIf int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random."
            },
            "Attributes": {
                "n_components_": "int\nOptimal number of components based on BIC.",
                "covariance_type_": "str\nOptimal covariance type based on BIC.",
                "model_GaussianMixture_": "object\nFitted GaussianMixture object fitted with optimal number of components and optimal covariance structure.",
                "bic_": "pandas.DataFrame\nA pandas DataFrame of BIC values computed for all possible number of clusters given by range(min_components, max_components + 1) and all covariance structures given by covariance_type.",
                "ari_": "pandas.DataFrame\nOnly computed when y is given. Pandas Dataframe containing ARI values computed for all possible number of clusters given by range(min_components, max_components) and all covariance structures given by covariance_type."
            },
            "Methods": {
                "__init__": {
                    "Parameters": {
                        "min_components": "int",
                        "max_components": "int | None",
                        "covariance_type": "str",
                        "tol": "float",
                        "reg_covar": "float",
                        "max_iter": "int",
                        "n_init": "int",
                        "init_params": "str",
                        "random_state": "int | RandomState | None"
                    }
                },
                "fit": {
                    "Description": "Fits gaussian mixure model to the data. Estimate model parameters with the EM algorithm.",
                    "Parameters": {
                        "X": "array-like, shape (n_samples, n_features)\nList of n_features-dimensional data points. Each row corresponds to a single data point.",
                        "y": "array-like, shape (n_samples,), optional (default=None)\nList of labels for X if available. Used to compute ARI scores."
                    },
                    "Returns": {
                        "self": "self"
                    }
                },
                "fit_predict": {
                    "Description": "Fit the models and predict clusters based on best model.",
                    "Parameters": {
                        "X": "array-like, shape (n_samples, n_features)\nList of n_features-dimensional data points. Each row corresponds to a single data point.",
                        "y": "array-like, shape (n_samples,), optional (default=None)\nList of labels for X if available. Used to compute ARI scores."
                    },
                    "Returns": {
                        "labels": "array, shape (n_samples,)\nComponent labels."
                    }
                },
                "get_metadata_routing": {
                    "Description": "Get metadata routing of this object.\nPlease check User Guide on how the routing mechanism works.",
                    "Returns": {
                        "routing": "MetadataRequest\nA MetadataRequest encapsulating routing information."
                    }
                },
                "get_params": {
                    "Description": "Get parameters for this estimator.",
                    "Parameters": {
                        "deep": "bool, default=True\nIf True, will return the parameters for this estimator and contained subobjects that are estimators."
                    },
                    "Returns": {
                        "params": "dict\nParameter names mapped to their values."
                    }
                },
                "predict": {
                    "Description": "Predict clusters based on best model.",
                    "Parameters": {
                        "X": "array-like, shape (n_samples, n_features)\nList of n_features-dimensional data points. Each row corresponds to a single data point.",
                        "y": "array-like, shape (n_samples,), optional (default=None)\nList of labels for X if available. Used to compute ARI scores."
                    },
                    "Returns": {
                        "labels": "array, shape (n_samples,)\nComponent labels."
                    }
                },
                "set_params": {
                    "Description": "Set the parameters of this estimator.\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.",
                    "Parameters": {
                        "**params": "dict"
                    },
                    "Returns": {
                        "self": "estimator instance"
                    }
                }
            }
        }
    },
    {
        "Section_id": "AutoGMMCluster",
        "Description": "Automatic Gaussian Mixture Model (GMM) selection.\nClustering algorithm using a hierarchical agglomerative clustering then Gaussian mixtured model (GMM) fitting. Different combinations of agglomeration, GMM, and cluster numbers are used and the clustering with the best selection criterion (bic/aic) is chosen.",
        "Field List": {
            "Parameters": {
                "min_components": "int, default=2.\nThe minimum number of mixture components to consider (unless max_components is None, in which case this is the maximum number of components to consider). If max_components is not None, min_components must be less than or equal to max_components. If label_init is given, min_components must match number of unique labels in label_init.",
                "max_components": "int or None, default=10.\nThe maximum number of mixture components to consider. Must be greater than or equal to min_components. If label_init is given, min_components must match number of unique labels in label_init.",
                "affinity": "{'euclidean','manhattan','cosine','none', 'all' (default)}, optional\nString or list/array describing the type of affinities to use in agglomeration. If a string, it must be one of:\n\n'euclidean'\nL2 norm\n'manhattan'\nL1 norm\n'cosine'\ncosine similarity\n'none'\nno agglomeration - GMM is initialized with k-means\n'all'\nconsiders all affinities in ['euclidean','manhattan','cosine','none']\nIf a list/array, it must be a list/array of strings containing only 'euclidean', 'manhattan', 'cosine', and/or 'none'.\n\nNote that cosine similarity can only work when all of the rows are not the zero vector. If the input matrix has a zero row, cosine similarity will be skipped and a warning will be thrown.",
                "linkage": "{'ward','complete','average','single', 'all' (default)}, optional\nString or list/array describing the type of linkages to use in agglomeration. If a string, it must be one of:\n\n'ward'\nward's clustering, can only be used with euclidean affinity\n'complete'\ncomplete linkage\n'average'\naverage linkage\n'single'\nsingle linkage\n'all'\nconsiders all linkages in ['ward','complete','average','single']\nIf a list/array, it must be a list/array of strings containing only 'ward', 'complete', 'average', and/or 'single'.",
                "covariance_type": "{'full', 'tied', 'diag', 'spherical', 'all' (default)} , optional\nString or list/array describing the type of covariance parameters to use. If a string, it must be one of:\n\n'full'\neach component has its own general covariance matrix\n'tied'\nall components share the same general covariance matrix\n'diag'\neach component has its own diagonal covariance matrix\n'spherical'\neach component has its own single variance\n'all'\nconsiders all covariance structures in ['spherical', 'diag', 'tied', 'full']\nIf a list/array, it must be a list/array of strings containing only 'spherical', 'tied', 'diag', and/or 'spherical'.",
                "random_state": "int, RandomState instance or None, optional (default=None)\nThere is randomness in k-means initialization of sklearn.mixture.GaussianMixture. This parameter is passed to GaussianMixture to control the random state. If int, random_state is used as the random number generator seed; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.",
                "label_init": "array-like, shape (n_samples,), optional (default=None)\nList of labels for samples if available. Used to initialize the model. If provided, min_components and max_components must match the number of unique labels given here.",
                "kmeans_n_init": "int, optional (default = 1)\nIf kmeans_n_init is larger than 1 and label_init is None, additional kmeans_n_init-1 runs of sklearn.mixture.GaussianMixture initialized with k-means will be performed for all covariance parameters in covariance_type.",
                "max_iter": "int, optional (default = 100).\nThe maximum number of EM iterations to perform.",
                "selection_criteria": "str {\"bic\" or \"aic\"}, optional, (default=\"bic\")\nselect the best model based on Bayesian Information Criterion (bic) or Aikake Information Criterion (aic)",
                "verbose": "int, optional (default = 0)\nEnable verbose output. If 1 then it prints the current initialization and each iteration step. If greater than 1 then it prints also the log probability and the time needed for each step.",
                "max_agglom_size": "int or None, optional (default = 2000)\nThe maximum number of datapoints on which to do agglomerative clustering as the initialization to GMM. If the number of datapoints is larger than this value, a random subset of the data is used for agglomerative initialization. If None, all data is used for agglomerative clustering for initialization.",
                "n_jobs": "int or None, optional (default = None)\nThe number of jobs to use for the computation. This works by computing each of the initialization runs in parallel. None means 1 unless in a joblib.parallel_backend context. -1 means using all processors. See https://scikit-learn.org/stable/glossary.html#term-n-jobs for more details."
            },
            "Attributes": {
                "results_pandas_": "pandas.DataFrame\nContains exhaustive information about all the clustering runs. Columns are:\n'model'GaussianMixture object\nGMM clustering fit to the data\n\n'bic/aic'float\nBayesian Information Criterion\n\n'ari'float or nan\nAdjusted Rand Index between GMM classification, and true classification, nan if y is not given\n\n'n_components'int\nnumber of clusters\n\n'affinity'{'euclidean','manhattan','cosine','none'}\naffinity used in Agglomerative Clustering\n\n'linkage'{'ward','complete','average','single'}\nlinkage used in Agglomerative Clustering\n\n'covariance_type'{'full', 'tied', 'diag', 'spherical'}\ncovariance type used in GMM\n\n'reg_covar'float\nregularization used in GMM",
                "criter_": "the best (lowest) Bayesian Information Criterion",
                "n_components_": "int\nnumber of clusters in the model with the best bic/aic",
                "covariance_type_": "str\ncovariance type in the model with the best bic/aic",
                "affinity_": "str\naffinity used in the model with the best bic/aic",
                "linkage_": "str\nlinkage used in the model with the best bic/aic",
                "reg_covar_": "float\nregularization used in the model with the best bic/aic",
                "ari_": "float\nARI from the model with the best bic/aic, nan if no y is given",
                "model_": "sklearn.mixture.GaussianMixture\nobject with the best bic/aic"
            },
            "Methods": {
                "__init__": {
                    "Parameters": {
                        "min_components": "int",
                        "max_components": "int | None",
                        "affinity": "str | ndarray | List[str]",
                        "linkage": "str | ndarray | List[str]",
                        "covariance_type": "str | ndarray | List[str]",
                        "random_state": "int | RandomState | None",
                        "label_init": "ndarray | List[int] | None",
                        "kmeans_n_init": "int",
                        "max_iter": "int",
                        "verbose": "int",
                        "selection_criteria": "str",
                        "max_agglom_size": "int | None",
                        "n_jobs": "int | None"
                    }
                },
                "fit": {
                    "Description": "Fits gaussian mixture model to the data. Initialize with agglomerative clustering then estimate model parameters with EM algorithm.",
                    "Parameters": {
                        "X": "array-like, shape (n_samples, n_features)\nList of n_features-dimensional data points. Each row corresponds to a single data point.",
                        "y": "array-like, shape (n_samples,), optional (default=None)\nList of labels for X if available. Used to compute ARI scores."
                    },
                    "Returns": {
                        "self": "object\nReturns an instance of self."
                    }
                },
                "fit_predict": {
                    "Description": "Fit the models and predict clusters based on best model.",
                    "Parameters": {
                        "X": "array-like, shape (n_samples, n_features)\nList of n_features-dimensional data points. Each row corresponds to a single data point.",
                        "y": "array-like, shape (n_samples, ), optional (default=None)\nList of labels for X if available. Used to compute ARI scores."
                    },
                    "Returns": {
                        "labels": "array, shape (n_samples,)\nComponent labels."
                    }
                },
                "get_metadata_routing": {
                    "Description": "Get metadata routing of this object.\nPlease check User Guide on how the routing mechanism works.",
                    "Returns": {
                        "routing": "MetadataRequest\nA MetadataRequest encapsulating routing information."
                    }
                },
                "get_params": {
                    "Description": "Get parameters for this estimator.",
                    "Parameters": {
                        "deep": "bool, default=True\nIf True, will return the parameters for this estimator and contained subobjects that are estimators."
                    },
                    "Returns": {
                        "params": "dict\nParameter names mapped to their values."
                    }
                },
                "predict": {
                    "Description": "Predict clusters based on best model.",
                    "Parameters": {
                        "X": "array-like, shape (n_samples, n_features)\nList of n_features-dimensional data points. Each row corresponds to a single data point.",
                        "y": "array-like, shape (n_samples, ), optional (default=None)\nList of labels for X if available. Used to compute ARI scores."
                    },
                    "Returns": {
                        "labels": "array, shape (n_samples,)\nComponent labels."
                    }
                },
                "set_params": {
                    "Description": "Set the parameters of this estimator.\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.",
                    "Parameters": {
                        "**params": "dict\nEstimator parameters."
                    },
                    "Returns": {
                        "self": "estimator instance\nEstimator instance."
                    }
                }
            }
        },
        "Rubric": {
            "References": [
                "Jeffrey D. Banfield and Adrian E. Raftery. Model-based gaussian and non-gaussian clustering. Biometrics, 49:803\u2013821, 1993.",
                "Abhijit Dasgupta and Adrian E. Raftery. Detecting features in spatial point processes with clutter via model-based clustering. Journal of the American Statistical Association, 93(441):294\u2013302, 1998."
            ]
        }
    },
    {
        "Section_id": "DivisiveCluster",
        "Description": "Recursively clusters data based on a chosen clustering algorithm. This algorithm implements a 'divisive' or 'top-down' approach.",
        "Field List": {
            "Parameters": {
                "cluster_method": "str {'gmm', 'kmeans'}, defaults to 'gmm'.\nThe underlying clustering method to apply. If 'gmm' will use AutoGMMCluster. If 'kmeans', will use KMeansCluster.",
                "min_components": "int, defaults to 1.\nThe minimum number of mixture components/clusters to consider for the first split if 'gmm' is selected as cluster_method; and is set to 1 for later splits. If cluster_method is 'kmeans', it is set to 2 for all splits.",
                "max_components": "int, defaults to 2.\nThe maximum number of mixture components/clusters to consider at each split.",
                "min_split": "int, defaults to 1.\nThe minimum size of a cluster for it to be considered to be split again.",
                "max_level": "int, defaults to 4.\nThe maximum number of times to recursively cluster the data.",
                "delta_criter": "float, non-negative, defaults to 0.\nThe smallest difference between selection criterion values of a new model and the current model that is required to accept the new model. Applicable only if cluster_method is 'gmm'.",
                "cluster_kws": "dict, defaults to {}\nKeyword arguments (except min_components and max_components) for chosen clustering method."
            },
            "Attributes": {
                "model_": "GaussianMixture or KMeans object\nFitted clustering object based on which cluster_method was used."
            },
            "Methods": {
                "__init__": {
                    "Parameters": {
                        "cluster_method": "str {'gmm', 'kmeans'}",
                        "min_components": "int",
                        "max_components": "int",
                        "cluster_kws": "dict",
                        "min_split": "int",
                        "max_level": "int",
                        "delta_criter": "float"
                    }
                },
                "fit": {
                    "Description": "Fits clustering models to the data as well as resulting clusters",
                    "Parameters": {
                        "X": "array-like, shape (n_samples, n_features)\n"
                    },
                    "Returns": {
                        "self": "object\nReturns an instance of self."
                    }
                },
                "fit_predict": {
                    "Description": "Fits clustering models to the data as well as resulting clusters and using fitted models to predict a hierarchy of labels",
                    "Parameters": {
                        "X": "array-like, shape (n_samples, n_features)\n",
                        "fcluster": "bool, default=False\nif True, returned labels will be re-numbered so that each column of labels represents a flat clustering at current level, and each label corresponds to a cluster indexed the same as the corresponding node in the overall clustering dendrogram",
                        "level": "int, optional (default=None)\nthe level of a single flat clustering to generate only available if fcluster is True"
                    },
                    "Returns": {
                        "labels": "array_label,shape (n_samples, n_levels)\nif no level specified; otherwise, shape (n_samples,)"
                    }
                },
                "predict": {
                    "Description": "Predicts a hierarchy of labels based on fitted models",
                    "Parameters": {
                        "X": "array-like, shape (n_samples, n_features)\n",
                        "fcluster": "bool, default=False\nif True, returned labels will be re-numbered so that each column of labels represents a flat clustering at current level, and each label corresponds to a cluster indexed the same as the corresponding node in the overall clustering dendrogram",
                        "level": "int, optional (default=None)\nthe level of a single flat clustering to generate only available if fcluster is True"
                    },
                    "Returns": {
                        "labels": "array-like, shape (n_samples, n_levels)\nif no level specified; otherwise, shape (n_samples,)"
                    }
                },
                "set_predict_request": {
                    "Description": "Request metadata passed to the predict method.\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to the predict method.\nFalse: metadata is not requested, and not passed to the predict.\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\nStr: metadata should be passed to the meta-estimator with this given alias instead of the original name.",
                    "Parameters": {
                        "fcluster": "str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED\nMetadata routing for fcluster parameter in predict.",
                        "level": "str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED\nMetadata routing for level parameter in predict."
                    }
                }
            }
        },
        "Rubric": {
            "Note": "This class inherits from anytree.node.nodemixin.NodeMixin, a lightweight class for doing various simple operations on trees.\nThis algorithm was strongly inspired by maggotcluster, a divisive clustering algorithm in https://github.com/neurodata/maggot_models and the algorithm for estimating a hierarchical stochastic block model presented in [2].",
            "References": [
                "Athey, T. L., & Vogelstein, J. T. (2019). AutoGMM: Automatic Gaussian Mixture Modeling in Python. arXiv preprint arXiv:1909.02688.",
                "Lyzinski, V., Tang, M., Athreya, A., Park, Y., & Priebe, C. E (2016). Community detection and classification in hierarchical stochastic blockmodels. IEEE Transactions on Network Science and Engineering, 4(1), 13-26."
            ]
        }
    },
    {
        "Section_id": "load_drosophila_left",
        "Description": "Load the left Drosophila larva mushroom body connectome\nThe mushroom body is a learning and memory center in the fly brain which is involved in sensory integration and processing. This connectome was observed by electron microscopy and then individial neurons were reconstructed; synaptic partnerships between these neurons became the edges of the graph.",
        "Field List": {
            "Parameters": {
                "return_labels": "bool, optional (default=False)\nwhether to have a second return value which is an array of cell type labels for each node in the adjacency matrix"
            },
            "Returns": {
                "graph": "np.ndarray\nAdjacency matrix of the connectome",
                "labels": "np.ndarray\nOnly returned if return_labels is true. Array of string labels for each cell (vertex)"
            }
        },
        "Rubric": {
            "References": [
                "Eichler, K., Li, F., Litwin-Kumar, A., Park, Y., Andrade, I., Schneider-Mizell, C. M., ... & Fetter, R. D. (2017). The complete connectome of a learning and memory centre in an insect brain. Nature, 548(7666), 175."
            ]
        }
    },
    {
        "Section_id": "load_drosophila_right",
        "Description": "Load the right Drosophila larva mushroom body connectome\nThe mushroom body is a learning and memory center in the fly brain which is involved in sensory integration and processing. This connectome was observed by electron microscopy and then individial neurons were reconstructed; synaptic partnerships between these neurons became the edges of the graph.",
        "Field List": {
            "Parameters": {
                "return_labels": "bool, optional (default=False)\nwhether to have a second return value which is an array of cell type labels for each node in the adjacency matrix"
            },
            "Returns": {
                "graph": "np.ndarray\nAdjacency matrix of the connectome",
                "labels": "np.ndarray\nOnly returned if return_labels is true. Array of string labels for each cell (vertex)"
            }
        },
        "Rubric": {
            "References": [
                "Eichler, K., Li, F., Litwin-Kumar, A., Park, Y., Andrade, I., Schneider-Mizell, C. M., ... & Fetter, R. D. (2017). The complete connectome of a learning and memory centre in an insect brain. Nature, 548(7666), 175."
            ]
        }
    },
    {
        "Section_id": "load_mice",
        "Description": "Load connectomes of mice from distinct genotypes.\nDataset of 32 mouse connectomes derived from whole-brain diffusion magnetic resonance imaging of four distinct mouse genotypes: BTBR T+ Itpr3tf/J (BTBR), C57BL/6J(B6), CAST/EiJ (CAST), and DBA/2J (DBA2). For each strain, connectomes were generated from eight age-matched mice (N = 8 per strain), with a sex distribution of of four males and four females. Each connectome was parcellated using asymmetric Waxholm Space, yielding a vertex set with a total of 332 regions of interest (ROIs) symmetrically distributed across the left and right hemispheres. Within a given hemisphere, there are seven superstructures consisting up multiple ROIs, resulting in a total of 14 distinct communities in each connectome.",
        "Field List": {
            "Returns": {
                "data": "Bunch\nDictionary-like object, with the following attributes.\ngraphs: list of np.ndarray\nList of adjacency matrices of the connectome\nlabels: np.ndarray\nArray of string labels for each mouse (subject)\natlas: pd.DataFrame\nDataFrame of information for each ROI\nblocks: pd.DataFrame\nDataFrame of block assignments for each ROI\nfeatures: pd.DataFrame\nDataFrame of anatomical features for each ROI in each connectome\nparticipants: pd.DataFrame\nDataFrame of subject IDs and genotypes for each connectome\nmeta: Dictionary\nDictionary with meta information about the dataset (n_subjects and n_vertices)"
            }
        }
    },
    {
        "Section_id": "select_dimension",
        "Description": "Generates profile likelihood from array based on Zhu and Godsie method. Elbows correspond to the optimal embedding dimension.",
        "Field List": {
            "Parameters": {
                "X": "1d or 2d array-like\nInput array generate profile likelihoods for. If 1d-array, it should be sorted in decreasing order. If 2d-array, shape should be (n_samples, n_features).",
                "n_components": " int, optional, default: None.\nNumber of components to embed. If None, n_components = floor(log2(min(n_samples, n_features))). Ignored if X is 1d-array.",
                "n_elbows": "int, optional, default: 2.\nNumber of likelihood elbows to return. Must be > 1.",
                "threshold": "float, int, optional, default: None\nIf given, only consider the singular values that are > threshold. Must be >= 0.",
                "return_likelihoods": "bool, optional, default: False\nIf True, returns the all likelihoods associated with each elbow."
            },
            "Returns": {
                "elbows": "List\nElbows indicate subsequent optimal embedding dimensions. Number of elbows may be less than n_elbows if there are not enough singular values.",
                "sing_vals": "List\nThe singular values associated with each elbow.",
                "likelihoods": "List of array-like\nArray of likelihoods of the corresponding to each elbow. Only returned if return_likelihoods is True."
            }
        },
        "Rubric": {
            "References": [
                "Zhu, M. and Ghodsi, A. (2006). Automatic dimensionality selection from the scree plot via the use of profile likelihood. Computational Statistics & Data Analysis, 51(2), pp.918-930."
            ]
        }
    },
    {
        "Section_id": "select_svd",
        "Description": "Dimensionality reduction using SVD.\nPerforms linear dimensionality reduction by using either full singular value decomposition (SVD) or truncated SVD. Full SVD is performed using SciPy's wrapper for ARPACK, while truncated SVD is performed using either SciPy's wrapper for LAPACK or Sklearn's implementation of randomized SVD.\nIt also performs optimal dimensionality selection using Zhu & Godsie algorithm if number of target dimension is not specified.",
        "Field List": {
            "Parameters": {
                "X": "array-like, shape (n_samples, n_features)\nThe data to perform svd on.",
                "n_components": "int or None, default = None\nDesired dimensionality of output data. If 'full', n_components must be <= min(X.shape). Otherwise, n_components must be < min(X.shape). If None, then optimal dimensions will be chosen by select_dimension() using n_elbows argument.",
                "n_elbows": "int, optional, default: 2\nIf n_components is None, then compute the optimal embedding dimension using select_dimension(). Otherwise, ignored.",
                "algorithm": "{'randomized' (default), 'full', 'truncated'}, optional\nSVD solver to use:\n\n'randomized'\nComputes randomized svd using sklearn.utils.extmath.randomized_svd()\n'full'\nComputes full svd using scipy.linalg.svd() Does not support graph input of type scipy.sparse.csr_array\n'truncated'\nComputes truncated svd using scipy.sparse.linalg.svds()\n'eigsh'\nComputes svd of a real, symmetric square matrix using scipy.sparse.linalg.eigsh(). Extremely fast for these types of matrices.",
                "n_iter": "int, optional, default: 5\nNumber of iterations for randomized SVD solver. Ignored for 'full' or 'truncated'. The default is larger than the default in randomized_svd to handle sparse matrices that may have large slowly decaying spectrum.",
                "svd_seed": "int or None, optional, default: None\nOnly applicable for algorithm='randomized'; allows you to seed the randomized svd solver for deterministic, albeit pseudo-randomized behavior."
            },
            "Returns": {
                "U": "array-like, shape (n_samples, n_components)\nLeft singular vectors corresponding to singular values.",
                "D": "array-like, shape (n_components)\nSingular values in decreasing order, as a 1d array.",
                "V": "array-like, shape (n_components, n_samples)\nRight singular vectors corresponding to singular values."
            }
        },
        "Rubric": {
            "References": [
                "Zhu, M. and Ghodsi, A. (2006). Automatic dimensionality selection from the scree plot via the use of profile likelihood. Computational Statistics & Data Analysis, 51(2), pp.918-930."
            ]
        }
    },
    {
        "Section_id": "AdjacencySpectralEmbed",
        "Description": "Class for computing the adjacency spectral embedding of a graph.\nThe adjacency spectral embedding (ASE) is a k-dimensional Euclidean representation of the graph based on its adjacency matrix. It relies on an SVD to reduce the dimensionality to the specified k, or if k is unspecified, can find a number of dimensions automatically (see select_svd).",
        "Field List": {
            "Parameters": {
                "n_components": "int or None, default = None\nDesired dimensionality of output data. If 'full', n_components must be <= min(X.shape). Otherwise, n_components must be < min(X.shape). If None, then optimal dimensions will be chosen by select_dimension() using n_elbows argument.",
                "n_elbows": "int, optional, default: 2\nIf n_components is None, then compute the optimal embedding dimension using select_dimension(). Otherwise, ignored.",
                "algorithm": "{'randomized' (default), 'full', 'truncated'}, optional\nSVD solver to use:\n\n'randomized'\nComputes randomized svd using sklearn.utils.extmath.randomized_svd()\n'full'\nComputes full svd using scipy.linalg.svd() Does not support graph input of type scipy.sparse.csr_array\n'truncated'\nComputes truncated svd using scipy.sparse.linalg.svds()",
                "n_iter": "int, optional (default = 5)\nNumber of iterations for randomized SVD solver. Not used by 'full' or 'truncated'. The default is larger than the default in randomized_svd to handle sparse matrices that may have large slowly decaying spectrum.",
                "check_lcc": "bool , optional (default = True)\nWhether to check if input graph is connected. May result in non-optimal results if the graph is unconnected. If True and input is unconnected, a UserWarning is thrown. Not checking for connectedness may result in faster computation.",
                "diag_aug": "bool, optional (default = True)\nWhether to replace the main diagonal of the adjacency matrix with a vector corresponding to the degree (or sum of edge weights for a weighted network) before embedding. Empirically, this produces latent position estimates closer to the ground truth.",
                "concat": "bool, optional (default False)\nIf graph is directed, whether to concatenate left and right (out and in) latent positions along axis 1.",
                "svd_seed": "int or None (default None)\nOnly applicable for algorithm='randomized'; allows you to seed the randomized svd solver for deterministic, albeit pseudo-randomized behavior."
            },
            "Attributes": {
                "n_features_in_": "int\nNumber of features passed to the fit() method.",
                "latent_left_": "array, shape (n_samples, n_components)\nEstimated left latent positions of the graph.",
                "latent_right_": "array, shape (n_samples, n_components), or None\nOnly computed when the graph is directed, or adjacency matrix is assymetric. Estimated right latent positions of the graph. Otherwise, None.",
                "singular_values_": "array, shape (n_components)\nSingular values associated with the latent position matrices."
            },
            "Methods": {
                "__init__": {
                    "Parameters": {
                        "n_components": "int | None",
                        "n_elbows": "int | None",
                        "algorithm": "str",
                        "n_iter": "int",
                        "check_lcc": "bool",
                        "diag_aug": "bool",
                        "concat": "bool",
                        "svd_seed": "int | None"
                    }
                },
                "fit": {
                    "Description": "Fit ASE model to input graph",
                    "Parameters": {
                        "graph": "array-like, scipy.sparse.csr_array, or networkx.Graph\nInput graph to embed.",
                        "y": "Ignored"
                    },
                    "Returns": {
                        "self": "object\nReturns an instance of self."
                    }
                },
                "fit_transform": {
                    "Description": "Fit the model with graphs and apply the transformation.\nn_dimension is either automatically determined or based on user input.",
                    "Parameters": {
                        "graph": "array-like, scipy.sparse.csr_array, or networkx.Graph\nInput graph to embed."
                    },
                    "Returns": {
                        "out": "np.ndarray OR length 2 tuple of np.ndarray.\nIf undirected then returns single np.ndarray of latent position, shape(n_vertices, n_components). If directed, concat is True then concatenate latent matrices on axis 1, shape(n_vertices, 2*n_components). If directed, concat is False then tuple of the latent matrices. Each of shape (n_vertices, n_components)."
                    }
                },
                "get_metadata_routing": {
                    "Description": "Get metadata routing of this object.\nPlease check User Guide on how the routing mechanism works.",
                    "Returns": {
                        "routing": "MetadataRequest\nA MetadataRequest encapsulating routing information."
                    }
                },
                "get_params": {
                    "Description": "Get parameters for this estimator.",
                    "Parameters": {
                        "deep": "bool, default=True\nIf True, will return the parameters for this estimator and contained subobjects that are estimators."
                    },
                    "Returns": {
                        "params": "dict\nParameter names mapped to their values."
                    }
                },
                "set_fit_request": {
                    "Description": "Request metadata passed to the fit method.\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to fit if provided. The request is ignored if metadata is not provided.\nFalse: metadata is not requested and the meta-estimator will not pass it to fit.\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\nStr: metadata should be passed to the meta-estimator with this given alias instead of the original name.",
                    "Parameters": {
                        "graph": "str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED\nMetadata routing for graph parameter in fit."
                    },
                    "Returns": {
                        "self": "object\nThe updated object."
                    }
                }
            },
            "Rubric": {
                "Note": "The singular value decomposition is used to find an orthonormal basis for a matrix, which in our case is the adjacency matrix of the graph. These basis vectors (in the matrices U or V) are ordered according to the amount of variance they explain in the original matrix. By selecting a subset of these basis vectors (through our choice of dimensionality reduction) we can find a lower dimensional space in which to represent the graph.",
                "References": [
                    "Sussman, D.L., Tang, M., Fishkind, D.E., Priebe, C.E. \"A Consistent Adjacency Spectral Embedding for Stochastic Blockmodel Graphs,\" Journal of the American Statistical Association, Vol. 107(499), 2012",
                    "Levin, K., Roosta-Khorasani, F., Mahoney, M. W., & Priebe, C. E. (2018). Out-of-sample extension of graph adjacency spectral embedding. PMLR: Proceedings of Machine Learning Research, 80, 2975-2984."
                ]
            }
        }
    },
    {
        "Section_id": "LaplacianSpectralEmbed",
        "Description": "Class for computing the laplacian spectral embedding of a graph.\nThe laplacian spectral embedding (LSE) is a k-dimensional Euclidean representation of the graph based on its Laplacian matrix. It relies on an SVD to reduce the dimensionality to the specified n_components, or if n_components is unspecified, can find a number of dimensions automatically.",
        "Field List": {
            "Parameters": {
                "form": "{'DAD' (default), 'I-DAD', 'R-DAD'}, optional\nSpecifies the type of Laplacian normalization to use. See to_laplacian() for more details regarding form.",
                "n_components": "int or None, default = None\nDesired dimensionality of output data. If 'full', n_components must be <= min(X.shape). Otherwise, n_components must be < min(X.shape). If None, then optimal dimensions will be chosen by select_dimension() using n_elbows argument.",
                "n_elbows": "int, optional, default: 2\nIf n_components is None, then compute the optimal embedding dimension using select_dimension(). Otherwise, ignored.",
                "algorithm": "{'randomized' (default), 'full', 'truncated'}, optional\nSVD solver to use:\n\n'randomized'\nComputes randomized svd using sklearn.utils.extmath.randomized_svd()\n'full'\nComputes full svd using scipy.linalg.svd()\n'truncated'\nComputes truncated svd using scipy.sparse.linalg.svds()",
                "n_iter": "int, optional (default = 5)\nNumber of iterations for randomized SVD solver. Not used by 'full' or 'truncated'. The default is larger than the default in randomized_svd to handle sparse matrices that may have large slowly decaying spectrum.",
                "check_lcc": "bool , optional (defult = True)\nWhether to check if input graph is connected. May result in non-optimal results if the graph is unconnected. If True and input is unconnected, a UserWarning is thrown. Not checking for connectedness may result in faster computation.",
                "regularizer": "int, float or None, optional (default=None)\nConstant to be added to the diagonal of degree matrix. If None, average node degree is added. If int or float, must be >= 0. Only used when form is 'R-DAD'.",
                "concat": "bool, optional (default False)\nIf graph is directed, whether to concatenate left and right (out and in) latent positions along axis 1."
            },
            "Attributes": {
                "n_features_in_": "int\nNumber of features passed to the fit() method.",
                "latent_left_": "array, shape (n_samples, n_components)\nEstimated left latent positions of the graph.",
                "latent_right_": "array, shape (n_samples, n_components), or None\nOnly computed when the graph is directed, or adjacency matrix is assymetric. Estimated right latent positions of the graph. Otherwise, None.",
                "singular_values_": "array, shape (n_components)\nSingular values associated with the latent position matrices.",
                "svd_seed_": "int or None\nOnly applicable for algorithm='randomized'; allows you to seed the randomized svd solver for deterministic, albeit pseudo-randomized behavior."
            },
            "Methods": {
                "__init__": {
                    "Parameters": {
                        "form": "str {'DAD' (default), 'I-DAD', 'R-DAD'}",
                        "n_components": "int | None",
                        "n_elbows": "int",
                        "algorithm": "str",
                        "n_iter": "int",
                        "check_lcc": "bool",
                        "regularizer": "int | float | None",
                        "concat": "bool"
                    }
                },
                "fit": {
                    "Description": "Fit LSE model to input graph",
                    "Parameters": {
                        "graph": "array-like, scipy.sparse.csr_array, or networkx.Graph\nInput graph to embed."
                    },
                    "Returns": {
                        "self": "object\nReturns an instance of self."
                    }
                },
                "fit_transform": {
                    "Description": "Fit the model with graphs and apply the transformation.\nn_dimension is either automatically determined or based on user input.",
                    "Parameters": {
                        "graph": "array-like, scipy.sparse.csr_array, or networkx.Graph\nInput graph to embed."
                    },
                    "Returns": {
                        "out": "np.ndarray OR length 2 tuple of np.ndarray.\nIf undirected then returns single np.ndarray of latent position, shape(n_vertices, n_components). If directed, concat is True then concatenate latent matrices on axis 1, shape(n_vertices, 2*n_components). If directed, concat is False then tuple of the latent matrices. Each of shape (n_vertices, n_components)."
                    }
                },
                "get_metadata_routing": {
                    "Description": "Get metadata routing of this object.\nPlease check User Guide on how the routing mechanism works.",
                    "Returns": {
                        "routing": "MetadataRequest\nA MetadataRequest encapsulating routing information."
                    }
                },
                "get_params": {
                    "Description": "Get parameters for this estimator.",
                    "Parameters": {
                        "deep": "bool, default=True\nIf True, will return the parameters for this estimator and contained subobjects that are estimators."
                    },
                    "Returns": {
                        "params": "dict\nParameter names mapped to their values."
                    }
                },
                "set_fit_request": {
                    "Description": "Request metadata passed to the fit method.\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to fit if provided. The request is ignored if metadata is not provided.\nFalse: metadata is not requested and the meta-estimator will not pass it to fit.\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\nStr: metadata should be passed to the meta-estimator with this given alias instead of the original name.",
                    "Parameters": {
                        "graph": "str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED\nMetadata routing for graph parameter in fit."
                    },
                    "Returns": {
                        "self": "object\nThe updated object."
                    }
                },
                "set_params": {
                    "Description": "Set the parameters of this estimator.\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.",
                    "Parameters": {
                        "**params": "dict\nEstimator parameters."
                    },
                    "Returns": {
                        "self": "estimator instance\nEstimator instance."
                    }
                },
                "transform": {
                    "Description": "Obtain latent positions from an adjacency matrix or matrix of out-of-sample vertices. For more details on transforming out-of-sample vertices, see Out-of-Sample (OOS) Embedding\nFor mathematical background, see [2].",
                    "Parameters": {
                        "X": "array-like or tuple, original shape or (n_oos_vertices, n_vertices).\nThe original fitted matrix ('graph' in fit) or new out-of-sample data. If X is the original fitted matrix, returns a matrix close to self.fit_transform(X).\n\nIf X is an out-of-sample matrix, n_oos_vertices is the number of new vertices, and n_vertices is the number of vertices in the original graph. If tuple, graph is directed and X[0] contains edges from out-of-sample vertices to in-sample vertices."
                    },
                    "Returns": {
                        "out": "np.ndarray OR length 2 tuple of np.ndarray\nArray of latent positions, shape (n_oos_vertices, n_components) or (n_vertices, n_components). Transforms the fitted matrix if it was passed in.\n\nIf X is an array or tuple containing adjacency vectors corresponding to new nodes, returns the estimated latent positions for the new out-of-sample adjacency vectors. If undirected, returns array. If directed, returns (X_out, X_in), where X_out contains latent positions corresponding to nodes with edges from out-of-sample vertices to in-sample vertices."
                    }
                }
            }
        },
        "Rubric": {
            "Note": "The singular value decomposition:\n\nis used to find an orthonormal basis for a matrix, which in our case is the Laplacian matrix of the graph. These basis vectors (in the matrices U or V) are ordered according to the amount of variance they explain in the original matrix. By selecting a subset of these basis vectors (through our choice of dimensionality reduction) we can find a lower dimensional space in which to represent the graph.",
            "References": [
                "Sussman, D.L., Tang M., Fishkind, D.E., Priebe, C.E. \"A Consistent Adjacency Spectral Embedding for Stochastic Blockmodel Graphs,\" Journal of the American Statistical Association, Vol. 107(499), 2012.",
                "Von Luxburg, Ulrike. \"A tutorial on spectral clustering,\" Statistics and computing, Vol. 17(4), pp. 395-416, 2007.",
                "Rohe, Karl, Sourav Chatterjee, and Bin Yu. \"Spectral clustering and the high-dimensional stochastic blockmodel,\" The Annals of Statistics, Vol. 39(4), pp. 1878-1915, 2011."
            ]
        }
    },
    {
        "Section_id": "node2vec_embed",
        "Description": "Generates a node2vec embedding from a given graph. Will follow the word2vec algorithm to create the embedding.",
        "Field List": {
            "Parameters": {
                "graph": "Union[nx.Graph, nx.DiGraph]\nA networkx graph or digraph. A multigraph should be turned into a non-multigraph so that the calling user properly handles the multi-edges (i.e. aggregate weights or take last edge weight). If the graph is unweighted, the weight of each edge will default to 1.",
                "num_walks": "int\nNumber of walks per source. Default is 10.",
                "walk_length": "int\nLength of walk per source. Default is 40.",
                "return_hyperparameter": "float\nReturn hyperparameter (p). Default is 1.0",
                "inout_hyperparameter": "float\nInout hyperparameter (q). Default is 1.0",
                "dimensions": "int\nDimensionality of the word vectors. Default is 128.",
                "window_size": "int\nMaximum distance between the current and predicted word within a sentence. Default is 2.",
                "workers": "int\nUse these many worker threads to train the model. Default is 8.",
                "iterations": "int\nNumber of epochs in stochastic gradient descent (SGD). Default is 3.",
                "interpolate_walk_lengths_by_node_degree": "bool\nUse a dynamic walk length that corresponds to each nodes degree. If the node is in the bottom 20 percentile, default to a walk length of 1. If it is in the top 10 percentile, use walk_length. If it is in the 20-80 percentiles, linearly interpolate between 1 and walk_length. This will reduce lower degree nodes from biasing your resulting embedding. If a low degree node has the same number of walks as a high degree node (which it will if this setting is not on), then the lower degree nodes will take a smaller breadth of random walks when compared to the high degree nodes. This will result in your lower degree walks dominating your higher degree nodes.",
                "random_seed": "int\nSeed to be used for reproducible results. Default is None and will produce a random output. Note that for a fully deterministically-reproducible run, you must also limit to a single worker thread (workers=1), to eliminate ordering jitter from OS thread scheduling. In addition the environment variable PYTHONHASHSEED must be set to control hash randomization."
            },
            "Returns": {
                "Tuple[np.array, List[Any]]": "A tuple containing a matrix, with each row index corresponding to the embedding for each node. The tuple also contains a vector containing the corresponding vertex labels for each row in the matrix. The matrix and vector are positionally correlated."
            }
        },
        "Rubric": {
            "Note": "The original reference implementation of node2vec comes from Aditya Grover from\nhttps://github.com/aditya-grover/node2vec/.\nFurther details on the Alias Method used in this functionality can be found at\nhttps://lips.cs.princeton.edu/the-alias-method-efficient-sampling-with-many-discrete-outcomes/\n",
            "References": [
                "Aditya Grover and Jure Leskovec \"node2vec: Scalable Feature Learning for Networks.\" Knowledge Discovery and Data Mining, 2016."
            ]
        }
    },
    {
        "Section_id": "OmnibusEmbed",
        "Description": "Omnibus embedding of arbitrary number of input graphs with matched vertex sets.\nGiven A1, A2, ..., An, a collection of (possibly weighted) adjacency matrices of a collection undirected graphs with matched vertices. Then the (mn x mn) omnibus matrix, M, has the subgraph where Mij = 1/2(Ai + Aj). The omnibus matrix is then embedded using adjacency spectral embedding.",
        "Field List": {
            "Parameters": {
                "n_components": "int or None, default = None\nDesired dimensionality of output data. If 'full', n_components must be <= min(X.shape). Otherwise, n_components must be < min(X.shape). If None, then optimal dimensions will be chosen by select_dimension() using n_elbows argument.",
                "n_elbows": "int, optional, default: 2\nIf n_components is None, then compute the optimal embedding dimension using select_dimension(). Otherwise, ignored.",
                "algorithm": "{'randomized' (default), 'full', 'truncated'}, optional\nSVD solver to use:\n\n'randomized'\nComputes randomized svd using sklearn.utils.extmath.randomized_svd()\n'full'\nComputes full svd using scipy.linalg.svd()\n'truncated'\nComputes truncated svd using scipy.sparse.linalg.svds()",
                "n_iter": "int, optional (default = 5)\nNumber of iterations for randomized SVD solver. Not used by 'full' or 'truncated'. The default is larger than the default in randomized_svd to handle sparse matrices that may have large slowly decaying spectrum.",
                "check_lcc": "bool , optional (defult = True)\nWhether to check if the average of all input graphs are connected. May result in non-optimal results if the average graph is unconnected. If True and average graph is unconnected, a UserWarning is thrown.",
                "diag_aug": "bool, optional (default = True)\nWhether to replace the main diagonal of each adjacency matrices with a vector corresponding to the degree (or sum of edge weights for a weighted network) before embedding.",
                "concat": "bool, optional (default = False)\nIf graph(s) are directed, whether to concatenate each graph's left and right (out and in) latent positions along axis 1.",
                "svd_seed": "int or None (default = None)\nOnly applicable for algorithm='randomized'; allows you to seed the randomized svd solver for deterministic, albeit pseudo-randomized behavior.",
                "lse": "bool, optional (default = False)\nWhether to construct the Omni matrix use the laplacian matrices of the graphs and embed the Omni matrix with LSE"
            },
            "Attributes": {
                "n_features_in_": "int\nNumber of features passed to the fit() method.",
                "latent_left_": "array, shape (n_samples, n_components)\nEstimated left latent positions of the graph.",
                "latent_right_": "array, shape (n_samples, n_components), or None\nOnly computed when the graph is directed, or adjacency matrix is assymetric. Estimated right latent positions of the graph. Otherwise, None.",
                "singular_values_": "array, shape (n_components)\nSingular values associated with the latent position matrices."
            },
            "Methods": {
                "__init__": {
                    "Parameters": {
                        "n_components": "int | None",
                        "n_elbows": "int | None",
                        "algorithm": "str",
                        "n_iter": "int",
                        "check_lcc": "bool",
                        "diag_aug": "bool",
                        "concat": "bool",
                        "svd_seed": "int | None",
                        "lse": "bool"
                    }
                },
                "fit": {
                    "Description": "Fit Omnibus model to input graphs",
                    "Parameters": {
                        "graphs": "list of array-like, scipy.sparse.csr_array, or networkx.Graph\nInput graphs to embed.",
                        "y": "Ignored"
                    },
                    "Returns": {
                        "self": "object\nReturns an instance of self."
                    }
                },
                "fit_transform": {
                    "Description": "Fit the model with graphs and apply the transformation.\nn_dimension is either automatically determined or based on user input.",
                    "Parameters": {
                        "graphs": "list of array-like, scipy.sparse.csr_array, or networkx.Graph\nInput graphs to embed."
                    },
                    "Returns": {
                        "out": "np.ndarray OR length 2 tuple of np.ndarray.\nIf undirected then returns single np.ndarray of latent position, shape(n_vertices, n_components). If directed, concat is True then concatenate latent matrices on axis 1, shape(n_vertices, 2*n_components). If directed, concat is False then tuple of the latent matrices. Each of shape (n_vertices, n_components)."
                    }
                },
                "get_metadata_routing": {
                    "Description": "Get metadata routing of this object.\nPlease check User Guide on how the routing mechanism works.",
                    "Returns": {
                        "routing": "MetadataRequest\nA MetadataRequest encapsulating routing information."
                    }
                },
                "get_params": {
                    "Description": "Get parameters for this estimator.",
                    "Parameters": {
                        "deep": "bool, default=True\nIf True, will return the parameters for this estimator and contained subobjects that are estimators."
                    },
                    "Returns": {
                        "params": "dict\nParameter names mapped to their values."
                    }
                },
                "set_fit_request": {
                    "Description": "Request metadata passed to the fit method.\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to fit if provided. The request is ignored if metadata is not provided.\nFalse: metadata is not requested and the meta-estimator will not pass it to fit.\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\nStr: metadata should be passed to the meta-estimator with this given alias instead of the original name.",
                    "Parameters": {
                        "graphs": "str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED\nMetadata routing for graphs parameter in fit."
                    },
                    "Returns": {
                        "self": "object\nThe updated object."
                    }
                },
                "set_params": {
                    "Description": "Set the parameters of this estimator.\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.",
                    "Parameters": {
                        "**params": "dict\nEstimator parameters."
                    },
                    "Returns": {
                        "self": "estimator instance\nEstimator instance."
                    }
                },
                "transform": {
                    "Description": "Obtain latent positions from an adjacency matrix or matrix of out-of-sample vertices. For more details on transforming out-of-sample vertices, see Out-of-Sample (OOS) Embedding\nFor mathematical background, see [2].",
                    "Parameters": {
                        "X": "array-like or tuple, original shape or (n_oos_vertices, n_vertices).\nThe original fitted matrix ('graph' in fit) or new out-of-sample data."
                    },
                    "Returns": {
                        "out": "np.ndarray OR length 2 tuple of np.ndarray\nArray of latent positions, shape (n_oos_vertices, n_components) or (n_vertices, n_components). Transforms the fitted matrix if it was passed in.\n\nIf X is an array or tuple containing adjacency vectors corresponding to new nodes, returns the estimated latent positions for the new out-of-sample adjacency vectors. If undirected, returns array. If directed, returns (X_out, X_in), where X_out contains latent positions corresponding to nodes with edges from out-of-sample vertices to in-sample vertices."
                    }
                }
            }
        },
        "Rubric": {
            "Note": "The singular value decomposition is used to find an orthonormal basis for a matrix, which in our case is the adjacency matrix of the graph. These basis vectors (in the matrices U or V) are ordered according to the amount of variance they explain in the original matrix. By selecting a subset of these basis vectors (through our choice of dimensionality reduction) we can find a lower dimensional space in which to represent the graph.",
            "References": [
                "Sussman, D.L., Tang M., Fishkind, D.E., Priebe, C.E. \"A Consistent Adjacency Spectral Embedding for Stochastic Blockmodel Graphs,\" Journal of the American Statistical Association, Vol. 107(499), 2012.",
                "Levin, K., Roosta-Khorasani, F., Mahoney, M. W., & Priebe, C. E. (2018). Out-of-sample extension of graph adjacency spectral embedding. PMLR: Proceedings of Machine Learning Research, 80, 2975-2984."
            ]
        }
    },
    {
        "Section_id": "MultipleASE",
        "Description": "Multiple Adjacency Spectral Embedding (MASE) embeds arbitrary number of input graphs with matched vertex sets.\nFor a population of undirected graphs, MASE assumes that the population of graphs is sampled from P(A) = \u2211_{k=1}^{K} \u03c0_k P(A|Z=k) where P(A|Z=k) = N(0, \u039b_k) and \u039b_k = \u03b1_k I + \u03b2_k J. Score matrices, \u039b_k, are allowed to vary for each graph, but are symmetric. All graphs share a common a latent position matrix X.\nFor a population of directed graphs, MASE assumes that the population is sampled from P(A) = \u2211_{k=1}^{K} \u03c0_k P(A|Z=k) where P(A|Z=k) = N(0, \u039b_k) and \u039b_k = \u03b1_k I + \u03b2_k J. In this case, score matrices \u039b_k can be assymetric and non-square, but all graphs still share a common latent position matrices X and Y.",
        "Field List": {
            "Parameters": {
                "n_components": "int or None, default = None\nDesired dimensionality of output data. If 'full', n_components must be <= min(X.shape). Otherwise, n_components must be < min(X.shape). If None, then optimal dimensions will be chosen by select_dimension() using n_elbows argument.",
                "n_elbows": "int, optional, default: 2\nIf n_components is None, then compute the optimal embedding dimension using select_dimension(). Otherwise, ignored.",
                "algorithm": "{'randomized' (default), 'full', 'truncated'}, optional\nSVD solver to use:\n\n'randomized'\nComputes randomized svd using sklearn.utils.extmath.randomized_svd()\n'full'\nComputes full svd using scipy.linalg.svd()\n'truncated'\nComputes truncated svd using scipy.sparse.linalg.svds()",
                "n_iter": "int, optional (default = 5)\nNumber of iterations for randomized SVD solver. Not used by 'full' or 'truncated'. The default is larger than the default in randomized_svd to handle sparse matrices that may have large slowly decaying spectrum.",
                "scaled": "bool, optional (default=True)\nWhether to scale individual eigenvectors with eigenvalues in first embedding stage.",
                "diag_aug": "bool, optional (default = True)\nWhether to replace the main diagonal of each adjacency matrices with a vector corresponding to the degree (or sum of edge weights for a weighted network) before embedding.",
                "concat": "bool, optional (default False)\nIf graph(s) are directed, whether to concatenate each graph's left and right (out and in) latent positions along axis 1.",
                "svd_seed": "int or None (default None)\nOnly applicable for algorithm='randomized'; allows you to seed the randomized svd solver for deterministic, albeit pseudo-randomized behavior."
            },
            "Attributes": {
                "n_graphs_": "int\nNumber of graphs",
                "n_vertices_": "int\nNumber of vertices in each graph",
                "latent_left_": "array, shape (n_samples, n_components)\nEstimated left latent positions of the graph.",
                "latent_right_": "array, shape (n_samples, n_components), or None\nEstimated right latent positions of the graph. Only computed when the an input graph is directed, or adjacency matrix is assymetric. Otherwise, None.",
                "scores_": "array, shape (n_samples, n_components, n_components)\nEstimated \u039b matrices for each input graph.",
                "singular_values_": "array, shape (n_components) OR length 2 tuple of arrays\nIf input graph is undirected, equal to the singular values of the concatenated adjacency spectral embeddings. If input graph is directed, singular_values_ is a tuple of length 2, where singular_values_[0] corresponds to the singular values of the concatenated left adjacency spectral embeddings, and singular_values_[1] corresponds to the singular values of the concatenated right adjacency spectral embeddings."
            },
            "Methods": {
                "__init__": {
                    "Parameters": {
                        "n_components": "int | None",
                        "n_elbows": "int",
                        "algorithm": "str",
                        "n_iter": "int",
                        "scaled": "bool",
                        "diag_aug": "bool",
                        "concat": "bool",
                        "svd_seed": "int | None"
                    }
                },
                "fit": {
                    "Description": "Fit MASE model to input graphs",
                    "Parameters": {
                        "graphs": "list of nx.Graph, ndarray or scipy.sparse.csr_array\nIf list of nx.Graph, each Graph must contain same number of nodes. If list of ndarray or csr_array, each array must have shape (n_vertices, n_vertices). If ndarray, then array must have shape (n_graphs, n_vertices, n_vertices).",
                        "y": "Ignored"
                    },
                    "Returns": {
                        "self": "object\nReturns an instance of self."
                    }
                },
                "fit_transform": {
                    "Description": "Fit the model with graphs and apply the embedding on graphs. n_components is either automatically determined or based on user input.",
                    "Parameters": {
                        "graphs": "list of nx.Graph, ndarray or scipy.sparse.csr_array\nIf list of nx.Graph, each Graph must contain same number of nodes. If list of ndarray or csr_array, each array must have shape (n_vertices, n_vertices). If ndarray, then array must have shape (n_graphs, n_vertices, n_vertices)."
                    },
                    "Returns": {
                        "out": "np.ndarray or length 2 tuple of np.ndarray.\nIf input graphs were symmetric shape (n_vertices, n_components). If graphs were directed and concat is False, returns tuple of two arrays (same shape as above). The first corresponds to the left latent positions, and the second to the right latent positions. When concat is True left and right (out and in"
                    }
                },
                "get_metadata_routing": {
                    "Description": "Get metadata routing of this object.\nPlease check User Guide on how the routing mechanism works.",
                    "Returns": {
                        "routing": "MetadataRequest\nA MetadataRequest encapsulating routing information."
                    }
                },
                "get_params": {
                    "Description": "Get parameters for this estimator.",
                    "Parameters": {
                        "deep": "bool, default=True\nIf True, will return the parameters for this estimator and contained subobjects that are estimators."
                    },
                    "Returns": {
                        "params": "dict\nParameter names mapped to their values."
                    }
                },
                "set_fit_request": {
                    "Description": "Request metadata passed to the fit method.\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to fit if provided. The request is ignored if metadata is not provided.\nFalse: metadata is not requested and the meta-estimator will not pass it to fit.\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\nStr: metadata should be passed to the meta-estimator with this given alias instead of the original name.",
                    "Parameters": {
                        "graphs": "str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED\nMetadata routing for graphs parameter in fit."
                    },
                    "Returns": {
                        "self": "object\nThe updated object."
                    }
                },
                "set_params": {
                    "Description": "Set the parameters of this estimator.\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.",
                    "Parameters": {
                        "**params": "dict\nEstimator parameters."
                    },
                    "Returns": {
                        "self": "estimator instance\nEstimator instance."
                    }
                },
                "transform": {
                    "Description": "Obtain latent positions from an adjacency matrix or matrix of out-of-sample vertices. For more details on transforming out-of-sample vertices, see Out-of-Sample (OOS) Embedding\nFor mathematical background, see [2].",
                    "Parameters": {
                        "X": "array-like or tuple, original shape or (n_oos_vertices, n_vertices).\nThe original fitted matrix ('graph' in fit) or new out-of-sample data. If X is the original fitted matrix, returns a matrix close to self.fit_transform(X).\n\nIf X is an out-of-sample matrix, n_oos_vertices is the number of new vertices, and n_vertices is the number of vertices in the original graph. If tuple, graph is directed and X[0] contains edges from out-of-sample vertices to in-sample vertices."
                    },
                    "Returns": {
                        "out": "np.ndarray OR length 2 tuple of np.ndarray\nArray of latent positions, shape (n_oos_vertices, n_components) or (n_vertices, n_components). Transforms the fitted matrix if it was passed in.\n\nIf X is an array or tuple containing adjacency vectors corresponding to new nodes, returns the estimated latent positions for the new out-of-sample adjacency vectors. If undirected, returns array. If directed, returns (X_out, X_in), where X_out contains latent positions corresponding to nodes with edges from out-of-sample vertices to in-sample vertices."
                    }
                }
            }
        },
        "Rubric": {
            "Note": "If the matrix was diagonally augmented (e.g., self.diag_aug was True), fit followed by transform will produce a slightly different matrix than fit_transform.\nTo get the original embedding, using fit_transform is recommended. In the directed case, if A is the original in-sample adjacency matrix, the tuple (A.T, A) will need to be passed to transform if you do not wish to use fit_transform.",
            "References": [
                "Sussman, D.L., Tang M., Fishkind, D.E., Priebe, C.E. \"A Consistent Adjacency Spectral Embedding for Stochastic Blockmodel Graphs,\" Journal of the American Statistical Association, Vol. 107(499), 2012.",
                "Levin, K., Roosta-Khorasani, F., Mahoney, M. W., & Priebe, C. E. (2018). Out-of-sample extension of graph adjacency spectral embedding. PMLR: Proceedings of Machine Learning Research, 80, 2975-2984"
            ]
        }
    },
    {
        "Section_id": "mug2vec",
        "Description": "Multigraphs-2-vectors (mug2vec).\n\nmug2vec is a sequence of three algorithms that learns a feature vector for each input graph.\n\nSteps:\n\n1. Pass to ranks - ranks all edge weights from smallest to largest valued edges then normalize by a constant.\n\n2. Omnibus embedding - jointly learns a low dimensional matrix representation for all graphs under the random dot product model (RDPG).\n\n3. Classical MDS (cMDS) - learns a feature vector for each graph by computing Euclidean distance between each pair of graph embeddings from omnibus embedding, followed by an eigen decomposition.",
        "Field List": {
            "Parameters": {
                "pass_to_ranks": "{'simple-nonzero' (default), 'simple-all', 'zero-boost'} string, or None\n'simple-nonzero'\nassigns ranks to all non-zero edges, settling ties using the average. Ranks are then scaled by \n\n'simple-all'\nassigns ranks to all non-zero edges, settling ties using the average. Ranks are then scaled by \n\n where n is the number of nodes\n\n'zero-boost'\npreserves the edge weight for all 0s, but ranks the other edges as if the ranks of all 0 edges has been assigned. If there are 10 0-valued edges, the lowest non-zero edge gets weight 11 / (number of possible edges). Ties settled by the average of the weight that those edges would have received. Number of possible edges is determined by the type of graph (loopless or looped, directed or undirected).\n\nNone\nNo pass to ranks applied.",
                "omnibus_components": "int or None, default = None\nDesired dimensionality of output data. If 'full', n_components must be <= min(X.shape). Otherwise, n_components must be < min(X.shape). If None, then optimal dimensions will be chosen by select_dimension() using n_elbows argument.",
                "omnibus_n_elbows": "int, optional, default: 2\nIf n_components is None, then compute the optimal embedding dimension using select_dimension(). Otherwise, ignored.",
                "cmds_components": "int or None, default = None\nDesired dimensionality of output data. If 'full', n_components must be <= min(X.shape). Otherwise, n_components must be < min(X.shape). If None, then optimal dimensions will be chosen by select_dimension() using n_elbows argument.",
                "cmds_n_elbows": "int, optional, default: 2\nIf n_components is None, then compute the optimal embedding dimension using select_dimension(). Otherwise, ignored.",
                "svd_seed": "int or None (default None)\nAllows you to seed the randomized svd solver used in the Omnibus embedding for deterministic, albeit pseudo-randomized behavior."
            },
            "Attributes": {
                "omnibus_n_components_": "int\nEquals the parameter n_components. If input n_components was None, then equals the optimal embedding dimension.",
                "cmds_n_components_": "int\nEquals the parameter n_components. If input n_components was None, then equals the optimal embedding dimension.",
                "embeddings_": "array, shape (n_components, n_features)\nEmbeddings from the pipeline. Each graph is a point in n_features dimensions."
            },
            "Methods": {
                "__init__": {
                    "Parameters": {
                        "pass_to_ranks": "typing_extensions.Literal[simple-nonzero, simple-all, zero-boost]",
                        "omnibus_components": "int | None",
                        "omnibus_n_elbows": "int",
                        "cmds_components": "int | None",
                        "cmds_n_elbows": "int",
                        "svd_seed": "int | None"
                    }
                },
                "fit": {
                    "Description": "Computes a vector for each graph.",
                    "Parameters": {
                        "graphs": "list of nx.Graph or ndarray, or ndarray\nIf list of nx.Graph, each Graph must contain same number of nodes. If list of ndarray, each array must have shape (n_vertices, n_vertices). If ndarray, then array must have shape (n_graphs, n_vertices, n_vertices).",
                        "y": "Ignored"
                    },
                    "Returns": {
                        "self": "mug2vec\nReturns an instance of self."
                    }
                },
                "fit_transform": {
                    "Description": "Computes a vector for each graph.",
                    "Parameters": {
                        "graphs": "list of nx.Graph or ndarray, or ndarray\nIf list of nx.Graph, each Graph must contain same number of nodes. If list of ndarray, each array must have shape (n_vertices, n_vertices). If ndarray, then array must have shape (n_graphs, n_vertices, n_vertices).",
                        "y": "Ignored"
                    },
                    "Returns": {
                        "embedding": "ndarray\nembeddings generated by fit."
                    }
                },
                "get_metadata_routing": {
                    "Description": "Get metadata routing of this object.\nPlease check User Guide on how the routing mechanism works.",
                    "Returns": {
                        "routing": "MetadataRequest\nA MetadataRequest encapsulating routing information."
                    }
                },
                "get_params": {
                    "Description": "Get parameters for this estimator.",
                    "Parameters": {
                        "deep": "bool, default=True\nIf True, will return the parameters for this estimator and contained subobjects that are estimators."
                    },
                    "Returns": {
                        "params": "dict\nParameter names mapped to their values."
                    }
                },
                "set_fit_request": {
                    "Description": "Request metadata passed to the fit method.\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\nThe options for each parameter are:\n\nTrue: metadata is requested",
                    "Parameters": {
                        "graphs": "str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED\nMetadata routing for graphs parameter in fit."
                    },
                    "Returns": {
                        "self": "object\nThe updated object."
                    }
                },
                "set_params": {
                    "Description": "Set the parameters of this estimator.\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.",
                    "Parameters": {
                        "**params": "dict\nEstimator parameters."
                    },
                    "Returns": {
                        "self": "estimator instance\nEstimator instance."
                    }
                }
            }
        }
    },
    {
        "Section_id": "ClassicalMDS",
        "Description": "Classical multidimensional scaling (cMDS).\n\ncMDS seeks a low-dimensional representation of the data in which the distances respect well the distances in the original high-dimensional space.",
        "Field List": {
            "Parameters": {
                "n_components": "int, or None (default=None)\nNumber of components to keep. If None, then it will run select_dimension() to find the optimal embedding dimension.",
                "n_elbows": "int, or None (default=2)\nIf n_components is None, then compute the optimal embedding dimension using select_dimension(). Otherwise, ignored.",
                "dissimilarity": "{'euclidean', 'precomputed'}, optional, default: 'euclidean'\nDissimilarity measure to use:\n\n'euclidean'\nPairwise Euclidean distances between points in the dataset.\n\n'precomputed'\nPre-computed dissimilarities are passed directly to fit() and fit_transform()."
            },
            "Attributes": {
                "n_components": "int\nEquals the parameter n_components. If input n_components was None, then equals the optimal embedding dimension.",
                "n_features_in_": "int\nNumber of features passed to the fit() method.",
                "components_": "array, shape (n_components, n_features)\nPrincipal axes in feature space.",
                "singular_values_": "array, shape (n_components,)\nThe singular values corresponding to each of the selected components.",
                "dissimilarity_matrix_": "array, shape (n_features, n_features)\nDissimilarity matrix",
                "svd_seed_": "int or None (default None)\nOnly applicable for n_components!=1; allows you to seed the randomized svd solver for deterministic, albeit pseudo-randomized behavior."
            },
            "Methods": {
                "__init__": {
                    "Parameters": {
                        "n_components": "int | None",
                        "n_elbows": "int | None",
                        "dissimilarity": "typing_extensions.Literal[euclidean, precomputed]",
                        "svd_seed": "int | None"
                    }
                },
                "fit": {
                    "Description": "Fit the model with X.",
                    "Parameters": {
                        "X": "array_like\nIf dissimilarity=='precomputed', the input should be the dissimilarity matrix with shape (n_samples, n_samples). If dissimilarity=='euclidean', then the input should be 2d-array with shape (n_samples, n_features) or a 3d-array with shape (n_samples, n_features_1, n_features_2)."
                    },
                    "Returns": {
                        "self": "object\nReturns an instance of self."
                    }
                },
                "fit_transform": {
                    "Description": "Fit the data from X, and returns the embedded coordinates.",
                    "Parameters": {
                        "X": "nd-array\nIf dissimilarity=='precomputed', the input should be the dissimilarity matrix with shape (n_samples, n_samples). If dissimilarity=='euclidean', then the input should be array with shape (n_samples, n_features) or a nd-array with shape (n_samples, n_features_1, n_features_2, ..., n_features_d). First axis of nd-array must be n_samples."
                    },
                    "Returns": {
                        "X_new": "array-like, shape (n_samples, n_components)\nEmbedded input."
                    }
                },
                "get_metadata_routing": {
                    "Description": "Get metadata routing of this object.\nPlease check User Guide on how the routing mechanism works.",
                    "Returns": {
                        "routing": "MetadataRequest\nA MetadataRequest encapsulating routing information."
                    }
                },
                "get_params": {
                    "Description": "Get parameters for this estimator.",
                    "Parameters": {
                        "deep": "bool, default=True\nIf True, will return the parameters for this estimator and contained subobjects that are estimators."
                    },
                    "Returns": {
                        "params": "dict\nParameter names mapped to their values."
                    }
                },
                "set_params": {
                    "Description": "Set the parameters of this estimator.\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.",
                    "Parameters": {
                        "**params": "dict\nEstimator parameters."
                    },
                    "Returns": {
                        "self": "estimator instance\nEstimator instance."
                    }
                }
            }
        },
        "Rubric": {
            "References": [
                "Wickelmaier, Florian. \"An introduction to MDS.\" Sound Quality Research Unit, Aalborg University, Denmark 46.5 (2003)."
            ]
        }
    },
    {
        "Section_id": "density_test",
        "Description": "Compares two networks by testing whether the global connection probabilities (densites) for the two networks are equal under an Erdos-Renyi model assumption.",
        "Field List": {
            "Parameters": {
                "A1": "np.array, int\nThe adjacency matrix for network 1. Will be treated as a binary network, regardless of whether it was weighted.",
                "A2": "np.array, int\nAdjacency matrix for network 2. Will be treated as a binary network, regardless of whether it was weighted.",
                "method": "string, optional, default=\"fisher\"\nSpecifies the statistical test to be used. The default option is \"fisher\", which uses Fisher's exact test, but the user may also enter \"chi2\" to use a chi-squared test."
            },
            "Returns": {
                "DensityTestResult": "namedtuple\nThis named tuple returns the following data:\n\nstat: float\nThe statistic for the test specified by method.\npvalue: float\nThe p-value for the test specified by method.\nmisc: dict\nDictionary containing a number of computed statistics for the network comparison performed:\n\n\"probability1\", float\nThe probability of an edge (density) in network 1 (\").\n\n\"probability2\", float\nThe probability of an edge (density) in network 2 (\").\n\n\"observed1\", pd.DataFrame\nThe total number of edge connections for network 1.\n\n\"observed2\", pd.DataFrame\nThe total number of edge connections for network 2.\n\n\"possible1\", pd.DataFrame\nThe total number of possible edges for network 1.\n\n\"possible2\", pd.DataFrame\nThe total number of possible edges for network 1."
            }
        },
        "Rubric": {
            "Note": "Under the Erdos-Renyi model, edges are generated independently with probability is also known as the network density. This function tests whether the probability of an edge in network 1 is significantly different from that in network 2, by assuming that both networks came from an Erdos-Renyi model. In other words, the null hypothesis is\n\nAnd the alternative hypothesis is\n\nThis test makes several assumptions about the data and test (which could easily be loosened in future versions):\n\nWe assume that the networks are directed. If the networks are undirected (and the adjacency matrices are thus symmetric), then edges would be counted twice, which would lead to an incorrect calculation of the edge probability. We believe passing in the upper or lower triangle of the adjacency matrix would solve this, but this has not been tested.\n\nWe assume that the networks are loopless, that is we do not consider the probability of an edge existing between a node and itself. This can be weakened and made an option in future versions.\n\nWe only implement the alternative hypothesis of \"not equals\" (two-sided); future versions could implement the one-sided alternative hypotheses.",
            "References": [
                "Pedigo, B.D., Powell, M., Bridgeford, E.W., Winding, M., Priebe, C.E., Vogelstein, J.T. \"Generative network modeling reveals quantitative definitions of bilateral symmetry exhibited by a whole insect brain connectome,\" eLife (2023): e83739."
            ]
        }
    },
    {
        "Section_id": "group_connection_test",
        "Description": "Compares two networks by testing whether edge probabilities between groups are significantly different for the two networks under a stochastic block model assumption.",
        "Field List": {
            "Parameters": {
                "A1": "np.array, shape(n1,n1)\nThe adjacency matrix for network 1. Will be treated as a binary network, regardless of whether it was weighted.",
                "A2": "np.array, shape(n2,n2)\nThe adjacency matrix for network 2. Will be treated as a binary network, regardless of whether it was weighted.",
                "labels1": "array-like, shape (n1,)\nThe group labels for each node in network 1.",
                "labels2": "array-like, shape (n2,)\nThe group labels for each node in network 2.",
                "density_adjustment": "boolean, optional\nWhether to perform a density adjustment procedure. If True, will test the null hypothesis that the group-to-group connection probabilities of one network are a constant multiple of those of the other network. Otherwise, no density adjustment will be performed.",
                "method": "str, optional\nSpecifies the statistical test to be performed to compare each of the group-to-group connection probabilities. By default, this performs the score test (essentially equivalent to chi-squared test when density_adjustment=False), but the user may also enter \"chi2\" to perform the chi-squared test, or \"fisher\" for Fisher's exact test.",
                "combine_method": "str, optional\nSpecifies the method for combining p-values (see Notes and [1] for more details). Default is \"tippett\" for Tippett's method (recommended), but the user can also enter any other method supported by scipy.stats.combine_pvalues().",
                "correct_method": "str, optional\nSpecifies the method for correcting for multiple comparisons. Default value is \"holm\" to use the Holm-Bonferroni correction method, but many others are possible (see statsmodels.stats.multitest.multipletests() for more details and options).",
                "alpha": "float, optional\nThe significance threshold. By default, this is the conventional value of 0.05 but any value on the interval [0,1] can be entered. This only affects the results in misc['rejections']."
            },
            "Returns": {
                "GroupTestResult": "namedtuple\nA tuple containing the following data:\n\nstat: float\nThe statistic computed by the method chosen for combining p-values (see combine_method).\npvalue: float\nThe p-value for the overall network-to-network comparison using under a stochastic block model assumption. Note that this is the p-value for the comparison of the entire group-to-group connection matrices (i.e., B1 and B2).\nmisc: dict\nA dictionary containing a number of statistics relating to the individual group-to-group connection comparisons.\n\n\"uncorrected_pvalues\", pd.DataFrame\nThe p-values for each group-to-group connection comparison, before correction for multiple comparisons.\n\n\"stats\", pd.DataFrame\nThe test statistics for each of the group-to-group comparisons, depending on method.\n\n\"probabilities1\", pd.DataFrame\nThis contains the B_hat values computed in fit_sbm above for network 1, i.e. the hypothesized group connection density for each group-to-group connection for network 1.\n\n\"probabilities2\", pd.DataFrame\nSame as above, but for network 2.\n\n\"observed1\", pd.DataFrame\nThe total number of observed group-to-group edge connections for network 1.\n\n\"observed2\", pd.DataFrame\nSame as above, but for network 2.\n\n\"possible1\", pd.DataFrame\nThe total number of possible edges for each group-to-group pair in network 1.\n\n\"possible2\", pd.DataFrame\nSame as above, but for network 2.\n\n\"group_counts1\", pd.Series\nContains total number of nodes corresponding to each group label for network 1.\n\n\"group_counts2\", pd.Series\nSame as above, for network 2\n\n\"null_ratio\", float\nIf the \"density adjustment\" parameter is set to \"true\", this variable contains the null hypothesis for the quotient of odds ratios for the group-to-group connection densities for the two networks. In other words, it contains the hypothesized factor by which network 1 is \"more dense\" or \"less dense\" than network 2. If \"density adjustment\" is set to \"false\", this simply returns a value of 1.0.\n\n\"n_tests\", int\nThis variable contains the number of group-to-group comparisons performed by the function.\n\n\"rejections\", pd.DataFrame\nContains a square matrix of boolean variables. The side length of the matrix is equal to the number of distinct group labels. An entry in the matrix is \"true\" if the null hypothesis, i.e. that the group-to-group connection density corresponding to the row and column of the matrix is equal for both networks (with or without a density adjustment factor), is rejected. In simpler terms, an entry is only \"true\" if the group-to-group density is statistically different between the two networks for the connection from the group corresponding to the row of the matrix to the"
            }
        },
        "Rubric": {
            "Note": "This function requires the group labels in both networks to be known and to have the same categories; although the exact number of nodes belonging to each group does not need to be identical. Note that using group labels inferred from the data may yield an invalid test.\n\nThis function also permits the user to test whether one network's group connection probabilities are a constant multiple of the other's (see density_adjustment parameter).",
            "References": [
                "Pedigo, B.D., Powell, M., Bridgeford, E.W., Winding, M., Priebe, C.E., Vogelstein, J.T. \"Generative network modeling reveals quantitative definitions of bilateral symmetry exhibited by a whole insect brain connectome,\" eLife (2023): e83739."
            ]
        }
    },
    {
        "Section_id": "latent_position_test",
        "Description": "Two-sample hypothesis test for the problem of determining whether two random dot product graphs have the same latent positions.\n\nThis test assumes that the two input graphs are vertex aligned, that is, there is a known mapping between vertices in the two graphs and the input graphs have their vertices sorted in the same order. Currently, the function only supports undirected graphs. \n\nRead more in the Latent Position Two-Graph Testing Tutorial",
        "Field List": {
            "Parameters": {
                "A1": "ndarray | csr_array | Graph\nThe first graph to run a hypothesis test on.",
                "A2": "ndarray | csr_array | Graph\nThe second graph to run a hypothesis test on.",
                "embedding": "typing_extensions.Literal[ase, omnibus]\nString describing the embedding method to use:\n\n'ase'\nEmbed each graph separately using adjacency spectral embedding and use Procrustes to align the embeddings.\n\n'omnibus'\nEmbed all graphs simultaneously using omnibus embedding.",
                "n_components": "int | None\nNumber of embedding dimensions. If None, the optimal embedding dimensions are found by the Zhu and Godsi algorithm.",
                "test_case": "typing_extensions.Literal[rotation, scalar-rotation, diagonal-rotation]\ndescribes the exact form of the hypothesis to test when using 'ase' or 'lse' as an embedding method. Ignored if using 'omnibus'. Given two latent positions, \n and \n, and an orthogonal rotation matrix \n that minimizes \n:\n\n'rotation'\n'scalar-rotation'\nwhere \n is a scalar, \n\n'diagonal-rotation'\nwhere \n is an arbitrary diagonal matrix",
                "n_bootstraps": "int\nNumber of bootstrap simulations to run to generate the null distribution",
                "workers": "int\nNumber of workers to use. If more than 1, parallelizes the bootstrap simulations. Supply -1 to use all cores available."
            },
            "Returns": {
                "stat": "float\nThe observed difference between the embedded positions of the two input graphs after an alignment (the type of alignment depends on test_case)",
                "pvalue": "float\nThe overall p value from the test; this is the max of 'p_value_1' and 'p_value_2'",
                "misc_dict": "dictionary\nA collection of other statistics obtained from the latent position test\n\n'p_value_1', 'p_value_2'float\nThe p value estimate from the null distributions from sample 1 and sample 2\n\n'null_distribution_1', 'null_distribution_2'np.ndarray (n_bootstraps,)\nThe distribution of T statistics generated under the null, using the first and and second input graph, respectively. The latent positions of each sample graph are used independently to sample random dot product graphs, so two null distributions are generated"
            }
        },
        "Rubric": {
            "References": [
                "Tang, M., A. Athreya, D. Sussman, V. Lyzinski, Y. Park, Priebe, C.E. \"A Semiparametric Two-Sample Hypothesis Testing Problem for Random Graphs\" Journal of Computational and Graphical Statistics, Vol. 26(2), 2017"
            ]
        }
    },
    {
        "Section_id": "latent_distribution_test",
        "Description": "Two-sample hypothesis test for the problem of determining whether two random dot product graphs have the same distributions of latent positions.\n\nThis test can operate on two graphs where there is no known matching between the vertices of the two graphs, or even when the number of vertices is different. Currently, testing is only supported for undirected graphs.\n\nRead more in the Latent Distribution Two-Graph Testing Tutorial",
        "Field List": {
            "Parameters": {
                "A1": "variable (see description of 'input_graph')\nThe two graphs, or their embeddings to run a hypothesis test on. Expected variable type and shape depends on input_graph attribute",
                "A2": "variable (see description of 'input_graph')\nThe two graphs, or their embeddings to run a hypothesis test on. Expected variable type and shape depends on input_graph attribute",
                "test": "str (default=\"dcorr\")\nBackend hypothesis test to use, one of [\"cca\", \"dcorr\", \"hhg\", \"rv\", \"hsic\", \"mgc\"]. These tests are typically used for independence testing, but here they are used for a two-sample hypothesis test on the latent positions of two graphs. See hyppo.ksample.KSample for more information.",
                "metric": "str or function (default=\"euclidean\")\nDistance or a kernel metric to use, either a callable or a valid string. Kernel metrics (e.g. \"gaussian\") must be used with kernel-based HSIC test and distances (e.g. \"euclidean\") with all other tests. If a callable, then it should behave similarly to either sklearn.metrics.pairwise_distances() or to sklearn.metrics.pairwise.pairwise_kernels().\n\nValid strings for distance metric are, as defined in sklearn.metrics.pairwise_distances(),\n\nFrom scikit-learn: [\"euclidean\", \"cityblock\", \"cosine\", \"l1\", \"l2\", \"manhattan\"].\n\nFrom scipy.spatial.distance: [\"braycurtis\", \"canberra\", \"chebyshev\", \"correlation\", \"dice\", \"hamming\", \"jaccard\", \"kulsinski\", \"mahalanobis\", \"minkowski\", \"rogerstanimoto\", \"russellrao\", \"seuclidean\", \"sokalmichener\", \"sokalsneath\", \"sqeuclidean\", \"yule\"] See the documentation for scipy.spatial.distance for details on these metrics.\n\nValid strings for kernel metric are, as defined in sklearn.metrics.pairwise.pairwise_kernels(),\n\n[\"additive_chi2\", \"chi2\", \"linear\", \"poly\", \"polynomial\", \"rbf\", \"laplacian\", \"sigmoid\", \"cosine\"]\n\nNote \"rbf\" and \"gaussian\" are the same metric, which will use an adaptively selected bandwidth.",
                "n_components": "int or None (default=None)\nNumber of embedding dimensions. If None, the optimal embedding dimensions are found by the Zhu and Godsi algorithm. See select_svd() for more information. This argument is ignored if input_graph is False.",
                "n_bootstraps": "int (default=200)\nNumber of bootstrap iterations for the backend hypothesis test. See hyppo.ksample.KSample for more information.",
                "random_state": "{None, int, ~np.random.RandomState, ~np.random.Generator}\nThis parameter defines the object to use for drawing random variates. If random_state is None the ~np.random.RandomState singleton is used. If random_state is an int, a new RandomState instance is used, seeded with random_state. If random_state is already a RandomState or Generator instance, then that object is used. Default is None.",
                "workers": "int or None (default=None)\nNumber of workers to use. If more than 1, parallelizes the code. Supply -1 to use all cores available. None is a marker for 'unset' that will be interpreted as workers=1 (sequential execution) unless the call is performed under a Joblib parallel_backend context manager that sets another value for workers. See :class:joblib.Parallel for more details.",
                "size_correction": "bool (default=True)\nIgnored when the two graphs have the same number of vertices. The test degrades in validity as the number of vertices of the two graphs diverge from each other, unless a correction is performed.\n\nTrue\nWhenever the two graphs have different numbers of vertices, estimates the plug-in estimator for the variance and uses it to correct the embedding of the larger graph.\n\nFalse\nDoes not perform any modifications (not recommended).",
                "pooled": "bool (default=False)\nIgnored whenever the two graphs have the same number of vertices or size_correction is set to False. In order to correct the adjacency spectral embedding used in the test, it is needed to estimate the variance for each of the latent position estimates in the larger graph, which requires to compute different sample moments. These moments can be computed either over the larger graph (False), or over both graphs (True). Setting it to True should not affect the behavior of the test under the null hypothesis, but it is not clear whether it has more power or less power under which alternatives. Generally not recomended, as it is untested and included for experimental purposes.",
                "align_type": "str, {'sign_flips' (default), 'seedless_procrustes'} or None\nRandom dot product graphs have an inherent non-identifiability, associated with their latent positions. Thus, two embeddings of different graphs may not be orthogonally aligned. Without this accounted for, two embeddings of different graphs may appear",
                "align_kws": "dict\nKeyword arguments for the aligner of choice, either graspologic.align.SignFlips or graspologic.align.SeedlessProcrustes, depending on the align_type. See respective classes for more information.",
                "input_graph": "bool (default=True)\nFlag whether to expect two full graphs, or the embeddings.\n\nTrue\nThis function expects graphs, either as NetworkX graph objects or as adjacency matrices, provided as ndarrays of size (n, n) and (m, m). They will be embedded using adjacency spectral embeddings.\n\nFalse\nThis function expects adjacency spectral embeddings of the graphs, they must be ndarrays of size (n, d) and (m, d), where d must be same. n_components attribute is ignored in this case."
            }
        },
        "Rubric": {
            "References": [
                "Tang, M., Athreya, A., Sussman, D. L., Lyzinski, V., & Priebe, C. E. (2017). \"A nonparametric two-sample hypothesis testing problem for random graphs.\" Bernoulli, 23(3), 1599-1630.",
                "Panda, S., Palaniappan, S., Xiong, J., Bridgeford, E., Mehta, R., Shen, C., & Vogelstein, J. (2019). \"hyppo: A Comprehensive Multivariate Hypothesis Testing Python Package.\" arXiv:1907.02088.",
                "Alyakin, A. A., Agterberg, J., Helm, H. S., Priebe, C. E. (2020). \"Correcting a Nonparametric Two-sample Graph Hypothesis Test for Graphs with Different Numbers of Vertices\" arXiv:2008.09434"
            ]
        }
    },
    {
        "Section_id": "NodePosition",
        "Description": "Contains the node id, 2d coordinates, size, and community id for a node.\n\nCreate new instance of NodePosition(node_id, x, y, size, community)",
        "Field List": {
            "Parameters": {
                "node_id": "str",
                "x": "float",
                "y": "float",
                "size": "float",
                "community": "int"
            },
            "Methods": {
                "static__new__": {
                    "Description": "Create new instance of NodePosition(node_id, x, y, size, community)",
                    "Parameters": {
                        "node_id": "str",
                        "x": "float",
                        "y": "float",
                        "size": "float",
                        "community": "int"
                    }
                },
                "count": {
                    "Description": "Return number of occurrences of value."
                },
                "index": {
                    "Description": "Return first index of value."
                }
            }
        }
    },
    {
        "Section_id": "layout_tsne",
        "Description": "Automatic graph layout generation by creating a generalized node2vec embedding, then using t-SNE for dimensionality reduction to 2d space.\n\nBy default, this function automatically attempts to prune each graph to a maximum of 10,000,000 edges by removing the lowest weight edges. This pruning is approximate and will leave your graph with at most max_edges, but is not guaranteed to be precisely max_edges.\n\nIn addition to pruning edges by weight, this function also only operates over the largest connected component in the graph.\n\nAfter dimensionality reduction, sizes are generated for each node based upon their degree centrality, and these sizes and positions are further refined by an overlap removal phase. Lastly, a global partitioning algorithm (graspologic.partition.leiden()) is executed for the largest connected component and the partition ID is included with each node position.",
        "Field List": {
            "Parameters": {
                "graph": "networkx.Graph\nThe graph to generate a layout for. This graph may have edges pruned if the count is too high and only the largest connected component will be used to automatically generate a layout.",
                "perplexity": "int\nThe perplexity is related to the number of nearest neighbors that is used in other manifold learning algorithms. Larger datasets usually require a larger perplexity. Consider selecting a value between 4 and 100. Different values can result in significantly different results.",
                "n_iter": "int\nMaximum number of iterations for the optimization. We have found in practice that larger graphs require more iterations. We hope to eventually have more guidance on the number of iterations based on the size of the graph and the density of the edge connections.",
                "max_edges": "int\nThe maximum number of edges to use when generating the embedding. Default is 10000000. The edges with the lowest weights will be pruned until at most max_edges exist. Warning: this pruning is approximate and more edges than are necessary may be pruned. Running in 32 bit environment you will most likely need to reduce this number or you will out of memory.",
                "weight_attribute": "str\nThe edge dictionary data attribute that holds the weight. Default is weight. Note that the graph must be fully weighted or unweighted.",
                "random_seed": "int | None\nSeed to be used for reproducible results. Default is None and will produce a new random state. Specifying a random state will provide consistent results between runs. In addition the environment variable PYTHONHASHSEED must be set to control hash randomization.",
                "adjust_overlaps": "bool\nMake room for overlapping nodes while maintaining some semblance of the 2d spatial characteristics of each node. Default is True"
            },
            "Returns": {
                "Tuple[nx.Graph, List[NodePosition]]": "The largest connected component and a list of NodePositions for each node in the largest connected component. The NodePosition object contains: - node_id - x coordinate - y coordinate - size - community"
            }
        },
        "Rubric": {
            "References": [
                "van der Maaten, L.J.P.; Hinton, G.E. Visualizing High-Dimensional Data Using t-SNE. Journal of Machine Learning Research 9:2579-2605, 2008."
            ]
        }
    },
    {
        "Section_id": "layout_umap",
        "Description": "Automatic graph layout generation by creating a generalized node2vec embedding, then using UMAP for dimensionality reduction to 2d space.\n\nBy default, this function automatically attempts to prune each graph to a maximum of 10,000,000 edges by removing the lowest weight edges. This pruning is approximate and will leave your graph with at most max_edges, but is not guaranteed to be precisely max_edges.\n\nIn addition to pruning edges by weight, this function also only operates over the largest connected component in the graph.\n\nAfter dimensionality reduction, sizes are generated for each node based upon their degree centrality, and these sizes and positions are further refined by an overlap removal phase. Lastly, a global partitioning algorithm (graspologic.partition.leiden()) is executed for the largest connected component and the partition ID is included with each node position.",
        "Field List": {
            "Parameters": {
                "graph": "Graph\nThe graph to generate a layout for. This graph may have edges pruned if the count is too high and only the largest connected component will be used to automatically generate a layout.",
                "min_dist": "float\nThe effective minimum distance between embedded points. Default is 0.75. Smaller values will result in a more clustered/clumped embedding where nearby points on the manifold are drawn closer together, while larger values will result on a more even dispersal of points. The value should be set relative to the spread value, which determines the scale at which embedded points will be spread out.",
                "n_neighbors": "int\nThe size of local neighborhood (in terms of number of neighboring sample points) used for manifold approximation. Default is 25. Larger values result in more global views of the manifold, while smaller values result in more local data being preserved.",
                "max_edges": "int\nThe maximum number of edges to use when generating the embedding. Default is 10000000. The edges with the lowest weights will be pruned until at most max_edges exist. Warning: this pruning is approximate and more edges than are necessary may be pruned. Running in 32 bit environment you will most likely need to reduce this number or you will out of memory.",
                "weight_attribute": "str\nThe edge dictionary data attribute that holds the weight. Default is weight. Note that the graph must be fully weighted or unweighted.",
                "random_seed": "int | None\nSeed to be used for reproducible results. Default is None and will produce random results.",
                "adjust_overlaps": "bool\nMake room for overlapping nodes while maintaining some semblance of the 2d spatial characteristics of each node. Default is True"
            },
            "Returns": {
                "Tuple[nx.Graph, List[NodePosition]]": "The largest connected component and a list of NodePositions for each node in the largest connected component. The NodePosition object contains: - node_id - x coordinate - y coordinate - size - community"
            }
        },
        "Rubric": {
            "References": [
                "McInnes, L, Healy, J, UMAP: Uniform Manifold Approximation and Projection for Dimension Reduction, ArXiv e-prints 1802.03426, 2018",
                "B\u00f6hm, Jan Niklas; Berens, Philipp; Kobak, Dmitry. A Unifying Perspective on Neighbor Embeddings along the Attraction-Repulsion Spectrum. ArXiv e-prints 2007.08902v1, 17 Jul 2020."
            ]
        }
    },
    {
        "Section_id": "categorical_colors",
        "Description": "Generates a node -> color mapping based on the partitions provided.\n\nThe partitions are ordered by population descending, and a series of perceptually balanced, complementary colors are chosen in sequence.\n\nIf a theme_path is provided, it must contain a path to a json file generated by Thematic, otherwise it will use the theme packaged with this library.\n\nColors will be different when selecting for a light background vs. a dark background, using the principles defined by Thematic.\n\nIf more partitions than colors available (100) are selected, the colors will be cycled through again.",
        "Field List": {
            "Parameters": {
                "partitions": "Dict[Any, int]\nA dictionary of node ids to partition ids.",
                "light_background": "bool\nDefault is True. Colors selected for a light background will be slightly different in hue and saturation to complement a light or dark background.",
                "theme_path": "Optional[str]\nA color scheme is provided with graspologic, but if you wish to use your own you can generate one with Thematic and provide the path to it to override the bundled theme."
            },
            "Returns": {
                "Dict[Any, str]": "Returns a dictionary of node id -> color based on the partitions provided."
            }
        }
    },
    {
        "Section_id": "sequential_colors",
        "Description": "Generates a node -> color mapping where a color is chosen for the value as it maps the value range into the sequential color space.\n\nIf a theme_path is provided, it must contain a path to a json file generated by Thematic, otherwise it will use the theme packaged with this library.\n\nColors will be different when selecting for a light background vs. a dark background, using the principles defined by Thematic.\n\nIf more partitions than colors available (100) are selected, the colors will be cycled through again.",
        "Field List": {
            "Parameters": {
                "node_and_value": "Dict[Any, float]\nA node to value mapping. The value is a single entry in a continuous range, which is then mapped into the sequential color space.",
                "light_background": "bool\nDefault is True. Colors selected for a light background will be slightly different in hue and saturation to complement a light or dark background.",
                "use_log_scale": "bool\nDefault is False.",
                "theme_path": "Optional[str]\nA color scheme is provided with graspologic, but if you wish to use your own you can generate one with Thematic and provide the path to it to override the bundled theme."
            },
            "Returns": {
                "Dict[Any, str]": "Returns a dictionary of node id -> color based on the original value provided for the node as it relates to the total range of all values."
            }
        }
    },
    {
        "Section_id": "save_graph",
        "Description": "Renders a graph to file.\n\nEdges will be displayed with the same color as the source node.",
        "Field List": {
            "Parameters": {
                "output_path": "str\nThe output path to write the rendered graph to. Suggested file extension is .png.",
                "graph": "nx.Graph\nThe graph to be displayed. If the networkx Graph contains only nodes, no edges will be displayed.",
                "positions": "List[graspologic.layouts.NodePosition]\nThe positionsfor every node in the graph.",
                "node_colors": "Dict[Any, str]\nA mapping of node id to colors. Must contain an entry for every node in the graph.",
                "vertex_line_width": "float\nLine width of vertex outline. Default is 0.01.",
                "vertex_alpha": "float\nAlpha (transparency) of vertices in visualization. Default is 0.55.",
                "edge_line_width": "float\nLine width of edge. Default is 0.5.",
                "edge_alpha": "float\nAlpha (transparency) of edges in visualization. Default is 0.02.",
                "figure_width": "float\nWidth of figure. Default is 15.0.",
                "figure_height": "float\nHeight of figure. Default is 15.0.",
                "light_background": "bool\nLight background or dark background. Default is True.",
                "vertex_shape": "str\nMatplotlib Marker for the vertex shape. See https://matplotlib.org/api/markers_api.html for a list of allowed values . Default is o (i.e: a circle)",
                "arrows": "bool\nFor directed graphs, if True, draw arrow heads. Default is False",
                "dpi": "int\nDots per inch of the figure. Default is 100."
            },
            "Returns": {
                "None": "None"
            }
        }
    },
    {
        "Section_id": "show_graph",
        "Description": "Renders and displays a graph.\n\nAttempts to display it via the platform-specific display library such as TkInter\n\nEdges will be displayed with the same color as the source node.",
        "Field List": {
            "Parameters": {
                "graph": "nx.Graph\nThe graph to be displayed. If the networkx Graph contains only nodes, no edges will be displayed.",
                "positions": "List[graspologic.layouts.NodePosition]\nThe positionsfor every node in the graph.",
                "node_colors": "Dict[Any, str]\nA mapping of node id to colors. Must contain an entry for every node in the graph.",
                "vertex_line_width": "float\nLine width of vertex outline. Default is 0.01.",
                "vertex_alpha": "float\nAlpha (transparency) of vertices in visualization. Default is 0.55.",
                "edge_line_width": "float\nLine width of edge. Default is 0.5.",
                "edge_alpha": "float\nAlpha (transparency) of edges in visualization. Default is 0.02.",
                "figure_width": "float\nWidth of figure. Default is 15.0.",
                "figure_height": "float\nHeight of figure. Default is 15.0.",
                "light_background": "bool\nLight background or dark background. Default is True.",
                "vertex_shape": "str\nMatplotlib Marker for the vertex shape. See https://matplotlib.org/api/markers_api.html for a list of allowed values . Default is o (i.e: a circle)",
                "arrows": "bool\nFor directed graphs, if True, draw arrow heads. Default is False",
                "dpi": "int\nDots per inch of the figure. Default is 500."
            },
            "Returns": {
                "None": "None"
            }
        }
    },
    {
        "Section_id": "graph_match",
        "Description": "Attempts to solve the Graph Matching Problem or the Quadratic Assignment Problem (QAP) through an implementation of the Fast Approximate QAP (FAQ) Algorithm [1].\n\nThis algorithm can be thought of as finding an alignment of the vertices of two graphs which minimizes the number of induced edge disagreements, or, in the case of weighted graphs, the sum of squared differences of edge weight disagreements. Various extensions to the original FAQ algorithm are also included in this function ([2-5]).",
        "Field List": {
            "Parameters": {
                "A": "ndarray, csr_array, csr_array of shape (n, n), or a list thereof\nThe first (potentially multilayer) adjacency matrix to be matched. Multiplex networks (e.g. a network with multiple edge types) can be used by inputting a list of the adjacency matrices for each edge type.",
                "B": "ndarray, csr_array, csr_array of shape (m, m), or a list thereof\nThe second (potentially multilayer) adjacency matrix to be matched. Must have the same number of layers as A, but need not have the same size (see padding).",
                "AB": "ndarray, csr_array, csr_array of shape (n, m), or a list thereof, default=None\nA (potentially multilayer) matrix representing connections from the objects indexed in A to those in B, used for bisected graph matching (see [2]).",
                "BA": "ndarray, csr_array, csr_array of shape (m, n), or a list thereof, default=None\nA (potentially multilayer) matrix representing connections from the objects indexed in B to those in A, used for bisected graph matching (see [2]).",
                "S": "ndarray, csr_array, csr_array of shape (n, m), default=None\nA matrix representing the similarity of objects indexed in A to each object indexed in B. Note that the scale (i.e. the norm) of this matrix will affect how strongly the similarity (linear) term is weighted relative to the adjacency (quadratic) terms.",
                "partial_match": "ndarray of shape (n_matches, 2), dtype=int, or tuple of two array-likes of shape (n_matches,), default=None\nIndices specifying known matches to include in the optimization. The first column represents indices of the objects in A, and the second column represents their corresponding matches in B.",
                "init": "ndarray of shape (n_unseed, n_unseed), default=None\nInitialization for the algorithm. Setting to None specifies the \"barycenter\", which is the most commonly used initialization and represents an uninformative (flat) initialization. If a ndarray, then this matrix must be square and have size equal to the number of unseeded (not already matched in partial_match) nodes.",
                "init_perturbation": "float, default=0.0\nWeight of the random perturbation from init that the initialization will undergo. Must be between 0 and 1.",
                "n_init": "int, default=1\nNumber of initializations/runs of the algorithm to repeat. The solution with the best objective function value over all initializations is kept. Increasing n_init can improve performance but will take longer.",
                "shuffle_input": "bool, default=True\nWhether to shuffle the order of the inputs internally during optimization. This option is recommended to be kept to True besides for testing purposes; it alleviates a dependence of the solution on the (arbitrary) ordering of the input rows/columns.",
                "maximize": "bool, default=True\nWhether to maximize the objective function (graph matching problem) or minimize it (quadratic assignment problem). maximize=True corresponds to trying to find a permutation wherein the input matrices are as similar as possible - for adjacency matrices, this corresponds to maximizing the overlap of the edges of the two networks. Conversely, maximize=False would attempt to make this overlap as small as possible.",
                "padding": "{'naive', 'adopted'}, default='naive'\nSpecification of a padding scheme if A and B are not of equal size. See the padded graph matching tutorial or [3] for more explanation. Adopted padding has not been tested for weighted networks; use with caution.",
                "n_jobs": "int, default=None\nThe number of jobs to run in parallel. Parallelization is over the initializations, so only relevant when n_init > 1. None means 1 unless in a joblib.parallel_backend context. -1 means using all processors. See joblib.Parallel for more details.",
                "max_iter": "int, default=30\nMust be 1 or greater, specifying the max number of iterations for the algorithm. Setting this value higher may provide more precise solutions at the cost of longer computation time.",
                "tol": "float, default=0.01\nStopping tolerance for the FAQ algorithm. Setting this value smaller may provide more precise solutions at the cost of longer computation time.",
                "verbose": "int, default=0\nA positive number specifying the level of verbosity for status updates in the algorithm's progress. If n_jobs > 1, then this parameter behaves as the verbose parameter for joblib.Parallel.",
                "rng": "int, default=None\nThis parameter defines the object to use for drawing random variates. If rng is None the ~np.random.RandomState singleton is used. If rng is an int, a new RandomState instance is used, seeded with rng. If rng is already a RandomState or Generator instance, then that object is used. Default is None.",
                "transport": "bool, default=False\nWhether to use the transportation problem formulation of the QAP. If True, the transport_regularizer and transport_tol parameters must be set.",
                "transport_regularizer": "float, default=100\nRegularization parameter for the transportation problem. Larger values will result in a closer approximation to the true QAP, but will also be more computationally expensive.",
                "transport_tol": "float, default=0.05\nTolerance for the transportation problem. Smaller values will result in a closer approximation to the true QAP, but will also be more computationally expensive.",
                "transport_max_iter": "int, default=1000\nMaximum number of iterations for the transportation problem. Setting this value higher may provide more precise solutions at the cost of longer computation time.",
                "fast": "bool, default=True\nWhether to use the fast version of the FAQ algorithm. If False, the slower version will be used."
            },
            "Returns": {
                "res": "MatchResult\nMatchResult containing the following fields.\n\nindices_A: ndarray\nSorted indices in A which were matched.\n\nindices_B: ndarray\nIndices in B which were matched. Element indices_B[i] was matched to element indices_A[i]. indices_B can also be thought of as a permutation of the nodes of B with respect to A.\n\nscore: float\nObjective function value at the end of optimization.\n\nmisc: list of dict\nList of length n_init containing information about each run. Fields for each run are score, n_iter, convex_solution, and converged."
            }
        },
        "Rubric": {
            "Note": "Many extensions [2-5] to the original FAQ algorithm are included in this function. The full objective function which this function aims to solve can be written as\n\nwhere \n is a permutation matrix we are trying to learn, \n is the adjacency matrix in network \n for the \n-th edge type (and likewise for B), \n (with a slight abuse of notation, but for consistency with the code) is an adjacency matrix representing a subgraph of any connections which go from objects in \n to those in \n (and defined likewise for \n), and \n is a similarity matrix indexing the similarity of each object in \n to each object in \n.\n\nIf partial_match is used, then the above will be maximized/minimized over the set of permutations which respect this partial matching of the two networks.\n\nIf maximize, this function will attempt to maximize \n (solve the graph matching problem); otherwise, it will be minimized.",
            "References": [
                "J.T. Vogelstein, J.M. Conroy, V. Lyzinski, L.J. Podrazik, S.G. Kratzer, E.T. Harley, D.E. Fishkind, R.J. Vogelstein, and C.E. Priebe, \u201cFast approximate quadratic programming for graph matching,\u201d PLOS one, vol. 10, no. 4, p. e0121002, 2015.",
                "B.D. Pedigo, M. Winding, C.E. Priebe, J.T. Vogelstein, \"Bisected graph matching improves automated pairing of bilaterally homologous neurons from connectomes,\" bioRxiv 2022.05.19.492713 (2022)",
                "D. Fishkind, S. Adali, H. Patsolic, L. Meng, D. Singh, V. Lyzinski, C. Priebe, \"Seeded graph matching,\" Pattern Recognit. 87 (2019) 203\u2013215",
                "A. Saad-Eldin, B.D. Pedigo, C.E. Priebe, J.T. Vogelstein \"Graph Matching via Optimal Transport,\" arXiv 2111.05366 (2021)",
                "K. Pantazis, D.L. Sussman, Y. Park, Z. Li, C.E. Priebe, V. Lyzinski, \"Multiplex graph matching matched filters,\" Applied Network Science (2022)"
            ]
        }
    },
    {
        "Section_id": "EREstimator",
        "Description": "Erdos-Reyni Model\n\nThe Erdos-Reyni (ER) model is a simple random graph model in which the probability of any potential edge in the graph existing is the same for any two nodes i and j.\n\n for all i, j\n\nRead more in the Erdos-Renyi (ER) Model Tutorial",
        "Field List": {
            "Parameters": {
                "directed": "boolean, optional (default=True)\nWhether to treat the input graph as directed. Even if a directed graph is input, this determines whether to force symmetry upon the block probability matrix fit for the SBM. It will also determine whether graphs sampled from the model are directed.",
                "loops": "boolean, optional (default=False)\nWhether to allow entries on the diagonal of the adjacency matrix, i.e. loops in the graph where a node connects to itself."
            },
            "Attributes": {
                "p": "float\nValue between 0 and 1 (inclusive) representing the probability of any edge in the ER graph model",
                "p_mat": "np.ndarray, shape (n_verts, n_verts)\nProbability matrix for the fit model, from which graphs could be sampled."
            },
            "Methods": {
                "__init__": {
                    "Parameters": {
                        "directed": "bool"
                    }
                },
                "fit": {
                    "Parameters": {
                        "graph": "array_like or networkx.Graph\nInput graph to fit",
                        "y": "array_like, length graph.shape[0], optional\nCategorical labels for the block assignments of the graph"
                    }
                },
                "bic": {
                    "Description": "Bayesian information criterion for the current model on the input graph.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.",
                    "Parameters": {
                        "graph": "np.ndarray\nInput graph"
                    },
                    "Returns": {
                        "float": "The lower the better"
                    }
                },
                "get_metadata_routing": {
                    "Description": "Get metadata routing of this object.\n\nPlease check User Guide on how the routing mechanism works.",
                    "Returns": {
                        "routing": "MetadataRequest\nA MetadataRequest encapsulating routing information."
                    }
                },
                "get_params": {
                    "Description": "Get parameters for this estimator.",
                    "Parameters": {
                        "deep": "bool, default=True\nIf True, will return the parameters for this estimator and contained subobjects that are estimators."
                    },
                    "Returns": {
                        "params": "dict\nParameter names mapped to their values."
                    }
                },
                "mse": {
                    "Description": "Compute mean square error for the current model on the input graph\n\nNote that this implicitly assumes the input graph is indexed like the fit model.",
                    "Parameters": {
                        "graph": "np.ndarray\nInput graph"
                    },
                    "Returns": {
                        "float": "Mean square error for the model's fit P matrix"
                    }
                },
                "sample": {
                    "Description": "Sample graphs (realizations) from the fitted model\n\nCan only be called after the the model has been fit",
                    "Parameters": {
                        "n_samples": "int (default 1), optional\nThe number of graphs to sample"
                    },
                    "Returns": {
                        "graphs": "np.array (n_samples, n_verts, n_verts)\nArray of sampled graphs, where the first dimension indexes each sample, and the other dimensions represent (n_verts x n_verts) adjacency matrices for the sampled graphs.\n\nNote that if only one sample is drawn, a (1, n_verts, n_verts) array will still be returned."
                    }
                },
                "score": {
                    "Description": "Compute the average log-likelihood over each potential edge of the given graph.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.",
                    "Parameters": {
                        "graph": "np.ndarray\nInput graph. Must be same shape as model's p_mat_ attribute"
                    },
                    "Returns": {
                        "float": "sum of log-loglikelihoods for each potential edge in input graph"
                    }
                },
                "score_samples": {
                    "Description": "Compute the weighted log probabilities for each potential edge.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.",
                    "Parameters": {
                        "graph": "np.ndarray\nInput graph. Must be same shape as model's p_mat_ attribute",
                        "clip": "scalar or None, optional (default=None)\nValues for which to clip probability matrix, entries less than c or more than 1 - c are set to c or 1 - c, respectively. If None, values will not be clipped in the likelihood calculation, which may result in poorly behaved likelihoods depending on the model."
                    },
                    "Returns": {
                        "sample_scores": "np.ndarray (size of graph)\nlog-likelihood per potential edge in the graph"
                    }
                },
                "set_fit_request": {
                    "Description": "Request metadata passed to the fit method.\n\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\n\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to fit if provided. The request is ignored if metadata is not provided.\n\nFalse: metadata is not requested and the meta-estimator will not pass it to fit.\n\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\nstr: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\nThe default (sklearn.utils.metadata_routing.UNCHANGED) retains the existing request. This allows you to change the request for some parameters and not others.\n\nNew in version 1.3.",
                    "Parameters": {
                        "graph": "str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED\nMetadata routing for graph parameter in fit."
                    },
                    "Returns": {
                        "self": "object\nThe updated object."
                    }
                },
                "set_params": {
                    "Description": "Set the parameters of this estimator.\n\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.",
                    "Parameters": {
                        "**params": "dict\nEstimator parameters."
                    },
                    "Returns": {
                        "self": "estimator instance\nEstimator instance."
                    }
                },
                "set_score_request": {
                    "Description": "Request metadata passed to the score method.\n\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\n\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to score if provided. The request is ignored if metadata is not provided.\n\nFalse: metadata is not requested and the meta-estimator will not pass it to score.\n\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\nstr: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\nThe default (sklearn.utils.metadata_routing.UNCHANGED) retains the existing request. This allows you to change the request for some parameters and not others.\n\nNew in version 1.3.\n\nNote\n\nThis method is only relevant if this estimator is used as a sub-estimator of a meta-estimator, e.g. used inside a Pipeline. Otherwise it has no effect.",
                    "Parameters": {
                        "graph": "str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED\nMetadata routing for graph parameter in score."
                    },
                    "Returns": {
                        "self": "object\nThe updated object."
                    }
                }
            }
        },
        "Rubric": {
            "References": [
                "https://en.wikipedia.org/wiki/Erd%C5%91s%E2%80%93R%C3%A9nyi_model"
            ]
        }
    },
    {
        "Section_id": "DCEREstimator",
        "Description": "Degree-corrected Erdos-Reyni Model\n\nThe Degree-corrected Erdos-Reyni (DCER) model is an extension of the ER model in which each node has an additional \"promiscuity\" parameter that determines its expected degree in the graph.\n\nRead more in the Erdos-Renyi (ER) Model Tutorial",
        "Field List": {
            "Parameters": {
                "directed": "boolean, optional (default=True)\nWhether to treat the input graph as directed. Even if a directed graph is input, this determines whether to force symmetry upon the block probability matrix fit for the SBM. It will also determine whether graphs sampled from the model are directed.",
                "loops": "boolean, optional (default=False)\nWhether to allow entries on the diagonal of the adjacency matrix, i.e. loops in the graph where a node connects to itself.",
                "degree_directed": "boolean\nWhether to allow seperate degree correction parameters for the in and out degree of each node. Ignored if directed is False."
            },
            "Attributes": {
                "p_": "float\nThe p parameter as described in the above model, which weights the overall probability of connections between any two nodes.",
                "p_mat_": "np.ndarray, shape (n_verts, n_verts)\nProbability matrix for the fit model, from which graphs could be sampled.",
                "degree_corrections_": "np.ndarray, shape (n_verts, 1) or (n_verts, 2)\nDegree correction vector(s) . If degree_directed parameter was False, then will be of shape (n_verts, 1) and element i represents the degree correction for node . Otherwise, the first column contains out degree corrections and the second column contains in degree corrections."
            },
            "Methods": {
                "__init__": {
                    "Parameters": {
                        "directed": "bool",
                        "loops": "bool",
                        "degree_directed": "bool"
                    }
                },
                "fit": {
                    "Description": "Fit the DCSBM to a graph, optionally with known block labels.\nIf y is None, the block assignments for each vertex will first be estimated.",
                    "Parameters": {
                        "graph": "array-like or array_like or networkx.Graph\nInput graph to fit",
                        "y": "array-like, length graph.shape[0], optional\nCategorical labels for the block assignments of the graph"
                    },
                    "Returns": {
                        "self": "DCEREstimator\nFitted instance of self"
                    }
                },
                "bic": {
                    "Description": "Bayesian information criterion for the current model on the input graph.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.",
                    "Parameters": {
                        "graph": "np.ndarray\nInput graph"
                    },
                    "Returns": {
                        "float": "The lower the better"
                    }
                },
                "get_metadata_routing": {
                    "Description": "Get metadata routing of this object.\n\nPlease check User Guide on how the routing mechanism works.",
                    "Returns": {
                        "routing": "MetadataRequest\nA MetadataRequest encapsulating routing information."
                    }
                },
                "get_params": {
                    "Description": "Get parameters for this estimator.",
                    "Parameters": {
                        "deep": "bool, default=True\nIf True, will return the parameters for this estimator and contained subobjects that are estimators."
                    },
                    "Returns": {
                        "params": "dict\nParameter names mapped to their values."
                    }
                },
                "mse": {
                    "Description": "Compute mean square error for the current model on the input graph\n\nNote that this implicitly assumes the input graph is indexed like the fit model.",
                    "Parameters": {
                        "graph": "np.ndarray\nInput graph"
                    },
                    "Returns": {
                        "float": "Mean square error for the model's fit P matrix"
                    }
                },
                "sample": {
                    "Description": "Sample graphs (realizations) from the fitted model\n\nCan only be called after the the model has been fit",
                    "Parameters": {
                        "n_samples": "int\nThe number of graphs to sample"
                    },
                    "Returns": {
                        "graphs": "np.array\nArray of sampled graphs, where the first dimension indexes each sample, and the other dimensions represent (n_verts x n_verts) adjacency matrices for the sampled graphs."
                    }
                },
                "score": {
                    "Description": "Compute the average log-likelihood over each potential edge of the given graph.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.",
                    "Parameters": {
                        "graph": "np.ndarray\nInput graph. Must be same shape as model's p_mat_ attribute"
                    },
                    "Returns": {
                        "float": "sum of log-loglikelihoods for each potential edge in input graph"
                    }
                },
                "score_samples": {
                    "Description": "Compute the weighted log probabilities for each potential edge.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.",
                    "Parameters": {
                        "graph": "np.ndarray\nInput graph. Must be same shape as model's p_mat_ attribute",
                        "clip": "float or None\nValues for which to clip probability matrix, entries less than c or more than 1 - c are set to c or 1 - c, respectively. If None, values will not be clipped in the likelihood calculation, which may result in poorly behaved likelihoods depending on the model."
                    },
                    "Returns": {
                        "sample_scores": "np.ndarray\nlog-likelihood per potential edge in the graph"
                    }
                },
                "set_fit_request": {
                    "Description": "Request metadata passed to the fit method.\n\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\n\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to fit if provided. The request is ignored if metadata is not provided.\n\nFalse: metadata is not requested and the meta-estimator will not pass it to fit.\n\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\nstr: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\nThe default (sklearn.utils.metadata_routing.UNCHANGED) retains the existing request. This allows you to change the request for some parameters and not others.\n\nNew in version 1.3.",
                    "Parameters": {
                        "graph": "str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED\nMetadata routing for graph parameter in fit."
                    },
                    "Returns": {
                        "self": "object\nThe updated object."
                    }
                },
                "set_params": {
                    "Description": "Set the parameters of this estimator.\n\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.",
                    "Parameters": {
                        "**params": "dict\nEstimator parameters."
                    },
                    "Returns": {
                        "self": "estimator instance\nEstimator instance."
                    }
                },
                "set_score_request": {
                    "Description": "Request metadata passed to the score method.\n\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\n\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to score if provided. The request is ignored if metadata is not provided.\n\nFalse: metadata is not requested and the meta-estimator will not pass it to score.\n\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\nstr: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\nThe default (sklearn.utils.metadata_routing.UNCHANGED) retains the existing request. This allows you to change the request for some parameters and not others.\n\nNew in version 1.3.\n\nNote\n\nThis method is only relevant if this estimator is used as a sub-estimator of a meta-estimator, e.g. used inside a Pipeline. Otherwise it has no effect.",
                    "Parameters": {
                        "graph": "str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED\nMetadata routing for graph parameter in score."
                    },
                    "Returns": {
                        "self": "object\nThe updated object."
                    }
                }
            }
        },
        "Rubric": {
            "Note": "The DCER model is rarely mentioned in literature, though it is simply a special case of the DCSBM where there is only one community.",
            "References": [
                "https://en.wikipedia.org/wiki/Erd%C5%91s%E2%80%93R%C3%A9nyi_model",
                "Karrer, B., & Newman, M. E. (2011). Stochastic blockmodels and community structure in networks. Physical review E, 83(1), 016107."
            ]
        }
    },
    {
        "Section_id": "SBMEstimator",
        "Description": "Stochastic Block Model\n\nThe stochastic block model (SBM) represents each node as belonging to a block (or community). For a given potential edge between node i and j, the probability of an edge existing is specified by the block that nodes i and j belong to:\n\nP(A_ij = 1 | z_i = k, z_j = l) = B[k, l]\n\nwhere \ud835\udfd8\ud835\udfd9 is an n_nodes length vector specifying which block each node belongs to.\n\nRead more in the Stochastic Block Model (SBM) Tutorial",
        "Field List": {
            "Parameters": {
                "directed": "boolean, optional (default=True)\nWhether to treat the input graph as directed. Even if a directed graph is input, this determines whether to force symmetry upon the block probability matrix fit for the SBM. It will also determine whether graphs sampled from the model are directed.",
                "loops": "boolean, optional (default=False)\nWhether to allow entries on the diagonal of the adjacency matrix, i.e. loops in the graph where a node connects to itself.",
                "n_components": "int, optional (default=None)\nDesired dimensionality of embedding for clustering to find communities. n_components must be < min(X.shape). If None, then optimal dimensions will be chosen by select_dimension().",
                "min_comm": "int, optional (default=1)\nThe minimum number of communities (blocks) to consider.",
                "max_comm": "int, optional (default=10)\nThe maximum number of communities (blocks) to consider (inclusive).",
                "cluster_kws": "dict, optional (default={})\nAdditional kwargs passed down to GaussianCluster",
                "embed_kws": "dict, optional (default={})\nAdditional kwargs passed down to AdjacencySpectralEmbed"
            },
            "Attributes": {
                "block_p_": "ndarray,shape (n_blocks, n_blocks)\nThe block probability matrix B, where the element Bij represents the probability of an edge between block i and block j .",
                "p_mat_": "ndarray, shape (n_verts, n_verts)\nProbability matrix P for the fit model, from which graphs could be sampled.",
                "vertex_assignments_": "ndarray, shape (n_verts)\nA vector of integer labels corresponding to the predicted block that each node belongs to if y was not passed during the call to fit().",
                "block_weights_": "ndarray, shape (n_blocks)\nContains the proportion of nodes that belong to each block in the fit model."
            },
            "Methods": {
                "__init__": {
                    "Parameters": {
                        "directed": "bool",
                        "loops": "bool",
                        "n_components": "int",
                        "min_comm": "int",
                        "max_comm": "int",
                        "cluster_kws": "Dict[str, Any]",
                        "embed_kws": "Dict[str, Any]"
                    }
                },
                "fit": {
                    "Description": "Fit the SBM to a graph, optionally with known block labels\n\nIf y is None, the block assignments for each vertex will first be estimated.",
                    "Parameters": {
                        "graph": "ndarray | csr_array | Graph",
                        "y": "Any | None"
                    },
                    "Returns": {
                        "SBMEstimator": "SBMEstimator"
                    }
                },
                "bic": {
                    "Description": "Bayesian information criterion for the current model on the input graph.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.",
                    "Parameters": {
                        "graph": "ndarray\nInput graph"
                    },
                    "Returns": {
                        "float": "The lower the better"
                    }
                },
                "get_metadata_routing": {
                    "Description": "Get metadata routing of this object.\n\nPlease check User Guide on how the routing mechanism works.",
                    "Returns": {
                        "routing": "MetadataRequest\nA MetadataRequest encapsulating routing information."
                    }
                },
                "get_params": {
                    "Description": "Get parameters for this estimator.",
                    "Parameters": {
                        "deep": "bool, default=True\nIf True, will return the parameters for this estimator and contained subobjects that are estimators."
                    },
                    "Returns": {
                        "params": "dict\nParameter names mapped to their values."
                    }
                },
                "mse": {
                    "Description": "Compute mean square error for the current model on the input graph\n\nNote that this implicitly assumes the input graph is indexed like the fit model.",
                    "Parameters": {
                        "graph": "ndarray\nInput graph"
                    },
                    "Returns": {
                        "float": "Mean square error for the model's fit P matrix"
                    }
                },
                "sample": {
                    "Description": "Sample graphs (realizations) from the fitted model\n\nCan only be called after the the model has been fit",
                    "Parameters": {
                        "n_samples": "int (default 1), optional\nThe number of graphs to sample"
                    },
                    "Returns": {
                        "graphs": "np.array (n_samples, n_verts, n_verts)\nArray of sampled graphs, where the first dimension indexes each sample, and the other dimensions represent (n_verts x n_verts)"
                    }
                },
                "score": {
                    "Description": "Compute the average log-likelihood over each potential edge of the given graph.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.",
                    "Parameters": {
                        "graph": "np.ndarray\nInput graph. Must be same shape as model's p_mat_ attribute"
                    },
                    "Returns": {
                        "float": "sum of log-loglikelihoods for each potential edge in input graph"
                    }
                },
                "score_samples": {
                    "Description": "Compute the weighted log probabilities for each potential edge.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.",
                    "Parameters": {
                        "graph": "np.ndarray\nInput graph. Must be same shape as model's p_mat_ attribute",
                        "clip": "scalar or None, optional (default=None)\nValues for which to clip probability matrix, entries less than c or more than 1 - c are set to c or 1 - c, respectively. If None, values will not be clipped in the likelihood calculation, which may result in poorly behaved likelihoods depending on the model."
                    },
                    "Returns": {
                        "sample_scores": "np.ndarray (size of graph)\nlog-likelihood per potential edge in the graph"
                    }
                },
                "set_fit_request": {
                    "Description": "Request metadata passed to the fit method.\n\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\n\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to fit if provided. The request is ignored if metadata is not provided.\n\nFalse: metadata is not requested and the meta-estimator will not pass it to fit.\n\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\nstr: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\nThe default (sklearn.utils.metadata_routing.UNCHANGED) retains the existing request. This allows you to change the request for some parameters and not others.\n\nNew in version 1.3.",
                    "Parameters": {
                        "graph": "str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED\nMetadata routing for graph parameter in fit."
                    },
                    "Returns": {
                        "self": "object\nThe updated object."
                    }
                },
                "set_params": {
                    "Description": "Set the parameters of this estimator.\n\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.",
                    "Parameters": {
                        "**params": "dict\nEstimator parameters."
                    },
                    "Returns": {
                        "self": "estimator instance\nEstimator instance."
                    }
                },
                "set_score_request": {
                    "Description": "Request metadata passed to the score method.\n\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\n\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to score if provided. The request is ignored if metadata is not provided.\n\nFalse: metadata is not requested and the meta-estimator will not pass it to score.\n\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\nstr: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\nThe default (sklearn.utils.metadata_routing.UNCHANGED) retains the existing request. This allows you to change the request for some parameters and not others.\n\nNew in version 1.3.\n\nNote\n\nThis method is only relevant if this estimator is used as a sub-estimator of a meta-estimator, e.g. used inside a Pipeline. Otherwise it has no effect.",
                    "Parameters": {
                        "graph": "str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED\nMetadata routing for graph parameter in score."
                    },
                    "Returns": {
                        "self": "object\nThe updated object."
                    }
                }
            }
        },
        "Rubric": {
            "References": [
                "Holland, P. W., Laskey, K. B., & Leinhardt, S. (1983). Stochastic blockmodels: First steps. Social networks, 5(2), 109-137."
            ]
        }
    },
    {
        "Section_id": "DCSBMEstimator",
        "Description": "Degree-corrected Stochastic Block Model\n\nThe degree-corrected stochastic block model (DCSBM) represents each node as belonging to a block (or community). For a given potential edge between node i and j, the probability of an edge existing is specified by the block that nodes i and j belong to as in the SBM. However, an additional \"promiscuity\" parameter is added for each node, allowing the vertices within a block to have heterogeneous expected degree distributions:\n\nP(A_ij = 1 | z_i = k, z_j = l) = B[k, l]\u03b8_i\u03b8_j\n\nwhere \ud835\udfd8\ud835\udfd9 is an n_nodes length vector specifying which block each node belongs to, and \u03b8 is an n_nodes length vector specifiying the degree correction for each node.\n\nThe degree_directed parameter of this model allows the degree correction parameter to be different for the in and out degree of each node:\n\nP(A_ij = 1 | z_i = k, z_j = l) = B[k, l]\u03b8_i\u03b8_j\n\nwhere \u03b8_i and \u03b8_j need not be the same.\n\nRead more in the Stochastic Block Model (SBM) Tutorial",
        "Field List": {
            "Parameters": {
                "directed": "boolean, optional (default=True)\nWhether to treat the input graph as directed. Even if a directed graph is input, this determines whether to force symmetry upon the block probability matrix fit for the SBM. It will also determine whether graphs sampled from the model are directed.",
                "degree_directed": "boolean, optional (default=False)\nWhether to fit an \"in\" and \"out\" degree correction for each node. In the degree_directed case, the fit model can have a different expected in and out degree for each node.",
                "loops": "boolean, optional (default=False)\nWhether to allow entries on the diagonal of the adjacency matrix, i.e. loops in the graph where a node connects to itself.",
                "n_components": "int, optional (default=None)\nDesired dimensionality of embedding for clustering to find communities. n_components must be < min(X.shape). If None, then optimal dimensions will be chosen by select_dimension().",
                "min_comm": "int, optional (default=1)\nThe minimum number of communities (blocks) to consider.",
                "max_comm": "int, optional (default=10)\nThe maximum number of communities (blocks) to consider (inclusive).",
                "cluster_kws": "dict, optional (default={})\nAdditional kwargs passed down to GaussianCluster",
                "embed_kws": "dict, optional (default={})\nAdditional kwargs passed down to LaplacianSpectralEmbed"
            },
            "Attributes": {
                "block_p_": "np.ndarray, shape (n_blocks, n_blocks)\nThe block probability matrix , where the element represents the expected number of edges between block and block .",
                "p_mat_": "np.ndarray, shape (n_verts, n_verts)\nProbability matrix  for the fit model, from which graphs could be sampled.",
                "degree_corrections_": "np.ndarray, shape (n_verts, 1) or (n_verts, 2)\nDegree correction vector(s) . If degree_directed parameter was False, then will be of shape (n_verts, 1) and element represents the degree correction for node . Otherwise, the first column contains out degree corrections and the second column contains in degree corrections.",
                "vertex_assignments_": "np.ndarray, shape (n_verts)\nA vector of integer labels corresponding to the predicted block that each node belongs to if y was not passed during the call to fit().",
                "block_weights_": "np.ndarray, shape (n_blocks)\nContains the proportion of nodes that belong to each block in the fit model."
            },
            "Methods": {
                "__init__": {
                    "Parameters": {
                        "degree_directed": "bool",
                        "directed": "bool",
                        "loops": "bool",
                        "n_components": "int",
                        "min_comm": "int",
                        "max_comm": "int",
                        "cluster_kws": "Dict[str, Any]",
                        "embed_kws": "Dict[str, Any]"
                    }
                },
                "fit": {
                    "Description": "Fit the DCSBM to a graph, optionally with known block labels\n\nIf y is None, the block assignments for each vertex will first be estimated.",
                    "Parameters": {
                        "graph": "array_like or networkx.Graph\nInput graph to fit",
                        "y": "array_like, length graph.shape[0], optional\nCategorical labels for the block assignments of the graph"
                    },
                    "Returns": {
                        "self": "DCSBMEstimator object\nFitted instance of self"
                    }
                },
                "bic": {
                    "Description": "Bayesian information criterion for the current model on the input graph.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.",
                    "Parameters": {
                        "graph": "np.ndarray\nInput graph"
                    },
                    "Returns": {
                        "float": "The lower the better"
                    }
                },
                "get_metadata_routing": {
                    "Description": "Get metadata routing of this object.\n\nPlease check User Guide on how the routing mechanism works.",
                    "Returns": {
                        "routing": "MetadataRequest\nA MetadataRequest encapsulating routing information."
                    }
                },
                "get_params": {
                    "Description": "Get parameters for this estimator.",
                    "Parameters": {
                        "deep": "bool, default=True\nIf True, will return the parameters for this estimator and contained subobjects that are estimators."
                    },
                    "Returns": {
                        "params": "dict\nParameter names mapped to their values."
                    }
                },
                "mse": {
                    "Description": "Compute mean square error for the current model on the input graph\n\nNote that this implicitly assumes the input graph is indexed like the fit model.",
                    "Parameters": {
                        "graph": "np.ndarray\nInput graph"
                    },
                    "Returns": {
                        "float": "Mean square error for the model's fit P matrix"
                    }
                },
                "sample": {
                    "Description": "Sample graphs (realizations) from the fitted model\n\nCan only be called after the the model has been fit",
                    "Parameters": {
                        "n_samples": "int\nThe number of graphs to sample"
                    },
                    "Returns": {
                        "graphs": "np.array\nArray of sampled graphs, where the first dimension indexes each sample, and the other dimensions represent (n_verts x n_verts) adjacency matrices for the sampled graphs."
                    }
                },
                "score": {
                    "Description": "Compute the average log-likelihood over each potential edge of the given graph.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.",
                    "Parameters": {
                        "graph": "np.ndarray\nInput graph. Must be same shape as model's p_mat_ attribute"
                    },
                    "Returns": {
                        "float": "sum of log-loglikelihoods for each potential edge in input graph"
                    }
                },
                "score_samples": {
                    "Description": "Compute the weighted log probabilities for each potential edge.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.",
                    "Parameters": {
                        "graph": "np.ndarray\nInput graph. Must be same shape as model's p_mat_ attribute",
                        "clip": "scalar or None, optional (default=None)\nValues for which to clip probability matrix, entries less than c or more than 1 - c are set to c or 1 - c, respectively. If None, values will not be clipped in the likelihood calculation, which may result in poorly behaved likelihoods depending on the model."
                    },
                    "Returns": {
                        "sample_scores": "np.ndarray (size of graph)\nlog-likelihood per potential edge in the graph"
                    }
                },
                "set_fit_request": {
                    "Description": "Request metadata passed to the fit method.\n\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\n\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to fit if provided. The request is ignored if metadata is not provided.\n\nFalse: metadata is not requested and the meta-estimator will not pass it to fit.\n\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\nstr: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\nThe default (sklearn.utils.metadata_routing.UNCHANGED) retains the existing request. This allows you to change the request for some parameters and not others.\n\nNew in version 1.3.",
                    "Parameters": {
                        "graph": "str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED\nMetadata routing for graph parameter in fit."
                    },
                    "Returns": {
                        "self": "object\nThe updated object."
                    }
                },
                "set_params": {
                    "Description": "Set the parameters of this estimator.\n\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.",
                    "Parameters": {
                        "**params": "dict\nEstimator parameters."
                    },
                    "Returns": {
                        "self": "estimator instance\nEstimator instance."
                    }
                },
                "set_score_request": {
                    "Description": "Request metadata passed to the score method.\n\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\n\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to score if provided. The request is ignored if metadata is not provided.\n\nFalse: metadata is not requested and the meta-estimator will not pass it to score.\n\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\nstr: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\nThe default (sklearn.utils.metadata_routing.UNCHANGED) retains the existing request. This allows you to change the request for some parameters and not others.\n\nNew in version 1.3.\n\nNote\n\nThis method is only relevant if this estimator is used as a sub-estimator of a meta-estimator, e.g. used inside a Pipeline. Otherwise it has no effect.",
                    "Parameters": {
                        "graph": "str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED\nMetadata routing for graph parameter in score."
                    },
                    "Returns": {
                        "self": "object\nThe updated object."
                    }
                }
            }
        },
        "Rubric": {
            "Note": "Note that many examples in the literature describe the DCSBM as being sampled with a Poisson distribution. Here, we implement this model with a Bernoulli. When individual edge probabilities are relatively low these two distributions will yield similar results.",
            "References": [
                "Karrer, B., & Newman, M. E. (2011). Stochastic blockmodels and community structure in networks. Physical review E, 83(1), 016107."
            ]
        }
    },
    {
        "Section_id": "RDPGEstimator",
        "Description": "Random Dot Product Graph\n\nUnder the random dot product graph model, each node is assumed to have a \"latent position\" in some -dimensional Euclidian space. This vector dictates that node's probability of connection to other nodes. For a given pair of nodes i and j, the probability of connection is the dot product between their latent positions:\n\nP(A_ij = 1) = <x_i, x_j>\n\nwhere x_i is the latent position of node i. If the graph being modeled is is undirected, then P(A_ij = 1) = <x_i, x_j> + <x_j, x_i>. Latent positions can be estimated via AdjacencySpectralEmbed.\n\nRead more in the Random Dot Product Graph (RDPG) Model Tutorial",
        "Field List": {
            "Parameters": {
                "loops": "boolean, optional (default=False)\nWhether to allow entries on the diagonal of the adjacency matrix, i.e. loops in the graph where a node connects to itself.",
                "n_components": "int, optional (default=None)\nThe dimensionality of the latent space used to model the graph. If None, the method of Zhu and Godsie will be used to select an embedding dimension.",
                "ase_kws": "dict, optional (default={})\nDictionary of keyword arguments passed down to AdjacencySpectralEmbed, which is used to fit the model.",
                "diag_aug_weight": "int or float, optional (default=1)\nWeighting used for diagonal augmentation, which is a form of regularization for fitting the RDPG model.",
                "plus_c_weight": "int or float, optional (default=1)\nWeighting used for a constant scalar added to the adjacency matrix before embedding as a form of regularization."
            },
            "Attributes": {
                "latent_tuple_": "length 2, or np.ndarray, shape (n_verts, n_components)\nThe fit latent positions for the RDPG model. If a tuple, then the graph that was input to fit was directed, and the first and second elements of the tuple are the left and right latent positions, respectively. The left and right latent positions will both be of shape (n_verts, n_components). If latent_ is an array, then the graph that was input to fit was undirected and the left and right latent positions are the same.",
                "p_mat_": "np.ndarray, shape (n_verts, n_verts)\nProbability matrix P for the fit model, from which graphs could be sampled."
            },
            "Methods": {
                "__init__": {
                    "Parameters": {
                        "loops": "bool",
                        "n_components": "int",
                        "ase_kws": "dict",
                        "diag_aug_weight": "float",
                        "plus_c_weight": "float"
                    }
                },
                "fit": {
                    "Description": "Calculate the parameters for the given graph model",
                    "Parameters": {
                        "graph": "ndarray | csr_array | Graph",
                        "y": "Any | None"
                    },
                    "Returns": {
                        "RDPGEstimator": "RDPGEstimator"
                    }
                },
                "bic": {
                    "Description": "Bayesian information criterion for the current model on the input graph.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.",
                    "Parameters": {
                        "graph": "ndarray"
                    },
                    "Returns": {
                        "bic": "float\nThe lower the better"
                    }
                },
                "get_metadata_routing": {
                    "Description": "Get metadata routing of this object.\n\nPlease check User Guide on how the routing mechanism works.",
                    "Returns": {
                        "routing": "MetadataRequest\nA MetadataRequest encapsulating routing information."
                    }
                },
                "get_params": {
                    "Description": "Get parameters for this estimator.",
                    "Parameters": {
                        "deep": "bool, default=True\nIf True, will return the parameters for this estimator and contained subobjects that are estimators."
                    },
                    "Returns": {
                        "params": "dict\nParameter names mapped to their values."
                    }
                },
                "mse": {
                    "Description": "Compute mean square error for the current model on the input graph\n\nNote that this implicitly assumes the input graph is indexed like the fit model.",
                    "Parameters": {
                        "graph": "ndarray\nInput graph"
                    },
                    "Returns": {
                        "mse": "float\nMean square error for the model's fit P matrix"
                    }
                },
                "sample": {
                    "Description": "Sample graphs (realizations) from the fitted model\n\nCan only be called after the the model has been fit",
                    "Parameters": {
                        "n_samples": "int\nThe number of graphs to sample"
                    },
                    "Returns": {
                        "graphs": "np.array\nArray of sampled graphs, where the first dimension indexes each sample, and the other dimensions represent (n_verts x n_verts) adjacency matrices for the sampled graphs."
                    }
                },
                "score": {
                    "Description": "Compute the average log-likelihood over each potential edge of the given graph.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.",
                    "Parameters": {
                        "graph": "np.ndarray\nInput graph. Must be same shape as model's p_mat_ attribute"
                    },
                    "Returns": {
                        "float": "sum of log-loglikelihoods for each potential edge in input graph"
                    }
                },
                "score_samples": {
                    "Description": "Compute the weighted log probabilities for each potential edge.\n\nNote that this implicitly assumes the input graph is indexed like the fit model.",
                    "Parameters": {
                        "graph": "np.ndarray\nInput graph. Must be same shape as model's p_mat_ attribute",
                        "clip": "scalar or None, optional (default=None)\nValues for which to clip probability matrix, entries less than c or more than 1 - c are set to c or 1 - c, respectively. If None, values will not be clipped in the likelihood calculation, which may result in poorly behaved likelihoods depending on the model."
                    },
                    "Returns": {
                        "sample_scores": "np.ndarray (size of graph)\nlog-likelihood per potential edge in the graph"
                    }
                },
                "set_fit_request": {
                    "Description": "Request metadata passed to the fit method.\n\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\n\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to fit if provided. The request is ignored if metadata is not provided.\n\nFalse: metadata is not requested and the meta-estimator will not pass it to fit.\n\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\nstr: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\nThe default (sklearn.utils.metadata_routing.UNCHANGED) retains the existing request. This allows you to change the request for some parameters and not others.\n\nNew in version 1.3.",
                    "Parameters": {
                        "graph": "str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED\nMetadata routing for graph parameter in fit."
                    },
                    "Returns": {
                        "self": "object\nThe updated object."
                    }
                },
                "set_params": {
                    "Description": "Set the parameters of this estimator.\n\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.",
                    "Parameters": {
                        "**params": "dict\nEstimator parameters."
                    },
                    "Returns": {
                        "self": "estimator instance\nEstimator instance."
                    }
                },
                "set_score_request": {
                    "Description": "Request metadata passed to the score method.\n\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\n\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to score if provided. The request is ignored if metadata is not provided.\n\nFalse: metadata is not requested and the meta-estimator will not pass it to score.\n\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\nstr: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\nThe default (sklearn.utils.metadata_routing.UNCHANGED) retains the existing request. This allows you to change the request for some parameters and not others.\n\nNew in version 1.3.\n\nNote\n\nThis method is only relevant if this estimator is used as a sub-estimator of a meta-estimator, e.g. used inside a Pipeline. Otherwise it has no effect.",
                    "Parameters": {
                        "graph": "str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED\nMetadata routing for graph parameter in score."
                    },
                    "Returns": {
                        "self": "object\nThe updated object."
                    }
                }
            }
        },
        "Rubric": {
            "References": [
                "Athreya, A., Fishkind, D. E., Tang, M., Priebe, C. E., Park, Y., Vogelstein, J. T., ... & Sussman, D. L. (2018). Statistical inference on random dot product graphs: a survey. Journal of Machine Learning Research, 18(226), 1-92.",
                "Zhu, M. and Ghodsi, A. (2006). Automatic dimensionality selection from the scree plot via the use of profile likelihood. Computational Statistics & Data Analysis, 51(2), pp.918-930."
            ]
        }
    },
    {
        "Section_id": "EdgeSwapper",
        "Description": "Degree Preserving Edge Swaps\n\nThis class allows for performing degree preserving edge swaps to generate new networks with the same degree sequence as the input network.",
        "Field List": {
            "Attributes": {
                "adjacency_": "np.ndarray OR csr_array, shape (n_verts, n_verts)\nThe initial adjacency matrix to perform edge swaps on. Must be unweighted and undirected.",
                "edge_list_": "np.ndarray, shape (n_verts, 2)\nThe corresponding edgelist for the input network",
                "seed_": "int, optional\nRandom seed to make outputs reproducible, must be positive"
            },
            "Methods": {
                "__init__": {
                    "Parameters": {
                        "adjacency": "ndarray | csr_array",
                        "seed": "int | None"
                    }
                },
                "swap_edges": {
                    "Description": "Performs a number of edge swaps on the graph",
                    "Parameters": {
                        "n_swaps": "int(default 1), optional\nThe number of edge swaps to be performed"
                    },
                    "Returns": {
                        "adjacency": "np.ndarray OR csr.matrix, shape (n_verts, n_verts)\nThe adjancency matrix after a number of edge swaps are performed on the graph",
                        "edge_list": "np.ndarray (n_verts, 2)\nThe edge_list after a number of edge swaps are perfomed on the graph"
                    }
                }
            }
        },
        "Rubric": {
            "References": [
                "Fosdick, B. K., Larremore, D. B., Nishimura, J., & Ugander, J. (2018). Configuring random graph models with fixed degree sequences. Siam Review, 60(2), 315-355.",
                "Carstens, C. J., & Horadam, K. J. (2017). Switching edges to randomize networks: what goes wrong and how to fix it. Journal of Complex Networks, 5(3), 337-351.",
                "https://github.com/joelnish/double-edge-swap-mcmc/blob/master/dbl_edge_mcmc.py"
            ]
        }
    },
    {
        "Section_id": "SpectralVertexNomination",
        "Description": "Class for spectral vertex nomination on a single graph.\n\nGiven a graph  and a subset of  called  (the \"seed\"), Single Graph Vertex Nomination is the problem of ranking all  in order of relation to members of . Spectral Vertex Nomination solves this problem by embedding  into a low dimensional euclidean space (see: Adjacency Spectral Embed Tutorial ), and then generating a nomination list by some distance based algorithm. In the simple unattributed case, for each seed vertex , the other vertices are ranked in order of euclidean distance from .",
        "Field List": {
            "Parameters": {
                "input_graph": "bool, default = True\nFlag whether to expect two full graphs, or the embeddings.\n\nTrue\n.fit and .fit_predict() expect graphs as adjacency matrix, provided as ndarray of shape (n, n). They will be embedded using the specified embedder.\n\nFalse\n.fit() and .fit_predict() expect an embedding of the graph, i.e. a ndarray of size (n, d).",
                "embedder": "str or BaseSpectralEmbed, default = 'ASE'\nMay provide either a embed object or a string indicating which embedding method to use, which may be either: \"ASE\" for AdjacencySpectralEmbed or \"LSE\" for LaplacianSpectralEmbed.",
                "n_neighbors": "int, default=None\nThe number of vertices to nominate for each seed.",
                "metric": "str, default = 'euclidean'\nDistance metric to use when finding the nearest neighbors, all sklearn metrics available.",
                "metric_params": "dict, default = None\nArguments for the sklearn DistanceMetric specified via metric parameter."
            },
            "Attributes": {
                "nearest_neighbors_": "sklearn.neighbors.NearestNeighbors\nA fit sklearn NearestNeighbors classifier used to find closest vertices to each seed."
            },
            "Methods": {
                "__init__": {
                    "Parameters": {
                        "input_graph": "bool",
                        "embedder": "str | BaseSpectralEmbed",
                        "n_neighbors": "int | None",
                        "metric": "str",
                        "metric_params": "dict | None"
                    }
                },
                "fit": {
                    "Description": "Constructs the embedding if not provided, then calculates the pairwise distance from each seed to each vertex in graph",
                    "Parameters": {
                        "X": "ndarray\nIf input_graph is True\nExpects a graph as an adjacency matrix, i.e. an ndarray of shape (n, n). Will be embedded using the specified embedder.\n\nIf input_graph is False\nExpects an embedding of the graph, i.e. a ndarray of size (n, d).",
                        "y": "NoneType\nIncluded by sklearn convention."
                    },
                    "Returns": {
                        "self": "object\nReturns an instance of self."
                    }
                },
                "predict": {
                    "Description": "Nominates vertices for each seed vertex. Methodology is distance based ranking",
                    "Parameters": {
                        "y": "np.ndarray\nThe indices of the seed vertices. Should be a dim 1 array with length less than ."
                    },
                    "Returns": {
                        "Tuple[ndarray, ndarray]": "Nomination Listnp.ndarray\nShape is (number_vertices, number_vertices_in_seed) . Each column is a seed vertex, and the rows of each column are a list of vertex indexes from the original adjacency matrix in order degree of match.\n\nDistance Matrixnp.ndarray\nThe matrix of distances associated with each element of the nomination list."
                    }
                },
                "fit_predict": {
                    "Description": "Calls this class' fit and then predict methods",
                    "Parameters": {
                        "X": "ndarray\nIf input_graph is True\nExpects a graph as an adjacency matrix, i.e. an ndarray of shape (n, n). Will be embedded using the specified embedder.\n\nIf input_graph is False\nExpects an embedding of the graph, i.e. a ndarray of size (n, d).",
                        "y": "ndarray.\nList of unattributed seed vertex indices."
                    },
                    "Returns": {
                        "Tuple[ndarray, ndarray]": "Nomination Listnp.ndarray\nShape is (number_vertices, number_vertices_in_seed) . Each column is a seed vertex, and the rows of each column are a list of vertex indexes from the original adjacency matrix in order degree of match.\n\nDistance Matrixnp.ndarray\nThe matrix of distances associated with each element of the nomination list."
                    }
                },
                "get_metadata_routing": {
                    "Description": "Get metadata routing of this object.\n\nPlease check User Guide on how the routing mechanism works.",
                    "Returns": {
                        "routing": "MetadataRequest\nA MetadataRequest encapsulating routing information."
                    }
                },
                "get_params": {
                    "Description": "Get parameters for this estimator.",
                    "Parameters": {
                        "deep": "bool, default=True\nIf True, will return the parameters for this estimator and contained subobjects that are estimators."
                    },
                    "Returns": {
                        "params": "dict\nParameter names mapped to their values."
                    }
                },
                "set_params": {
                    "Description": "Set the parameters of this estimator.\n\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it's possible to update each component of a nested object.",
                    "Parameters": {
                        "**params": "dict\nEstimator parameters."
                    },
                    "Returns": {
                        "self": "estimator instance\nEstimator instance."
                    }
                }
            }
        },
        "Rubric": {
            "References": [
                "Fishkind, D. E.; Lyzinski, V.; Pao, H.; Chen, L.; Priebe, C. E. Vertex nomination schemes for membership prediction. Ann. Appl. Stat. 9 2015. https://projecteuclid.org/euclid.aoas/1446488749",
                "Jordan Yoder, Li Chen, Henry Pao, Eric Bridgeford, Keith Levin, Donniell E. Fishkind, Carey Priebe, Vince Lyzinski, Vertex nomination: The canonical sampling and the extended spectral nomination schemes, Computational Statistics & Data Analysis, Volume 145, 2020. http://www.sciencedirect.com/science/article/pii/S0167947320300074"
            ]
        }
    },
    {
        "Section_id": "VNviaSGM",
        "Description": "This class implements Vertex Nomination via Seeded Graph Matching (VNviaSGM) with the algorithm described in [1].\n\nRather than providing a 1-1 matching for the vertices of two graphs, as in GraphMatch, VNviaSGM ranks the potential matches for a vertex of interst (VOI) in one to graph to the vertices in another graph, based on probability of matching.",
        "Field List": {
            "Parameters": {
                "order_voi_subgraph": "int, positive (default = 1)\nOrder used to create induced subgraph on A about VOI where the max distance between VOI and other nodes is order_voi_subgraph. This induced subgraph will be used to determine what seeds are used when the SGM algorithm is called. If no seeds are in this subgraph about VOI, then a UserWarning is thrown, and nomination_list_ is None.",
                "order_seeds_subgraph": "int, positive (default = 1)\nOrder used to create induced subgraphs on A and B. These subgraphs are centered about the seeds that were determined by the subgraph generated by order_voi_subgraph. These two subgraphs will be passed into the SGM algorithm.",
                "n_init": "int, positive (default = 100)\nNumber of random initializations of the seeded graph matching algorithm (SGM). Increasing the number of restarts will make the probabilities returned more precise.",
                "max_nominations": "int (default = None)\nMax number of nominations to include in the nomination list. If None is passed, then all nominations computed will be returned.",
                "graph_match_kwsdict": "default = {}\nGives users the option to pass custom arguments to the graph matching algorithm. Format should be {'arg_name': arg_value, ...}. See GraphMatch"
            },
            "Attributes": {
                "n_seeds_": "int\nNumber of seeds passed in seedsA that occured in the induced subgraph about VOI",
                "nomination_list_": "2d-array\nAn array containing vertex nominations in the form nomination list = [[j, p_val],...] where p_val is the probability that the VOI matches to node j in graph B (sorted by descending probability)"
            },
            "Methods": {
                "__init__": {
                    "Parameters": {
                        "order_voi_subgraph": "int",
                        "order_seeds_subgraph": "int",
                        "n_init": "int",
                        "max_nominations": "int | None",
                        "graph_match_kws": "Dict[str, Any]"
                    }
                },
                "fit": {
                    "Description": "Fits the model to two graphs.",
                    "Parameters": {
                        "A": "2d-array, square\nAdjacency matrix, the graph where voi is known",
                        "B": "2d-array, square\nAdjacency matrix, the graph where voi is not known",
                        "voi": "int\nVertex of interest",
                        "seeds": "list, 2d-array\nList of length two, of form [seedsA, seedsB]. The elements of seedsA and seedsB are vertex indices from A and B, respectively, which are known to be matched; that is, vertex seedsA[i] is matched to vertex seedsB[i]. Note: len(seedsA)==len(seedsB)."
                    },
                    "Returns": {
                        "self": "An instance of self"
                    }
                },
                "fit_predict": {
                    "Description": "Fits model to two adjacency matrices and returns",
                    "Parameters": {
                        "A": "2d-array, square\nAdjacency matrix, the graph where voi is known",
                        "B": "2d-array, square\nAdjacency matrix, the graph where voi is not known",
                        "voi": "int\nVertex of interest",
                        "seeds": "list, 2d-array\nList of length two, of form [seedsA, seedsB]. The elements of seedsA and seedsB are vertex indices from A and B, respectively, which are known to be matched; that is, vertex seedsA[i] is matched to vertex seedsB[i]. Note: len(seedsA)==len(seedsB)."
                    },
                    "Returns": {
                        "nomination_list_": "2d-array\nThe nomination list."
                    }
                },
                "get_metadata_routing": {
                    "Description": "Get metadata routing of this object.\n\nPlease check User Guide on how the routing mechanism works.",
                    "Returns": {
                        "routing": "MetadataRequest\nA MetadataRequest encapsulating routing information."
                    }
                },
                "get_params": {
                    "Description": "Get parameters for this estimator.",
                    "Parameters": {
                        "deep": "bool, default=True\nIf True, will return the parameters for this estimator and contained subobjects that are estimators."
                    },
                    "Returns": {
                        "params": "dict\nParameter names mapped to their values."
                    }
                },
                "set_fit_request": {
                    "Description": "Request metadata passed to the fit method.\n\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config()). Please see User Guide on how the routing mechanism works.\n\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to fit if provided. The request is ignored if metadata is not provided.\n\nFalse: metadata is not requested and the meta-estimator will not pass it to fit.\n\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\nstr: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\nThe default (sklearn.utils.metadata_routing.UNCHANGED) retains the existing request. This allows you to change the request for some parameters and not others.\n\nNew in version 1.3.",
                    "Parameters": {
                        "A": "str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED\nMetadata routing for A parameter in fit.",
                        "B": "str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED\nMetadata routing for B parameter in fit.",
                        "seeds": "str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED\nMetadata routing for seeds parameter in fit.",
                        "voi": "str, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED\nMetadata routing for voi parameter in fit."
                    },
                    "Returns": {
                        "self": "object\nThe updated object."
                    }
                }
            }
        },
        "Rubric": {
            "Note": "VNviaSGM generates an initial induced subgraph about the VOI to determine which seeds are close enough to be used. If no seeds are close enough, then a warning is thrown and nomination_list_ is set to None.\n\nAll the seeds that are close enough are then used to generate subgraphs in both A and B. These subgraphs are matched using several random initializations of the seeded graph matching algorithm (SGM), and a nomination list is returned. See GraphMatch for SGM docs",
            "References": [
                "Patsolic, HG, Park, Y, Lyzinski, V, Priebe, CE. Vertex nomination via seeded graph matching. Stat Anal Data Min: The ASA Data Sci Journal. 2020; 13: 229\u2013 244. https://doi.org/10.1002/sam.11454"
            ]
        }
    },
    {
        "Section_id": "modularity",
        "Description": "Given an undirected graph and a dictionary of vertices to community ids, calculate the modularity.",
        "Field List": {
            "Parameters": {
                "graph": "Graph\nAn undirected graph",
                "partitions": "Dict[Any, int]\nA dictionary representing a community partitioning scheme with the keys being the vertex and the value being a community id.",
                "weight_attribute": "str\nThe edge data attribute on the graph that contains a float weight for the edge.",
                "resolution": "float\nThe resolution to use when calculating the modularity."
            },
            "Returns": {
                "float": "The sum of the modularity of each of the communities."
            }
        },
        "Rubric": {
            "References": [
                "https://en.wikipedia.org/wiki/Modularity_(networks)"
            ]
        }
    },
    {
        "Section_id": "modularity_components",
        "Description": "Given an undirected, weighted graph and a community partition dictionary, calculates a modularity quantum for each community ID. The sum of these quanta is the modularity of the graph and partitions provided.",
        "Field List": {
            "Parameters": {
                "graph": "Graph\nAn undirected graph",
                "partitions": "Dict[Any, int]\nA dictionary representing a community partitioning scheme with the keys being the vertex and the value being a community id.",
                "weight_attribute": "str\nThe edge data attribute on the graph that contains a float weight for the edge.",
                "resolution": "float\nThe resolution to use when calculating the modularity."
            },
            "Returns": {
                "Dict[int, float]": "A dictionary of the community id to the modularity component of that community"
            }
        }
    },
    {
        "Section_id": "leiden",
        "Description": "Leiden is a global network partitioning algorithm. Given a graph, it will iterate through the network node by node, and test for an improvement in our quality maximization function by speculatively joining partitions of each neighboring node.\n\nThis process continues until no moves are made that increases the partitioning quality.",
        "Field List": {
            "Parameters": {
                "graph": "GraphRepresentation\nA graph representation, whether a weighted edge list referencing an undirected graph, an undirected networkx graph, or an undirected adjacency matrix in either numpy.ndarray or scipy.sparse.csr_array form. Please see the Notes section regarding node ids used.",
                "starting_communities": "Optional[Dict[Any, int]]\nDefault is None. An optional community mapping dictionary that contains a node id mapping to the community it belongs to. Please see the Notes section regarding node ids used.\n\nIf no community map is provided, the default behavior is to create a node community identity map, where every node is in their own community.",
                "extra_forced_iterations": "int\nDefault is 0. Leiden will run until a maximum quality score has been found for the node clustering and no nodes are moved to a new cluster in another iteration. As there is an element of randomness to the Leiden algorithm, it is sometimes useful to set extra_forced_iterations to a number larger than 0 where the process is forced to attempt further refinement.",
                "resolution": "Union[int, float]\nDefault is 1.0. Higher resolution values lead to more communities and lower resolution values leads to fewer communities. Must be greater than 0.",
                "randomness": "Union[int, float]\nDefault is 0.001. The larger the randomness value, the more exploration of the partition space is possible. This is a major difference from the Louvain algorithm, which is purely greedy in the partition exploration.",
                "use_modularity": "bool\nDefault is True. If False, will use a Constant Potts Model (CPM).",
                "random_seed": "Optional[int]\nDefault is None. Can provide an optional seed to the PRNG used in Leiden for deterministic output.",
                "weight_attribute": "str\nDefault is weight. Only used when creating a weighed edge list of tuples when the source graph is a networkx graph. This attribute corresponds to the edge data dict key.",
                "is_weighted": "Optional[bool]\nDefault is None. Only used when creating a weighted edge list of tuples when the source graph is an adjacency matrix. The graspologic.utils.is_unweighted() function will scan these matrices and attempt to determine whether it is weighted or not. This flag can short circuit this test and the values in the adjacency matrix will be treated as weights.",
                "weight_default": "Union[int, float]\nDefault is 1.0. If the graph is a networkx graph and the graph does not have a fully weighted sequence of edges, this default will be used. If the adjacency matrix is found or specified to be unweighted, this weight_default will be used for every edge.",
                "check_directed": "bool\nDefault is True. If the graph is an adjacency matrix, we will attempt to ascertain whether it is directed or undirected. As our leiden implementation is only known to work with an undirected graph, this function will raise an error if it is found to be a directed graph. If you know it is undirected and wish to avoid this scan, you can set this value to False and only the lower triangle of the adjacency matrix will be used to generate the weighted edge list.",
                "trials": "int\nDefault is 1. Runs leiden trials times, keeping the best partitioning as judged by the quality maximization function (default: modularity, see use_modularity parameter for details). This differs from extra_forced_iterations by starting over from scratch each for each trial, while extra_forced_iterations attempts to make microscopic adjustments from the \"final\" state."
            },
            "Returns": {
                "Dict[Any, int]": "The results of running leiden over the provided graph, a dictionary containing mappings of node -> community id. Isolate nodes in the input graph are not returned in the result."
            }
        },
        "Rubric": {
            "Note": "No two different nodes are allowed to encode to the same str representation, e.g. node_a id of \"1\" and node_b id of 1 are different object types but str(node_a) == str(node_b). This collision will result in a ValueError",
            "References": [
                "Traag, V.A.; Waltman, L.; Van, Eck N.J. \"From Louvain to Leiden: guaranteeing well-connected communities\", Scientific Reports, Vol. 9, 2019",
                "https://github.com/microsoft/graspologic-native"
            ]
        }
    },
    {
        "Section_id": "HierarchicalCluster",
        "Description": "Create new instance of HierarchicalCluster(node, cluster, parent_cluster, level, is_final_cluster)",
        "Field List": {
            "Attributes": {
                "node": "Any\nNode id",
                "cluster": "int\nLeiden cluster id",
                "parent_cluster": "int | None\nOnly used when level != 0, but will indicate the previous cluster id that this node was in",
                "level": "int\nEach time a community has a higher population than we would like, we create a subnetwork of that community and process it again to break it into smaller chunks. Each time we detect this, the level increases by 1",
                "is_final_cluster": "bool\nWhether this is the terminal cluster in the hierarchical leiden process or not"
            },
            "Methods": {
                "__new__": {
                    "Parameters": {
                        "node": "Any",
                        "cluster": "int",
                        "parent_cluster": "int | None",
                        "level": "int",
                        "is_final_cluster": "bool"
                    }
                }
            }
        }
    },
    {
        "Section_id": "HierarchicalClusters",
        "Description": "HierarchicalClusters is a subclass of Python's list class with two helper methods for retrieving dictionary views of the first and final level of hierarchical clustering in dictionary form. The rest of the HierarchicalCluster entries in this list can be seen as a transition state log of our graspologic.partition.hierarchical_leiden() process as it continuously tries to break down communities over a certain size, with the two helper methods on this list providing you the starting point community map and ending point community map.",
        "Field List": {
            "Methods": {
                "__init__": {},
                "__new__": {},
                "append": {},
                "clear": {},
                "copy": {},
                "count": {},
                "extend": {},
                "index": {},
                "insert": {},
                "pop": {},
                "remove": {},
                "reverse": {},
                "sort": {},
                "first_level_hierarchical_clustering": {
                    "Returns": {
                        "Dict[Any, int]": "The initial leiden algorithm clustering results as a dictionary of node id to community id."
                    }
                },
                "final_level_hierarchical_clustering": {
                    "Returns": {
                        "Dict[Any, int]": "The last leiden algorithm clustering results as a dictionary of node id to community id."
                    }
                }
            }
        }
    },
    {
        "Section_id": "hierarchical_leiden",
        "Description": "Leiden is a global network partitioning algorithm. Given a graph, it will iterate through the network node by node, and test for an improvement in our quality maximization function by speculatively joining partitions of each neighboring node.\n\nThis process continues until no moves are made that increases the partitioning quality.\n\nUnlike the function graspologic.partition.leiden(), this function does not stop after maximization has been achieved. On some large graphs, it's useful to identify particularly large communities whose membership counts exceed max_cluster_size and induce a subnetwork solely out of that community. This subnetwork is then treated as a wholly separate entity, leiden is run over it, and the new, smaller communities are then mapped into the original community map space.\n\nThe results also differ substantially; the returned List[HierarchicalCluster] is more of a log of state at each level. All HierarchicalClusters at level 0 should be considered to be the results of running graspologic.partition.leiden(). Every community whose membership is greater than max_cluster_size will then also have entries where level == 1, and so on until no communities are greater in population than max_cluster_size OR we are unable to break them down any further.\n\nOnce a node's membership registration in a community cannot be changed any further, it is marked with the flag graspologic.partition.HierarchicalCluster.is_final_cluster = True.",
        "Field List": {
            "Parameters": {
                "graph": "GraphRepresentation\nA graph representation, whether a weighted edge list referencing an undirected graph, an undirected networkx graph, or an undirected adjacency matrix in either numpy.ndarray or scipy.sparse.csr_array form. Please see the Notes section regarding node ids used.",
                "max_cluster_size": "int\nDefault is 1000. Any partition or cluster with membership >= max_cluster_size will be isolated into a subnetwork. This subnetwork will be used for a new leiden global partition mapping, which will then be remapped back into the global space after completion. Once all clusters with membership >= max_cluster_size have been completed, the level increases and the partition scheme is scanned again for any new clusters with membership >= max_cluster_size and the process continues until every cluster's membership is < max_cluster_size or if they cannot be broken into more than one new community.",
                "starting_communities": "Optional[Dict[Any, int]]\nDefault is None. An optional community mapping dictionary that contains a node id mapping to the community it belongs to. Please see the Notes section regarding node ids used.\n\nIf no community map is provided, the default behavior is to create a node community identity map, where every node is in their own community.",
                "extra_forced_iterations": "int\nDefault is 0. Leiden will run until a maximum quality score has been found for the node clustering and no nodes are moved to a new cluster in another iteration. As there is an element of randomness to the Leiden algorithm, it is sometimes useful to set extra_forced_iterations to a number larger than 0 where the entire process is forced to attempt further refinement.",
                "resolution": "Union[int, float]\nDefault is 1.0. Higher resolution values lead to more communities and lower resolution values leads to fewer communities. Must be greater than 0.",
                "randomness": "Union[int, float]\nDefault is 0.001. The larger the randomness value, the more exploration of the partition space is possible. This is a major difference from the Louvain algorithm, which is purely greedy in the partition exploration.",
                "use_modularity": "bool\nDefault is True. If False, will use a Constant Potts Model (CPM).",
                "random_seed": "Optional int\nDefault is None. Can provide an optional seed to the PRNG used in Leiden for deterministic output.",
                "weight_attribute": "str\nDefault is weight. Only used when creating a weighed edge list of tuples when the source graph is a networkx graph. This attribute corresponds to the edge data dict key.",
                "is_weighted": "Optional[bool]\nDefault is None. Only used when creating a weighted edge list of tuples when the source graph is an adjacency matrix. The graspologic.utils.is_unweighted() function will scan these matrices and attempt to determine whether it is weighted or not. This flag can short circuit this test and the values in the adjacency matrix will be treated as weights.",
                "weight_default": "Union[int, float]\nDefault is 1.0. If the graph is a networkx graph and the graph does not have a fully weighted sequence of edges, this default will be used. If the adjacency matrix is found or specified to be unweighted, this weight_default will be used for every edge.",
                "check_directed": "bool\nDefault is True. If the graph is an adjacency matrix, we will attempt to ascertain whether it is directed or undirected. As our leiden implementation is only known to work with an undirected graph, this function will raise an error if it is found to be a directed graph. If you know it is undirected and wish to avoid this scan, you can set this value to False and only the lower triangle of the adjacency matrix will be used to generate the weighted edge list."
            },
            "Returns": {
                "HierarchicalClusters": "The results of running hierarchical leiden over the provided graph, a list of HierarchicalClusters identifying the state of every node and cluster at each level. Isolate nodes in the input graph"
            }
        },
        "Rubric": {
            "Note": "No two different nodes are allowed to encode to the same str representation, e.g. node_a id of \"1\" and node_b id of 1 are different object types but str(node_a) == str(node_b). This collision will result in a ValueError\nThis function is implemented in the graspologic-native Python module, a module written in Rust for Python.",
            "References": [
                "Traag, V.A.; Waltman, L.; Van, Eck N.J. \"From Louvain to Leiden: guaranteeing well-connected communities\",Scientific Reports, Vol. 9, 2019",
                "https://github.com/microsoft/graspologic-native"
            ]
        }
    },
    {
        "Section_id": "check_argument_types",
        "Description": "Raises a TypeError if the provided value is not one of the required_types",
        "Field List": {
            "Parameters": {
                "value": "Any\nThe argument to test for valid type",
                "required_types": "Union[type, Tuple[type, ...]]\nA type or a n-ary tuple of types to test for validity",
                "message": "str\nThe message to use as the body of the TypeError"
            },
            "Returns": {
                "None": "None"
            }
        }
    },
    {
        "Section_id": "check_optional_argument_types",
        "Description": "Raises a TypeError if the provided value is not one of the required_types, unless it is None. A None value is treated as a valid type.",
        "Field List": {
            "Parameters": {
                "value": "Any\nThe argument to test for valid type",
                "required_types": "Union[type, Tuple[type, ...]]\nA type or a n-ary tuple of types to test for validity",
                "message": "str\nThe message to use as the body of the TypeError"
            },
            "Returns": {
                "None": "None"
            }
        }
    },
    {
        "Section_id": "check_argument",
        "Description": "Raises a ValueError if the provided check is false",
        "Field List": {
            "Parameters": {
                "check": "bool",
                "message": "str"
            },
            "Returns": {
                "None": "None"
            }
        }
    },
    {
        "Section_id": "is_real_weighted",
        "Description": "Checks every edge in graph to ascertain whether it has:\n\na weight_attribute key in the data dictionary for the edge\nif that weight_attribute value is a subclass of numbers.Real\n\nIf any edge fails this test, it returns False, else True",
        "Field List": {
            "Parameters": {
                "graph": "Union[nx.Graph, nx.DiGraph]\nThe networkx graph to test",
                "weight_attribute": "str\nThe edge dictionary data attribute that holds the weight. Default is weight."
            },
            "Returns": {
                "bool": "True if every edge has a numeric weight_attribute weight, False if any edge fails this test"
            }
        }
    },
    {
        "Section_id": "GraphBuilder",
        "Description": "GraphBuilder is a simple builder for networkx Graphs. To use less memory, it automatically maps all node ids of any hashable type to int.\n\nIn other words, if you can use it as a key in a dictionary, it will work.",
        "Field List": {
            "Parameters": {
                "directed": "bool\nUsed to create either a networkx.Graph or networkx.DiGraph object."
            },
            "Methods": {
                "__init__": {
                    "Parameters": {
                        "directed": "bool"
                    }
                },
                "add_edge": {
                    "Description": "Adds a weighted edge between the provided source and target. The source and target id are converted to a unique int.",
                    "Parameters": {
                        "source": "Any\nsource node id",
                        "target": "Any\ntarget node id",
                        "weight": "Union[int, float] (default=1.0)\nThe weight for the edge. If none is provided, the weight is defaulted to 1.",
                        "sum_weight": "bool(default=True)\nIf an edge between the source and target already exist, should we sum the edge weights or overwrite the edge weight with the provided weight value.",
                        "attributes": "kwargs\nThe attributes kwargs are presumed to be attributes that should be added to the edge dictionary for source and target."
                    },
                    "Returns": {
                        "None": "None"
                    }
                },
                "build": {
                    "Returns": {
                        "Tuple[Graph | DiGraph, Dict[Any, int], List[Any]]": "The returned tuple is either an undirected or directed graph, depending on the constructor argument directed. The second value in the tuple is a dictionary of original node ids to their assigned integer ids. The third and final value in the tuple is a List of original node ids, where the index corresponds to the assigned integer and the value is the corresponding original ID."
                    }
                }
            }
        }
    },
    {
        "Section_id": "embeddings",
        "Description": "Embeddings is an iterable, indexed interface over the parallel numpy arrays that are generated by our embedding functions.",
        "Field List": {
            "Parameters": {
                "labels": "np.ndarray\nThe node labels that are positionally correlated with the embeddings. The dtype of labels is any object stored in a networkx Graph object, though type uniformity will be required",
                "embeddings": "np.ndarray\nThe embedded values generated by the embedding technique."
            },
            "Methods": {
                "__init__": {
                    "Parameters": {
                        "labels": "np.ndarry\nThe node labels that are positionally correlated with the embeddings. The dtype of labels is any object stored in a networkx Graph object, though type uniformity will be required",
                        "embeddings": "np.ndarray\nThe embedded values generated by the embedding technique."
                    },
                    "Returns": {
                        "beartype.roar.BeartypeCallHintParamViolation": "if the types are invalid",
                        "ValueError": "if the row count of labels does not equal the row count of embeddings"
                    },
                    "example": [
                        "import numpy as np\nraw_embeddings = np.array([[1,2,3,4,5], [6,4,2,0,8]])\nlabels = np.array([\"monotonic\", \"not_monotonic\"])\nembeddings_obj = Embeddings(labels, raw_embeddings)\nembeddings_obj[0]\n('monotonic', array([1, 2, 3, 4, 5]))\nlen(embeddings_obj)\n2\nlist(iter(embeddings_obj))\n[('monotonic', array([1, 2, 3, 4, 5])), ('not_monotonic', array([6, 4, 2, 0, 8]))]\nembeddings_lookup = embeddings_obj.as_dict()\nembeddings_lookup[\"not_monotonic\"]\narray([6, 4, 2, 0, 8])"
                    ]
                },
                "labels": {
                    "Returns": {
                        "ndarray": "ndarray"
                    }
                },
                "embeddings": {
                    "Returns": {
                        "ndarray": "ndarray"
                    }
                },
                "as_dict": {
                    "Returns": {
                        "EmbeddingsView": "EmbeddingsView"
                    }
                }
            }
        },
        "Rubric": {
            "example": [
                "import numpy as np\nraw_embeddings = np.array([[1,2,3,4,5], [6,4,2,0,8]])\nlabels = np.array([\"monotonic\", \"not_monotonic\"])\nembeddings_obj = Embeddings(labels, raw_embeddings)\nembeddings_obj[0]\n('monotonic', array([1, 2, 3, 4, 5]))\nlen(embeddings_obj)\n2\nlist(iter(embeddings_obj))\n[('monotonic', array([1, 2, 3, 4, 5])), ('not_monotonic', array([6, 4, 2, 0, 8]))]\nembeddings_lookup = embeddings_obj.as_dict()\nembeddings_lookup[\"not_monotonic\"]\narray([6, 4, 2, 0, 8])"
            ]
        }
    },
    {
        "Section_id": "adjacency_spectral_embedding",
        "Description": "Given a directed or undirected networkx graph (not multigraph), generate an Embeddings object.\n\nAdjacency spectral embeddings are extremely egocentric, implying that results are slanted toward the core-periphery of each node. This is in contrast to Laplacian spectral embeddings, which look further into the latent space when it captures change.\n\nAdjacency Spectral Embedding Tutorial\n\nGraphs will always have their diagonal augmented. In other words, a self-loop will be created for each node with a weight corresponding to the weighted degree.\n\nLastly, all weights will be rescaled based on their relative rank in the graph, which is beneficial in minimizing anomalous results if some edge weights are extremely atypical of the rest of the graph.",
        "Field List": {
            "Parameters": {
                "graph": "Union[nx.Graph, nx.OrderedGraph, nx.DiGraph, nx.OrderedDiGraph]\nAn undirected or directed graph. The graph must:\n\nbe fully numerically weighted (every edge must have a real, numeric weight or else it will be treated as an unweighted graph)\nbe a basic graph (meaning it should not be a multigraph; if you have a multigraph you must first decide how you want to handle the weights of the edges between two nodes, whether summed, averaged, last-wins, maximum-weight-only, etc)",
                "dimensions": "int\nDimensions to use for the svd solver. For undirected graphs, if elbow_cut==None, you will receive an embedding that has nodes rows and dimensions columns. For directed graphs, if elbow_cut==None, you will receive an embedding that has nodes rows and 2*dimensions columns. If elbow_cut is specified to be not None, we will cut the embedding at elbow_cut elbow, but the provided dimensions will be used in the creation of the SVD.",
                "elbow_cut": "Optional[int]\nUsing a process described by Zhu & Ghodsi in their paper \"Automatic dimensionality selection from the scree plot via the use of profile likelihood\", truncate the dimensionality of the return on the elbow_cut-th elbow. By default this value is None but can be used to reduce the dimensionality of the returned tensors.",
                "svd_solver_algorithm": "str\nSVD solver to use:\n\n'randomized'\nComputes randomized svd using sklearn.utils.extmath.randomized_svd()\n\n'full'\nComputes full svd using scipy.linalg.svd() Does not support graph input of type scipy.sparse.csr_array\n\n'truncated'\nComputes truncated svd using scipy.sparse.linalg.svds()",
                "svd_solver_iterations": "int\nNumber of iterations for randomized SVD solver. Not used by 'full' or 'truncated'. The default is larger than the default in randomized_svd to handle sparse matrices that may have large slowly decaying spectrum.",
                "svd_seed": "Optional[int]\nUsed to seed the PRNG used in the randomized svd solver algorithm.",
                "weight_attribute": "str\nThe edge dictionary key that contains the weight of the edge."
            },
            "Returns": {
                "Embeddings": "Embeddings"
            }
        },
        "Rubric": {
            "Note": "The singular value decomposition:\n\nis used to find an orthonormal basis for a matrix, which in our case is the adjacency matrix of the graph. These basis vectors (in the matrices U or V) are ordered according to the amount of variance they explain in the original matrix. By selecting a subset of these basis vectors (through our choice of dimensionality reduction) we can find a lower dimensional space in which to represent the graph.",
            "References": [
                "Sussman, D.L., Tang, M., Fishkind, D.E., Priebe, C.E. \"A Consistent Adjacency Spectral Embedding for Stochastic Blockmodel Graphs,\" Journal of the American Statistical Association, Vol. 107(499), 2012",
                "Levin, K., Roosta-Khorasani, F., Mahoney, M. W., & Priebe, C. E. (2018). Out-of-sample extension of graph adjacency spectral embedding. PMLR: Proceedings of Machine Learning Research, 80, 2975-2984.",
                "Zhu, M. and Ghodsi, A. (2006). Automatic dimensionality selection from the scree plot via the use of profile likelihood. Computational Statistics & Data Analysis, 51(2), pp.918-930."
            ]
        }
    },
    {
        "Section_id": "laplacian_spectral_embedding",
        "Description": "Given a directed or undirected networkx graph (not multigraph), generate an Embeddings object.\n\nThe laplacian spectral embedding process is similar to the adjacency spectral embedding process, with the key differentiator being that the LSE process looks further into the latent space when it captures changes, whereas the ASE process is egocentric and focused on immediate differentiators in a node's periphery.\n\nAll weights will be rescaled based on their relative rank in the graph, which is beneficial in minimizing anomalous results if some edge weights are extremely atypical of the rest of the graph.",
        "Field List": {
            "Parameters": {
                "graph": "Union[nx.Graph, nx.OrderedGraph, nx.DiGraph, nx.OrderedDiGraph]\nAn undirected or directed graph. The graph must:\n\nbe fully numerically weighted (every edge must have a real, numeric weight or else it will be treated as an unweighted graph)\nbe a basic graph (meaning it should not be a multigraph; if you have a multigraph you must first decide how you want to handle the weights of the edges between two nodes, whether summed, averaged, last-wins, maximum-weight-only, etc)",
                "form": "str\nSpecifies the type of Laplacian normalization to use. Allowed values are: { \"DAD\", \"I-DAD\", \"R-DAD\" }. See to_laplacian() for more details regarding form.",
                "dimensions": "int\nDimensions to use for the svd solver. For undirected graphs, if elbow_cut==None, you will receive an embedding that has nodes rows and dimensions columns. For directed graphs, if elbow_cut==None, you will receive an embedding that has nodes rows and 2*dimensions columns. If elbow_cut is specified to be not None, we will cut the embedding at elbow_cut elbow, but the provided dimensions will be used in the creation of the SVD.",
                "elbow_cut": "Optional[int]\nUsing a process described by Zhu & Ghodsi in their paper \"Automatic dimensionality selection from the scree plot via the use of profile likelihood\", truncate the dimensionality of the return on the elbow_cut-th elbow. By default this value is None but can be used to reduce the dimensionality of the returned tensors.",
                "svd_solver_algorithm": "str\nallowed values: {'randomized', 'full', 'truncated'}\n\nSVD solver to use:\n\n'randomized'\nComputes randomized svd using sklearn.utils.extmath.randomized_svd()\n\n'full'\nComputes full svd using scipy.linalg.svd() Does not support graph input of type scipy.sparse.csr_array\n\n'truncated'\nComputes truncated svd using scipy.sparse.linalg.svds()",
                "svd_solver_iterations": "int\nNumber of iterations for randomized SVD solver. Not used by 'full' or 'truncated'. The default is larger than the default in randomized_svd to handle sparse matrices that may have large slowly decaying spectrum.",
                "svd_seed": "Optional[int]\nUsed to seed the PRNG used in the randomized svd solver algorithm.",
                "weight_attribute": "str\nThe edge dictionary key that contains the weight of the edge.",
                "regularizer": "Optional[numbers.Real]\nOnly used when form=\"R-DAD\". Must be None or nonnegative. Constant to be added to the diagonal of degree matrix. If None, average node degree is added. If int or float, must be >= 0."
            },
            "Returns": {
                "Embeddings": "Embeddings"
            }
        },
        "Rubric": {
            "Note": "The singular value decomposition:\n\nis used to find an orthonormal basis for a matrix, which in our case is the Laplacian matrix of the graph. These basis vectors (in the matrices U or V) are ordered according to the amount of variance they explain in the original matrix. By selecting a subset of these basis vectors (through our choice of dimensionality reduction) we can find a lower dimensional space in which to represent the graph.",
            "References": [
                "Sussman, D.L., Tang M., Fishkind, D.E., Priebe, C.E. \"A Consistent Adjacency Spectral Embedding for Stochastic Blockmodel Graphs,\" Journal of the American Statistical Association, Vol. 107(499), 2012.",
                "Von Luxburg, Ulrike. \"A tutorial on spectral clustering,\" Statistics and computing, Vol. 17(4), 2007.",
                "Rohe, Karl, Sourav Chatterjee, and Bin Yu. \"Spectral clustering and the high-dimensional stochastic blockmodel,\" The Annals of Statistics, Vol. 39(4), pp. 1878-1915, 2011.",
                "Zhu, M. and Ghodsi, A. \"Automatic dimensionality selection from the scree plot via the use of profile likelihood,\" Computational Statistics & Data Analysis, Vol. 51(2), pp. 918-930, 2006."
            ]
        }
    },
    {
        "Section_id": "omnibus_embedding_pairwise",
        "Description": "Generates a pairwise omnibus embedding for each pair of graphs in a list of graphs using the adjacency matrix. If given graphs A, B, and C, the embeddings will be computed for A, B and B, C.\n\nIf the node labels differ between each pair of graphs, then those nodes will only be found in the resulting embedding if they exist in the largest connected component of the union of all edges across all graphs in the time series.\n\nGraphs will always have their diagonal augmented. In other words, a self-loop will be created for each node with a weight corresponding to the weighted degree.\n\nLastly, all weights will be rescaled based on their relative rank in the graph, which is beneficial in minimizing anomalous results if some edge weights are extremely atypical of the rest of the graph.",
        "Field List": {
            "Parameters": {
                "graphs": "List[Union[nx.Graph, nx.OrderedGraph, nx.DiGraph, nx.OrderedDiGraph]]\nA list of undirected or directed graphs. The graphs must:\n\nbe fully numerically weighted (every edge must have a real, numeric weight or else it will be treated as an unweighted graph)\nbe a basic graph (meaning it should not be a multigraph; if you have a multigraph you must first decide how you want to handle the weights of the edges between two nodes, whether summed, averaged, last-wins, maximum-weight-only, etc)",
                "dimensions": "int\nDimensions to use for the svd solver. For undirected graphs, if elbow_cut==None, you will receive an embedding that has nodes rows and dimensions columns. For directed graphs, if elbow_cut==None, you will receive an embedding that has nodes rows and 2*dimensions columns. If elbow_cut is specified to be not None, we will cut the embedding at elbow_cut elbow, but the provided dimensions will be used in the creation of the SVD.",
                "elbow_cut": "Optional[int]\nUsing a process described by Zhu & Ghodsi in their paper \"Automatic dimensionality selection from the scree plot via the use of profile likelihood\", truncate the dimensionality of the return on the elbow_cut-th elbow. By default this value is None but can be used to reduce the dimensionality of the returned tensors.",
                "svd_solver_algorithm": "str\nallowed values: {'randomized', 'full', 'truncated'}\n\nSVD solver to use:\n\n'randomized'\nComputes randomized svd using sklearn.utils.extmath.randomized_svd()\n\n'full'\nComputes full svd using scipy.linalg.svd() Does not support graph input of type scipy.sparse.csr_array\n\n'truncated'\nComputes truncated svd using scipy.sparse.linalg.svds()",
                "svd_solver_iterations": "int\nNumber of iterations for randomized SVD solver. Not used by 'full' or 'truncated'. The default is larger than the default in randomized_svd to handle sparse matrices that may have large slowly decaying spectrum.",
                "svd_seed": "Optional[int]\nUsed to seed the PRNG used in the randomized svd solver algorithm.",
                "weight_attribute": "str\nThe edge dictionary key that contains the weight of the edge.",
                "use_laplacian": "bool\nDetermine whether to use the Laplacian matrix of each graph in order to calculate the omnibus embedding using the Laplacian spectral embedding technique."
            },
            "Returns": {
                "List[Tuple[Embeddings, Embeddings]]": "List of Tuple[Embeddings, Embeddings]"
            }
        },
        "Rubric": {
            "References": [
                "Levin, K., Athreya, A., Tang, M., Lyzinski, V., & Priebe, C. E. \"A central limit theorem for an omnibus embedding of multiple random dot product graphs,\" Data Mining Workshops (ICDMW), 2017 IEEE International Conference on, 2017",
                "Sussman, D.L., Tang, M., Fishkind, D.E., Priebe, C.E. \"A Consistent Adjacency Spectral Embedding for Stochastic Blockmodel Graphs,\" Journal of the American Statistical Association, Vol. 107(499), 2012",
                "Levin, K., Roosta-Khorasani, F., Mahoney, M. W., & Priebe, C. E. \"Out-of-sample extension of graph adjacency spectral embedding,\" PMLR: Proceedings of Machine Learning Research, 80, 2975-2984.",
                "Zhu, M. and Ghodsi, A. \"Automatic dimensionality selection from the scree plot via the use of profile likelihood,\" Computational Statistics & Data Analysis, 51(2), pp.918-930."
            ]
        }
    },
    {
        "Section_id": "heatmap",
        "Description": "Plots a graph as a color-encoded matrix.\n\nNodes can be grouped by providing inner_hier_labels or both inner_hier_labels and outer_hier_labels. Nodes can also be sorted by the degree from largest to smallest degree nodes. The nodes will be sorted within each group if labels are also provided.",
        "Field List": {
            "Parameters": {
                "X": "nx.Graph or np.ndarray object\nGraph or numpy matrix to plot",
                "transform": "None, or string {'log', 'log10', 'zero-boost', 'simple-all', 'simple-nonzero'}\n'log'\nPlots the natural log of all nonzero numbers\n\n'log10'\nPlots the base 10 log of all nonzero numbers\n\n'zero-boost'\nPass to ranks method. preserves the edge weight for all 0s, but ranks the other edges as if the ranks of all 0 edges has been assigned.\n\n'simple-all'\nPass to ranks method. Assigns ranks to all non-zero edges, settling ties using the average. Ranks are then scaled by  where n is the number of nodes\n\n'simple-nonzero'\nPass to ranks method. Same as simple-all, but ranks are scaled by ",
                "figsize": "Tuple[int, int]\nWidth, height in inches.",
                "title": "str\nTitle of plot.",
                "context": "str\nThe name of a preconfigured set.",
                "font_scale": "int\nSeparate scaling factor to independently scale the size of the font elements.",
                "xticklabels": "bool\nIf list-like, plot these alternate labels as the ticklabels.",
                "yticklabels": "bool\nIf list-like, plot these alternate labels as the ticklabels.",
                "cmap": "str\nValid matplotlib color map.",
                "vmin": "float\nValues to anchor the colormap, otherwise they are inferred from the data and other keyword arguments.",
                "vmax": "float\nValues to anchor the colormap, otherwise they are inferred from the data and other keyword arguments.",
                "center": "int\nThe value at which to center the colormap",
                "cbar": "bool\nWhether to draw a colorbar.",
                "inner_hier_labels": "ndarray | List[Any] | None\nCategorical labeling of the nodes. If not None, will group the nodes according to these labels and plot the labels on the marginal",
                "outer_hier_labels": "ndarray | List[Any] | None\nCategorical labeling of the nodes, ignored without inner_hier_labels If not None, will plot these labels as the second level of a hierarchy on the marginals",
                "hier_label_fontsize": "int\nSize (in points) of the text labels for the inner_hier_labels and outer_hier_labels.",
                "ax": "Axes | None\nAxes in which to draw the plot, otherwise will generate its own axes",
                "title_pad": "float\nCustom padding to use for the distance of the title from the heatmap. Autoscales if None",
                "sort_nodes": "bool\nWhether or not to sort the nodes of the graph by the sum of edge weights (degree for an unweighted graph). If inner_hier_labels is passed and sort_nodes is True, will sort nodes this way within block.",
                "kwargs": "Any\nadditional plotting arguments passed to Seaborn's heatmap"
            },
            "Returns": {
                "Axes": "Axes"
            }
        }
    },
    {
        "Section_id": "gridplot",
        "Description": "Plots multiple graphs on top of each other with dots as edges.\n\nThis function is useful for visualizing multiple graphs simultaneously. The size of the dots correspond to the edge weights of the graphs, and colors represent input graphs.",
        "Field List": {
            "Parameters": {
                "X": "list of nx.Graph or np.ndarray object\nList of nx.Graph or numpy arrays to plot",
                "labels": "list of str\nList of strings, which are labels for each element in X. len(X) == len(labels).",
                "transform": "None, or string {'log', 'log10', 'zero-boost', 'simple-all', 'simple-nonzero'}\n'log'\nPlots the natural log of all nonzero numbers\n\n'log10'\nPlots the base 10 log of all nonzero numbers\n\n'zero-boost'\nPass to ranks method. preserves the edge weight for all 0s, but ranks the other edges as if the ranks of all 0 edges has been assigned.\n\n'simple-all'\nPass to ranks method. Assigns ranks to all non-zero edges, settling ties using the average. Ranks are then scaled by  where n is the number of nodes\n\n'simple-nonzero'\nPass to ranks method. Same as simple-all, but ranks are scaled by ",
                "height": "int\nHeight of figure in inches.",
                "title": "str\nTitle of plot.",
                "context": "str\nThe name of a preconfigured set.",
                "font_scale": "float\nSeparate scaling factor to independently scale the size of the font elements.",
                "palette": "str\nSet of colors for mapping the hue variable. If a dict, keys should be values in the hue variable. For acceptable string arguments, see the palette options at Choosing Colormaps in Matplotlib",
                "alpha": "float [0, 1]\nAlpha value of plotted gridplot points",
                "sizes": "Tuple[int, int]\nMin and max size to plot edge weights",
                "legend_name": "str\nName to plot above the legend",
                "inner_hier_labels": "ndarray | List[Any] | None\nCategorical labeling of the nodes. If not None, will group the nodes according to these labels and plot the labels on the marginal",
                "outer_hier_labels": "ndarray | List[Any] | None\nCategorical labeling of the nodes, ignored without inner_hier_labels If not None, will plot these labels as the second level of a hierarchy on the marginals",
                "hier_label_fontsize": "int\nSize (in points) of the text labels for the inner_hier_labels and outer_hier_labels.",
                "title_pad": "int, float or None\nCustom padding to use for the distance of the title from the heatmap. Autoscales if None",
                "sort_nodes": "bool\nWhether or not to sort the nodes of the graph by the sum of edge weights (degree for an unweighted graph). If inner_hier_labels is passed and sort_nodes is True, will sort nodes this way within block."
            },
            "Returns": {
                "Axes": "Axes"
            }
        }
    },
    {
        "Section_id": "pairplot",
        "Description": "Plot pairwise relationships in a dataset.\n\nBy default, this function will create a grid of axes such that each dimension in data will by shared in the y-axis across a single row and in the x-axis across a single column.\n\nThe off-diagonal axes show the pairwise relationships displayed as scatterplot. The diagonal axes show the univariate distribution of the data for that dimension displayed as either a histogram or kernel density estimates (KDEs).",
        "Field List": {
            "Parameters": {
                "X": "array-like, shape (n_samples, n_features)\nInput data.",
                "labels": "array-like or list, shape (n_samples), optional\nLabels that correspond to each sample in X.",
                "col_names": "array-like or list, shape (n_features), optional\nNames or labels for each feature in X. If not provided, the default will be Dimension 1, Dimension 2, etc.",
                "title": "str, optional\nTitle of plot.",
                "legend_name": "str, optional\nTitle of the legend.",
                "variables": "list of variable names, optional\nVariables to plot based on col_names, otherwise use every column with a numeric datatype.",
                "height": "int, optional, default: 10\nHeight of figure in inches.",
                "context": "None, or one of {paper, notebook, talk (default), poster}\nThe name of a preconfigured set.",
                "font_scale": "float, optional, default: 1\nSeparate scaling factor to independently scale the size of the font elements.",
                "palette": "str, dict, optional, default: 'Set1'\nSet of colors for mapping the hue variable. If a dict, keys should be values in the hue variable. For acceptable string arguments, see the palette options at Choosing Colormaps in Matplotlib.",
                "alpha": "float, optional, default: 0.7\nOpacity value of plotter markers between 0 and 1",
                "size": "float or int, optional, default: 50\nSize of plotted markers.",
                "marker": "string, optional, default: '.'\nMatplotlib marker specifier, see the marker options at Matplotlib style marker specification"
            },
            "Returns": {
                "PairGrid": "PairGrid"
            }
        }
    },
    {
        "Section_id": "pairplot_with_gmm",
        "Description": "Plot pairwise relationships in a dataset, also showing a clustering predicted by a Gaussian mixture model.\n\nBy default, this function will create a grid of axes such that each dimension in data will by shared in the y-axis across a single row and in the x-axis across a single column.\n\nThe off-diagonal axes show the pairwise relationships displayed as scatterplot. The diagonal axes show the univariate distribution of the data for that dimension displayed as either a histogram or kernel density estimates (KDEs).",
        "Field List": {
            "Parameters": {
                "X": "array-like, shape (n_samples, n_features)\nInput data.",
                "gmm": "GaussianMixture object\nA fit sklearn.mixture.GaussianMixture object. Gaussian mixture models (GMMs) are probabilistic models for representing data based on normally distributed subpopulations, GMM clusters each data point into a corresponding subpopulation.",
                "labels": "array-like or list, shape (n_samples), optional\nLabels that correspond to each sample in X. If labels are not passed in then labels are predicted by gmm.",
                "label_palette": "str or dict, optional, default: 'Set1'\nPalette used to color points if labels are passed in.",
                "cluster_palette": "str or dict, optional, default: 'Set1'\nPalette used to color GMM ellipses (and points if no labels are passed).",
                "title": "string, default: \"\"\nTitle of the plot.",
                "legend_name": "string, default: None\nName to put above the legend. If None, will be \"Cluster\" if no custom labels are passed, and \"\" otherwise.",
                "context": "None, or one of {talk (default), paper, notebook, poster}\nSeaborn plotting context",
                "font_scale": "float, optional, default: 1\nSeparate scaling factor to independently scale the size of the font elements.",
                "alpha": "float, optional, default: 0.7\nOpacity value of plotter markers between 0 and 1",
                "figsize": "tuple\nThe size of the 2d subplots configuration",
                "histplot_kws": "dict, default: {}\nKeyword arguments passed down to seaborn.histplot()"
            },
            "Returns": {
                "fit": {
                    "Figure": "matplotlib Figure",
                    "Axes": "np.ndarray\nArray of matplotlib Axes"
                }
            }
        }
    },
    {
        "Section_id": "degreeplot",
        "Description": "Plots the distribution of node degrees for the input graph. Allows for sets of node labels, will plot a distribution for each node category.",
        "Field List": {
            "Parameters": {
                "X": "ndarray\ninput graph",
                "labels": "ndarray | List[Any] | None",
                "direction": "str",
                "title": "str",
                "context": "str",
                "font_scale": "float",
                "figsize": "Tuple[int, int]",
                "palette": "str"
            },
            "Returns": {
                "Axes": "Axes"
            }
        }
    },
    {
        "Section_id": "edgeplot",
        "Description": "Plots the distribution of edge weights for the input graph. Allows for sets of node labels, will plot edge weight distribution for each node category.",
        "Field List": {
            "Parameters": {
                "X": "ndarray",
                "labels": "ndarray | List[Any] | None",
                "nonzero": "bool",
                "title": "str",
                "context": "str",
                "font_scale": "float",
                "figsize": "Tuple[int, int]",
                "palette": "str"
            },
            "Returns": {
                "Axes": "Axes"
            }
        }
    },
    {
        "Section_id": "screeplot",
        "Description": "Plots the distribution of singular values for a matrix, either showing the raw distribution or an empirical CDF (depending on cumulative)",
        "Field List": {
            "Parameters": {
                "X": "ndarray",
                "title": "str",
                "context": "str",
                "font_scale": "float",
                "figsize": "Tuple[int, int]",
                "ax": "Axes | None",
                "cumulative": "bool",
                "show_first": "int | None",
                "show_elbow": "bool | int | None"
            },
            "Returns": {
                "Axes": "Axes"
            }
        },
        "Rubric": {
            "References": [
                "Zhu, M. and Ghodsi, A. (2006). Automatic dimensionality selection from the scree plot via the use of profile likelihood. Computational Statistics & Data Analysis, 51(2), pp.918-930."
            ]
        }
    },
    {
        "Section_id": "adjplot",
        "Description": "Sorts and plots a square matrix in various ways, and with optional information added to the margin of the matrix plot.This function is a wrapper around matrixplot which assumes that the plotted matrix is square, and that the rows and columns represent the same items and have the same metadata (e.g. the adjacency matrix of a graph).",
        "Field List": {
            "Parameters": {
                "data": "ndarray\nMatrix to plot, must be square. Sparse matrix input is only accepted if plot_type == 'scattermap'.",
                "ax": "matplotlib axes object (default=None)\nAxes in which to draw the plot. If no axis is passed, one will be created.",
                "meta": "pd.DataFrame or None, (default=None)\nMetadata of the matrix.\nmeta is pd.DataFrame All sorting keywords should only be str or list of str. They should contain references to columns in meta.\nmeta is None\nAll sorting keywords should only array-like with the same length as the corresponding axis of data.",
                "plot_type": "str in {\"heatmap\", \"scattermap\"} (default=\"heatmap\")\n\"heatmap\" will draw the matrix using seaborn.heatmap(), \"scattermap\" will draw each nonzero element of the matrix using seaborn.scatterplot(). \"scattermap\" is recommended for larger sparse matrices.",
                "group": "str, list of str, or array-like, (default=None)\nAttribute(s) by which to group rows/columns of data. If multiple groups are specified, rows/columns will be sorted hierarchically (first by the first group), then within that group by a possible second group, etc.). Behaves similarly to pandas.DataFrame.sort_values().",
                "group_order": "str, list of str, or array-like, (default=\"size\")\nAttribute(s) by which to sort the groups if provided by group. Groups are sorted by the mean of this attribute in ascending order. \"size\" is a special keyword which will sort groups by the number of elements per group.",
                "item_order": "str, list of str, or array-like (default=None)\nAttribute(s) by which to sort the individual rows/columns within each group.",
                "color": "str, list of str, or array-like (default=None)\nAttribute(s) to use for drawing colors on the borders of the matrix plot.",
                "highlight": "str, list of str, or array-like (default=None)\nAttribute(s) in meta by which to draw highlighted separators between specific groups, can be useful for emphasizing a particular region of the plot. Styling of the highlighted separators can be specified via spinestyle_kws.",
                "palette": "str, dict, list of str or dict (default=\"tab10\")\nColormap(s) of the color axes if specified by color.",
                "ticks": "bool, optional (default=True)\nWhether the plot has labels for the groups specified by group.",
                "tick_pad": "int or float (default=None)\nCustom padding to use for the distance between tick axes",
                "color_pad": "int or float (default=None)\nCustom padding to use for the distance between color axes",
                "border": "bool (default=True)\nWhether the plot should have a border.",
                "center": "int (default=0)\nThe value at which to center the colormap when plotting divergent data (only used when plot_type=\"heatmap\").",
                "cmap": "str (default=\"RdBu_r\")\nColormap of the heatmap (only used when plot_type=\"heatmap\").",
                "sizes": "tuple (default=(5, 10))\nMin and max sizes of dots (only used when plot_type=\"scattermap\").",
                "square": "bool (default=False)\nWhether the plot should be square.",
                "gridline_kws": "dict (default=None)\nPlotting arguments for the separators.",
                "spinestyle_kws": "dict (default=None)\nPlotting arguments for the spine border.",
                "highlight_kws": "dict (default=None)\nPlotting arguments for the highlighted separators.",
                "**kwargs": "Additional plotting arguments passed down to the plotting function which will draw the matrix data, see plot_type for more information."
            },
            "Returns": {
                "Axes": "Axes\nAxes in which to draw the plot, by default None",
                "divider": "AxesLocator\nDivider used to add new axes to the plot"
            }
        }
    },
    {
        "Section_id": "matrixplot",
        "Description": "Sorts and plots a matrix in various ways, and with optional information added to the margin of the matrix plot.",
        "Field List": {
            "Parameters": {
                "data": "np.ndarray or scipy.sparse.csr_array with ndim=2\nMatrix to plot. Sparse matrix input is only accepted if plot_type == 'scattermap'.",
                "ax": "matplotlib axes object (default=None)\nAxes in which to draw the plot. If no axis is passed, one will be created.",
                "plot_type": "str in {\"heatmap\", \"scattermap\"} (default=\"heatmap\")\n\"heatmap\" will draw the matrix using seaborn.heatmap(), \"scattermap\" will draw each nonzero element of the matrix using seaborn.scatterplot(). \"scattermap\" is recommended for larger sparse matrices.",
                "{row,col}_meta": "pd.DataFrame or None, (default=None)\nMetadata of the matrix.\n{row,col}_meta is pd.DataFrame All sorting keywords should only be str or list of str. They should contain references to columns in meta.\n{row,col}_meta is None All sorting keywords should only array-like with the same length as the corresponding axis of data.",
                "{row,col}_group": "str, list of str, or array-like, (default=None)\nAttribute(s) by which to group rows/columns of data. If multiple groups are specified, rows/columns will be sorted hierarchically (first by the first group), then within that group by a possible second group, etc.). Behaves similarly to pandas.DataFrame.sort_values().",
                "{row,col}_group_order": "str, list of str, or array-like, (default=\"size\")\nAttribute(s) by which to sort the groups if provided by {row,col}_group. Groups are sorted by the mean of this attribute in ascending order. \"size\" is a special keyword which will sort groups by the number of elements per group.",
                "{row,col}_item_order": "str, list of str, or array-like (default=None)\nAttribute(s) by which to sort the individual rows/columns within each group.",
                "{row,col}_color": "str, list of str, or array-like (default=None)\nAttribute(s) to use for drawing colors on the borders of the matrix plot.",
                "{row,col}_highlight": "str, list of str, or array-like (default=None)\nAttribute(s) in meta by which to draw highlighted separators between specific groups, can be useful for emphasizing a particular region of the plot. Styling of the highlighted separators can be specified via spinestyle_kws.",
                "{row,col}_palette": "str, dict, list of str or dict (default=\"tab10\")\nColormap(s) of the color axes if specified by {row,col}_color.",
                "{row,col}_ticks": "bool, optional (default=True)\nWhether the plot has labels for the groups specified by {row,col}_group.",
                "{row,col}_tick_pad": "int or float (default=None)\nCustom padding to use for the distance between tick axes",
                "{row,col}_color_pad": "int or float (default=None)\nCustom padding to use for the distance between color axes",
                "border": "bool (default=True)\nWhether the plot should have a border.",
                "center": "int (default=0)\nThe value at which to center the colormap when plotting divergent data (only used when plot_type=\"heatmap\").",
                "cmap": "str (default=\"RdBu_r\")\nColormap of the heatmap (only used when plot_type=\"heatmap\").",
                "sizes": "tuple (default=(5, 10))\nMin and max sizes of dots (only used when plot_type=\"scattermap\").",
                "square": "bool (default=False)\nWhether the plot should be square.",
                "gridline_kws": "dict (default=None)\nPlotting arguments for the separators.",
                "spinestyle_kws": "dict (default=None)\nPlotting arguments for the spine border.",
                "highlight_kws": "dict (default=None)\nPlotting arguments for the highlighted separators.",
                "**kwargs": "Additional plotting arguments passed down to the plotting function which will draw the matrix data, see plot_type for more information."
            },
            "Returns": {
                "Axes": "Axes\nAxes in which to draw the plot, by default None",
                "divider": "AxesLocator\nDivider used to add new axes to the plot"
            }
        }
    },
    {
        "Section_id": "er_np",
        "Description": "Samples a Erdos Renyi (n, p) graph with specified edge probability.\n\nErdos Renyi (n, p) graph is a simple graph with n vertices and a probability p of edges being connected.",
        "Field List": {
            "Parameters": {
                "n": "int\nNumber of vertices",
                "p": "float\nProbability of an edge existing between two vertices, between 0 and 1.",
                "directed": "boolean, optional (default=False)\nIf False, output adjacency matrix will be symmetric. Otherwise, output adjacency matrix will be asymmetric.",
                "loops": "boolean, optional (default=False)\nIf False, no edges will be sampled in the diagonal. Otherwise, edges are sampled in the diagonal.",
                "wt": "object, optional (default=1)\nWeight function for each of the edges, taking only a size argument. This weight function will be randomly assigned for selected edges. If 1, graph produced is binary.",
                "wtargs": "dictionary, optional (default=None)\nOptional arguments for parameters that can be passed to weight function wt.",
                "dc": "function or array-like, shape (n_vertices)\ndc is used to generate a degree-corrected Erdos Renyi Model in which each node in the graph has a parameter to specify its expected degree relative to other nodes.\n\nfunction:\nshould generate a non-negative number to be used as a degree correction to create a heterogenous degree distribution. A weight will be generated for each vertex, normalized so that the sum of weights is 1.\n\narray-like of scalars, shape (n_vertices):\nThe weights should sum to 1; otherwise, they will be normalized and a warning will be thrown. The scalar associated with each vertex is the node's relative expected degree.",
                "dc_kws": "dictionary\nIgnored if dc is none or array of scalar. If dc is a function, dc_kws corresponds to its named arguments. If not specified, in either case all functions will assume their default parameters."
            },
            "Returns": {
                "A": "ndarray,shape (n, n)\nSampled adjacency matrix"
            }
        },
        "Rubric": {
            "example": [
                "np.random.seed(1)\nn=4\np=0.25",
                "To sample a binary Erdos Renyi (n, p) graph:\n\ner_np(n, p)\narray([[0., 0., 1., 0.],\n       [0., 0., 1., 0.],\n       [1., 1., 0., 0.],\n       [0., 0., 0., 0.]])\n",
                "To sample a weighted Erdos Renyi (n, p) graph with Uniform(0, 1) distribution:\n \nwt = np.random.uniform\nwtargs = dict(low=0, high=1)\ner_np(n, p, wt=wt, wtargs=wtargs)\narray([[0.        , 0.        , 0.95788953, 0.53316528],\n       [0.        , 0.        , 0.        , 0.        ],\n       [0.95788953, 0.        , 0.        , 0.31551563],\n       [0.53316528, 0.        , 0.31551563, 0.        ]])"
            ]
        }
    },
    {
        "Section_id": "er_nm",
        "Description": "Samples an Erdos Renyi (n, m) graph with specified number of edges.\n\nErdos Renyi (n, m) graph is a simple graph with n vertices and exactly m number of total edges.",
        "Field List": {
            "Parameters": {
                "n": "int\n,Number of vertices",
                "m": "int\nNumber of edges, a value between 1 and .",
                "directed": "boolean, optional (default=False)\nIf False, output adjacency matrix will be symmetric. Otherwise, output adjacency matrix will be asymmetric.",
                "loops": "boolean, optional (default=False)\nIf False, no edges will be sampled in the diagonal. Otherwise, edges are sampled in the diagonal.",
                "wt": "object, optional (default=1)\nWeight function for each of the edges, taking only a size argument. This weight function will be randomly assigned for selected edges. If 1, graph produced is binary.",
                "wtargs": "dictionary, optional (default=None)\nOptional arguments for parameters that can be passed to weight function wt."
            },
            "Returns": {
                "A": "ndarray,shape (n, n)\nSampled adjacency matrix"
            }
        },
        "Rubric": {
            "example": [
                "np.random.seed(1)\nn = 4\nm = 4",
                "To sample a binary Erdos Renyi (n, m) graph:\n\ner_nm(n, m)\narray([[0., 1., 1., 1.],\n       [1., 0., 0., 1.],\n       [1., 0., 0., 0.],\n       [1., 1., 0., 0.]])",
                "To sample a weighted Erdos Renyi (n, m) graph with Uniform(0, 1) distribution:\n\nwt = np.random.uniform\nwtargs = dict(low=0, high=1)\ner_nm(n, m, wt=wt, wtargs=wtargs)\narray([[0.        , 0.66974604, 0.        , 0.38791074],\n       [0.66974604, 0.        , 0.        , 0.39658073],\n       [0.        , 0.        , 0.        , 0.93553907],\n       [0.38791074, 0.39658073, 0.93553907, 0.        ])"
            ]
        }
    },
    {
        "Section_id": "sbm",
        "Description": "Samples a graph from the stochastic block model (SBM).\n\nSBM produces a graph with specified communities, in which each community can have different sizes and edge probabilities.",
        "Field List": {
            "Parameters": {
                "n": "list of int, shape (n_communities)\nNumber of vertices in each community. Communities are assigned n[0], n[1], ...",
                "p": "array-like, shape (n_communities, n_communities)\nProbability of an edge between each of the communities, where p[i, j] indicates the probability of a connection between edges in communities [i, j]. 0 < p[i, j] < 1 for all i, j.",
                "directed": "boolean, optional (default=False)\nIf False, output adjacency matrix will be symmetric. Otherwise, output adjacency matrix will be asymmetric.",
                "loops": "boolean, optional (default=False)\nIf False, no edges will be sampled in the diagonal. Otherwise, edges are sampled in the diagonal.",
                "wt": "object or array-like, shape (n_communities, n_communities)\nif wt is an object, a weight function to use globally over the sbm for assigning weights. 1 indicates to produce a binary graph. If wt is an array-like, a weight function for each of the edge communities. wt[i, j] corresponds to the weight function between communities i and j. If the entry is a function, should accept an argument for size. An entry of wt[i, j] = 1 will produce a binary subgraph over the i, j community.",
                "wtargs": "dictionary or array-like, shape (n_communities, n_communities)\nif wt is an object, wtargs corresponds to the trailing arguments to pass to the weight function. If Wt is an array-like, wtargs[i, j] corresponds to trailing arguments to pass to wt[i, j].",
                "dc": "function or array-like, shape (n_vertices) or (n_communities), optional\ndc is used to generate a degree-corrected stochastic block model [1] in which each node in the graph has a parameter to specify its expected degree relative to other nodes within its community.\n\nfunction:\nshould generate a non-negative number to be used as a degree correction to create a heterogenous degree distribution. A weight will be generated for each vertex, normalized so that the sum of weights in each block is 1.\n\narray-like of functions, shape (n_communities):\nEach function will generate the degree distribution for its respective community.\n\narray-like of scalars, shape (n_vertices):\nThe weights in each block should sum to 1; otherwise, they will be normalized and a warning will be thrown. The scalar associated with each vertex is the node's relative expected degree within its community.",
                "dc_kws": "dictionary or array-like, shape (n_communities), optional\nIgnored if dc is none or array of scalar. If dc is a function, dc_kws corresponds to its named arguments. If dc is an array-like of functions, dc_kws should be an array-like, shape (n_communities), of dictionary. Each dictionary is the named arguments for the corresponding function for that community. If not specified, in either case all functions will assume their default parameters.",
                "return_labels": "boolean, optional (default=False)\nIf False, only output is adjacency matrix. Otherwise, an additional output will be an array with length equal to the number of vertices in the graph, where each entry in the array labels which block a vertex in the graph is in."
            },
            "Returns": {
                "A": "ndarray,shape (sum(n), sum(n))\nSampled adjacency matrix",
                "labels": "ndarray,shape (sum(n))\nLabel vector"
            }
        },
        "Rubric": {
            "References": [
                "Tai Qin and Karl Rohe. \"Regularized spectral clustering under the Degree-Corrected Stochastic Blockmodel,\" Advances in Neural Information Processing Systems 26, 2013"
            ],
            "example": [
                "np.random.seed(1)\nn = [3, 3]\np = [[0.5, 0.1], [0.1, 0.5]]",
                "To sample a binary 2-block SBM graph:\n\nsbm(n, p)\narray([[0., 0., 1., 0., 0., 0.],\n       [0., 0., 1., 0., 0., 1.],\n       [1., 1., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 1., 0.],\n       [0., 0., 0., 1., 0., 0.],\n       [0., 1., 0., 0., 0., 0.]])",
                "To sample a weighted 2-block SBM graph with Poisson(2) distribution:\n\nwt = np.random.poisson"
            ]
        }
    },
    {
        "Section_id": "rdpg",
        "Description": "Samples a random graph based on the latent positions in X (and optionally in Y)\n\nIf only X is given, the P matrix is calculated as . If X, Y is given, then . These operations correspond to the dot products between a set of latent positions, so each row in X or Y represents the latent positions in for a single vertex in the random graph Note that this function may also rescale or clip the resulting P matrix to get probabilities between 0 and 1, or remove loops. A binary random graph is then sampled from the P matrix described by X (and possibly Y).",
        "Field List": {
            "Parameters": {
                "X": "np.ndarray, shape (n_vertices, n_dimensions)\nlatent position from which to generate a P matrix if Y is given, interpreted as the left latent position",
                "Y": "np.ndarray, shape (n_vertices, n_dimensions) or None, optional\nright latent position from which to generate a P matrix",
                "rescale": "boolean, optional (default=False)\nwhen rescale is True, will subtract the minimum value in P (if it is below 0) and divide by the maximum (if it is above 1) to ensure that P has entries between 0 and 1. If False, elements of P outside of [0, 1] will be clipped",
                "directed": "boolean, optional (default=False)\nIf False, output adjacency matrix will be symmetric. Otherwise, output adjacency matrix will be asymmetric.",
                "loops": "boolean, optional (default=False)\nIf False, no edges will be sampled in the diagonal. Diagonal elements in P matrix are removed prior to rescaling (see above) which may affect behavior. Otherwise, edges are sampled in the diagonal.",
                "wt": "object, optional (default=1)\nWeight function for each of the edges, taking only a size argument. This weight function will be randomly assigned for selected edges. If 1, graph produced is binary.",
                "wtargs": "dictionary, optional (default=None)\nOptional arguments for parameters that can be passed to weight function wt."
            },
            "Returns": {
                "A": "ndarray (n_vertices, n_vertices)\nA matrix representing the probabilities of connections between vertices in a random graph based on their latent positions"
            }
        },
        "Rubric": {
            "References": [
                "Sussman, D.L., Tang, M., Fishkind, D.E., Priebe, C.E. \"A Consistent Adjacency Spectral Embedding for Stochastic Blockmodel Graphs,\" Journal of the American Statistical Association, Vol. 107(499), 2012"
            ],
            "example": [
                "np.random.seed(1)\n",
                "Generate random latent positions using 2-dimensional Dirichlet distribution.\n\nX = np.random.dirichlet([1, 1], size=5)\n",
                "Sample a binary RDPG using sampled latent positions.\n\nrdpg(X, loops=False)\narray([[0., 1., 0., 0., 1.],\n       [1., 0., 0., 1., 1.],\n       [0., 0., 0., 1., 1.],\n       [0., 1., 1., 0., 0.],\n       [1., 1., 1., 0., 0.]])\n",
                "Sample a weighted RDPG with Poisson(2) weight distribution\n\nwt = np.random.poisson\nwtargs = dict(lam=2)\nrdpg(X, loops=False, wt=wt, wtargs=wtargs)\narray([[0., 4., 0., 2., 0.],\n       [1., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 2.],\n       [1., 0., 0., 0., 1.],\n       [0., 2., 2., 0., 0.]])"
            ]
        }
    },
    {
        "Section_id": "er_corr",
        "Description": "Generate a pair of correlated graphs with specified edge probability\n\nBoth G1 and G2 are binary matrices.",
        "Field List": {
            "Parameters": {
                "n": "int\nNumber of vertices",
                "p": "float\nProbability of an edge existing between two vertices, between 0 and 1.",
                "r": "float\nThe value of the correlation between the same vertices in two graphs.",
                "directed": "boolean, optional (default=False)\nIf False, output adjacency matrix will be symmetric. Otherwise, output adjacency matrix will be asymmetric.",
                "loops": "boolean, optional (default=False)\nIf False, no edges will be sampled in the diagonal. Otherwise, edges are sampled in the diagonal."
            },
            "Returns": {
                "G1": "ndarray (n_vertices, n_vertices)\nAdjacency matrix the same size as P representing a random graph.",
                "G2": "ndarray (n_vertices, n_vertices)\nAdjacency matrix the same size as P representing a random graph."
            }
        },
        "Rubric": {
            "example": [
                "np.random.seed(2)\np = 0.5\nr = 0.3\nn = 5",
                "To sample a correlated ER graph pair based on n, p and r:\n\ner_corr(n, p, r, directed=False, loops=False)\n(array([[0., 0., 1., 0., 0.],\n        [0., 0., 0., 1., 0.],\n        [1., 0., 0., 1., 1.],\n        [0., 1., 1., 0., 1.],\n        [0., 0., 1., 1., 0.]]), array([[0., 1., 1., 1., 0.],\n        [1., 0., 0., 1., 0.],\n        [1., 0., 0., 1., 1.],\n        [1., 1., 1., 0., 1.],\n        [0., 0., 1., 1., 0.]]))"
            ]
        }
    },
    {
        "Section_id": "sbm_corr",
        "Description": "Generate a pair of correlated graphs with specified edge probability\n\nBoth G1 and G2 are binary matrices.",
        "Field List": {
            "Parameters": {
                "n": "ndarray | List[int]\nNumber of vertices in each community. Communities are assigned n[0], n[1], ...",
                "p": "ndarray\nProbability of an edge between each of the communities, where p[i, j] indicates the probability of a connection between edges in communities [i, j]. 0 < p[i, j] < 1 for all i, j.",
                "r": "float\nProbability of the correlation between the same vertices in two graphs.",
                "directed": "boolean, optional (default=False)\nIf False, output adjacency matrix will be symmetric. Otherwise, output adjacency matrix will be asymmetric.",
                "loops": "boolean, optional (default=False)\nIf False, no edges will be sampled in the diagonal. Otherwise, edges are sampled in the diagonal."
            },
            "Returns": {
                "G1": "ndarray (n_vertices, n_vertices)\nAdjacency matrix the same size as P representing a random graph.",
                "G2": "ndarray (n_vertices, n_vertices)\nAdjacency matrix the same size as P representing a random graph."
            }
        },
        "Rubric": {
            "example": [
                "np.random.seed(3)\nn = [3, 3]\np = [[0.5, 0.1], [0.1, 0.5]]\nr = 0.3",
                "To sample a correlated SBM graph pair based on n, p and r:\n\nsbm_corr(n, p, r, directed=False, loops=False)\n(array([[0., 1., 0., 0., 0., 0.],\n        [1., 0., 0., 0., 0., 0.],\n        [0., 0., 0., 0., 0., 0.],\n        [0., 0., 0., 0., 0., 1.],\n        [0., 0., 0., 0., 0., 0.],\n        [0., 0., 0., 1., 0., 0.]]), array([[0., 1., 0., 0., 0., 0.],\n        [1., 0., 0., 1., 1., 0.],\n        [0., 0., 0., 0., 0., 0.],\n        [0., 1., 0., 0., 0., 1.],\n        [0., 1., 0., 0., 0., 0.],\n        [0., 0., 0., 1., 0., 0.]]))"
            ]
        }
    },
    {
        "Section_id": "rdpg_corr",
        "Description": "Samples a random graph pair based on the latent positions in X (and optionally in Y)\n\nIf only X is given, the P matrix is calculated as . If X, Y is given, then . These operations correspond to the dot products between a set of latent positions, so each row in X or Y represents the latent positions in for a single vertex in the random graph. Note that this function may also rescale or clip the resulting P matrix to get probabilities between 0 and 1, or remove loops. A binary random graph is then sampled from the P matrix described by X (and possibly Y).",
        "Field List": {
            "Parameters": {
                "X": "np.ndarray, shape (n_vertices, n_dimensions)\nlatent position from which to generate a P matrix if Y is given, interpreted as the left latent position",
                "Y": "np.ndarray, shape (n_vertices, n_dimensions) or None, optional\nright latent position from which to generate a P matrix",
                "r": "float\nThe value of the correlation between the same vertices in two graphs.",
                "rescale": "boolean, optional (default=False)\nwhen rescale is True, will subtract the minimum value in P (if it is below 0) and divide by the maximum (if it is above 1) to ensure that P has entries between 0 and 1. If False, elements of P outside of [0, 1] will be clipped.",
                "directed": "boolean, optional (default=False)\nIf False, output adjacency matrix will be symmetric. Otherwise, output adjacency matrix will be asymmetric.",
                "loops": "boolean, optional (default=True)\nIf False, no edges will be sampled in the diagonal. Otherwise, edges are sampled in the diagonal."
            },
            "Returns": {
                "G1": "ndarray (n_vertices, n_vertices)\nA matrix representing the probabilities of connections between vertices in a random graph based on their latent positions",
                "G2": "ndarray (n_vertices, n_vertices)\nA matrix representing the probabilities of connections between vertices in a random graph based on their latent positions"
            }
        },
        "Rubric": {
            "References": [
                "Vince Lyzinski, Donniell E Fishkind profile imageDonniell E. Fishkind, Carey E Priebe. \"Seeded graph matching for correlated Erd\u00f6s-R\u00e9nyi graphs\". The Journal of Machine Learning Research, January 2014"
            ],
            "example": [
                "np.random.seed(1234)\nX = np.random.dirichlet([1, 1], size=5)\nY = None",
                "Generate random latent positions using 2-dimensional Dirichlet distribution. Then sample a correlated RDPG graph pair:\n\nrdpg_corr(X, Y, 0.3, rescale=False, directed=False, loops=False)\n(array([[0., 1., 0., 1., 0.],\n        [1., 0., 0., 1., 1.],\n        [0., 0., 0., 0., 0.],\n        [1., 1., 0., 0., 0.],\n        [0., 1., 0., 0., 0.]]), array([[0., 1., 0., 1., 0.],\n        [1., 0., 0., 0., 1.],\n        [0., 0., 0., 0., 0.],\n        [1., 0., 0., 0., 0.],\n        [0., 1., 0., 0., 0.]]))"
            ]
        }
    },
    {
        "Section_id": "mmsbm",
        "Description": "Samples a graph from Mixed Membership Stochastic Block Model (MMSBM).\n\nMMSBM produces a graph given the specified block connectivity matrix B, which indicates the probability of connection between nodes based upon their community membership. Each node is assigned a membership vector drawn from Dirichlet distribution with parameter . The entries of this vector indicate the probabilities for that node of pertaining to each community when interacting with another node. Each node's membership is determined according to those probabilities. Finally, interactions are sampled according to the assigned memberships.",
        "Field List": {
            "Parameters": {
                "n": "int\nNumber of vertices of the graph.",
                "p": "array-like, shape (n_communities, n_communities)\nProbability of an edge between each of the communities, where p[i, j] indicates the probability of a connection between edges in communities . 0 < p[i, j] < 1 for all .",
                "alpha": "array-like, shape (n_communities,)\nParameter alpha of the Dirichlet distribution used to sample the mixed-membership vectors for each node. alpha[i] > 0 for all .",
                "rng": "numpy.random.Generator, optional (default = None)\nnumpy.random.Generator object to sample from distributions. If None, the random number generator is the Generator object constructed by np.random.default_rng().",
                "directed": "boolean, optional (default=False)\nIf False, output adjacency matrix will be symmetric. Otherwise, output adjacency matrix will be asymmetric.",
                "loops": "boolean, optional (default=False)\nIf False, no edges will be sampled in the diagonal. Otherwise, edges are sampled in the diagonal.",
                "return_labels": "boolean, optional (default=False)\nIf False, the only output is the adjacency matrix. If True, output is a tuple. The first element of the tuple is the adjacency matrix. The second element is a matrix in which the entry indicates the membership assigned to node i when interacting with node j. Community 1 is labeled with a 0, community 2 with 1, etc. -1 indicates that no community was assigned for that interaction."
            },
            "Returns": {
                "A": "ndarray,shape (n, n)\nSampled adjacency matrix",
                "labels": "ndarray,shape (n, n), optional\nArray containing the membership assigned to each node when interacting with another node."
            }
        },
        "Rubric": {
            "References": [
                "Airoldi, Edoardo, et al. \"Mixed Membership Stochastic Blockmodels.\" Journal of Machine Learning Research, vol. 9, 2008, pp. 1981\u20132014."
            ],
            "example": [
                "rng = np.random.default_rng(1)\nnp.random.seed(1)\nn = 6\np = [[0.5, 0], [0, 1]]",
                "To sample a binary MMSBM in which very likely all nodes pertain to community two:\n\nalpha = [0.05, 1000]\nmmsbm(n, p, alpha, rng = rng)\narray([[0., 1., 1., 1., 1., 1.],\n       [1., 0., 1., 1., 1., 1.],\n       [1., 1., 0., 1., 1., 1.],\n       [1., 1., 1., 0., 1., 1.],\n       [1., 1., 1., 1., 0., 1.],\n       [1., 1., 1., 1., 1., 0.]])",
                "To sample a binary MMSBM similar to 2-block SBM with connectivity matrix B:\n\nrng = np.random.default_rng(1)\nnp.random.seed(1)\nalpha = [0.05, 0.05]\nmmsbm(n, p, alpha, rng = rng)\narray([[0., 1., 0., 0., 0., 0.],\n       [1., 0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 1., 1.],\n       [0., 0., 0., 1., 0., 1.],\n       [0., 0., 0., 1., 1., 0.]])"
            ]
        }
    },
    {
        "Section_id": "SignalSubgraph",
        "Description": "Estimate the signal-subgraph of a set of labeled graph samples.\n\nThe incoherent estimator finds the signal-subgraph, constrained by the number of edges. The coherent estimator finds the signal-subgraph, constrained by the number of edges and by the number of vertices that the edges in the signal-subgraph may be incident to.",
        "Field List": {
            "Parameters": {
                "graphs": "array-like, shape (n_vertices, n_vertices, s_samples)\nA series of labeled (n_vertices, n_vertices) unweighted graph samples. If undirected, the upper or lower triangle matrices should be used.",
                "labels": "vector, length (s_samples)\nA vector of class labels. There must be a maximum of two classes."
            },
            "Attributes": {
                "contmat_": "array-like, shape (n_vertices, n_vertices, 2, 2)\nAn array that stores the 2-by-2 contingency matrix for each point in the graph samples.",
                "sigsub_": "tuple, shape (2, n_edges)\nA tuple of a row index array and column index array, where n_edges is the size of the signal-subgraph determined by constraints.",
                "mask_": "array-like, shape (n_vertices, n_vertices)\nAn array of boolean values. Entries are true for edges that are in the signal subgraph."
            },
            "Methods": {
                "fit": {
                    "Description": "Fit the signal-subgraph estimator according to the constraints given.",
                    "Parameters": {
                        "graphs": "array-like, shape (n_vertices, n_vertices, s_samples)\nA series of labeled (n_vertices, n_vertices) unweighted graph samples. If undirected, the upper or lower triangle matrices should be used.",
                        "labels": "vector, length (s_samples)\nA vector of class labels. There must be a maximum of two classes.",
                        "constraints": "int or vector\nThe constraints that will be imposed onto the estimated signal-subgraph.\n\nIf constraints is an int, constraints is the number of edges in the signal-subgraph. If constraints is a vector, the first element of constraints is the number of edges in the signal-subgraph, and the second element of constraints is the number of vertices that the signal-subgraph must be incident to."
                    },
                    "Returns": {
                        "self": "returns an instance of self"
                    }
                },
                "fit_transform": {
                    "Description": "A function to return the indices of the signal-subgraph. If return_mask is True, also returns a mask for the signal-subgraph.",
                    "Parameters": {
                        "graphs": "array-like, shape (n_vertices, n_vertices, s_samples)\nA series of labeled (n_vertices, n_vertices) unweighted graph samples. If undirected, the upper or lower triangle matrices should be used.",
                        "labels": "vector, length (s_samples)\nA vector of class labels. There must be a maximum of two classes.",
                        "constraints": "int or vector\nThe constraints that will be imposed onto the estimated signal-subgraph.\n\nIf constraints is an int, constraints is the number of edges in the signal-subgraph. If constraints is a vector, the first element of constraints is the number of edges in the signal-subgraph, and the second element of constraints is the number of vertices that the signal-subgraph must be incident to."
                    },
                    "Returns": {
                        "sigsub": "tuple\nContains an array of row indices and an array of column indices."
                    }
                }
            }
        },
        "Rubric": {
            "References": [
                "J.T.Vogelstein, W. R. Gray, R. J. Vogelstein, and C. E. Priebe, \"Graph Classification using Signal-Subgraphs: Applications in Statistical Connectomics,\" arXiv:1108.1427v2 [stat.AP], 2012."
            ]
        }
    },
    {
        "Section_id": "pass_to_ranks",
        "Description": "Rescales edge weights of an adjacency matrix based on their relative rank in the graph.",
        "Field List": {
            "Parameters": {
                "graph": "array_like or networkx.Graph\nAdjacency matrix",
                "method": "{'simple-nonzero' (default), 'simple-all', 'zero-boost'} string, optional\n'simple-nonzero'\nassigns ranks to all non-zero edges, settling ties using the average. Ranks are then scaled by \n\n'simple-all'\nassigns ranks to all non-zero edges, settling ties using the average. Ranks are then scaled by \n\n where n is the number of nodes\n\n'zero-boost'\npreserves the edge weight for all 0s, but ranks the other edges as if the ranks of all 0 edges has been assigned. If there are 10 0-valued edges, the lowest non-zero edge gets weight 11 / (number of possible edges). Ties settled by the average of the weight that those edges would have received. Number of possible edges is determined by the type of graph (loopless or looped, directed or undirected)."
            },
            "Returns": {
                "graph": "numpy.ndarray, shape(n_vertices, n_vertices)\nAdjacency matrix of graph after being passed to ranks"
            }
        }
    },
    {
        "Section_id": "to_laplacian",
        "Description": "A function to convert graph adjacency matrix to graph Laplacian.\n\nCurrently supports I-DAD, DAD, and R-DAD Laplacians, where D is the diagonal matrix of degrees of each node, I is the identity matrix, and A is the adjacency matrix.\n\nR-DAD is regularized Laplacian: where .",
        "Field List": {
            "Parameters": {
                "graph": "object\nEither array-like, (n_vertices, n_vertices) numpy array, scipy.sparse.csr_array, or an object of type networkx.Graph.",
                "form": "{'I-DAD', 'DAD' (default), 'R-DAD'}, string, optional\n'I-DAD'\nComputes \n\n'DAD'\nComputes \n\n'R-DAD'\nComputes \n where \n and likewise for \n",
                "regularizer": "int, float or None, optional (default=None)\nConstant to add to the degree vector(s). If None, average node degree is added. If int or float, must be >= 0. Only used when form is 'R-DAD'."
            },
            "Returns": {
                "L": "numpy.ndarray\n2D (n_vertices, n_vertices) array representing graph Laplacian of specified form"
            }
        },
        "Rubric": {
            "References": [
                "Qin, Tai, and Karl Rohe. \"Regularized spectral clustering under the degree-corrected stochastic blockmodel.\" In Advances in Neural Information Processing Systems, pp. 3120-3128. 2013",
                "Rohe, Karl, Tai Qin, and Bin Yu. \"Co-clustering directed graphs to discover asymmetries and directional communities.\" Proceedings of the National Academy of Sciences 113.45 (2016): 12679-12684."
            ],
            "example": [
                "a = np.array([\n   [0, 1, 1],\n   [1, 0, 0],\n   [1, 0, 0]])\nto_laplacian(a, \"DAD\")\narray([[0.        , 0.70710678, 0.70710678],\n       [0.70710678, 0.        , 0.        ],\n       [0.70710678, 0.        , 0.        ]])"
            ]
        }
    },
    {
        "Section_id": "augment_diagonal",
        "Description": "Replaces the diagonal of an adjacency matrix with d/(nverts-1) where d is the degree vector for an unweighted graph and the sum of magnitude of edge weights for each node for a weighted graph. For a directed graph the in/out d is averaged.",
        "Field List": {
            "Parameters": {
                "graph": "nx.Graph, nx.DiGraph, nx.MultiDiGraph, nx.MultiGraph, np.ndarray\nInput graph in any of the above specified formats. If np.ndarray, interpreted as an adjacency matrix",
                "weight": "float/int\nscalar value to multiply the new diagonal vector by"
            },
            "Returns": {
                "graph": "np.array or csr_array\nAdjacency matrix with average degrees added to the diagonal."
            }
        },
        "Rubric": {
            "example": [
                "a = np.array([\n   [0, 1, 1],\n   [1, 0, 0],\n   [1, 0, 0]])\naugment_diagonal(a)\narray([[1. , 1. , 1. ],\n       [1. , 0.5, 0. ],\n       [1. , 0. , 0.5]])"
            ]
        }
    },
    {
        "Section_id": "symmetrize",
        "Description": "A function for forcing symmetry upon a graph.",
        "Field List": {
            "Parameters": {
                "graph": "object\nEither array-like, (n_vertices, n_vertices) numpy matrix or csr_array",
                "method": "{'avg' (default), 'triu', 'tril',}, optional\nAn option indicating which half of the edges to retain when symmetrizing.\n\n'avg'\nRetain the average weight between the upper and lower right triangle, of the adjacency matrix.\n\n'triu'\nRetain the upper right triangle.\n\n'tril'\nRetain the lower left triangle."
            },
            "Returns": {
                "graph": "array-like, shape (n_vertices, n_vertices)\nGraph with asymmetries removed."
            }
        },
        "Rubric": {
            "example": [
                "a = np.array([\n   [0, 1, 1],\n   [0, 0, 1],\n   [0, 0, 1]])\nsymmetrize(a, method=\"triu\")\narray([[0, 1, 1],\n       [1, 0, 1],\n       [1, 1, 1]])"
            ]
        }
    },
    {
        "Section_id": "remove_loops",
        "Description": "A function to remove loops from a graph.",
        "Field List": {
            "Parameters": {
                "graph": "object\nEither array-like, (n_vertices, n_vertices) numpy matrix, or an object of type networkx.Graph."
            },
            "Returns": {
                "graph": "array-like, shape(n_vertices, n_vertices)\nthe graph with self-loops (edges between the same node) removed."
            }
        }
    },
    {
        "Section_id": "is_fully_connected",
        "Description": "Checks whether the input graph is fully connected in the undirected case or weakly connected in the directed case.\n\nConnected means one can get from any vertex to vertex by traversing the graph. For a directed graph, weakly connected means that the graph is connected after it is converted to an unweighted graph (ignore the direction of each edge)",
        "Field List": {
            "Parameters": {
                "graph": "nx.Graph, nx.MultiDiGraph, nx.MultiGraph\nscipy.sparse.csr_array, np.ndarray Input graph in any of the above specified formats. If np.ndarray, interpreted as an adjacency matrix"
            },
            "Returns": {
                "boolean": "True if the entire input graph is connected"
            }
        },
        "Rubric": {
            "References": [
                "http://mathworld.wolfram.com/ConnectedGraph.html",
                "http://mathworld.wolfram.com/WeaklyConnectedDigraph.html"
            ],
            "example": [
                "a = np.array([\n   [0, 1, 0],\n   [1, 0, 0],\n   [0, 0, 0]])\nis_fully_connected(a)\nFalse"
            ]
        }
    },
    {
        "Section_id": "largest_connected_component",
        "Description": "Finds the largest connected component for the input graph.\n\nThe largest connected component is the fully connected subgraph which has the most nodes.",
        "Field List": {
            "Parameters": {
                "graph": "nx.Graph, nx.DiGraph, nx.MultiDiGraph, nx.MultiGraph, np.ndarray, scipy.sparse.csr_array\nInput graph in any of the above specified formats. If np.ndarray or scipy.sparse.csr_array interpreted as an adjacency matrix.",
                "return_inds": "boolean, default: False\nWhether to return a np.ndarray containing the indices/nodes in the original adjacency matrix that were kept and are now in the returned graph."
            },
            "Returns": {
                "graph": "nx.Graph, nx.DiGraph, nx.MultiDiGraph, nx.MultiGraph, np.ndarray, scipy.sparse.csr_array\nNew graph of the largest connected component, returned in the input format.",
                "inds": "(optional)\nIndices/nodes from the original adjacency matrix that were kept after taking the largest connected component."
            }
        },
        "Rubric": {
            "Note": "For networks input in scipy.sparse.csr_array format, explicit zeros are removed prior to finding the largest connected component, thus they are not treated as edges. This differs from the convention in scipy.sparse.csgraph.connected_components()."
        }
    },
    {
        "Section_id": "multigraph_lcc_union",
        "Description": "Finds the union of all multiple graphs, then compute the largest connected component.",
        "Field List": {
            "Parameters": {
                "graphs": "list or np.ndarray\nList of array-like, (n_vertices, n_vertices), or list of np.ndarray nx.Graph, nx.DiGraph, nx.MultiDiGraph, nx.MultiGraph.",
                "return_inds": "boolean, default: False\nWhether to return a np.ndarray containing the indices in the original adjacency matrix that were kept and are now in the returned graph. Ignored when input is networkx object"
            },
            "Returns": {
                "outlist": "or np.ndarray\nIf input was a list"
            }
        }
    },
    {
        "Section_id": "multigraph_lcc_intersection",
        "Description": "Finds the intersection of multiple graphs's largest connected components.\n\nComputes the largest connected component for each graph that was input, and takes the intersection over all of these resulting graphs. Note that this does not guarantee finding the largest graph where every node is shared among all of the input graphs.",
        "Field List": {
            "Parameters": {
                "graphs": "list or np.ndarray\nif list, each element must be an np.ndarray adjacency matrix",
                "return_inds": "boolean, default: False\nWhether to return a np.ndarray containing the indices in the original adjacency matrix that were kept and are now in the returned graph. Ignored when input is networkx object"
            },
            "Returns": {
                "graph": "list of(nx.Graph, nx.DiGraph, nx.MultiDiGraph, nx.MultiGraph) or np.ndarray\nNew graph of the largest connected component of the input parameter.",
                "inds": "(optional)\nIndices from the original adjacency matrix that were kept after taking the largest connected component"
            }
        }
    },
    {
        "Section_id": "import_graph",
        "Description": "A function for reading a graph and returning a shared data type.",
        "Field List": {
            "Parameters": {
                "graph": "GraphRepresentation\nEither array-like, shape (n_vertices, n_vertices) numpy array, a scipy.sparse.csr_array, or an object of type networkx.Graph.",
                "copy": "bool, (default=True)\nWhether to return a copied version of array. If False and input is np.array, the output returns the original input."
            },
            "Returns": {
                "out": "array-like, shape (n_vertices, n_vertices)\nA graph."
            }
        }
    },
    {
        "Section_id": "import_edgelist",
        "Description": "Function for reading a single or multiple edgelists.\n\nWhen importing multiple edgelists, the union of vertices from all graphs is computed so that each output graph have matched vertex set. The order of nodes are sorted by node values.",
        "Field List": {
            "Parameters": {
                "path": "str, Path object, or iterable\nIf path is a directory, then the importing order will be sorted in alphabetical order.",
                "extension": "str, optional\nIf path is a directory, then the function will convert all files with matching extension.",
                "delimiter": "str or None, default=None, optional\nDelimiter of edgelist. If None, the delimiter is whitespace.",
                "nodetype": "int (default), float, str, Python type, optional\nConvert node data from strings to specified type.",
                "return_vertices": "bool, default=False, optional\nReturns the union of all individual edgelists."
            },
            "Returns": {
                "out": "list of array-like, or array-like, shape (n_vertices, n_vertices)\nIf path is a directory, a list of arrays is returned. If path is a file, an array is returned.",
                "vertices": "array-like, shape (n_vertices, )\nIf return_vertices` is True, then returns an array of all vertices that were included in the output graphs."
            }
        }
    },
    {
        "Section_id": "remap_labels",
        "Description": "Remaps a categorical labeling (such as one predicted by a clustering algorithm) to match the labels used by another similar labeling.\n\nGiven two -length vectors describing a categorical labeling of  samples, this method reorders the labels of the second vector (y_pred) so that as many samples as possible from the two label vectors are in the same category.",
        "Field List": {
            "Parameters": {
                "y_true": "array-like of shape (n_samples,)\nGround truth labels, or, labels to map to.",
                "y_pred": "array-like of shape (n_samples,)\nLabels to remap to match the categorical labeling of y_true. The categorical labeling of y_pred will be preserved exactly, but the labels used to denote the categories will be changed to best match the categories used in y_true.",
                "return_map": "bool, optional\nWhether to return a dictionary where the keys are the original category labels from y_pred and the values are the new category labels that they were mapped to."
            },
            "Returns": {
                "remapped_y_pred": "np.ndarray of shape (n_samples,)\nSame categorical labeling as that of y_pred, but with the category labels permuted to best match those of y_true.",
                "label_map": "dict\nMapping from the original labels of y_pred to the new labels which best resemble those of y_true. Only returned if return_map was True."
            }
        },
        "Rubric": {
            "Note": "This method will work well when the label vectors describe a somewhat similar categorization of the data (as measured by metrics such as sklearn.metrics.adjusted_rand_score(), for example). When the categorizations are not similar, the remapping may not make sense (as such a remapping does not exist).",
            "example": [
                "y_true = np.array([0,0,1,1,2,2])\ny_pred = np.array([2,2,1,1,0,0])\nremap_labels(y_true, y_pred)\narray([0, 0, 1, 1, 2, 2])"
            ]
        }
    },
    {
        "Section_id": "EgoNetSplitter",
        "Description": "An implementation of \u201cEgo-Splitting\u201dfrom the KDD \u201817 paper \u201cEgo-Splitting Framework: from Non-Overlapping to Overlapping Clusters\u201d. The tool first createsthe ego-nets of nodes. A persona-graph is created which is clustered by the Louvain method. The resulting overlappingcluster memberships are stored as a dictionary.",
        "Field List": {
            "Parameters": {
                "resolution(float)": "Resolution parameter of Python Louvain. Default 1.0.",
                "seed(int)": "Random seed value. Default is 42.",
                "weight(str)": "the key in the graph to use as weight. Default to \u2018weight\u2019. Specify None to force using an unweighted version of the graph."
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting an Ego-Splitter clustering model.",
                        "Arg types:": {
                            "graph(NetworkX graph)": "The graph to be clustered."
                        }
                    }
                },
                {
                    "get_memberships": {
                        "Description": "Getting the cluster membership of nodes.",
                        "Return types:": {
                            "memberships(dictionary of lists)": "Cluster memberships."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "DANMF",
        "Description": "An implementation of \u201cDANMF\u201dfrom the CIKM \u201818 paper \u201cDeep Autoencoder-like Nonnegative Matrix Factorization forCommunity Detection\u201d. The procedure uses telescopic non-negative matrix factorizationin order to learn a cluster membership distribution over nodes. The method can beused in an overlapping and non-overlapping way.",
        "Field List": {
            "Parameters": {
                "layers(list)": "Autoencoder layer sizes in a list of integers. Default [32, 8].",
                "pre_iterations(int)": "Number of pre-training epochs. Default 100.",
                "iterations(int)": "Number of training epochs. Default 100.",
                "seed(int)": "Random seed for weight initializations. Default 42.",
                "lamb(float)": "Regularization parameter. Default 0.01.",
                "seed": "Random seed value. Default is 42."
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting a DANMF clustering model.",
                        "Arg types:": {
                            "graph(NetworkX graph)": "The graph to be clustered."
                        }
                    }
                },
                {
                    "get_embedding": {
                        "Description": "Getting the bottleneck layer embedding.",
                        "Return types:": {
                            "embedding(Numpy array)": "The bottleneck layer embedding of nodes."
                        }
                    }
                },
                {
                    "get_memberships": {
                        "Description": "Getting the cluster membership of nodes.",
                        "Return types:": {
                            "memberships(dict)": ": Node cluster memberships."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "NNSED",
        "Description": "An implementation of \u201cNNSED\u201dfrom the CIKM \u201817 paper \u201cA Non-negative Symmetric Encoder-Decoder Approachfor Community Detection\u201d. The procedure uses non-negative matrix factorizationin order to learn an unnormalized cluster membership distribution over nodes.The method can be used in an overlapping and non-overlapping way.",
        "Field List": {
            "Parameters": {
                "layers(int)": "Embedding layer size. Default is 32.",
                "iterations(int)": "Number of training epochs. Default 10.",
                "seed(int)": "Random seed for weight initializations. Default 42.",
                "noise(float)": "Random noise for normalization stability. Default is 10**-6."
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting an NNSED clustering model.",
                        "Arg types:": {
                            "graph(NetworkX graph)": "The graph to be clustered."
                        }
                    }
                },
                {
                    "get_embedding": {
                        "Description": "Getting the bottleneck layer embedding.",
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of nodes."
                        }
                    }
                },
                {
                    "get_memberships": {
                        "Description": "Getting the cluster membership of nodes.",
                        "Return types:": {
                            "memberships(dict)": "Node cluster memberships."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "MNMF",
        "Description": "An implementation of \u201cM-NMF\u201dfrom the AAAI \u201817 paper \u201cCommunity Preserving Network Embedding\u201d.The procedure uses joint non-negative matrix factorization with modularitybased regularization in order to learn a cluster membership distributionover nodes. The method can be used in an overlapping and non-overlapping way.",
        "Field List": {
            "Parameters": {
                "dimensions(int)": "Number of dimensions. Default is 128.",
                "clusters(int)": "Number of clusters. Default is 10.",
                "lambd(float)": "KKT penalty. Default is 0.2",
                "alpha(float)": "Clustering penalty. Default is 0.05.",
                "beta(float)": "Modularity regularization penalty. Default is 0.05.",
                "iterations(int)": "Number of power iterations. Default is 200.",
                "lower_control(float)": "Floating point overflow control. Default is 10**-15.",
                "eta(float)": "Similarity mixing parameter. Default is 5.0.",
                "seed(int)": "Random seed value. Default is 42."
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting an M-NMF clustering model.",
                        "Arg types:": {
                            "graph(NetworkX graph)": "The graph to be clustered."
                        }
                    }
                },
                {
                    "get_cluster_centers": {
                        "Description": "Getting the node embedding.",
                        "Return types:": {
                            "centers(Numpy array)": "The cluster centers."
                        }
                    }
                },
                {
                    "get_embedding": {
                        "Description": "Getting the node embedding.",
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of nodes."
                        }
                    }
                },
                {
                    "get_memberships": {
                        "Description": "Getting the cluster membership of nodes.",
                        "Return types:": {
                            "memberships(dict)": "Node cluster memberships."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "BigClam",
        "Description": "An implementation of \u201cBigClam\u201dfrom the WSDM \u201813 paper \u201cOverlapping Community Detection at Scale: A Non-negative MatrixFactorization Approach\u201d. The procedure uses gradient ascent to create an embedding which isused for deciding the node-cluster affiliations.",
        "Field List": {
            "Parameters": {
                "dimensions(int)": "Number of embedding dimensions. Default 8.",
                "iterations(int)": "Number of training iterations. Default 50.",
                "learning_rate(float)": "Gradient ascent learning rate. Default is 0.005.",
                "seed(int)": "Random seed value. Default is 42."
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting a BigClam clustering model.",
                        "Arg types:": {
                            "graph(NetworkX graph)": "The graph to be clustered."
                        }
                    }
                },
                {
                    "get_embedding": {
                        "Description": "Getting the node embedding.",
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of nodes."
                        }
                    }
                },
                {
                    "get_memberships": {
                        "Description": "Getting the cluster membership of nodes.",
                        "Return types:": {
                            "memberships(dict)": "Node cluster memberships."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "SymmNMF",
        "Description": "An implementation of \u201cSymm-NMF\u201dfrom the SDM\u201912 paper \u201cSymmetric Nonnegative Matrix Factorization for Graph Clustering\u201d. The proceduredecomposed the second power od the normalized adjacency matrix with an ADMM based non-negative matrixfactorization based technique. This results in a node embedding and each node is associated with anembedding factor in the created latent space.",
        "Field List": {
            "Parameters": {
                "dimensions(int)": "Number of dimensions. Default is 32.",
                "iterations(int)": "Number of power iterations. Default is 200.",
                "rho(float)": "Regularization tuning parameter. Default is 100.0.",
                "seed(int)": "Random seed value. Default is 42."
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting a Symm-NMF clustering model.",
                        "Arg types:": {
                            "graph(NetworkX graph)": "The graph to be clustered."
                        }
                    }
                },
                {
                    "get_embedding": {
                        "Description": "Getting the node embedding.",
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of nodes."
                        }
                    }
                },
                {
                    "get_memberships": {
                        "Description": "Getting the cluster membership of nodes.",
                        "Return types:": {
                            "memberships(dict)": "Node cluster memberships."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "GEMSEC",
        "Description": "An implementation of \u201cGEMSEC\u201dfrom the ASONAM \u201819 paper \u201cGEMSEC: Graph Embedding with Self Clustering\u201d.The procedure uses random walks to approximate the pointwise mutual informationmatrix obtained by pooling normalized adjacency matrix powers. This matrixis decomposed by an approximate factorization technique which is combinedwith a k-means like clustering cost. A node embedding and clustering arelearned jointly.",
        "Field List": {
            "Parameters": {
                "walk_number(int)": "Number of random walks. Default is 5.",
                "walk_length(int)": "Length of random walks. Default is 80.",
                "dimensions(int)": "Dimensionality of embedding. Default is 32.",
                "negative_samples(int)": "Number of negative samples. Default is 5.",
                "window_size(int)": "Matrix power order. Default is 5.",
                "learning_rate(float)": "Gradient descent learning rate. Default is 0.1.",
                "clusters(int)": "Number of cluster centers. Default is 10.",
                "gamma(float)": "Clustering cost weight coefficient. Default is 0.1.",
                "seed(int)": "Random seed value. Default is 42."
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting a GEMSEC model.",
                        "Arg types:": {
                            "graph(NetworkX graph)": "The graph to be embedded."
                        }
                    }
                },
                {
                    "get_embedding": {
                        "Description": "Getting the node embedding.",
                        "Return types:": {
                            "embedding(Numpy array)": ": The embedding of nodes."
                        }
                    }
                },
                {
                    "get_memberships": {
                        "Description": "Getting the cluster membership of nodes.",
                        "Return types:": {
                            "memberships(dict)": ": Node cluster memberships."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "EdMot",
        "Description": "An implementation of \u201cEdge Motif Clustering\u201dfrom the KDD \u201819 paper \u201cEdMot: An Edge Enhancement Approach for Motif-aware Community Detection\u201d. The tool first createsthe graph of higher order motifs. This graph is clustered by the Louvain method. The resultingcluster memberships are stored as a dictionary.",
        "Field List": {
            "Parameters": {
                "component_count(int)": "Number of extracted motif hypergraph components. Default is 2.",
                "cutoff(int)": "Motif edge cut-off value. Default is 50.",
                "seed(int)": "Random seed value. Default is 42."
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting an Edge Motif clustering model.",
                        "Arg types:": {
                            "graph(NetworkX graph)": "The graph to be clustered."
                        }
                    }
                },
                {
                    "get_memberships": {
                        "Description": "Getting the cluster membership of nodes.",
                        "Return types:": {
                            "memberships(dictionary of ints)": "Cluster memberships."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "SCD",
        "Description": "An implementation of \u201cSCD\u201d from theWWW \u201814 paper \u201cHigh Quality, Scalable and Parallel Community Detection forLarge Real Graphs\u201d. The procedure greedily optimizes the approximate weightedcommunity clustering metric. First, clusters are built around highly clustered nodes.Second, we refine the initial partition by using the approximate WCC. These refinementshappen for the whole vertex set.",
        "Field List": {
            "Parameters": {
                "iterations(int)": "Refinemeent iterations. Default is 25.",
                "eps(float)": "Epsilon score for zero division correction. Default is 10**-6.",
                "seed(int)": "Random seed value. Default is 42."
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting a Label Propagation clustering model.",
                        "Arg types:": {
                            "graph(NetworkX graph)": "The graph to be clustered."
                        }
                    }
                },
                {
                    "get_memberships": {
                        "Description": "Getting the cluster membership of nodes.",
                        "Return types:": {
                            "memberships(dict)": "Node cluster memberships."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "LabelPropagation",
        "Description": "An implementation of \u201cLabel Propagation Clustering\u201dfrom the Physical Review \u201807 paper \u201cNear Linear Time Algorithm to Detect Community Structuresin Large-Scale Networks\u201d. The tool executes a series of label propagations with unique labels.The final labels are used as cluster memberships.",
        "Field List": {
            "Parameters": {
                "seed(int)": "Random seed. Default is 42.",
                "iterations(int)": "Propagation iterations. Default is 100."
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting a Label Propagation clustering model.",
                        "Arg types:": {
                            "graph(NetworkX graph)": "The graph to be clustered."
                        }
                    }
                },
                {
                    "get_memberships": {
                        "Description": "Getting the cluster membership of nodes.",
                        "Return types:": {
                            "memberships(dict)": "Node cluster memberships."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "SocioDim",
        "Description": "An implementation of \u201cSocioDim\u201dfrom the KDD \u201809 paper \u201cRelational Learning via Latent Social Dimensions\u201d.The procedure extracts the eigenvectors corresponding to the largest eigenvaluesof the graph modularity matrix. These vectors are used as the node embedding.",
        "Field List": {
            "Parameters": {
                "dimensions(int)": "Dimensionality of embedding. Default is 128.",
                "seed(int)": "Random seed value. Default is 42."
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting a Social Dimensions model.",
                        "Arg types:": {
                            "graph(NetworkX graph)": "The graph to be embedded."
                        }
                    }
                },
                {
                    "get_embedding": {
                        "Description": "Getting the node embedding.",
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of nodes."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "RandNE",
        "Description": "An implementation of \u201cRandNE\u201d from the ICDM \u201818 paper \u201cBillion-scale Network Embedding with Iterative Random Projection\u201d. The procedure uses normalized adjacency matrix basedsmoothing on an orthogonalized random normally generate base node embedding matrix.",
        "Field List": {
            "Parameters": {
                "dimensions(int)": "Number of embedding dimension. Default is 128.",
                "alphas(list)": "Smoothing weights for adjacency matrix powers. Default is [0.5, 0.5].",
                "seed(int)": "Random seed. Default is 42."
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting a NetMF model.",
                        "Arg types:": {
                            "graph(NetworkX graph)": "The graph to be embedded."
                        }
                    }
                },
                {
                    "get_embedding": {
                        "Description": "Getting the node embedding.",
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of nodes."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "GLEE",
        "Description": "An implementation of \u201cGeometric Laplacian Eigenmaps\u201dfrom the Journal of Complex Networks \u201820 paper \u201cGLEE: Geometric Laplacian Eigenmap Embedding\u201d.The procedure extracts the eigenvectors corresponding to the largest eigenvaluesof the graph Laplacian. These vectors are used as the node embedding.",
        "Field List": {
            "Parameters": {
                "dimensions(int)": "Dimensionality of embedding. Default is 128.",
                "seed(int)": "Random seed value. Default is 42."
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting a Geometric Laplacian EigenMaps model.",
                        "Arg types:": {
                            "graph(NetworkX graph)": "The graph to be embedded."
                        }
                    }
                },
                {
                    "get_embedding": {
                        "Description": "Getting the node embedding.",
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of nodes."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "Diff2Vec",
        "Description": "An implementation of \u201cDiff2Vec\u201dfrom the CompleNet \u201818 paper \u201cDiff2Vec: Fast Sequence Based Embedding with Diffusion Graphs\u201d.The procedure creates diffusion trees from every source node in the graph. These graphs are linearizedby a directed Eulerian walk, the walks are used for running the skip-gram algorithm the learn nodelevel neighbourhood based embeddings.",
        "Field List": {
            "Parameters": {
                "diffusion_number(int)": "Number of diffusions. Default is 10.",
                "diffusion_cover(int)": "Number of nodes in diffusion. Default is 80.",
                "dimensions(int)": "Dimensionality of embedding. Default is 128.",
                "workers(int)": "Number of cores. Default is 4.",
                "window_size(int)": "Matrix power order. Default is 5.",
                "epochs(int)": "Number of epochs. Default is 1.",
                "learning_rate(float)": "HogWild! learning rate. Default is 0.05.",
                "min_count(int)": "Minimal count of node occurrences. Default is 1.",
                "seed(int)": "Random seed value. Default is 42."
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting a Diff2Vec model.",
                        "Arg types:": {
                            "graph(NetworkX graph)": "The graph to be embedded."
                        }
                    }
                },
                {
                    "get_embedding": {
                        "Description": "Getting the node embedding.",
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of nodes."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "NodeSketch",
        "Description": "An implementation of \u201cNodeSketch\u201dfrom the KDD \u201819 paper \u201cNodeSketch: Highly-Efficient Graph Embeddingsvia Recursive Sketching\u201d. The procedure  starts by sketching the self-loop-augmentedadjacency matrix of the graph to output low-order node embeddings, and then recursivelygenerates k-order node embeddings based on the self-loop-augmented adjacency matrixand (k-1)-order node embeddings.",
        "Field List": {
            "Parameters": {
                "dimensions(int)": "Embedding dimensions. Default is 32.",
                "iterations(int)": "Number of iterations (sketch order minus one). Default is 2.",
                "decay(float)": "Exponential decay rate. Default is 0.01.",
                "seed(int)": "Random seed value. Default is 42."
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting a NodeSketch model.",
                        "Arg types:": {
                            "graph(NetworkX graph)": "The graph to be embedded."
                        }
                    }
                },
                {
                    "get_embedding": {
                        "Description": "Getting the node embedding.",
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of nodes."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "NetMF",
        "Description": "An implementation of \u201cNetMF\u201dfrom the WSDM \u201818 paper \u201cNetwork Embedding as Matrix Factorization: UnifyingDeepWalk, LINE, PTE, and Node2Vec\u201d. The procedure uses sparse truncated SVD tolearn embeddings for the pooled powers of the PMI matrix computed from powersof the normalized adjacency matrix.",
        "Field List": {
            "Parameters": {
                "dimensions(int)": "Number of embedding dimension. Default is 32.",
                "iteration(int)": "Number of SVD iterations. Default is 10.",
                "order(int)": "Number of PMI matrix powers. Default is 2.",
                "negative_samples(in)": "Number of negative samples. Default is 1.",
                "seed(int)": "SVD random seed. Default is 42."
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting a NetMF model.",
                        "Arg types:": {
                            "graph(NetworkX graph)": "The graph to be embedded."
                        }
                    }
                },
                {
                    "get_embedding": {
                        "Description": "Getting the node embedding.",
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of nodes."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "BoostNE",
        "Description": "An implementation of \u201cBoostNE\u201dfrom the ASONAM \u201819 paper \u201cMulti-Level Network Embedding with Boosted Low-RankMatrix Approximation\u201d. The procedure uses non-negative matrix factorizationiteratively to decompose the residuals obtained by previous factorization models.The base target matrix is a pooled sum of adjacency matrix powers.",
        "Field List": {
            "Parameters": {
                "dimensions(int)": "Number of individual embedding dimensions. Default is 8.",
                "iterations(int)": "Number of boosting iterations. Default is 16.",
                "order(int)": "Number of adjacency matrix powers. Default is 2.",
                "alpha(float)": "NMF regularization parameter. Default is 0.01.",
                "seed(int)": "Random seed value. Default is 42."
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting a BoostNE model.",
                        "Arg types:": {
                            "graph(NetworkX graph)": "The graph to be embedded."
                        }
                    }
                },
                {
                    "get_embedding": {
                        "Description": "Getting the node embedding.",
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of nodes."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "Walklets",
        "Description": "An implementation of \u201cWalklets\u201dfrom the ASONAM \u201817 paper \u201cDon\u2019t Walk, Skip! Online Learning of Multi-scaleNetwork Embeddings\u201d. The procedure uses random walks to approximate thepointwise mutual information matrix obtained by individual normalizedadjacency matrix powers. These are all decomposed by an approximatefactorization technique and the embeddings are concatenated together.",
        "Field List": {
            "Parameters": {
                "walk_number(int)": "Number of random walks. Default is 10.",
                "walk_length(int)": "Length of random walks. Default is 80.",
                "dimensions(int)": "Dimensionality of embedding. Default is 32.",
                "workers(int)": "Number of cores. Default is 4.",
                "window_size(int)": "Matrix power order. Default is 4.",
                "epochs(int)": "Number of epochs. Default is 1.",
                "learning_rate(float)": "HogWild! learning rate. Default is 0.05.",
                "min_count(int)": "Minimal count of node occurrences. Default is 1.",
                "seed(int)": "Random seed value. Default is 42."
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting a Walklets model.",
                        "Arg types:": {
                            "graph(NetworkX graph)": "The graph to be embedded."
                        }
                    }
                },
                {
                    "get_embedding": {
                        "Description": "Getting the node embedding.",
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of nodes."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "GraRep",
        "Description": "An implementation of \u201cGraRep\u201dfrom the CIKM \u201815 paper \u201cGraRep: Learning Graph Representations with GlobalStructural Information\u201d. The procedure uses sparse truncated SVD to learnembeddings for the powers of the PMI matrix computed from powers of thenormalized adjacency matrix.",
        "Field List": {
            "Parameters": {
                "dimensions(int)": "Number of individual embedding dimensions. Default is 32.",
                "iteration(int)": "Number of SVD iterations. Default is 10.",
                "order(int)": "Number of PMI matrix powers. Default is 5.",
                "seed(int)": "SVD random seed. Default is 42."
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting a GraRep model.",
                        "Arg types:": {
                            "graph(NetworkX graph)": "The graph to be embedded."
                        }
                    }
                },
                {
                    "get_embedding": {
                        "Description": "Getting the node embedding.",
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of nodes."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "DeepWalk",
        "Description": "An implementation of \u201cDeepWalk\u201dfrom the KDD \u201814 paper \u201cDeepWalk: Online Learning of Social Representations\u201d.The procedure uses random walks to approximate the pointwise mutual informationmatrix obtained by pooling normalized adjacency matrix powers. This matrixis decomposed by an approximate factorization technique.",
        "Field List": {
            "Parameters": {
                "walk_number(int)": "Number of random walks. Default is 10.",
                "walk_length(int)": "Length of random walks. Default is 80.",
                "dimensions(int)": "Dimensionality of embedding. Default is 128.",
                "workers(int)": "Number of cores. Default is 4.",
                "window_size(int)": "Matrix power order. Default is 5.",
                "epochs(int)": "Number of epochs. Default is 1.",
                "learning_rate(float)": "HogWild! learning rate. Default is 0.05.",
                "min_count(int)": "Minimal count of node occurrences. Default is 1.",
                "seed(int)": "Random seed value. Default is 42."
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting a DeepWalk model.",
                        "Arg types:": {
                            "graph(NetworkX graph)": "The graph to be embedded."
                        }
                    }
                },
                {
                    "get_embedding": {
                        "Description": "Getting the node embedding.",
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of nodes."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "Node2Vec",
        "Description": "An implementation of \u201cNode2Vec\u201dfrom the KDD \u201816 paper \u201cnode2vec: Scalable Feature Learning for Networks\u201d.The procedure uses biased second order random walks to approximate the pointwise mutual informationmatrix obtained by pooling normalized adjacency matrix powers. This matrixis decomposed by an approximate factorization technique.",
        "Field List": {
            "Parameters": {
                "walk_number(int)": "Number of random walks. Default is 10.",
                "walk_length(int)": "Length of random walks. Default is 80.",
                "p(float)": "Return parameter (1/p transition probability) to move towards from previous node.",
                "q(float)": "In-out parameter (1/q transition probability) to move away from previous node.",
                "dimensions(int)": "Dimensionality of embedding. Default is 128.",
                "workers(int)": "Number of cores. Default is 4.",
                "window_size(int)": "Matrix power order. Default is 5.",
                "epochs(int)": "Number of epochs. Default is 1.",
                "learning_rate(float)": "HogWild! learning rate. Default is 0.05.",
                "min_count(int)": "Minimal count of node occurrences. Default is 1.",
                "seed(int)": "Random seed value. Default is 42."
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting a DeepWalk model.",
                        "Arg types:": {
                            "graph(NetworkX graph)": "The graph to be embedded."
                        }
                    }
                },
                {
                    "get_embedding": {
                        "Description": "Getting the node embedding.",
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of nodes."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "NMFADMM",
        "Description": "An implementation of \u201cNMF-ADMM\u201dfrom the ICASSP \u201814 paper \u201cAlternating Direction Method of Multipliers forNon-Negative Matrix Factorization with the Beta-Divergence\u201d. The procedurelearns an embedding of the normalized adjacency matrix with by using the alternatingdirection method of multipliers to solve a non negative matrix factorization problem.",
        "Field List": {
            "Parameters": {
                "dimensions(int)": "Number of individual embedding dimensions. Default is 32.",
                "iterations(int)": "Number of ADMM iterations. Default is 100.",
                "rho(float)": "ADMM Tuning parameter. Default is 1.0.",
                "seed(int)": "Random seed value. Default is 42."
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting an NMF model on the normalized adjacency matrix with ADMM.",
                        "Arg types:": {
                            "graph(NetworkX graph)": "The graph to be embedded."
                        }
                    }
                },
                {
                    "get_embedding": {
                        "Description": "Getting the node embedding.",
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of nodes."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "LaplacianEigenmaps",
        "Description": "An implementation of \u201cLaplacian Eigenmaps\u201dfrom the NIPS \u201801 paper \u201cLaplacian Eigenmaps and Spectral Techniques for Embedding and Clustering\u201d.The procedure extracts the eigenvectors corresponding to the largest eigenvaluesof the graph Laplacian. These vectors are used as the node embedding.",
        "Field List": {
            "Parameters": {
                "dimensions(int)": "Dimensionality of embedding. Default is 128.",
                "maximum_number_of_iterations(int)": "Maximum number of iterations to execute with ARPACK. The value will be multiplied by the number of nodes.",
                "seed(int)": "Random seed value. Default is 42."
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting a Laplacian EigenMaps model.",
                        "Arg types:": {
                            "graph(NetworkX graph)": "The graph to be embedded."
                        }
                    }
                },
                {
                    "get_embedding": {
                        "Description": "Getting the node embedding.",
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of nodes."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "GraphWave",
        "Description": "An implementation of \u201cGraphWave\u201dfrom the KDD \u201818 paper \u201cLearning Structural Node Embeddings Via Diffusion Wavelets\u201d.The procedure first calculates the graph wavelets using a heat kernel. The waveletsare treated as probability distributions over nodes from a source node. Using thesethe characteristic function is evaluated at certain gird points to learn structuralnode embeddings of the vertices.",
        "Field List": {
            "Parameters": {
                "sample_number(int)": "Number of evaluation points. Default is 200.",
                "step_size(float)": "Grid point step size. Default is 0.1.",
                "heat_coefficient(float)": "Heat kernel coefficient. Default is 1.0.",
                "approximation(int)": "Chebyshev polynomial order. Default is 100.",
                "mechanism(str)": "Wavelet calculation method one of:\n(\"exact\",\"approximate\"). Default is \u2018approximate\u2019.",
                "switch(int)": "Vertex cardinality when the wavelet calculation method switches to approximation. Default is 1000.",
                "seed(int)": "Random seed value. Default is 42."
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting a GraphWave model.",
                        "Arg types:": {
                            "graph(NetworkX graph)": "The graph to be embedded."
                        }
                    }
                },
                {
                    "get_embedding": {
                        "Description": "Getting the node embedding.",
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of nodes."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "Role2Vec",
        "Description": "An implementation of \u201cRole2vec\u201dfrom the IJCAI \u201818 paper \u201cLearning Role-based Graph Embeddings\u201d.The procedure uses random walks to approximate the pointwise mutual informationmatrix obtained by multiplying the pooled adjacency power matrix with astructural feature matrix (in this case Weisfeiler-Lehman features). This wayone gets structural node embeddings.",
        "Field List": {
            "Parameters": {
                "walk_number(int)": "Number of random walks. Default is 10.",
                "walk_length(int)": "Length of random walks. Default is 80.",
                "dimensions(int)": "Dimensionality of embedding. Default is 128.",
                "workers(int)": "Number of cores. Default is 4.",
                "window_size(int)": "Matrix power order. Default is 2.",
                "epochs(int)": "Number of epochs. Default is 1.",
                "learning_rate(float)": "HogWild! learning rate. Default is 0.05.",
                "down_sampling(float)": "Down sampling frequency. Default is 0.0001.",
                "min_count(int)": "Minimal count of feature occurrences. Default is 10.",
                "wl_iterations(int)": "Number of Weisfeiler-Lehman hashing iterations. Default is 2.",
                "seed(int)": "Random seed value. Default is 42.",
                "erase_base_features(bool)": "Removing the base features. Default is False."
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting a Role2vec model.",
                        "Arg types:": {
                            "graph(NetworkX graph)": "The graph to be embedded."
                        }
                    }
                },
                {
                    "get_embedding": {
                        "Description": "Getting the node embedding.",
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of nodes."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "FeatherNode",
        "Description": "An implementation of \u201cFEATHER-N\u201dfrom the CIKM \u201820 paper \u201cCharacteristic Functions on Graphs: Birds of a Feather,from Statistical Descriptors to Parametric Models\u201d. The procedureuses characteristic functions of node features with random walk weights to describenode neighborhoods.",
        "Field List": {
            "Parameters": {
                "reduction_dimensions(int)": "SVD reduction dimensions. Default is 64.",
                "svd_iterations(int)": "SVD iteration count. Default is 20.",
                "theta_max(float)": "Maximal evaluation point. Default is 2.5.",
                "eval_points(int)": "Number of characteristic function evaluation points. Default is 25.",
                "order(int)": "Scale - number of adjacency matrix powers. Default is 5.",
                "seed(int)": "Random seed value. Default is 42."
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting a FEATHER-N model.",
                        "Arg types:": {
                            "graph(NetworkX graph)": "The graph to be embedded.",
                            "X(Scipy COO or Numpy array)": "The matrix of node features."
                        }
                    }
                },
                {
                    "get_embedding": {
                        "Description": "Getting the node embedding.",
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of nodes."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "AE",
        "Description": "An implementation of \u201cAE\u201dfrom the Arxiv \u201819 paper \u201cMUSAE: Multi-Scale Attributed Node Embedding\u201d. Theprocedure does attributed random walks to approximate the pooled adjacencymatrix power node feature matrix product. The matrix is decomposedimplicitly by a Skip-Gram style optimization problem.",
        "Field List": {
            "Parameters": {
                "walk_number(int)": "Number of random walks. Default is 5.",
                "walk_length(int)": "Length of random walks. Default is 80.",
                "dimensions(int)": "Dimensionality of embedding. Default is 32.",
                "workers(int)": "Number of cores. Default is 4.",
                "window_size(int)": "Matrix power order. Default is 3.",
                "epochs(int)": "Number of epochs. Default is 1.",
                "learning_rate(float)": "HogWild! learning rate. Default is 0.05.",
                "down_sampling(float)": "Down sampling rate in the corpus. Default is 0.0001.",
                "min_count(int)": "Minimal count of node occurrences. Default is 1.",
                "seed(int)": "Random seed value. Default is 42."
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting an AE model.",
                        "Arg types:": {
                            "graph(NetworkX graph)": "The graph to be embedded.",
                            "X(Scipy COO array)": "The binary matrix of node features."
                        }
                    }
                },
                {
                    "get_embedding": {
                        "Description": "Getting the node embedding.",
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of nodes."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "MUSAE",
        "Description": "An implementation of \u201cMUSAE\u201dfrom the Arxiv \u201819 paper \u201cMUSAE: Multi-Scale Attributed Node Embedding\u201d. Theprocedure does attributed random walks to approximate the adjacency matrix powernode feature matrix products. The matrices are decomposed implicitly by a Skip-Gramstyle optimizer. The individual embeddings are concatenated together to form amulti-scale attributed node embedding. This way the feature distributions at different scalesare separable.",
        "Field List": {
            "Parameters": {
                "walk_number(int)": "Number of random walks. Default is 5.",
                "walk_length(int)": "Length of random walks. Default is 80.",
                "dimensions(int)": "Dimensionality of embedding. Default is 32.",
                "workers(int)": "Number of cores. Default is 4.",
                "window_size(int)": "Matrix power order. Default is 3.",
                "epochs(int)": "Number of epochs. Default is 1.",
                "learning_rate(float)": "HogWild! learning rate. Default is 0.05.",
                "down_sampling(float)": "Down sampling rate in the corpus. Default is 0.0001.",
                "min_count(int)": "Minimal count of node occurrences. Default is 1.",
                "seed(int)": "Random seed value. Default is 42."
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting a MUSAE model.",
                        "Arg types:": {
                            "graph(NetworkX graph)": "The graph to be embedded.",
                            "X(Scipy COO array)": "The binary matrix of node features."
                        }
                    }
                },
                {
                    "get_embedding": {
                        "Description": "Getting the node embedding.",
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of nodes."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "SINE",
        "Description": "An implementation of \u201cSINE\u201dfrom the ICDM \u201818 paper \u201cSINE: Scalable Incomplete Network Embedding\u201d. Theprocedure implicitly factorizes a joint adjacency matrix power and feature matrix.The decomposition happens on truncated random walks and the adjacency matrix powersare pooled together.",
        "Field List": {
            "Parameters": {
                "walk_number(int)": "Number of random walks. Default is 10.",
                "walk_length(int)": "Length of random walks. Default is 80.",
                "dimensions(int)": "Dimensionality of embedding. Default is 128.",
                "workers(int)": "Number of cores. Default is 4.",
                "window_size(int)": "Matrix power order. Default is 5.",
                "epochs(int)": "Number of epochs. Default is 1.",
                "learning_rate(float)": "HogWild! learning rate. Default is 0.05.",
                "min_count(int)": "Minimal count of node occurrences. Default is 1.",
                "seed(int)": "Random seed value. Default is 42."
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting a SINE model.",
                        "Arg types:": {
                            "graph(NetworkX graph)": "The graph to be embedded.",
                            "X(Scipy COO array)": "The matrix of node features."
                        }
                    }
                },
                {
                    "get_embedding": {
                        "Description": "Getting the node embedding.",
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of nodes."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "BANE",
        "Description": "An implementation of \u201cBANE\u201dfrom the ICDM \u201818 paper \u201cBinarized Attributed Network Embedding Class\u201d. Theprocedure first calculates the truncated SVD of an adjacency - feature matrixproduct. This matrix is further decomposed by a binary CCD based technique.",
        "Field List": {
            "Parameters": {
                "dimensions(int)": "Number of embedding dimensions. Default is 32.",
                "svd_iterations(int)": "SVD iteration count. Default is 20.",
                "seed(int)": "Random seed. Default is 42.",
                "alpha(float)": "Kernel matrix inversion parameter. Default is 0.3.",
                "iterations(int)": "Matrix decomposition iterations. Default is 100.",
                "binarization_iterations(int)": "Binarization iterations. Default is 20.",
                "seed": "Random seed value. Default is 42."
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting a BANE model.",
                        "Arg types:": {
                            "graph(NetworkX graph)": "The graph to be embedded.",
                            "X(Scipy COO or Numpy array)": "The matrix of node features."
                        }
                    }
                },
                {
                    "get_embedding": {
                        "Description": "Getting the node embedding.",
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of nodes."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "TENE",
        "Description": "An implementation of \u201cTENE\u201dfrom the ICPR \u201818 paper \u201cEnhanced Network Embedding with Text Information\u201d. Theprocedure jointly factorizes the adjacency and node feature matrices using alternatingleast squares.",
        "Field List": {
            "Parameters": {
                "dimensions(int)": "Number of embedding dimensions. Default is 32.",
                "lower_control(float)": "Embedding score minimal value. Default is 10**-15.",
                "alpha(float)": "Adjacency matrix regularization coefficient. Default is 0.1.",
                "beta(float)": "Feature matrix regularization coefficient. Default is 0.1.",
                "iterations(int)": "ALS iterations. Default is 200.",
                "seed(int)": "Random seed value. Default is 42."
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting a TENE model.",
                        "Arg types:": {
                            "graph(NetworkX graph)": "The graph to be embedded.",
                            "T(Scipy COO or Numpy array)": "The matrix of node features."
                        }
                    }
                },
                {
                    "get_embedding": {
                        "Description": "Getting the node embedding.",
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of nodes."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "TADW",
        "Description": "An implementation of \u201cTADW\u201dfrom the IJCAI \u201815 paper \u201cNetwork Representation Learning with Rich Text Information\u201d. Theprocedure uses the node attribute matrix with a factorization matrix to reproduce a powerof the adjacency matrix to create representations.",
        "Field List": {
            "Parameters": {
                "dimensions(int)": "Number of embedding dimensions. Default is 32.",
                "reduction_dimensions(int)": "SVD reduction dimensions. Default is 64.",
                "svd_iterations(int)": "SVD iteration count. Default is 20.",
                "seed(int)": "Random seed. Default is 42.",
                "alpha(float)": "Learning rate. Default is 0.01.",
                "iterations(int)": "Matrix decomposition iterations. Default is 10.",
                "lambd(float)": "Regularization coefficient. Default is 10.0."
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting a TADW model.",
                        "Arg types:": {
                            "graph(NetworkX graph)": "The graph to be embedded.",
                            "X(Scipy COO or Numpy array)": "The matrix of node features."
                        }
                    }
                },
                {
                    "get_embedding": {
                        "Description": "Getting the node embedding.",
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of nodes."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "FSCNMF",
        "Description": "An implementation of \u201cFCNMF\u201dfrom the Arxiv \u201818 paper \u201cFusing Structure and Content via Non-negative MatrixFactorization for Embedding Information Networks\u201d. The procedure uses a jointmatrix factorization technique on the adjacency and feature matrices. The nodeand feature embeddings are co-regularized for alignment of the embedding spaces.",
        "Field List": {
            "Parameters": {
                "dimensions(int)": "Number of embedding dimensions. Default is 32.",
                "lower_control(float)": "Embedding score minimal value. Default is 10**-15.",
                "iterations(int)": "Power iterations. Default is 500.",
                "alpha_1(float)": "Alignment parameter for adjacency matrix. Default is 1000.0.",
                "alpha_2(float)": "Adjacency basis regularization. Default is 1.0.",
                "alpha_3(float)": "Adjacency features regularization. Default is 1.0.",
                "beta_1(float)": "Alignment parameter for feature matrix. Default is 1000.0.",
                "beta_2(float)": "Attribute basis regularization. Default is 1.0.",
                "beta_3(float)": "Attribute basis regularization. Default is 1.0.",
                "seed(int)": "Random seed value. Default is 42."
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting an FSCNMF model.",
                        "Arg types:": {
                            "graph(NetworkX graph)": "The graph to be embedded.",
                            "X(Scipy COO or Numpy array)": "The matrix of node features."
                        }
                    }
                },
                {
                    "get_embedding": {
                        "Description": "Getting the node embedding.",
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of nodes."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "ASNE",
        "Description": "An implementation of \u201cASNE\u201dfrom the TKDE \u201818 paper \u201cAttributed Social Network Embedding\u201d. Theprocedure implicitly factorizes a concatenated adjacency matrix and feature matrix.",
        "Field List": {
            "Parameters": {
                "dimensions(int)": "Dimensionality of embedding. Default is 128.",
                "workers(int)": "Number of cores. Default is 4.",
                "epochs(int)": "Number of epochs. Default is 100.",
                "down_sampling(float)": "Down sampling frequency. Default is 0.0001.",
                "learning_rate(float)": "HogWild! learning rate. Default is 0.05.",
                "min_count(int)": "Minimal count of node occurrences. Default is 1.",
                "seed(int)": "Random seed value. Default is 42."
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting an ASNE model.",
                        "Arg types:": {
                            "graph(NetworkX graph)": "The graph to be embedded.",
                            "X(Scipy COO array)": "The matrix of node features."
                        }
                    }
                },
                {
                    "get_embedding": {
                        "Description": "Getting the node embedding.",
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of nodes."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "NEU",
        "Description": "An implementation of \u201cNEU\u201dfrom the IJCAI 17 paper \u201cFast Network Embedding Enhancement via High Order Proximity Approximation\u201d.The procedure uses an arbitrary embedding and augments it by higher order proximities with a recursivemeta learning algorithm.",
        "Field List": {
            "Parameters": {
                "L1(float)": "Weight of lower order proximities. Defauls is 0.5",
                "L2(float)": "Weight of higher order proximities. Default is 0.25.",
                "T(int)": "Number of iterations. Default is 1.",
                "seed(int)": "Random seed value. Default is 42."
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting an NEU model.",
                        "Arg types:": {
                            "graph * (*)": "",
                            "model * (*)": ""
                        }
                    }
                },
                {
                    "get_embedding": {
                        "Description": "Getting the node embedding.",
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of nodes."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "WaveletCharacteristic",
        "Description": "An implementation of \u201cWaveCharacteristic\u201dfrom the CIKM \u201821 paper \u201cGraph Embedding via Diffusion-Wavelets-Based Node FeatureDistribution Characterization\u201d. The procedure uses characteristic functions ofnode features with wavelet function weights to describe node neighborhoods.These node level features are pooled by mean pooling to create graph level statistics.",
        "Field List": {
            "Parameters": {
                "order(int)": "Adjacency matrix powers. Default is 5.",
                "eval_points(int)": "Number of characteristic function evaluations. Default is 5.",
                "theta_max(float)": "Largest characteristic function time value. Default is 2.5.",
                "tau(float)": "Wave function heat - time diffusion. Default is 1.0.",
                "pooling(str)": "Pooling function appliead to the characteristic functions. Default is \u201cmean\u201d."
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting a Geometric-Scattering model.",
                        "Arg types:": {
                            "graphs(List of NetworkX graphs)": "The graphs to be embedded."
                        }
                    }
                },
                {
                    "get_embedding": {
                        "Description": "Getting the embedding of graphs.",
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of graphs."
                        }
                    }
                },
                {
                    "infer": {
                        "Description": "Infer the graph embeddings.",
                        "Arg types:": {
                            "graphs(List of NetworkX graphs)": "The graphs to be embedded."
                        },
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of graphs."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "LDP",
        "Description": "An implementation of \u201cLDP\u201d from theICLR Representation Learning on Graphs and Manifolds Workshop \u201819 paper \u201cASimple Yet Effective Baseline for Non-Attributed Graph Classification\u201d. Theprocedure calculates histograms of degree profiles. These concatenatedhistograms form the graph representations.",
        "Field List": {
            "Parameters": {
                "bins (int) ": "Number of histogram bins. Default is 32."
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting an LDP model.",
                        "Arg types:": {
                            "graphs(List of NetworkX graphs)": "The graphs to be embedded."
                        }
                    }
                },
                {
                    "get_embedding": {
                        "Description": "Getting the embedding of graphs.",
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of graphs."
                        }
                    }
                },
                {
                    "infer": {
                        "Description": "Infer the embedding of graphs.",
                        "Arg types:": {
                            "graphs(List of NetworkX graphs)": "The graphs to be embedded."
                        },
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of graphs."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "FeatherGraph",
        "Description": "An implementation of \u201cFEATHER-G\u201dfrom the CIKM \u201820 paper \u201cCharacteristic Functions on Graphs: Birds of a Feather,from Statistical Descriptors to Parametric Models\u201d. The procedureuses characteristic functions of node features with random walk weights to describenode neighborhoods. These node level features are pooled by mean pooling tocreate graph level statistics.",
        "Field List": {
            "Parameters": {
                "order(int)": "Adjacency matrix powers. Default is 5.",
                "eval_points(int)": "Number of evaluation points. Default is 25.",
                "theta_max(int)": "Maximal evaluation point value. Default is 2.5.",
                "seed(int)": "Random seed value. Default is 42.",
                "pooling(str)": "Permutation invariant pooling function, one of:\n(\"mean\",\"max\",\"min\"). Default is \u201cmean.\u201d"
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting a graph level FEATHER model.",
                        "Arg types:": {
                            "graphs(List of NetworkX graphs)": "The graphs to be embedded."
                        }
                    }
                },
                {
                    "get_embedding": {
                        "Description": "Getting the embedding of graphs.",
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of graphs."
                        }
                    }
                },
                {
                    "infer": {
                        "Description": "Inferring graph embeddings with a graph level FEATHER model.",
                        "Arg types:": {
                            "graphs(List of NetworkX graphs)": "The graphs to be embedded."
                        },
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of graphs."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "IGE",
        "Description": "An implementation of \u201cInvariant Graph Embedding\u201dfrom the ICML 2019 Workshop on Learning and Reasoning with Graph-StructuredData paper \u201cInvariant Embedding for Graph Classification\u201d. The procedurecomputes a mixture of spectral and node embedding based features. Specifically,it uses scattering, eigenvalues and pooled node feature embeddings to creategraph descriptors.",
        "Field List": {
            "Parameters": {
                "feature_embedding_dimensions(list)": "Feature embedding dimensions. Default is [3, 5]",
                "spectral_embedding_dimensions(list)": "Spectral embedding dimensions. Default is [10, 20].",
                "histogram_bins(list)": "Number of histogram bins. Default is [10, 20].",
                "seed(int)": "Random seed value. Default is 42."
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting an Invariant Graph Embedding model.",
                        "Arg types:": {
                            "graphs(List of NetworkX graphs)": "The graphs to be embedded."
                        }
                    }
                },
                {
                    "get_embedding": {
                        "Description": "Getting the embedding of graphs.",
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of graphs."
                        }
                    }
                },
                {
                    "infer": {
                        "Description": "Infer the embedding of graphs.",
                        "Arg types:": {
                            "graphs(List of NetworkX graphs)": "The graphs to be embedded."
                        },
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of graphs."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "GeoScattering",
        "Description": "An implementation of \u201cGeoScattering\u201dfrom the ICML \u201819 paper \u201cGeometric Scattering for Graph Data Analysis\u201d. The procedureuses scattering with wavelet transforms to create graph spectral descriptors. Moments of thewavelet transformed features are used as graph level features for the embedding.",
        "Field List": {
            "Parameters": {
                "order(int)": "Adjacency matrix powers. Default is 4.",
                "moments(int)": "Unnormalized moments considered. Default is 4.",
                "seed(int)": "Random seed value. Default is 42."
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting a Geometric-Scattering model.",
                        "Arg types:": {
                            "graphs(List of NetworkX graphs)": "The graphs to be embedded."
                        }
                    }
                },
                {
                    "get_embedding": {
                        "Description": "Getting the embedding of graphs.",
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of graphs."
                        }
                    }
                },
                {
                    "infer": {
                        "Description": "Infer the embedding of graphs.",
                        "Arg types:": {
                            "graphs(List of NetworkX graphs)": "The graphs to be embedded."
                        },
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of graphs."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "GL2Vec",
        "Description": "An implementation of \u201cGL2Vec\u201dfrom the ICONIP \u201819 paper \u201cGL2vec: Graph Embedding Enriched by Line Graphs with Edge Features\u201d.First, the algorithm creates the line graph of each graph in the graph dataset.The procedure creates Weisfeiler-Lehman tree features for nodes in graphs. Usingthese features a document (graph) - feature co-occurrence matrix is decomposed in orderto generate representations for the graphs.",
        "Field List": {
            "Parameters": {
                "wl_iterations(int)": "Number of Weisfeiler-Lehman iterations. Default is 2.",
                "dimensions(int)": "Dimensionality of embedding. Default is 128.",
                "workers(int)": "Number of cores. Default is 4.",
                "down_sampling(float)": "Down sampling frequency. Default is 0.0001.",
                "epochs(int)": "Number of epochs. Default is 10.",
                "learning_rate(float)": "HogWild! learning rate. Default is 0.025.",
                "min_count(int)": "Minimal count of graph feature occurrences. Default is 5.",
                "seed(int)": "Random seed for the model. Default is 42."
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting a GL2Vec model.",
                        "Arg types:": {
                            "graphs(List of NetworkX graphs)": "The graphs to be embedded."
                        }
                    }
                },
                {
                    "get_embedding": {
                        "Description": "Getting the embedding of graphs.",
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of graphs."
                        }
                    }
                },
                {
                    "infer": {
                        "Description": "Infer the graph embeddings.",
                        "Arg types:": {
                            "graphs(List of NetworkX graphs)": "The graphs to be embedded."
                        },
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of graphs."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "NetLSD",
        "Description": "An implementation of \u201cNetLSD\u201dfrom the KDD \u201818 paper \u201cNetLSD: Hearing the Shape of a Graph\u201d. The procedurecalculate the heat kernel trace of the normalized Laplacian matrix over avector of time scales. If the matrix is large it switches to an approximationof the eigenvalues.",
        "Field List": {
            "Parameters": {
                "scale_min(float)": "Time scale interval minimum. Default is -2.0.",
                "scale_max(float)": "Time scale interval maximum. Default is 2.0.",
                "scale_steps(int)": "Number of steps in time scale. Default is 250.",
                "scale_approximations(int)": "Number of eigenvalue approximations. Default is 200.",
                "seed(int)": "Random seed value. Default is 42."
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting a NetLSD model.",
                        "Arg types:": {
                            "graphs(List of NetworkX graphs)": "The graphs to be embedded."
                        }
                    }
                },
                {
                    "get_embedding": {
                        "Description": "Getting the embedding of graphs.",
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of graphs."
                        }
                    }
                },
                {
                    "infer": {
                        "Description": "Inferring the NetLSD embeddings.",
                        "Arg types:": {
                            "graphs(List of NetworkX graphs)": "The graphs to be embedded."
                        },
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of graphs."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "SF",
        "Description": "An implementation of \u201cSF\u201dfrom the NeurIPS Relational Representation Learning Workshop \u201818 paper \u201cA Simple Baseline Algorithm for Graph Classification\u201d.The procedure calculates the k lowest eigenvalues of the normalized Laplacian.If the graph has a lower number of eigenvalues than k the representation is padded with zeros.",
        "Field List": {
            "Parameters": {
                "dimensions(int)": "Number of lowest eigenvalues. Default is 128.",
                "seed(int)": "Random seed value. Default is 42."
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting an SF model.",
                        "Arg types:": {
                            "graphs(List of NetworkX graphs)": "The graphs to be embedded."
                        }
                    }
                },
                {
                    "get_embedding": {
                        "Description": "Getting the embedding of graphs.",
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of graphs."
                        }
                    }
                },
                {
                    "infer": {
                        "Description": "Inferring the embedding vectors.",
                        "Arg types:": {
                            "graphs(List of NetworkX graphs)": "The graphs to be embedded."
                        },
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of graphs."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "FGSD",
        "Description": "An implementation of \u201cFGSD\u201dfrom the NeurIPS \u201817 paper \u201cHunt For The Unique, Stable, Sparse And Fast Feature Learning On Graphs\u201d.The procedure calculates the Moore-Penrose spectrum of the normalized Laplacian.Using this spectrum the histogram of the spectral features is used as a whole graph representation.",
        "Field List": {
            "Parameters": {
                "hist_bins(int)": "Number of histogram bins. Default is 200.",
                "hist_range(int)": "Histogram range considered. Default is 20.",
                "seed(int)": "Random seed value. Default is 42."
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting a FGSD model.",
                        "Arg types:": {
                            "graphs(List of NetworkX graphs)": "The graphs to be embedded."
                        }
                    }
                },
                {
                    "get_embedding": {
                        "Description": "Getting the embedding of graphs.",
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of graphs."
                        }
                    }
                },
                {
                    "infer": {
                        "Description": "Inferring the embedding for a list of graphs.",
                        "Arg types:": {
                            "graphs(List of NetworkX graphs)": "The graphs to be embedded."
                        },
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of graphs."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "Graph2Vec",
        "Description": "An implementation of \u201cGraph2Vec\u201dfrom the MLGWorkshop \u201817 paper \u201cGraph2Vec: Learning Distributed Representations of Graphs\u201d.The procedure creates Weisfeiler-Lehman tree features for nodes in graphs. Usingthese features a document (graph) - feature co-occurrence matrix is decomposed in orderto generate representations for the graphs.",
        "Field List": {
            "Parameters": {
                "wl_iterations(int)": "Number of Weisfeiler-Lehman iterations. Default is 2.",
                "attributed(bool)": "Presence of graph attributes. Default is False.",
                "dimensions(int)": "Dimensionality of embedding. Default is 128.",
                "workers(int)": "Number of cores. Default is 4.",
                "down_sampling(float)": "Down sampling frequency. Default is 0.0001.",
                "epochs(int)": "Number of epochs. Default is 10.",
                "learning_rate(float)": "HogWild! learning rate. Default is 0.025.",
                "min_count(int)": "Minimal count of graph feature occurrences. Default is 5.",
                "seed(int)": "Random seed for the model. Default is 42.",
                "erase_base_features(bool)": "Erasing the base features. Default is False."
            },
            "Methods": [
                {
                    "fit": {
                        "Description": "Fitting a Graph2Vec model.",
                        "Arg types:": {
                            "graphs(List of NetworkX graphs)": "The graphs to be embedded."
                        }
                    }
                },
                {
                    "get_embedding": {
                        "Description": "Getting the embedding of graphs.",
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of graphs."
                        }
                    }
                },
                {
                    "infer": {
                        "Description": "Infer the graph embeddings.",
                        "Arg types:": {
                            "graphs(List of NetworkX graphs)": "The graphs to be embedded."
                        },
                        "Return types:": {
                            "embedding(Numpy array)": "The embedding of graphs."
                        }
                    }
                }
            ]
        }
    },
    {
        "Section_id": "RandomNodeSampler",
        "Description": "An implementation of random node sampling. Nodes are sampled with uniform probability. For details about the algorithm see this paper.",
        "Field List": {
            "Parameters": {
                "number_of_nodes": "Number of nodes. Default is 100.",
                "seed": "Random seed. Default is 42."
            },
            "Methods": {
                "sample": {
                    "Description": "Sampling nodes randomly.",
                    "Arg types": {
                        "graph": "NetworkX or NetworKit graph - The graph to be sampled from."
                    },
                    "Return types": {
                        "new_graph": "NetworkX or NetworKit graph - The graph of sampled nodes."
                    }
                }
            }
        }
    },
    {
        "Section_id": "DegreeBasedSampler",
        "Description": "An implementation of degree based sampling. Nodes are sampled proportional to the degree centrality of nodes. For details about the algorithm see this paper.",
        "Field List": {
            "Parameters": {
                "number_of_nodes": "Number of nodes. Default is 100.",
                "seed": "Random seed. Default is 42."
            },
            "Methods": {
                "sample": {
                    "Description": "Sampling nodes proportional to the degree.",
                    "Arg types": {
                        "graph": "NetworkX or NetworKit graph - The graph to be sampled from."
                    },
                    "Return types": {
                        "new_graph": "NetworkX or NetworKit graph - The graph of sampled nodes."
                    }
                }
            }
        }
    },
    {
        "Section_id": "PageRankBasedSampler",
        "Description": "An implementation of PageRank based sampling. Nodes are sampled proportional to the PageRank score of nodes. For details about the algorithm see this paper.",
        "Field List": {
            "Parameters": {
                "number_of_nodes": "Number of nodes. Default is 100.",
                "seed": "Random seed. Default is 42."
            },
            "Methods": {
                "sample": {
                    "Description": "Sampling nodes randomly proportional to the normalized pagerank score.",
                    "Arg types": {
                        "graph": "NetworkX or NetworKit graph - The graph to be sampled from."
                    },
                    "Return types": {
                        "new_graph": "NetworkX or NetworKit graph - The graph of sampled nodes."
                    }
                }
            }
        }
    },
    {
        "Section_id": "RandomEdgeSampler",
        "Description": "An implementation of random edge sampling. Edges are sampled with the same uniform probability randomly. For details about the algorithm see this paper.",
        "Field List": {
            "Parameters": {
                "number_of_edges": "int - Number of edges. Default is 100.",
                "seed": "int - Random seed. Default is 42."
            },
            "Methods": {
                "sample": {
                    "Description": "Sampling edges randomly.",
                    "Arg types": {
                        "graph": "NetworkX or NetworKit graph - The graph to be sampled from."
                    },
                    "Return types": {
                        "new_graph": "NetworkX or NetworKit graph - The graph of sampled edges."
                    }
                }
            }
        }
    },
    {
        "Section_id": "RandomNodeEdgeSampler",
        "Description": "An implementation of random node-edge sampling. The algorithm first randomly samples a node. From this node it samples an edge with a neighbor. For details about the algorithm see this paper.",
        "Field List": {
            "Parameters": {
                "number_of_edges": "int - Number of edges. Default is 100.",
                "seed": "int - Random seed. Default is 42."
            },
            "Methods": {
                "sample": {
                    "Description": "Sampling edges randomly from randomly sampled nodes.",
                    "Arg types": {
                        "graph": "NetworkX or NetworKit graph - The graph to be sampled from."
                    },
                    "Return types": {
                        "new_graph": "NetworkX or NetworKit graph - The graph of sampled edges."
                    }
                }
            }
        }
    },
    {
        "Section_id": "HybridNodeEdgeSampler",
        "Description": "An implementation of hybrid node-edge sampling. The algorithm alternates between two sampling methods. (A) Random uniform edge sampling. (B) The algorithm first randomly samples a node. From this node it samples an edge with a neighbor. For details about the algorithm see this paper.",
        "Field List": {
            "Parameters": {
                "number_of_edges": "int - Number of edges. Default is 100.",
                "seed": "int - Random seed. Default is 42.",
                "p": "float - Hybridization probability. Default is 0.8."
            },
            "Methods": {
                "sample": {
                    "Description": "Sampling edges randomly from randomly sampled nodes or sampling random edges.",
                    "Arg types": {
                        "graph": "NetworkX or NetworKit graph - The graph to be sampled from."
                    },
                    "Return types": {
                        "new_graph": "NetworkX or NetworKit graph - The graph of sampled edges."
                    }
                }
            }
        }
    },
    {
        "Section_id": "RandomEdgeSamplerWithInduction",
        "Description": "An implementation of random edge sampling with edge set induction. The algorithm randomly samples edges with a fixed probability. Edges between nodes which are already in the sample are retained with an induction step. For details about the algorithm see this paper.",
        "Field List": {
            "Parameters": {
                "number_of_edges": "int - Number of edges. Default is 100.",
                "seed": "int - Random seed. Default is 42."
            },
            "Methods": {
                "sample": {
                    "Description": "Sampling edges randomly with induction.",
                    "Arg types": {
                        "graph": "NetworkX or NetworKit graph - The graph to be sampled from."
                    },
                    "Return types": {
                        "new_graph": "NetworkX or NetworKit graph - The graph of sampled edges."
                    }
                }
            }
        }
    },
    {
        "Section_id": "GraphReader",
        "Description": "Class to read benchmark datasets for the sampling task.",
        "Field List": {
            "Parameters": {
                "dataset": "str - Dataset of interest. One of facebook/wikipedia/github/twitch/deezer/lastfm. Default is \u2018wikipedia\u2019."
            },
            "Methods": {
                "get_graph": {
                    "Description": "Getting the graph.",
                    "Return types": {
                        "graph": "NetworkX graph - Graph of interest."
                    }
                }
            }
        }
    },
    {
        "Section_id": "DiffusionSampler",
        "Description": "An implementation of exploration sampling by a diffusion branching process. A simple diffusion which creates an induced subgraph by an incrementally diffusion. For details about the algorithm see this paper.",
        "Field List": {
            "Parameters": {
                "number_of_nodes": "int - Number of nodes. Default is 100.",
                "seed": "int - Random seed. Default is 42."
            },
            "Methods": {
                "sample": {
                    "Description": "Sampling nodes with a diffusion process.",
                    "Arg types": {
                        "graph": "NetworkX or NetworKit graph - The graph to be sampled from.",
                        "start_node": "int, optional - The start node."
                    },
                    "Return types": {
                        "new_graph": "NetworkX or NetworKit graph - The graph of sampled nodes."
                    }
                }
            }
        }
    },
    {
        "Section_id": "DiffusionTreeSampler",
        "Description": "An implementation of exploration sampling by a diffusion branching process. A simple diffusion which creates an induced tree by an incrementally diffusion. For details about the algorithm see this paper.",
        "Field List": {
            "Parameters": {
                "number_of_nodes": "int - Number of nodes. Default is 100.",
                "seed": "int - Random seed. Default is 42."
            },
            "Methods": {
                "sample": {
                    "Description": "Sampling nodes with a diffusion process.",
                    "Arg types": {
                        "graph": "NetworkX or NetworKit graph - The graph to be sampled from.",
                        "start_node": "int, optional - The start node."
                    },
                    "Return types": {
                        "new_graph": "NetworkX or NetworKit graph - The graph of sampled nodes."
                    }
                }
            }
        }
    },
    {
        "Section_id": "ForestFireSampler",
        "Description": "An implementation of forest fire sampling. The procedure is a stochastic snowball sampling method where the expansion is proportional to the burning probability. For details about the algorithm see this paper.",
        "Field List": {
            "Parameters": {
                "number_of_nodes": "int - Number of sampled nodes. Default is 100.",
                "p": "float - Burning probability. Default is 0.4.",
                "seed": "int - Random seed. Default is 42."
            },
            "Methods": {
                "sample": {
                    "Description": "Sampling nodes iteratively with a forest fire sampler.",
                    "Arg types": {
                        "graph": "NetworkX or NetworKit graph - The graph to be sampled from."
                    },
                    "Return types": {
                        "new_graph": "NetworkX or NetworKit graph - The graph of sampled nodes."
                    }
                }
            }
        }
    },
    {
        "Section_id": "SpikyBallSampler",
        "Description": "An implementation of spiky ball sampling. The procedure is a filtered breadth-first search sampling method where the expansion is is performed over a random subset of neighbors. For details about the algorithm see this paper.",
        "Field List": {
            "Parameters": {
                "number_of_nodes": "int - Number of sampled nodes. Default is 100.",
                "sampling_probability": "float - Edge sampling probability. Default is 0.1.",
                "initial_nodes_ratio": "float - Initial ratio of sampled nodes. Default is 0.1.",
                "seed": "int - Random seed. Default is 42.",
                "max_hops": "int - Number of hops. Default is 100000.",
                "mode": "str - Sampling procedure, one of: (\"edgeball\", \"hubball\", \"coreball\", \"fireball\", \"firecoreball\"). Default is \u2018fireball\u2019.",
                "max_visited_nodes_backlog": "int - Maximal number of nodes in restart queue. Default is 100.",
                "restart_hop_size": "int - Mimimal number of nodes to pop from restart queue. Default is 10.",
                "distrib_coeff": "float - Proposal distribution power coefficient. Default is 1.0."
            },
            "Methods": {
                "sample": {
                    "Description": "Sampling nodes iteratively with a spiky ball sampler.",
                    "Arg types": {
                        "graph": "NetworkX or NetworKit graph - The graph to be sampled from."
                    },
                    "Return types": {
                        "new_graph": "NetworkX or NetworKit graph - The graph of sampled nodes."
                    }
                }
            }
        }
    },
    {
        "Section_id": "CommonNeighborAwareRandomWalkSampler",
        "Description": "An implementation of node sampling by common neighbor aware random walks. The random walker is biased to visit neighbors that have a lower number of common neighbors. For details about the algorithm see this paper.",
        "Field List": {
            "Parameters": {
                "number_of_nodes": "int - Number of nodes. Default is 100.",
                "seed": "int - Random seed. Default is 42."
            },
            "Methods": {
                "sample": {
                    "Description": "Sampling nodes with a single common neighbor aware random walk.",
                    "Arg types": {
                        "graph": "NetworkX or NetworKit graph - The graph to be sampled from.",
                        "start_node": "int, optional - The start node."
                    },
                    "Return types": {
                        "new_graph": "NetworkX or NetworKit graph - The graph of sampled nodes."
                    }
                }
            }
        }
    },
    {
        "Section_id": "NonBackTrackingRandomWalkSampler",
        "Description": "An implementation of node sampling by non back-tracking random walks. The process generates a random walk in which the random walker cannot make steps backwards. This way the tottering behaviour of random walkers can be avoided. For details about the algorithm see this paper.",
        "Field List": {
            "Parameters": {
                "number_of_nodes": "int - Number of nodes. Default is 100.",
                "seed": "int - Random seed. Default is 42."
            },
            "Methods": {
                "sample": {
                    "Description": "Sampling nodes with a single non back-tracking random walk.",
                    "Arg types": {
                        "graph": "NetworkX or NetworKit graph - The graph to be sampled from.",
                        "start_node": "int, optional - The start node."
                    },
                    "Return types": {
                        "new_graph": "NetworkX or NetworKit graph - The graph of sampled edges."
                    }
                }
            }
        }
    },
    {
        "Section_id": "LoopErasedRandomWalkSampler",
        "Description": "An implementation of node sampling by loop-erased random walks. The random walkers samples a fixed number of nodes. Only edges that connect so far unconnected nodes to the sampled node set are added to the edge set (cycles are erased). The resulting graph is always an undirected tree. For details about the algorithm see this paper.",
        "Field List": {
            "Parameters": {
                "number_of_nodes": "int - Number of nodes. Default is 100.",
                "seed": "int - Random seed. Default is 42."
            },
            "Methods": {
                "sample": {
                    "Description": "Sampling nodes with a single loop-erased random walk.",
                    "Arg types": {
                        "graph": "NetworkX or NetworKit graph - The graph to be sampled from.",
                        "start_node": "int, optional - The start node."
                    },
                    "Return types": {
                        "new_graph": "NetworkX or NetworKit graph - The graph of sampled edges."
                    }
                }
            }
        }
    },
    {
        "Section_id": "RandomWalkSampler",
        "Description": "An implementation of node sampling by random walks. A simple random walker which creates an induced subgraph by walking around. For details about the algorithm see this paper.",
        "Field List": {
            "Parameters": {
                "number_of_nodes": "int - Number of nodes. Default is 100.",
                "seed": "int - Random seed. Default is 42."
            },
            "Methods": {
                "sample": {
                    "Description": "Sampling nodes with a single random walk.",
                    "Arg types": {
                        "graph": "NetworkX or NetworKit graph - The graph to be sampled from.",
                        "start_node": "int, optional - The start node."
                    },
                    "Return types": {
                        "new_graph": "NetworkX or NetworKit graph - The graph of sampled nodes."
                    }
                }
            }
        }
    },
    {
        "Section_id": "RandomWalkWithRestartSampler",
        "Description": "An implementation of node sampling by random walks with restart. The process is a discrete random walker on nodes which teleports back to the staring node with a fixed probability. This results in a connected subsample from the original input graph. For details about the algorithm see this paper.",
        "Field List": {
            "Parameters": {
                "number_of_nodes": "int - Number of nodes. Default is 100.",
                "seed": "int - Random seed. Default is 42.",
                "p": "float - Restart probability. Default is 0.1."
            },
            "Methods": {
                "sample": {
                    "Description": "Sampling nodes with a single random walk that restarts.",
                    "Arg types": {
                        "graph": "NetworkX or NetworKit graph - The graph to be sampled from.",
                        "start_node": "int, optional - The start node."
                    },
                    "Return types": {
                        "new_graph": "NetworkX or NetworKit graph - The graph of sampled nodes."
                    }
                }
            }
        }
    },
    {
        "Section_id": "MetropolisHastingsRandomWalkSampler",
        "Description": "An implementation of node sampling by Metropolis Hastings random walks. The random walker has a probabilistic acceptance condition for adding new nodes to the sampled node set. This constraint can be parametrized by the rejection constraint exponent. The sampled graph is always connected. For details about the algorithm see this paper.",
        "Field List": {
            "Parameters": {
                "number_of_nodes": "int - Number of nodes. Default is 100.",
                "seed": "int - Random seed. Default is 42.",
                "alpha": "float - Rejection constraint exponent. Default is 1.0."
            },
            "Methods": {
                "sample": {
                    "Description": "Sampling nodes with a Metropolis Hastings single random walk.",
                    "Arg types": {
                        "graph": "NetworkX or NetworKit graph - The graph to be sampled from.",
                        "start_node": "int, optional - The start node."
                    },
                    "Return types": {
                        "new_graph": "NetworkX or NetworKit graph - The graph of sampled edges."
                    }
                }
            }
        }
    },
    {
        "Section_id": "SnowBallSampler",
        "Description": "An implementation of node sampling by snow ball search. Starting from a source node the algorithm places a fixed number of neighbors in a queue of nodes to explore. The expansion goes on until the target number of sampled vertices is reached. For details about the algorithm see this paper.",
        "Field List": {
            "Parameters": {
                "number_of_nodes": "int - Number of nodes. Default is 100.",
                "k": "int - Bound on degree. Default is 50.",
                "seed": "int - Random seed. Default is 42."
            },
            "Methods": {
                "sample": {
                    "Description": "Sampling a graph with randomized snow ball sampling.",
                    "Arg types": {
                        "graph": "NetworkX or NetworKit graph - The graph to be sampled from.",
                        "start_node": "int, optional - The start node."
                    },
                    "Return types": {
                        "new_graph": "NetworkX or NetworKit graph - The graph of sampled nodes."
                    }
                }
            }
        }
    },
    {
        "Section_id": "CirculatedNeighborsRandomWalkSampler",
        "Description": "An implementation of circulated neighbor random walk sampling. The process simulates a random walker. Vertices of a neighbourhood are randomly reshuffled after all of them is sampled from the vicinity of a node. This way the walker can escape closely knit communities. For details about the algorithm see this paper.",
        "Field List": {
            "Parameters": {
                "number_of_nodes": "int - Number of sampled nodes. Default is 100.",
                "seed": "int - Random seed. Default is 42."
            },
            "Methods": {
                "sample": {
                    "Description": "Sampling nodes iteratively with a circulated neighbor random walk sampler.",
                    "Arg types": {
                        "graph": "NetworkX or NetworKit graph - The graph to be sampled from.",
                        "start_node": "int, optional - The start node."
                    },
                    "Return types": {
                        "new_graph": "NetworkX or NetworKit graph - The graph of sampled nodes."
                    }
                }
            }
        }
    },
    {
        "Section_id": "BreadthFirstSearchSampler",
        "Description": "An implementation of node sampling by breadth first search. The starting node is selected randomly and neighbors are added to the queue by shuffling them randomly.",
        "Field List": {
            "Parameters": {
                "number_of_nodes": "int - Number of nodes. Default is 100.",
                "seed": "int - Random seed. Default is 42."
            },
            "Methods": {
                "sample": {
                    "Description": "Sampling a graph with randomized breadth first search.",
                    "Arg types": {
                        "graph": "NetworkX or NetworKit graph - The graph to be sampled from.",
                        "start_node": "int, optional - The start node."
                    },
                    "Return types": {
                        "new_graph": "NetworkX or NetworKit graph - The graph of sampled nodes."
                    }
                }
            }
        }
    },
    {
        "Section_id": "DepthFirstSearchSampler",
        "Description": "An implementation of node sampling by depth first search. The starting node is selected randomly and neighbors are added to the last in first out queue by shuffling them randomly.",
        "Field List": {
            "Parameters": {
                "number_of_nodes": "int - Number of nodes. Default is 100.",
                "seed": "int - Random seed. Default is 42."
            },
            "Methods": {
                "sample": {
                    "Description": "Sampling a graph with randomized depth first search.",
                    "Arg types": {
                        "graph": "NetworkX or NetworKit graph - The graph to be sampled from.",
                        "start_node": "int, optional - The start node."
                    },
                    "Return types": {
                        "new_graph": "NetworkX or NetworKit graph - The graph of sampled nodes."
                    }
                }
            }
        }
    },
    {
        "Section_id": "RandomWalkWithJumpSampler",
        "Description": "An implementation of node sampling by random walks with jumps. The process is a discrete random walker on nodes which teleports back to a random node with a fixed probability. This might result in a disconnected subsample from the original input graph. For details about the algorithm see this paper.",
        "Field List": {
            "Parameters": {
                "number_of_nodes": "int - Number of nodes. Default is 100.",
                "seed": "int - Random seed. Default is 42.",
                "p": "float - Jump (teleport) probability. Default is 0.1."
            },
            "Methods": {
                "sample": {
                    "Description": "Sampling nodes with a single random walk jumps.",
                    "Arg types": {
                        "graph": "NetworkX or NetworKit graph - The graph to be sampled from.",
                        "start_node": "int, optional - The start node."
                    },
                    "Return types": {
                        "new_graph": "NetworkX or NetworKit graph - The graph of sampled nodes."
                    }
                }
            }
        }
    },
    {
        "Section_id": "CommunityStructureExpansionSampler",
        "Description": "An implementation of community structure preserving expansion sampling. Starting with a random source node the procedure chooses a node which is connected to the already sampled nodes. This node is the one with the largest community expansion score. The extracted subgraph is always connected. For details about the algorithm see this paper.",
        "Field List": {
            "Parameters": {
                "number_of_nodes": "int - Number of sampled nodes. Default is 100.",
                "seed": "int - Random seed. Default is 42."
            },
            "Methods": {
                "sample": {
                    "Description": "Sampling nodes iteratively with a community structure expansion sampler.",
                    "Arg types": {
                        "graph": "NetworkX or NetworKit graph - The graph to be sampled from.",
                        "start_node": "int, optional - The start node."
                    },
                    "Return types": {
                        "new_graph": "NetworkX or NetworKit graph - The graph of sampled nodes."
                    }
                }
            }
        }
    },
    {
        "Section_id": "FrontierSampler",
        "Description": "An implementation of frontier sampling. A fixed number of random walkers traverses the graph and the walkers which make a step are selected randomly. The procedure might result in a disconnected graph as the walks might never connect with each other. For details about the algorithm see this paper.",
        "Field List": {
            "Parameters": {
                "number_of_seeds": "int - Number of seed nodes. Default is 10.",
                "number_of_nodes": "int - Number of nodes to sample. Default is 100.",
                "seed": "int - Random seed. Default is 42."
            },
            "Methods": {
                "sample": {
                    "Description": "Sampling nodes and edges with a frontier sampler.",
                    "Arg types": {
                        "graph": "NetworkX graph - The graph to be sampled from."
                    },
                    "Return types": {
                        "new_graph": "NetworkX graph - The graph of sampled nodes."
                    }
                }
            }
        }
    },
    {
        "Section_id": "RandomNodeNeighborSampler",
        "Description": "An implementation of random node-neighbor sampling. The process uniformly samples a fixed number of nodes first. Later it induces the neighboring nodes as the node set and the edges between all of the nodes. For details about the algorithm see this paper.",
        "Field List": {
            "Parameters": {
                "number_of_nodes": "int - Number of nodes. Default is 100.",
                "seed": "int - Random seed. Default is 42."
            },
            "Methods": {
                "sample": {
                    "Description": "Sampling nodes randomly.",
                    "Arg types": {
                        "graph": "NetworkX or NetworKit graph - The graph to be sampled from."
                    },
                    "Return types": {
                        "new_graph": "NetworkX or NetworKit graph - The graph of sampled nodes."
                    }
                }
            }
        }
    },
    {
        "Section_id": "ShortestPathSampler",
        "Description": "An implementation of shortest path sampling. The procedure samples pairs of nodes and chooses a random shortest path between them. Vertices and edges on this shortest path are added to the induces subgraph that is extracted. For details about the algorithm see this paper.",
        "Field List": {
            "Parameters": {
                "number_of_nodes": "int - Number of nodes to sample. Default is 100.",
                "seed": "int - Random seed. Default is 42."
            },
            "Methods": {
                "sample": {
                    "Description": "Sampling with a shortest path sampler.",
                    "Arg types": {
                        "graph": "NetworkX or NetworKit graph - The graph to be sampled from."
                    },
                    "Return types": {
                        "new_graph": "NetworkX or NetworKit graph - The graph of sampled nodes."
                    }
                }
            }
        }
    }
]